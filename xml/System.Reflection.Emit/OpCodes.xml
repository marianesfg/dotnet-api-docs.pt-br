<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="OpCodes.xml" source-language="en-US" target-language="pt-BR">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-15c36f0" tool-company="Microsoft" />
      <xliffext:skl_file_name xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">02cd5861-7ce2-4a82-b358-31f8435a0ac5a136bc8fb48fe619f1be21928afbfcd9094d7463.skl</xliffext:skl_file_name>
      <xliffext:version xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">1.2</xliffext:version>
      <xliffext:ms.openlocfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">a136bc8fb48fe619f1be21928afbfcd9094d7463</xliffext:ms.openlocfilehash>
      <xliffext:ms.sourcegitcommit xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b</xliffext:ms.sourcegitcommit>
      <xliffext:ms.lasthandoff xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">04/03/2018</xliffext:ms.lasthandoff>
      <xliffext:moniker_ids xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">netcore-1.0,netcore-1.1,netcore-2.0,netcore-2.1,netframework-4.5.1,netframework-4.5.2,netframework-4.5,netframework-4.6.1,netframework-4.6.2,netframework-4.6,netframework-4.7.1,netframework-4.7,netstandard-1.0,netstandard-1.1,netstandard-1.2,netstandard-1.3,netstandard-1.4,netstandard-1.6,netstandard-2.0,xamarinandroid-7.1,xamarinios-10.8,xamarinmac-3.0</xliffext:moniker_ids>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve" uid="T:System.Reflection.Emit.OpCodes">
          <source>Provides field representations of the Microsoft Intermediate Language (MSIL) instructions for emission by the <ph id="ph1">&lt;see cref="T:System.Reflection.Emit.ILGenerator" /&gt;</ph> class members (such as <ph id="ph2">&lt;see cref="M:System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)" /&gt;</ph>).</source>
          <target state="translated">Fornece representações de campo das instruções da MSIL (Microsoft intermediate language) para emissão por membros da classe <ph id="ph1">&lt;see cref="T:System.Reflection.Emit.ILGenerator" /&gt;</ph> (como <ph id="ph2">&lt;see cref="M:System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)" /&gt;</ph>).</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.OpCodes">
          <source>For a detailed description of the member opcodes, see the Common Language Infrastructure (CLI) documentation, especially "Partition III: CIL Instruction Set" and "Partition II: Metadata Definition and Semantics".</source>
          <target state="translated">Para obter uma descrição detalhada do que a operação de membro, consulte a documentação de infra-estrutura de linguagem comum (CLI), especialmente "Partição III: conjunto de instruções CIL" e "Partição II: metadados definição e semântica".</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.OpCodes">
          <source>The documentation is available online; see <bpt id="p1">[</bpt>ECMA C# and Common Language Infrastructure Standards<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=99212)</ept> on MSDN and <bpt id="p2">[</bpt>Standard ECMA-335 - Common Language Infrastructure (CLI)<ept id="p2">](http://go.microsoft.com/fwlink/?LinkID=65552)</ept> on the Ecma International Web site.</source>
          <target state="translated">A documentação está disponível online; confira <bpt id="p1">[</bpt>ECMA C# and Common Language Infrastructure Standards<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=99212)</ept>, no MSDN, e <bpt id="p2">[</bpt>Standard ECMA-335 - Common Language Infrastructure (CLI)<ept id="p2">](http://go.microsoft.com/fwlink/?LinkID=65552)</ept>, no site internacional da Ecma.</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.OpCodes">
          <source>The following example demonstrates the construction of a dynamic method using <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator&gt;</ph> to emit <ph id="ph2">`OpCodes`</ph> into a <ph id="ph3">&lt;xref:System.Reflection.Emit.MethodBuilder&gt;</ph>.</source>
          <target state="translated">O exemplo a seguir demonstra a construção de um método dinâmico usando <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator&gt;</ph> emitir <ph id="ph2">`OpCodes`</ph> em um <ph id="ph3">&lt;xref:System.Reflection.Emit.MethodBuilder&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Add">
          <source>Adds two values and pushes the result onto the evaluation stack.</source>
          <target state="translated">Adiciona dois valores e envia o resultado para a pilha de avaliação.</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">A tabela a seguir lista as instruções hexadecimal e formato de assembly do Microsoft Intermediate Language (MSIL), junto com um resumo breve de referência:</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add">
          <source>Format</source>
          <target state="translated">Formatar</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add">
          <source>Assembly Format</source>
          <target state="translated">Formato de assembly</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add">
          <source>Description</source>
          <target state="translated">Descrição</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add">
          <source>58</source>
          <target state="translated">58</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add">
          <source>add</source>
          <target state="translated">adicionar</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add">
          <source>Adds two numeric values, returning a new numeric value.</source>
          <target state="translated">Adiciona dois valores numéricos, retornando um novo valor numérico.</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">O comportamento de transição de pilha, em ordem sequencial, é:</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add">
          <source><ph id="ph1">`value1`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value1`</ph> é inserido na pilha.</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add">
          <source><ph id="ph1">`value2`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value2`</ph> é inserido na pilha.</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add">
          <source><ph id="ph1">`value2`</ph> and <ph id="ph2">`value1`</ph> are popped from the stack; <ph id="ph3">`value1`</ph> is added to <ph id="ph4">`value2`</ph>.</source>
          <target state="translated"><ph id="ph1">`value2`</ph> e <ph id="ph2">`value1`</ph> são disparados da pilha; <ph id="ph3">`value1`</ph> é adicionado ao <ph id="ph4">`value2`</ph>.</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add">
          <source>The result is pushed onto the stack.</source>
          <target state="translated">O resultado é inserido na pilha.</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add">
          <source>Overflow is not detected for integer operations (for proper overflow handling, see <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Add_Ovf&gt;</ph>).</source>
          <target state="translated">Estouro não é detectado para operações de inteiro (para manipulação de estouro adequada, consulte <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Add_Ovf&gt;</ph>).</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add">
          <source>Integer addition wraps, rather than saturates.</source>
          <target state="translated">Adição de inteiro é quebrada, em vez de esteja saturado.</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add">
          <source>For example, assuming 8-bit integers where <ph id="ph1">`value1`</ph> is set to 255 and <ph id="ph2">`value2`</ph> is set to 1, the wrapped result is 0 rather than 256.</source>
          <target state="translated">Por exemplo, supondo que inteiros de 8 bits onde <ph id="ph1">`value1`</ph> é definido como 255 e <ph id="ph2">`value2`</ph> é definido como 1, o resultado encapsulado é 0, em vez de 256.</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add">
          <source>Floating-point overflow returns <ph id="ph1">`+inf`</ph> (<ph id="ph2">`PositiveInfinity`</ph>) or <ph id="ph3">`-inf`</ph> (<ph id="ph4">`NegativeInfinity`</ph>).</source>
          <target state="translated">Estouro de ponto flutuante retorna <ph id="ph1">`+inf`</ph> (<ph id="ph2">`PositiveInfinity`</ph>) ou <ph id="ph3">`-inf`</ph> (<ph id="ph4">`NegativeInfinity`</ph>).</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add">
          <source>The acceptable operand types and their corresponding result data type are listed in the table below.</source>
          <target state="translated">Os tipos de operando aceitável e seu tipo de dados de resultado correspondente são listados na tabela a seguir.</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add">
          <source>If there is no entry for a particular type combination (for example, <ph id="ph1">`int32`</ph> and <ph id="ph2">`float`</ph>; <ph id="ph3">`int32`</ph> and <ph id="ph4">`int64`</ph>), it is an invalid Microsoft Intermediate Language (MSIL) and generates an error.</source>
          <target state="translated">Se não houver nenhuma entrada para uma combinação de tipo específico (por exemplo, <ph id="ph1">`int32`</ph> e <ph id="ph2">`float`</ph>; <ph id="ph3">`int32`</ph> e <ph id="ph4">`int64`</ph>), ele é um inválido idioma MSIL (Microsoft Intermediate) e gera um erro.</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add">
          <source>operand</source>
          <target state="translated">operando</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add">
          <source>value1 type</source>
          <target state="translated">tipo de value1</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add">
          <source>value2 type</source>
          <target state="translated">tipo de value2</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add">
          <source>result type</source>
          <target state="translated">tipo de resultado</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add">
          <source>add</source>
          <target state="translated">adicionar</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add">
          <source>add</source>
          <target state="translated">adicionar</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add">
          <source>add</source>
          <target state="translated">adicionar</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add">
          <source>add</source>
          <target state="translated">adicionar</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add">
          <source>add</source>
          <target state="translated">adicionar</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add">
          <source>add</source>
          <target state="translated">adicionar</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add">
          <source>add</source>
          <target state="translated">adicionar</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add">
          <source>add</source>
          <target state="translated">adicionar</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add">
          <source>add</source>
          <target state="translated">adicionar</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add">
          <source>add</source>
          <target state="translated">adicionar</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add">
          <source>add</source>
          <target state="translated">adicionar</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add">
          <source>add</source>
          <target state="translated">adicionar</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add">
          <source>add</source>
          <target state="translated">adicionar</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add">
          <source>add</source>
          <target state="translated">adicionar</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`add`</ph> opcode:</source>
          <target state="translated">O seguinte <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> sobrecarga de método pode usar o <ph id="ph2">`add`</ph> opcode:</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Add_Ovf">
          <source>Adds two integers, performs an overflow check, and pushes the result onto the evaluation stack.</source>
          <target state="translated">Adiciona dois números inteiros, executa uma verificação de estouro e efetua o push do resultado para a pilha de avaliação.</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add_Ovf">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">A tabela a seguir lista as instruções hexadecimal e formato de assembly do Microsoft Intermediate Language (MSIL), junto com um resumo breve de referência:</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add_Ovf">
          <source>Format</source>
          <target state="translated">Formatar</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add_Ovf">
          <source>Assembly Format</source>
          <target state="translated">Formato de assembly</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add_Ovf">
          <source>Description</source>
          <target state="translated">Descrição</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add_Ovf">
          <source>D6</source>
          <target state="translated">D6</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add_Ovf">
          <source>add.ovf</source>
          <target state="translated">add.ovf</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add_Ovf">
          <source>Adds two signed integer values with an overflow check.</source>
          <target state="translated">Adiciona dois valores de inteiro assinado com uma verificação de estouro.</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add_Ovf">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">O comportamento de transição de pilha, em ordem sequencial, é:</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add_Ovf">
          <source><ph id="ph1">`value1`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value1`</ph> é inserido na pilha.</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add_Ovf">
          <source><ph id="ph1">`value2`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value2`</ph> é inserido na pilha.</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add_Ovf">
          <source><ph id="ph1">`value2`</ph> and <ph id="ph2">`value1`</ph> are popped from the stack; <ph id="ph3">`value1`</ph> is added to <ph id="ph4">`value2`</ph> with a check for overflow.</source>
          <target state="translated"><ph id="ph1">`value2`</ph> e <ph id="ph2">`value1`</ph> são disparados da pilha; <ph id="ph3">`value1`</ph> é adicionado ao <ph id="ph4">`value2`</ph> com uma verificação de estouro.</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add_Ovf">
          <source>The result is pushed onto the stack.</source>
          <target state="translated">O resultado é inserido na pilha.</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add_Ovf">
          <source><ph id="ph1">&lt;xref:System.OverflowException&gt;</ph> is thrown if the result is not represented in the result type.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.OverflowException&gt;</ph> é gerada se o resultado não é representado no tipo de resultado.</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add_Ovf">
          <source>You can perform this operation on signed integers.</source>
          <target state="translated">Você pode executar esta operação em inteiros com sinal.</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add_Ovf">
          <source>For floating-point values, use <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Add&gt;</ph>.</source>
          <target state="translated">Para valores de ponto flutuantes, use <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Add&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add_Ovf">
          <source>The acceptable operand types and their corresponding result data type are listed in the table below.</source>
          <target state="translated">Os tipos de operando aceitável e seu tipo de dados de resultado correspondente são listados na tabela a seguir.</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add_Ovf">
          <source>If there is no entry for a particular type combination (for example, <ph id="ph1">`int32`</ph> and <ph id="ph2">`float`</ph>; <ph id="ph3">`int32`</ph> and <ph id="ph4">`int64`</ph>), it is an invalid Microsoft Intermediate Language (MSIL) instruction and generates an error.</source>
          <target state="translated">Se não houver nenhuma entrada para uma combinação de tipo específico (por exemplo, <ph id="ph1">`int32`</ph> e <ph id="ph2">`float`</ph>; <ph id="ph3">`int32`</ph> e <ph id="ph4">`int64`</ph>), ele é uma instrução inválida do Microsoft Intermediate Language (MSIL) e gera um erro.</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add_Ovf">
          <source>operand</source>
          <target state="translated">operando</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add_Ovf">
          <source>value1 type</source>
          <target state="translated">tipo de value1</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add_Ovf">
          <source>value2 type</source>
          <target state="translated">tipo de value2</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add_Ovf">
          <source>result type</source>
          <target state="translated">tipo de resultado</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add_Ovf">
          <source>add</source>
          <target state="translated">adicionar</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add_Ovf">
          <source>add</source>
          <target state="translated">adicionar</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add_Ovf">
          <source>add</source>
          <target state="translated">adicionar</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add_Ovf">
          <source>add</source>
          <target state="translated">adicionar</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add_Ovf">
          <source>add</source>
          <target state="translated">adicionar</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add_Ovf">
          <source>add</source>
          <target state="translated">adicionar</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add_Ovf">
          <source>add</source>
          <target state="translated">adicionar</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add_Ovf">
          <source>add</source>
          <target state="translated">adicionar</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add_Ovf">
          <source>add</source>
          <target state="translated">adicionar</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add_Ovf">
          <source>add</source>
          <target state="translated">adicionar</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add_Ovf">
          <source>add</source>
          <target state="translated">adicionar</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add_Ovf">
          <source>add</source>
          <target state="translated">adicionar</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add_Ovf">
          <source>add</source>
          <target state="translated">adicionar</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add_Ovf">
          <source>add</source>
          <target state="translated">adicionar</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add_Ovf">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`add.ovf`</ph> opcode:</source>
          <target state="translated">O seguinte <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> sobrecarga de método pode usar o <ph id="ph2">`add.ovf`</ph> opcode:</target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add_Ovf">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Add_Ovf_Un">
          <source>Adds two unsigned integer values, performs an overflow check, and pushes the result onto the evaluation stack.</source>
          <target state="translated">Adiciona dois valores de inteiro sem sinal, executa uma verificação de estouro e efetua o push do resultado para a pilha de avaliação.</target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add_Ovf_Un">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">A tabela a seguir lista as instruções hexadecimal e formato de assembly do Microsoft Intermediate Language (MSIL), junto com um resumo breve de referência:</target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add_Ovf_Un">
          <source>Format</source>
          <target state="translated">Formatar</target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add_Ovf_Un">
          <source>Assembly Format</source>
          <target state="translated">Formato de assembly</target>       </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add_Ovf_Un">
          <source>Description</source>
          <target state="translated">Descrição</target>       </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add_Ovf_Un">
          <source>D7</source>
          <target state="translated">D7</target>       </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add_Ovf_Un">
          <source>add.ovf.un</source>
          <target state="translated">add.ovf.un</target>       </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add_Ovf_Un">
          <source>Adds two unsigned integer values with an overflow check.</source>
          <target state="translated">Adiciona dois valores inteiros sem sinal com uma verificação de estouro.</target>       </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add_Ovf_Un">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">O comportamento de transição de pilha, em ordem sequencial, é:</target>       </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add_Ovf_Un">
          <source><ph id="ph1">`value1`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value1`</ph> é inserido na pilha.</target>       </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add_Ovf_Un">
          <source><ph id="ph1">`value2`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value2`</ph> é inserido na pilha.</target>       </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add_Ovf_Un">
          <source><ph id="ph1">`value2`</ph> and <ph id="ph2">`value1`</ph> are popped from the stack; <ph id="ph3">`value1`</ph> is added to <ph id="ph4">`value2`</ph> with a check for overflow.</source>
          <target state="translated"><ph id="ph1">`value2`</ph> e <ph id="ph2">`value1`</ph> são disparados da pilha; <ph id="ph3">`value1`</ph> é adicionado ao <ph id="ph4">`value2`</ph> com uma verificação de estouro.</target>       </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add_Ovf_Un">
          <source>The result is pushed onto the stack.</source>
          <target state="translated">O resultado é inserido na pilha.</target>       </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add_Ovf_Un">
          <source><ph id="ph1">&lt;xref:System.OverflowException&gt;</ph> is thrown if the result is not represented in the result type.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.OverflowException&gt;</ph> é gerada se o resultado não é representado no tipo de resultado.</target>       </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add_Ovf_Un">
          <source>You can perform this operation on signed integers.</source>
          <target state="translated">Você pode executar esta operação em inteiros com sinal.</target>       </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add_Ovf_Un">
          <source>For floating-point values, use <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Add&gt;</ph>.</source>
          <target state="translated">Para valores de ponto flutuantes, use <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Add&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add_Ovf_Un">
          <source>The acceptable operand types and their corresponding result data type are listed in the table below.</source>
          <target state="translated">Os tipos de operando aceitável e seu tipo de dados de resultado correspondente são listados na tabela a seguir.</target>       </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add_Ovf_Un">
          <source>If there is no entry for a particular type combination (for example, <ph id="ph1">`int32`</ph> and <ph id="ph2">`float`</ph>; <ph id="ph3">`int32`</ph> and <ph id="ph4">`int64`</ph>), it is an invalid Microsoft Intermediate Language (MSIL) instruction and generates an error.</source>
          <target state="translated">Se não houver nenhuma entrada para uma combinação de tipo específico (por exemplo, <ph id="ph1">`int32`</ph> e <ph id="ph2">`float`</ph>; <ph id="ph3">`int32`</ph> e <ph id="ph4">`int64`</ph>), ele é uma instrução inválida do Microsoft Intermediate Language (MSIL) e gera um erro.</target>       </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add_Ovf_Un">
          <source>operand</source>
          <target state="translated">operando</target>       </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add_Ovf_Un">
          <source>value1 type</source>
          <target state="translated">tipo de value1</target>       </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add_Ovf_Un">
          <source>value2 type</source>
          <target state="translated">tipo de value2</target>       </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add_Ovf_Un">
          <source>result type</source>
          <target state="translated">tipo de resultado</target>       </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add_Ovf_Un">
          <source>add</source>
          <target state="translated">adicionar</target>       </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add_Ovf_Un">
          <source>add</source>
          <target state="translated">adicionar</target>       </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add_Ovf_Un">
          <source>add</source>
          <target state="translated">adicionar</target>       </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add_Ovf_Un">
          <source>add</source>
          <target state="translated">adicionar</target>       </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add_Ovf_Un">
          <source>add</source>
          <target state="translated">adicionar</target>       </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add_Ovf_Un">
          <source>add</source>
          <target state="translated">adicionar</target>       </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add_Ovf_Un">
          <source>add</source>
          <target state="translated">adicionar</target>       </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add_Ovf_Un">
          <source>add</source>
          <target state="translated">adicionar</target>       </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add_Ovf_Un">
          <source>add</source>
          <target state="translated">adicionar</target>       </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add_Ovf_Un">
          <source>add</source>
          <target state="translated">adicionar</target>       </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add_Ovf_Un">
          <source>add</source>
          <target state="translated">adicionar</target>       </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add_Ovf_Un">
          <source>add</source>
          <target state="translated">adicionar</target>       </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add_Ovf_Un">
          <source>add</source>
          <target state="translated">adicionar</target>       </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add_Ovf_Un">
          <source>add</source>
          <target state="translated">adicionar</target>       </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add_Ovf_Un">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`add.ovf.un`</ph> opcode:</source>
          <target state="translated">O seguinte <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> sobrecarga de método pode usar o <ph id="ph2">`add.ovf.un`</ph> opcode:</target>       </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add_Ovf_Un">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.And">
          <source>Computes the bitwise AND of two values and pushes the result onto the evaluation stack.</source>
          <target state="translated">Calcula o AND bit a bit de dois valores e efetua o push do resultado para a pilha de avaliação.</target>       </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.And">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">A tabela a seguir lista as instruções hexadecimal e formato de assembly do Microsoft Intermediate Language (MSIL), junto com um resumo breve de referência:</target>       </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.And">
          <source>Format</source>
          <target state="translated">Formatar</target>       </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.And">
          <source>Instruction</source>
          <target state="translated">Instrução</target>       </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.And">
          <source>Description</source>
          <target state="translated">Descrição</target>       </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.And">
          <source>5F</source>
          <target state="translated">5F</target>       </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.And">
          <source>and</source>
          <target state="translated">e</target>       </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.And">
          <source>Determines the bitwise AND of two integer values.</source>
          <target state="translated">Determina o AND bit a bit de dois valores inteiros.</target>       </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.And">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">O comportamento de transição de pilha, em ordem sequencial, é:</target>       </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.And">
          <source><ph id="ph1">`value1`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value1`</ph> é inserido na pilha.</target>       </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.And">
          <source><ph id="ph1">`value2`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value2`</ph> é inserido na pilha.</target>       </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.And">
          <source><ph id="ph1">`value1`</ph> and <ph id="ph2">`value2`</ph> are popped from the stack; the bitwise AND of the two values is computed.</source>
          <target state="translated"><ph id="ph1">`value1`</ph> e <ph id="ph2">`value2`</ph> são disparados da pilha; AND bit a bit de dois valores é computado.</target>       </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.And">
          <source>The result is pushed onto the stack.</source>
          <target state="translated">O resultado é inserido na pilha.</target>       </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.And">
          <source>The <ph id="ph1">`and`</ph> instruction computes the bitwise AND of the top two values on the stack and leaves the result on the stack.</source>
          <target state="translated">O <ph id="ph1">`and`</ph> instrução calcula o AND bit a bit dos valores de duas primeiras na pilha e deixa o resultado na pilha.</target>       </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.And">
          <source><ph id="ph1">`And`</ph> is an integer-specific operation.</source>
          <target state="translated"><ph id="ph1">`And`</ph> é uma operação de inteiro específico.</target>       </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.And">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`and`</ph> opcode:</source>
          <target state="translated">O seguinte <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> sobrecarga de método pode usar o <ph id="ph2">`and`</ph> opcode:</target>       </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.And">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Arglist">
          <source>Returns an unmanaged pointer to the argument list of the current method.</source>
          <target state="translated">Retorna um ponteiro não gerenciado para a lista de argumentos do método atual.</target>       </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Arglist">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">A tabela a seguir lista as instruções hexadecimal e formato de assembly do Microsoft Intermediate Language (MSIL), junto com um resumo breve de referência:</target>       </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Arglist">
          <source>Format</source>
          <target state="translated">Formatar</target>       </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Arglist">
          <source>Assembly Format</source>
          <target state="translated">Formato de assembly</target>       </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Arglist">
          <source>Description</source>
          <target state="translated">Descrição</target>       </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Arglist">
          <source>FE 00</source>
          <target state="translated">FE 00</target>       </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Arglist">
          <source>arglist</source>
          <target state="translated">arglist</target>       </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Arglist">
          <source>Returns an argument list handle for the current method.</source>
          <target state="translated">Retorna um identificador de lista de argumento para o método atual.</target>       </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Arglist">
          <source>No evaluation stack behaviors are performed by this operation.</source>
          <target state="translated">Não há comportamentos de pilha de avaliação são executados por essa operação.</target>       </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Arglist">
          <source>The <ph id="ph1">`arglist`</ph> instruction returns an opaque handle (an unmanaged pointer, of type <ph id="ph2">`native int`</ph>) that represents the argument list of the current method.</source>
          <target state="translated">O <ph id="ph1">`arglist`</ph> instrução retorna um identificador opaco (um ponteiro não gerenciado, do tipo <ph id="ph2">`native int`</ph>) que representa a lista de argumento do método atual.</target>       </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Arglist">
          <source>This handle is valid only during the lifetime of the current method.</source>
          <target state="translated">Esse identificador é válido somente durante o tempo de vida do método atual.</target>       </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Arglist">
          <source>You can, however, pass the handle to other methods as long as the current method is on the thread of control.</source>
          <target state="translated">No entanto, você pode, passar o identificador de outros métodos de como o método atual está no thread de controle.</target>       </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Arglist">
          <source>You can only execute the <ph id="ph1">`arglist`</ph> instruction within a method that takes a variable number of arguments.</source>
          <target state="translated">Você pode executar somente a <ph id="ph1">`arglist`</ph> instrução dentro de um método que usa um número variável de argumentos.</target>       </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Arglist">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`arglist`</ph> opcode:</source>
          <target state="translated">O seguinte <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> sobrecarga de método pode usar o <ph id="ph2">`arglist`</ph> opcode:</target>       </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Arglist">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Beq">
          <source>Transfers control to a target instruction if two values are equal.</source>
          <target state="translated">Transfere o controle para uma instrução de destino se dois valores são iguais.</target>       </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Beq">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">A tabela a seguir lista as instruções hexadecimal e formato de assembly do Microsoft Intermediate Language (MSIL), junto com um resumo breve de referência:</target>       </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Beq">
          <source>Format</source>
          <target state="translated">Formatar</target>       </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Beq">
          <source>Assembly Format</source>
          <target state="translated">Formato de assembly</target>       </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Beq">
          <source>Description</source>
          <target state="translated">Descrição</target>       </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Beq">
          <source>3B &lt; <ph id="ph1">`int32`</ph><ph id="ph2"> &gt;</ph></source>
          <target state="translated">3B &lt; <ph id="ph1">`int32`</ph><ph id="ph2"> &gt;</ph></target>       </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Beq">
          <source>beq <ph id="ph1">`target`</ph></source>
          <target state="translated">beq <ph id="ph1">`target`</ph></target>       </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Beq">
          <source>Branch to the target instruction at offset <ph id="ph1">`target`</ph> if the two values are equal.</source>
          <target state="translated">Ramificação a instrução de destino no deslocamento <ph id="ph1">`target`</ph> se os dois valores são iguais.</target>       </trans-unit>
        <trans-unit id="260" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Beq">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">O comportamento de transição de pilha, em ordem sequencial, é:</target>       </trans-unit>
        <trans-unit id="261" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Beq">
          <source><ph id="ph1">`value1`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value1`</ph> é inserido na pilha.</target>       </trans-unit>
        <trans-unit id="262" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Beq">
          <source><ph id="ph1">`value2`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value2`</ph> é inserido na pilha.</target>       </trans-unit>
        <trans-unit id="263" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Beq">
          <source><ph id="ph1">`value2`</ph> and <ph id="ph2">`value1`</ph> are popped from the stack; if <ph id="ph3">`value1`</ph> is equal to <ph id="ph4">`value2`</ph>, the branch operation is performed.</source>
          <target state="translated"><ph id="ph1">`value2`</ph> e <ph id="ph2">`value1`</ph> são disparados da pilha; se <ph id="ph3">`value1`</ph> é igual a <ph id="ph4">`value2`</ph>, a operação de ramificação é executada.</target>       </trans-unit>
        <trans-unit id="264" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Beq">
          <source>The <ph id="ph1">`beq`</ph> instruction transfers control to the specified target instruction if <ph id="ph2">`value1`</ph> is equal to <ph id="ph3">`value2`</ph>.</source>
          <target state="translated">O <ph id="ph1">`beq`</ph> instrução transfere o controle para a instrução de destino especificado se <ph id="ph2">`value1`</ph> é igual a <ph id="ph3">`value2`</ph>.</target>       </trans-unit>
        <trans-unit id="265" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Beq">
          <source>The effect is the same as performing a <ph id="ph1">`ceq`</ph> instruction followed by a <ph id="ph2">`brtrue`</ph> branch to the specific target instruction.</source>
          <target state="translated">O efeito é o mesmo que executar uma <ph id="ph1">`ceq`</ph> instrução seguida por um <ph id="ph2">`brtrue`</ph> ramificação para a instrução de destino específico.</target>       </trans-unit>
        <trans-unit id="266" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Beq">
          <source>The target instruction is represented as a 4-byte signed offset from the beginning of the instruction following the current instruction.</source>
          <target state="translated">A instrução de destino é representada como um deslocamento assinado de 4 bytes do início da instrução após a instrução atual.</target>       </trans-unit>
        <trans-unit id="267" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Beq">
          <source>The acceptable operand types are encapsulated below:</source>
          <target state="translated">Os tipos de operando aceitáveis são encapsulados abaixo:</target>       </trans-unit>
        <trans-unit id="268" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Beq">
          <source>If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</source>
          <target state="translated">Se a instrução de destino tem um ou mais códigos de prefixo, o controle só pode ser transferido para o primeiro desses prefixos.</target>       </trans-unit>
        <trans-unit id="269" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Beq">
          <source>Control transfers into and out of <ph id="ph1">`try`</ph>, <ph id="ph2">`catch`</ph>, <ph id="ph3">`filter`</ph>, and <ph id="ph4">`finally`</ph> blocks cannot be performed by this instruction (such transfers are severely restricted and must use the <ph id="ph5">&lt;xref:System.Reflection.Emit.OpCodes.Leave&gt;</ph> instruction instead).</source>
          <target state="translated">O controle transfere dentro e fora do <ph id="ph1">`try`</ph>, <ph id="ph2">`catch`</ph>, <ph id="ph3">`filter`</ph>, e <ph id="ph4">`finally`</ph> blocos não podem ser executados por essa instrução (essas transferências são restritas severos e deve usar o <ph id="ph5">&lt;xref:System.Reflection.Emit.OpCodes.Leave&gt;</ph> instrução em vez disso).</target>       </trans-unit>
        <trans-unit id="270" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Beq">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`beq`</ph> opcode:</source>
          <target state="translated">O seguinte <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> sobrecarga de método pode usar o <ph id="ph2">`beq`</ph> opcode:</target>       </trans-unit>
        <trans-unit id="271" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Beq">
          <source>ILGenerator.Emit(OpCode, Label)</source>
          <target state="translated">ILGenerator.Emit(OpCode, Label)</target>       </trans-unit>
        <trans-unit id="272" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Beq_S">
          <source>Transfers control to a target instruction (short form) if two values are equal.</source>
          <target state="translated">Transferirá o controle para uma instrução de destino (forma abreviada) se dois valores forem iguais.</target>       </trans-unit>
        <trans-unit id="273" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Beq_S">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">A tabela a seguir lista as instruções hexadecimal e formato de assembly do Microsoft Intermediate Language (MSIL), junto com um resumo breve de referência:</target>       </trans-unit>
        <trans-unit id="274" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Beq_S">
          <source>Format</source>
          <target state="translated">Formatar</target>       </trans-unit>
        <trans-unit id="275" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Beq_S">
          <source>Assembly Format</source>
          <target state="translated">Formato de assembly</target>       </trans-unit>
        <trans-unit id="276" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Beq_S">
          <source>Description</source>
          <target state="translated">Descrição</target>       </trans-unit>
        <trans-unit id="277" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Beq_S">
          <source>2E &lt; <ph id="ph1">`int8`</ph><ph id="ph2"> &gt;</ph></source>
          <target state="translated">2E &lt; <ph id="ph1">`int8`</ph><ph id="ph2"> &gt;</ph></target>       </trans-unit>
        <trans-unit id="278" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Beq_S">
          <source>beq.s <ph id="ph1">`target`</ph></source>
          <target state="translated">beq.s <ph id="ph1">`target`</ph></target>       </trans-unit>
        <trans-unit id="279" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Beq_S">
          <source>Branch to the target instruction at offset <ph id="ph1">`target`</ph> if equal, short form</source>
          <target state="translated">Ramificação a instrução de destino no deslocamento <ph id="ph1">`target`</ph> se igual, forma abreviada</target>       </trans-unit>
        <trans-unit id="280" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Beq_S">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">O comportamento de transição de pilha, em ordem sequencial, é:</target>       </trans-unit>
        <trans-unit id="281" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Beq_S">
          <source><ph id="ph1">`value1`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value1`</ph> é inserido na pilha.</target>       </trans-unit>
        <trans-unit id="282" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Beq_S">
          <source><ph id="ph1">`value2`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value2`</ph> é inserido na pilha.</target>       </trans-unit>
        <trans-unit id="283" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Beq_S">
          <source><ph id="ph1">`value2`</ph> and <ph id="ph2">`value1`</ph> are popped from the stack; if <ph id="ph3">`value1`</ph> is equal to <ph id="ph4">`value2`</ph>, the branch operation is performed.</source>
          <target state="translated"><ph id="ph1">`value2`</ph> e <ph id="ph2">`value1`</ph> são disparados da pilha; se <ph id="ph3">`value1`</ph> é igual a <ph id="ph4">`value2`</ph>, a operação de ramificação é executada.</target>       </trans-unit>
        <trans-unit id="284" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Beq_S">
          <source>The <ph id="ph1">`beq.s`</ph> instruction transfers control to the specified target instruction if <ph id="ph2">`value1`</ph> is equal to <ph id="ph3">`value2`</ph>.</source>
          <target state="translated">O <ph id="ph1">`beq.s`</ph> instrução transfere o controle para a instrução de destino especificado se <ph id="ph2">`value1`</ph> é igual a <ph id="ph3">`value2`</ph>.</target>       </trans-unit>
        <trans-unit id="285" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Beq_S">
          <source>The effect is the same as performing a <ph id="ph1">`ceq`</ph> instruction followed by a <ph id="ph2">`brtrue`</ph> branch to the specific target instruction.</source>
          <target state="translated">O efeito é o mesmo que executar uma <ph id="ph1">`ceq`</ph> instrução seguida por um <ph id="ph2">`brtrue`</ph> ramificação para a instrução de destino específico.</target>       </trans-unit>
        <trans-unit id="286" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Beq_S">
          <source>The target instruction is represented as a 1-byte signed offset from the beginning of the instruction following the current instruction.</source>
          <target state="translated">A instrução de destino é representada como um deslocamento de 1 byte assinado desde o início da instrução após a instrução atual.</target>       </trans-unit>
        <trans-unit id="287" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Beq_S">
          <source>The acceptable operand types are encapsulated below:</source>
          <target state="translated">Os tipos de operando aceitáveis são encapsulados abaixo:</target>       </trans-unit>
        <trans-unit id="288" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Beq_S">
          <source>If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</source>
          <target state="translated">Se a instrução de destino tem um ou mais códigos de prefixo, o controle só pode ser transferido para o primeiro desses prefixos.</target>       </trans-unit>
        <trans-unit id="289" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Beq_S">
          <source>Control transfers into and out of <ph id="ph1">`try`</ph>, <ph id="ph2">`catch`</ph>, <ph id="ph3">`filter`</ph>, and <ph id="ph4">`finally`</ph> blocks cannot be performed by this instruction (such transfers are severely restricted and must use the <ph id="ph5">&lt;xref:System.Reflection.Emit.OpCodes.Leave&gt;</ph> instruction instead).</source>
          <target state="translated">O controle transfere dentro e fora do <ph id="ph1">`try`</ph>, <ph id="ph2">`catch`</ph>, <ph id="ph3">`filter`</ph>, e <ph id="ph4">`finally`</ph> blocos não podem ser executados por essa instrução (essas transferências são restritas severos e deve usar o <ph id="ph5">&lt;xref:System.Reflection.Emit.OpCodes.Leave&gt;</ph> instrução em vez disso).</target>       </trans-unit>
        <trans-unit id="290" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Beq_S">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`beq.s`</ph> opcode:</source>
          <target state="translated">O seguinte <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> sobrecarga de método pode usar o <ph id="ph2">`beq.s`</ph> opcode:</target>       </trans-unit>
        <trans-unit id="291" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Beq_S">
          <source>ILGenerator.Emit(OpCode, Label)</source>
          <target state="translated">ILGenerator.Emit(OpCode, Label)</target>       </trans-unit>
        <trans-unit id="292" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Bge">
          <source>Transfers control to a target instruction if the first value is greater than or equal to the second value.</source>
          <target state="translated">Transferirá controle para uma instrução de destino se o primeiro valor for maior ou igual ao segundo valor.</target>       </trans-unit>
        <trans-unit id="293" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bge">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">A tabela a seguir lista as instruções hexadecimal e formato de assembly do Microsoft Intermediate Language (MSIL), junto com um resumo breve de referência:</target>       </trans-unit>
        <trans-unit id="294" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bge">
          <source>Format</source>
          <target state="translated">Formatar</target>       </trans-unit>
        <trans-unit id="295" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bge">
          <source>Assembly Format</source>
          <target state="translated">Formato de assembly</target>       </trans-unit>
        <trans-unit id="296" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bge">
          <source>Description</source>
          <target state="translated">Descrição</target>       </trans-unit>
        <trans-unit id="297" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bge">
          <source>3C <ph id="ph1">`&lt;int32&gt;`</ph></source>
          <target state="translated">3C <ph id="ph1">`&lt;int32&gt;`</ph></target>       </trans-unit>
        <trans-unit id="298" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bge">
          <source>bge <ph id="ph1">`target`</ph></source>
          <target state="translated">bge <ph id="ph1">`target`</ph></target>       </trans-unit>
        <trans-unit id="299" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bge">
          <source>Branch to the target instruction at the specified offset if the first value is greater than or equal to the second value.</source>
          <target state="translated">Ramificação a instrução de destino no deslocamento especificado se o primeiro valor é maior que ou igual ao segundo valor.</target>       </trans-unit>
        <trans-unit id="300" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bge">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">O comportamento de transição de pilha, em ordem sequencial, é:</target>       </trans-unit>
        <trans-unit id="301" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bge">
          <source><ph id="ph1">`value1`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value1`</ph> é inserido na pilha.</target>       </trans-unit>
        <trans-unit id="302" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bge">
          <source><ph id="ph1">`value2`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value2`</ph> é inserido na pilha.</target>       </trans-unit>
        <trans-unit id="303" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bge">
          <source><ph id="ph1">`value2`</ph> and <ph id="ph2">`value1`</ph> are popped from the stack; if <ph id="ph3">`value1`</ph> is greater than or equal to <ph id="ph4">`value2`</ph>, the branch operation is performed.</source>
          <target state="translated"><ph id="ph1">`value2`</ph> e <ph id="ph2">`value1`</ph> são disparados da pilha; se <ph id="ph3">`value1`</ph> é maior que ou igual a <ph id="ph4">`value2`</ph>, a operação de ramificação é executada.</target>       </trans-unit>
        <trans-unit id="304" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bge">
          <source>The <ph id="ph1">`bge`</ph> instruction transfers control to the specified target instruction if <ph id="ph2">`value1`</ph> is greater than or equal to <ph id="ph3">`value2`</ph>.</source>
          <target state="translated">O <ph id="ph1">`bge`</ph> instrução transfere o controle para a instrução de destino especificado se <ph id="ph2">`value1`</ph> é maior que ou igual a <ph id="ph3">`value2`</ph>.</target>       </trans-unit>
        <trans-unit id="305" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bge">
          <source>The effect is identical to performing a <ph id="ph1">`clt.un`</ph> instruction followed by a <ph id="ph2">`brfalse`</ph> branch to the specific target instruction.</source>
          <target state="translated">O efeito é idêntico ao executar uma <ph id="ph1">`clt.un`</ph> instrução seguida por um <ph id="ph2">`brfalse`</ph> ramificação para a instrução de destino específico.</target>       </trans-unit>
        <trans-unit id="306" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bge">
          <source>The target instruction is represented as a 4-byte signed offset from the beginning of the instruction following the current instruction.</source>
          <target state="translated">A instrução de destino é representada como um deslocamento assinado de 4 bytes do início da instrução após a instrução atual.</target>       </trans-unit>
        <trans-unit id="307" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bge">
          <source>If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</source>
          <target state="translated">Se a instrução de destino tem um ou mais códigos de prefixo, o controle só pode ser transferido para o primeiro desses prefixos.</target>       </trans-unit>
        <trans-unit id="308" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bge">
          <source>Control transfers into and out of <ph id="ph1">`try`</ph>, <ph id="ph2">`catch`</ph>, <ph id="ph3">`filter`</ph>, and <ph id="ph4">`finally`</ph> blocks cannot be performed by this instruction.</source>
          <target state="translated">O controle transfere dentro e fora do <ph id="ph1">`try`</ph>, <ph id="ph2">`catch`</ph>, <ph id="ph3">`filter`</ph>, e <ph id="ph4">`finally`</ph> blocos não podem ser executados por essa instrução.</target>       </trans-unit>
        <trans-unit id="309" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bge">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`bge`</ph> opcode:</source>
          <target state="translated">O seguinte <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> sobrecarga de método pode usar o <ph id="ph2">`bge`</ph> opcode:</target>       </trans-unit>
        <trans-unit id="310" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bge">
          <source>ILGenerator.Emit(OpCode, Label)</source>
          <target state="translated">ILGenerator.Emit(OpCode, Label)</target>       </trans-unit>
        <trans-unit id="311" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Bge_S">
          <source>Transfers control to a target instruction (short form) if the first value is greater than or equal to the second value.</source>
          <target state="translated">Transferirá controle para uma instrução de destino (forma abreviada) se o primeiro valor for maior ou igual ao segundo valor.</target>       </trans-unit>
        <trans-unit id="312" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bge_S">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">A tabela a seguir lista as instruções hexadecimal e formato de assembly do Microsoft Intermediate Language (MSIL), junto com um resumo breve de referência:</target>       </trans-unit>
        <trans-unit id="313" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bge_S">
          <source>Format</source>
          <target state="translated">Formatar</target>       </trans-unit>
        <trans-unit id="314" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bge_S">
          <source>Assembly Format</source>
          <target state="translated">Formato de assembly</target>       </trans-unit>
        <trans-unit id="315" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bge_S">
          <source>Description</source>
          <target state="translated">Descrição</target>       </trans-unit>
        <trans-unit id="316" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bge_S">
          <source>2F <ph id="ph1">`&lt;int8&gt;`</ph></source>
          <target state="translated">2F <ph id="ph1">`&lt;int8&gt;`</ph></target>       </trans-unit>
        <trans-unit id="317" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bge_S">
          <source>bge.s <ph id="ph1">`target`</ph></source>
          <target state="translated">bge.s <ph id="ph1">`target`</ph></target>       </trans-unit>
        <trans-unit id="318" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bge_S">
          <source>Branch to the target instruction at the specified offset if the first value is greater than or equal to the second value, short form.</source>
          <target state="translated">Ramificação a instrução de destino no deslocamento especificado se o primeiro valor é maior que ou igual ao segundo valor, forma abreviada.</target>       </trans-unit>
        <trans-unit id="319" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bge_S">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">O comportamento de transição de pilha, em ordem sequencial, é:</target>       </trans-unit>
        <trans-unit id="320" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bge_S">
          <source><ph id="ph1">`value1`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value1`</ph> é inserido na pilha.</target>       </trans-unit>
        <trans-unit id="321" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bge_S">
          <source><ph id="ph1">`value2`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value2`</ph> é inserido na pilha.</target>       </trans-unit>
        <trans-unit id="322" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bge_S">
          <source><ph id="ph1">`value2`</ph> and <ph id="ph2">`value1`</ph> are popped from the stack; if <ph id="ph3">`value1`</ph> is greater than or equal to <ph id="ph4">`value2`</ph>, the branch operation is performed.</source>
          <target state="translated"><ph id="ph1">`value2`</ph> e <ph id="ph2">`value1`</ph> são disparados da pilha; se <ph id="ph3">`value1`</ph> é maior que ou igual a <ph id="ph4">`value2`</ph>, a operação de ramificação é executada.</target>       </trans-unit>
        <trans-unit id="323" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bge_S">
          <source>The <ph id="ph1">`bge.s`</ph> instruction transfers control to the specified target instruction if <ph id="ph2">`value1`</ph> is greater than or equal to <ph id="ph3">`value2`</ph>.</source>
          <target state="translated">O <ph id="ph1">`bge.s`</ph> instrução transfere o controle para a instrução de destino especificado se <ph id="ph2">`value1`</ph> é maior que ou igual a <ph id="ph3">`value2`</ph>.</target>       </trans-unit>
        <trans-unit id="324" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bge_S">
          <source>The effect is identical to performing a <ph id="ph1">`clt.un`</ph> instruction followed by a <ph id="ph2">`brfalse`</ph> branch to the specific target instruction.</source>
          <target state="translated">O efeito é idêntico ao executar uma <ph id="ph1">`clt.un`</ph> instrução seguida por um <ph id="ph2">`brfalse`</ph> ramificação para a instrução de destino específico.</target>       </trans-unit>
        <trans-unit id="325" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bge_S">
          <source>The target instruction is represented as a 1-byte signed offset from the beginning of the instruction following the current instruction.</source>
          <target state="translated">A instrução de destino é representada como um deslocamento de 1 byte assinado desde o início da instrução após a instrução atual.</target>       </trans-unit>
        <trans-unit id="326" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bge_S">
          <source>If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</source>
          <target state="translated">Se a instrução de destino tem um ou mais códigos de prefixo, o controle só pode ser transferido para o primeiro desses prefixos.</target>       </trans-unit>
        <trans-unit id="327" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bge_S">
          <source>Control transfers into and out of <ph id="ph1">`try`</ph>, <ph id="ph2">`catch`</ph>, <ph id="ph3">`filter`</ph>, and <ph id="ph4">`finally`</ph> blocks cannot be performed by this instruction.</source>
          <target state="translated">O controle transfere dentro e fora do <ph id="ph1">`try`</ph>, <ph id="ph2">`catch`</ph>, <ph id="ph3">`filter`</ph>, e <ph id="ph4">`finally`</ph> blocos não podem ser executados por essa instrução.</target>       </trans-unit>
        <trans-unit id="328" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bge_S">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`bge.s`</ph> opcode:</source>
          <target state="translated">O seguinte <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> sobrecarga de método pode usar o <ph id="ph2">`bge.s`</ph> opcode:</target>       </trans-unit>
        <trans-unit id="329" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bge_S">
          <source>ILGenerator.Emit(OpCode, Label)</source>
          <target state="translated">ILGenerator.Emit(OpCode, Label)</target>       </trans-unit>
        <trans-unit id="330" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Bge_Un">
          <source>Transfers control to a target instruction if the first value is greater than the second value, when comparing unsigned integer values or unordered float values.</source>
          <target state="translated">Transferirá o controle para uma instrução de destino se o primeiro valor for maior que o segundo valor ao comparar valores de inteiro sem sinal ou valores float não ordenados.</target>       </trans-unit>
        <trans-unit id="331" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bge_Un">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">A tabela a seguir lista as instruções hexadecimal e formato de assembly do Microsoft Intermediate Language (MSIL), junto com um resumo breve de referência:</target>       </trans-unit>
        <trans-unit id="332" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bge_Un">
          <source>Format</source>
          <target state="translated">Formatar</target>       </trans-unit>
        <trans-unit id="333" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bge_Un">
          <source>Assembly Format</source>
          <target state="translated">Formato de assembly</target>       </trans-unit>
        <trans-unit id="334" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bge_Un">
          <source>Description</source>
          <target state="translated">Descrição</target>       </trans-unit>
        <trans-unit id="335" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bge_Un">
          <source>41 <ph id="ph1">`&lt;int32&gt;`</ph></source>
          <target state="translated">41 <ph id="ph1">`&lt;int32&gt;`</ph></target>       </trans-unit>
        <trans-unit id="336" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bge_Un">
          <source>bge.un <ph id="ph1">`target`</ph></source>
          <target state="translated">bge.Un <ph id="ph1">`target`</ph></target>       </trans-unit>
        <trans-unit id="337" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bge_Un">
          <source>Branch to the target instruction at the specified offset if the first value is greater than or equal to the second value (unsigned values).</source>
          <target state="translated">Ramificação a instrução de destino no deslocamento especificado se o primeiro valor é maior que ou igual ao segundo valor (valores sem sinal).</target>       </trans-unit>
        <trans-unit id="338" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bge_Un">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">O comportamento de transição de pilha, em ordem sequencial, é:</target>       </trans-unit>
        <trans-unit id="339" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bge_Un">
          <source><ph id="ph1">`value1`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value1`</ph> é inserido na pilha.</target>       </trans-unit>
        <trans-unit id="340" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bge_Un">
          <source><ph id="ph1">`value2`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value2`</ph> é inserido na pilha.</target>       </trans-unit>
        <trans-unit id="341" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bge_Un">
          <source><ph id="ph1">`value2`</ph> and <ph id="ph2">`value1`</ph> are popped from the stack; if <ph id="ph3">`value1`</ph> is greater than or equal to <ph id="ph4">`value2`</ph>, the branch operation is performed.</source>
          <target state="translated"><ph id="ph1">`value2`</ph> e <ph id="ph2">`value1`</ph> são disparados da pilha; se <ph id="ph3">`value1`</ph> é maior que ou igual a <ph id="ph4">`value2`</ph>, a operação de ramificação é executada.</target>       </trans-unit>
        <trans-unit id="342" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bge_Un">
          <source>The <ph id="ph1">`bge.un`</ph> instruction transfers control to the specified target instruction if <ph id="ph2">`value1`</ph> is greater than or equal to <ph id="ph3">`value2`</ph>, when compared using unsigned integer or unordered float values.</source>
          <target state="translated">O <ph id="ph1">`bge.un`</ph> instrução transfere o controle para a instrução de destino especificado se <ph id="ph2">`value1`</ph> é maior que ou igual a <ph id="ph3">`value2`</ph>, quando comparados com valores de float não ordenada ou inteiro não assinado.</target>       </trans-unit>
        <trans-unit id="343" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bge_Un">
          <source>The effect is identical to performing a <ph id="ph1">`clt`</ph> instruction followed by a <ph id="ph2">`brfalse`</ph> branch to the specific target instruction.</source>
          <target state="translated">O efeito é idêntico ao executar uma <ph id="ph1">`clt`</ph> instrução seguida por um <ph id="ph2">`brfalse`</ph> ramificação para a instrução de destino específico.</target>       </trans-unit>
        <trans-unit id="344" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bge_Un">
          <source>The target instruction is represented as a 4-byte signed offset from the beginning of the instruction following the current instruction.</source>
          <target state="translated">A instrução de destino é representada como um deslocamento assinado de 4 bytes do início da instrução após a instrução atual.</target>       </trans-unit>
        <trans-unit id="345" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bge_Un">
          <source>If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</source>
          <target state="translated">Se a instrução de destino tem um ou mais códigos de prefixo, o controle só pode ser transferido para o primeiro desses prefixos.</target>       </trans-unit>
        <trans-unit id="346" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bge_Un">
          <source>Control transfers into and out of <ph id="ph1">`try`</ph>, <ph id="ph2">`catch`</ph>, <ph id="ph3">`filter`</ph>, and <ph id="ph4">`finally`</ph> blocks cannot be performed by this instruction.</source>
          <target state="translated">O controle transfere dentro e fora do <ph id="ph1">`try`</ph>, <ph id="ph2">`catch`</ph>, <ph id="ph3">`filter`</ph>, e <ph id="ph4">`finally`</ph> blocos não podem ser executados por essa instrução.</target>       </trans-unit>
        <trans-unit id="347" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bge_Un">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`bge.un`</ph> opcode:</source>
          <target state="translated">O seguinte <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> sobrecarga de método pode usar o <ph id="ph2">`bge.un`</ph> opcode:</target>       </trans-unit>
        <trans-unit id="348" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bge_Un">
          <source>ILGenerator.Emit(OpCode, Label)</source>
          <target state="translated">ILGenerator.Emit(OpCode, Label)</target>       </trans-unit>
        <trans-unit id="349" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Bge_Un_S">
          <source>Transfers control to a target instruction (short form) if the first value is greater than the second value, when comparing unsigned integer values or unordered float values.</source>
          <target state="translated">Transferirá o controle para uma instrução de destino (forma abreviada) se o primeiro valor for maior que o segundo valor ao comparar valores de inteiro sem sinal ou valores float não ordenados.</target>       </trans-unit>
        <trans-unit id="350" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bge_Un_S">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">A tabela a seguir lista as instruções hexadecimal e formato de assembly do Microsoft Intermediate Language (MSIL), junto com um resumo breve de referência:</target>       </trans-unit>
        <trans-unit id="351" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bge_Un_S">
          <source>Format</source>
          <target state="translated">Formatar</target>       </trans-unit>
        <trans-unit id="352" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bge_Un_S">
          <source>Assembly Format</source>
          <target state="translated">Formato de assembly</target>       </trans-unit>
        <trans-unit id="353" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bge_Un_S">
          <source>Description</source>
          <target state="translated">Descrição</target>       </trans-unit>
        <trans-unit id="354" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bge_Un_S">
          <source>34 &lt; <ph id="ph1">`int8`</ph><ph id="ph2"> &gt;</ph></source>
          <target state="translated">34 &lt; <ph id="ph1">`int8`</ph><ph id="ph2"> &gt;</ph></target>       </trans-unit>
        <trans-unit id="355" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bge_Un_S">
          <source>bge.un.s <ph id="ph1">`target`</ph></source>
          <target state="translated">bge.un.s <ph id="ph1">`target`</ph></target>       </trans-unit>
        <trans-unit id="356" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bge_Un_S">
          <source>Branch to the target instruction at the specified offset if the first value is greater than or equal to the second value (unsigned values), short form.</source>
          <target state="translated">Ramificação a instrução de destino no deslocamento especificado se o primeiro valor é maior que ou igual ao valor (valores sem sinal), segunda forma abreviada.</target>       </trans-unit>
        <trans-unit id="357" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bge_Un_S">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">O comportamento de transição de pilha, em ordem sequencial, é:</target>       </trans-unit>
        <trans-unit id="358" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bge_Un_S">
          <source><ph id="ph1">`value1`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value1`</ph> é inserido na pilha.</target>       </trans-unit>
        <trans-unit id="359" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bge_Un_S">
          <source><ph id="ph1">`value2`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value2`</ph> é inserido na pilha.</target>       </trans-unit>
        <trans-unit id="360" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bge_Un_S">
          <source><ph id="ph1">`value2`</ph> and <ph id="ph2">`value1`</ph> are popped from the stack; if <ph id="ph3">`value1`</ph> is greater than or equal to <ph id="ph4">`value2`</ph>, the branch operation is performed.</source>
          <target state="translated"><ph id="ph1">`value2`</ph> e <ph id="ph2">`value1`</ph> são disparados da pilha; se <ph id="ph3">`value1`</ph> é maior que ou igual a <ph id="ph4">`value2`</ph>, a operação de ramificação é executada.</target>       </trans-unit>
        <trans-unit id="361" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bge_Un_S">
          <source>The <ph id="ph1">`bge.un.s`</ph> instruction transfers control to the specified target instruction if <ph id="ph2">`value1`</ph> is greater than or equal to <ph id="ph3">`value2`</ph>, when compared using unsigned integer or unordered float values.</source>
          <target state="translated">O <ph id="ph1">`bge.un.s`</ph> instrução transfere o controle para a instrução de destino especificado se <ph id="ph2">`value1`</ph> é maior que ou igual a <ph id="ph3">`value2`</ph>, quando comparados com valores de float não ordenada ou inteiro não assinado.</target>       </trans-unit>
        <trans-unit id="362" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bge_Un_S">
          <source>The effect is identical to performing a <ph id="ph1">`clt`</ph> instruction followed by a <ph id="ph2">`brfalse`</ph> branch to the specific target instruction.</source>
          <target state="translated">O efeito é idêntico ao executar uma <ph id="ph1">`clt`</ph> instrução seguida por um <ph id="ph2">`brfalse`</ph> ramificação para a instrução de destino específico.</target>       </trans-unit>
        <trans-unit id="363" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bge_Un_S">
          <source>The target instruction is represented as a 1-byte signed offset from the beginning of the instruction following the current instruction.</source>
          <target state="translated">A instrução de destino é representada como um deslocamento de 1 byte assinado desde o início da instrução após a instrução atual.</target>       </trans-unit>
        <trans-unit id="364" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bge_Un_S">
          <source>If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</source>
          <target state="translated">Se a instrução de destino tem um ou mais códigos de prefixo, o controle só pode ser transferido para o primeiro desses prefixos.</target>       </trans-unit>
        <trans-unit id="365" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bge_Un_S">
          <source>Control transfers into and out of <ph id="ph1">`try`</ph>, <ph id="ph2">`catch`</ph>, <ph id="ph3">`filter`</ph>, and <ph id="ph4">`finally`</ph> blocks cannot be performed by this instruction.</source>
          <target state="translated">O controle transfere dentro e fora do <ph id="ph1">`try`</ph>, <ph id="ph2">`catch`</ph>, <ph id="ph3">`filter`</ph>, e <ph id="ph4">`finally`</ph> blocos não podem ser executados por essa instrução.</target>       </trans-unit>
        <trans-unit id="366" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bge_Un_S">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`bge.un.s`</ph> opcode:</source>
          <target state="translated">O seguinte <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> sobrecarga de método pode usar o <ph id="ph2">`bge.un.s`</ph> opcode:</target>       </trans-unit>
        <trans-unit id="367" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bge_Un_S">
          <source>ILGenerator.Emit(OpCode, Label)</source>
          <target state="translated">ILGenerator.Emit(OpCode, Label)</target>       </trans-unit>
        <trans-unit id="368" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Bgt">
          <source>Transfers control to a target instruction if the first value is greater than the second value.</source>
          <target state="translated">Transferirá controle para uma instrução de destino se o primeiro valor for maior que o segundo valor.</target>       </trans-unit>
        <trans-unit id="369" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bgt">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">A tabela a seguir lista as instruções hexadecimal e formato de assembly do Microsoft Intermediate Language (MSIL), junto com um resumo breve de referência:</target>       </trans-unit>
        <trans-unit id="370" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bgt">
          <source>Format</source>
          <target state="translated">Formatar</target>       </trans-unit>
        <trans-unit id="371" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bgt">
          <source>Assembly Format</source>
          <target state="translated">Formato de assembly</target>       </trans-unit>
        <trans-unit id="372" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bgt">
          <source>Description</source>
          <target state="translated">Descrição</target>       </trans-unit>
        <trans-unit id="373" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bgt">
          <source>3D &lt; <ph id="ph1">`int32`</ph><ph id="ph2"> &gt;</ph></source>
          <target state="translated">3D &lt; <ph id="ph1">`int32`</ph><ph id="ph2"> &gt;</ph></target>       </trans-unit>
        <trans-unit id="374" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bgt">
          <source>bgt <ph id="ph1">`target`</ph></source>
          <target state="translated">bgt <ph id="ph1">`target`</ph></target>       </trans-unit>
        <trans-unit id="375" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bgt">
          <source>Branch to the target instruction at the specified offset if the first value is greater than the second value.</source>
          <target state="translated">Ramificação a instrução de destino no deslocamento especificado se o primeiro valor é maior que o segundo valor.</target>       </trans-unit>
        <trans-unit id="376" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bgt">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">O comportamento de transição de pilha, em ordem sequencial, é:</target>       </trans-unit>
        <trans-unit id="377" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bgt">
          <source><ph id="ph1">`value1`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value1`</ph> é inserido na pilha.</target>       </trans-unit>
        <trans-unit id="378" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bgt">
          <source><ph id="ph1">`value2`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value2`</ph> é inserido na pilha.</target>       </trans-unit>
        <trans-unit id="379" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bgt">
          <source><ph id="ph1">`value2`</ph> and <ph id="ph2">`value1`</ph> are popped from the stack; if <ph id="ph3">`value1`</ph> is greater than <ph id="ph4">`value2`</ph>, the branch operation is performed.</source>
          <target state="translated"><ph id="ph1">`value2`</ph> e <ph id="ph2">`value1`</ph> são disparados da pilha; se <ph id="ph3">`value1`</ph> é maior do que <ph id="ph4">`value2`</ph>, a operação de ramificação é executada.</target>       </trans-unit>
        <trans-unit id="380" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bgt">
          <source>The <ph id="ph1">`bgt`</ph> instruction transfers control to the specified target instruction if <ph id="ph2">`value1`</ph> is greater than <ph id="ph3">`value2`</ph>.</source>
          <target state="translated">O <ph id="ph1">`bgt`</ph> instrução transfere o controle para a instrução de destino especificado se <ph id="ph2">`value1`</ph> é maior do que <ph id="ph3">`value2`</ph>.</target>       </trans-unit>
        <trans-unit id="381" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bgt">
          <source>The effect is identical to performing a <ph id="ph1">`cgt`</ph> instruction followed by a <ph id="ph2">`brtrue`</ph> branch to the specific target instruction.</source>
          <target state="translated">O efeito é idêntico ao executar uma <ph id="ph1">`cgt`</ph> instrução seguida por um <ph id="ph2">`brtrue`</ph> ramificação para a instrução de destino específico.</target>       </trans-unit>
        <trans-unit id="382" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bgt">
          <source>The target instruction is represented as a 4-byte signed offset from the beginning of the instruction following the current instruction.</source>
          <target state="translated">A instrução de destino é representada como um deslocamento assinado de 4 bytes do início da instrução após a instrução atual.</target>       </trans-unit>
        <trans-unit id="383" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bgt">
          <source>If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</source>
          <target state="translated">Se a instrução de destino tem um ou mais códigos de prefixo, o controle só pode ser transferido para o primeiro desses prefixos.</target>       </trans-unit>
        <trans-unit id="384" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bgt">
          <source>Control transfers into and out of <ph id="ph1">`try`</ph>, <ph id="ph2">`catch`</ph>, <ph id="ph3">`filter`</ph>, and <ph id="ph4">`finally`</ph> blocks cannot be performed by this instruction.</source>
          <target state="translated">O controle transfere dentro e fora do <ph id="ph1">`try`</ph>, <ph id="ph2">`catch`</ph>, <ph id="ph3">`filter`</ph>, e <ph id="ph4">`finally`</ph> blocos não podem ser executados por essa instrução.</target>       </trans-unit>
        <trans-unit id="385" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bgt">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`bgt`</ph> opcode:</source>
          <target state="translated">O seguinte <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> sobrecarga de método pode usar o <ph id="ph2">`bgt`</ph> opcode:</target>       </trans-unit>
        <trans-unit id="386" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bgt">
          <source>ILGenerator.Emit(OpCode, Label)</source>
          <target state="translated">ILGenerator.Emit(OpCode, Label)</target>       </trans-unit>
        <trans-unit id="387" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Bgt_S">
          <source>Transfers control to a target instruction (short form) if the first value is greater than the second value.</source>
          <target state="translated">Transferirá controle para uma instrução de destino (forma abreviada) se o primeiro valor for maior que o segundo valor.</target>       </trans-unit>
        <trans-unit id="388" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bgt_S">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">A tabela a seguir lista as instruções hexadecimal e formato de assembly do Microsoft Intermediate Language (MSIL), junto com um resumo breve de referência:</target>       </trans-unit>
        <trans-unit id="389" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bgt_S">
          <source>Format</source>
          <target state="translated">Formatar</target>       </trans-unit>
        <trans-unit id="390" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bgt_S">
          <source>Assembly Format</source>
          <target state="translated">Formato de assembly</target>       </trans-unit>
        <trans-unit id="391" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bgt_S">
          <source>Description</source>
          <target state="translated">Descrição</target>       </trans-unit>
        <trans-unit id="392" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bgt_S">
          <source>30 &lt; <ph id="ph1">`int8`</ph><ph id="ph2"> &gt;</ph></source>
          <target state="translated">30 &lt; <ph id="ph1">`int8`</ph><ph id="ph2"> &gt;</ph></target>       </trans-unit>
        <trans-unit id="393" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bgt_S">
          <source>bgt.s <ph id="ph1">`target`</ph></source>
          <target state="translated">bgt.s <ph id="ph1">`target`</ph></target>       </trans-unit>
        <trans-unit id="394" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bgt_S">
          <source>Branch to the target instruction at the specified offset if the first value is greater than the second value, short form.</source>
          <target state="translated">Ramificação a instrução de destino no deslocamento especificado se o primeiro valor é maior que o segundo valor, de forma abreviada.</target>       </trans-unit>
        <trans-unit id="395" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bgt_S">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">O comportamento de transição de pilha, em ordem sequencial, é:</target>       </trans-unit>
        <trans-unit id="396" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bgt_S">
          <source><ph id="ph1">`value1`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value1`</ph> é inserido na pilha.</target>       </trans-unit>
        <trans-unit id="397" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bgt_S">
          <source><ph id="ph1">`value2`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value2`</ph> é inserido na pilha.</target>       </trans-unit>
        <trans-unit id="398" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bgt_S">
          <source><ph id="ph1">`value2`</ph> and <ph id="ph2">`value1`</ph> are popped from the stack; if <ph id="ph3">`value1`</ph> is greater than <ph id="ph4">`value2`</ph>, the branch operation is performed.</source>
          <target state="translated"><ph id="ph1">`value2`</ph> e <ph id="ph2">`value1`</ph> são disparados da pilha; se <ph id="ph3">`value1`</ph> é maior do que <ph id="ph4">`value2`</ph>, a operação de ramificação é executada.</target>       </trans-unit>
        <trans-unit id="399" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bgt_S">
          <source>The <ph id="ph1">`bgt.s`</ph> instruction transfers control to the specified target instruction if <ph id="ph2">`value1`</ph> is greater than <ph id="ph3">`value2`</ph>.</source>
          <target state="translated">O <ph id="ph1">`bgt.s`</ph> instrução transfere o controle para a instrução de destino especificado se <ph id="ph2">`value1`</ph> é maior do que <ph id="ph3">`value2`</ph>.</target>       </trans-unit>
        <trans-unit id="400" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bgt_S">
          <source>The effect is identical to performing a <ph id="ph1">`cgt`</ph> instruction followed by a <ph id="ph2">`brtrue`</ph> branch to the specific target instruction.</source>
          <target state="translated">O efeito é idêntico ao executar uma <ph id="ph1">`cgt`</ph> instrução seguida por um <ph id="ph2">`brtrue`</ph> ramificação para a instrução de destino específico.</target>       </trans-unit>
        <trans-unit id="401" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bgt_S">
          <source>The target instruction is represented as a 1-byte signed offset from the beginning of the instruction following the current instruction.</source>
          <target state="translated">A instrução de destino é representada como um deslocamento de 1 byte assinado desde o início da instrução após a instrução atual.</target>       </trans-unit>
        <trans-unit id="402" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bgt_S">
          <source>If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</source>
          <target state="translated">Se a instrução de destino tem um ou mais códigos de prefixo, o controle só pode ser transferido para o primeiro desses prefixos.</target>       </trans-unit>
        <trans-unit id="403" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bgt_S">
          <source>Control transfers into and out of <ph id="ph1">`try`</ph>, <ph id="ph2">`catch`</ph>, <ph id="ph3">`filter`</ph>, and <ph id="ph4">`finally`</ph> blocks cannot be performed by this instruction.</source>
          <target state="translated">O controle transfere dentro e fora do <ph id="ph1">`try`</ph>, <ph id="ph2">`catch`</ph>, <ph id="ph3">`filter`</ph>, e <ph id="ph4">`finally`</ph> blocos não podem ser executados por essa instrução.</target>       </trans-unit>
        <trans-unit id="404" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bgt_S">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`bgt.s`</ph> opcode:</source>
          <target state="translated">O seguinte <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> sobrecarga de método pode usar o <ph id="ph2">`bgt.s`</ph> opcode:</target>       </trans-unit>
        <trans-unit id="405" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bgt_S">
          <source>ILGenerator.Emit(OpCode, Label)</source>
          <target state="translated">ILGenerator.Emit(OpCode, Label)</target>       </trans-unit>
        <trans-unit id="406" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Bgt_Un">
          <source>Transfers control to a target instruction if the first value is greater than the second value, when comparing unsigned integer values or unordered float values.</source>
          <target state="translated">Transferirá o controle para uma instrução de destino se o primeiro valor for maior que o segundo valor ao comparar valores de inteiro sem sinal ou valores float não ordenados.</target>       </trans-unit>
        <trans-unit id="407" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bgt_Un">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">A tabela a seguir lista as instruções hexadecimal e formato de assembly do Microsoft Intermediate Language (MSIL), junto com um resumo breve de referência:</target>       </trans-unit>
        <trans-unit id="408" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bgt_Un">
          <source>Format</source>
          <target state="translated">Formatar</target>       </trans-unit>
        <trans-unit id="409" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bgt_Un">
          <source>Assembly Format</source>
          <target state="translated">Formato de assembly</target>       </trans-unit>
        <trans-unit id="410" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bgt_Un">
          <source>Description</source>
          <target state="translated">Descrição</target>       </trans-unit>
        <trans-unit id="411" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bgt_Un">
          <source>42 &lt; <ph id="ph1">`int32`</ph><ph id="ph2"> &gt;</ph></source>
          <target state="translated">42 &lt; <ph id="ph1">`int32`</ph><ph id="ph2"> &gt;</ph></target>       </trans-unit>
        <trans-unit id="412" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bgt_Un">
          <source>bgt.un <ph id="ph1">`target`</ph></source>
          <target state="translated">bgt.Un <ph id="ph1">`target`</ph></target>       </trans-unit>
        <trans-unit id="413" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bgt_Un">
          <source>Branch to the target instruction at the specified offset if the first value is greater than the second value (unsigned values).</source>
          <target state="translated">Ramificação a instrução de destino no deslocamento especificado se o primeiro valor é maior que o valor de segundo (valores sem sinal).</target>       </trans-unit>
        <trans-unit id="414" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bgt_Un">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">O comportamento de transição de pilha, em ordem sequencial, é:</target>       </trans-unit>
        <trans-unit id="415" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bgt_Un">
          <source><ph id="ph1">`value1`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value1`</ph> é inserido na pilha.</target>       </trans-unit>
        <trans-unit id="416" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bgt_Un">
          <source><ph id="ph1">`value2`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value2`</ph> é inserido na pilha.</target>       </trans-unit>
        <trans-unit id="417" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bgt_Un">
          <source><ph id="ph1">`value2`</ph> and <ph id="ph2">`value1`</ph> are popped from the stack; if <ph id="ph3">`value1`</ph> is greater than <ph id="ph4">`value2`</ph>, the branch operation is performed.</source>
          <target state="translated"><ph id="ph1">`value2`</ph> e <ph id="ph2">`value1`</ph> são disparados da pilha; se <ph id="ph3">`value1`</ph> é maior do que <ph id="ph4">`value2`</ph>, a operação de ramificação é executada.</target>       </trans-unit>
        <trans-unit id="418" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bgt_Un">
          <source>The <ph id="ph1">`bgt.un`</ph> instruction transfers control to the specified target instruction if <ph id="ph2">`value1`</ph> is greater than <ph id="ph3">`value2`</ph>, when compared using unsigned integer or unordered float values.</source>
          <target state="translated">O <ph id="ph1">`bgt.un`</ph> instrução transfere o controle para a instrução de destino especificado se <ph id="ph2">`value1`</ph> é maior do que <ph id="ph3">`value2`</ph>, quando comparados com valores de float não ordenada ou inteiro não assinado.</target>       </trans-unit>
        <trans-unit id="419" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bgt_Un">
          <source>The effect is identical to performing a <ph id="ph1">`cgt.un`</ph> instruction followed by a <ph id="ph2">`brtrue`</ph> branch to the specific target instruction.</source>
          <target state="translated">O efeito é idêntico ao executar uma <ph id="ph1">`cgt.un`</ph> instrução seguida por um <ph id="ph2">`brtrue`</ph> ramificação para a instrução de destino específico.</target>       </trans-unit>
        <trans-unit id="420" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bgt_Un">
          <source>The target instruction is represented as a 4-byte signed offset from the beginning of the instruction following the current instruction.</source>
          <target state="translated">A instrução de destino é representada como um deslocamento assinado de 4 bytes do início da instrução após a instrução atual.</target>       </trans-unit>
        <trans-unit id="421" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bgt_Un">
          <source>If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</source>
          <target state="translated">Se a instrução de destino tem um ou mais códigos de prefixo, o controle só pode ser transferido para o primeiro desses prefixos.</target>       </trans-unit>
        <trans-unit id="422" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bgt_Un">
          <source>Control transfers into and out of <ph id="ph1">`try`</ph>, <ph id="ph2">`catch`</ph>, <ph id="ph3">`filter`</ph>, and <ph id="ph4">`finally`</ph> blocks cannot be performed by this instruction.</source>
          <target state="translated">O controle transfere dentro e fora do <ph id="ph1">`try`</ph>, <ph id="ph2">`catch`</ph>, <ph id="ph3">`filter`</ph>, e <ph id="ph4">`finally`</ph> blocos não podem ser executados por essa instrução.</target>       </trans-unit>
        <trans-unit id="423" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bgt_Un">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`bgt.un`</ph> opcode:</source>
          <target state="translated">O seguinte <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> sobrecarga de método pode usar o <ph id="ph2">`bgt.un`</ph> opcode:</target>       </trans-unit>
        <trans-unit id="424" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bgt_Un">
          <source>ILGenerator.Emit(OpCode, Label)</source>
          <target state="translated">ILGenerator.Emit(OpCode, Label)</target>       </trans-unit>
        <trans-unit id="425" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Bgt_Un_S">
          <source>Transfers control to a target instruction (short form) if the first value is greater than the second value, when comparing unsigned integer values or unordered float values.</source>
          <target state="translated">Transferirá o controle para uma instrução de destino (forma abreviada) se o primeiro valor for maior que o segundo valor ao comparar valores de inteiro sem sinal ou valores float não ordenados.</target>       </trans-unit>
        <trans-unit id="426" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bgt_Un_S">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">A tabela a seguir lista as instruções hexadecimal e formato de assembly do Microsoft Intermediate Language (MSIL), junto com um resumo breve de referência:</target>       </trans-unit>
        <trans-unit id="427" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bgt_Un_S">
          <source>Format</source>
          <target state="translated">Formatar</target>       </trans-unit>
        <trans-unit id="428" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bgt_Un_S">
          <source>Assembly Format</source>
          <target state="translated">Formato de assembly</target>       </trans-unit>
        <trans-unit id="429" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bgt_Un_S">
          <source>Description</source>
          <target state="translated">Descrição</target>       </trans-unit>
        <trans-unit id="430" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bgt_Un_S">
          <source>35 &lt; <ph id="ph1">`int8`</ph><ph id="ph2"> &gt;</ph></source>
          <target state="translated">35 &lt; <ph id="ph1">`int8`</ph><ph id="ph2"> &gt;</ph></target>       </trans-unit>
        <trans-unit id="431" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bgt_Un_S">
          <source>bgt.un.s <ph id="ph1">`target`</ph></source>
          <target state="translated">bgt.un.s <ph id="ph1">`target`</ph></target>       </trans-unit>
        <trans-unit id="432" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bgt_Un_S">
          <source>Branch to the target instruction at the specified offset if the first value is greater than the second value (unsigned values), short form.</source>
          <target state="translated">Ramificação a instrução de destino no deslocamento especificado se o primeiro valor é maior que o valor de segundo (valores sem sinal), forma abreviada.</target>       </trans-unit>
        <trans-unit id="433" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bgt_Un_S">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">O comportamento de transição de pilha, em ordem sequencial, é:</target>       </trans-unit>
        <trans-unit id="434" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bgt_Un_S">
          <source><ph id="ph1">`value1`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value1`</ph> é inserido na pilha.</target>       </trans-unit>
        <trans-unit id="435" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bgt_Un_S">
          <source><ph id="ph1">`value2`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value2`</ph> é inserido na pilha.</target>       </trans-unit>
        <trans-unit id="436" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bgt_Un_S">
          <source><ph id="ph1">`value2`</ph> and <ph id="ph2">`value1`</ph> are popped from the stack; if <ph id="ph3">`value1`</ph> is greater than <ph id="ph4">`value2`</ph>, the branch operation is performed.</source>
          <target state="translated"><ph id="ph1">`value2`</ph> e <ph id="ph2">`value1`</ph> são disparados da pilha; se <ph id="ph3">`value1`</ph> é maior do que <ph id="ph4">`value2`</ph>, a operação de ramificação é executada.</target>       </trans-unit>
        <trans-unit id="437" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bgt_Un_S">
          <source>The <ph id="ph1">`bgt.un.s`</ph> instruction transfers control to the specified target instruction if <ph id="ph2">`value1`</ph> is greater than <ph id="ph3">`value2`</ph>, when compared using unsigned integer or unordered float values.</source>
          <target state="translated">O <ph id="ph1">`bgt.un.s`</ph> instrução transfere o controle para a instrução de destino especificado se <ph id="ph2">`value1`</ph> é maior do que <ph id="ph3">`value2`</ph>, quando comparados com valores de float não ordenada ou inteiro não assinado.</target>       </trans-unit>
        <trans-unit id="438" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bgt_Un_S">
          <source>The effect is identical to performing a <ph id="ph1">`cgt.un`</ph> instruction followed by a <ph id="ph2">`brtrue`</ph> branch to the specific target instruction.</source>
          <target state="translated">O efeito é idêntico ao executar uma <ph id="ph1">`cgt.un`</ph> instrução seguida por um <ph id="ph2">`brtrue`</ph> ramificação para a instrução de destino específico.</target>       </trans-unit>
        <trans-unit id="439" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bgt_Un_S">
          <source>The target instruction is represented as a 1-byte signed offset from the beginning of the instruction following the current instruction.</source>
          <target state="translated">A instrução de destino é representada como um deslocamento de 1 byte assinado desde o início da instrução após a instrução atual.</target>       </trans-unit>
        <trans-unit id="440" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bgt_Un_S">
          <source>If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</source>
          <target state="translated">Se a instrução de destino tem um ou mais códigos de prefixo, o controle só pode ser transferido para o primeiro desses prefixos.</target>       </trans-unit>
        <trans-unit id="441" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bgt_Un_S">
          <source>Control transfers into and out of <ph id="ph1">`try`</ph>, <ph id="ph2">`catch`</ph>, <ph id="ph3">`filter`</ph>, and <ph id="ph4">`finally`</ph> blocks cannot be performed by this instruction.</source>
          <target state="translated">O controle transfere dentro e fora do <ph id="ph1">`try`</ph>, <ph id="ph2">`catch`</ph>, <ph id="ph3">`filter`</ph>, e <ph id="ph4">`finally`</ph> blocos não podem ser executados por essa instrução.</target>       </trans-unit>
        <trans-unit id="442" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bgt_Un_S">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`bgt.un.s`</ph> opcode:</source>
          <target state="translated">O seguinte <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> sobrecarga de método pode usar o <ph id="ph2">`bgt.un.s`</ph> opcode:</target>       </trans-unit>
        <trans-unit id="443" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bgt_Un_S">
          <source>ILGenerator.Emit(OpCode, Label)</source>
          <target state="translated">ILGenerator.Emit(OpCode, Label)</target>       </trans-unit>
        <trans-unit id="444" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Ble">
          <source>Transfers control to a target instruction if the first value is less than or equal to the second value.</source>
          <target state="translated">Transferirá controle para uma instrução de destino se o primeiro valor for menor ou igual ao segundo valor.</target>       </trans-unit>
        <trans-unit id="445" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ble">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">A tabela a seguir lista as instruções hexadecimal e formato de assembly do Microsoft Intermediate Language (MSIL), junto com um resumo breve de referência:</target>       </trans-unit>
        <trans-unit id="446" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ble">
          <source>Format</source>
          <target state="translated">Formatar</target>       </trans-unit>
        <trans-unit id="447" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ble">
          <source>Assembly Format</source>
          <target state="translated">Formato de assembly</target>       </trans-unit>
        <trans-unit id="448" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ble">
          <source>Description</source>
          <target state="translated">Descrição</target>       </trans-unit>
        <trans-unit id="449" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ble">
          <source>3E <ph id="ph1">`&lt;int32&gt;`</ph></source>
          <target state="translated">3E <ph id="ph1">`&lt;int32&gt;`</ph></target>       </trans-unit>
        <trans-unit id="450" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ble">
          <source>ble <ph id="ph1">`target`</ph></source>
          <target state="translated">var <ph id="ph1">`target`</ph></target>       </trans-unit>
        <trans-unit id="451" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ble">
          <source>Branch to the target instruction at the specified offset if the first value is less than or equal to the second value.</source>
          <target state="translated">Ramificação a instrução de destino no deslocamento especificado se o primeiro valor é menor ou igual ao segundo valor.</target>       </trans-unit>
        <trans-unit id="452" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ble">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">O comportamento de transição de pilha, em ordem sequencial, é:</target>       </trans-unit>
        <trans-unit id="453" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ble">
          <source><ph id="ph1">`value1`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value1`</ph> é inserido na pilha.</target>       </trans-unit>
        <trans-unit id="454" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ble">
          <source><ph id="ph1">`value2`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value2`</ph> é inserido na pilha.</target>       </trans-unit>
        <trans-unit id="455" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ble">
          <source><ph id="ph1">`value2`</ph> and <ph id="ph2">`value1`</ph> are popped from the stack; if <ph id="ph3">`value1`</ph> is less than or equal to <ph id="ph4">`value2`</ph>, the branch operation is performed.</source>
          <target state="translated"><ph id="ph1">`value2`</ph> e <ph id="ph2">`value1`</ph> são disparados da pilha; se <ph id="ph3">`value1`</ph> é menor que ou igual a <ph id="ph4">`value2`</ph>, a operação de ramificação é executada.</target>       </trans-unit>
        <trans-unit id="456" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ble">
          <source>The <ph id="ph1">`ble`</ph> instruction transfers control to the specified target instruction if <ph id="ph2">`value1`</ph> is less than or equal to <ph id="ph3">`value2`</ph>.</source>
          <target state="translated">O <ph id="ph1">`ble`</ph> instrução transfere o controle para a instrução de destino especificado se <ph id="ph2">`value1`</ph> é menor que ou igual a <ph id="ph3">`value2`</ph>.</target>       </trans-unit>
        <trans-unit id="457" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ble">
          <source>The effect is identical to performing a <ph id="ph1">`cgt`</ph> instruction (<ph id="ph2">`cgt.un`</ph> for floats) followed by a <ph id="ph3">`brfalse`</ph> branch to the specific target instruction.</source>
          <target state="translated">O efeito é idêntico ao executar uma <ph id="ph1">`cgt`</ph> instrução (<ph id="ph2">`cgt.un`</ph> para flutuações) seguido por um <ph id="ph3">`brfalse`</ph> ramificação para a instrução de destino específico.</target>       </trans-unit>
        <trans-unit id="458" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ble">
          <source>The target instruction is represented as a 4-byte signed offset from the beginning of the instruction following the current instruction.</source>
          <target state="translated">A instrução de destino é representada como um deslocamento assinado de 4 bytes do início da instrução após a instrução atual.</target>       </trans-unit>
        <trans-unit id="459" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ble">
          <source>If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</source>
          <target state="translated">Se a instrução de destino tem um ou mais códigos de prefixo, o controle só pode ser transferido para o primeiro desses prefixos.</target>       </trans-unit>
        <trans-unit id="460" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ble">
          <source>Control transfers into and out of <ph id="ph1">`try`</ph>, <ph id="ph2">`catch`</ph>, <ph id="ph3">`filter`</ph>, and <ph id="ph4">`finally`</ph> blocks cannot be performed by this instruction.</source>
          <target state="translated">O controle transfere dentro e fora do <ph id="ph1">`try`</ph>, <ph id="ph2">`catch`</ph>, <ph id="ph3">`filter`</ph>, e <ph id="ph4">`finally`</ph> blocos não podem ser executados por essa instrução.</target>       </trans-unit>
        <trans-unit id="461" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ble">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`ble`</ph> opcode:</source>
          <target state="translated">O seguinte <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> sobrecarga de método pode usar o <ph id="ph2">`ble`</ph> opcode:</target>       </trans-unit>
        <trans-unit id="462" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ble">
          <source>ILGenerator.Emit(OpCode, Label)</source>
          <target state="translated">ILGenerator.Emit(OpCode, Label)</target>       </trans-unit>
        <trans-unit id="463" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Ble_S">
          <source>Transfers control to a target instruction (short form) if the first value is less than or equal to the second value.</source>
          <target state="translated">Transferirá controle para uma instrução de destino (forma abreviada) se o primeiro valor for menor ou igual ao segundo valor.</target>       </trans-unit>
        <trans-unit id="464" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ble_S">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">A tabela a seguir lista as instruções hexadecimal e formato de assembly do Microsoft Intermediate Language (MSIL), junto com um resumo breve de referência:</target>       </trans-unit>
        <trans-unit id="465" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ble_S">
          <source>Format</source>
          <target state="translated">Formatar</target>       </trans-unit>
        <trans-unit id="466" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ble_S">
          <source>Assembly Format</source>
          <target state="translated">Formato de assembly</target>       </trans-unit>
        <trans-unit id="467" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ble_S">
          <source>Description</source>
          <target state="translated">Descrição</target>       </trans-unit>
        <trans-unit id="468" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ble_S">
          <source>31 <ph id="ph1">`&lt;int8&gt;`</ph></source>
          <target state="translated">31 <ph id="ph1">`&lt;int8&gt;`</ph></target>       </trans-unit>
        <trans-unit id="469" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ble_S">
          <source>ble.s <ph id="ph1">`target`</ph></source>
          <target state="translated">ble.s <ph id="ph1">`target`</ph></target>       </trans-unit>
        <trans-unit id="470" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ble_S">
          <source>Branch to the target instruction at the specified offset if the first value is less than or equal to the second value, short form.</source>
          <target state="translated">Ramificação a instrução de destino no deslocamento especificado se o primeiro valor é menor ou igual ao segundo valor, forma abreviada.</target>       </trans-unit>
        <trans-unit id="471" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ble_S">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">O comportamento de transição de pilha, em ordem sequencial, é:</target>       </trans-unit>
        <trans-unit id="472" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ble_S">
          <source><ph id="ph1">`value1`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value1`</ph> é inserido na pilha.</target>       </trans-unit>
        <trans-unit id="473" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ble_S">
          <source><ph id="ph1">`value2`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value2`</ph> é inserido na pilha.</target>       </trans-unit>
        <trans-unit id="474" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ble_S">
          <source><ph id="ph1">`value2`</ph> and <ph id="ph2">`value1`</ph> are popped from the stack; if <ph id="ph3">`value1`</ph> is less than or equal to <ph id="ph4">`value2`</ph>, the branch operation is performed.</source>
          <target state="translated"><ph id="ph1">`value2`</ph> e <ph id="ph2">`value1`</ph> são disparados da pilha; se <ph id="ph3">`value1`</ph> é menor que ou igual a <ph id="ph4">`value2`</ph>, a operação de ramificação é executada.</target>       </trans-unit>
        <trans-unit id="475" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ble_S">
          <source>The <ph id="ph1">`ble.s`</ph> instruction transfers control to the specified target instruction if <ph id="ph2">`value1`</ph> is less than or equal to <ph id="ph3">`value2`</ph>.</source>
          <target state="translated">O <ph id="ph1">`ble.s`</ph> instrução transfere o controle para a instrução de destino especificado se <ph id="ph2">`value1`</ph> é menor que ou igual a <ph id="ph3">`value2`</ph>.</target>       </trans-unit>
        <trans-unit id="476" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ble_S">
          <source>The effect is identical to performing a <ph id="ph1">`cgt`</ph> instruction (<ph id="ph2">`cgt.un`</ph> for floats) instruction followed by a<ph id="ph3">`brfalse`</ph> branch to the specific target instruction.</source>
          <target state="translated">O efeito é idêntico ao executar uma <ph id="ph1">`cgt`</ph> instrução (<ph id="ph2">`cgt.un`</ph> para flutuações) instrução seguida por um<ph id="ph3">`brfalse`</ph> ramificação para a instrução de destino específico.</target>       </trans-unit>
        <trans-unit id="477" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ble_S">
          <source>The target instruction is represented as a 1-byte signed offset from the beginning of the instruction following the current instruction.</source>
          <target state="translated">A instrução de destino é representada como um deslocamento de 1 byte assinado desde o início da instrução após a instrução atual.</target>       </trans-unit>
        <trans-unit id="478" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ble_S">
          <source>If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</source>
          <target state="translated">Se a instrução de destino tem um ou mais códigos de prefixo, o controle só pode ser transferido para o primeiro desses prefixos.</target>       </trans-unit>
        <trans-unit id="479" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ble_S">
          <source>Control transfers into and out of <ph id="ph1">`try`</ph>, <ph id="ph2">`catch`</ph>, <ph id="ph3">`filter`</ph>, and <ph id="ph4">`finally`</ph> blocks cannot be performed by this instruction.</source>
          <target state="translated">O controle transfere dentro e fora do <ph id="ph1">`try`</ph>, <ph id="ph2">`catch`</ph>, <ph id="ph3">`filter`</ph>, e <ph id="ph4">`finally`</ph> blocos não podem ser executados por essa instrução.</target>       </trans-unit>
        <trans-unit id="480" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ble_S">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`ble.s`</ph> opcode:</source>
          <target state="translated">O seguinte <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> sobrecarga de método pode usar o <ph id="ph2">`ble.s`</ph> opcode:</target>       </trans-unit>
        <trans-unit id="481" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ble_S">
          <source>ILGenerator.Emit(OpCode, Label)</source>
          <target state="translated">ILGenerator.Emit(OpCode, Label)</target>       </trans-unit>
        <trans-unit id="482" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Ble_Un">
          <source>Transfers control to a target instruction if the first value is less than or equal to the second value, when comparing unsigned integer values or unordered float values.</source>
          <target state="translated">Transferirá o controle para uma instrução de destino se o primeiro valor for menor ou igual ao segundo valor ao comparar valores de inteiro sem sinal ou valores float não ordenados.</target>       </trans-unit>
        <trans-unit id="483" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ble_Un">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">A tabela a seguir lista as instruções hexadecimal e formato de assembly do Microsoft Intermediate Language (MSIL), junto com um resumo breve de referência:</target>       </trans-unit>
        <trans-unit id="484" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ble_Un">
          <source>Format</source>
          <target state="translated">Formatar</target>       </trans-unit>
        <trans-unit id="485" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ble_Un">
          <source>Assembly Format</source>
          <target state="translated">Formato de assembly</target>       </trans-unit>
        <trans-unit id="486" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ble_Un">
          <source>Description</source>
          <target state="translated">Descrição</target>       </trans-unit>
        <trans-unit id="487" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ble_Un">
          <source>43 <ph id="ph1">`&lt;int32&gt;`</ph></source>
          <target state="translated">43 <ph id="ph1">`&lt;int32&gt;`</ph></target>       </trans-unit>
        <trans-unit id="488" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ble_Un">
          <source>ble.un <ph id="ph1">`target`</ph></source>
          <target state="translated">ble.Un <ph id="ph1">`target`</ph></target>       </trans-unit>
        <trans-unit id="489" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ble_Un">
          <source>Branch to the target instruction at the specified offset if the first value is less than or equal to the second value (unsigned values).</source>
          <target state="translated">Ramificação a instrução de destino no deslocamento especificado se o primeiro valor é menor ou igual ao segundo valor (valores sem sinal).</target>       </trans-unit>
        <trans-unit id="490" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ble_Un">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">O comportamento de transição de pilha, em ordem sequencial, é:</target>       </trans-unit>
        <trans-unit id="491" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ble_Un">
          <source><ph id="ph1">`value1`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value1`</ph> é inserido na pilha.</target>       </trans-unit>
        <trans-unit id="492" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ble_Un">
          <source><ph id="ph1">`value2`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value2`</ph> é inserido na pilha.</target>       </trans-unit>
        <trans-unit id="493" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ble_Un">
          <source><ph id="ph1">`value2`</ph> and <ph id="ph2">`value1`</ph> are popped from the stack; if <ph id="ph3">`value1`</ph> is less than or equal to <ph id="ph4">`value2`</ph>, the branch operation is performed.</source>
          <target state="translated"><ph id="ph1">`value2`</ph> e <ph id="ph2">`value1`</ph> são disparados da pilha; se <ph id="ph3">`value1`</ph> é menor que ou igual a <ph id="ph4">`value2`</ph>, a operação de ramificação é executada.</target>       </trans-unit>
        <trans-unit id="494" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ble_Un">
          <source>The <ph id="ph1">`ble.un`</ph> instruction transfers control to the specified target instruction if <ph id="ph2">`value1`</ph> is less than or equal to <ph id="ph3">`value2`</ph>, when compared using unsigned integer or unordered float values.</source>
          <target state="translated">O <ph id="ph1">`ble.un`</ph> instrução transfere o controle para a instrução de destino especificado se <ph id="ph2">`value1`</ph> é menor que ou igual a <ph id="ph3">`value2`</ph>, quando comparados com valores de float não ordenada ou inteiro não assinado.</target>       </trans-unit>
        <trans-unit id="495" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ble_Un">
          <source>The effect is identical to performing a <ph id="ph1">`cgt.un`</ph> instruction (<ph id="ph2">`cgt`</ph> for floats) followed by a <ph id="ph3">`brfalse`</ph> branch to the specific target instruction.</source>
          <target state="translated">O efeito é idêntico ao executar uma <ph id="ph1">`cgt.un`</ph> instrução (<ph id="ph2">`cgt`</ph> para flutuações) seguido por um <ph id="ph3">`brfalse`</ph> ramificação para a instrução de destino específico.</target>       </trans-unit>
        <trans-unit id="496" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ble_Un">
          <source>The target instruction is represented as a 4-byte signed offset from the beginning of the instruction following the current instruction.</source>
          <target state="translated">A instrução de destino é representada como um deslocamento assinado de 4 bytes do início da instrução após a instrução atual.</target>       </trans-unit>
        <trans-unit id="497" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ble_Un">
          <source>If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</source>
          <target state="translated">Se a instrução de destino tem um ou mais códigos de prefixo, o controle só pode ser transferido para o primeiro desses prefixos.</target>       </trans-unit>
        <trans-unit id="498" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ble_Un">
          <source>Control transfers into and out of <ph id="ph1">`try`</ph>, <ph id="ph2">`catch`</ph>, <ph id="ph3">`filter`</ph>, and <ph id="ph4">`finally`</ph> blocks cannot be performed by this instruction.</source>
          <target state="translated">O controle transfere dentro e fora do <ph id="ph1">`try`</ph>, <ph id="ph2">`catch`</ph>, <ph id="ph3">`filter`</ph>, e <ph id="ph4">`finally`</ph> blocos não podem ser executados por essa instrução.</target>       </trans-unit>
        <trans-unit id="499" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ble_Un">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`ble.un`</ph> opcode:</source>
          <target state="translated">O seguinte <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> sobrecarga de método pode usar o <ph id="ph2">`ble.un`</ph> opcode:</target>       </trans-unit>
        <trans-unit id="500" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ble_Un">
          <source>ILGenerator.Emit(OpCode, Label)</source>
          <target state="translated">ILGenerator.Emit(OpCode, Label)</target>       </trans-unit>
        <trans-unit id="501" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Ble_Un_S">
          <source>Transfers control to a target instruction (short form) if the first value is less than or equal to the second value, when comparing unsigned integer values or unordered float values.</source>
          <target state="translated">Transferirá o controle para uma instrução de destino (forma abreviada) se o primeiro valor for menor ou igual ao segundo valor ao comparar valores de inteiro sem sinal ou valores float não ordenados.</target>       </trans-unit>
        <trans-unit id="502" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ble_Un_S">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">A tabela a seguir lista as instruções hexadecimal e formato de assembly do Microsoft Intermediate Language (MSIL), junto com um resumo breve de referência:</target>       </trans-unit>
        <trans-unit id="503" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ble_Un_S">
          <source>Format</source>
          <target state="translated">Formatar</target>       </trans-unit>
        <trans-unit id="504" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ble_Un_S">
          <source>Assembly Format</source>
          <target state="translated">Formato de assembly</target>       </trans-unit>
        <trans-unit id="505" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ble_Un_S">
          <source>Description</source>
          <target state="translated">Descrição</target>       </trans-unit>
        <trans-unit id="506" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ble_Un_S">
          <source>36 <ph id="ph1">`&lt;int8&gt;`</ph></source>
          <target state="translated">36 <ph id="ph1">`&lt;int8&gt;`</ph></target>       </trans-unit>
        <trans-unit id="507" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ble_Un_S">
          <source>ble.un.s <ph id="ph1">`target`</ph></source>
          <target state="translated">ble.un.s <ph id="ph1">`target`</ph></target>       </trans-unit>
        <trans-unit id="508" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ble_Un_S">
          <source>Branch to the target instruction at the specified offset if the first value is less than or equal to the second value (unsigned values), short form.</source>
          <target state="translated">Ramificação a instrução de destino no deslocamento especificado se o primeiro valor é menor ou igual ao segundo valor (valores sem sinal), forma abreviada.</target>       </trans-unit>
        <trans-unit id="509" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ble_Un_S">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">O comportamento de transição de pilha, em ordem sequencial, é:</target>       </trans-unit>
        <trans-unit id="510" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ble_Un_S">
          <source><ph id="ph1">`value1`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value1`</ph> é inserido na pilha.</target>       </trans-unit>
        <trans-unit id="511" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ble_Un_S">
          <source><ph id="ph1">`value2`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value2`</ph> é inserido na pilha.</target>       </trans-unit>
        <trans-unit id="512" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ble_Un_S">
          <source><ph id="ph1">`value2`</ph> and <ph id="ph2">`value1`</ph> are popped from the stack; if <ph id="ph3">`value1`</ph> is less than or equal to <ph id="ph4">`value2`</ph>, the branch operation is performed.</source>
          <target state="translated"><ph id="ph1">`value2`</ph> e <ph id="ph2">`value1`</ph> são disparados da pilha; se <ph id="ph3">`value1`</ph> é menor que ou igual a <ph id="ph4">`value2`</ph>, a operação de ramificação é executada.</target>       </trans-unit>
        <trans-unit id="513" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ble_Un_S">
          <source>The <ph id="ph1">`ble.un.s`</ph> instruction transfers control to the specified target instruction if <ph id="ph2">`value1`</ph> is less than or equal to <ph id="ph3">`value2`</ph>, when compared using unsigned integer or unordered float values.</source>
          <target state="translated">O <ph id="ph1">`ble.un.s`</ph> instrução transfere o controle para a instrução de destino especificado se <ph id="ph2">`value1`</ph> é menor que ou igual a <ph id="ph3">`value2`</ph>, quando comparados com valores de float não ordenada ou inteiro não assinado.</target>       </trans-unit>
        <trans-unit id="514" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ble_Un_S">
          <source>The effect is identical to performing a <ph id="ph1">`cgt.un`</ph> instruction (<ph id="ph2">`cgt`</ph> for floats) followed by a <ph id="ph3">`brfalse`</ph> branch to the specific target instruction.</source>
          <target state="translated">O efeito é idêntico ao executar uma <ph id="ph1">`cgt.un`</ph> instrução (<ph id="ph2">`cgt`</ph> para flutuações) seguido por um <ph id="ph3">`brfalse`</ph> ramificação para a instrução de destino específico.</target>       </trans-unit>
        <trans-unit id="515" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ble_Un_S">
          <source>The target instruction is represented as a 1-byte signed offset from the beginning of the instruction following the current instruction.</source>
          <target state="translated">A instrução de destino é representada como um deslocamento de 1 byte assinado desde o início da instrução após a instrução atual.</target>       </trans-unit>
        <trans-unit id="516" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ble_Un_S">
          <source>If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</source>
          <target state="translated">Se a instrução de destino tem um ou mais códigos de prefixo, o controle só pode ser transferido para o primeiro desses prefixos.</target>       </trans-unit>
        <trans-unit id="517" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ble_Un_S">
          <source>Control transfers into and out of <ph id="ph1">`try`</ph>, <ph id="ph2">`catch`</ph>, <ph id="ph3">`filter`</ph>, and <ph id="ph4">`finally`</ph> blocks cannot be performed by this instruction.</source>
          <target state="translated">O controle transfere dentro e fora do <ph id="ph1">`try`</ph>, <ph id="ph2">`catch`</ph>, <ph id="ph3">`filter`</ph>, e <ph id="ph4">`finally`</ph> blocos não podem ser executados por essa instrução.</target>       </trans-unit>
        <trans-unit id="518" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ble_Un_S">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`ble.un.s`</ph> opcode:</source>
          <target state="translated">O seguinte <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> sobrecarga de método pode usar o <ph id="ph2">`ble.un.s`</ph> opcode:</target>       </trans-unit>
        <trans-unit id="519" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ble_Un_S">
          <source>ILGenerator.Emit(OpCode, Label)</source>
          <target state="translated">ILGenerator.Emit(OpCode, Label)</target>       </trans-unit>
        <trans-unit id="520" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Blt">
          <source>Transfers control to a target instruction if the first value is less than the second value.</source>
          <target state="translated">Transferirá controle para uma instrução de destino se o primeiro valor for menor que o segundo valor.</target>       </trans-unit>
        <trans-unit id="521" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Blt">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">A tabela a seguir lista as instruções hexadecimal e formato de assembly do Microsoft Intermediate Language (MSIL), junto com um resumo breve de referência:</target>       </trans-unit>
        <trans-unit id="522" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Blt">
          <source>Format</source>
          <target state="translated">Formatar</target>       </trans-unit>
        <trans-unit id="523" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Blt">
          <source>Assembly Format</source>
          <target state="translated">Formato de assembly</target>       </trans-unit>
        <trans-unit id="524" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Blt">
          <source>Description</source>
          <target state="translated">Descrição</target>       </trans-unit>
        <trans-unit id="525" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Blt">
          <source>3F &lt; <ph id="ph1">`int32`</ph><ph id="ph2"> &gt;</ph></source>
          <target state="translated">3F &lt; <ph id="ph1">`int32`</ph><ph id="ph2"> &gt;</ph></target>       </trans-unit>
        <trans-unit id="526" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Blt">
          <source>blt <ph id="ph1">`target`</ph></source>
          <target state="translated">blt <ph id="ph1">`target`</ph></target>       </trans-unit>
        <trans-unit id="527" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Blt">
          <source>Branch to the target instruction at the specified offset if the first value is less than the second value.</source>
          <target state="translated">Ramificação para a instrução de destino no deslocamento especificado se o primeiro valor é menor que o segundo valor.</target>       </trans-unit>
        <trans-unit id="528" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Blt">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">O comportamento de transição de pilha, em ordem sequencial, é:</target>       </trans-unit>
        <trans-unit id="529" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Blt">
          <source><ph id="ph1">`value1`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value1`</ph> é inserido na pilha.</target>       </trans-unit>
        <trans-unit id="530" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Blt">
          <source><ph id="ph1">`value2`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value2`</ph> é inserido na pilha.</target>       </trans-unit>
        <trans-unit id="531" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Blt">
          <source><ph id="ph1">`value2`</ph> and <ph id="ph2">`value1`</ph> are popped from the stack; if <ph id="ph3">`value1`</ph> is less than <ph id="ph4">`value2`</ph>, the branch operation is performed.</source>
          <target state="translated"><ph id="ph1">`value2`</ph> e <ph id="ph2">`value1`</ph> são disparados da pilha; se <ph id="ph3">`value1`</ph> é menor que <ph id="ph4">`value2`</ph>, a operação de ramificação é executada.</target>       </trans-unit>
        <trans-unit id="532" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Blt">
          <source>The <ph id="ph1">`blt`</ph> instruction transfers control to the specified target instruction if <ph id="ph2">`value1`</ph> is less than or equal to <ph id="ph3">`value2`</ph>.</source>
          <target state="translated">O <ph id="ph1">`blt`</ph> instrução transfere o controle para a instrução de destino especificado se <ph id="ph2">`value1`</ph> é menor que ou igual a <ph id="ph3">`value2`</ph>.</target>       </trans-unit>
        <trans-unit id="533" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Blt">
          <source>The effect is identical to performing a <ph id="ph1">`clt`</ph> instruction followed by a <ph id="ph2">`brtrue`</ph> branch to the specific target instruction.</source>
          <target state="translated">O efeito é idêntico ao executar uma <ph id="ph1">`clt`</ph> instrução seguida por um <ph id="ph2">`brtrue`</ph> ramificação para a instrução de destino específico.</target>       </trans-unit>
        <trans-unit id="534" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Blt">
          <source>The target instruction is represented as a 4-byte signed offset from the beginning of the instruction following the current instruction.</source>
          <target state="translated">A instrução de destino é representada como um deslocamento assinado de 4 bytes do início da instrução após a instrução atual.</target>       </trans-unit>
        <trans-unit id="535" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Blt">
          <source>If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</source>
          <target state="translated">Se a instrução de destino tem um ou mais códigos de prefixo, o controle só pode ser transferido para o primeiro desses prefixos.</target>       </trans-unit>
        <trans-unit id="536" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Blt">
          <source>Control transfers into and out of <ph id="ph1">`try`</ph>, <ph id="ph2">`catch`</ph>, <ph id="ph3">`filter`</ph>, and <ph id="ph4">`finally`</ph> blocks cannot be performed by this instruction.</source>
          <target state="translated">O controle transfere dentro e fora do <ph id="ph1">`try`</ph>, <ph id="ph2">`catch`</ph>, <ph id="ph3">`filter`</ph>, e <ph id="ph4">`finally`</ph> blocos não podem ser executados por essa instrução.</target>       </trans-unit>
        <trans-unit id="537" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Blt">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`blt`</ph> opcode:</source>
          <target state="translated">O seguinte <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> sobrecarga de método pode usar o <ph id="ph2">`blt`</ph> opcode:</target>       </trans-unit>
        <trans-unit id="538" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Blt">
          <source>ILGenerator.Emit(OpCode, Label)</source>
          <target state="translated">ILGenerator.Emit(OpCode, Label)</target>       </trans-unit>
        <trans-unit id="539" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Blt_S">
          <source>Transfers control to a target instruction (short form) if the first value is less than the second value.</source>
          <target state="translated">Transferirá controle para uma instrução de destino (forma abreviada) se o primeiro valor for menor que o segundo valor.</target>       </trans-unit>
        <trans-unit id="540" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Blt_S">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">A tabela a seguir lista as instruções hexadecimal e formato de assembly do Microsoft Intermediate Language (MSIL), junto com um resumo breve de referência:</target>       </trans-unit>
        <trans-unit id="541" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Blt_S">
          <source>Format</source>
          <target state="translated">Formatar</target>       </trans-unit>
        <trans-unit id="542" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Blt_S">
          <source>Assembly Format</source>
          <target state="translated">Formato de assembly</target>       </trans-unit>
        <trans-unit id="543" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Blt_S">
          <source>Description</source>
          <target state="translated">Descrição</target>       </trans-unit>
        <trans-unit id="544" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Blt_S">
          <source>32 &lt; <ph id="ph1">`int8`</ph><ph id="ph2"> &gt;</ph></source>
          <target state="translated">32 &lt; <ph id="ph1">`int8`</ph><ph id="ph2"> &gt;</ph></target>       </trans-unit>
        <trans-unit id="545" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Blt_S">
          <source>blt.s <ph id="ph1">`target`</ph></source>
          <target state="translated">blt.s <ph id="ph1">`target`</ph></target>       </trans-unit>
        <trans-unit id="546" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Blt_S">
          <source>Branch to the target instruction at the specified offset if the first value is less than the second value, short form.</source>
          <target state="translated">Ramificação para a instrução de destino no deslocamento especificado se o primeiro valor é menor que o segundo valor, de forma abreviada.</target>       </trans-unit>
        <trans-unit id="547" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Blt_S">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">O comportamento de transição de pilha, em ordem sequencial, é:</target>       </trans-unit>
        <trans-unit id="548" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Blt_S">
          <source><ph id="ph1">`value1`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value1`</ph> é inserido na pilha.</target>       </trans-unit>
        <trans-unit id="549" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Blt_S">
          <source><ph id="ph1">`value2`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value2`</ph> é inserido na pilha.</target>       </trans-unit>
        <trans-unit id="550" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Blt_S">
          <source><ph id="ph1">`value2`</ph> and <ph id="ph2">`value1`</ph> are popped from the stack; if <ph id="ph3">`value1`</ph> is less than <ph id="ph4">`value2`</ph>, the branch operation is performed.</source>
          <target state="translated"><ph id="ph1">`value2`</ph> e <ph id="ph2">`value1`</ph> são disparados da pilha; se <ph id="ph3">`value1`</ph> é menor que <ph id="ph4">`value2`</ph>, a operação de ramificação é executada.</target>       </trans-unit>
        <trans-unit id="551" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Blt_S">
          <source>The <ph id="ph1">`blt.s`</ph> instruction transfers control to the specified target instruction if <ph id="ph2">`value1`</ph> is less than <ph id="ph3">`value2`</ph>.</source>
          <target state="translated">O <ph id="ph1">`blt.s`</ph> instrução transfere o controle para a instrução de destino especificado se <ph id="ph2">`value1`</ph> é menor que <ph id="ph3">`value2`</ph>.</target>       </trans-unit>
        <trans-unit id="552" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Blt_S">
          <source>The effect is identical to performing a <ph id="ph1">`clt`</ph> instruction followed by a <ph id="ph2">`brtrue`</ph> branch to the specific target instruction.</source>
          <target state="translated">O efeito é idêntico ao executar uma <ph id="ph1">`clt`</ph> instrução seguida por um <ph id="ph2">`brtrue`</ph> ramificação para a instrução de destino específico.</target>       </trans-unit>
        <trans-unit id="553" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Blt_S">
          <source>The target instruction is represented as a 1-byte signed offset from the beginning of the instruction following the current instruction.</source>
          <target state="translated">A instrução de destino é representada como um deslocamento de 1 byte assinado desde o início da instrução após a instrução atual.</target>       </trans-unit>
        <trans-unit id="554" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Blt_S">
          <source>If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</source>
          <target state="translated">Se a instrução de destino tem um ou mais códigos de prefixo, o controle só pode ser transferido para o primeiro desses prefixos.</target>       </trans-unit>
        <trans-unit id="555" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Blt_S">
          <source>Control transfers into and out of <ph id="ph1">`try`</ph>, <ph id="ph2">`catch`</ph>, <ph id="ph3">`filter`</ph>, and <ph id="ph4">`finally`</ph> blocks cannot be performed by this instruction.</source>
          <target state="translated">O controle transfere dentro e fora do <ph id="ph1">`try`</ph>, <ph id="ph2">`catch`</ph>, <ph id="ph3">`filter`</ph>, e <ph id="ph4">`finally`</ph> blocos não podem ser executados por essa instrução.</target>       </trans-unit>
        <trans-unit id="556" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Blt_S">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`blt.s`</ph> opcode:</source>
          <target state="translated">O seguinte <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> sobrecarga de método pode usar o <ph id="ph2">`blt.s`</ph> opcode:</target>       </trans-unit>
        <trans-unit id="557" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Blt_S">
          <source>ILGenerator.Emit(OpCode, Label)</source>
          <target state="translated">ILGenerator.Emit(OpCode, Label)</target>       </trans-unit>
        <trans-unit id="558" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Blt_Un">
          <source>Transfers control to a target instruction if the first value is less than the second value, when comparing unsigned integer values or unordered float values.</source>
          <target state="translated">Transferirá o controle para uma instrução de destino se o primeiro valor for menor que o segundo valor ao comparar valores de inteiro sem sinal ou valores float não ordenados.</target>       </trans-unit>
        <trans-unit id="559" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Blt_Un">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">A tabela a seguir lista as instruções hexadecimal e formato de assembly do Microsoft Intermediate Language (MSIL), junto com um resumo breve de referência:</target>       </trans-unit>
        <trans-unit id="560" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Blt_Un">
          <source>Format</source>
          <target state="translated">Formatar</target>       </trans-unit>
        <trans-unit id="561" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Blt_Un">
          <source>Assembly Format</source>
          <target state="translated">Formato de assembly</target>       </trans-unit>
        <trans-unit id="562" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Blt_Un">
          <source>Description</source>
          <target state="translated">Descrição</target>       </trans-unit>
        <trans-unit id="563" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Blt_Un">
          <source>44 &lt; <ph id="ph1">`int32`</ph><ph id="ph2"> &gt;</ph></source>
          <target state="translated">44 &lt; <ph id="ph1">`int32`</ph><ph id="ph2"> &gt;</ph></target>       </trans-unit>
        <trans-unit id="564" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Blt_Un">
          <source>blt.un <ph id="ph1">`target`</ph></source>
          <target state="translated">blt.Un <ph id="ph1">`target`</ph></target>       </trans-unit>
        <trans-unit id="565" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Blt_Un">
          <source>Branch to the target instruction at the specified offset if the first value is less than the second value (unsigned values).</source>
          <target state="translated">Ramificação para a instrução de destino no deslocamento especificado se o primeiro valor é menor que o valor de segundo (valores sem sinal).</target>       </trans-unit>
        <trans-unit id="566" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Blt_Un">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">O comportamento de transição de pilha, em ordem sequencial, é:</target>       </trans-unit>
        <trans-unit id="567" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Blt_Un">
          <source><ph id="ph1">`value1`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value1`</ph> é inserido na pilha.</target>       </trans-unit>
        <trans-unit id="568" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Blt_Un">
          <source><ph id="ph1">`value2`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value2`</ph> é inserido na pilha.</target>       </trans-unit>
        <trans-unit id="569" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Blt_Un">
          <source><ph id="ph1">`value2`</ph> and <ph id="ph2">`value1`</ph> are popped from the stack; if <ph id="ph3">`value1`</ph> is less than <ph id="ph4">`value2`</ph>, the branch operation is performed.</source>
          <target state="translated"><ph id="ph1">`value2`</ph> e <ph id="ph2">`value1`</ph> são disparados da pilha; se <ph id="ph3">`value1`</ph> é menor que <ph id="ph4">`value2`</ph>, a operação de ramificação é executada.</target>       </trans-unit>
        <trans-unit id="570" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Blt_Un">
          <source>The <ph id="ph1">`blt.un`</ph> instruction transfers control to the specified target instruction if <ph id="ph2">`value1`</ph> is less than <ph id="ph3">`value2`</ph>, when compared using unsigned integer or unordered float values.</source>
          <target state="translated">O <ph id="ph1">`blt.un`</ph> instrução transfere o controle para a instrução de destino especificado se <ph id="ph2">`value1`</ph> é menor que <ph id="ph3">`value2`</ph>, quando comparados com valores de float não ordenada ou inteiro não assinado.</target>       </trans-unit>
        <trans-unit id="571" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Blt_Un">
          <source>The effect is identical to performing a <ph id="ph1">`clt.un`</ph> instruction followed by a <ph id="ph2">`brtrue`</ph> branch to the specific target instruction.</source>
          <target state="translated">O efeito é idêntico ao executar uma <ph id="ph1">`clt.un`</ph> instrução seguida por um <ph id="ph2">`brtrue`</ph> ramificação para a instrução de destino específico.</target>       </trans-unit>
        <trans-unit id="572" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Blt_Un">
          <source>The target instruction is represented as a 4-byte signed offset from the beginning of the instruction following the current instruction.</source>
          <target state="translated">A instrução de destino é representada como um deslocamento assinado de 4 bytes do início da instrução após a instrução atual.</target>       </trans-unit>
        <trans-unit id="573" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Blt_Un">
          <source>If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</source>
          <target state="translated">Se a instrução de destino tem um ou mais códigos de prefixo, o controle só pode ser transferido para o primeiro desses prefixos.</target>       </trans-unit>
        <trans-unit id="574" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Blt_Un">
          <source>Control transfers into and out of <ph id="ph1">`try`</ph>, <ph id="ph2">`catch`</ph>, <ph id="ph3">`filter`</ph>, and <ph id="ph4">`finally`</ph> blocks cannot be performed by this instruction.</source>
          <target state="translated">O controle transfere dentro e fora do <ph id="ph1">`try`</ph>, <ph id="ph2">`catch`</ph>, <ph id="ph3">`filter`</ph>, e <ph id="ph4">`finally`</ph> blocos não podem ser executados por essa instrução.</target>       </trans-unit>
        <trans-unit id="575" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Blt_Un">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`blt.un`</ph> opcode:</source>
          <target state="translated">O seguinte <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> sobrecarga de método pode usar o <ph id="ph2">`blt.un`</ph> opcode:</target>       </trans-unit>
        <trans-unit id="576" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Blt_Un">
          <source>ILGenerator.Emit(OpCode, Label)</source>
          <target state="translated">ILGenerator.Emit(OpCode, Label)</target>       </trans-unit>
        <trans-unit id="577" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Blt_Un_S">
          <source>Transfers control to a target instruction (short form) if the first value is less than the second value, when comparing unsigned integer values or unordered float values.</source>
          <target state="translated">Transferirá o controle para uma instrução de destino (forma abreviada) se o primeiro valor for menor que o segundo valor ao comparar valores de inteiro sem sinal ou valores float não ordenados.</target>       </trans-unit>
        <trans-unit id="578" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Blt_Un_S">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">A tabela a seguir lista as instruções hexadecimal e formato de assembly do Microsoft Intermediate Language (MSIL), junto com um resumo breve de referência:</target>       </trans-unit>
        <trans-unit id="579" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Blt_Un_S">
          <source>Format</source>
          <target state="translated">Formatar</target>       </trans-unit>
        <trans-unit id="580" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Blt_Un_S">
          <source>Assembly Format</source>
          <target state="translated">Formato de assembly</target>       </trans-unit>
        <trans-unit id="581" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Blt_Un_S">
          <source>Description</source>
          <target state="translated">Descrição</target>       </trans-unit>
        <trans-unit id="582" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Blt_Un_S">
          <source>37 &lt; <ph id="ph1">`int8`</ph><ph id="ph2"> &gt;</ph></source>
          <target state="translated">37 &lt; <ph id="ph1">`int8`</ph><ph id="ph2"> &gt;</ph></target>       </trans-unit>
        <trans-unit id="583" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Blt_Un_S">
          <source>blt.un.s <ph id="ph1">`target`</ph></source>
          <target state="translated">blt.un.s <ph id="ph1">`target`</ph></target>       </trans-unit>
        <trans-unit id="584" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Blt_Un_S">
          <source>Branch to the target instruction at the specified offset if the first value is less than the second value (unsigned values), short form.</source>
          <target state="translated">Ramificação para a instrução de destino no deslocamento especificado se o primeiro valor é menor que o segundo valor (valores sem sinal), forma abreviada.</target>       </trans-unit>
        <trans-unit id="585" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Blt_Un_S">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">O comportamento de transição de pilha, em ordem sequencial, é:</target>       </trans-unit>
        <trans-unit id="586" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Blt_Un_S">
          <source><ph id="ph1">`value1`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value1`</ph> é inserido na pilha.</target>       </trans-unit>
        <trans-unit id="587" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Blt_Un_S">
          <source><ph id="ph1">`value2`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value2`</ph> é inserido na pilha.</target>       </trans-unit>
        <trans-unit id="588" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Blt_Un_S">
          <source><ph id="ph1">`value2`</ph> and <ph id="ph2">`value1`</ph> are popped from the stack; if <ph id="ph3">`value1`</ph> is less than <ph id="ph4">`value2`</ph>, the branch operation is performed.</source>
          <target state="translated"><ph id="ph1">`value2`</ph> e <ph id="ph2">`value1`</ph> são disparados da pilha; se <ph id="ph3">`value1`</ph> é menor que <ph id="ph4">`value2`</ph>, a operação de ramificação é executada.</target>       </trans-unit>
        <trans-unit id="589" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Blt_Un_S">
          <source>The <ph id="ph1">`blt.un`</ph> instruction transfers control to the specified target instruction if <ph id="ph2">`value1`</ph> is less than <ph id="ph3">`value2`</ph>, when compared using unsigned integer or unordered float values.</source>
          <target state="translated">O <ph id="ph1">`blt.un`</ph> instrução transfere o controle para a instrução de destino especificado se <ph id="ph2">`value1`</ph> é menor que <ph id="ph3">`value2`</ph>, quando comparados com valores de float não ordenada ou inteiro não assinado.</target>       </trans-unit>
        <trans-unit id="590" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Blt_Un_S">
          <source>The effect is identical to performing a <ph id="ph1">`clt.un`</ph> instruction followed by a <ph id="ph2">`brtrue`</ph> branch to the specific target instruction.</source>
          <target state="translated">O efeito é idêntico ao executar uma <ph id="ph1">`clt.un`</ph> instrução seguida por um <ph id="ph2">`brtrue`</ph> ramificação para a instrução de destino específico.</target>       </trans-unit>
        <trans-unit id="591" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Blt_Un_S">
          <source>The target instruction is represented as a 4-byte signed offset from the beginning of the instruction following the current instruction.</source>
          <target state="translated">A instrução de destino é representada como um deslocamento assinado de 4 bytes do início da instrução após a instrução atual.</target>       </trans-unit>
        <trans-unit id="592" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Blt_Un_S">
          <source>If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</source>
          <target state="translated">Se a instrução de destino tem um ou mais códigos de prefixo, o controle só pode ser transferido para o primeiro desses prefixos.</target>       </trans-unit>
        <trans-unit id="593" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Blt_Un_S">
          <source>Control transfers into and out of <ph id="ph1">`try`</ph>, <ph id="ph2">`catch`</ph>, <ph id="ph3">`filter`</ph>, and <ph id="ph4">`finally`</ph> blocks cannot be performed by this instruction.</source>
          <target state="translated">O controle transfere dentro e fora do <ph id="ph1">`try`</ph>, <ph id="ph2">`catch`</ph>, <ph id="ph3">`filter`</ph>, e <ph id="ph4">`finally`</ph> blocos não podem ser executados por essa instrução.</target>       </trans-unit>
        <trans-unit id="594" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Blt_Un_S">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`blt.un.s`</ph> opcode:</source>
          <target state="translated">O seguinte <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> sobrecarga de método pode usar o <ph id="ph2">`blt.un.s`</ph> opcode:</target>       </trans-unit>
        <trans-unit id="595" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Blt_Un_S">
          <source>ILGenerator.Emit(OpCode, Label)</source>
          <target state="translated">ILGenerator.Emit(OpCode, Label)</target>       </trans-unit>
        <trans-unit id="596" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Bne_Un">
          <source>Transfers control to a target instruction when two unsigned integer values or unordered float values are not equal.</source>
          <target state="translated">Transfere o controle para uma instrução de destino quando dois valores de inteiro sem sinal ou valores de float não ordenados não são iguais.</target>       </trans-unit>
        <trans-unit id="597" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bne_Un">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">A tabela a seguir lista as instruções hexadecimal e formato de assembly do Microsoft Intermediate Language (MSIL), junto com um resumo breve de referência:</target>       </trans-unit>
        <trans-unit id="598" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bne_Un">
          <source>Format</source>
          <target state="translated">Formatar</target>       </trans-unit>
        <trans-unit id="599" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bne_Un">
          <source>Assembly Format</source>
          <target state="translated">Formato de assembly</target>       </trans-unit>
        <trans-unit id="600" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bne_Un">
          <source>Description</source>
          <target state="translated">Descrição</target>       </trans-unit>
        <trans-unit id="601" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bne_Un">
          <source>40 &lt; <ph id="ph1">`int32`</ph><ph id="ph2"> &gt;</ph></source>
          <target state="translated">40 &lt; <ph id="ph1">`int32`</ph><ph id="ph2"> &gt;</ph></target>       </trans-unit>
        <trans-unit id="602" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bne_Un">
          <source>bne.un <ph id="ph1">`target`</ph></source>
          <target state="translated">bne.Un <ph id="ph1">`target`</ph></target>       </trans-unit>
        <trans-unit id="603" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bne_Un">
          <source>Branch to the target instruction at the specified offset if two unsigned integer values are not equal (unsigned values).</source>
          <target state="translated">Ramificação para o destino de instrução no deslocamento especificado se dois valores inteiros sem sinal são não igual (valores sem sinal).</target>       </trans-unit>
        <trans-unit id="604" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bne_Un">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">O comportamento de transição de pilha, em ordem sequencial, é:</target>       </trans-unit>
        <trans-unit id="605" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bne_Un">
          <source><ph id="ph1">`value1`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value1`</ph> é inserido na pilha.</target>       </trans-unit>
        <trans-unit id="606" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bne_Un">
          <source><ph id="ph1">`value2`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value2`</ph> é inserido na pilha.</target>       </trans-unit>
        <trans-unit id="607" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bne_Un">
          <source><ph id="ph1">`value2`</ph> and <ph id="ph2">`value1`</ph> are popped from the stack; if <ph id="ph3">`value1`</ph> is not equal to <ph id="ph4">`value2`</ph>, the branch operation is performed.</source>
          <target state="translated"><ph id="ph1">`value2`</ph> e <ph id="ph2">`value1`</ph> são disparados da pilha; se <ph id="ph3">`value1`</ph> não é igual a <ph id="ph4">`value2`</ph>, a operação de ramificação é executada.</target>       </trans-unit>
        <trans-unit id="608" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bne_Un">
          <source>The <ph id="ph1">`bne.un`</ph> instruction transfers control to the specified target instruction if <ph id="ph2">`value1`</ph> is not equal to <ph id="ph3">`value2`</ph>, when compared using unsigned integer or unordered float values.</source>
          <target state="translated">O <ph id="ph1">`bne.un`</ph> instrução transfere o controle para a instrução de destino especificado se <ph id="ph2">`value1`</ph> não é igual a <ph id="ph3">`value2`</ph>, quando comparados com valores de float não ordenada ou inteiro não assinado.</target>       </trans-unit>
        <trans-unit id="609" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bne_Un">
          <source>The effect is identical to performing a <ph id="ph1">`ceq`</ph> instruction followed by a <ph id="ph2">`brfalse`</ph> branch to the specific target instruction.</source>
          <target state="translated">O efeito é idêntico ao executar uma <ph id="ph1">`ceq`</ph> instrução seguida por um <ph id="ph2">`brfalse`</ph> ramificação para a instrução de destino específico.</target>       </trans-unit>
        <trans-unit id="610" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bne_Un">
          <source>The target instruction is represented as a 4-byte signed offset from the beginning of the instruction following the current instruction.</source>
          <target state="translated">A instrução de destino é representada como um deslocamento assinado de 4 bytes do início da instrução após a instrução atual.</target>       </trans-unit>
        <trans-unit id="611" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bne_Un">
          <source>If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</source>
          <target state="translated">Se a instrução de destino tem um ou mais códigos de prefixo, o controle só pode ser transferido para o primeiro desses prefixos.</target>       </trans-unit>
        <trans-unit id="612" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bne_Un">
          <source>Control transfers into and out of <ph id="ph1">`try`</ph>, <ph id="ph2">`catch`</ph>, <ph id="ph3">`filter`</ph>, and <ph id="ph4">`finally`</ph> blocks cannot be performed by this instruction.</source>
          <target state="translated">O controle transfere dentro e fora do <ph id="ph1">`try`</ph>, <ph id="ph2">`catch`</ph>, <ph id="ph3">`filter`</ph>, e <ph id="ph4">`finally`</ph> blocos não podem ser executados por essa instrução.</target>       </trans-unit>
        <trans-unit id="613" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bne_Un">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`bne.un`</ph> opcode:</source>
          <target state="translated">O seguinte <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> sobrecarga de método pode usar o <ph id="ph2">`bne.un`</ph> opcode:</target>       </trans-unit>
        <trans-unit id="614" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bne_Un">
          <source>ILGenerator.Emit(OpCode, Label)</source>
          <target state="translated">ILGenerator.Emit(OpCode, Label)</target>       </trans-unit>
        <trans-unit id="615" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Bne_Un_S">
          <source>Transfers control to a target instruction (short form) when two unsigned integer values or unordered float values are not equal.</source>
          <target state="translated">Transfere o controle para uma instrução de destino (forma abreviada) quando dois valores inteiros sem sinal ou valores de float não ordenados não são iguais.</target>       </trans-unit>
        <trans-unit id="616" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bne_Un_S">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">A tabela a seguir lista as instruções hexadecimal e formato de assembly do Microsoft Intermediate Language (MSIL), junto com um resumo breve de referência:</target>       </trans-unit>
        <trans-unit id="617" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bne_Un_S">
          <source>Format</source>
          <target state="translated">Formatar</target>       </trans-unit>
        <trans-unit id="618" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bne_Un_S">
          <source>Assembly Format</source>
          <target state="translated">Formato de assembly</target>       </trans-unit>
        <trans-unit id="619" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bne_Un_S">
          <source>Description</source>
          <target state="translated">Descrição</target>       </trans-unit>
        <trans-unit id="620" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bne_Un_S">
          <source>33 &lt; <ph id="ph1">`int8`</ph><ph id="ph2"> &gt;</ph></source>
          <target state="translated">33 &lt; <ph id="ph1">`int8`</ph><ph id="ph2"> &gt;</ph></target>       </trans-unit>
        <trans-unit id="621" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bne_Un_S">
          <source>bne.un.s <ph id="ph1">`target`</ph></source>
          <target state="translated">bne.un.s <ph id="ph1">`target`</ph></target>       </trans-unit>
        <trans-unit id="622" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bne_Un_S">
          <source>Branch to the target instruction at the specified offset if two unsigned integer values are not equal (unsigned values), short form.</source>
          <target state="translated">Ramificação para o destino de instrução no deslocamento especificado se dois valores inteiros sem sinal são não igual (valores sem sinal), forma abreviada.</target>       </trans-unit>
        <trans-unit id="623" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bne_Un_S">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">O comportamento de transição de pilha, em ordem sequencial, é:</target>       </trans-unit>
        <trans-unit id="624" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bne_Un_S">
          <source><ph id="ph1">`value1`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value1`</ph> é inserido na pilha.</target>       </trans-unit>
        <trans-unit id="625" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bne_Un_S">
          <source><ph id="ph1">`value2`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value2`</ph> é inserido na pilha.</target>       </trans-unit>
        <trans-unit id="626" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bne_Un_S">
          <source><ph id="ph1">`value2`</ph> and <ph id="ph2">`value1`</ph> are popped from the stack; if <ph id="ph3">`value1`</ph> is not equal to <ph id="ph4">`value2`</ph>, the branch operation is performed.</source>
          <target state="translated"><ph id="ph1">`value2`</ph> e <ph id="ph2">`value1`</ph> são disparados da pilha; se <ph id="ph3">`value1`</ph> não é igual a <ph id="ph4">`value2`</ph>, a operação de ramificação é executada.</target>       </trans-unit>
        <trans-unit id="627" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bne_Un_S">
          <source>The <ph id="ph1">`bne.un`</ph> instruction transfers control to the specified target instruction if <ph id="ph2">`value1`</ph> is not equal to <ph id="ph3">`value2`</ph>, when compared using unsigned integer or unordered float values.</source>
          <target state="translated">O <ph id="ph1">`bne.un`</ph> instrução transfere o controle para a instrução de destino especificado se <ph id="ph2">`value1`</ph> não é igual a <ph id="ph3">`value2`</ph>, quando comparados com valores de float não ordenada ou inteiro não assinado.</target>       </trans-unit>
        <trans-unit id="628" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bne_Un_S">
          <source>The effect is identical to performing a <ph id="ph1">`ceq`</ph> instruction followed by a <ph id="ph2">`brfalse`</ph> branch to the specific target instruction.</source>
          <target state="translated">O efeito é idêntico ao executar uma <ph id="ph1">`ceq`</ph> instrução seguida por um <ph id="ph2">`brfalse`</ph> ramificação para a instrução de destino específico.</target>       </trans-unit>
        <trans-unit id="629" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bne_Un_S">
          <source>The target instruction is represented as a 4-byte signed offset from the beginning of the instruction following the current instruction.</source>
          <target state="translated">A instrução de destino é representada como um deslocamento assinado de 4 bytes do início da instrução após a instrução atual.</target>       </trans-unit>
        <trans-unit id="630" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bne_Un_S">
          <source>If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</source>
          <target state="translated">Se a instrução de destino tem um ou mais códigos de prefixo, o controle só pode ser transferido para o primeiro desses prefixos.</target>       </trans-unit>
        <trans-unit id="631" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bne_Un_S">
          <source>Control transfers into and out of <ph id="ph1">`try`</ph>, <ph id="ph2">`catch`</ph>, <ph id="ph3">`filter`</ph>, and <ph id="ph4">`finally`</ph> blocks cannot be performed by this instruction.</source>
          <target state="translated">O controle transfere dentro e fora do <ph id="ph1">`try`</ph>, <ph id="ph2">`catch`</ph>, <ph id="ph3">`filter`</ph>, e <ph id="ph4">`finally`</ph> blocos não podem ser executados por essa instrução.</target>       </trans-unit>
        <trans-unit id="632" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bne_Un_S">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`bne.un.s`</ph> opcode:</source>
          <target state="translated">O seguinte <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> sobrecarga de método pode usar o <ph id="ph2">`bne.un.s`</ph> opcode:</target>       </trans-unit>
        <trans-unit id="633" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bne_Un_S">
          <source>ILGenerator.Emit(OpCode, Label)</source>
          <target state="translated">ILGenerator.Emit(OpCode, Label)</target>       </trans-unit>
        <trans-unit id="634" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Box">
          <source>Converts a value type to an object reference (type <ph id="ph1">&lt;see langword="O" /&gt;</ph>).</source>
          <target state="translated">Converte um tipo de valor em uma referência de objeto (tipo <ph id="ph1">&lt;see langword="O" /&gt;</ph>).</target>       </trans-unit>
        <trans-unit id="635" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Box">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">A tabela a seguir lista as instruções hexadecimal e formato de assembly do Microsoft Intermediate Language (MSIL), junto com um resumo breve de referência:</target>       </trans-unit>
        <trans-unit id="636" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Box">
          <source>Format</source>
          <target state="translated">Formatar</target>       </trans-unit>
        <trans-unit id="637" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Box">
          <source>Assembly Format</source>
          <target state="translated">Formato de assembly</target>       </trans-unit>
        <trans-unit id="638" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Box">
          <source>Description</source>
          <target state="translated">Descrição</target>       </trans-unit>
        <trans-unit id="639" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Box">
          <source>8C &lt; <ph id="ph1">`T`</ph><ph id="ph2"> &gt;</ph></source>
          <target state="translated">8C &lt; <ph id="ph1">`T`</ph><ph id="ph2"> &gt;</ph></target>       </trans-unit>
        <trans-unit id="640" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Box">
          <source>box <ph id="ph1">`valTypeToken`</ph></source>
          <target state="translated">Caixa <ph id="ph1">`valTypeToken`</ph></target>       </trans-unit>
        <trans-unit id="641" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Box">
          <source>Convert a value type (of the type specified in <ph id="ph1">`valTypeToken`</ph>) to a true object reference.</source>
          <target state="translated">Converter um tipo de valor (do tipo especificado em <ph id="ph1">`valTypeToken`</ph>) para uma referência de objeto true.</target>       </trans-unit>
        <trans-unit id="642" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Box">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">O comportamento de transição de pilha, em ordem sequencial, é:</target>       </trans-unit>
        <trans-unit id="643" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Box">
          <source>A value type is pushed onto the stack.</source>
          <target state="translated">Um tipo de valor é inserido na pilha.</target>       </trans-unit>
        <trans-unit id="644" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Box">
          <source>The value type is popped from the stack; the <ph id="ph1">`box`</ph> operation is performed.</source>
          <target state="translated">O tipo de valor é exibido da pilha; o <ph id="ph1">`box`</ph> operação é executada.</target>       </trans-unit>
        <trans-unit id="645" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Box">
          <source>An object reference to the resulting "boxed" value type is pushed onto the stack.</source>
          <target state="translated">Uma referência de objeto para o tipo de valor "box" resultante é inserida na pilha.</target>       </trans-unit>
        <trans-unit id="646" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Box">
          <source>A value type has two separate representations within the Common Language Infrastructure (CLI):</source>
          <target state="translated">Um tipo de valor tem duas representações separadas no Common Language Infrastructure (CLI):</target>       </trans-unit>
        <trans-unit id="647" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Box">
          <source>A 'raw' form used when a value type is embedded within another object or on the stack.</source>
          <target state="translated">Uma forma 'bruta' usada quando um tipo de valor é inserido em outro objeto ou na pilha.</target>       </trans-unit>
        <trans-unit id="648" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Box">
          <source>A 'boxed' form, where the data in the value type is wrapped (boxed) into an object so it can exist as an independent entity.</source>
          <target state="translated">Uma forma 'boxed', onde os dados no tipo de valor são encapsulados (boxed) em um objeto para que ele pode existir de modo independente.</target>       </trans-unit>
        <trans-unit id="649" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Box">
          <source>The <ph id="ph1">`box`</ph> instruction converts the 'raw' (unboxed) value type into an object reference (type <ph id="ph2">`O`</ph>).</source>
          <target state="translated">O <ph id="ph1">`box`</ph> instrução converte o tipo de valor (não demarcado) 'brutas' em uma referência de objeto (tipo <ph id="ph2">`O`</ph>).</target>       </trans-unit>
        <trans-unit id="650" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Box">
          <source>This is accomplished by creating a new object and copying the data from the value type into the newly allocated object.</source>
          <target state="translated">Isso é feito criando um novo objeto e copiar os dados do tipo de valor para o objeto recentemente alocado.</target>       </trans-unit>
        <trans-unit id="651" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Box">
          <source><ph id="ph1">`valTypeToken`</ph> is a metadata token indicating the type of the value type on the stack.</source>
          <target state="translated"><ph id="ph1">`valTypeToken`</ph> um token de metadados que indica o tipo do tipo de valor na pilha.</target>       </trans-unit>
        <trans-unit id="652" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Box">
          <source><ph id="ph1">&lt;xref:System.OutOfMemoryException&gt;</ph> is thrown if there is insufficient memory to satisfy the request.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.OutOfMemoryException&gt;</ph> é gerada se há memória suficiente para atender à solicitação.</target>       </trans-unit>
        <trans-unit id="653" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Box">
          <source><ph id="ph1">&lt;xref:System.TypeLoadException&gt;</ph> is thrown if the class cannot be found.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.TypeLoadException&gt;</ph> é gerada se a classe não pode ser encontrada.</target>       </trans-unit>
        <trans-unit id="654" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Box">
          <source>This is typically detected when Microsoft Intermediate Language (MSIL) is converted to native code, rather than at runtime.</source>
          <target state="translated">Normalmente, isso é detectado quando Microsoft Intermediate Language (MSIL) é convertido em código nativo, em vez de em tempo de execução.</target>       </trans-unit>
        <trans-unit id="655" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Box">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`box`</ph> opcode:</source>
          <target state="translated">O seguinte <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> sobrecarga de método pode usar o <ph id="ph2">`box`</ph> opcode:</target>       </trans-unit>
        <trans-unit id="656" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Box">
          <source>ILGenerator.Emit(OpCode, Type)</source>
          <target state="translated">ILGenerator.Emit(OpCode, Type)</target>       </trans-unit>
        <trans-unit id="657" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Br">
          <source>Unconditionally transfers control to a target instruction.</source>
          <target state="translated">Transfere o controle 	incondicionalmente para uma instrução de destino.</target>       </trans-unit>
        <trans-unit id="658" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Br">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">A tabela a seguir lista as instruções hexadecimal e formato de assembly do Microsoft Intermediate Language (MSIL), junto com um resumo breve de referência:</target>       </trans-unit>
        <trans-unit id="659" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Br">
          <source>Format</source>
          <target state="translated">Formatar</target>       </trans-unit>
        <trans-unit id="660" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Br">
          <source>Assembly Format</source>
          <target state="translated">Formato de assembly</target>       </trans-unit>
        <trans-unit id="661" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Br">
          <source>Description</source>
          <target state="translated">Descrição</target>       </trans-unit>
        <trans-unit id="662" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Br">
          <source>38 &lt; <ph id="ph1">`int32`</ph><ph id="ph2"> &gt;</ph></source>
          <target state="translated">38 &lt; <ph id="ph1">`int32`</ph><ph id="ph2"> &gt;</ph></target>       </trans-unit>
        <trans-unit id="663" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Br">
          <source>br <ph id="ph1">`target`</ph></source>
          <target state="translated">br <ph id="ph1">`target`</ph></target>       </trans-unit>
        <trans-unit id="664" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Br">
          <source>Branches to a target instruction at the specified offset.</source>
          <target state="translated">Ramificações de uma instrução de destino no deslocamento especificado.</target>       </trans-unit>
        <trans-unit id="665" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Br">
          <source>No evaluation stack behaviors are performed by this operation.</source>
          <target state="translated">Não há comportamentos de pilha de avaliação são executados por essa operação.</target>       </trans-unit>
        <trans-unit id="666" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Br">
          <source>The <ph id="ph1">`br`</ph> instruction unconditionally transfers control to a target instruction.</source>
          <target state="translated">O <ph id="ph1">`br`</ph> instrução incondicionalmente transfere o controle para uma instrução de destino.</target>       </trans-unit>
        <trans-unit id="667" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Br">
          <source>The target instruction is represented as a 4-byte signed offset from the beginning of the instruction following the current instruction.</source>
          <target state="translated">A instrução de destino é representada como um deslocamento assinado de 4 bytes do início da instrução após a instrução atual.</target>       </trans-unit>
        <trans-unit id="668" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Br">
          <source>If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</source>
          <target state="translated">Se a instrução de destino tem um ou mais códigos de prefixo, o controle só pode ser transferido para o primeiro desses prefixos.</target>       </trans-unit>
        <trans-unit id="669" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Br">
          <source>Control transfers into and out of <ph id="ph1">`try`</ph>, <ph id="ph2">`catch`</ph>, <ph id="ph3">`filter`</ph>, and <ph id="ph4">`finally`</ph> blocks cannot be performed by this instruction.</source>
          <target state="translated">O controle transfere dentro e fora do <ph id="ph1">`try`</ph>, <ph id="ph2">`catch`</ph>, <ph id="ph3">`filter`</ph>, e <ph id="ph4">`finally`</ph> blocos não podem ser executados por essa instrução.</target>       </trans-unit>
        <trans-unit id="670" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Br">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`br`</ph> opcode:</source>
          <target state="translated">O seguinte <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> sobrecarga de método pode usar o <ph id="ph2">`br`</ph> opcode:</target>       </trans-unit>
        <trans-unit id="671" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Br">
          <source>ILGenerator.Emit(OpCode, Label)</source>
          <target state="translated">ILGenerator.Emit(OpCode, Label)</target>       </trans-unit>
        <trans-unit id="672" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Br_S">
          <source>Unconditionally transfers control to a target instruction (short form).</source>
          <target state="translated">Transfere o controle de forma incondicional para uma instrução de destino (forma abreviada).</target>       </trans-unit>
        <trans-unit id="673" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Br_S">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">A tabela a seguir lista as instruções hexadecimal e formato de assembly do Microsoft Intermediate Language (MSIL), junto com um resumo breve de referência:</target>       </trans-unit>
        <trans-unit id="674" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Br_S">
          <source>Format</source>
          <target state="translated">Formatar</target>       </trans-unit>
        <trans-unit id="675" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Br_S">
          <source>Assembly Format</source>
          <target state="translated">Formato de assembly</target>       </trans-unit>
        <trans-unit id="676" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Br_S">
          <source>Description</source>
          <target state="translated">Descrição</target>       </trans-unit>
        <trans-unit id="677" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Br_S">
          <source>2B &lt; <ph id="ph1">`int8`</ph><ph id="ph2"> &gt;</ph></source>
          <target state="translated">2B &lt; <ph id="ph1">`int8`</ph><ph id="ph2"> &gt;</ph></target>       </trans-unit>
        <trans-unit id="678" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Br_S">
          <source>br.s <ph id="ph1">`target`</ph></source>
          <target state="translated">br.s <ph id="ph1">`target`</ph></target>       </trans-unit>
        <trans-unit id="679" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Br_S">
          <source>Branches to a target instruction at the specified offset, short form.</source>
          <target state="translated">Ramificações de uma instrução de destino no deslocamento especificado, de forma abreviada.</target>       </trans-unit>
        <trans-unit id="680" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Br_S">
          <source>No evaluation stack behaviors are performed by this operation.</source>
          <target state="translated">Não há comportamentos de pilha de avaliação são executados por essa operação.</target>       </trans-unit>
        <trans-unit id="681" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Br_S">
          <source>The <ph id="ph1">`br.s`</ph> instruction unconditionally transfers control to a target instruction.</source>
          <target state="translated">O <ph id="ph1">`br.s`</ph> instrução incondicionalmente transfere o controle para uma instrução de destino.</target>       </trans-unit>
        <trans-unit id="682" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Br_S">
          <source>The target instruction is represented as a 1-byte signed offset from the beginning of the instruction following the current instruction.</source>
          <target state="translated">A instrução de destino é representada como um deslocamento de 1 byte assinado desde o início da instrução após a instrução atual.</target>       </trans-unit>
        <trans-unit id="683" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Br_S">
          <source>If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</source>
          <target state="translated">Se a instrução de destino tem um ou mais códigos de prefixo, o controle só pode ser transferido para o primeiro desses prefixos.</target>       </trans-unit>
        <trans-unit id="684" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Br_S">
          <source>Control transfers into and out of <ph id="ph1">`try`</ph>, <ph id="ph2">`catch`</ph>, <ph id="ph3">`filter`</ph>, and <ph id="ph4">`finally`</ph> blocks cannot be performed by this instruction.</source>
          <target state="translated">O controle transfere dentro e fora do <ph id="ph1">`try`</ph>, <ph id="ph2">`catch`</ph>, <ph id="ph3">`filter`</ph>, e <ph id="ph4">`finally`</ph> blocos não podem ser executados por essa instrução.</target>       </trans-unit>
        <trans-unit id="685" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Br_S">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`br.s`</ph> opcode:</source>
          <target state="translated">O seguinte <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> sobrecarga de método pode usar o <ph id="ph2">`br.s`</ph> opcode:</target>       </trans-unit>
        <trans-unit id="686" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Br_S">
          <source>ILGenerator.Emit(OpCode, Label)</source>
          <target state="translated">ILGenerator.Emit(OpCode, Label)</target>       </trans-unit>
        <trans-unit id="687" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Break">
          <source>Signals the Common Language Infrastructure (CLI) to inform the debugger that a break point has been tripped.</source>
          <target state="translated">Sinaliza a CLI (Common Language Infrastructure) para informar o depurador de que um ponto de interrupção foi ultrapassado.</target>       </trans-unit>
        <trans-unit id="688" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Break">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">A tabela a seguir lista as instruções hexadecimal e formato de assembly do Microsoft Intermediate Language (MSIL), junto com um resumo breve de referência:</target>       </trans-unit>
        <trans-unit id="689" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Break">
          <source>Format</source>
          <target state="translated">Formatar</target>       </trans-unit>
        <trans-unit id="690" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Break">
          <source>Assembly Format</source>
          <target state="translated">Formato de assembly</target>       </trans-unit>
        <trans-unit id="691" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Break">
          <source>Description</source>
          <target state="translated">Descrição</target>       </trans-unit>
        <trans-unit id="692" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Break">
          <source>01</source>
          <target state="translated">01</target>       </trans-unit>
        <trans-unit id="693" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Break">
          <source>break</source>
          <target state="translated">break</target>       </trans-unit>
        <trans-unit id="694" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Break">
          <source>inform a debugger that a breakpoint has been reached.</source>
          <target state="translated">Informe um depurador um ponto de interrupção foi atingido.</target>       </trans-unit>
        <trans-unit id="695" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Break">
          <source>No evaluation stack behaviors are performed by this operation.</source>
          <target state="translated">Não há comportamentos de pilha de avaliação são executados por essa operação.</target>       </trans-unit>
        <trans-unit id="696" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Break">
          <source>The <ph id="ph1">`break`</ph> instruction is for debugging support.</source>
          <target state="translated">O <ph id="ph1">`break`</ph> instrução é para suporte à depuração.</target>       </trans-unit>
        <trans-unit id="697" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Break">
          <source>It signals the CLI to inform the debugger that a break point has been tripped.</source>
          <target state="translated">Ele sinaliza o CLI para informar o depurador um ponto de interrupção foi ultrapassado.</target>       </trans-unit>
        <trans-unit id="698" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Break">
          <source>It has no other effect on the interpreter state.</source>
          <target state="translated">Não tem nenhum outro efeito sobre o estado do interpretador.</target>       </trans-unit>
        <trans-unit id="699" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Break">
          <source>The <ph id="ph1">`break`</ph> instruction has the smallest possible instruction size enabling code patching with a break point and generating minimal disturbance to the surrounding code.</source>
          <target state="translated">O <ph id="ph1">`break`</ph> instrução tem o menor possível tamanho habilitar código de instrução de aplicação de patches com um ponto de interrupção e gerando interferência no mínimo para o código ao redor.</target>       </trans-unit>
        <trans-unit id="700" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Break">
          <source>The <ph id="ph1">`break`</ph> instruction can trap to a debugger, do nothing, or raise a security exception.</source>
          <target state="translated">O <ph id="ph1">`break`</ph> instrução pode interceptar a um depurador, não fazer nada ou gerar uma exceção de segurança.</target>       </trans-unit>
        <trans-unit id="701" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Break">
          <source>The exact behavior is implementation-defined.</source>
          <target state="translated">O comportamento exato é definido pela implementação.</target>       </trans-unit>
        <trans-unit id="702" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Break">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`break`</ph> opcode:</source>
          <target state="translated">O seguinte <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> sobrecarga de método pode usar o <ph id="ph2">`break`</ph> opcode:</target>       </trans-unit>
        <trans-unit id="703" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Break">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="704" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Brfalse">
          <source>Transfers control to a target instruction if <ph id="ph1">&lt;paramref name="value" /&gt;</ph> is <ph id="ph2">&lt;see langword="false" /&gt;</ph>, a null reference (<ph id="ph3">&lt;see langword="Nothing" /&gt;</ph> in Visual Basic), or zero.</source>
          <target state="translated">Transferirá o controle para uma instrução de destino se <ph id="ph1">&lt;paramref name="value" /&gt;</ph> for <ph id="ph2">&lt;see langword="false" /&gt;</ph>, uma referência nula (<ph id="ph3">&lt;see langword="Nothing" /&gt;</ph> no Visual Basic) ou zero.</target>       </trans-unit>
        <trans-unit id="705" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Brfalse">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">A tabela a seguir lista as instruções hexadecimal e formato de assembly do Microsoft Intermediate Language (MSIL), junto com um resumo breve de referência:</target>       </trans-unit>
        <trans-unit id="706" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Brfalse">
          <source>Format</source>
          <target state="translated">Formatar</target>       </trans-unit>
        <trans-unit id="707" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Brfalse">
          <source>Assembly Format</source>
          <target state="translated">Formato de assembly</target>       </trans-unit>
        <trans-unit id="708" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Brfalse">
          <source>Description</source>
          <target state="translated">Descrição</target>       </trans-unit>
        <trans-unit id="709" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Brfalse">
          <source>39 &lt; <ph id="ph1">`int32`</ph><ph id="ph2"> &gt;</ph></source>
          <target state="translated">39 &lt; <ph id="ph1">`int32`</ph><ph id="ph2"> &gt;</ph></target>       </trans-unit>
        <trans-unit id="710" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Brfalse">
          <source>brfalse <ph id="ph1">`target`</ph></source>
          <target state="translated">brfalse <ph id="ph1">`target`</ph></target>       </trans-unit>
        <trans-unit id="711" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Brfalse">
          <source>brnull <ph id="ph1">`target`</ph></source>
          <target state="translated">brnull <ph id="ph1">`target`</ph></target>       </trans-unit>
        <trans-unit id="712" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Brfalse">
          <source>brzero <ph id="ph1">`target`</ph></source>
          <target state="translated">brzero <ph id="ph1">`target`</ph></target>       </trans-unit>
        <trans-unit id="713" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Brfalse">
          <source>Branches to a target instruction at the specified offset if <ph id="ph1">`false`</ph>.</source>
          <target state="translated">Ramificações de uma instrução de destino no deslocamento especificado se <ph id="ph1">`false`</ph>.</target>       </trans-unit>
        <trans-unit id="714" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Brfalse">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">O comportamento de transição de pilha, em ordem sequencial, é:</target>       </trans-unit>
        <trans-unit id="715" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Brfalse">
          <source><ph id="ph1">`value`</ph> is pushed onto the stack by a previous operation.</source>
          <target state="translated"><ph id="ph1">`value`</ph> é inserido na pilha por uma operação anterior.</target>       </trans-unit>
        <trans-unit id="716" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Brfalse">
          <source><ph id="ph1">`value`</ph> is popped from the stack; if <ph id="ph2">`value`</ph> is <ph id="ph3">`false`</ph>, branch to <ph id="ph4">`target`</ph>.</source>
          <target state="translated"><ph id="ph1">`value`</ph> é exibido da pilha; Se <ph id="ph2">`value`</ph> é <ph id="ph3">`false`</ph>, ramificar para <ph id="ph4">`target`</ph>.</target>       </trans-unit>
        <trans-unit id="717" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Brfalse">
          <source>The <ph id="ph1">`brfalse`</ph> instruction (and its aliases <ph id="ph2">`brnull`</ph> and <ph id="ph3">`brzero`</ph>) transfers control to the specified target instruction if <ph id="ph4">`value`</ph> (of type <ph id="ph5">`int32`</ph>, <ph id="ph6">`int64`</ph>, object reference <ph id="ph7">`O`</ph>, managed pointer <ph id="ph8">`&amp;`</ph>, transient pointer <ph id="ph9">`*`</ph>, <ph id="ph10">`native int`</ph>) is zero (<ph id="ph11">`false`</ph>).</source>
          <target state="translated">O <ph id="ph1">`brfalse`</ph> instrução (e seus aliases <ph id="ph2">`brnull`</ph> e <ph id="ph3">`brzero`</ph>) transfere o controle para a instrução de destino especificado se <ph id="ph4">`value`</ph> (do tipo <ph id="ph5">`int32`</ph>, <ph id="ph6">`int64`</ph>, referência de objeto <ph id="ph7">`O`</ph>gerenciado ponteiro <ph id="ph8">`&amp;`</ph>, ponteiro transitório <ph id="ph9">`*`</ph>, <ph id="ph10">`native int`</ph>) é zero (<ph id="ph11">`false`</ph>).</target>       </trans-unit>
        <trans-unit id="718" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Brfalse">
          <source>If <ph id="ph1">`value`</ph> is non-zero (<ph id="ph2">`true`</ph>) execution continues at the next instruction.</source>
          <target state="translated">Se <ph id="ph1">`value`</ph> é diferente de zero (<ph id="ph2">`true`</ph>) a execução continua na próxima instrução.</target>       </trans-unit>
        <trans-unit id="719" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Brfalse">
          <source>The target instruction is represented as a 4-byte signed offset from the beginning of the instruction following the current instruction.</source>
          <target state="translated">A instrução de destino é representada como um deslocamento assinado de 4 bytes do início da instrução após a instrução atual.</target>       </trans-unit>
        <trans-unit id="720" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Brfalse">
          <source>If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</source>
          <target state="translated">Se a instrução de destino tem um ou mais códigos de prefixo, o controle só pode ser transferido para o primeiro desses prefixos.</target>       </trans-unit>
        <trans-unit id="721" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Brfalse">
          <source>Control transfers into and out of <ph id="ph1">`try`</ph>, <ph id="ph2">`catch`</ph>, <ph id="ph3">`filter`</ph>, and <ph id="ph4">`finally`</ph> blocks cannot be performed by this instruction.</source>
          <target state="translated">O controle transfere dentro e fora do <ph id="ph1">`try`</ph>, <ph id="ph2">`catch`</ph>, <ph id="ph3">`filter`</ph>, e <ph id="ph4">`finally`</ph> blocos não podem ser executados por essa instrução.</target>       </trans-unit>
        <trans-unit id="722" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Brfalse">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`brfalse`</ph> opcode:</source>
          <target state="translated">O seguinte <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> sobrecarga de método pode usar o <ph id="ph2">`brfalse`</ph> opcode:</target>       </trans-unit>
        <trans-unit id="723" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Brfalse">
          <source>ILGenerator.Emit(OpCode, Label)</source>
          <target state="translated">ILGenerator.Emit(OpCode, Label)</target>       </trans-unit>
        <trans-unit id="724" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Brfalse_S">
          <source>Transfers control to a target instruction if <ph id="ph1">&lt;paramref name="value" /&gt;</ph> is <ph id="ph2">&lt;see langword="false" /&gt;</ph>, a null reference, or zero.</source>
          <target state="translated">Transferirá o controle para uma instrução de destino se <ph id="ph1">&lt;paramref name="value" /&gt;</ph> for <ph id="ph2">&lt;see langword="false" /&gt;</ph>, uma referência nula ou zero.</target>       </trans-unit>
        <trans-unit id="725" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Brfalse_S">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">A tabela a seguir lista as instruções hexadecimal e formato de assembly do Microsoft Intermediate Language (MSIL), junto com um resumo breve de referência:</target>       </trans-unit>
        <trans-unit id="726" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Brfalse_S">
          <source>Format</source>
          <target state="translated">Formatar</target>       </trans-unit>
        <trans-unit id="727" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Brfalse_S">
          <source>Assembly Format</source>
          <target state="translated">Formato de assembly</target>       </trans-unit>
        <trans-unit id="728" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Brfalse_S">
          <source>Description</source>
          <target state="translated">Descrição</target>       </trans-unit>
        <trans-unit id="729" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Brfalse_S">
          <source>2C &lt;<ph id="ph1">`int8`</ph><ph id="ph2"> &gt;</ph></source>
          <target state="translated">2C &lt;<ph id="ph1">`int8`</ph><ph id="ph2"> &gt;</ph></target>       </trans-unit>
        <trans-unit id="730" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Brfalse_S">
          <source>brfalse.s <ph id="ph1">`target`</ph></source>
          <target state="translated">brfalse.s <ph id="ph1">`target`</ph></target>       </trans-unit>
        <trans-unit id="731" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Brfalse_S">
          <source>brnull.s <ph id="ph1">`target`</ph></source>
          <target state="translated">brnull.s <ph id="ph1">`target`</ph></target>       </trans-unit>
        <trans-unit id="732" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Brfalse_S">
          <source>brzero.s <ph id="ph1">`target`</ph></source>
          <target state="translated">brzero.s <ph id="ph1">`target`</ph></target>       </trans-unit>
        <trans-unit id="733" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Brfalse_S">
          <source>Branches to a target instruction at the specified offset if <ph id="ph1">`false`</ph>, short form.</source>
          <target state="translated">Ramificações de uma instrução de destino no deslocamento especificado se <ph id="ph1">`false`</ph>, forma abreviada.</target>       </trans-unit>
        <trans-unit id="734" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Brfalse_S">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">O comportamento de transição de pilha, em ordem sequencial, é:</target>       </trans-unit>
        <trans-unit id="735" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Brfalse_S">
          <source><ph id="ph1">`value`</ph> is pushed onto the stack by a previous operation.</source>
          <target state="translated"><ph id="ph1">`value`</ph> é inserido na pilha por uma operação anterior.</target>       </trans-unit>
        <trans-unit id="736" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Brfalse_S">
          <source><ph id="ph1">`value`</ph> is popped from the stack; if <ph id="ph2">`value`</ph> is <ph id="ph3">`false`</ph>, branch to <ph id="ph4">`target`</ph>.</source>
          <target state="translated"><ph id="ph1">`value`</ph> é exibido da pilha; Se <ph id="ph2">`value`</ph> é <ph id="ph3">`false`</ph>, ramificar para <ph id="ph4">`target`</ph>.</target>       </trans-unit>
        <trans-unit id="737" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Brfalse_S">
          <source>The <ph id="ph1">`brfalse.s`</ph> instruction (and its aliases <ph id="ph2">`brnull`</ph> and <ph id="ph3">`brzero`</ph>) transfers control to the specified target instruction if <ph id="ph4">`value`</ph> (of type <ph id="ph5">`int32`</ph>, <ph id="ph6">`int64`</ph>, object reference <ph id="ph7">`O`</ph>, managed pointer <ph id="ph8">`&amp;`</ph>, transient pointer <ph id="ph9">`*`</ph>, <ph id="ph10">`native int`</ph>) is zero (<ph id="ph11">`false`</ph>).</source>
          <target state="translated">O <ph id="ph1">`brfalse.s`</ph> instrução (e seus aliases <ph id="ph2">`brnull`</ph> e <ph id="ph3">`brzero`</ph>) transfere o controle para a instrução de destino especificado se <ph id="ph4">`value`</ph> (do tipo <ph id="ph5">`int32`</ph>, <ph id="ph6">`int64`</ph>, referência de objeto <ph id="ph7">`O`</ph>gerenciado ponteiro <ph id="ph8">`&amp;`</ph>, ponteiro transitório <ph id="ph9">`*`</ph>, <ph id="ph10">`native int`</ph>) é zero (<ph id="ph11">`false`</ph>).</target>       </trans-unit>
        <trans-unit id="738" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Brfalse_S">
          <source>If <ph id="ph1">`value`</ph> is non-zero (<ph id="ph2">`true`</ph>) execution continues at the next instruction.</source>
          <target state="translated">Se <ph id="ph1">`value`</ph> é diferente de zero (<ph id="ph2">`true`</ph>) a execução continua na próxima instrução.</target>       </trans-unit>
        <trans-unit id="739" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Brfalse_S">
          <source>The target instruction is represented as a 1-byte signed offset from the beginning of the instruction following the current instruction.</source>
          <target state="translated">A instrução de destino é representada como um deslocamento de 1 byte assinado desde o início da instrução após a instrução atual.</target>       </trans-unit>
        <trans-unit id="740" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Brfalse_S">
          <source>If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</source>
          <target state="translated">Se a instrução de destino tem um ou mais códigos de prefixo, o controle só pode ser transferido para o primeiro desses prefixos.</target>       </trans-unit>
        <trans-unit id="741" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Brfalse_S">
          <source>Control transfers into and out of <ph id="ph1">`try`</ph>, <ph id="ph2">`catch`</ph>, <ph id="ph3">`filter`</ph>, and <ph id="ph4">`finally`</ph> blocks cannot be performed by this instruction.</source>
          <target state="translated">O controle transfere dentro e fora do <ph id="ph1">`try`</ph>, <ph id="ph2">`catch`</ph>, <ph id="ph3">`filter`</ph>, e <ph id="ph4">`finally`</ph> blocos não podem ser executados por essa instrução.</target>       </trans-unit>
        <trans-unit id="742" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Brfalse_S">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`brfalse.s`</ph> opcode:</source>
          <target state="translated">O seguinte <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> sobrecarga de método pode usar o <ph id="ph2">`brfalse.s`</ph> opcode:</target>       </trans-unit>
        <trans-unit id="743" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Brfalse_S">
          <source>ILGenerator.Emit(OpCode, Label)</source>
          <target state="translated">ILGenerator.Emit(OpCode, Label)</target>       </trans-unit>
        <trans-unit id="744" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Brtrue">
          <source>Transfers control to a target instruction if <ph id="ph1">&lt;paramref name="value" /&gt;</ph> is <ph id="ph2">&lt;see langword="true" /&gt;</ph>, not null, or non-zero.</source>
          <target state="translated">Transfere o controle para uma instrução de destino se <ph id="ph1">&lt;paramref name="value" /&gt;</ph> for <ph id="ph2">&lt;see langword="true" /&gt;</ph>, não nulo ou diferente de zero.</target>       </trans-unit>
        <trans-unit id="745" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Brtrue">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">A tabela a seguir lista as instruções hexadecimal e formato de assembly do Microsoft Intermediate Language (MSIL), junto com um resumo breve de referência:</target>       </trans-unit>
        <trans-unit id="746" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Brtrue">
          <source>Format</source>
          <target state="translated">Formatar</target>       </trans-unit>
        <trans-unit id="747" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Brtrue">
          <source>Assembly Format</source>
          <target state="translated">Formato de assembly</target>       </trans-unit>
        <trans-unit id="748" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Brtrue">
          <source>Description</source>
          <target state="translated">Descrição</target>       </trans-unit>
        <trans-unit id="749" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Brtrue">
          <source>3A &lt; <ph id="ph1">`int32`</ph><ph id="ph2"> &gt;</ph></source>
          <target state="translated">3A &lt; <ph id="ph1">`int32`</ph><ph id="ph2"> &gt;</ph></target>       </trans-unit>
        <trans-unit id="750" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Brtrue">
          <source>brtrue <ph id="ph1">`target`</ph></source>
          <target state="translated">brtrue <ph id="ph1">`target`</ph></target>       </trans-unit>
        <trans-unit id="751" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Brtrue">
          <source>brinst <ph id="ph1">`target`</ph></source>
          <target state="translated">brinst <ph id="ph1">`target`</ph></target>       </trans-unit>
        <trans-unit id="752" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Brtrue">
          <source>Branch to a target instruction at the specified offset if non-zero (<ph id="ph1">`true`</ph>).</source>
          <target state="translated">Ramificar para uma instrução de destino no deslocamento especificado se diferente de zero (<ph id="ph1">`true`</ph>).</target>       </trans-unit>
        <trans-unit id="753" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Brtrue">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">O comportamento de transição de pilha, em ordem sequencial, é:</target>       </trans-unit>
        <trans-unit id="754" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Brtrue">
          <source><ph id="ph1">`value`</ph> is pushed onto the stack by a previous operation.</source>
          <target state="translated"><ph id="ph1">`value`</ph> é inserido na pilha por uma operação anterior.</target>       </trans-unit>
        <trans-unit id="755" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Brtrue">
          <source><ph id="ph1">`value`</ph> is popped from the stack; if <ph id="ph2">`value`</ph> is <ph id="ph3">`true`</ph>, branch to <ph id="ph4">`target`</ph>.</source>
          <target state="translated"><ph id="ph1">`value`</ph> é exibido da pilha; Se <ph id="ph2">`value`</ph> é <ph id="ph3">`true`</ph>, ramificar para <ph id="ph4">`target`</ph>.</target>       </trans-unit>
        <trans-unit id="756" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Brtrue">
          <source>The <ph id="ph1">`brtrue`</ph> instruction transfers control to the specified target instruction if <ph id="ph2">`value`</ph> (type <ph id="ph3">`native int`</ph>) is nonzero (<ph id="ph4">`true`</ph>).</source>
          <target state="translated">O <ph id="ph1">`brtrue`</ph> instrução transfere o controle para a instrução de destino especificado se <ph id="ph2">`value`</ph> (tipo <ph id="ph3">`native int`</ph>) é diferente de zero (<ph id="ph4">`true`</ph>).</target>       </trans-unit>
        <trans-unit id="757" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Brtrue">
          <source>If <ph id="ph1">`value`</ph> is zero (<ph id="ph2">`false`</ph>) execution continues at the next instruction.</source>
          <target state="translated">Se <ph id="ph1">`value`</ph> é zero (<ph id="ph2">`false`</ph>) a execução continua na próxima instrução.</target>       </trans-unit>
        <trans-unit id="758" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Brtrue">
          <source>If <ph id="ph1">`value`</ph> is an object reference (type <ph id="ph2">`O`</ph>) then <ph id="ph3">`brinst`</ph> (an alias for <ph id="ph4">`brtrue`</ph>) transfers control if it represents an instance of an object (for example, if it is not the null object reference; see <ph id="ph5">&lt;xref:System.Reflection.Emit.OpCodes.Ldnull&gt;</ph>).</source>
          <target state="translated">Se <ph id="ph1">`value`</ph> é uma referência de objeto (tipo <ph id="ph2">`O`</ph>), em seguida, <ph id="ph3">`brinst`</ph> (um alias para <ph id="ph4">`brtrue`</ph>) transfere o controle se ele representa uma instância de um objeto (por exemplo, se não for a referência de objeto nulo; consulte <ph id="ph5">&lt;xref:System.Reflection.Emit.OpCodes.Ldnull&gt;</ph>).</target>       </trans-unit>
        <trans-unit id="759" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Brtrue">
          <source>The target instruction is represented as a 4-byte signed offset from the beginning of the instruction following the current instruction.</source>
          <target state="translated">A instrução de destino é representada como um deslocamento assinado de 4 bytes do início da instrução após a instrução atual.</target>       </trans-unit>
        <trans-unit id="760" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Brtrue">
          <source>If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</source>
          <target state="translated">Se a instrução de destino tem um ou mais códigos de prefixo, o controle só pode ser transferido para o primeiro desses prefixos.</target>       </trans-unit>
        <trans-unit id="761" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Brtrue">
          <source>Control transfers into and out of <ph id="ph1">`try`</ph>, <ph id="ph2">`catch`</ph>, <ph id="ph3">`filter`</ph>, and <ph id="ph4">`finally`</ph> blocks cannot be performed by this instruction.</source>
          <target state="translated">O controle transfere dentro e fora do <ph id="ph1">`try`</ph>, <ph id="ph2">`catch`</ph>, <ph id="ph3">`filter`</ph>, e <ph id="ph4">`finally`</ph> blocos não podem ser executados por essa instrução.</target>       </trans-unit>
        <trans-unit id="762" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Brtrue">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`brtrue`</ph> opcode:</source>
          <target state="translated">O seguinte <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> sobrecarga de método pode usar o <ph id="ph2">`brtrue`</ph> opcode:</target>       </trans-unit>
        <trans-unit id="763" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Brtrue">
          <source>ILGenerator.Emit(OpCode, Label)</source>
          <target state="translated">ILGenerator.Emit(OpCode, Label)</target>       </trans-unit>
        <trans-unit id="764" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Brtrue_S">
          <source>Transfers control to a target instruction (short form) if <ph id="ph1">&lt;paramref name="value" /&gt;</ph> is <ph id="ph2">&lt;see langword="true" /&gt;</ph>, not null, or non-zero.</source>
          <target state="translated">Transfere o controle para uma instrução de destino (forma abreviada) se <ph id="ph1">&lt;paramref name="value" /&gt;</ph> for <ph id="ph2">&lt;see langword="true" /&gt;</ph>, não nulo ou diferente de zero.</target>       </trans-unit>
        <trans-unit id="765" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Brtrue_S">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">A tabela a seguir lista as instruções hexadecimal e formato de assembly do Microsoft Intermediate Language (MSIL), junto com um resumo breve de referência:</target>       </trans-unit>
        <trans-unit id="766" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Brtrue_S">
          <source>Format</source>
          <target state="translated">Formatar</target>       </trans-unit>
        <trans-unit id="767" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Brtrue_S">
          <source>Assembly Format</source>
          <target state="translated">Formato de assembly</target>       </trans-unit>
        <trans-unit id="768" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Brtrue_S">
          <source>Description</source>
          <target state="translated">Descrição</target>       </trans-unit>
        <trans-unit id="769" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Brtrue_S">
          <source>2D &lt; <ph id="ph1">`int8`</ph><ph id="ph2"> &gt;</ph></source>
          <target state="translated">2D &lt; <ph id="ph1">`int8`</ph><ph id="ph2"> &gt;</ph></target>       </trans-unit>
        <trans-unit id="770" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Brtrue_S">
          <source>brtrue.s <ph id="ph1">`target`</ph></source>
          <target state="translated">brtrue.s <ph id="ph1">`target`</ph></target>       </trans-unit>
        <trans-unit id="771" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Brtrue_S">
          <source>brinst.s <ph id="ph1">`target`</ph></source>
          <target state="translated">brinst.s <ph id="ph1">`target`</ph></target>       </trans-unit>
        <trans-unit id="772" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Brtrue_S">
          <source>Branch to a target instruction at the specified offset if non-zero (<ph id="ph1">`true`</ph>), short form.</source>
          <target state="translated">Ramificar para uma instrução de destino no deslocamento especificado se diferente de zero (<ph id="ph1">`true`</ph>), forma abreviada.</target>       </trans-unit>
        <trans-unit id="773" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Brtrue_S">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">O comportamento de transição de pilha, em ordem sequencial, é:</target>       </trans-unit>
        <trans-unit id="774" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Brtrue_S">
          <source><ph id="ph1">`value`</ph> is pushed onto the stack by a previous operation.</source>
          <target state="translated"><ph id="ph1">`value`</ph> é inserido na pilha por uma operação anterior.</target>       </trans-unit>
        <trans-unit id="775" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Brtrue_S">
          <source><ph id="ph1">`value`</ph> is popped from the stack; if <ph id="ph2">`value`</ph> is <ph id="ph3">`true`</ph>, branch to <ph id="ph4">`target`</ph>.</source>
          <target state="translated"><ph id="ph1">`value`</ph> é exibido da pilha; Se <ph id="ph2">`value`</ph> é <ph id="ph3">`true`</ph>, ramificar para <ph id="ph4">`target`</ph>.</target>       </trans-unit>
        <trans-unit id="776" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Brtrue_S">
          <source>The <ph id="ph1">`brtrue.s`</ph> instruction transfers control to the specified target instruction if <ph id="ph2">`value`</ph> (type <ph id="ph3">`native int`</ph>) is nonzero (<ph id="ph4">`true`</ph>).</source>
          <target state="translated">O <ph id="ph1">`brtrue.s`</ph> instrução transfere o controle para a instrução de destino especificado se <ph id="ph2">`value`</ph> (tipo <ph id="ph3">`native int`</ph>) é diferente de zero (<ph id="ph4">`true`</ph>).</target>       </trans-unit>
        <trans-unit id="777" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Brtrue_S">
          <source>If <ph id="ph1">`value`</ph> is zero (<ph id="ph2">`false`</ph>) execution continues at the next instruction.</source>
          <target state="translated">Se <ph id="ph1">`value`</ph> é zero (<ph id="ph2">`false`</ph>) a execução continua na próxima instrução.</target>       </trans-unit>
        <trans-unit id="778" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Brtrue_S">
          <source>If <ph id="ph1">`value`</ph> is an object reference (type <ph id="ph2">`O`</ph>) then <ph id="ph3">`brinst`</ph> (an alias for <ph id="ph4">`brtrue`</ph>) transfers control if it represents an instance of an object (for example, if it is not the null object reference; see <ph id="ph5">&lt;xref:System.Reflection.Emit.OpCodes.Ldnull&gt;</ph>).</source>
          <target state="translated">Se <ph id="ph1">`value`</ph> é uma referência de objeto (tipo <ph id="ph2">`O`</ph>), em seguida, <ph id="ph3">`brinst`</ph> (um alias para <ph id="ph4">`brtrue`</ph>) transfere o controle se ele representa uma instância de um objeto (por exemplo, se não for a referência de objeto nulo; consulte <ph id="ph5">&lt;xref:System.Reflection.Emit.OpCodes.Ldnull&gt;</ph>).</target>       </trans-unit>
        <trans-unit id="779" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Brtrue_S">
          <source>The target instruction is represented as a 1-byte signed offset from the beginning of the instruction following the current instruction.</source>
          <target state="translated">A instrução de destino é representada como um deslocamento de 1 byte assinado desde o início da instrução após a instrução atual.</target>       </trans-unit>
        <trans-unit id="780" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Brtrue_S">
          <source>If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</source>
          <target state="translated">Se a instrução de destino tem um ou mais códigos de prefixo, o controle só pode ser transferido para o primeiro desses prefixos.</target>       </trans-unit>
        <trans-unit id="781" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Brtrue_S">
          <source>Control transfers into and out of <ph id="ph1">`try`</ph>, <ph id="ph2">`catch`</ph>, <ph id="ph3">`filter`</ph>, and <ph id="ph4">`finally`</ph> blocks cannot be performed by this instruction.</source>
          <target state="translated">O controle transfere dentro e fora do <ph id="ph1">`try`</ph>, <ph id="ph2">`catch`</ph>, <ph id="ph3">`filter`</ph>, e <ph id="ph4">`finally`</ph> blocos não podem ser executados por essa instrução.</target>       </trans-unit>
        <trans-unit id="782" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Brtrue_S">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`brtrue.s`</ph> opcode:</source>
          <target state="translated">O seguinte <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> sobrecarga de método pode usar o <ph id="ph2">`brtrue.s`</ph> opcode:</target>       </trans-unit>
        <trans-unit id="783" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Brtrue_S">
          <source>ILGenerator.Emit(OpCode, Label)</source>
          <target state="translated">ILGenerator.Emit(OpCode, Label)</target>       </trans-unit>
        <trans-unit id="784" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Call">
          <source>Calls the method indicated by the passed method descriptor.</source>
          <target state="translated">Chama o método indicado pelo descritor de método passado.</target>       </trans-unit>
        <trans-unit id="785" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Call">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">A tabela a seguir lista as instruções hexadecimal e formato de assembly do Microsoft Intermediate Language (MSIL), junto com um resumo breve de referência:</target>       </trans-unit>
        <trans-unit id="786" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Call">
          <source>Format</source>
          <target state="translated">Formatar</target>       </trans-unit>
        <trans-unit id="787" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Call">
          <source>Assembly Format</source>
          <target state="translated">Formato de assembly</target>       </trans-unit>
        <trans-unit id="788" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Call">
          <source>Description</source>
          <target state="translated">Descrição</target>       </trans-unit>
        <trans-unit id="789" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Call">
          <source>28 &lt; <ph id="ph1">`T`</ph><ph id="ph2"> &gt;</ph></source>
          <target state="translated">28 &lt; <ph id="ph1">`T`</ph><ph id="ph2"> &gt;</ph></target>       </trans-unit>
        <trans-unit id="790" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Call">
          <source>call <ph id="ph1">`methodDesc`</ph></source>
          <target state="translated">Chamada <ph id="ph1">`methodDesc`</ph></target>       </trans-unit>
        <trans-unit id="791" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Call">
          <source>Call the method described by <ph id="ph1">`methodDesc`</ph>.</source>
          <target state="translated">Chame o método descrito pelo <ph id="ph1">`methodDesc`</ph>.</target>       </trans-unit>
        <trans-unit id="792" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Call">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">O comportamento de transição de pilha, em ordem sequencial, é:</target>       </trans-unit>
        <trans-unit id="793" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Call">
          <source>Method arguments <ph id="ph1">`arg1`</ph> through <ph id="ph2">`argN`</ph> are pushed onto the stack.</source>
          <target state="translated">Argumentos de método <ph id="ph1">`arg1`</ph> por meio de <ph id="ph2">`argN`</ph> são colocados na pilha.</target>       </trans-unit>
        <trans-unit id="794" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Call">
          <source>Method arguments <ph id="ph1">`arg1`</ph> through <ph id="ph2">`argN`</ph> are popped from the stack; the method call is performed with these arguments and control is transferred to the method referred to by the method descriptor.</source>
          <target state="translated">Argumentos de método <ph id="ph1">`arg1`</ph> por meio de <ph id="ph2">`argN`</ph> são disparados da pilha; a chamada do método é executada com estes argumentos e o controle é transferido para o método chamado pelo descritor de método.</target>       </trans-unit>
        <trans-unit id="795" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Call">
          <source>When complete, a return value is generated by the callee method and sent to the caller.</source>
          <target state="translated">Ao concluir, um valor de retorno é gerado pelo método de receptor e enviado para o chamador.</target>       </trans-unit>
        <trans-unit id="796" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Call">
          <source>The return value is pushed onto the stack.</source>
          <target state="translated">O valor de retorno é inserido na pilha.</target>       </trans-unit>
        <trans-unit id="797" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Call">
          <source>The <ph id="ph1">`call`</ph> instruction calls the method indicated by the method descriptor passed with the instruction.</source>
          <target state="translated">O <ph id="ph1">`call`</ph> instrução chama o método indicado pelo descritor de método passado com a instrução.</target>       </trans-unit>
        <trans-unit id="798" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Call">
          <source>The method descriptor is a metadata token that indicates the method to call and the number, type, and order of the arguments that have been placed on the stack to be passed to that method as well as the calling convention to be used.</source>
          <target state="translated">O descritor de método é um token de metadados que indica o método de chamada e o número, tipo e ordem dos argumentos que foram colocadas na pilha a serem passados para esse método, bem como a convenção de chamada a ser usado.</target>       </trans-unit>
        <trans-unit id="799" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Call">
          <source>The <ph id="ph1">`call`</ph> instruction can be immediately preceded by a <ph id="ph2">`tail`</ph> (<ph id="ph3">&lt;xref:System.Reflection.Emit.OpCodes.Tailcall&gt;</ph>) prefix instruction to specify that the current method state should be released before transferring control.</source>
          <target state="translated">O <ph id="ph1">`call`</ph> instrução pode ser imediatamente precedida por um <ph id="ph2">`tail`</ph> (<ph id="ph3">&lt;xref:System.Reflection.Emit.OpCodes.Tailcall&gt;</ph>) prefixo instrução para especificar que o estado atual do método deve ser liberado antes da transferência de controle.</target>       </trans-unit>
        <trans-unit id="800" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Call">
          <source>If the call transfers control to a method of higher trust than the origin method, the stack frame is not released.</source>
          <target state="translated">Se a chamada transfere o controle para um método de confiança mais alto que o método de origem, o quadro de pilha não está liberado.</target>       </trans-unit>
        <trans-unit id="801" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Call">
          <source>Instead, the execution continues silently as if the <ph id="ph1">`tail`</ph> had not been supplied.</source>
          <target state="translated">Em vez disso, a execução continua silenciosamente como se o <ph id="ph1">`tail`</ph> não tinha sido fornecido.</target>       </trans-unit>
        <trans-unit id="802" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Call">
          <source>The metadata token carries sufficient information to determine whether the call is to a static method, an instance method, a virtual method, or a global function.</source>
          <target state="translated">O token de metadados contém informações suficientes para determinar se a chamada é um método estático, um método de instância, um método virtual ou uma função global.</target>       </trans-unit>
        <trans-unit id="803" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Call">
          <source>In all of these cases the destination address is determined entirely from the method descriptor (contrast this with the <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Callvirt&gt;</ph> instruction for calling virtual methods, where the destination address also depends upon the runtime type of the instance reference pushed before the <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Callvirt&gt;</ph>).</source>
          <target state="translated">Em todos esses casos, o endereço de destino é determinado inteiramente do descritor de método (Compare isso com o <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Callvirt&gt;</ph> instrução para chamar métodos virtuais, em que o endereço de destino também depende do tipo de tempo de execução da referência de instância enviada por push antes do <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Callvirt&gt;</ph>).</target>       </trans-unit>
        <trans-unit id="804" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Call">
          <source>The arguments are placed on the stack in left-to-right order.</source>
          <target state="translated">Os argumentos são colocados na pilha na ordem da esquerda para direita.</target>       </trans-unit>
        <trans-unit id="805" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Call">
          <source>That is, the first argument is computed and placed on the stack, then the second argument, then the third, until all necessary arguments are atop the stack in descending order.</source>
          <target state="translated">Ou seja, o primeiro argumento é calculado e colocado na pilha, em seguida, o segundo argumento e o terceiro, até que todos os argumentos necessários forem sobre a pilha em ordem decrescente.</target>       </trans-unit>
        <trans-unit id="806" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Call">
          <source>There are three important special cases:</source>
          <target state="translated">Há três casos especiais importantes:</target>       </trans-unit>
        <trans-unit id="807" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Call">
          <source>Calls to an instance (or virtual) method must push that instance reference before any of the user-visible arguments.</source>
          <target state="translated">Chamadas para uma instância (ou virtuais) método deve enviar por push essa referência de instância antes de qualquer um dos argumentos visível pelo usuário.</target>       </trans-unit>
        <trans-unit id="808" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Call">
          <source>The instance reference must not be a null reference.</source>
          <target state="translated">A referência de instância não deve ser uma referência nula.</target>       </trans-unit>
        <trans-unit id="809" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Call">
          <source>The signature carried in the metadata does not contain an entry in the parameter list for the <ph id="ph1">`this`</ph> pointer; instead, it uses a bit to indicate whether the method requires passing the <ph id="ph2">`this`</ph> pointer.</source>
          <target state="translated">A assinatura executada nos metadados não contém uma entrada na lista de parâmetros para o <ph id="ph1">`this`</ph> ponteiro; em vez disso, ele usa um bit para indicar se o método requer passando o <ph id="ph2">`this`</ph> ponteiro.</target>       </trans-unit>
        <trans-unit id="810" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Call">
          <source>It is valid to call a virtual method using <ph id="ph1">`call`</ph> (rather than <ph id="ph2">`callvirt`</ph>); this indicates that the method is to be resolved using the class specified by method rather than as specified dynamically from the object being invoked.</source>
          <target state="translated">É válido chamar um método virtual usando <ph id="ph1">`call`</ph> (em vez de <ph id="ph2">`callvirt`</ph>); isso indica que o método deve ser resolvido com a classe especificada pelo método em vez de como especificado dinamicamente a partir do objeto a ser chamado.</target>       </trans-unit>
        <trans-unit id="811" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Call">
          <source>Note that a delegate's <ph id="ph1">`Invoke`</ph> method can be called with either the <ph id="ph2">`call`</ph> or <ph id="ph3">`callvirt`</ph> instruction.</source>
          <target state="translated">Observe que um representante <ph id="ph1">`Invoke`</ph> método pode ser chamado com um o <ph id="ph2">`call`</ph> ou <ph id="ph3">`callvirt`</ph> instrução.</target>       </trans-unit>
        <trans-unit id="812" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Call">
          <source><ph id="ph1">&lt;xref:System.Security.SecurityException&gt;</ph> may be thrown if system security does not grant the caller access to the called method.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Security.SecurityException&gt;</ph> pode ser acionada se a segurança do sistema não concede o acesso externo para o método chamado.</target>       </trans-unit>
        <trans-unit id="813" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Call">
          <source>The security check may occur when the Microsoft Intermediate Language (MSIL) instructions are converted to native code rather than at run time.</source>
          <target state="translated">A verificação de segurança pode ocorrer quando as instruções da Microsoft Intermediate Language (MSIL) são convertidas em código nativo em vez de em tempo de execução.</target>       </trans-unit>
        <trans-unit id="814" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Call">
          <source>When calling methods of System.Object on value types, consider using the <ph id="ph1">`constrained`</ph> prefix with the <ph id="ph2">`callvirt`</ph> instruction instead of emitting a <ph id="ph3">`call`</ph> instruction.</source>
          <target state="translated">Ao chamar métodos de System. Object em tipos de valor, considere o uso de <ph id="ph1">`constrained`</ph> com prefixo o <ph id="ph2">`callvirt`</ph> instrução, em vez de emitir um <ph id="ph3">`call`</ph> instrução.</target>       </trans-unit>
        <trans-unit id="815" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Call">
          <source>This removes the need to emit different IL depending on whether or not the value type overrides the method, avoiding a potential versioning problem.</source>
          <target state="translated">Isso elimina a necessidade de emissão de IL diferente dependendo se o tipo de valor substitui o método, evitando um possível problema de controle de versão.</target>       </trans-unit>
        <trans-unit id="816" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Call">
          <source>Consider using the <ph id="ph1">`constrained`</ph> prefix when invoking interface methods on value types, since the value type method implementing the interface method can be changed using a <ph id="ph2">`MethodImpl`</ph>.</source>
          <target state="translated">Considere o uso de <ph id="ph1">`constrained`</ph> prefixo ao chamar métodos em tipos de valor, como o método de tipo de valor implementando o método de interface pode ser alterado usando um <ph id="ph2">`MethodImpl`</ph>.</target>       </trans-unit>
        <trans-unit id="817" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Call">
          <source>These issues are described in more detail in the <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Constrained&gt;</ph> opcode.</source>
          <target state="translated">Esses problemas são descritos mais detalhadamente o <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Constrained&gt;</ph> opcode.</target>       </trans-unit>
        <trans-unit id="818" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Call">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overloads can use the <ph id="ph2">`call`</ph> opcode:</source>
          <target state="translated">O seguinte <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> sobrecargas de método podem usar o <ph id="ph2">`call`</ph> opcode:</target>       </trans-unit>
        <trans-unit id="819" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Call">
          <source>ILGenerator.Emit(OpCode, MethodInfo)</source>
          <target state="translated">ILGenerator.Emit(OpCode, MethodInfo)</target>       </trans-unit>
        <trans-unit id="820" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Call">
          <source>ILGenerator.EmitCall(OpCode, MethodInfo, Type[])</source>
          <target state="translated">ILGenerator.EmitCall(OpCode, MethodInfo, Type[])</target>       </trans-unit>
        <trans-unit id="821" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Call">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.EmitCall%2A&gt;</ph> method is provided for <ph id="ph2">`varargs`</ph> calls.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.EmitCall%2A&gt;</ph> método é fornecido para <ph id="ph2">`varargs`</ph> chamadas.</target>       </trans-unit>
        <trans-unit id="822" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Call">
          <source>Use the <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method for normal calls.</source>
          <target state="translated">Use o <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> método para chamadas normais.</target>       </trans-unit>
        <trans-unit id="823" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Calli">
          <source>Calls the method indicated on the evaluation stack (as a pointer to an entry point) with arguments described by a calling convention.</source>
          <target state="translated">Chama o método indicado na pilha de avaliação (como um ponteiro para um ponto de entrada) com argumentos descritos por uma convenção de chamada.</target>       </trans-unit>
        <trans-unit id="824" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Calli">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">A tabela a seguir lista as instruções hexadecimal e formato de assembly do Microsoft Intermediate Language (MSIL), junto com um resumo breve de referência:</target>       </trans-unit>
        <trans-unit id="825" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Calli">
          <source>Format</source>
          <target state="translated">Formatar</target>       </trans-unit>
        <trans-unit id="826" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Calli">
          <source>Assembly Format</source>
          <target state="translated">Formato de assembly</target>       </trans-unit>
        <trans-unit id="827" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Calli">
          <source>Description</source>
          <target state="translated">Descrição</target>       </trans-unit>
        <trans-unit id="828" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Calli">
          <source>29 &lt; <ph id="ph1">`T`</ph><ph id="ph2"> &gt;</ph></source>
          <target state="translated">29 &lt; <ph id="ph1">`T`</ph><ph id="ph2"> &gt;</ph></target>       </trans-unit>
        <trans-unit id="829" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Calli">
          <source>calli <ph id="ph1">`callSiteDescr`</ph></source>
          <target state="translated">calli <ph id="ph1">`callSiteDescr`</ph></target>       </trans-unit>
        <trans-unit id="830" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Calli">
          <source>Calls the method pointed to with arguments described by the calling convention.</source>
          <target state="translated">Chama o método apontado com argumentos descritos pela convenção de chamada.</target>       </trans-unit>
        <trans-unit id="831" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Calli">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">O comportamento de transição de pilha, em ordem sequencial, é:</target>       </trans-unit>
        <trans-unit id="832" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Calli">
          <source>Method arguments <ph id="ph1">`arg1`</ph> through <ph id="ph2">`argN`</ph> are pushed onto the stack.</source>
          <target state="translated">Argumentos de método <ph id="ph1">`arg1`</ph> por meio de <ph id="ph2">`argN`</ph> são colocados na pilha.</target>       </trans-unit>
        <trans-unit id="833" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Calli">
          <source>The method entry pointer is pushed onto the stack.</source>
          <target state="translated">O ponteiro de entrada do método é inserido na pilha.</target>       </trans-unit>
        <trans-unit id="834" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Calli">
          <source>Method arguments <ph id="ph1">`arg1`</ph> through <ph id="ph2">`argN`</ph> and the method entry pointer are popped from the stack; the call to the method is performed.</source>
          <target state="translated">Argumentos de método <ph id="ph1">`arg1`</ph> por meio de <ph id="ph2">`argN`</ph> e o ponteiro de entrada do método são disparados da pilha; a chamada ao método é executada.</target>       </trans-unit>
        <trans-unit id="835" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Calli">
          <source>When complete, a return value is generated by the callee method and sent to the caller.</source>
          <target state="translated">Ao concluir, um valor de retorno é gerado pelo método de receptor e enviado para o chamador.</target>       </trans-unit>
        <trans-unit id="836" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Calli">
          <source>The return value is pushed onto the stack.</source>
          <target state="translated">O valor de retorno é inserido na pilha.</target>       </trans-unit>
        <trans-unit id="837" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Calli">
          <source>The <ph id="ph1">`calli`</ph> instruction calls the method entry pointer with the arguments <ph id="ph2">`arg1`</ph> through <ph id="ph3">`argN`</ph>.</source>
          <target state="translated">O <ph id="ph1">`calli`</ph> instrução chama o ponteiro de entrada do método com os argumentos <ph id="ph2">`arg1`</ph> por meio de <ph id="ph3">`argN`</ph>.</target>       </trans-unit>
        <trans-unit id="838" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Calli">
          <source>The types of these arguments are described by the specific calling convention (<ph id="ph1">`callSiteDesc`</ph>).</source>
          <target state="translated">Os tipos desses argumentos são descritos pela convenção de chamada específica (<ph id="ph1">`callSiteDesc`</ph>).</target>       </trans-unit>
        <trans-unit id="839" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Calli">
          <source>The <ph id="ph1">`calli`</ph> instruction may be immediately preceded by a <ph id="ph2">`tail`</ph> prefix (<ph id="ph3">&lt;xref:System.Reflection.Emit.OpCodes.Tailcall&gt;</ph>) to specify that the current method state should be released before transferring control.</source>
          <target state="translated">O <ph id="ph1">`calli`</ph> instrução pode ser imediatamente precedida por um <ph id="ph2">`tail`</ph> prefixo (<ph id="ph3">&lt;xref:System.Reflection.Emit.OpCodes.Tailcall&gt;</ph>) para especificar que o estado atual do método deve ser liberado antes da transferência de controle.</target>       </trans-unit>
        <trans-unit id="840" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Calli">
          <source>If the call would transfer control to a method of higher trust than the origin method the stack frame will not be released; instead, the execution will continue silently as if the <ph id="ph1">`tail`</ph> had not been supplied.</source>
          <target state="translated">Se a chamada transfere controle a um método de confiança mais alto que o método de origem do quadro de pilha não será liberado; em vez disso, a execução continuará silenciosamente como se o <ph id="ph1">`tail`</ph> não tinha sido fornecido.</target>       </trans-unit>
        <trans-unit id="841" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Calli">
          <source>The method entry pointer is assumed to be a specific pointer to native code (of the target machine) that can be legitimately called with the arguments described by the calling convention (a metadata token for a stand-alone signature).</source>
          <target state="translated">O ponteiro de entrada do método deve para ser um ponteiro específico para código nativo (da máquina de destino) que pode ser chamado de forma legítima com os argumentos descritos pela convenção de chamada (um token de metadados para uma assinatura autônoma).</target>       </trans-unit>
        <trans-unit id="842" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Calli">
          <source>Such a pointer can be created using the <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Ldftn&gt;</ph> or <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Ldvirtftn&gt;</ph> instructions, or passed in from native code.</source>
          <target state="translated">Um ponteiro esse pode ser criado usando o <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Ldftn&gt;</ph> ou <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Ldvirtftn&gt;</ph> instruções, ou transmitida de código nativo.</target>       </trans-unit>
        <trans-unit id="843" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Calli">
          <source>The calling convention is not checked dynamically, so code that uses a <ph id="ph1">`calli`</ph> instruction does not work correctly if the destination does not actually use the specified calling convention.</source>
          <target state="translated">A convenção de chamada não é verificada dinamicamente, portanto código que usa um <ph id="ph1">`calli`</ph> instrução não funcionarão corretamente se o destino não usa, na verdade, a convenção de chamada especificada.</target>       </trans-unit>
        <trans-unit id="844" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Calli">
          <source>The arguments are placed on the stack in left-to-right order.</source>
          <target state="translated">Os argumentos são colocados na pilha na ordem da esquerda para direita.</target>       </trans-unit>
        <trans-unit id="845" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Calli">
          <source>That is, the first argument is computed and placed on the stack, then the second argument, then the third, until all necessary arguments are atop the stack in descending order.</source>
          <target state="translated">Ou seja, o primeiro argumento é calculado e colocado na pilha, em seguida, o segundo argumento e o terceiro, até que todos os argumentos necessários forem sobre a pilha em ordem decrescente.</target>       </trans-unit>
        <trans-unit id="846" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Calli">
          <source>The argument-building code sequence for an instance or virtual method must push that instance reference (which must not be a null reference) before any of the user-visible arguments.</source>
          <target state="translated">A sequência de código de construção de argumento para uma instância ou um método virtual deve enviar por push essa referência de instância (que não deve ser uma referência nula) antes de qualquer um dos argumentos visível pelo usuário.</target>       </trans-unit>
        <trans-unit id="847" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Calli">
          <source><ph id="ph1">&lt;xref:System.Security.SecurityException&gt;</ph> may be thrown if the system security does not grant the caller access to the called method.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Security.SecurityException&gt;</ph> pode ser acionada se a segurança do sistema não concede o acesso externo para o método chamado.</target>       </trans-unit>
        <trans-unit id="848" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Calli">
          <source>The security check can occur when the Microsoft Intermediate Language (MSIL) instructions are converted to native code rather than at runtime.</source>
          <target state="translated">A verificação de segurança pode ocorrer quando as instruções da Microsoft Intermediate Language (MSIL) são convertidas em código nativo em vez de em tempo de execução.</target>       </trans-unit>
        <trans-unit id="849" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Calli">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.EmitCalli%2A&gt;</ph> methods can be used to perform a <ph id="ph2">`calli`</ph> instruction on the stack.</source>
          <target state="translated">O seguinte <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.EmitCalli%2A&gt;</ph> métodos podem ser usados para executar um <ph id="ph2">`calli`</ph> instrução na pilha.</target>       </trans-unit>
        <trans-unit id="850" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Calli">
          <source>Note that <ph id="ph1">`calli`</ph> should be called through the below methods rather than using the <ph id="ph2">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> class to place the instruction directly on the stack.</source>
          <target state="translated">Observe que <ph id="ph1">`calli`</ph> deve ser chamado por meio de abaixo métodos em vez de usar o <ph id="ph2">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> classe para inserir a instrução diretamente na pilha.</target>       </trans-unit>
        <trans-unit id="851" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Calli">
          <source>ILGenerator.EmitCalli(Opcode, CallingConventions, Type, Type[], Type[]) for calls using a managed calling convention.</source>
          <target state="translated">ILGenerator.EmitCalli (Opcode, CallingConventions, tipo, tipo [], Type[]) para chamadas usando uma convenção de chamada gerenciada.</target>       </trans-unit>
        <trans-unit id="852" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Calli">
          <source>ILGenerator.EmitCalli(Opcode, CallingConvention, Type, Type[]) for calls using an unmanaged calling convention.</source>
          <target state="translated">ILGenerator.EmitCalli (código de operação, Type[]) CallingConvention, tipo, para chamadas usando uma convenção de chamada não gerenciada.</target>       </trans-unit>
        <trans-unit id="853" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Callvirt">
          <source>Calls a late-bound method on an object, pushing the return value onto the evaluation stack.</source>
          <target state="translated">Chama um método de associação tardia em um objeto, enviando o valor retornado por push para a pilha de avaliação.</target>       </trans-unit>
        <trans-unit id="854" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Callvirt">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">A tabela a seguir lista as instruções hexadecimal e formato de assembly do Microsoft Intermediate Language (MSIL), junto com um resumo breve de referência:</target>       </trans-unit>
        <trans-unit id="855" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Callvirt">
          <source>Format</source>
          <target state="translated">Formatar</target>       </trans-unit>
        <trans-unit id="856" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Callvirt">
          <source>Assembly Format</source>
          <target state="translated">Formato de assembly</target>       </trans-unit>
        <trans-unit id="857" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Callvirt">
          <source>Description</source>
          <target state="translated">Descrição</target>       </trans-unit>
        <trans-unit id="858" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Callvirt">
          <source>6F &lt; <ph id="ph1">`T`</ph><ph id="ph2"> &gt;</ph></source>
          <target state="translated">6F &lt; <ph id="ph1">`T`</ph><ph id="ph2"> &gt;</ph></target>       </trans-unit>
        <trans-unit id="859" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Callvirt">
          <source>callvirt <ph id="ph1">`method`</ph></source>
          <target state="translated">callvirt <ph id="ph1">`method`</ph></target>       </trans-unit>
        <trans-unit id="860" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Callvirt">
          <source>Calls a specific method associated with <ph id="ph1">`obj`</ph>.</source>
          <target state="translated">Chama um método específico associado <ph id="ph1">`obj`</ph>.</target>       </trans-unit>
        <trans-unit id="861" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Callvirt">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">O comportamento de transição de pilha, em ordem sequencial, é:</target>       </trans-unit>
        <trans-unit id="862" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Callvirt">
          <source>An object reference <ph id="ph1">`obj`</ph> is pushed onto the stack.</source>
          <target state="translated">Uma referência de objeto <ph id="ph1">`obj`</ph> é inserido na pilha.</target>       </trans-unit>
        <trans-unit id="863" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Callvirt">
          <source>Method arguments <ph id="ph1">`arg1`</ph> through <ph id="ph2">`argN`</ph> are pushed onto the stack.</source>
          <target state="translated">Argumentos de método <ph id="ph1">`arg1`</ph> por meio de <ph id="ph2">`argN`</ph> são colocados na pilha.</target>       </trans-unit>
        <trans-unit id="864" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Callvirt">
          <source>Method arguments <ph id="ph1">`arg1`</ph> through <ph id="ph2">`argN`</ph> and the object reference <ph id="ph3">`obj`</ph> are popped from the stack; the method call is performed with these arguments and control is transferred to the method in <ph id="ph4">`obj`</ph> referred to by the method metadata token.</source>
          <target state="translated">Argumentos de método <ph id="ph1">`arg1`</ph> por meio de <ph id="ph2">`argN`</ph> e a referência de objeto <ph id="ph3">`obj`</ph> são disparados da pilha; a chamada do método é executada com estes argumentos e o controle é transferido para o método <ph id="ph4">`obj`</ph> chamado pelo token de metadados de método.</target>       </trans-unit>
        <trans-unit id="865" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Callvirt">
          <source>When complete, a return value is generated by the callee method and sent to the caller.</source>
          <target state="translated">Ao concluir, um valor de retorno é gerado pelo método de receptor e enviado para o chamador.</target>       </trans-unit>
        <trans-unit id="866" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Callvirt">
          <source>The return value is pushed onto the stack.</source>
          <target state="translated">O valor de retorno é inserido na pilha.</target>       </trans-unit>
        <trans-unit id="867" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Callvirt">
          <source>The <ph id="ph1">`callvirt`</ph> instruction calls a late-bound method on an object.</source>
          <target state="translated">O <ph id="ph1">`callvirt`</ph> instrução chama um método de associação tardia em um objeto.</target>       </trans-unit>
        <trans-unit id="868" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Callvirt">
          <source>That is, the method is chosen based on the runtime type of <ph id="ph1">`obj`</ph> rather than the compile-time class visible in the method pointer.</source>
          <target state="translated">Ou seja, o método é escolhido com base no tipo de tempo de execução do <ph id="ph1">`obj`</ph> em vez da classe de tempo de compilação visível no ponteiro de método.</target>       </trans-unit>
        <trans-unit id="869" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Callvirt">
          <source><ph id="ph1">`Callvirt`</ph> can be used to call both virtual and instance methods.</source>
          <target state="translated"><ph id="ph1">`Callvirt`</ph> pode ser usado para chamar virtual e métodos de instância.</target>       </trans-unit>
        <trans-unit id="870" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Callvirt">
          <source>The <ph id="ph1">`callvirt`</ph> instruction may be immediately preceded by a <ph id="ph2">`tail`</ph> (<ph id="ph3">&lt;xref:System.Reflection.Emit.OpCodes.Tailcall&gt;</ph>) prefix to specify that the current stack frame should be released before transferring control.</source>
          <target state="translated">O <ph id="ph1">`callvirt`</ph> instrução pode ser imediatamente precedida por um <ph id="ph2">`tail`</ph> (<ph id="ph3">&lt;xref:System.Reflection.Emit.OpCodes.Tailcall&gt;</ph>) prefixo para especificar que o quadro de pilhas atual deve ser liberado antes da transferência de controle.</target>       </trans-unit>
        <trans-unit id="871" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Callvirt">
          <source>If the call would transfer control to a method of higher trust than the original method the stack frame will not be released.</source>
          <target state="translated">Se a chamada transfere controle para um método de confiança superior do método original de quadro de pilha não seja liberado.</target>       </trans-unit>
        <trans-unit id="872" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Callvirt">
          <source>The method metadata token provides the name, class and signature of the method to call.</source>
          <target state="translated">O token de metadados de método fornece o nome, a classe e a assinatura do método a ser chamado.</target>       </trans-unit>
        <trans-unit id="873" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Callvirt">
          <source>The class associated with <ph id="ph1">`obj`</ph> is the class of which it is an instance.</source>
          <target state="translated">A classe associada <ph id="ph1">`obj`</ph> é a classe do qual ele é uma instância.</target>       </trans-unit>
        <trans-unit id="874" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Callvirt">
          <source>If the class defines a non-static method that matches the indicated method name and signature, this method is called.</source>
          <target state="translated">Se a classe define um método não estático que corresponde ao nome do método indicado e a assinatura, este método é chamado.</target>       </trans-unit>
        <trans-unit id="875" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Callvirt">
          <source>Otherwise all classes in the base class chain of this class are checked in order.</source>
          <target state="translated">Caso contrário, todas as classes na cadeia de classe base desta classe são verificadas em ordem.</target>       </trans-unit>
        <trans-unit id="876" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Callvirt">
          <source>It is an error if no method is found.</source>
          <target state="translated">É um erro se nenhum método foi encontrado.</target>       </trans-unit>
        <trans-unit id="877" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Callvirt">
          <source><ph id="ph1">`Callvirt`</ph> pops the object and the associated arguments off the evaluation stack before calling the method.</source>
          <target state="translated"><ph id="ph1">`Callvirt`</ph> Exibe o objeto e os argumentos associados na pilha de avaliação antes de chamar o método.</target>       </trans-unit>
        <trans-unit id="878" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Callvirt">
          <source>If the method has a return value, it is pushed on the stack upon method completion.</source>
          <target state="translated">Se o método tiver um valor de retorno, ela é enviada por push na pilha após a conclusão do método.</target>       </trans-unit>
        <trans-unit id="879" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Callvirt">
          <source>On the callee side, the <ph id="ph1">`obj`</ph> parameter is accessed as argument 0, <ph id="ph2">`arg1`</ph> as argument 1, and so on.</source>
          <target state="translated">No lado receptor, o <ph id="ph1">`obj`</ph> parâmetro é acessado como argumento 0, <ph id="ph2">`arg1`</ph> como argumento 1 e assim por diante.</target>       </trans-unit>
        <trans-unit id="880" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Callvirt">
          <source>The arguments are placed on the stack in left-to-right order.</source>
          <target state="translated">Os argumentos são colocados na pilha na ordem da esquerda para direita.</target>       </trans-unit>
        <trans-unit id="881" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Callvirt">
          <source>That is, the first argument is computed and placed on the stack, then the second argument, then the third, until all necessary arguments are atop the stack in descending order.</source>
          <target state="translated">Ou seja, o primeiro argumento é calculado e colocado na pilha, em seguida, o segundo argumento e o terceiro, até que todos os argumentos necessários forem sobre a pilha em ordem decrescente.</target>       </trans-unit>
        <trans-unit id="882" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Callvirt">
          <source>The instance reference <ph id="ph1">`obj`</ph> (always required for <ph id="ph2">`callvirt`</ph>) must be pushed before any of the user-visible arguments.</source>
          <target state="translated">A referência de instância <ph id="ph1">`obj`</ph> (sempre necessário para <ph id="ph2">`callvirt`</ph>) deve ser enviado antes de qualquer um dos argumentos visível pelo usuário.</target>       </trans-unit>
        <trans-unit id="883" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Callvirt">
          <source>The signature (carried in the metadata token) need not contain an entry in the parameter list for the this pointer.</source>
          <target state="translated">A assinatura (executada no token de metadados) não precisa conter uma entrada na lista de parâmetros para este ponteiro.</target>       </trans-unit>
        <trans-unit id="884" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Callvirt">
          <source>Note that a virtual method can also be called using the <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Call&gt;</ph> instruction.</source>
          <target state="translated">Observe que um método virtual também pode ser chamado usando o <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Call&gt;</ph> instrução.</target>       </trans-unit>
        <trans-unit id="885" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Callvirt">
          <source><ph id="ph1">&lt;xref:System.MissingMethodException&gt;</ph> is thrown if a non-static method with the indicated name and signature could not be found in the class associated with <ph id="ph2">`obj`</ph> or any of its base classes.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.MissingMethodException&gt;</ph> é gerada se um método não estático com o nome indicado e a assinatura não pôde ser encontrado na classe associada <ph id="ph2">`obj`</ph> ou qualquer uma de suas classes base.</target>       </trans-unit>
        <trans-unit id="886" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Callvirt">
          <source>This is typically detected when Microsoft Intermediate Language (MSIL) instructions are converted to native code, rather than at runtime.</source>
          <target state="translated">Normalmente, isso é detectado quando instruções Microsoft Intermediate Language (MSIL) são convertidas em código nativo, em vez de em tempo de execução.</target>       </trans-unit>
        <trans-unit id="887" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Callvirt">
          <source><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> is thrown if obj is null.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> é gerada se o obj for null.</target>       </trans-unit>
        <trans-unit id="888" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Callvirt">
          <source><ph id="ph1">&lt;xref:System.Security.SecurityException&gt;</ph> is thrown if system security does not grant the caller access to the called method.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Security.SecurityException&gt;</ph> é gerada se a segurança do sistema não concede o acesso externo para o método chamado.</target>       </trans-unit>
        <trans-unit id="889" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Callvirt">
          <source>The security check may occur when the CIL is converted to native code rather than at run time.</source>
          <target state="translated">A verificação de segurança pode ocorrer quando a CIL é convertida em código nativo em vez de em tempo de execução.</target>       </trans-unit>
        <trans-unit id="890" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Callvirt">
          <source>When calling methods of System.Object on value types, consider using the <ph id="ph1">`constrained`</ph> prefix with the <ph id="ph2">`callvirt`</ph> instruction.</source>
          <target state="translated">Ao chamar métodos de System. Object em tipos de valor, considere o uso de <ph id="ph1">`constrained`</ph> prefixo com o <ph id="ph2">`callvirt`</ph> instrução.</target>       </trans-unit>
        <trans-unit id="891" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Callvirt">
          <source>This removes the need to emit different IL depending on whether or not the value type overrides the method, avoiding a potential versioning problem.</source>
          <target state="translated">Isso elimina a necessidade de emissão de IL diferente dependendo se o tipo de valor substitui o método, evitando um possível problema de controle de versão.</target>       </trans-unit>
        <trans-unit id="892" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Callvirt">
          <source>Consider using the <ph id="ph1">`constrained`</ph> prefix when invoking interface methods on value types, since the value type method implementing the interface method can be changed using a <ph id="ph2">`MethodImpl`</ph>.</source>
          <target state="translated">Considere o uso de <ph id="ph1">`constrained`</ph> prefixo ao chamar métodos em tipos de valor, como o método de tipo de valor implementando o método de interface pode ser alterado usando um <ph id="ph2">`MethodImpl`</ph>.</target>       </trans-unit>
        <trans-unit id="893" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Callvirt">
          <source>These issues are described in more detail in the <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Constrained&gt;</ph> opcode.</source>
          <target state="translated">Esses problemas são descritos mais detalhadamente o <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Constrained&gt;</ph> opcode.</target>       </trans-unit>
        <trans-unit id="894" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Callvirt">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`callvirt`</ph> opcode:</source>
          <target state="translated">O seguinte <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> sobrecarga de método pode usar o <ph id="ph2">`callvirt`</ph> opcode:</target>       </trans-unit>
        <trans-unit id="895" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Callvirt">
          <source>ILGenerator.Emit(OpCode, MethodInfo)</source>
          <target state="translated">ILGenerator.Emit(OpCode, MethodInfo)</target>       </trans-unit>
        <trans-unit id="896" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Callvirt">
          <source>ILGenerator.EmitCall(OpCode, MethodInfo, Type[])</source>
          <target state="translated">ILGenerator.EmitCall(OpCode, MethodInfo, Type[])</target>       </trans-unit>
        <trans-unit id="897" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Castclass">
          <source>Attempts to cast an object passed by reference to the specified class.</source>
          <target state="translated">Tenta converter um objeto passado por referência à classe especificada.</target>       </trans-unit>
        <trans-unit id="898" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Castclass">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">A tabela a seguir lista as instruções hexadecimal e formato de assembly do Microsoft Intermediate Language (MSIL), junto com um resumo breve de referência:</target>       </trans-unit>
        <trans-unit id="899" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Castclass">
          <source>Format</source>
          <target state="translated">Formatar</target>       </trans-unit>
        <trans-unit id="900" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Castclass">
          <source>Assembly Format</source>
          <target state="translated">Formato de assembly</target>       </trans-unit>
        <trans-unit id="901" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Castclass">
          <source>Description</source>
          <target state="translated">Descrição</target>       </trans-unit>
        <trans-unit id="902" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Castclass">
          <source>74 &lt; <ph id="ph1">`T`</ph><ph id="ph2"> &gt;</ph></source>
          <target state="translated">74 &lt; <ph id="ph1">`T`</ph><ph id="ph2"> &gt;</ph></target>       </trans-unit>
        <trans-unit id="903" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Castclass">
          <source>castclass <ph id="ph1">`class`</ph></source>
          <target state="translated">castclass <ph id="ph1">`class`</ph></target>       </trans-unit>
        <trans-unit id="904" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Castclass">
          <source>Casts an object to a new object of type <ph id="ph1">`class`</ph>.</source>
          <target state="translated">Converte um objeto para um novo objeto do tipo <ph id="ph1">`class`</ph>.</target>       </trans-unit>
        <trans-unit id="905" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Castclass">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">O comportamento de transição de pilha, em ordem sequencial, é:</target>       </trans-unit>
        <trans-unit id="906" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Castclass">
          <source>An object reference is pushed onto the stack.</source>
          <target state="translated">Uma referência de objeto é inserida na pilha.</target>       </trans-unit>
        <trans-unit id="907" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Castclass">
          <source>The object reference is popped from the stack; the referenced object is cast as the specified <ph id="ph1">`class`</ph>.</source>
          <target state="translated">A referência de objeto é exibida da pilha; o objeto referenciado é convertido conforme o especificado <ph id="ph1">`class`</ph>.</target>       </trans-unit>
        <trans-unit id="908" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Castclass">
          <source>If successful, a new object reference is pushed onto the stack.</source>
          <target state="translated">Se for bem-sucedido, uma nova referência de objeto é inserida na pilha.</target>       </trans-unit>
        <trans-unit id="909" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Castclass">
          <source>The <ph id="ph1">`castclass`</ph> instruction attempts to cast the object reference (type <ph id="ph2">`O`</ph>) atop the stack to a specified class.</source>
          <target state="translated">O <ph id="ph1">`castclass`</ph> instrução tenta converter a referência de objeto (tipo <ph id="ph2">`O`</ph>) sobre a pilha para uma determinada classe.</target>       </trans-unit>
        <trans-unit id="910" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Castclass">
          <source>The new class is specified by a metadata token indicating the desired class.</source>
          <target state="translated">A nova classe é especificada por um token de metadados que indica a classe desejada.</target>       </trans-unit>
        <trans-unit id="911" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Castclass">
          <source>If the class of the object on the top of the stack does not implement the new class (assuming the new class is an interface) and is not a derived class of the new class then an <ph id="ph1">&lt;xref:System.InvalidCastException&gt;</ph> is thrown.</source>
          <target state="translated">Se a classe do objeto no topo da pilha não implementa a nova classe (supondo que a nova classe é uma interface) e não é uma classe derivada da nova classe e um <ph id="ph1">&lt;xref:System.InvalidCastException&gt;</ph> é gerada.</target>       </trans-unit>
        <trans-unit id="912" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Castclass">
          <source>If the object reference is a null reference, <ph id="ph1">`castclass`</ph> succeeds and returns the new object as a null reference.</source>
          <target state="translated">Se a referência de objeto é uma referência nula, <ph id="ph1">`castclass`</ph> for bem-sucedida e retorna o novo objeto como uma referência nula.</target>       </trans-unit>
        <trans-unit id="913" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Castclass">
          <source><ph id="ph1">&lt;xref:System.InvalidCastException&gt;</ph> is thrown if obj cannot be cast to class.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.InvalidCastException&gt;</ph> é gerada se o obj não pode ser convertido em classe.</target>       </trans-unit>
        <trans-unit id="914" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Castclass">
          <source><ph id="ph1">&lt;xref:System.TypeLoadException&gt;</ph> is thrown if class cannot be found.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.TypeLoadException&gt;</ph> é gerada se a classe não pode ser encontrada.</target>       </trans-unit>
        <trans-unit id="915" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Castclass">
          <source>This is typically detected when a Microsoft Intermediate Language (MSIL)instruction is converted to native code rather than at runtime.</source>
          <target state="translated">Normalmente, isso é detectado quando uma instrução Microsoft Intermediate Language (MSIL) é convertida em código nativo em vez de em tempo de execução.</target>       </trans-unit>
        <trans-unit id="916" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Castclass">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`castclass`</ph> opcode:</source>
          <target state="translated">O seguinte <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> sobrecarga de método pode usar o <ph id="ph2">`castclass`</ph> opcode:</target>       </trans-unit>
        <trans-unit id="917" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Castclass">
          <source>ILGenerator.Emit(OpCode, Type)</source>
          <target state="translated">ILGenerator.Emit(OpCode, Type)</target>       </trans-unit>
        <trans-unit id="918" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Ceq">
          <source>Compares two values.</source>
          <target state="translated">Compara dois valores.</target>       </trans-unit>
        <trans-unit id="919" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Ceq">
          <source>If they are equal, the integer value 1 <ph id="ph1">&lt;see langword="(int32" /&gt;</ph>) is pushed onto the evaluation stack; otherwise 0 (<ph id="ph2">&lt;see langword="int32" /&gt;</ph>) is pushed onto the evaluation stack.</source>
          <target state="translated">Se eles forem iguais, o valor inteiro 1 <ph id="ph1">&lt;see langword="(int32" /&gt;</ph>) será enviado para a pilha de avaliação; caso contrário, 0 (<ph id="ph2">&lt;see langword="int32" /&gt;</ph>) será enviado para a pilha de avaliação.</target>       </trans-unit>
        <trans-unit id="920" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ceq">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">A tabela a seguir lista as instruções hexadecimal e formato de assembly do Microsoft Intermediate Language (MSIL), junto com um resumo breve de referência:</target>       </trans-unit>
        <trans-unit id="921" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ceq">
          <source>Format</source>
          <target state="translated">Formatar</target>       </trans-unit>
        <trans-unit id="922" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ceq">
          <source>Assembly Format</source>
          <target state="translated">Formato de assembly</target>       </trans-unit>
        <trans-unit id="923" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ceq">
          <source>Description</source>
          <target state="translated">Descrição</target>       </trans-unit>
        <trans-unit id="924" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ceq">
          <source>FE 01</source>
          <target state="translated">FE 01</target>       </trans-unit>
        <trans-unit id="925" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ceq">
          <source>ceq</source>
          <target state="translated">ceq</target>       </trans-unit>
        <trans-unit id="926" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ceq">
          <source>Pushes 1 if <ph id="ph1">`value1`</ph> equals <ph id="ph2">`value2`</ph>; else pushes 0.</source>
          <target state="translated">Envia 1 se <ph id="ph1">`value1`</ph> é igual a <ph id="ph2">`value2`</ph>; caso contrário envia 0.</target>       </trans-unit>
        <trans-unit id="927" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ceq">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">O comportamento de transição de pilha, em ordem sequencial, é:</target>       </trans-unit>
        <trans-unit id="928" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ceq">
          <source><ph id="ph1">`value1`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value1`</ph> é inserido na pilha.</target>       </trans-unit>
        <trans-unit id="929" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ceq">
          <source><ph id="ph1">`value2`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value2`</ph> é inserido na pilha.</target>       </trans-unit>
        <trans-unit id="930" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ceq">
          <source><ph id="ph1">`value2`</ph> and <ph id="ph2">`value1`</ph> are popped from the stack; <ph id="ph3">`value1`</ph> is compared to <ph id="ph4">`value2`</ph>.</source>
          <target state="translated"><ph id="ph1">`value2`</ph> e <ph id="ph2">`value1`</ph> são disparados da pilha; <ph id="ph3">`value1`</ph> é comparado ao <ph id="ph4">`value2`</ph>.</target>       </trans-unit>
        <trans-unit id="931" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ceq">
          <source>If <ph id="ph1">`value1`</ph> is equal to <ph id="ph2">`value2`</ph>, 1 is pushed onto the stack; otherwise 0 is pushed onto the stack.</source>
          <target state="translated">Se <ph id="ph1">`value1`</ph> é igual a <ph id="ph2">`value2`</ph>, 1 é inserido na pilha; caso contrário, 0 é inserido na pilha.</target>       </trans-unit>
        <trans-unit id="932" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ceq">
          <source>The <ph id="ph1">`ceq`</ph> instruction compares <ph id="ph2">`value1`</ph> and <ph id="ph3">`value2`</ph>.</source>
          <target state="translated">O <ph id="ph1">`ceq`</ph> instrução compara <ph id="ph2">`value1`</ph> e <ph id="ph3">`value2`</ph>.</target>       </trans-unit>
        <trans-unit id="933" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ceq">
          <source>If <ph id="ph1">`value1`</ph> is equal to <ph id="ph2">`value2`</ph>, then 1 (of type <ph id="ph3">`int32`</ph>) is pushed on the stack.</source>
          <target state="translated">Se <ph id="ph1">`value1`</ph> é igual a <ph id="ph2">`value2`</ph>, em seguida, 1 (do tipo <ph id="ph3">`int32`</ph>) é enviada por push na pilha.</target>       </trans-unit>
        <trans-unit id="934" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ceq">
          <source>Otherwise 0 (of type <ph id="ph1">`int32`</ph>) is pushed on the stack.</source>
          <target state="translated">Caso contrário, 0 (do tipo <ph id="ph1">`int32`</ph>) é enviada por push na pilha.</target>       </trans-unit>
        <trans-unit id="935" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ceq">
          <source>For floating-point number, <ph id="ph1">`ceq`</ph> will return 0 if the numbers are unordered (either or both are NaN).</source>
          <target state="translated">Número de ponto flutuante, <ph id="ph1">`ceq`</ph> retornará 0 se os números são classificados (um ou ambos são NaN).</target>       </trans-unit>
        <trans-unit id="936" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ceq">
          <source>The infinite values are equal to themselves.</source>
          <target state="translated">Os valores de infinitos são iguais entre si.</target>       </trans-unit>
        <trans-unit id="937" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ceq">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`ceq`</ph> opcode:</source>
          <target state="translated">O seguinte <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> sobrecarga de método pode usar o <ph id="ph2">`ceq`</ph> opcode:</target>       </trans-unit>
        <trans-unit id="938" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ceq">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="939" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Cgt">
          <source>Compares two values.</source>
          <target state="translated">Compara dois valores.</target>       </trans-unit>
        <trans-unit id="940" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Cgt">
          <source>If the first value is greater than the second, the integer value 1 <ph id="ph1">&lt;see langword="(int32" /&gt;</ph>) is pushed onto the evaluation stack; otherwise 0 (<ph id="ph2">&lt;see langword="int32" /&gt;</ph>) is pushed onto the evaluation stack.</source>
          <target state="translated">Se o primeiro valor for maior que o segundo, o valor inteiro 1 <ph id="ph1">&lt;see langword="(int32" /&gt;</ph>) será enviado para a pilha de avaliação; caso contrário, 0 (<ph id="ph2">&lt;see langword="int32" /&gt;</ph>) será enviada para a pilha de avaliação.</target>       </trans-unit>
        <trans-unit id="941" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Cgt">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">A tabela a seguir lista as instruções hexadecimal e formato de assembly do Microsoft Intermediate Language (MSIL), junto com um resumo breve de referência:</target>       </trans-unit>
        <trans-unit id="942" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Cgt">
          <source>Format</source>
          <target state="translated">Formatar</target>       </trans-unit>
        <trans-unit id="943" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Cgt">
          <source>Assembly Format</source>
          <target state="translated">Formato de assembly</target>       </trans-unit>
        <trans-unit id="944" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Cgt">
          <source>Description</source>
          <target state="translated">Descrição</target>       </trans-unit>
        <trans-unit id="945" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Cgt">
          <source>FE 02</source>
          <target state="translated">FE 02</target>       </trans-unit>
        <trans-unit id="946" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Cgt">
          <source>cgt</source>
          <target state="translated">cgt</target>       </trans-unit>
        <trans-unit id="947" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Cgt">
          <source>Pushes 1 if <ph id="ph1">`value1`</ph> is greater than <ph id="ph2">`value2`</ph>; else pushes 0.</source>
          <target state="translated">Envia 1 se <ph id="ph1">`value1`</ph> é maior do que <ph id="ph2">`value2`</ph>; caso contrário envia 0.</target>       </trans-unit>
        <trans-unit id="948" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Cgt">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">O comportamento de transição de pilha, em ordem sequencial, é:</target>       </trans-unit>
        <trans-unit id="949" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Cgt">
          <source><ph id="ph1">`value1`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value1`</ph> é inserido na pilha.</target>       </trans-unit>
        <trans-unit id="950" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Cgt">
          <source><ph id="ph1">`value2`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value2`</ph> é inserido na pilha.</target>       </trans-unit>
        <trans-unit id="951" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Cgt">
          <source><ph id="ph1">`value2`</ph> and <ph id="ph2">`value1`</ph> are popped from the stack; <ph id="ph3">`cgt`</ph> tests if <ph id="ph4">`value1`</ph> is greater than <ph id="ph5">`value2`</ph>.</source>
          <target state="translated"><ph id="ph1">`value2`</ph> e <ph id="ph2">`value1`</ph> são disparados da pilha; <ph id="ph3">`cgt`</ph> testa se <ph id="ph4">`value1`</ph> é maior do que <ph id="ph5">`value2`</ph>.</target>       </trans-unit>
        <trans-unit id="952" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Cgt">
          <source>If <ph id="ph1">`value1`</ph> is greater than <ph id="ph2">`value2`</ph>, 1 is pushed onto the stack; otherwise 0 is pushed onto the stack.</source>
          <target state="translated">Se <ph id="ph1">`value1`</ph> é maior do que <ph id="ph2">`value2`</ph>, 1 é inserido na pilha; caso contrário, 0 é inserido na pilha.</target>       </trans-unit>
        <trans-unit id="953" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Cgt">
          <source>The <ph id="ph1">`cgt`</ph> instruction compares <ph id="ph2">`value1`</ph> and <ph id="ph3">`value2`</ph>.</source>
          <target state="translated">O <ph id="ph1">`cgt`</ph> instrução compara <ph id="ph2">`value1`</ph> e <ph id="ph3">`value2`</ph>.</target>       </trans-unit>
        <trans-unit id="954" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Cgt">
          <source>If <ph id="ph1">`value1`</ph> is strictly greater than <ph id="ph2">`value2`</ph>, then an <ph id="ph3">`int32`</ph> value of 1 is pushed on the stack.</source>
          <target state="translated">Se <ph id="ph1">`value1`</ph> é estritamente maior que <ph id="ph2">`value2`</ph>, então um <ph id="ph3">`int32`</ph> valor 1 é enviada por push na pilha.</target>       </trans-unit>
        <trans-unit id="955" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Cgt">
          <source>Otherwise, an <ph id="ph1">`int32`</ph> value of 0 is pushed on the stack.</source>
          <target state="translated">Caso contrário, um <ph id="ph1">`int32`</ph> valor de 0 é enviada por push na pilha.</target>       </trans-unit>
        <trans-unit id="956" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Cgt">
          <source>For floating-point numbers, <ph id="ph1">`cgt`</ph> returns 0 if the numbers are unordered (that is, if one or both of the arguments are NaN).</source>
          <target state="translated">Para números de ponto flutuante, <ph id="ph1">`cgt`</ph> retornará 0 se os números são classificados (ou seja, se um ou ambos os argumentos forem NaN).</target>       </trans-unit>
        <trans-unit id="957" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Cgt">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`cgt`</ph> opcode:</source>
          <target state="translated">O seguinte <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> sobrecarga de método pode usar o <ph id="ph2">`cgt`</ph> opcode:</target>       </trans-unit>
        <trans-unit id="958" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Cgt">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="959" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Cgt_Un">
          <source>Compares two unsigned or unordered values.</source>
          <target state="translated">Compara dois sem sinal ou não ordenados.</target>       </trans-unit>
        <trans-unit id="960" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Cgt_Un">
          <source>If the first value is greater than the second, the integer value 1 <ph id="ph1">&lt;see langword="(int32" /&gt;</ph>) is pushed onto the evaluation stack; otherwise 0 (<ph id="ph2">&lt;see langword="int32" /&gt;</ph>) is pushed onto the evaluation stack.</source>
          <target state="translated">Se o primeiro valor for maior que o segundo, o valor inteiro 1 <ph id="ph1">&lt;see langword="(int32" /&gt;</ph>) será enviado para a pilha de avaliação; caso contrário, 0 (<ph id="ph2">&lt;see langword="int32" /&gt;</ph>) será enviada para a pilha de avaliação.</target>       </trans-unit>
        <trans-unit id="961" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Cgt_Un">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">A tabela a seguir lista as instruções hexadecimal e formato de assembly do Microsoft Intermediate Language (MSIL), junto com um resumo breve de referência:</target>       </trans-unit>
        <trans-unit id="962" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Cgt_Un">
          <source>Format</source>
          <target state="translated">Formatar</target>       </trans-unit>
        <trans-unit id="963" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Cgt_Un">
          <source>Assembly Format</source>
          <target state="translated">Formato de assembly</target>       </trans-unit>
        <trans-unit id="964" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Cgt_Un">
          <source>Description</source>
          <target state="translated">Descrição</target>       </trans-unit>
        <trans-unit id="965" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Cgt_Un">
          <source>FE 03</source>
          <target state="translated">FE 03</target>       </trans-unit>
        <trans-unit id="966" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Cgt_Un">
          <source>cgt.un</source>
          <target state="translated">cgt.un</target>       </trans-unit>
        <trans-unit id="967" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Cgt_Un">
          <source>Pushes 1 if <ph id="ph1">`value1`</ph> is greater than <ph id="ph2">`value2`</ph>; else pushes 0 (unsigned values).</source>
          <target state="translated">Envia 1 se <ph id="ph1">`value1`</ph> é maior do que <ph id="ph2">`value2`</ph>; caso contrário envia 0 (valores sem sinal).</target>       </trans-unit>
        <trans-unit id="968" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Cgt_Un">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">O comportamento de transição de pilha, em ordem sequencial, é:</target>       </trans-unit>
        <trans-unit id="969" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Cgt_Un">
          <source><ph id="ph1">`value1`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value1`</ph> é inserido na pilha.</target>       </trans-unit>
        <trans-unit id="970" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Cgt_Un">
          <source><ph id="ph1">`value2`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value2`</ph> é inserido na pilha.</target>       </trans-unit>
        <trans-unit id="971" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Cgt_Un">
          <source><ph id="ph1">`value2`</ph> and <ph id="ph2">`value1`</ph> are popped from the stack; <ph id="ph3">`cgt.un`</ph> tests if <ph id="ph4">`value1`</ph> is greater than <ph id="ph5">`value2`</ph>.</source>
          <target state="translated"><ph id="ph1">`value2`</ph> e <ph id="ph2">`value1`</ph> são disparados da pilha; <ph id="ph3">`cgt.un`</ph> testa se <ph id="ph4">`value1`</ph> é maior do que <ph id="ph5">`value2`</ph>.</target>       </trans-unit>
        <trans-unit id="972" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Cgt_Un">
          <source>If <ph id="ph1">`value1`</ph> is greater than <ph id="ph2">`value2`</ph>, 1 is pushed onto the stack; otherwise 0 is pushed onto the stack.</source>
          <target state="translated">Se <ph id="ph1">`value1`</ph> é maior do que <ph id="ph2">`value2`</ph>, 1 é inserido na pilha; caso contrário, 0 é inserido na pilha.</target>       </trans-unit>
        <trans-unit id="973" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Cgt_Un">
          <source>An <ph id="ph1">`int32`</ph> value of 1 is pushed on the stack if any of the following is <ph id="ph2">`true`</ph> :</source>
          <target state="translated">Um <ph id="ph1">`int32`</ph> valor 1 é enviada por push na pilha se qualquer um dos seguintes for <ph id="ph2">`true`</ph> :</target>       </trans-unit>
        <trans-unit id="974" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Cgt_Un">
          <source>For floating-point numbers, <ph id="ph1">`value1`</ph> is not ordered with respect to <ph id="ph2">`value2`</ph>.</source>
          <target state="translated">Para números de ponto flutuante, <ph id="ph1">`value1`</ph> não for ordenado em relação ao <ph id="ph2">`value2`</ph>.</target>       </trans-unit>
        <trans-unit id="975" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Cgt_Un">
          <source>For integer values, <ph id="ph1">`value1`</ph> is strictly greater than <ph id="ph2">`value2`</ph> when considered as unsigned numbers.</source>
          <target state="translated">Para valores inteiros, <ph id="ph1">`value1`</ph> é estritamente maior que <ph id="ph2">`value2`</ph> quando considerados como números sem sinal.</target>       </trans-unit>
        <trans-unit id="976" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Cgt_Un">
          <source>Otherwise an <ph id="ph1">`int32`</ph> value of 0 is pushed on the stack.</source>
          <target state="translated">Caso contrário, um <ph id="ph1">`int32`</ph> valor de 0 é enviada por push na pilha.</target>       </trans-unit>
        <trans-unit id="977" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Cgt_Un">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`cgt.un`</ph> opcode:</source>
          <target state="translated">O seguinte <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> sobrecarga de método pode usar o <ph id="ph2">`cgt.un`</ph> opcode:</target>       </trans-unit>
        <trans-unit id="978" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Cgt_Un">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="979" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Ckfinite">
          <source>Throws <ph id="ph1">&lt;see cref="T:System.ArithmeticException" /&gt;</ph> if value is not a finite number.</source>
          <target state="translated">Gera <ph id="ph1">&lt;see cref="T:System.ArithmeticException" /&gt;</ph> se o valor não for um número finito.</target>       </trans-unit>
        <trans-unit id="980" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ckfinite">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">A tabela a seguir lista as instruções hexadecimal e formato de assembly do Microsoft Intermediate Language (MSIL), junto com um resumo breve de referência:</target>       </trans-unit>
        <trans-unit id="981" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ckfinite">
          <source>Format</source>
          <target state="translated">Formatar</target>       </trans-unit>
        <trans-unit id="982" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ckfinite">
          <source>Assembly Format</source>
          <target state="translated">Formato de assembly</target>       </trans-unit>
        <trans-unit id="983" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ckfinite">
          <source>Description</source>
          <target state="translated">Descrição</target>       </trans-unit>
        <trans-unit id="984" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ckfinite">
          <source>C3</source>
          <target state="translated">C3</target>       </trans-unit>
        <trans-unit id="985" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ckfinite">
          <source>ckfinite</source>
          <target state="translated">ckfinite</target>       </trans-unit>
        <trans-unit id="986" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ckfinite">
          <source>throw <ph id="ph1">&lt;xref:System.ArithmeticException&gt;</ph> if value is not a finite number.</source>
          <target state="translated">lançar <ph id="ph1">&lt;xref:System.ArithmeticException&gt;</ph> se o valor não é um número finito.</target>       </trans-unit>
        <trans-unit id="987" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ckfinite">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">O comportamento de transição de pilha, em ordem sequencial, é:</target>       </trans-unit>
        <trans-unit id="988" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ckfinite">
          <source><ph id="ph1">`value`</ph> is pushed onto the stack..</source>
          <target state="translated"><ph id="ph1">`value`</ph> é inserido na pilha.</target>       </trans-unit>
        <trans-unit id="989" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ckfinite">
          <source><ph id="ph1">`value`</ph> is popped from the stack and the <ph id="ph2">`ckfinite`</ph> instruction is performed on it.</source>
          <target state="translated"><ph id="ph1">`value`</ph> é exibido da pilha e a <ph id="ph2">`ckfinite`</ph> instrução é executada nele.</target>       </trans-unit>
        <trans-unit id="990" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ckfinite">
          <source><ph id="ph1">`value`</ph> is pushed back onto the stack if no exception is thrown.</source>
          <target state="translated"><ph id="ph1">`value`</ph> é enviada de volta para a pilha se nenhuma exceção for lançada.</target>       </trans-unit>
        <trans-unit id="991" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ckfinite">
          <source>The <ph id="ph1">`ckfinite instruction`</ph> throws <ph id="ph2">&lt;xref:System.ArithmeticException&gt;</ph> if <ph id="ph3">`value`</ph> (a floating-point number) is either a "not a number" value (NaN) or a <ph id="ph4">`+-`</ph> infinity value.</source>
          <target state="translated">O <ph id="ph1">`ckfinite instruction`</ph> lança <ph id="ph2">&lt;xref:System.ArithmeticException&gt;</ph> se <ph id="ph3">`value`</ph> (um número de ponto flutuante) é um valor de "não é um número" (NaN) ou um <ph id="ph4">`+-`</ph> valor infinito.</target>       </trans-unit>
        <trans-unit id="992" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ckfinite">
          <source><ph id="ph1">`Ckfinite`</ph> leaves the value on the stack if no exception is thrown.</source>
          <target state="translated"><ph id="ph1">`Ckfinite`</ph> deixa o valor na pilha se nenhuma exceção for lançada.</target>       </trans-unit>
        <trans-unit id="993" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ckfinite">
          <source>Execution is unspecified if <ph id="ph1">`value`</ph> is not a floating-point number.</source>
          <target state="translated">A execução não for especificada, se <ph id="ph1">`value`</ph> não é um número de ponto flutuante.</target>       </trans-unit>
        <trans-unit id="994" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ckfinite">
          <source><ph id="ph1">&lt;xref:System.ArithmeticException&gt;</ph> is thrown if <ph id="ph2">`value`</ph> is not a 'normal' number.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.ArithmeticException&gt;</ph> será gerada se <ph id="ph2">`value`</ph> não é um número 'normal'.</target>       </trans-unit>
        <trans-unit id="995" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ckfinite">
          <source>Note that a special exception or a derived class of <ph id="ph1">&lt;xref:System.ArithmeticException&gt;</ph> may be more appropriate, passing the incorrect value to the exception handler.</source>
          <target state="translated">Observe que uma exceção especial ou uma classe derivada de <ph id="ph1">&lt;xref:System.ArithmeticException&gt;</ph> pode ser mais apropriado, passando o valor incorreto para o manipulador de exceção.</target>       </trans-unit>
        <trans-unit id="996" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ckfinite">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`ckfinite`</ph> opcode:</source>
          <target state="translated">O seguinte <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> sobrecarga de método pode usar o <ph id="ph2">`ckfinite`</ph> opcode:</target>       </trans-unit>
        <trans-unit id="997" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ckfinite">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="998" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Clt">
          <source>Compares two values.</source>
          <target state="translated">Compara dois valores.</target>       </trans-unit>
        <trans-unit id="999" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Clt">
          <source>If the first value is less than the second, the integer value 1 <ph id="ph1">&lt;see langword="(int32" /&gt;</ph>) is pushed onto the evaluation stack; otherwise 0 (<ph id="ph2">&lt;see langword="int32" /&gt;</ph>) is pushed onto the evaluation stack.</source>
          <target state="translated">Se o primeiro valor for menor que o segundo, o valor inteiro 1 (<ph id="ph1">&lt;see langword="(int32" /&gt;</ph>) será enviado para a pilha de avaliação; caso contrário, 0 (<ph id="ph2">&lt;see langword="int32" /&gt;</ph>) será enviada para a pilha de avaliação.</target>       </trans-unit>
        <trans-unit id="1000" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Clt">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">A tabela a seguir lista as instruções hexadecimal e formato de assembly do Microsoft Intermediate Language (MSIL), junto com um resumo breve de referência:</target>       </trans-unit>
        <trans-unit id="1001" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Clt">
          <source>Format</source>
          <target state="translated">Formatar</target>       </trans-unit>
        <trans-unit id="1002" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Clt">
          <source>Assembly Format</source>
          <target state="translated">Formato de assembly</target>       </trans-unit>
        <trans-unit id="1003" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Clt">
          <source>Description</source>
          <target state="translated">Descrição</target>       </trans-unit>
        <trans-unit id="1004" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Clt">
          <source>FE 04</source>
          <target state="translated">FE 04</target>       </trans-unit>
        <trans-unit id="1005" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Clt">
          <source>clt</source>
          <target state="translated">clt</target>       </trans-unit>
        <trans-unit id="1006" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Clt">
          <source>Pushes 1 if <ph id="ph1">`value1`</ph> is less than <ph id="ph2">`value2`</ph>; else pushes 0.</source>
          <target state="translated">Envia 1 se <ph id="ph1">`value1`</ph> é menor que <ph id="ph2">`value2`</ph>; caso contrário envia 0.</target>       </trans-unit>
        <trans-unit id="1007" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Clt">
          <source>The stack transitional behavior, in sequential order, is: <ph id="ph1">`value1`</ph> is pushed onto the stack.</source>
          <target state="translated">O comportamento de transição de pilha, em ordem sequencial, é: <ph id="ph1">`value1`</ph> é inserido na pilha.</target>       </trans-unit>
        <trans-unit id="1008" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Clt">
          <source><ph id="ph1">`value2`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value2`</ph> é inserido na pilha.</target>       </trans-unit>
        <trans-unit id="1009" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Clt">
          <source><ph id="ph1">`value2`</ph> and <ph id="ph2">`value1`</ph> are popped from the stack; <ph id="ph3">`clt`</ph> tests if <ph id="ph4">`value1`</ph> is less than <ph id="ph5">`value2`</ph>.</source>
          <target state="translated"><ph id="ph1">`value2`</ph> e <ph id="ph2">`value1`</ph> são disparados da pilha; <ph id="ph3">`clt`</ph> testa se <ph id="ph4">`value1`</ph> é menor que <ph id="ph5">`value2`</ph>.</target>       </trans-unit>
        <trans-unit id="1010" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Clt">
          <source>If <ph id="ph1">`value1`</ph> is less than <ph id="ph2">`value2`</ph>, 1 is pushed onto the stack; otherwise 0 is pushed onto the stack.</source>
          <target state="translated">Se <ph id="ph1">`value1`</ph> é menor que <ph id="ph2">`value2`</ph>, 1 é inserido na pilha; caso contrário, 0 é inserido na pilha.</target>       </trans-unit>
        <trans-unit id="1011" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Clt">
          <source>The <ph id="ph1">`clt`</ph> instruction compares <ph id="ph2">`value1`</ph> and <ph id="ph3">`value2`</ph>.</source>
          <target state="translated">O <ph id="ph1">`clt`</ph> instrução compara <ph id="ph2">`value1`</ph> e <ph id="ph3">`value2`</ph>.</target>       </trans-unit>
        <trans-unit id="1012" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Clt">
          <source>If <ph id="ph1">`value1`</ph> is strictly less than <ph id="ph2">`value2`</ph>, then an <ph id="ph3">`int32`</ph> value of 1 is pushed on the stack.</source>
          <target state="translated">Se <ph id="ph1">`value1`</ph> é estritamente menor que <ph id="ph2">`value2`</ph>, então um <ph id="ph3">`int32`</ph> valor 1 é enviada por push na pilha.</target>       </trans-unit>
        <trans-unit id="1013" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Clt">
          <source>Otherwise, an <ph id="ph1">`int32`</ph> value of 0 is pushed on the stack.</source>
          <target state="translated">Caso contrário, um <ph id="ph1">`int32`</ph> valor de 0 é enviada por push na pilha.</target>       </trans-unit>
        <trans-unit id="1014" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Clt">
          <source>For floating-point numbers, <ph id="ph1">`clt`</ph> returns 0 if the numbers are unordered (that is, if one or both of the arguments are NaN).</source>
          <target state="translated">Para números de ponto flutuante, <ph id="ph1">`clt`</ph> retornará 0 se os números são classificados (ou seja, se um ou ambos os argumentos forem NaN).</target>       </trans-unit>
        <trans-unit id="1015" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Clt">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`clt`</ph> opcode:</source>
          <target state="translated">O seguinte <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> sobrecarga de método pode usar o <ph id="ph2">`clt`</ph> opcode:</target>       </trans-unit>
        <trans-unit id="1016" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Clt">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="1017" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Clt_Un">
          <source>Compares the unsigned or unordered values <ph id="ph1">&lt;paramref name="value1" /&gt;</ph> and <ph id="ph2">&lt;paramref name="value2" /&gt;</ph>.</source>
          <target state="translated">Compara os valores sem sinal ou não ordenados <ph id="ph1">&lt;paramref name="value1" /&gt;</ph> e <ph id="ph2">&lt;paramref name="value2" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1018" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Clt_Un">
          <source>If <ph id="ph1">&lt;paramref name="value1" /&gt;</ph> is less than <ph id="ph2">&lt;paramref name="value2" /&gt;</ph>, then the integer value 1 <ph id="ph3">&lt;see langword="(int32" /&gt;</ph>) is pushed onto the evaluation stack; otherwise 0 (<ph id="ph4">&lt;see langword="int32" /&gt;</ph>) is pushed onto the evaluation stack.</source>
          <target state="translated">Se <ph id="ph1">&lt;paramref name="value1" /&gt;</ph> for menor que <ph id="ph2">&lt;paramref name="value2" /&gt;</ph>, o valor de inteiro 1 (<ph id="ph3">&lt;see langword="(int32" /&gt;</ph>) será enviado para a pilha de avaliação; caso contrário, 0 (<ph id="ph4">&lt;see langword="int32" /&gt;</ph>) será enviado para a pilha de avaliação.</target>       </trans-unit>
        <trans-unit id="1019" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Clt_Un">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">A tabela a seguir lista as instruções hexadecimal e formato de assembly do Microsoft Intermediate Language (MSIL), junto com um resumo breve de referência:</target>       </trans-unit>
        <trans-unit id="1020" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Clt_Un">
          <source>Format</source>
          <target state="translated">Formatar</target>       </trans-unit>
        <trans-unit id="1021" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Clt_Un">
          <source>Assembly Format</source>
          <target state="translated">Formato de assembly</target>       </trans-unit>
        <trans-unit id="1022" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Clt_Un">
          <source>Description</source>
          <target state="translated">Descrição</target>       </trans-unit>
        <trans-unit id="1023" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Clt_Un">
          <source>FE 05</source>
          <target state="translated">FE 05</target>       </trans-unit>
        <trans-unit id="1024" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Clt_Un">
          <source>clt.un</source>
          <target state="translated">CLT.Un</target>       </trans-unit>
        <trans-unit id="1025" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Clt_Un">
          <source>Pushes 1 if <ph id="ph1">`value1`</ph> is less than <ph id="ph2">`value2`</ph>; else pushes 0 (unsigned values).</source>
          <target state="translated">Envia 1 se <ph id="ph1">`value1`</ph> é menor que <ph id="ph2">`value2`</ph>; caso contrário envia 0 (valores sem sinal).</target>       </trans-unit>
        <trans-unit id="1026" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Clt_Un">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">O comportamento de transição de pilha, em ordem sequencial, é:</target>       </trans-unit>
        <trans-unit id="1027" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Clt_Un">
          <source><ph id="ph1">`value1`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value1`</ph> é inserido na pilha.</target>       </trans-unit>
        <trans-unit id="1028" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Clt_Un">
          <source><ph id="ph1">`value2`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value2`</ph> é inserido na pilha.</target>       </trans-unit>
        <trans-unit id="1029" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Clt_Un">
          <source><ph id="ph1">`value2`</ph> and <ph id="ph2">`value1`</ph> are popped from the stack; <ph id="ph3">`clt.un`</ph> tests if <ph id="ph4">`value1`</ph> is less than <ph id="ph5">`value2`</ph>.</source>
          <target state="translated"><ph id="ph1">`value2`</ph> e <ph id="ph2">`value1`</ph> são disparados da pilha; <ph id="ph3">`clt.un`</ph> testa se <ph id="ph4">`value1`</ph> é menor que <ph id="ph5">`value2`</ph>.</target>       </trans-unit>
        <trans-unit id="1030" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Clt_Un">
          <source>If <ph id="ph1">`value1`</ph> is less than <ph id="ph2">`value2`</ph>, 1 is pushed onto the stack; otherwise 0 is pushed onto the stack.</source>
          <target state="translated">Se <ph id="ph1">`value1`</ph> é menor que <ph id="ph2">`value2`</ph>, 1 é inserido na pilha; caso contrário, 0 é inserido na pilha.</target>       </trans-unit>
        <trans-unit id="1031" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Clt_Un">
          <source>The <ph id="ph1">`clt.un`</ph> instruction compares <ph id="ph2">`value1`</ph> and <ph id="ph3">`value2`</ph>.</source>
          <target state="translated">O <ph id="ph1">`clt.un`</ph> instrução compara <ph id="ph2">`value1`</ph> e <ph id="ph3">`value2`</ph>.</target>       </trans-unit>
        <trans-unit id="1032" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Clt_Un">
          <source>An <ph id="ph1">`int32`</ph> value of 1 is pushed on the stack if any of the following is true:</source>
          <target state="translated">Um <ph id="ph1">`int32`</ph> valor 1 é enviada por push na pilha se qualquer um dos seguintes for verdadeiro:</target>       </trans-unit>
        <trans-unit id="1033" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Clt_Un">
          <source><ph id="ph1">`value1`</ph> is strictly less than <ph id="ph2">`value2`</ph> (as for <ph id="ph3">`clt`</ph>).</source>
          <target state="translated"><ph id="ph1">`value1`</ph> é estritamente menor que <ph id="ph2">`value2`</ph> (como <ph id="ph3">`clt`</ph>).</target>       </trans-unit>
        <trans-unit id="1034" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Clt_Un">
          <source>For floating-point numbers, <ph id="ph1">`value1`</ph> is not ordered with respect to <ph id="ph2">`value2`</ph>.</source>
          <target state="translated">Para números de ponto flutuante, <ph id="ph1">`value1`</ph> não for ordenado em relação ao <ph id="ph2">`value2`</ph>.</target>       </trans-unit>
        <trans-unit id="1035" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Clt_Un">
          <source>For integer values, <ph id="ph1">`value1`</ph> is strictly less than <ph id="ph2">`value2`</ph> when considered as unsigned numbers.</source>
          <target state="translated">Para valores inteiros, <ph id="ph1">`value1`</ph> é estritamente menor que <ph id="ph2">`value2`</ph> quando considerados como números sem sinal.</target>       </trans-unit>
        <trans-unit id="1036" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Clt_Un">
          <source>Otherwise, an <ph id="ph1">`int32`</ph> value of 0 is pushed on the stack.</source>
          <target state="translated">Caso contrário, um <ph id="ph1">`int32`</ph> valor de 0 é enviada por push na pilha.</target>       </trans-unit>
        <trans-unit id="1037" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Clt_Un">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`clt.un`</ph> opcode:</source>
          <target state="translated">O seguinte <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> sobrecarga de método pode usar o <ph id="ph2">`clt.un`</ph> opcode:</target>       </trans-unit>
        <trans-unit id="1038" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Clt_Un">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="1039" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Constrained">
          <source>Constrains the type on which a virtual method call is made.</source>
          <target state="translated">Restringe o tipo no qual uma chamada de método virtual é feita.</target>       </trans-unit>
        <trans-unit id="1040" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Constrained">
          <source>The following table lists the instruction's hexadecimal and Microsoft intermediate language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">A tabela a seguir lista a instrução hexadecimal e formato de assembly Microsoft intermediate language (MSIL), junto com um resumo breve de referência:</target>       </trans-unit>
        <trans-unit id="1041" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Constrained">
          <source>Format</source>
          <target state="translated">Formatar</target>       </trans-unit>
        <trans-unit id="1042" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Constrained">
          <source>Assembly Format</source>
          <target state="translated">Formato de assembly</target>       </trans-unit>
        <trans-unit id="1043" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Constrained">
          <source>Description</source>
          <target state="translated">Descrição</target>       </trans-unit>
        <trans-unit id="1044" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Constrained">
          <source>FE 16 &lt; <ph id="ph1">`T`</ph><ph id="ph2"> &gt;</ph></source>
          <target state="translated">FE 16 &lt; <ph id="ph1">`T`</ph><ph id="ph2"> &gt;</ph></target>       </trans-unit>
        <trans-unit id="1045" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Constrained">
          <source>constrained.</source>
          <target state="translated">restrito.</target>       </trans-unit>
        <trans-unit id="1046" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Constrained">
          <source>Call a virtual method on a type constrained to be type <ph id="ph1">`T`</ph>.</source>
          <target state="translated">Chamada de um método virtual em um tipo restrito a ser do tipo <ph id="ph1">`T`</ph>.</target>       </trans-unit>
        <trans-unit id="1047" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Constrained">
          <source>The <ph id="ph1">`constrained`</ph> prefix is permitted only on a <ph id="ph2">`callvirt`</ph> instruction.</source>
          <target state="translated">O <ph id="ph1">`constrained`</ph> prefixo é permitido somente em um <ph id="ph2">`callvirt`</ph> instrução.</target>       </trans-unit>
        <trans-unit id="1048" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Constrained">
          <source>The state of the MSIL stack at this point must be as follows:</source>
          <target state="translated">O estado da pilha de MSIL agora deve ser da seguinte maneira:</target>       </trans-unit>
        <trans-unit id="1049" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Constrained">
          <source>A managed pointer, <ph id="ph1">`ptr`</ph>, is pushed onto the stack.</source>
          <target state="translated">Um ponteiro gerenciado, <ph id="ph1">`ptr`</ph>, é inserido na pilha.</target>       </trans-unit>
        <trans-unit id="1050" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Constrained">
          <source>The type of <ph id="ph1">`ptr`</ph> must be a managed pointer (<ph id="ph2">`&amp;`</ph>) to <ph id="ph3">`thisType`</ph>.</source>
          <target state="translated">O tipo de <ph id="ph1">`ptr`</ph> deve ser um ponteiro gerenciado (<ph id="ph2">`&amp;`</ph>) para <ph id="ph3">`thisType`</ph>.</target>       </trans-unit>
        <trans-unit id="1051" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Constrained">
          <source>Note that this is different from the case of an unprefixed <ph id="ph1">`callvirt`</ph> instruction, which expects a reference of <ph id="ph2">`thisType`</ph>.</source>
          <target state="translated">Observe que isso é diferente do caso de uma sem-prefixo <ph id="ph1">`callvirt`</ph> instrução, que espera uma referência de <ph id="ph2">`thisType`</ph>.</target>       </trans-unit>
        <trans-unit id="1052" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Constrained">
          <source>Method arguments <ph id="ph1">`arg1`</ph> through <ph id="ph2">`argN`</ph> are pushed onto the stack, just as with an unprefixed <ph id="ph3">`callvirt`</ph> instruction.</source>
          <target state="translated">Argumentos de método <ph id="ph1">`arg1`</ph> por meio de <ph id="ph2">`argN`</ph> são enviados por push para a pilha, assim como ocorre com um sem-prefixo <ph id="ph3">`callvirt`</ph> instrução.</target>       </trans-unit>
        <trans-unit id="1053" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Constrained">
          <source>The <ph id="ph1">`constrained`</ph> prefix is designed to allow <ph id="ph2">`callvirt`</ph> instructions to be made in a uniform way independent of whether <ph id="ph3">`thisType`</ph> is a value type or a reference type.</source>
          <target state="translated">O <ph id="ph1">`constrained`</ph> prefixo foi projetado para permitir <ph id="ph2">`callvirt`</ph> instruções a serem feitas em um uniforme maneira independente de se <ph id="ph3">`thisType`</ph> é um tipo de valor ou um tipo de referência.</target>       </trans-unit>
        <trans-unit id="1054" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Constrained">
          <source>When a <ph id="ph1">`callvirt`</ph> <ph id="ph2">`method`</ph> instruction has been prefixed by <ph id="ph3">`constrained`</ph> <ph id="ph4">`thisType`</ph>, the instruction is executed as follows:</source>
          <target state="translated">Quando um <ph id="ph1">`callvirt`</ph> <ph id="ph2">`method`</ph> instrução foi antecedida <ph id="ph3">`constrained`</ph> <ph id="ph4">`thisType`</ph>, a instrução é executada da seguinte maneira:</target>       </trans-unit>
        <trans-unit id="1055" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Constrained">
          <source>If <ph id="ph1">`thisType`</ph> is a reference type (as opposed to a value type) then <ph id="ph2">`ptr`</ph> is dereferenced and passed as the 'this' pointer to the <ph id="ph3">`callvirt`</ph> of <ph id="ph4">`method`</ph>.</source>
          <target state="translated">Se <ph id="ph1">`thisType`</ph> é um tipo de referência (em vez de um tipo de valor), em seguida, <ph id="ph2">`ptr`</ph> é cancelada e passado como o ponteiro 'this' para o <ph id="ph3">`callvirt`</ph> de <ph id="ph4">`method`</ph>.</target>       </trans-unit>
        <trans-unit id="1056" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Constrained">
          <source>If <ph id="ph1">`thisType`</ph> is a value type and <ph id="ph2">`thisType`</ph> implements <ph id="ph3">`method`</ph> then <ph id="ph4">`ptr`</ph> is passed unmodified as the 'this' pointer to a <ph id="ph5">`call`</ph> <ph id="ph6">`method`</ph> instruction, for the implementation of <ph id="ph7">`method`</ph> by <ph id="ph8">`thisType`</ph>.</source>
          <target state="translated">Se <ph id="ph1">`thisType`</ph> é um tipo de valor e <ph id="ph2">`thisType`</ph> implementa <ph id="ph3">`method`</ph> , em seguida, <ph id="ph4">`ptr`</ph> é passado não modificado como o ponteiro 'this' para uma <ph id="ph5">`call`</ph> <ph id="ph6">`method`</ph> instruções para a implementação de <ph id="ph7">`method`</ph> por <ph id="ph8">`thisType`</ph>.</target>       </trans-unit>
        <trans-unit id="1057" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Constrained">
          <source>If <ph id="ph1">`thisType`</ph> is a value type and <ph id="ph2">`thisType`</ph> does not implement <ph id="ph3">`method`</ph> then <ph id="ph4">`ptr`</ph> is dereferenced, boxed, and passed as the 'this' pointer to the <ph id="ph5">`callvirt`</ph> <ph id="ph6">`method`</ph> instruction.</source>
          <target state="translated">Se <ph id="ph1">`thisType`</ph> é um tipo de valor e <ph id="ph2">`thisType`</ph> não implementa <ph id="ph3">`method`</ph> , em seguida, <ph id="ph4">`ptr`</ph> é cancelada, box e passado como o ponteiro 'this' para o <ph id="ph5">`callvirt`</ph> <ph id="ph6">`method`</ph> instrução.</target>       </trans-unit>
        <trans-unit id="1058" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Constrained">
          <source>This last case can occur only when <ph id="ph1">`method`</ph> was defined on <ph id="ph2">&lt;xref:System.Object&gt;</ph>, <ph id="ph3">&lt;xref:System.ValueType&gt;</ph>, or <ph id="ph4">&lt;xref:System.Enum&gt;</ph> and not overridden by <ph id="ph5">`thisType`</ph>.</source>
          <target state="translated">Esse último caso pode ocorrer apenas quando <ph id="ph1">`method`</ph> foi definido em <ph id="ph2">&lt;xref:System.Object&gt;</ph>, <ph id="ph3">&lt;xref:System.ValueType&gt;</ph>, ou <ph id="ph4">&lt;xref:System.Enum&gt;</ph> e não é substituído por <ph id="ph5">`thisType`</ph>.</target>       </trans-unit>
        <trans-unit id="1059" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Constrained">
          <source>In this case, the boxing causes a copy of the original object to be made.</source>
          <target state="translated">Nesse caso, a conversão boxing faz com que uma cópia do objeto original a ser feita.</target>       </trans-unit>
        <trans-unit id="1060" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Constrained">
          <source>However, because none of the methods of <ph id="ph1">&lt;xref:System.Object&gt;</ph>, <ph id="ph2">&lt;xref:System.ValueType&gt;</ph>, and <ph id="ph3">&lt;xref:System.Enum&gt;</ph> modify the state of the object, this fact cannot be detected.</source>
          <target state="translated">No entanto, porque nenhum dos métodos de <ph id="ph1">&lt;xref:System.Object&gt;</ph>, <ph id="ph2">&lt;xref:System.ValueType&gt;</ph>, e <ph id="ph3">&lt;xref:System.Enum&gt;</ph> modificar o estado do objeto, esse fato não pode ser detectado.</target>       </trans-unit>
        <trans-unit id="1061" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Constrained">
          <source>The <ph id="ph1">`constrained`</ph> prefix supports IL generators that create generic code.</source>
          <target state="translated">O <ph id="ph1">`constrained`</ph> prefixo suporta geradores de IL que cria o código genérico.</target>       </trans-unit>
        <trans-unit id="1062" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Constrained">
          <source>Normally the <ph id="ph1">`callvirt`</ph> instruction is not valid on value types.</source>
          <target state="translated">Normalmente o <ph id="ph1">`callvirt`</ph> instrução não é válida em tipos de valor.</target>       </trans-unit>
        <trans-unit id="1063" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Constrained">
          <source>Instead it is required that IL compilers effectively perform the 'this' transformation outlined above at compile time, depending on the type of <ph id="ph1">`ptr`</ph> and the method being called.</source>
          <target state="translated">Em vez disso, é necessário que os compiladores de IL efetivamente executam a 'this' transformação descrita acima no tempo de compilação, dependendo do tipo de <ph id="ph1">`ptr`</ph> e o método que está sendo chamado.</target>       </trans-unit>
        <trans-unit id="1064" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Constrained">
          <source>However, when <ph id="ph1">`ptr`</ph> is a generic type that is unknown at compile time, it is not possible to make this transformation at compile time.</source>
          <target state="translated">No entanto, quando <ph id="ph1">`ptr`</ph> é um tipo genérico que é desconhecido no tempo de compilação, não é possível fazer essa transformação em tempo de compilação.</target>       </trans-unit>
        <trans-unit id="1065" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Constrained">
          <source>The <ph id="ph1">`constrained`</ph> opcode allows IL compilers to make a call to a virtual function in a uniform way independent of whether <ph id="ph2">`ptr`</ph> is a value type or a reference type.</source>
          <target state="translated">O <ph id="ph1">`constrained`</ph> opcode permite que os compiladores de IL fazer uma chamada para uma função virtual de um uniforme maneira independente de se <ph id="ph2">`ptr`</ph> é um tipo de valor ou um tipo de referência.</target>       </trans-unit>
        <trans-unit id="1066" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Constrained">
          <source>Although it is intended for the case where <ph id="ph1">`thisType`</ph> is a generic type variable, the <ph id="ph2">`constrained`</ph> prefix also works for nongeneric types and can reduce the complexity of generating virtual calls in languages that hide the distinction between value types and reference types.</source>
          <target state="translated">Embora seja destinado para o caso onde <ph id="ph1">`thisType`</ph> é uma variável de tipo genérico, o <ph id="ph2">`constrained`</ph> prefixo também funciona para tipos não genéricos e pode reduzir a complexidade de gerar chamadas virtuais em idiomas que ocultam a distinção entre tipos de valor e tipos de referência.</target>       </trans-unit>
        <trans-unit id="1067" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Constrained">
          <source>Using the <ph id="ph1">`constrained`</ph> prefix also avoids potential versioning problems with value types.</source>
          <target state="translated">Usando o <ph id="ph1">`constrained`</ph> prefixo também evita possíveis problemas de controle de versão com tipos de valor.</target>       </trans-unit>
        <trans-unit id="1068" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Constrained">
          <source>If the <ph id="ph1">`constrained`</ph> prefix is not used, different IL must be emitted depending on whether or not a value type overrides a method of System.Object.</source>
          <target state="translated">Se o <ph id="ph1">`constrained`</ph> prefixo não for usado, deve ser emitido IL diferente dependendo se um tipo de valor substitui um método de System. Object.</target>       </trans-unit>
        <trans-unit id="1069" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Constrained">
          <source>For example, if a value type <ph id="ph1">`V`</ph> overrides the Object.ToString() method, a <ph id="ph2">`call`</ph> <ph id="ph3">`V.ToString()`</ph> instruction is emitted; if it does not, a <ph id="ph4">`box`</ph> instruction and a <ph id="ph5">`callvirt`</ph> <ph id="ph6">`Object.ToString()`</ph> instruction are emitted.</source>
          <target state="translated">Por exemplo, se um tipo de valor <ph id="ph1">`V`</ph> substitui o método Object.ToString(), um <ph id="ph2">`call`</ph> <ph id="ph3">`V.ToString()`</ph> instrução é emitida; se não, uma <ph id="ph4">`box`</ph> instrução e um <ph id="ph5">`callvirt`</ph> <ph id="ph6">`Object.ToString()`</ph> instrução são emitidos.</target>       </trans-unit>
        <trans-unit id="1070" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Constrained">
          <source>A versioning problem can arise in the former case if the override is later removed, and in the latter case if an override is later added.</source>
          <target state="translated">Pode haver problemas de controle de versão no primeiro caso, se a substituição é removida posteriormente e no último caso se uma substituição for adicionada mais tarde.</target>       </trans-unit>
        <trans-unit id="1071" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Constrained">
          <source>The <ph id="ph1">`constrained`</ph> prefix can also be used for invocation of interface methods on value types, because the value type method implementing the interface method can be changed using a <ph id="ph2">`MethodImpl`</ph>.</source>
          <target state="translated">O <ph id="ph1">`constrained`</ph> prefixo também pode ser usado para a invocação de métodos de interface em tipos de valor, porque o método de tipo de valor implementando o método de interface pode ser alterado usando um <ph id="ph2">`MethodImpl`</ph>.</target>       </trans-unit>
        <trans-unit id="1072" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Constrained">
          <source>If the <ph id="ph1">`constrained`</ph> prefix is not used, the compiler is forced to choose which of the value type's methods to bind to at compile time.</source>
          <target state="translated">Se o <ph id="ph1">`constrained`</ph> prefixo não for usado, o compilador é forçado a escolher a que o valor de métodos tipos de para associar em tempo de compilação.</target>       </trans-unit>
        <trans-unit id="1073" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Constrained">
          <source>Using the <ph id="ph1">`constrained`</ph> prefix allows the MSIL to bind to the method that implements the interface method at run time, rather than at compile time.</source>
          <target state="translated">Usando o <ph id="ph1">`constrained`</ph> prefixo permite que o MSIL ligar para o método que implementa o método de interface em tempo de execução, em vez de em tempo de compilação.</target>       </trans-unit>
        <trans-unit id="1074" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Constrained">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`constrained`</ph> opcode:</source>
          <target state="translated">O seguinte <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> sobrecarga de método pode usar o <ph id="ph2">`constrained`</ph> opcode:</target>       </trans-unit>
        <trans-unit id="1075" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Constrained">
          <source>ILGenerator.Emit(OpCode, Type)</source>
          <target state="translated">ILGenerator.Emit(OpCode, Type)</target>       </trans-unit>
        <trans-unit id="1076" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Conv_I">
          <source>Converts the value on top of the evaluation stack to <ph id="ph1">&lt;see langword="native int" /&gt;</ph>.</source>
          <target state="translated">Converte o valor na parte superior da pilha de avaliação em <ph id="ph1">&lt;see langword="native int" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1077" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">A tabela a seguir lista as instruções hexadecimal e formato de assembly do Microsoft Intermediate Language (MSIL), junto com um resumo breve de referência:</target>       </trans-unit>
        <trans-unit id="1078" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I">
          <source>Format</source>
          <target state="translated">Formatar</target>       </trans-unit>
        <trans-unit id="1079" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I">
          <source>Assembly Format</source>
          <target state="translated">Formato de assembly</target>       </trans-unit>
        <trans-unit id="1080" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I">
          <source>Description</source>
          <target state="translated">Descrição</target>       </trans-unit>
        <trans-unit id="1081" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I">
          <source>D3</source>
          <target state="translated">D3</target>       </trans-unit>
        <trans-unit id="1082" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I">
          <source>conv.i</source>
          <target state="translated">Conv.i</target>       </trans-unit>
        <trans-unit id="1083" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I">
          <source>Convert to <ph id="ph1">`native int`</ph>, pushing <ph id="ph2">`native int`</ph> on stack.</source>
          <target state="translated">Converter em <ph id="ph1">`native int`</ph>, envio <ph id="ph2">`native int`</ph> na pilha.</target>       </trans-unit>
        <trans-unit id="1084" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">O comportamento de transição de pilha, em ordem sequencial, é:</target>       </trans-unit>
        <trans-unit id="1085" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I">
          <source><ph id="ph1">`value`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value`</ph> é inserido na pilha.</target>       </trans-unit>
        <trans-unit id="1086" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I">
          <source><ph id="ph1">`value`</ph> is popped from the stack and the conversion operation is attempted.</source>
          <target state="translated"><ph id="ph1">`value`</ph> é exibido na pilha e a conversão de tentativa de operação.</target>       </trans-unit>
        <trans-unit id="1087" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I">
          <source>If the conversion is successful, the resulting value is pushed onto the stack.</source>
          <target state="translated">Se a conversão for bem-sucedida, o valor resultante é inserido na pilha.</target>       </trans-unit>
        <trans-unit id="1088" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I">
          <source>The <ph id="ph1">`conv.i`</ph> opcode converts the <ph id="ph2">`value`</ph> on top of the stack to the type specified in the opcode, and leave that converted value on the top of the stack.</source>
          <target state="translated">O <ph id="ph1">`conv.i`</ph> opcode converte o <ph id="ph2">`value`</ph> na parte superior da pilha para o tipo especificado no opcode e deixe que converter o valor no topo da pilha.</target>       </trans-unit>
        <trans-unit id="1089" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I">
          <source>Integer values of less than 4 bytes are extended to <ph id="ph1">`int32`</ph> when they are loaded onto the evaluation stack (unless <ph id="ph2">`conv.i`</ph> or <ph id="ph3">`conv.u`</ph> is used, in which case the result is also <ph id="ph4">`native int`</ph>).</source>
          <target state="translated">Valores de inteiro de menos de 4 bytes são estendidos para <ph id="ph1">`int32`</ph> quando eles são carregados para a pilha de avaliação (a menos que <ph id="ph2">`conv.i`</ph> ou <ph id="ph3">`conv.u`</ph> for usado, caso em que o resultado é também <ph id="ph4">`native int`</ph>).</target>       </trans-unit>
        <trans-unit id="1090" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I">
          <source>Floating-point values are converted to the <ph id="ph1">`F`</ph> type.</source>
          <target state="translated">Valores de ponto flutuante são convertidos para o <ph id="ph1">`F`</ph> tipo.</target>       </trans-unit>
        <trans-unit id="1091" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I">
          <source>Conversion from floating-point numbers to integer values truncates the number toward zero.</source>
          <target state="translated">A conversão de números de ponto flutuante em valores inteiros trunca o número em direção a zero.</target>       </trans-unit>
        <trans-unit id="1092" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I">
          <source>When converting from a <ph id="ph1">`float64`</ph> to a <ph id="ph2">`float32`</ph>, precision can be lost.</source>
          <target state="translated">Ao converter de um <ph id="ph1">`float64`</ph> para um <ph id="ph2">`float32`</ph>, precisão pode ser perdida.</target>       </trans-unit>
        <trans-unit id="1093" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I">
          <source>If <ph id="ph1">`value`</ph> is too large to fit in a <ph id="ph2">`float32 (F)`</ph>, positive infinity (if <ph id="ph3">`value`</ph> is positive) or negative infinity (if <ph id="ph4">`value`</ph> is negative) is returned.</source>
          <target state="translated">Se <ph id="ph1">`value`</ph> é muito grande para caber em uma <ph id="ph2">`float32 (F)`</ph>, infinito positivo (se <ph id="ph3">`value`</ph> for positivo) ou negativo infinito (se <ph id="ph4">`value`</ph> for negativo) será retornado.</target>       </trans-unit>
        <trans-unit id="1094" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I">
          <source>If overflow occurs converting one integer type to another, the high order bits are truncated.</source>
          <target state="translated">Se estouro ocorre conversão de tipo de um inteiro para outro, os bits de ordem mais alta serão truncados.</target>       </trans-unit>
        <trans-unit id="1095" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I">
          <source>If the result is smaller than an <ph id="ph1">`int32`</ph>, the value is sign-extended to fill the slot.</source>
          <target state="translated">Se o resultado for menor do que um <ph id="ph1">`int32`</ph>, o valor é de assinatura estendida para preencher o slot.</target>       </trans-unit>
        <trans-unit id="1096" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I">
          <source>If overflow occurs converting a floating-point type to an integer the value returned is unspecified.</source>
          <target state="translated">Se ocorrer estouro de converter um tipo de ponto flutuante para um inteiro, o valor retornado é especificada.</target>       </trans-unit>
        <trans-unit id="1097" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I">
          <source>No exceptions are ever thrown when using this field.</source>
          <target state="translated">Nenhuma exceção nunca é geradas quando o uso desse campo.</target>       </trans-unit>
        <trans-unit id="1098" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I">
          <source>See <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I&gt;</ph> and <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I_Un&gt;</ph> for equivalent instructions that will throw an exception when the result type can not properly represent the result value.</source>
          <target state="translated">Consulte <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I&gt;</ph> e <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I_Un&gt;</ph> para obter instruções equivalentes que lançará uma exceção quando o tipo de resultado pode não representar corretamente o valor do resultado.</target>       </trans-unit>
        <trans-unit id="1099" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`conv.i`</ph> opcode:</source>
          <target state="translated">O seguinte <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> sobrecarga de método pode usar o <ph id="ph2">`conv.i`</ph> opcode:</target>       </trans-unit>
        <trans-unit id="1100" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="1101" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Conv_I1">
          <source>Converts the value on top of the evaluation stack to <ph id="ph1">&lt;see langword="int8" /&gt;</ph>, then extends (pads) it to <ph id="ph2">&lt;see langword="int32" /&gt;</ph>.</source>
          <target state="translated">Converte o valor na parte superior da pilha de avaliação em <ph id="ph1">&lt;see langword="int8" /&gt;</ph> e então estende-o (preenche) para <ph id="ph2">&lt;see langword="int32" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1102" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I1">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">A tabela a seguir lista as instruções hexadecimal e formato de assembly do Microsoft Intermediate Language (MSIL), junto com um resumo breve de referência:</target>       </trans-unit>
        <trans-unit id="1103" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I1">
          <source>Format</source>
          <target state="translated">Formatar</target>       </trans-unit>
        <trans-unit id="1104" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I1">
          <source>Assembly Format</source>
          <target state="translated">Formato de assembly</target>       </trans-unit>
        <trans-unit id="1105" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I1">
          <source>Description</source>
          <target state="translated">Descrição</target>       </trans-unit>
        <trans-unit id="1106" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I1">
          <source>67</source>
          <target state="translated">67</target>       </trans-unit>
        <trans-unit id="1107" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I1">
          <source>conv.i1</source>
          <target state="translated">conv.i1</target>       </trans-unit>
        <trans-unit id="1108" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I1">
          <source>Convert to <ph id="ph1">`int8`</ph>, pushing <ph id="ph2">`int32`</ph> on stack.</source>
          <target state="translated">Converter em <ph id="ph1">`int8`</ph>, envio <ph id="ph2">`int32`</ph> na pilha.</target>       </trans-unit>
        <trans-unit id="1109" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I1">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">O comportamento de transição de pilha, em ordem sequencial, é:</target>       </trans-unit>
        <trans-unit id="1110" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I1">
          <source><ph id="ph1">`value`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value`</ph> é inserido na pilha.</target>       </trans-unit>
        <trans-unit id="1111" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I1">
          <source><ph id="ph1">`value`</ph> is popped from the stack and the conversion operation is attempted.</source>
          <target state="translated"><ph id="ph1">`value`</ph> é exibido na pilha e a conversão de tentativa de operação.</target>       </trans-unit>
        <trans-unit id="1112" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I1">
          <source>If the conversion is successful, the resulting value is pushed onto the stack.</source>
          <target state="translated">Se a conversão for bem-sucedida, o valor resultante é inserido na pilha.</target>       </trans-unit>
        <trans-unit id="1113" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I1">
          <source>The <ph id="ph1">`conv.i1`</ph> opcode converts the <ph id="ph2">`value`</ph> on top of the stack to the type specified in the opcode, and leave that converted value on the top of the stack.</source>
          <target state="translated">O <ph id="ph1">`conv.i1`</ph> opcode converte o <ph id="ph2">`value`</ph> na parte superior da pilha para o tipo especificado no opcode e deixe que converter o valor no topo da pilha.</target>       </trans-unit>
        <trans-unit id="1114" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I1">
          <source>Integer values of less than 4 bytes are extended to <ph id="ph1">`int32`</ph> when they are loaded onto the evaluation stack (unless <ph id="ph2">`conv.i`</ph> or <ph id="ph3">`conv.u`</ph> is used, in which case the result is also <ph id="ph4">`native int`</ph>).</source>
          <target state="translated">Valores de inteiro de menos de 4 bytes são estendidos para <ph id="ph1">`int32`</ph> quando eles são carregados para a pilha de avaliação (a menos que <ph id="ph2">`conv.i`</ph> ou <ph id="ph3">`conv.u`</ph> for usado, caso em que o resultado é também <ph id="ph4">`native int`</ph>).</target>       </trans-unit>
        <trans-unit id="1115" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I1">
          <source>Floating-point values are converted to the <ph id="ph1">`F`</ph> type.</source>
          <target state="translated">Valores de ponto flutuante são convertidos para o <ph id="ph1">`F`</ph> tipo.</target>       </trans-unit>
        <trans-unit id="1116" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I1">
          <source>Conversion from floating-point numbers to integer values truncates the number toward zero.</source>
          <target state="translated">A conversão de números de ponto flutuante em valores inteiros trunca o número em direção a zero.</target>       </trans-unit>
        <trans-unit id="1117" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I1">
          <source>When converting from a <ph id="ph1">`float64`</ph> to a <ph id="ph2">`float32`</ph>, precision can be lost.</source>
          <target state="translated">Ao converter de um <ph id="ph1">`float64`</ph> para um <ph id="ph2">`float32`</ph>, precisão pode ser perdida.</target>       </trans-unit>
        <trans-unit id="1118" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I1">
          <source>If <ph id="ph1">`value`</ph> is too large to fit in a <ph id="ph2">`float32 (F)`</ph>, positive infinity (if <ph id="ph3">`value`</ph> is positive) or negative infinity (if <ph id="ph4">`value`</ph> is negative) is returned.</source>
          <target state="translated">Se <ph id="ph1">`value`</ph> é muito grande para caber em uma <ph id="ph2">`float32 (F)`</ph>, infinito positivo (se <ph id="ph3">`value`</ph> for positivo) ou negativo infinito (se <ph id="ph4">`value`</ph> for negativo) será retornado.</target>       </trans-unit>
        <trans-unit id="1119" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I1">
          <source>If overflow occurs converting one integer type to another, the high order bits are truncated.</source>
          <target state="translated">Se estouro ocorre conversão de tipo de um inteiro para outro, os bits de ordem mais alta serão truncados.</target>       </trans-unit>
        <trans-unit id="1120" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I1">
          <source>If the result is smaller than an <ph id="ph1">`int32`</ph>, the value is sign-extended to fill the slot.</source>
          <target state="translated">Se o resultado for menor do que um <ph id="ph1">`int32`</ph>, o valor é de assinatura estendida para preencher o slot.</target>       </trans-unit>
        <trans-unit id="1121" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I1">
          <source>If overflow occurs converting a floating-point type to an integer the value returned is unspecified.</source>
          <target state="translated">Se ocorrer estouro de converter um tipo de ponto flutuante para um inteiro, o valor retornado é especificada.</target>       </trans-unit>
        <trans-unit id="1122" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I1">
          <source>No exceptions are ever thrown when using this field.</source>
          <target state="translated">Nenhuma exceção nunca é geradas quando o uso desse campo.</target>       </trans-unit>
        <trans-unit id="1123" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I1">
          <source>See <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I1&gt;</ph> and <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I1_Un&gt;</ph> for equivalent instructions that will throw an exception when the result type can not properly represent the result value.</source>
          <target state="translated">Consulte <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I1&gt;</ph> e <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I1_Un&gt;</ph> para obter instruções equivalentes que lançará uma exceção quando o tipo de resultado pode não representar corretamente o valor do resultado.</target>       </trans-unit>
        <trans-unit id="1124" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I1">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`conv.i1`</ph> opcode:</source>
          <target state="translated">O seguinte <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> sobrecarga de método pode usar o <ph id="ph2">`conv.i1`</ph> opcode:</target>       </trans-unit>
        <trans-unit id="1125" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I1">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="1126" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Conv_I2">
          <source>Converts the value on top of the evaluation stack to <ph id="ph1">&lt;see langword="int16" /&gt;</ph>, then extends (pads) it to <ph id="ph2">&lt;see langword="int32" /&gt;</ph>.</source>
          <target state="translated">Converte o valor na parte superior da pilha de avaliação em <ph id="ph1">&lt;see langword="int16" /&gt;</ph> e então estende-o (preenche) para <ph id="ph2">&lt;see langword="int32" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1127" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I2">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">A tabela a seguir lista as instruções hexadecimal e formato de assembly do Microsoft Intermediate Language (MSIL), junto com um resumo breve de referência:</target>       </trans-unit>
        <trans-unit id="1128" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I2">
          <source>Format</source>
          <target state="translated">Formatar</target>       </trans-unit>
        <trans-unit id="1129" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I2">
          <source>Assembly Format</source>
          <target state="translated">Formato de assembly</target>       </trans-unit>
        <trans-unit id="1130" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I2">
          <source>Description</source>
          <target state="translated">Descrição</target>       </trans-unit>
        <trans-unit id="1131" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I2">
          <source>68</source>
          <target state="translated">68</target>       </trans-unit>
        <trans-unit id="1132" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I2">
          <source>conv.i2</source>
          <target state="translated">conv.i2</target>       </trans-unit>
        <trans-unit id="1133" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I2">
          <source>Convert to <ph id="ph1">`int16`</ph>, pushing <ph id="ph2">`int32`</ph> on stack.</source>
          <target state="translated">Converter em <ph id="ph1">`int16`</ph>, envio <ph id="ph2">`int32`</ph> na pilha.</target>       </trans-unit>
        <trans-unit id="1134" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I2">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">O comportamento de transição de pilha, em ordem sequencial, é:</target>       </trans-unit>
        <trans-unit id="1135" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I2">
          <source><ph id="ph1">`value`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value`</ph> é inserido na pilha.</target>       </trans-unit>
        <trans-unit id="1136" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I2">
          <source><ph id="ph1">`value`</ph> is popped from the stack and the conversion operation is attempted.</source>
          <target state="translated"><ph id="ph1">`value`</ph> é exibido na pilha e a conversão de tentativa de operação.</target>       </trans-unit>
        <trans-unit id="1137" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I2">
          <source>If the conversion is successful, the resulting value is pushed onto the stack.</source>
          <target state="translated">Se a conversão for bem-sucedida, o valor resultante é inserido na pilha.</target>       </trans-unit>
        <trans-unit id="1138" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I2">
          <source>The <ph id="ph1">`conv.i2`</ph> opcode converts the <ph id="ph2">`value`</ph> on top of the stack to the type specified in the opcode, and leave that converted value on the top of the stack.</source>
          <target state="translated">O <ph id="ph1">`conv.i2`</ph> opcode converte o <ph id="ph2">`value`</ph> na parte superior da pilha para o tipo especificado no opcode e deixe que converter o valor no topo da pilha.</target>       </trans-unit>
        <trans-unit id="1139" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I2">
          <source>Integer values of less than 4 bytes are extended to <ph id="ph1">`int32`</ph> when they are loaded onto the evaluation stack (unless <ph id="ph2">`conv.i`</ph> or <ph id="ph3">`conv.u`</ph> is used, in which case the result is also <ph id="ph4">`native int`</ph>).</source>
          <target state="translated">Valores de inteiro de menos de 4 bytes são estendidos para <ph id="ph1">`int32`</ph> quando eles são carregados para a pilha de avaliação (a menos que <ph id="ph2">`conv.i`</ph> ou <ph id="ph3">`conv.u`</ph> for usado, caso em que o resultado é também <ph id="ph4">`native int`</ph>).</target>       </trans-unit>
        <trans-unit id="1140" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I2">
          <source>Floating-point values are converted to the <ph id="ph1">`F`</ph> type.</source>
          <target state="translated">Valores de ponto flutuante são convertidos para o <ph id="ph1">`F`</ph> tipo.</target>       </trans-unit>
        <trans-unit id="1141" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I2">
          <source>Conversion from floating-point numbers to integer values truncates the number toward zero.</source>
          <target state="translated">A conversão de números de ponto flutuante em valores inteiros trunca o número em direção a zero.</target>       </trans-unit>
        <trans-unit id="1142" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I2">
          <source>When converting from a <ph id="ph1">`float64`</ph> to a <ph id="ph2">`float32`</ph>, precision can be lost.</source>
          <target state="translated">Ao converter de um <ph id="ph1">`float64`</ph> para um <ph id="ph2">`float32`</ph>, precisão pode ser perdida.</target>       </trans-unit>
        <trans-unit id="1143" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I2">
          <source>If <ph id="ph1">`value`</ph> is too large to fit in a <ph id="ph2">`float32 (F)`</ph>, positive infinity (if <ph id="ph3">`value`</ph> is positive) or negative infinity (if <ph id="ph4">`value`</ph> is negative) is returned.</source>
          <target state="translated">Se <ph id="ph1">`value`</ph> é muito grande para caber em uma <ph id="ph2">`float32 (F)`</ph>, infinito positivo (se <ph id="ph3">`value`</ph> for positivo) ou negativo infinito (se <ph id="ph4">`value`</ph> for negativo) será retornado.</target>       </trans-unit>
        <trans-unit id="1144" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I2">
          <source>If overflow occurs converting one integer type to another, the high order bits are truncated.</source>
          <target state="translated">Se estouro ocorre conversão de tipo de um inteiro para outro, os bits de ordem mais alta serão truncados.</target>       </trans-unit>
        <trans-unit id="1145" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I2">
          <source>If the result is smaller than an <ph id="ph1">`int32`</ph>, the value is sign-extended to fill the slot.</source>
          <target state="translated">Se o resultado for menor do que um <ph id="ph1">`int32`</ph>, o valor é de assinatura estendida para preencher o slot.</target>       </trans-unit>
        <trans-unit id="1146" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I2">
          <source>If overflow occurs converting a floating-point type to an integer the value returned is unspecified.</source>
          <target state="translated">Se ocorrer estouro de converter um tipo de ponto flutuante para um inteiro, o valor retornado é especificada.</target>       </trans-unit>
        <trans-unit id="1147" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I2">
          <source>No exceptions are ever thrown when using this field.</source>
          <target state="translated">Nenhuma exceção nunca é geradas quando o uso desse campo.</target>       </trans-unit>
        <trans-unit id="1148" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I2">
          <source>See <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I2&gt;</ph> and <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I2_Un&gt;</ph> for equivalent instructions that will throw an exception when the result type can not properly represent the result value.</source>
          <target state="translated">Consulte <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I2&gt;</ph> e <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I2_Un&gt;</ph> para obter instruções equivalentes que lançará uma exceção quando o tipo de resultado pode não representar corretamente o valor do resultado.</target>       </trans-unit>
        <trans-unit id="1149" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I2">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`conv.i2`</ph> opcode:</source>
          <target state="translated">O seguinte <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> sobrecarga de método pode usar o <ph id="ph2">`conv.i2`</ph> opcode:</target>       </trans-unit>
        <trans-unit id="1150" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I2">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="1151" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Conv_I4">
          <source>Converts the value on top of the evaluation stack to <ph id="ph1">&lt;see langword="int32" /&gt;</ph>.</source>
          <target state="translated">Converte o valor na parte superior da pilha de avaliação em <ph id="ph1">&lt;see langword="int32" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1152" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I4">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">A tabela a seguir lista as instruções hexadecimal e formato de assembly do Microsoft Intermediate Language (MSIL), junto com um resumo breve de referência:</target>       </trans-unit>
        <trans-unit id="1153" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I4">
          <source>Format</source>
          <target state="translated">Formatar</target>       </trans-unit>
        <trans-unit id="1154" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I4">
          <source>Assembly Format</source>
          <target state="translated">Formato de assembly</target>       </trans-unit>
        <trans-unit id="1155" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I4">
          <source>Description</source>
          <target state="translated">Descrição</target>       </trans-unit>
        <trans-unit id="1156" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I4">
          <source>69</source>
          <target state="translated">69</target>       </trans-unit>
        <trans-unit id="1157" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I4">
          <source>conv.i4</source>
          <target state="translated">conv.i4</target>       </trans-unit>
        <trans-unit id="1158" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I4">
          <source>Convert to <ph id="ph1">`int32`</ph>, pushing <ph id="ph2">`int32`</ph> on stack.</source>
          <target state="translated">Converter em <ph id="ph1">`int32`</ph>, envio <ph id="ph2">`int32`</ph> na pilha.</target>       </trans-unit>
        <trans-unit id="1159" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I4">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">O comportamento de transição de pilha, em ordem sequencial, é:</target>       </trans-unit>
        <trans-unit id="1160" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I4">
          <source><ph id="ph1">`value`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value`</ph> é inserido na pilha.</target>       </trans-unit>
        <trans-unit id="1161" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I4">
          <source><ph id="ph1">`value`</ph> is popped from the stack and the conversion operation is attempted.</source>
          <target state="translated"><ph id="ph1">`value`</ph> é exibido na pilha e a conversão de tentativa de operação.</target>       </trans-unit>
        <trans-unit id="1162" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I4">
          <source>If the conversion is successful, the resulting value is pushed onto the stack.</source>
          <target state="translated">Se a conversão for bem-sucedida, o valor resultante é inserido na pilha.</target>       </trans-unit>
        <trans-unit id="1163" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I4">
          <source>The <ph id="ph1">`conv.i4`</ph> opcode converts the <ph id="ph2">`value`</ph> on top of the stack to the type specified in the opcode, and leave that converted value on the top of the stack.</source>
          <target state="translated">O <ph id="ph1">`conv.i4`</ph> opcode converte o <ph id="ph2">`value`</ph> na parte superior da pilha para o tipo especificado no opcode e deixe que converter o valor no topo da pilha.</target>       </trans-unit>
        <trans-unit id="1164" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I4">
          <source>Integer values of less than 4 bytes are extended to <ph id="ph1">`int32`</ph> when they are loaded onto the evaluation stack (unless <ph id="ph2">`conv.i`</ph> or <ph id="ph3">`conv.u`</ph> is used, in which case the result is also <ph id="ph4">`native int`</ph>).</source>
          <target state="translated">Valores de inteiro de menos de 4 bytes são estendidos para <ph id="ph1">`int32`</ph> quando eles são carregados para a pilha de avaliação (a menos que <ph id="ph2">`conv.i`</ph> ou <ph id="ph3">`conv.u`</ph> for usado, caso em que o resultado é também <ph id="ph4">`native int`</ph>).</target>       </trans-unit>
        <trans-unit id="1165" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I4">
          <source>Floating-point values are converted to the <ph id="ph1">`F`</ph> type.</source>
          <target state="translated">Valores de ponto flutuante são convertidos para o <ph id="ph1">`F`</ph> tipo.</target>       </trans-unit>
        <trans-unit id="1166" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I4">
          <source>Conversion from floating-point numbers to integer values truncates the number toward zero.</source>
          <target state="translated">A conversão de números de ponto flutuante em valores inteiros trunca o número em direção a zero.</target>       </trans-unit>
        <trans-unit id="1167" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I4">
          <source>When converting from a <ph id="ph1">`float64`</ph> to a <ph id="ph2">`float32`</ph>, precision can be lost.</source>
          <target state="translated">Ao converter de um <ph id="ph1">`float64`</ph> para um <ph id="ph2">`float32`</ph>, precisão pode ser perdida.</target>       </trans-unit>
        <trans-unit id="1168" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I4">
          <source>If <ph id="ph1">`value`</ph> is too large to fit in a <ph id="ph2">`float32 (F)`</ph>, positive infinity (if <ph id="ph3">`value`</ph> is positive) or negative infinity (if <ph id="ph4">`value`</ph> is negative) is returned.</source>
          <target state="translated">Se <ph id="ph1">`value`</ph> é muito grande para caber em uma <ph id="ph2">`float32 (F)`</ph>, infinito positivo (se <ph id="ph3">`value`</ph> for positivo) ou negativo infinito (se <ph id="ph4">`value`</ph> for negativo) será retornado.</target>       </trans-unit>
        <trans-unit id="1169" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I4">
          <source>If overflow occurs converting one integer type to another, the high order bits are truncated.</source>
          <target state="translated">Se estouro ocorre conversão de tipo de um inteiro para outro, os bits de ordem mais alta serão truncados.</target>       </trans-unit>
        <trans-unit id="1170" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I4">
          <source>If the result is smaller than an <ph id="ph1">`int32`</ph>, the value is sign-extended to fill the slot.</source>
          <target state="translated">Se o resultado for menor do que um <ph id="ph1">`int32`</ph>, o valor é de assinatura estendida para preencher o slot.</target>       </trans-unit>
        <trans-unit id="1171" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I4">
          <source>If overflow occurs converting a floating-point type to an integer the value returned is unspecified.</source>
          <target state="translated">Se ocorrer estouro de converter um tipo de ponto flutuante para um inteiro, o valor retornado é especificada.</target>       </trans-unit>
        <trans-unit id="1172" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I4">
          <source>No exceptions are ever thrown when using this field.</source>
          <target state="translated">Nenhuma exceção nunca é geradas quando o uso desse campo.</target>       </trans-unit>
        <trans-unit id="1173" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I4">
          <source>See <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I4&gt;</ph> and <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I4_Un&gt;</ph> for equivalent instructions that will throw an exception when the result type can not properly represent the result value.</source>
          <target state="translated">Consulte <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I4&gt;</ph> e <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I4_Un&gt;</ph> para obter instruções equivalentes que lançará uma exceção quando o tipo de resultado pode não representar corretamente o valor do resultado.</target>       </trans-unit>
        <trans-unit id="1174" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I4">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`conv.i4`</ph> opcode:</source>
          <target state="translated">O seguinte <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> sobrecarga de método pode usar o <ph id="ph2">`conv.i4`</ph> opcode:</target>       </trans-unit>
        <trans-unit id="1175" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I4">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="1176" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Conv_I8">
          <source>Converts the value on top of the evaluation stack to <ph id="ph1">&lt;see langword="int64" /&gt;</ph>.</source>
          <target state="translated">Converte o valor na parte superior da pilha de avaliação em <ph id="ph1">&lt;see langword="int64" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1177" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I8">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">A tabela a seguir lista as instruções hexadecimal e formato de assembly do Microsoft Intermediate Language (MSIL), junto com um resumo breve de referência:</target>       </trans-unit>
        <trans-unit id="1178" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I8">
          <source>Format</source>
          <target state="translated">Formatar</target>       </trans-unit>
        <trans-unit id="1179" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I8">
          <source>Assembly Format</source>
          <target state="translated">Formato de assembly</target>       </trans-unit>
        <trans-unit id="1180" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I8">
          <source>Description</source>
          <target state="translated">Descrição</target>       </trans-unit>
        <trans-unit id="1181" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I8">
          <source>6A</source>
          <target state="translated">6A</target>       </trans-unit>
        <trans-unit id="1182" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I8">
          <source>conv.i8</source>
          <target state="translated">conv.i8</target>       </trans-unit>
        <trans-unit id="1183" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I8">
          <source>Convert to <ph id="ph1">`int64`</ph>, pushing <ph id="ph2">`int64`</ph> on stack.</source>
          <target state="translated">Converter em <ph id="ph1">`int64`</ph>, envio <ph id="ph2">`int64`</ph> na pilha.</target>       </trans-unit>
        <trans-unit id="1184" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I8">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">O comportamento de transição de pilha, em ordem sequencial, é:</target>       </trans-unit>
        <trans-unit id="1185" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I8">
          <source><ph id="ph1">`value`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value`</ph> é inserido na pilha.</target>       </trans-unit>
        <trans-unit id="1186" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I8">
          <source><ph id="ph1">`value`</ph> is popped from the stack and the conversion operation is attempted.</source>
          <target state="translated"><ph id="ph1">`value`</ph> é exibido na pilha e a conversão de tentativa de operação.</target>       </trans-unit>
        <trans-unit id="1187" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I8">
          <source>If the conversion is successful, the resulting value is pushed onto the stack.</source>
          <target state="translated">Se a conversão for bem-sucedida, o valor resultante é inserido na pilha.</target>       </trans-unit>
        <trans-unit id="1188" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I8">
          <source>The <ph id="ph1">`conv.i8`</ph> opcode converts the <ph id="ph2">`value`</ph> on top of the stack to the type specified in the opcode, and leave that converted value on the top of the stack.</source>
          <target state="translated">O <ph id="ph1">`conv.i8`</ph> opcode converte o <ph id="ph2">`value`</ph> na parte superior da pilha para o tipo especificado no opcode e deixe que converter o valor no topo da pilha.</target>       </trans-unit>
        <trans-unit id="1189" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I8">
          <source>Integer values of less than 4 bytes are extended to <ph id="ph1">`int32`</ph> when they are loaded onto the evaluation stack (unless <ph id="ph2">`conv.i`</ph> or <ph id="ph3">`conv.u`</ph> is used, in which case the result is also <ph id="ph4">`native int`</ph>).</source>
          <target state="translated">Valores de inteiro de menos de 4 bytes são estendidos para <ph id="ph1">`int32`</ph> quando eles são carregados para a pilha de avaliação (a menos que <ph id="ph2">`conv.i`</ph> ou <ph id="ph3">`conv.u`</ph> for usado, caso em que o resultado é também <ph id="ph4">`native int`</ph>).</target>       </trans-unit>
        <trans-unit id="1190" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I8">
          <source>Floating-point values are converted to the <ph id="ph1">`F`</ph> type.</source>
          <target state="translated">Valores de ponto flutuante são convertidos para o <ph id="ph1">`F`</ph> tipo.</target>       </trans-unit>
        <trans-unit id="1191" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I8">
          <source>Conversion from floating-point numbers to integer values truncates the number toward zero.</source>
          <target state="translated">A conversão de números de ponto flutuante em valores inteiros trunca o número em direção a zero.</target>       </trans-unit>
        <trans-unit id="1192" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I8">
          <source>When converting from a <ph id="ph1">`float64`</ph> to a <ph id="ph2">`float32`</ph>, precision can be lost.</source>
          <target state="translated">Ao converter de um <ph id="ph1">`float64`</ph> para um <ph id="ph2">`float32`</ph>, precisão pode ser perdida.</target>       </trans-unit>
        <trans-unit id="1193" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I8">
          <source>If <ph id="ph1">`value`</ph> is too large to fit in a <ph id="ph2">`float32 (F)`</ph>, positive infinity (if <ph id="ph3">`value`</ph> is positive) or negative infinity (if <ph id="ph4">`value`</ph> is negative) is returned.</source>
          <target state="translated">Se <ph id="ph1">`value`</ph> é muito grande para caber em uma <ph id="ph2">`float32 (F)`</ph>, infinito positivo (se <ph id="ph3">`value`</ph> for positivo) ou negativo infinito (se <ph id="ph4">`value`</ph> for negativo) será retornado.</target>       </trans-unit>
        <trans-unit id="1194" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I8">
          <source>If overflow occurs converting one integer type to another, the high order bits are truncated.</source>
          <target state="translated">Se estouro ocorre conversão de tipo de um inteiro para outro, os bits de ordem mais alta serão truncados.</target>       </trans-unit>
        <trans-unit id="1195" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I8">
          <source>If the result is smaller than an <ph id="ph1">`int32`</ph>, the value is sign-extended to fill the slot.</source>
          <target state="translated">Se o resultado for menor do que um <ph id="ph1">`int32`</ph>, o valor é de assinatura estendida para preencher o slot.</target>       </trans-unit>
        <trans-unit id="1196" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I8">
          <source>If overflow occurs converting a floating-point type to an integer the value returned is unspecified.</source>
          <target state="translated">Se ocorrer estouro de converter um tipo de ponto flutuante para um inteiro, o valor retornado é especificada.</target>       </trans-unit>
        <trans-unit id="1197" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I8">
          <source>No exceptions are ever thrown when using this field.</source>
          <target state="translated">Nenhuma exceção nunca é geradas quando o uso desse campo.</target>       </trans-unit>
        <trans-unit id="1198" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I8">
          <source>See <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I8&gt;</ph> and <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I8_Un&gt;</ph> for equivalent instructions that will throw an exception when the result type can not properly represent the result value.</source>
          <target state="translated">Consulte <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I8&gt;</ph> e <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I8_Un&gt;</ph> para obter instruções equivalentes que lançará uma exceção quando o tipo de resultado pode não representar corretamente o valor do resultado.</target>       </trans-unit>
        <trans-unit id="1199" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I8">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`conv.i8`</ph> opcode:</source>
          <target state="translated">O seguinte <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> sobrecarga de método pode usar o <ph id="ph2">`conv.i8`</ph> opcode:</target>       </trans-unit>
        <trans-unit id="1200" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I8">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="1201" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I">
          <source>Converts the signed value on top of the evaluation stack to signed <ph id="ph1">&lt;see langword="native int" /&gt;</ph>, throwing <ph id="ph2">&lt;see cref="T:System.OverflowException" /&gt;</ph> on overflow.</source>
          <target state="translated">Converte o valor com sinal no topo da pilha de avaliação em <ph id="ph1">&lt;see langword="native int" /&gt;</ph> com sinal, gerando <ph id="ph2">&lt;see cref="T:System.OverflowException" /&gt;</ph> no estouro.</target>       </trans-unit>
        <trans-unit id="1202" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">A tabela a seguir lista as instruções hexadecimal e formato de assembly do Microsoft Intermediate Language (MSIL), junto com um resumo breve de referência:</target>       </trans-unit>
        <trans-unit id="1203" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I">
          <source>Format</source>
          <target state="translated">Formatar</target>       </trans-unit>
        <trans-unit id="1204" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I">
          <source>Assembly Format</source>
          <target state="translated">Formato de assembly</target>       </trans-unit>
        <trans-unit id="1205" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I">
          <source>Description</source>
          <target state="translated">Descrição</target>       </trans-unit>
        <trans-unit id="1206" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I">
          <source>D4</source>
          <target state="translated">D4</target>       </trans-unit>
        <trans-unit id="1207" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I">
          <source>conv.ovf.i</source>
          <target state="translated">conv.ovf.i</target>       </trans-unit>
        <trans-unit id="1208" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I">
          <source>Convert to a <ph id="ph1">`native int`</ph> (on the stack as <ph id="ph2">`native int`</ph>) and throw an exception on overflow.</source>
          <target state="translated">Converter em um <ph id="ph1">`native int`</ph> (na pilha como <ph id="ph2">`native int`</ph>) e gerará uma exceção no estouro.</target>       </trans-unit>
        <trans-unit id="1209" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">O comportamento de transição de pilha, em ordem sequencial, é:</target>       </trans-unit>
        <trans-unit id="1210" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I">
          <source><ph id="ph1">`value`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value`</ph> é inserido na pilha.</target>       </trans-unit>
        <trans-unit id="1211" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I">
          <source><ph id="ph1">`value`</ph> is popped from the stack and the conversion operation is attempted.</source>
          <target state="translated"><ph id="ph1">`value`</ph> é exibido na pilha e a conversão de tentativa de operação.</target>       </trans-unit>
        <trans-unit id="1212" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I">
          <source>If overflow occurs, an exception is thrown.</source>
          <target state="translated">Se ocorrer estouro, uma exceção será lançada.</target>       </trans-unit>
        <trans-unit id="1213" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I">
          <source>If the conversion is successful, the resulting value is pushed onto the stack.</source>
          <target state="translated">Se a conversão for bem-sucedida, o valor resultante é inserido na pilha.</target>       </trans-unit>
        <trans-unit id="1214" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I">
          <source>The <ph id="ph1">`conv.ovf.i`</ph> opcode converts the <ph id="ph2">`value`</ph> on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack.</source>
          <target state="translated">O <ph id="ph1">`conv.ovf.i`</ph> opcode converte o <ph id="ph2">`value`</ph> na parte superior da pilha para o tipo especificado no opcode e coloca convertidos valor na parte superior da pilha.</target>       </trans-unit>
        <trans-unit id="1215" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I">
          <source>If the value is too large or too small to be represented by the target type, an exception is thrown.</source>
          <target state="translated">Se o valor for muito grande ou muito pequeno para ser representado pelo tipo de destino, uma exceção será lançada.</target>       </trans-unit>
        <trans-unit id="1216" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I">
          <source>Conversions from floating-point numbers to integer values truncate the number toward zero.</source>
          <target state="translated">Conversões de números de ponto flutuante para valores inteiros truncam o número em direção a zero.</target>       </trans-unit>
        <trans-unit id="1217" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I">
          <source>Note that integer values of less than 4 bytes are extended to <ph id="ph1">`int32`</ph> when they are loaded onto the evaluation stack (unless <ph id="ph2">`conv.ovf.i`</ph> or <ph id="ph3">`conv.ovf.u`</ph> are used, in which case the result is also <ph id="ph4">`native int`</ph>).</source>
          <target state="translated">Observe que os valores inteiros de menos de 4 bytes são estendidos para <ph id="ph1">`int32`</ph> quando eles são carregados para a pilha de avaliação (a menos que <ph id="ph2">`conv.ovf.i`</ph> ou <ph id="ph3">`conv.ovf.u`</ph> forem usados, caso em que o resultado é também <ph id="ph4">`native int`</ph>).</target>       </trans-unit>
        <trans-unit id="1218" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I">
          <source><ph id="ph1">&lt;xref:System.OverflowException&gt;</ph> is thrown if the result can not be represented in the result type.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.OverflowException&gt;</ph> é gerada se o resultado não pode ser representado no tipo de resultado.</target>       </trans-unit>
        <trans-unit id="1219" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`conv.ovf.i`</ph> opcode:</source>
          <target state="translated">O seguinte <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> sobrecarga de método pode usar o <ph id="ph2">`conv.ovf.i`</ph> opcode:</target>       </trans-unit>
        <trans-unit id="1220" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="1221" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I_Un">
          <source>Converts the unsigned value on top of the evaluation stack to signed <ph id="ph1">&lt;see langword="native int" /&gt;</ph>, throwing <ph id="ph2">&lt;see cref="T:System.OverflowException" /&gt;</ph> on overflow.</source>
          <target state="translated">Converte o valor sem sinal no topo da pilha de avaliação em <ph id="ph1">&lt;see langword="native int" /&gt;</ph> com sinal, gerando <ph id="ph2">&lt;see cref="T:System.OverflowException" /&gt;</ph> no estouro.</target>       </trans-unit>
        <trans-unit id="1222" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I_Un">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">A tabela a seguir lista as instruções hexadecimal e formato de assembly do Microsoft Intermediate Language (MSIL), junto com um resumo breve de referência:</target>       </trans-unit>
        <trans-unit id="1223" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I_Un">
          <source>Format</source>
          <target state="translated">Formatar</target>       </trans-unit>
        <trans-unit id="1224" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I_Un">
          <source>Assembly Format</source>
          <target state="translated">Formato de assembly</target>       </trans-unit>
        <trans-unit id="1225" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I_Un">
          <source>Description</source>
          <target state="translated">Descrição</target>       </trans-unit>
        <trans-unit id="1226" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I_Un">
          <source>8A</source>
          <target state="translated">8A</target>       </trans-unit>
        <trans-unit id="1227" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I_Un">
          <source>conv.ovf.i.un</source>
          <target state="translated">conv.ovf.i.un</target>       </trans-unit>
        <trans-unit id="1228" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I_Un">
          <source>Converts an unsigned value to a <ph id="ph1">`native int`</ph> (on the stack as <ph id="ph2">`native int`</ph>) and throw an exception on overflow.</source>
          <target state="translated">Converte um valor sem sinal em um <ph id="ph1">`native int`</ph> (na pilha como <ph id="ph2">`native int`</ph>) e gerará uma exceção no estouro.</target>       </trans-unit>
        <trans-unit id="1229" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I_Un">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">O comportamento de transição de pilha, em ordem sequencial, é:</target>       </trans-unit>
        <trans-unit id="1230" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I_Un">
          <source><ph id="ph1">`value`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value`</ph> é inserido na pilha.</target>       </trans-unit>
        <trans-unit id="1231" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I_Un">
          <source><ph id="ph1">`value`</ph> is popped from the stack and the conversion operation is attempted.</source>
          <target state="translated"><ph id="ph1">`value`</ph> é exibido na pilha e a conversão de tentativa de operação.</target>       </trans-unit>
        <trans-unit id="1232" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I_Un">
          <source>If overflow occurs, an exception is thrown.</source>
          <target state="translated">Se ocorrer estouro, uma exceção será lançada.</target>       </trans-unit>
        <trans-unit id="1233" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I_Un">
          <source>If the conversion is successful, the resulting value is pushed onto the stack.</source>
          <target state="translated">Se a conversão for bem-sucedida, o valor resultante é inserido na pilha.</target>       </trans-unit>
        <trans-unit id="1234" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I_Un">
          <source>The <ph id="ph1">`conv.ovf.i.un`</ph> opcode converts the <ph id="ph2">`value`</ph> on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack.</source>
          <target state="translated">O <ph id="ph1">`conv.ovf.i.un`</ph> opcode converte o <ph id="ph2">`value`</ph> na parte superior da pilha para o tipo especificado no opcode e coloca convertidos valor na parte superior da pilha.</target>       </trans-unit>
        <trans-unit id="1235" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I_Un">
          <source>If the value is too large or too small to be represented by the target type, an exception is thrown.</source>
          <target state="translated">Se o valor for muito grande ou muito pequeno para ser representado pelo tipo de destino, uma exceção será lançada.</target>       </trans-unit>
        <trans-unit id="1236" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I_Un">
          <source>Conversions from floating-point numbers to integer values truncate the number toward zero.</source>
          <target state="translated">Conversões de números de ponto flutuante para valores inteiros truncam o número em direção a zero.</target>       </trans-unit>
        <trans-unit id="1237" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I_Un">
          <source>Note that integer values of less than 4 bytes are extended to <ph id="ph1">`int32`</ph> when they are loaded onto the evaluation stack (unless <ph id="ph2">`conv.ovf.i`</ph> or <ph id="ph3">`conv.ovf.u`</ph> are used, in which case the result is also <ph id="ph4">`native int`</ph>).</source>
          <target state="translated">Observe que os valores inteiros de menos de 4 bytes são estendidos para <ph id="ph1">`int32`</ph> quando eles são carregados para a pilha de avaliação (a menos que <ph id="ph2">`conv.ovf.i`</ph> ou <ph id="ph3">`conv.ovf.u`</ph> forem usados, caso em que o resultado é também <ph id="ph4">`native int`</ph>).</target>       </trans-unit>
        <trans-unit id="1238" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I_Un">
          <source><ph id="ph1">&lt;xref:System.OverflowException&gt;</ph> is thrown if the result can not be represented in the result type.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.OverflowException&gt;</ph> é gerada se o resultado não pode ser representado no tipo de resultado.</target>       </trans-unit>
        <trans-unit id="1239" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I_Un">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`conv.ovf.i.un`</ph> opcode:</source>
          <target state="translated">O seguinte <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> sobrecarga de método pode usar o <ph id="ph2">`conv.ovf.i.un`</ph> opcode:</target>       </trans-unit>
        <trans-unit id="1240" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I_Un">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="1241" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I1">
          <source>Converts the signed value on top of the evaluation stack to signed <ph id="ph1">&lt;see langword="int8" /&gt;</ph> and extends it to <ph id="ph2">&lt;see langword="int32" /&gt;</ph>, throwing <ph id="ph3">&lt;see cref="T:System.OverflowException" /&gt;</ph> on overflow.</source>
          <target state="translated">Converte o valor com sinal no topo da pilha de avaliação em <ph id="ph1">&lt;see langword="int8" /&gt;</ph> com sinal e estende-o para <ph id="ph2">&lt;see langword="int32" /&gt;</ph>, gerando <ph id="ph3">&lt;see cref="T:System.OverflowException" /&gt;</ph> no estouro.</target>       </trans-unit>
        <trans-unit id="1242" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I1">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">A tabela a seguir lista as instruções hexadecimal e formato de assembly do Microsoft Intermediate Language (MSIL), junto com um resumo breve de referência:</target>       </trans-unit>
        <trans-unit id="1243" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I1">
          <source>Format</source>
          <target state="translated">Formatar</target>       </trans-unit>
        <trans-unit id="1244" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I1">
          <source>Assembly Format</source>
          <target state="translated">Formato de assembly</target>       </trans-unit>
        <trans-unit id="1245" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I1">
          <source>Description</source>
          <target state="translated">Descrição</target>       </trans-unit>
        <trans-unit id="1246" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I1">
          <source>B3</source>
          <target state="translated">B3</target>       </trans-unit>
        <trans-unit id="1247" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I1">
          <source>conv.ovf.i1</source>
          <target state="translated">conv.ovf.i1</target>       </trans-unit>
        <trans-unit id="1248" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I1">
          <source>Convert to an <ph id="ph1">`int8`</ph> (on the stack as <ph id="ph2">`int32`</ph>) and throw an exception on overflow.</source>
          <target state="translated">Converter em um <ph id="ph1">`int8`</ph> (na pilha como <ph id="ph2">`int32`</ph>) e gerará uma exceção no estouro.</target>       </trans-unit>
        <trans-unit id="1249" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I1">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">O comportamento de transição de pilha, em ordem sequencial, é:</target>       </trans-unit>
        <trans-unit id="1250" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I1">
          <source><ph id="ph1">`value`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value`</ph> é inserido na pilha.</target>       </trans-unit>
        <trans-unit id="1251" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I1">
          <source><ph id="ph1">`value`</ph> is popped from the stack and the conversion operation is attempted.</source>
          <target state="translated"><ph id="ph1">`value`</ph> é exibido na pilha e a conversão de tentativa de operação.</target>       </trans-unit>
        <trans-unit id="1252" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I1">
          <source>If overflow occurs, an exception is thrown.</source>
          <target state="translated">Se ocorrer estouro, uma exceção será lançada.</target>       </trans-unit>
        <trans-unit id="1253" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I1">
          <source>If the conversion is successful, the resulting value is pushed onto the stack.</source>
          <target state="translated">Se a conversão for bem-sucedida, o valor resultante é inserido na pilha.</target>       </trans-unit>
        <trans-unit id="1254" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I1">
          <source>The <ph id="ph1">`conv.ovf.i1`</ph> opcode converts the <ph id="ph2">`value`</ph> on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack.</source>
          <target state="translated">O <ph id="ph1">`conv.ovf.i1`</ph> opcode converte o <ph id="ph2">`value`</ph> na parte superior da pilha para o tipo especificado no opcode e coloca convertidos valor na parte superior da pilha.</target>       </trans-unit>
        <trans-unit id="1255" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I1">
          <source>If the value is too large or too small to be represented by the target type, an exception is thrown.</source>
          <target state="translated">Se o valor for muito grande ou muito pequeno para ser representado pelo tipo de destino, uma exceção será lançada.</target>       </trans-unit>
        <trans-unit id="1256" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I1">
          <source>Conversions from floating-point numbers to integer values truncate the number toward zero.</source>
          <target state="translated">Conversões de números de ponto flutuante para valores inteiros truncam o número em direção a zero.</target>       </trans-unit>
        <trans-unit id="1257" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I1">
          <source>Note that integer values of less than 4 bytes are extended to <ph id="ph1">`int32`</ph> when they are loaded onto the evaluation stack (unless <ph id="ph2">`conv.ovf.i`</ph> or <ph id="ph3">`conv.ovf.u`</ph> are used, in which case the result is also <ph id="ph4">`native int`</ph>).</source>
          <target state="translated">Observe que os valores inteiros de menos de 4 bytes são estendidos para <ph id="ph1">`int32`</ph> quando eles são carregados para a pilha de avaliação (a menos que <ph id="ph2">`conv.ovf.i`</ph> ou <ph id="ph3">`conv.ovf.u`</ph> forem usados, caso em que o resultado é também <ph id="ph4">`native int`</ph>).</target>       </trans-unit>
        <trans-unit id="1258" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I1">
          <source><ph id="ph1">&lt;xref:System.OverflowException&gt;</ph> is thrown if the result can not be represented in the result type.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.OverflowException&gt;</ph> é gerada se o resultado não pode ser representado no tipo de resultado.</target>       </trans-unit>
        <trans-unit id="1259" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I1">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`conv.ovf.i1`</ph> opcode:</source>
          <target state="translated">O seguinte <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> sobrecarga de método pode usar o <ph id="ph2">`conv.ovf.i1`</ph> opcode:</target>       </trans-unit>
        <trans-unit id="1260" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I1">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="1261" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I1_Un">
          <source>Converts the unsigned value on top of the evaluation stack to signed <ph id="ph1">&lt;see langword="int8" /&gt;</ph> and extends it to <ph id="ph2">&lt;see langword="int32" /&gt;</ph>, throwing <ph id="ph3">&lt;see cref="T:System.OverflowException" /&gt;</ph> on overflow.</source>
          <target state="translated">Converte o valor sem sinal no topo da pilha de avaliação em <ph id="ph1">&lt;see langword="int8" /&gt;</ph> com sinal e estende-o para <ph id="ph2">&lt;see langword="int32" /&gt;</ph>, gerando <ph id="ph3">&lt;see cref="T:System.OverflowException" /&gt;</ph> no estouro.</target>       </trans-unit>
        <trans-unit id="1262" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I1_Un">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">A tabela a seguir lista as instruções hexadecimal e formato de assembly do Microsoft Intermediate Language (MSIL), junto com um resumo breve de referência:</target>       </trans-unit>
        <trans-unit id="1263" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I1_Un">
          <source>Format</source>
          <target state="translated">Formatar</target>       </trans-unit>
        <trans-unit id="1264" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I1_Un">
          <source>Assembly Format</source>
          <target state="translated">Formato de assembly</target>       </trans-unit>
        <trans-unit id="1265" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I1_Un">
          <source>Description</source>
          <target state="translated">Descrição</target>       </trans-unit>
        <trans-unit id="1266" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I1_Un">
          <source>82</source>
          <target state="translated">82</target>       </trans-unit>
        <trans-unit id="1267" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I1_Un">
          <source>conv.ovf.i1.un</source>
          <target state="translated">conv.ovf.i1.un</target>       </trans-unit>
        <trans-unit id="1268" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I1_Un">
          <source>Converts an unsigned value to an <ph id="ph1">`int8`</ph> (on the stack as <ph id="ph2">`int32`</ph>) and throw an exception on overflow.</source>
          <target state="translated">Converte um valor sem sinal em um <ph id="ph1">`int8`</ph> (na pilha como <ph id="ph2">`int32`</ph>) e gerará uma exceção no estouro.</target>       </trans-unit>
        <trans-unit id="1269" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I1_Un">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">O comportamento de transição de pilha, em ordem sequencial, é:</target>       </trans-unit>
        <trans-unit id="1270" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I1_Un">
          <source><ph id="ph1">`value`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value`</ph> é inserido na pilha.</target>       </trans-unit>
        <trans-unit id="1271" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I1_Un">
          <source><ph id="ph1">`value`</ph> is popped from the stack and the conversion operation is attempted.</source>
          <target state="translated"><ph id="ph1">`value`</ph> é exibido na pilha e a conversão de tentativa de operação.</target>       </trans-unit>
        <trans-unit id="1272" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I1_Un">
          <source>If overflow occurs, an exception is thrown.</source>
          <target state="translated">Se ocorrer estouro, uma exceção será lançada.</target>       </trans-unit>
        <trans-unit id="1273" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I1_Un">
          <source>If the conversion is successful, the resulting value is pushed onto the stack.</source>
          <target state="translated">Se a conversão for bem-sucedida, o valor resultante é inserido na pilha.</target>       </trans-unit>
        <trans-unit id="1274" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I1_Un">
          <source>The <ph id="ph1">`conv.ovf.i1.un`</ph> opcode converts the <ph id="ph2">`value`</ph> on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack.</source>
          <target state="translated">O <ph id="ph1">`conv.ovf.i1.un`</ph> opcode converte o <ph id="ph2">`value`</ph> na parte superior da pilha para o tipo especificado no opcode e coloca convertidos valor na parte superior da pilha.</target>       </trans-unit>
        <trans-unit id="1275" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I1_Un">
          <source>If the value is too large or too small to be represented by the target type, an exception is thrown.</source>
          <target state="translated">Se o valor for muito grande ou muito pequeno para ser representado pelo tipo de destino, uma exceção será lançada.</target>       </trans-unit>
        <trans-unit id="1276" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I1_Un">
          <source>Conversions from floating-point numbers to integer values truncate the number toward zero.</source>
          <target state="translated">Conversões de números de ponto flutuante para valores inteiros truncam o número em direção a zero.</target>       </trans-unit>
        <trans-unit id="1277" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I1_Un">
          <source>Note that integer values of less than 4 bytes are extended to <ph id="ph1">`int32`</ph> when they are loaded onto the evaluation stack (unless <ph id="ph2">`conv.ovf.i`</ph> or <ph id="ph3">`conv.ovf.u`</ph> are used, in which case the result is also <ph id="ph4">`native int`</ph>).</source>
          <target state="translated">Observe que os valores inteiros de menos de 4 bytes são estendidos para <ph id="ph1">`int32`</ph> quando eles são carregados para a pilha de avaliação (a menos que <ph id="ph2">`conv.ovf.i`</ph> ou <ph id="ph3">`conv.ovf.u`</ph> forem usados, caso em que o resultado é também <ph id="ph4">`native int`</ph>).</target>       </trans-unit>
        <trans-unit id="1278" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I1_Un">
          <source><ph id="ph1">&lt;xref:System.OverflowException&gt;</ph> is thrown if the result can not be represented in the result type.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.OverflowException&gt;</ph> é gerada se o resultado não pode ser representado no tipo de resultado.</target>       </trans-unit>
        <trans-unit id="1279" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I1_Un">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`conv.ovf.i1.un`</ph> opcode:</source>
          <target state="translated">O seguinte <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> sobrecarga de método pode usar o <ph id="ph2">`conv.ovf.i1.un`</ph> opcode:</target>       </trans-unit>
        <trans-unit id="1280" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I1_Un">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="1281" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I2">
          <source>Converts the signed value on top of the evaluation stack to signed <ph id="ph1">&lt;see langword="int16" /&gt;</ph> and extending it to <ph id="ph2">&lt;see langword="int32" /&gt;</ph>, throwing <ph id="ph3">&lt;see cref="T:System.OverflowException" /&gt;</ph> on overflow.</source>
          <target state="translated">Converte o valor com sinal no topo da pilha de avaliação em <ph id="ph1">&lt;see langword="int16" /&gt;</ph> com sinal e estendendo-o para <ph id="ph2">&lt;see langword="int32" /&gt;</ph>, gerando <ph id="ph3">&lt;see cref="T:System.OverflowException" /&gt;</ph> no estouro.</target>       </trans-unit>
        <trans-unit id="1282" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I2">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">A tabela a seguir lista as instruções hexadecimal e formato de assembly do Microsoft Intermediate Language (MSIL), junto com um resumo breve de referência:</target>       </trans-unit>
        <trans-unit id="1283" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I2">
          <source>Format</source>
          <target state="translated">Formatar</target>       </trans-unit>
        <trans-unit id="1284" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I2">
          <source>Assembly Format</source>
          <target state="translated">Formato de assembly</target>       </trans-unit>
        <trans-unit id="1285" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I2">
          <source>Description</source>
          <target state="translated">Descrição</target>       </trans-unit>
        <trans-unit id="1286" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I2">
          <source>B5</source>
          <target state="translated">B5</target>       </trans-unit>
        <trans-unit id="1287" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I2">
          <source>conv.ovf.i2</source>
          <target state="translated">conv.ovf.i2</target>       </trans-unit>
        <trans-unit id="1288" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I2">
          <source>Convert to an <ph id="ph1">`int16`</ph> (on the stack as <ph id="ph2">`int32`</ph>) and throw an exception on overflow.</source>
          <target state="translated">Converter em um <ph id="ph1">`int16`</ph> (na pilha como <ph id="ph2">`int32`</ph>) e gerará uma exceção no estouro.</target>       </trans-unit>
        <trans-unit id="1289" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I2">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">O comportamento de transição de pilha, em ordem sequencial, é:</target>       </trans-unit>
        <trans-unit id="1290" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I2">
          <source><ph id="ph1">`value`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value`</ph> é inserido na pilha.</target>       </trans-unit>
        <trans-unit id="1291" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I2">
          <source><ph id="ph1">`value`</ph> is popped from the stack and the conversion operation is attempted.</source>
          <target state="translated"><ph id="ph1">`value`</ph> é exibido na pilha e a conversão de tentativa de operação.</target>       </trans-unit>
        <trans-unit id="1292" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I2">
          <source>If overflow occurs, an exception is thrown.</source>
          <target state="translated">Se ocorrer estouro, uma exceção será lançada.</target>       </trans-unit>
        <trans-unit id="1293" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I2">
          <source>If the conversion is successful, the resulting value is pushed onto the stack.</source>
          <target state="translated">Se a conversão for bem-sucedida, o valor resultante é inserido na pilha.</target>       </trans-unit>
        <trans-unit id="1294" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I2">
          <source>The <ph id="ph1">`conv.ovf.i2`</ph> opcode converts the <ph id="ph2">`value`</ph> on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack.</source>
          <target state="translated">O <ph id="ph1">`conv.ovf.i2`</ph> opcode converte o <ph id="ph2">`value`</ph> na parte superior da pilha para o tipo especificado no opcode e coloca convertidos valor na parte superior da pilha.</target>       </trans-unit>
        <trans-unit id="1295" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I2">
          <source>If the value is too large or too small to be represented by the target type, an exception is thrown.</source>
          <target state="translated">Se o valor for muito grande ou muito pequeno para ser representado pelo tipo de destino, uma exceção será lançada.</target>       </trans-unit>
        <trans-unit id="1296" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I2">
          <source>Conversions from floating-point numbers to integer values truncate the number toward zero.</source>
          <target state="translated">Conversões de números de ponto flutuante para valores inteiros truncam o número em direção a zero.</target>       </trans-unit>
        <trans-unit id="1297" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I2">
          <source>Note that integer values of less than 4 bytes are extended to <ph id="ph1">`int32`</ph> when they are loaded onto the evaluation stack (unless <ph id="ph2">`conv.ovf.i`</ph> or <ph id="ph3">`conv.ovf.u`</ph> are used, in which case the result is also <ph id="ph4">`native int`</ph>).</source>
          <target state="translated">Observe que os valores inteiros de menos de 4 bytes são estendidos para <ph id="ph1">`int32`</ph> quando eles são carregados para a pilha de avaliação (a menos que <ph id="ph2">`conv.ovf.i`</ph> ou <ph id="ph3">`conv.ovf.u`</ph> forem usados, caso em que o resultado é também <ph id="ph4">`native int`</ph>).</target>       </trans-unit>
        <trans-unit id="1298" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I2">
          <source><ph id="ph1">&lt;xref:System.OverflowException&gt;</ph> is thrown if the result can not be represented in the result type.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.OverflowException&gt;</ph> é gerada se o resultado não pode ser representado no tipo de resultado.</target>       </trans-unit>
        <trans-unit id="1299" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I2">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`conv.ovf.i2`</ph> opcode:</source>
          <target state="translated">O seguinte <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> sobrecarga de método pode usar o <ph id="ph2">`conv.ovf.i2`</ph> opcode:</target>       </trans-unit>
        <trans-unit id="1300" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I2">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="1301" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I2_Un">
          <source>Converts the unsigned value on top of the evaluation stack to signed <ph id="ph1">&lt;see langword="int16" /&gt;</ph> and extends it to <ph id="ph2">&lt;see langword="int32" /&gt;</ph>, throwing <ph id="ph3">&lt;see cref="T:System.OverflowException" /&gt;</ph> on overflow.</source>
          <target state="translated">Converte o valor sem sinal no topo da pilha de avaliação em <ph id="ph1">&lt;see langword="int16" /&gt;</ph> com sinal e estende-o para <ph id="ph2">&lt;see langword="int32" /&gt;</ph>, gerando <ph id="ph3">&lt;see cref="T:System.OverflowException" /&gt;</ph> no estouro.</target>       </trans-unit>
        <trans-unit id="1302" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I2_Un">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">A tabela a seguir lista as instruções hexadecimal e formato de assembly do Microsoft Intermediate Language (MSIL), junto com um resumo breve de referência:</target>       </trans-unit>
        <trans-unit id="1303" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I2_Un">
          <source>Format</source>
          <target state="translated">Formatar</target>       </trans-unit>
        <trans-unit id="1304" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I2_Un">
          <source>Assembly Format</source>
          <target state="translated">Formato de assembly</target>       </trans-unit>
        <trans-unit id="1305" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I2_Un">
          <source>Description</source>
          <target state="translated">Descrição</target>       </trans-unit>
        <trans-unit id="1306" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I2_Un">
          <source>83</source>
          <target state="translated">83</target>       </trans-unit>
        <trans-unit id="1307" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I2_Un">
          <source>conv.ovf.i2.un</source>
          <target state="translated">conv.ovf.i2.un</target>       </trans-unit>
        <trans-unit id="1308" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I2_Un">
          <source>Converts an unsigned value to an <ph id="ph1">`int16`</ph> (on the stack as <ph id="ph2">`int32`</ph>) and throw an exception on overflow.</source>
          <target state="translated">Converte um valor sem sinal em um <ph id="ph1">`int16`</ph> (na pilha como <ph id="ph2">`int32`</ph>) e gerará uma exceção no estouro.</target>       </trans-unit>
        <trans-unit id="1309" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I2_Un">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">O comportamento de transição de pilha, em ordem sequencial, é:</target>       </trans-unit>
        <trans-unit id="1310" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I2_Un">
          <source><ph id="ph1">`value`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value`</ph> é inserido na pilha.</target>       </trans-unit>
        <trans-unit id="1311" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I2_Un">
          <source><ph id="ph1">`value`</ph> is popped from the stack and the conversion operation is attempted.</source>
          <target state="translated"><ph id="ph1">`value`</ph> é exibido na pilha e a conversão de tentativa de operação.</target>       </trans-unit>
        <trans-unit id="1312" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I2_Un">
          <source>If overflow occurs, an exception is thrown.</source>
          <target state="translated">Se ocorrer estouro, uma exceção será lançada.</target>       </trans-unit>
        <trans-unit id="1313" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I2_Un">
          <source>If the conversion is successful, the resulting value is pushed onto the stack.</source>
          <target state="translated">Se a conversão for bem-sucedida, o valor resultante é inserido na pilha.</target>       </trans-unit>
        <trans-unit id="1314" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I2_Un">
          <source>The <ph id="ph1">`conv.ovf.i2.un`</ph> opcode converts the <ph id="ph2">`value`</ph> on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack.</source>
          <target state="translated">O <ph id="ph1">`conv.ovf.i2.un`</ph> opcode converte o <ph id="ph2">`value`</ph> na parte superior da pilha para o tipo especificado no opcode e coloca convertidos valor na parte superior da pilha.</target>       </trans-unit>
        <trans-unit id="1315" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I2_Un">
          <source>If the value is too large or too small to be represented by the target type, an exception is thrown.</source>
          <target state="translated">Se o valor for muito grande ou muito pequeno para ser representado pelo tipo de destino, uma exceção será lançada.</target>       </trans-unit>
        <trans-unit id="1316" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I2_Un">
          <source>Conversions from floating-point numbers to integer values truncate the number toward zero.</source>
          <target state="translated">Conversões de números de ponto flutuante para valores inteiros truncam o número em direção a zero.</target>       </trans-unit>
        <trans-unit id="1317" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I2_Un">
          <source>Note that integer values of less than 4 bytes are extended to <ph id="ph1">`int32`</ph> when they are loaded onto the evaluation stack (unless <ph id="ph2">`conv.ovf.i`</ph> or <ph id="ph3">`conv.ovf.u`</ph> are used, in which case the result is also <ph id="ph4">`native int`</ph>).</source>
          <target state="translated">Observe que os valores inteiros de menos de 4 bytes são estendidos para <ph id="ph1">`int32`</ph> quando eles são carregados para a pilha de avaliação (a menos que <ph id="ph2">`conv.ovf.i`</ph> ou <ph id="ph3">`conv.ovf.u`</ph> forem usados, caso em que o resultado é também <ph id="ph4">`native int`</ph>).</target>       </trans-unit>
        <trans-unit id="1318" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I2_Un">
          <source><ph id="ph1">&lt;xref:System.OverflowException&gt;</ph> is thrown if the result can not be represented in the result type.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.OverflowException&gt;</ph> é gerada se o resultado não pode ser representado no tipo de resultado.</target>       </trans-unit>
        <trans-unit id="1319" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I2_Un">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`conv.ovf.i2.un`</ph> opcode:</source>
          <target state="translated">O seguinte <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> sobrecarga de método pode usar o <ph id="ph2">`conv.ovf.i2.un`</ph> opcode:</target>       </trans-unit>
        <trans-unit id="1320" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I2_Un">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="1321" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I4">
          <source>Converts the signed value on top of the evaluation stack to signed <ph id="ph1">&lt;see langword="int32" /&gt;</ph>, throwing <ph id="ph2">&lt;see cref="T:System.OverflowException" /&gt;</ph> on overflow.</source>
          <target state="translated">Converte o valor com sinal no topo da pilha de avaliação em <ph id="ph1">&lt;see langword="int32" /&gt;</ph> com sinal, gerando <ph id="ph2">&lt;see cref="T:System.OverflowException" /&gt;</ph> no estouro.</target>       </trans-unit>
        <trans-unit id="1322" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I4">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">A tabela a seguir lista as instruções hexadecimal e formato de assembly do Microsoft Intermediate Language (MSIL), junto com um resumo breve de referência:</target>       </trans-unit>
        <trans-unit id="1323" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I4">
          <source>Format</source>
          <target state="translated">Formatar</target>       </trans-unit>
        <trans-unit id="1324" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I4">
          <source>Assembly Format</source>
          <target state="translated">Formato de assembly</target>       </trans-unit>
        <trans-unit id="1325" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I4">
          <source>Description</source>
          <target state="translated">Descrição</target>       </trans-unit>
        <trans-unit id="1326" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I4">
          <source>B7</source>
          <target state="translated">B7</target>       </trans-unit>
        <trans-unit id="1327" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I4">
          <source>conv.ovf.i4</source>
          <target state="translated">conv.ovf.i4</target>       </trans-unit>
        <trans-unit id="1328" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I4">
          <source>Convert to an <ph id="ph1">`int32`</ph> (on the stack as <ph id="ph2">`int32`</ph>) and throw an exception on overflow.</source>
          <target state="translated">Converter em um <ph id="ph1">`int32`</ph> (na pilha como <ph id="ph2">`int32`</ph>) e gerará uma exceção no estouro.</target>       </trans-unit>
        <trans-unit id="1329" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I4">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">O comportamento de transição de pilha, em ordem sequencial, é:</target>       </trans-unit>
        <trans-unit id="1330" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I4">
          <source><ph id="ph1">`value`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value`</ph> é inserido na pilha.</target>       </trans-unit>
        <trans-unit id="1331" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I4">
          <source><ph id="ph1">`value`</ph> is popped from the stack and the conversion operation is attempted.</source>
          <target state="translated"><ph id="ph1">`value`</ph> é exibido na pilha e a conversão de tentativa de operação.</target>       </trans-unit>
        <trans-unit id="1332" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I4">
          <source>If overflow occurs, an exception is thrown.</source>
          <target state="translated">Se ocorrer estouro, uma exceção será lançada.</target>       </trans-unit>
        <trans-unit id="1333" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I4">
          <source>If the conversion is successful, the resulting value is pushed onto the stack.</source>
          <target state="translated">Se a conversão for bem-sucedida, o valor resultante é inserido na pilha.</target>       </trans-unit>
        <trans-unit id="1334" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I4">
          <source>The <ph id="ph1">`conv.ovf.i4`</ph> opcode converts the <ph id="ph2">`value`</ph> on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack.</source>
          <target state="translated">O <ph id="ph1">`conv.ovf.i4`</ph> opcode converte o <ph id="ph2">`value`</ph> na parte superior da pilha para o tipo especificado no opcode e coloca convertidos valor na parte superior da pilha.</target>       </trans-unit>
        <trans-unit id="1335" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I4">
          <source>If the value is too large or too small to be represented by the target type, an exception is thrown.</source>
          <target state="translated">Se o valor for muito grande ou muito pequeno para ser representado pelo tipo de destino, uma exceção será lançada.</target>       </trans-unit>
        <trans-unit id="1336" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I4">
          <source>Conversions from floating-point numbers to integer values truncate the number toward zero.</source>
          <target state="translated">Conversões de números de ponto flutuante para valores inteiros truncam o número em direção a zero.</target>       </trans-unit>
        <trans-unit id="1337" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I4">
          <source>Note that integer values of less than 4 bytes are extended to <ph id="ph1">`int32`</ph> when they are loaded onto the evaluation stack (unless <ph id="ph2">`conv.ovf.i`</ph> or <ph id="ph3">`conv.ovf.u`</ph> are used, in which case the result is also <ph id="ph4">`native int`</ph>).</source>
          <target state="translated">Observe que os valores inteiros de menos de 4 bytes são estendidos para <ph id="ph1">`int32`</ph> quando eles são carregados para a pilha de avaliação (a menos que <ph id="ph2">`conv.ovf.i`</ph> ou <ph id="ph3">`conv.ovf.u`</ph> forem usados, caso em que o resultado é também <ph id="ph4">`native int`</ph>).</target>       </trans-unit>
        <trans-unit id="1338" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I4">
          <source><ph id="ph1">&lt;xref:System.OverflowException&gt;</ph> is thrown if the result can not be represented in the result type.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.OverflowException&gt;</ph> é gerada se o resultado não pode ser representado no tipo de resultado.</target>       </trans-unit>
        <trans-unit id="1339" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I4">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`conv.ovf.i4`</ph> opcode:</source>
          <target state="translated">O seguinte <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> sobrecarga de método pode usar o <ph id="ph2">`conv.ovf.i4`</ph> opcode:</target>       </trans-unit>
        <trans-unit id="1340" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I4">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="1341" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I4_Un">
          <source>Converts the unsigned value on top of the evaluation stack to signed <ph id="ph1">&lt;see langword="int32" /&gt;</ph>, throwing <ph id="ph2">&lt;see cref="T:System.OverflowException" /&gt;</ph> on overflow.</source>
          <target state="translated">Converte o valor sem sinal no topo da pilha de avaliação em <ph id="ph1">&lt;see langword="int32" /&gt;</ph> com sinal, gerando <ph id="ph2">&lt;see cref="T:System.OverflowException" /&gt;</ph> no estouro.</target>       </trans-unit>
        <trans-unit id="1342" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I4_Un">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">A tabela a seguir lista as instruções hexadecimal e formato de assembly do Microsoft Intermediate Language (MSIL), junto com um resumo breve de referência:</target>       </trans-unit>
        <trans-unit id="1343" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I4_Un">
          <source>Format</source>
          <target state="translated">Formatar</target>       </trans-unit>
        <trans-unit id="1344" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I4_Un">
          <source>Assembly Format</source>
          <target state="translated">Formato de assembly</target>       </trans-unit>
        <trans-unit id="1345" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I4_Un">
          <source>Description</source>
          <target state="translated">Descrição</target>       </trans-unit>
        <trans-unit id="1346" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I4_Un">
          <source>84</source>
          <target state="translated">84</target>       </trans-unit>
        <trans-unit id="1347" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I4_Un">
          <source>conv.ovf.i4.un</source>
          <target state="translated">conv.ovf.i4.un</target>       </trans-unit>
        <trans-unit id="1348" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I4_Un">
          <source>Converts an unsigned value to an <ph id="ph1">`int32`</ph> (on the stack as <ph id="ph2">`int32`</ph>) and throw an exception on overflow.</source>
          <target state="translated">Converte um valor sem sinal em um <ph id="ph1">`int32`</ph> (na pilha como <ph id="ph2">`int32`</ph>) e gerará uma exceção no estouro.</target>       </trans-unit>
        <trans-unit id="1349" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I4_Un">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">O comportamento de transição de pilha, em ordem sequencial, é:</target>       </trans-unit>
        <trans-unit id="1350" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I4_Un">
          <source><ph id="ph1">`value`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value`</ph> é inserido na pilha.</target>       </trans-unit>
        <trans-unit id="1351" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I4_Un">
          <source><ph id="ph1">`value`</ph> is popped from the stack and the conversion operation is attempted.</source>
          <target state="translated"><ph id="ph1">`value`</ph> é exibido na pilha e a conversão de tentativa de operação.</target>       </trans-unit>
        <trans-unit id="1352" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I4_Un">
          <source>If overflow occurs, an exception is thrown.</source>
          <target state="translated">Se ocorrer estouro, uma exceção será lançada.</target>       </trans-unit>
        <trans-unit id="1353" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I4_Un">
          <source>If the conversion is successful, the resulting value is pushed onto the stack.</source>
          <target state="translated">Se a conversão for bem-sucedida, o valor resultante é inserido na pilha.</target>       </trans-unit>
        <trans-unit id="1354" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I4_Un">
          <source>The <ph id="ph1">`conv.ovf.i4.un`</ph> opcode converts the <ph id="ph2">`value`</ph> on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack.</source>
          <target state="translated">O <ph id="ph1">`conv.ovf.i4.un`</ph> opcode converte o <ph id="ph2">`value`</ph> na parte superior da pilha para o tipo especificado no opcode e coloca convertidos valor na parte superior da pilha.</target>       </trans-unit>
        <trans-unit id="1355" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I4_Un">
          <source>If the value is too large or too small to be represented by the target type, an exception is thrown.</source>
          <target state="translated">Se o valor for muito grande ou muito pequeno para ser representado pelo tipo de destino, uma exceção será lançada.</target>       </trans-unit>
        <trans-unit id="1356" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I4_Un">
          <source>Conversions from floating-point numbers to integer values truncate the number toward zero.</source>
          <target state="translated">Conversões de números de ponto flutuante para valores inteiros truncam o número em direção a zero.</target>       </trans-unit>
        <trans-unit id="1357" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I4_Un">
          <source>Note that integer values of less than 4 bytes are extended to <ph id="ph1">`int32`</ph> when they are loaded onto the evaluation stack (unless <ph id="ph2">`conv.ovf.i`</ph> or <ph id="ph3">`conv.ovf.u`</ph> are used, in which case the result is also <ph id="ph4">`native int`</ph>).</source>
          <target state="translated">Observe que os valores inteiros de menos de 4 bytes são estendidos para <ph id="ph1">`int32`</ph> quando eles são carregados para a pilha de avaliação (a menos que <ph id="ph2">`conv.ovf.i`</ph> ou <ph id="ph3">`conv.ovf.u`</ph> forem usados, caso em que o resultado é também <ph id="ph4">`native int`</ph>).</target>       </trans-unit>
        <trans-unit id="1358" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I4_Un">
          <source><ph id="ph1">&lt;xref:System.OverflowException&gt;</ph> is thrown if the result can not be represented in the result type.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.OverflowException&gt;</ph> é gerada se o resultado não pode ser representado no tipo de resultado.</target>       </trans-unit>
        <trans-unit id="1359" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I4_Un">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`conv.ovf.i4.un`</ph> opcode:</source>
          <target state="translated">O seguinte <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> sobrecarga de método pode usar o <ph id="ph2">`conv.ovf.i4.un`</ph> opcode:</target>       </trans-unit>
        <trans-unit id="1360" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I4_Un">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="1361" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I8">
          <source>Converts the signed value on top of the evaluation stack to signed <ph id="ph1">&lt;see langword="int64" /&gt;</ph>, throwing <ph id="ph2">&lt;see cref="T:System.OverflowException" /&gt;</ph> on overflow.</source>
          <target state="translated">Converte o valor com sinal no topo da pilha de avaliação em <ph id="ph1">&lt;see langword="int64" /&gt;</ph> com sinal, gerando <ph id="ph2">&lt;see cref="T:System.OverflowException" /&gt;</ph> no estouro.</target>       </trans-unit>
        <trans-unit id="1362" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I8">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">A tabela a seguir lista as instruções hexadecimal e formato de assembly do Microsoft Intermediate Language (MSIL), junto com um resumo breve de referência:</target>       </trans-unit>
        <trans-unit id="1363" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I8">
          <source>Format</source>
          <target state="translated">Formatar</target>       </trans-unit>
        <trans-unit id="1364" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I8">
          <source>Assembly Format</source>
          <target state="translated">Formato de assembly</target>       </trans-unit>
        <trans-unit id="1365" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I8">
          <source>Description</source>
          <target state="translated">Descrição</target>       </trans-unit>
        <trans-unit id="1366" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I8">
          <source>B9</source>
          <target state="translated">B9</target>       </trans-unit>
        <trans-unit id="1367" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I8">
          <source>conv.ovf.i8</source>
          <target state="translated">conv.ovf.i8</target>       </trans-unit>
        <trans-unit id="1368" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I8">
          <source>Convert to an <ph id="ph1">`int64`</ph> (on the stack as <ph id="ph2">`int64`</ph>) and throw an exception on overflow.</source>
          <target state="translated">Converter em um <ph id="ph1">`int64`</ph> (na pilha como <ph id="ph2">`int64`</ph>) e gerará uma exceção no estouro.</target>       </trans-unit>
        <trans-unit id="1369" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I8">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">O comportamento de transição de pilha, em ordem sequencial, é:</target>       </trans-unit>
        <trans-unit id="1370" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I8">
          <source><ph id="ph1">`value`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value`</ph> é inserido na pilha.</target>       </trans-unit>
        <trans-unit id="1371" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I8">
          <source><ph id="ph1">`value`</ph> is popped from the stack and the conversion operation is attempted.</source>
          <target state="translated"><ph id="ph1">`value`</ph> é exibido na pilha e a conversão de tentativa de operação.</target>       </trans-unit>
        <trans-unit id="1372" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I8">
          <source>If overflow occurs, an exception is thrown.</source>
          <target state="translated">Se ocorrer estouro, uma exceção será lançada.</target>       </trans-unit>
        <trans-unit id="1373" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I8">
          <source>If the conversion is successful, the resulting value is pushed onto the stack.</source>
          <target state="translated">Se a conversão for bem-sucedida, o valor resultante é inserido na pilha.</target>       </trans-unit>
        <trans-unit id="1374" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I8">
          <source>The <ph id="ph1">`conv.ovf.i8`</ph> opcode converts the <ph id="ph2">`value`</ph> on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack.</source>
          <target state="translated">O <ph id="ph1">`conv.ovf.i8`</ph> opcode converte o <ph id="ph2">`value`</ph> na parte superior da pilha para o tipo especificado no opcode e coloca convertidos valor na parte superior da pilha.</target>       </trans-unit>
        <trans-unit id="1375" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I8">
          <source>If the value is too large or too small to be represented by the target type, an exception is thrown.</source>
          <target state="translated">Se o valor for muito grande ou muito pequeno para ser representado pelo tipo de destino, uma exceção será lançada.</target>       </trans-unit>
        <trans-unit id="1376" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I8">
          <source>Conversions from floating-point numbers to integer values truncate the number toward zero.</source>
          <target state="translated">Conversões de números de ponto flutuante para valores inteiros truncam o número em direção a zero.</target>       </trans-unit>
        <trans-unit id="1377" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I8">
          <source>Note that integer values of less than 4 bytes are extended to <ph id="ph1">`int32`</ph> when they are loaded onto the evaluation stack (unless <ph id="ph2">`conv.ovf.i`</ph> or <ph id="ph3">`conv.ovf.u`</ph> are used, in which case the result is also <ph id="ph4">`native int`</ph>).</source>
          <target state="translated">Observe que os valores inteiros de menos de 4 bytes são estendidos para <ph id="ph1">`int32`</ph> quando eles são carregados para a pilha de avaliação (a menos que <ph id="ph2">`conv.ovf.i`</ph> ou <ph id="ph3">`conv.ovf.u`</ph> forem usados, caso em que o resultado é também <ph id="ph4">`native int`</ph>).</target>       </trans-unit>
        <trans-unit id="1378" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I8">
          <source><ph id="ph1">&lt;xref:System.OverflowException&gt;</ph> is thrown if the result can not be represented in the result type.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.OverflowException&gt;</ph> é gerada se o resultado não pode ser representado no tipo de resultado.</target>       </trans-unit>
        <trans-unit id="1379" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I8">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`conv.ovf.i8`</ph> opcode:</source>
          <target state="translated">O seguinte <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> sobrecarga de método pode usar o <ph id="ph2">`conv.ovf.i8`</ph> opcode:</target>       </trans-unit>
        <trans-unit id="1380" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I8">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="1381" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I8_Un">
          <source>Converts the unsigned value on top of the evaluation stack to signed <ph id="ph1">&lt;see langword="int64" /&gt;</ph>, throwing <ph id="ph2">&lt;see cref="T:System.OverflowException" /&gt;</ph> on overflow.</source>
          <target state="translated">Converte o valor sem sinal no topo da pilha de avaliação em <ph id="ph1">&lt;see langword="int64" /&gt;</ph> com sinal, gerando <ph id="ph2">&lt;see cref="T:System.OverflowException" /&gt;</ph> no estouro.</target>       </trans-unit>
        <trans-unit id="1382" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I8_Un">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">A tabela a seguir lista as instruções hexadecimal e formato de assembly do Microsoft Intermediate Language (MSIL), junto com um resumo breve de referência:</target>       </trans-unit>
        <trans-unit id="1383" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I8_Un">
          <source>Format</source>
          <target state="translated">Formatar</target>       </trans-unit>
        <trans-unit id="1384" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I8_Un">
          <source>Assembly Format</source>
          <target state="translated">Formato de assembly</target>       </trans-unit>
        <trans-unit id="1385" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I8_Un">
          <source>Description</source>
          <target state="translated">Descrição</target>       </trans-unit>
        <trans-unit id="1386" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I8_Un">
          <source>85</source>
          <target state="translated">85</target>       </trans-unit>
        <trans-unit id="1387" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I8_Un">
          <source>conv.ovf.i8.un</source>
          <target state="translated">conv.ovf.i8.un</target>       </trans-unit>
        <trans-unit id="1388" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I8_Un">
          <source>Converts an unsigned value to an <ph id="ph1">`int64`</ph> (on the stack as <ph id="ph2">`int64`</ph>) and throw an exception on overflow.</source>
          <target state="translated">Converte um valor sem sinal em um <ph id="ph1">`int64`</ph> (na pilha como <ph id="ph2">`int64`</ph>) e gerará uma exceção no estouro.</target>       </trans-unit>
        <trans-unit id="1389" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I8_Un">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">O comportamento de transição de pilha, em ordem sequencial, é:</target>       </trans-unit>
        <trans-unit id="1390" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I8_Un">
          <source><ph id="ph1">`value`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value`</ph> é inserido na pilha.</target>       </trans-unit>
        <trans-unit id="1391" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I8_Un">
          <source><ph id="ph1">`value`</ph> is popped from the stack and the conversion operation is attempted.</source>
          <target state="translated"><ph id="ph1">`value`</ph> é exibido na pilha e a conversão de tentativa de operação.</target>       </trans-unit>
        <trans-unit id="1392" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I8_Un">
          <source>If overflow occurs, an exception is thrown.</source>
          <target state="translated">Se ocorrer estouro, uma exceção será lançada.</target>       </trans-unit>
        <trans-unit id="1393" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I8_Un">
          <source>If the conversion is successful, the resulting value is pushed onto the stack.</source>
          <target state="translated">Se a conversão for bem-sucedida, o valor resultante é inserido na pilha.</target>       </trans-unit>
        <trans-unit id="1394" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I8_Un">
          <source>The <ph id="ph1">`conv.ovf.i8.un`</ph> opcode converts the <ph id="ph2">`value`</ph> on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack.</source>
          <target state="translated">O <ph id="ph1">`conv.ovf.i8.un`</ph> opcode converte o <ph id="ph2">`value`</ph> na parte superior da pilha para o tipo especificado no opcode e coloca convertidos valor na parte superior da pilha.</target>       </trans-unit>
        <trans-unit id="1395" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I8_Un">
          <source>If the value is too large or too small to be represented by the target type, an exception is thrown.</source>
          <target state="translated">Se o valor for muito grande ou muito pequeno para ser representado pelo tipo de destino, uma exceção será lançada.</target>       </trans-unit>
        <trans-unit id="1396" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I8_Un">
          <source>Conversions from floating-point numbers to integer values truncate the number toward zero.</source>
          <target state="translated">Conversões de números de ponto flutuante para valores inteiros truncam o número em direção a zero.</target>       </trans-unit>
        <trans-unit id="1397" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I8_Un">
          <source>Note that integer values of less than 4 bytes are extended to <ph id="ph1">`int32`</ph> when they are loaded onto the evaluation stack (unless <ph id="ph2">`conv.ovf.i`</ph> or <ph id="ph3">`conv.ovf.u`</ph> are used, in which case the result is also <ph id="ph4">`native int`</ph>).</source>
          <target state="translated">Observe que os valores inteiros de menos de 4 bytes são estendidos para <ph id="ph1">`int32`</ph> quando eles são carregados para a pilha de avaliação (a menos que <ph id="ph2">`conv.ovf.i`</ph> ou <ph id="ph3">`conv.ovf.u`</ph> forem usados, caso em que o resultado é também <ph id="ph4">`native int`</ph>).</target>       </trans-unit>
        <trans-unit id="1398" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I8_Un">
          <source><ph id="ph1">&lt;xref:System.OverflowException&gt;</ph> is thrown if the result can not be represented in the result type.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.OverflowException&gt;</ph> é gerada se o resultado não pode ser representado no tipo de resultado.</target>       </trans-unit>
        <trans-unit id="1399" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I8_Un">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`conv.ovf.i8.un`</ph> opcode:</source>
          <target state="translated">O seguinte <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> sobrecarga de método pode usar o <ph id="ph2">`conv.ovf.i8.un`</ph> opcode:</target>       </trans-unit>
        <trans-unit id="1400" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I8_Un">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="1401" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U">
          <source>Converts the signed value on top of the evaluation stack to <ph id="ph1">&lt;see langword="unsigned native int" /&gt;</ph>, throwing <ph id="ph2">&lt;see cref="T:System.OverflowException" /&gt;</ph> on overflow.</source>
          <target state="translated">Converte o valor com sinal no topo da pilha de avaliação em <ph id="ph1">&lt;see langword="unsigned native int" /&gt;</ph>, gerando <ph id="ph2">&lt;see cref="T:System.OverflowException" /&gt;</ph> no estouro.</target>       </trans-unit>
        <trans-unit id="1402" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">A tabela a seguir lista as instruções hexadecimal e formato de assembly do Microsoft Intermediate Language (MSIL), junto com um resumo breve de referência:</target>       </trans-unit>
        <trans-unit id="1403" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U">
          <source>Format</source>
          <target state="translated">Formatar</target>       </trans-unit>
        <trans-unit id="1404" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U">
          <source>Assembly Format</source>
          <target state="translated">Formato de assembly</target>       </trans-unit>
        <trans-unit id="1405" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U">
          <source>Description</source>
          <target state="translated">Descrição</target>       </trans-unit>
        <trans-unit id="1406" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U">
          <source>D5</source>
          <target state="translated">D5</target>       </trans-unit>
        <trans-unit id="1407" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U">
          <source>conv.ovf.u</source>
          <target state="translated">conv.ovf.u</target>       </trans-unit>
        <trans-unit id="1408" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U">
          <source>Convert to an <ph id="ph1">`unsigned native int`</ph> (on the stack as <ph id="ph2">`native int`</ph>) and throw an exception on overflow.</source>
          <target state="translated">Converter em um <ph id="ph1">`unsigned native int`</ph> (na pilha como <ph id="ph2">`native int`</ph>) e gerará uma exceção no estouro.</target>       </trans-unit>
        <trans-unit id="1409" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">O comportamento de transição de pilha, em ordem sequencial, é:</target>       </trans-unit>
        <trans-unit id="1410" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U">
          <source><ph id="ph1">`value`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value`</ph> é inserido na pilha.</target>       </trans-unit>
        <trans-unit id="1411" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U">
          <source><ph id="ph1">`value`</ph> is popped from the stack and the conversion operation is attempted.</source>
          <target state="translated"><ph id="ph1">`value`</ph> é exibido na pilha e a conversão de tentativa de operação.</target>       </trans-unit>
        <trans-unit id="1412" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U">
          <source>If overflow occurs, an exception is thrown.</source>
          <target state="translated">Se ocorrer estouro, uma exceção será lançada.</target>       </trans-unit>
        <trans-unit id="1413" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U">
          <source>If the conversion is successful, the resulting value is pushed onto the stack.</source>
          <target state="translated">Se a conversão for bem-sucedida, o valor resultante é inserido na pilha.</target>       </trans-unit>
        <trans-unit id="1414" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U">
          <source>The <ph id="ph1">`conv.ovf.u`</ph> opcode converts the <ph id="ph2">`value`</ph> on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack.</source>
          <target state="translated">O <ph id="ph1">`conv.ovf.u`</ph> opcode converte o <ph id="ph2">`value`</ph> na parte superior da pilha para o tipo especificado no opcode e coloca convertidos valor na parte superior da pilha.</target>       </trans-unit>
        <trans-unit id="1415" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U">
          <source>If the value is too large or too small to be represented by the target type, an exception is thrown.</source>
          <target state="translated">Se o valor for muito grande ou muito pequeno para ser representado pelo tipo de destino, uma exceção será lançada.</target>       </trans-unit>
        <trans-unit id="1416" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U">
          <source>Conversions from floating-point numbers to integer values truncate the number toward zero.</source>
          <target state="translated">Conversões de números de ponto flutuante para valores inteiros truncam o número em direção a zero.</target>       </trans-unit>
        <trans-unit id="1417" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U">
          <source>Note that integer values of less than 4 bytes are extended to <ph id="ph1">`int32`</ph> when they are loaded onto the evaluation stack (unless <ph id="ph2">`conv.ovf.i`</ph> or <ph id="ph3">`conv.ovf.u`</ph> are used, in which case the result is also <ph id="ph4">`native int`</ph>).</source>
          <target state="translated">Observe que os valores inteiros de menos de 4 bytes são estendidos para <ph id="ph1">`int32`</ph> quando eles são carregados para a pilha de avaliação (a menos que <ph id="ph2">`conv.ovf.i`</ph> ou <ph id="ph3">`conv.ovf.u`</ph> forem usados, caso em que o resultado é também <ph id="ph4">`native int`</ph>).</target>       </trans-unit>
        <trans-unit id="1418" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U">
          <source><ph id="ph1">&lt;xref:System.OverflowException&gt;</ph> is thrown if the result can not be represented in the result type.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.OverflowException&gt;</ph> é gerada se o resultado não pode ser representado no tipo de resultado.</target>       </trans-unit>
        <trans-unit id="1419" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`conv.ovf.u`</ph> opcode:</source>
          <target state="translated">O seguinte <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> sobrecarga de método pode usar o <ph id="ph2">`conv.ovf.u`</ph> opcode:</target>       </trans-unit>
        <trans-unit id="1420" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="1421" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U_Un">
          <source>Converts the unsigned value on top of the evaluation stack to <ph id="ph1">&lt;see langword="unsigned native int" /&gt;</ph>, throwing <ph id="ph2">&lt;see cref="T:System.OverflowException" /&gt;</ph> on overflow.</source>
          <target state="translated">Converte o valor sem sinal no topo da pilha de avaliação em <ph id="ph1">&lt;see langword="unsigned native int" /&gt;</ph>, gerando <ph id="ph2">&lt;see cref="T:System.OverflowException" /&gt;</ph> no estouro.</target>       </trans-unit>
        <trans-unit id="1422" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U_Un">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">A tabela a seguir lista as instruções hexadecimal e formato de assembly do Microsoft Intermediate Language (MSIL), junto com um resumo breve de referência:</target>       </trans-unit>
        <trans-unit id="1423" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U_Un">
          <source>Format</source>
          <target state="translated">Formatar</target>       </trans-unit>
        <trans-unit id="1424" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U_Un">
          <source>Assembly Format</source>
          <target state="translated">Formato de assembly</target>       </trans-unit>
        <trans-unit id="1425" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U_Un">
          <source>Description</source>
          <target state="translated">Descrição</target>       </trans-unit>
        <trans-unit id="1426" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U_Un">
          <source>8B</source>
          <target state="translated">8B</target>       </trans-unit>
        <trans-unit id="1427" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U_Un">
          <source>conv.ovf.u.un</source>
          <target state="translated">conv.ovf.u.un</target>       </trans-unit>
        <trans-unit id="1428" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U_Un">
          <source>Converts un unsigned value to an <ph id="ph1">`unsigned native int`</ph> (on the stack as <ph id="ph2">`native int`</ph>) and throw an exception on overflow.</source>
          <target state="translated">Converte Cancelar não assinado de valor para um <ph id="ph1">`unsigned native int`</ph> (na pilha como <ph id="ph2">`native int`</ph>) e gerará uma exceção no estouro.</target>       </trans-unit>
        <trans-unit id="1429" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U_Un">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">O comportamento de transição de pilha, em ordem sequencial, é:</target>       </trans-unit>
        <trans-unit id="1430" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U_Un">
          <source><ph id="ph1">`value`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value`</ph> é inserido na pilha.</target>       </trans-unit>
        <trans-unit id="1431" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U_Un">
          <source><ph id="ph1">`value`</ph> is popped from the stack and the conversion operation is attempted.</source>
          <target state="translated"><ph id="ph1">`value`</ph> é exibido na pilha e a conversão de tentativa de operação.</target>       </trans-unit>
        <trans-unit id="1432" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U_Un">
          <source>If overflow occurs, an exception is thrown.</source>
          <target state="translated">Se ocorrer estouro, uma exceção será lançada.</target>       </trans-unit>
        <trans-unit id="1433" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U_Un">
          <source>If the conversion is successful, the resulting value is pushed onto the stack.</source>
          <target state="translated">Se a conversão for bem-sucedida, o valor resultante é inserido na pilha.</target>       </trans-unit>
        <trans-unit id="1434" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U_Un">
          <source>The <ph id="ph1">`conv.ovf.u.un`</ph> opcode converts the <ph id="ph2">`value`</ph> on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack.</source>
          <target state="translated">O <ph id="ph1">`conv.ovf.u.un`</ph> opcode converte o <ph id="ph2">`value`</ph> na parte superior da pilha para o tipo especificado no opcode e coloca convertidos valor na parte superior da pilha.</target>       </trans-unit>
        <trans-unit id="1435" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U_Un">
          <source>If the value is too large or too small to be represented by the target type, an exception is thrown.</source>
          <target state="translated">Se o valor for muito grande ou muito pequeno para ser representado pelo tipo de destino, uma exceção será lançada.</target>       </trans-unit>
        <trans-unit id="1436" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U_Un">
          <source>Conversions from floating-point numbers to integer values truncate the number toward zero.</source>
          <target state="translated">Conversões de números de ponto flutuante para valores inteiros truncam o número em direção a zero.</target>       </trans-unit>
        <trans-unit id="1437" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U_Un">
          <source>Note that integer values of less than 4 bytes are extended to <ph id="ph1">`int32`</ph> when they are loaded onto the evaluation stack (unless <ph id="ph2">`conv.ovf.i`</ph> or <ph id="ph3">`conv.ovf.u`</ph> are used, in which case the result is also <ph id="ph4">`native int`</ph>).</source>
          <target state="translated">Observe que os valores inteiros de menos de 4 bytes são estendidos para <ph id="ph1">`int32`</ph> quando eles são carregados para a pilha de avaliação (a menos que <ph id="ph2">`conv.ovf.i`</ph> ou <ph id="ph3">`conv.ovf.u`</ph> forem usados, caso em que o resultado é também <ph id="ph4">`native int`</ph>).</target>       </trans-unit>
        <trans-unit id="1438" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U_Un">
          <source><ph id="ph1">&lt;xref:System.OverflowException&gt;</ph> is thrown if the result can not be represented in the result type.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.OverflowException&gt;</ph> é gerada se o resultado não pode ser representado no tipo de resultado.</target>       </trans-unit>
        <trans-unit id="1439" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U_Un">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`conv.uvf.u.un`</ph> opcode:</source>
          <target state="translated">O seguinte <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> sobrecarga de método pode usar o <ph id="ph2">`conv.uvf.u.un`</ph> opcode:</target>       </trans-unit>
        <trans-unit id="1440" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U_Un">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="1441" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U1">
          <source>Converts the signed value on top of the evaluation stack to <ph id="ph1">&lt;see langword="unsigned int8" /&gt;</ph> and extends it to <ph id="ph2">&lt;see langword="int32" /&gt;</ph>, throwing <ph id="ph3">&lt;see cref="T:System.OverflowException" /&gt;</ph> on overflow.</source>
          <target state="translated">Converte o valor com sinal no topo da pilha de avaliação em <ph id="ph1">&lt;see langword="unsigned int8" /&gt;</ph> e estende-o para <ph id="ph2">&lt;see langword="int32" /&gt;</ph>, gerando <ph id="ph3">&lt;see cref="T:System.OverflowException" /&gt;</ph> no estouro.</target>       </trans-unit>
        <trans-unit id="1442" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U1">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">A tabela a seguir lista as instruções hexadecimal e formato de assembly do Microsoft Intermediate Language (MSIL), junto com um resumo breve de referência:</target>       </trans-unit>
        <trans-unit id="1443" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U1">
          <source>Format</source>
          <target state="translated">Formatar</target>       </trans-unit>
        <trans-unit id="1444" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U1">
          <source>Assembly Format</source>
          <target state="translated">Formato de assembly</target>       </trans-unit>
        <trans-unit id="1445" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U1">
          <source>Description</source>
          <target state="translated">Descrição</target>       </trans-unit>
        <trans-unit id="1446" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U1">
          <source>B4</source>
          <target state="translated">B4</target>       </trans-unit>
        <trans-unit id="1447" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U1">
          <source>conv.ovf.u1</source>
          <target state="translated">conv.ovf.u1</target>       </trans-unit>
        <trans-unit id="1448" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U1">
          <source>Convert to an <ph id="ph1">`unsigned int8`</ph> (on the stack as <ph id="ph2">`int32`</ph>) and throw an exception on overflow.</source>
          <target state="translated">Converter em um <ph id="ph1">`unsigned int8`</ph> (na pilha como <ph id="ph2">`int32`</ph>) e gerará uma exceção no estouro.</target>       </trans-unit>
        <trans-unit id="1449" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U1">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">O comportamento de transição de pilha, em ordem sequencial, é:</target>       </trans-unit>
        <trans-unit id="1450" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U1">
          <source><ph id="ph1">`value`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value`</ph> é inserido na pilha.</target>       </trans-unit>
        <trans-unit id="1451" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U1">
          <source><ph id="ph1">`value`</ph> is popped from the stack and the conversion operation is attempted.</source>
          <target state="translated"><ph id="ph1">`value`</ph> é exibido na pilha e a conversão de tentativa de operação.</target>       </trans-unit>
        <trans-unit id="1452" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U1">
          <source>If overflow occurs, an exception is thrown.</source>
          <target state="translated">Se ocorrer estouro, uma exceção será lançada.</target>       </trans-unit>
        <trans-unit id="1453" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U1">
          <source>If the conversion is successful, the resulting value is pushed onto the stack.</source>
          <target state="translated">Se a conversão for bem-sucedida, o valor resultante é inserido na pilha.</target>       </trans-unit>
        <trans-unit id="1454" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U1">
          <source>The <ph id="ph1">`conv.ovf.u1`</ph> opcode converts the <ph id="ph2">`value`</ph> on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack.</source>
          <target state="translated">O <ph id="ph1">`conv.ovf.u1`</ph> opcode converte o <ph id="ph2">`value`</ph> na parte superior da pilha para o tipo especificado no opcode e coloca convertidos valor na parte superior da pilha.</target>       </trans-unit>
        <trans-unit id="1455" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U1">
          <source>If the value is too large or too small to be represented by the target type, an exception is thrown.</source>
          <target state="translated">Se o valor for muito grande ou muito pequeno para ser representado pelo tipo de destino, uma exceção será lançada.</target>       </trans-unit>
        <trans-unit id="1456" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U1">
          <source>Conversions from floating-point numbers to integer values truncate the number toward zero.</source>
          <target state="translated">Conversões de números de ponto flutuante para valores inteiros truncam o número em direção a zero.</target>       </trans-unit>
        <trans-unit id="1457" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U1">
          <source>Note that integer values of less than 4 bytes are extended to <ph id="ph1">`int32`</ph> when they are loaded onto the evaluation stack (unless <ph id="ph2">`conv.ovf.i`</ph> or <ph id="ph3">`conv.ovf.u`</ph> are used, in which case the result is also <ph id="ph4">`native int`</ph>).</source>
          <target state="translated">Observe que os valores inteiros de menos de 4 bytes são estendidos para <ph id="ph1">`int32`</ph> quando eles são carregados para a pilha de avaliação (a menos que <ph id="ph2">`conv.ovf.i`</ph> ou <ph id="ph3">`conv.ovf.u`</ph> forem usados, caso em que o resultado é também <ph id="ph4">`native int`</ph>).</target>       </trans-unit>
        <trans-unit id="1458" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U1">
          <source><ph id="ph1">&lt;xref:System.OverflowException&gt;</ph> is thrown if the result can not be represented in the result type.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.OverflowException&gt;</ph> é gerada se o resultado não pode ser representado no tipo de resultado.</target>       </trans-unit>
        <trans-unit id="1459" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U1">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`conv.ovf.u1`</ph> opcode:</source>
          <target state="translated">O seguinte <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> sobrecarga de método pode usar o <ph id="ph2">`conv.ovf.u1`</ph> opcode:</target>       </trans-unit>
        <trans-unit id="1460" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U1">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="1461" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U1_Un">
          <source>Converts the unsigned value on top of the evaluation stack to <ph id="ph1">&lt;see langword="unsigned int8" /&gt;</ph> and extends it to <ph id="ph2">&lt;see langword="int32" /&gt;</ph>, throwing <ph id="ph3">&lt;see cref="T:System.OverflowException" /&gt;</ph> on overflow.</source>
          <target state="translated">Converte o valor sem sinal no topo da pilha de avaliação em <ph id="ph1">&lt;see langword="unsigned int8" /&gt;</ph> e estende-o para <ph id="ph2">&lt;see langword="int32" /&gt;</ph>, gerando <ph id="ph3">&lt;see cref="T:System.OverflowException" /&gt;</ph> no estouro.</target>       </trans-unit>
        <trans-unit id="1462" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U1_Un">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">A tabela a seguir lista as instruções hexadecimal e formato de assembly do Microsoft Intermediate Language (MSIL), junto com um resumo breve de referência:</target>       </trans-unit>
        <trans-unit id="1463" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U1_Un">
          <source>Format</source>
          <target state="translated">Formatar</target>       </trans-unit>
        <trans-unit id="1464" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U1_Un">
          <source>Assembly Format</source>
          <target state="translated">Formato de assembly</target>       </trans-unit>
        <trans-unit id="1465" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U1_Un">
          <source>Description</source>
          <target state="translated">Descrição</target>       </trans-unit>
        <trans-unit id="1466" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U1_Un">
          <source>86</source>
          <target state="translated">86</target>       </trans-unit>
        <trans-unit id="1467" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U1_Un">
          <source>conv.ovf.u1.un</source>
          <target state="translated">conv.ovf.u1.un</target>       </trans-unit>
        <trans-unit id="1468" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U1_Un">
          <source>Converts an unsigned value to an <ph id="ph1">`unsigned int8`</ph> (on the stack as <ph id="ph2">`int32`</ph>) and throw an exception on overflow.</source>
          <target state="translated">Converte um valor sem sinal em um <ph id="ph1">`unsigned int8`</ph> (na pilha como <ph id="ph2">`int32`</ph>) e gerará uma exceção no estouro.</target>       </trans-unit>
        <trans-unit id="1469" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U1_Un">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">O comportamento de transição de pilha, em ordem sequencial, é:</target>       </trans-unit>
        <trans-unit id="1470" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U1_Un">
          <source><ph id="ph1">`value`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value`</ph> é inserido na pilha.</target>       </trans-unit>
        <trans-unit id="1471" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U1_Un">
          <source><ph id="ph1">`value`</ph> is popped from the stack and the conversion operation is attempted.</source>
          <target state="translated"><ph id="ph1">`value`</ph> é exibido na pilha e a conversão de tentativa de operação.</target>       </trans-unit>
        <trans-unit id="1472" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U1_Un">
          <source>If overflow occurs, an exception is thrown.</source>
          <target state="translated">Se ocorrer estouro, uma exceção será lançada.</target>       </trans-unit>
        <trans-unit id="1473" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U1_Un">
          <source>If the conversion is successful, the resulting value is pushed onto the stack.</source>
          <target state="translated">Se a conversão for bem-sucedida, o valor resultante é inserido na pilha.</target>       </trans-unit>
        <trans-unit id="1474" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U1_Un">
          <source>The <ph id="ph1">`conv.ovf.u1.un`</ph> opcode converts the <ph id="ph2">`value`</ph> on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack.</source>
          <target state="translated">O <ph id="ph1">`conv.ovf.u1.un`</ph> opcode converte o <ph id="ph2">`value`</ph> na parte superior da pilha para o tipo especificado no opcode e coloca convertidos valor na parte superior da pilha.</target>       </trans-unit>
        <trans-unit id="1475" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U1_Un">
          <source>If the value is too large or too small to be represented by the target type, an exception is thrown.</source>
          <target state="translated">Se o valor for muito grande ou muito pequeno para ser representado pelo tipo de destino, uma exceção será lançada.</target>       </trans-unit>
        <trans-unit id="1476" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U1_Un">
          <source>Conversions from floating-point numbers to integer values truncate the number toward zero.</source>
          <target state="translated">Conversões de números de ponto flutuante para valores inteiros truncam o número em direção a zero.</target>       </trans-unit>
        <trans-unit id="1477" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U1_Un">
          <source>Note that integer values of less than 4 bytes are extended to <ph id="ph1">`int32`</ph> when they are loaded onto the evaluation stack (unless <ph id="ph2">`conv.ovf.i`</ph> or <ph id="ph3">`conv.ovf.u`</ph> are used, in which case the result is also <ph id="ph4">`native int`</ph>).</source>
          <target state="translated">Observe que os valores inteiros de menos de 4 bytes são estendidos para <ph id="ph1">`int32`</ph> quando eles são carregados para a pilha de avaliação (a menos que <ph id="ph2">`conv.ovf.i`</ph> ou <ph id="ph3">`conv.ovf.u`</ph> forem usados, caso em que o resultado é também <ph id="ph4">`native int`</ph>).</target>       </trans-unit>
        <trans-unit id="1478" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U1_Un">
          <source><ph id="ph1">&lt;xref:System.OverflowException&gt;</ph> is thrown if the result can not be represented in the result type.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.OverflowException&gt;</ph> é gerada se o resultado não pode ser representado no tipo de resultado.</target>       </trans-unit>
        <trans-unit id="1479" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U1_Un">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`conv.ovf.u1.un`</ph> opcode:</source>
          <target state="translated">O seguinte <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> sobrecarga de método pode usar o <ph id="ph2">`conv.ovf.u1.un`</ph> opcode:</target>       </trans-unit>
        <trans-unit id="1480" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U1_Un">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="1481" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U2">
          <source>Converts the signed value on top of the evaluation stack to <ph id="ph1">&lt;see langword="unsigned int16" /&gt;</ph> and extends it to <ph id="ph2">&lt;see langword="int32" /&gt;</ph>, throwing <ph id="ph3">&lt;see cref="T:System.OverflowException" /&gt;</ph> on overflow.</source>
          <target state="translated">Converte o valor com sinal no topo da pilha de avaliação em <ph id="ph1">&lt;see langword="unsigned int16" /&gt;</ph> e estende-o para <ph id="ph2">&lt;see langword="int32" /&gt;</ph>, gerando <ph id="ph3">&lt;see cref="T:System.OverflowException" /&gt;</ph> no estouro.</target>       </trans-unit>
        <trans-unit id="1482" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U2">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">A tabela a seguir lista as instruções hexadecimal e formato de assembly do Microsoft Intermediate Language (MSIL), junto com um resumo breve de referência:</target>       </trans-unit>
        <trans-unit id="1483" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U2">
          <source>Format</source>
          <target state="translated">Formatar</target>       </trans-unit>
        <trans-unit id="1484" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U2">
          <source>Assembly Format</source>
          <target state="translated">Formato de assembly</target>       </trans-unit>
        <trans-unit id="1485" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U2">
          <source>Description</source>
          <target state="translated">Descrição</target>       </trans-unit>
        <trans-unit id="1486" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U2">
          <source>B6</source>
          <target state="translated">B6</target>       </trans-unit>
        <trans-unit id="1487" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U2">
          <source>conv.ovf.u2</source>
          <target state="translated">conv.ovf.u2</target>       </trans-unit>
        <trans-unit id="1488" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U2">
          <source>Convert to an <ph id="ph1">`unsigned int16`</ph> (on the stack as <ph id="ph2">`int32`</ph>) and throw an exception on overflow.</source>
          <target state="translated">Converter em um <ph id="ph1">`unsigned int16`</ph> (na pilha como <ph id="ph2">`int32`</ph>) e gerará uma exceção no estouro.</target>       </trans-unit>
        <trans-unit id="1489" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U2">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">O comportamento de transição de pilha, em ordem sequencial, é:</target>       </trans-unit>
        <trans-unit id="1490" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U2">
          <source><ph id="ph1">`value`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value`</ph> é inserido na pilha.</target>       </trans-unit>
        <trans-unit id="1491" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U2">
          <source><ph id="ph1">`value`</ph> is popped from the stack and the conversion operation is attempted.</source>
          <target state="translated"><ph id="ph1">`value`</ph> é exibido na pilha e a conversão de tentativa de operação.</target>       </trans-unit>
        <trans-unit id="1492" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U2">
          <source>If overflow occurs, an exception is thrown.</source>
          <target state="translated">Se ocorrer estouro, uma exceção será lançada.</target>       </trans-unit>
        <trans-unit id="1493" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U2">
          <source>If the conversion is successful, the resulting value is pushed onto the stack.</source>
          <target state="translated">Se a conversão for bem-sucedida, o valor resultante é inserido na pilha.</target>       </trans-unit>
        <trans-unit id="1494" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U2">
          <source>The <ph id="ph1">`conv.ovf.u2`</ph> opcode converts the <ph id="ph2">`value`</ph> on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack.</source>
          <target state="translated">O <ph id="ph1">`conv.ovf.u2`</ph> opcode converte o <ph id="ph2">`value`</ph> na parte superior da pilha para o tipo especificado no opcode e coloca convertidos valor na parte superior da pilha.</target>       </trans-unit>
        <trans-unit id="1495" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U2">
          <source>If the value is too large or too small to be represented by the target type, an exception is thrown.</source>
          <target state="translated">Se o valor for muito grande ou muito pequeno para ser representado pelo tipo de destino, uma exceção será lançada.</target>       </trans-unit>
        <trans-unit id="1496" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U2">
          <source>Conversions from floating-point numbers to integer values truncate the number toward zero.</source>
          <target state="translated">Conversões de números de ponto flutuante para valores inteiros truncam o número em direção a zero.</target>       </trans-unit>
        <trans-unit id="1497" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U2">
          <source>Note that integer values of less than 4 bytes are extended to <ph id="ph1">`int32`</ph> when they are loaded onto the evaluation stack (unless <ph id="ph2">`conv.ovf.i`</ph> or <ph id="ph3">`conv.ovf.u`</ph> are used, in which case the result is also <ph id="ph4">`native int`</ph>).</source>
          <target state="translated">Observe que os valores inteiros de menos de 4 bytes são estendidos para <ph id="ph1">`int32`</ph> quando eles são carregados para a pilha de avaliação (a menos que <ph id="ph2">`conv.ovf.i`</ph> ou <ph id="ph3">`conv.ovf.u`</ph> forem usados, caso em que o resultado é também <ph id="ph4">`native int`</ph>).</target>       </trans-unit>
        <trans-unit id="1498" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U2">
          <source><ph id="ph1">&lt;xref:System.OverflowException&gt;</ph> is thrown if the result can not be represented in the result type.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.OverflowException&gt;</ph> é gerada se o resultado não pode ser representado no tipo de resultado.</target>       </trans-unit>
        <trans-unit id="1499" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U2">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`conv.ovf.u2`</ph> opcode:</source>
          <target state="translated">O seguinte <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> sobrecarga de método pode usar o <ph id="ph2">`conv.ovf.u2`</ph> opcode:</target>       </trans-unit>
        <trans-unit id="1500" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U2">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="1501" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U2_Un">
          <source>Converts the unsigned value on top of the evaluation stack to <ph id="ph1">&lt;see langword="unsigned int16" /&gt;</ph> and extends it to <ph id="ph2">&lt;see langword="int32" /&gt;</ph>, throwing <ph id="ph3">&lt;see cref="T:System.OverflowException" /&gt;</ph> on overflow.</source>
          <target state="translated">Converte o valor sem sinal no topo da pilha de avaliação em <ph id="ph1">&lt;see langword="unsigned int16" /&gt;</ph> e estende-o para <ph id="ph2">&lt;see langword="int32" /&gt;</ph>, gerando <ph id="ph3">&lt;see cref="T:System.OverflowException" /&gt;</ph> no estouro.</target>       </trans-unit>
        <trans-unit id="1502" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U2_Un">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">A tabela a seguir lista as instruções hexadecimal e formato de assembly do Microsoft Intermediate Language (MSIL), junto com um resumo breve de referência:</target>       </trans-unit>
        <trans-unit id="1503" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U2_Un">
          <source>Format</source>
          <target state="translated">Formatar</target>       </trans-unit>
        <trans-unit id="1504" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U2_Un">
          <source>Assembly Format</source>
          <target state="translated">Formato de assembly</target>       </trans-unit>
        <trans-unit id="1505" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U2_Un">
          <source>Description</source>
          <target state="translated">Descrição</target>       </trans-unit>
        <trans-unit id="1506" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U2_Un">
          <source>87</source>
          <target state="translated">87</target>       </trans-unit>
        <trans-unit id="1507" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U2_Un">
          <source>conv.ovf.u2.un</source>
          <target state="translated">conv.ovf.u2.un</target>       </trans-unit>
        <trans-unit id="1508" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U2_Un">
          <source>Converts an unsigned value to an <ph id="ph1">`unsigned int16`</ph> (on the stack as <ph id="ph2">`int32`</ph>) and throw an exception on overflow.</source>
          <target state="translated">Converte um valor sem sinal em um <ph id="ph1">`unsigned int16`</ph> (na pilha como <ph id="ph2">`int32`</ph>) e gerará uma exceção no estouro.</target>       </trans-unit>
        <trans-unit id="1509" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U2_Un">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">O comportamento de transição de pilha, em ordem sequencial, é:</target>       </trans-unit>
        <trans-unit id="1510" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U2_Un">
          <source><ph id="ph1">`value`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value`</ph> é inserido na pilha.</target>       </trans-unit>
        <trans-unit id="1511" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U2_Un">
          <source><ph id="ph1">`value`</ph> is popped from the stack and the conversion operation is attempted.</source>
          <target state="translated"><ph id="ph1">`value`</ph> é exibido na pilha e a conversão de tentativa de operação.</target>       </trans-unit>
        <trans-unit id="1512" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U2_Un">
          <source>If overflow occurs, an exception is thrown.</source>
          <target state="translated">Se ocorrer estouro, uma exceção será lançada.</target>       </trans-unit>
        <trans-unit id="1513" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U2_Un">
          <source>If the conversion is successful, the resulting value is pushed onto the stack.</source>
          <target state="translated">Se a conversão for bem-sucedida, o valor resultante é inserido na pilha.</target>       </trans-unit>
        <trans-unit id="1514" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U2_Un">
          <source>The <ph id="ph1">`conv.ovf.u2.un`</ph> opcode converts the <ph id="ph2">`value`</ph> on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack.</source>
          <target state="translated">O <ph id="ph1">`conv.ovf.u2.un`</ph> opcode converte o <ph id="ph2">`value`</ph> na parte superior da pilha para o tipo especificado no opcode e coloca convertidos valor na parte superior da pilha.</target>       </trans-unit>
        <trans-unit id="1515" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U2_Un">
          <source>If the value is too large or too small to be represented by the target type, an exception is thrown.</source>
          <target state="translated">Se o valor for muito grande ou muito pequeno para ser representado pelo tipo de destino, uma exceção será lançada.</target>       </trans-unit>
        <trans-unit id="1516" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U2_Un">
          <source>Conversions from floating-point numbers to integer values truncate the number toward zero.</source>
          <target state="translated">Conversões de números de ponto flutuante para valores inteiros truncam o número em direção a zero.</target>       </trans-unit>
        <trans-unit id="1517" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U2_Un">
          <source>Note that integer values of less than 4 bytes are extended to <ph id="ph1">`int32`</ph> when they are loaded onto the evaluation stack (unless <ph id="ph2">`conv.ovf.i`</ph> or <ph id="ph3">`conv.ovf.u`</ph> are used, in which case the result is also <ph id="ph4">`native int`</ph>).</source>
          <target state="translated">Observe que os valores inteiros de menos de 4 bytes são estendidos para <ph id="ph1">`int32`</ph> quando eles são carregados para a pilha de avaliação (a menos que <ph id="ph2">`conv.ovf.i`</ph> ou <ph id="ph3">`conv.ovf.u`</ph> forem usados, caso em que o resultado é também <ph id="ph4">`native int`</ph>).</target>       </trans-unit>
        <trans-unit id="1518" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U2_Un">
          <source><ph id="ph1">&lt;xref:System.OverflowException&gt;</ph> is thrown if the result can not be represented in the result type.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.OverflowException&gt;</ph> é gerada se o resultado não pode ser representado no tipo de resultado.</target>       </trans-unit>
        <trans-unit id="1519" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U2_Un">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`conv.ovf.u2.un`</ph> opcode:</source>
          <target state="translated">O seguinte <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> sobrecarga de método pode usar o <ph id="ph2">`conv.ovf.u2.un`</ph> opcode:</target>       </trans-unit>
        <trans-unit id="1520" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U2_Un">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="1521" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U4">
          <source>Converts the signed value on top of the evaluation stack to <ph id="ph1">&lt;see langword="unsigned int32" /&gt;</ph>, throwing <ph id="ph2">&lt;see cref="T:System.OverflowException" /&gt;</ph> on overflow.</source>
          <target state="translated">Converte o valor com sinal no topo da pilha de avaliação em <ph id="ph1">&lt;see langword="unsigned int32" /&gt;</ph>, gerando <ph id="ph2">&lt;see cref="T:System.OverflowException" /&gt;</ph> no estouro.</target>       </trans-unit>
        <trans-unit id="1522" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U4">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">A tabela a seguir lista as instruções hexadecimal e formato de assembly do Microsoft Intermediate Language (MSIL), junto com um resumo breve de referência:</target>       </trans-unit>
        <trans-unit id="1523" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U4">
          <source>Format</source>
          <target state="translated">Formatar</target>       </trans-unit>
        <trans-unit id="1524" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U4">
          <source>Assembly Format</source>
          <target state="translated">Formato de assembly</target>       </trans-unit>
        <trans-unit id="1525" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U4">
          <source>Description</source>
          <target state="translated">Descrição</target>       </trans-unit>
        <trans-unit id="1526" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U4">
          <source>B8</source>
          <target state="translated">B8</target>       </trans-unit>
        <trans-unit id="1527" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U4">
          <source>conv.ovf.u4</source>
          <target state="translated">conv.ovf.u4</target>       </trans-unit>
        <trans-unit id="1528" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U4">
          <source>Convert to an <ph id="ph1">`unsigned int32`</ph> (on the stack as <ph id="ph2">`int32`</ph>) and throw an exception on overflow.</source>
          <target state="translated">Converter em um <ph id="ph1">`unsigned int32`</ph> (na pilha como <ph id="ph2">`int32`</ph>) e gerará uma exceção no estouro.</target>       </trans-unit>
        <trans-unit id="1529" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U4">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">O comportamento de transição de pilha, em ordem sequencial, é:</target>       </trans-unit>
        <trans-unit id="1530" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U4">
          <source><ph id="ph1">`value`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value`</ph> é inserido na pilha.</target>       </trans-unit>
        <trans-unit id="1531" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U4">
          <source><ph id="ph1">`value`</ph> is popped from the stack and the conversion operation is attempted.</source>
          <target state="translated"><ph id="ph1">`value`</ph> é exibido na pilha e a conversão de tentativa de operação.</target>       </trans-unit>
        <trans-unit id="1532" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U4">
          <source>If overflow occurs, an exception is thrown.</source>
          <target state="translated">Se ocorrer estouro, uma exceção será lançada.</target>       </trans-unit>
        <trans-unit id="1533" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U4">
          <source>If the conversion is successful, the resulting value is pushed onto the stack.</source>
          <target state="translated">Se a conversão for bem-sucedida, o valor resultante é inserido na pilha.</target>       </trans-unit>
        <trans-unit id="1534" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U4">
          <source>The <ph id="ph1">`conv.ovf.u4`</ph> opcode converts the <ph id="ph2">`value`</ph> on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack.</source>
          <target state="translated">O <ph id="ph1">`conv.ovf.u4`</ph> opcode converte o <ph id="ph2">`value`</ph> na parte superior da pilha para o tipo especificado no opcode e coloca convertidos valor na parte superior da pilha.</target>       </trans-unit>
        <trans-unit id="1535" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U4">
          <source>If the value is too large or too small to be represented by the target type, an exception is thrown.</source>
          <target state="translated">Se o valor for muito grande ou muito pequeno para ser representado pelo tipo de destino, uma exceção será lançada.</target>       </trans-unit>
        <trans-unit id="1536" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U4">
          <source>Conversions from floating-point numbers to integer values truncate the number toward zero.</source>
          <target state="translated">Conversões de números de ponto flutuante para valores inteiros truncam o número em direção a zero.</target>       </trans-unit>
        <trans-unit id="1537" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U4">
          <source>Note that integer values of less than 4 bytes are extended to <ph id="ph1">`int32`</ph> when they are loaded onto the evaluation stack (unless <ph id="ph2">`conv.ovf.i`</ph> or <ph id="ph3">`conv.ovf.u`</ph> are used, in which case the result is also <ph id="ph4">`native int`</ph>).</source>
          <target state="translated">Observe que os valores inteiros de menos de 4 bytes são estendidos para <ph id="ph1">`int32`</ph> quando eles são carregados para a pilha de avaliação (a menos que <ph id="ph2">`conv.ovf.i`</ph> ou <ph id="ph3">`conv.ovf.u`</ph> forem usados, caso em que o resultado é também <ph id="ph4">`native int`</ph>).</target>       </trans-unit>
        <trans-unit id="1538" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U4">
          <source><ph id="ph1">&lt;xref:System.OverflowException&gt;</ph> is thrown if the result can not be represented in the result type.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.OverflowException&gt;</ph> é gerada se o resultado não pode ser representado no tipo de resultado.</target>       </trans-unit>
        <trans-unit id="1539" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U4">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`conv.ovf.u4`</ph> opcode:</source>
          <target state="translated">O seguinte <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> sobrecarga de método pode usar o <ph id="ph2">`conv.ovf.u4`</ph> opcode:</target>       </trans-unit>
        <trans-unit id="1540" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U4">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="1541" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U4_Un">
          <source>Converts the unsigned value on top of the evaluation stack to <ph id="ph1">&lt;see langword="unsigned int32" /&gt;</ph>, throwing <ph id="ph2">&lt;see cref="T:System.OverflowException" /&gt;</ph> on overflow.</source>
          <target state="translated">Converte o valor sem sinal no topo da pilha de avaliação em <ph id="ph1">&lt;see langword="unsigned int32" /&gt;</ph>, gerando <ph id="ph2">&lt;see cref="T:System.OverflowException" /&gt;</ph> no estouro.</target>       </trans-unit>
        <trans-unit id="1542" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U4_Un">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">A tabela a seguir lista as instruções hexadecimal e formato de assembly do Microsoft Intermediate Language (MSIL), junto com um resumo breve de referência:</target>       </trans-unit>
        <trans-unit id="1543" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U4_Un">
          <source>Format</source>
          <target state="translated">Formatar</target>       </trans-unit>
        <trans-unit id="1544" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U4_Un">
          <source>Assembly Format</source>
          <target state="translated">Formato de assembly</target>       </trans-unit>
        <trans-unit id="1545" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U4_Un">
          <source>Description</source>
          <target state="translated">Descrição</target>       </trans-unit>
        <trans-unit id="1546" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U4_Un">
          <source>88</source>
          <target state="translated">88</target>       </trans-unit>
        <trans-unit id="1547" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U4_Un">
          <source>conv.ovf.u4.un</source>
          <target state="translated">conv.ovf.u4.un</target>       </trans-unit>
        <trans-unit id="1548" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U4_Un">
          <source>Converts an unsigned value to an <ph id="ph1">`unsigned int32`</ph> (on the stack as <ph id="ph2">`int32`</ph>) and throw an exception on overflow.</source>
          <target state="translated">Converte um valor sem sinal em um <ph id="ph1">`unsigned int32`</ph> (na pilha como <ph id="ph2">`int32`</ph>) e gerará uma exceção no estouro.</target>       </trans-unit>
        <trans-unit id="1549" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U4_Un">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">O comportamento de transição de pilha, em ordem sequencial, é:</target>       </trans-unit>
        <trans-unit id="1550" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U4_Un">
          <source><ph id="ph1">`value`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value`</ph> é inserido na pilha.</target>       </trans-unit>
        <trans-unit id="1551" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U4_Un">
          <source><ph id="ph1">`value`</ph> is popped from the stack and the conversion operation is attempted.</source>
          <target state="translated"><ph id="ph1">`value`</ph> é exibido na pilha e a conversão de tentativa de operação.</target>       </trans-unit>
        <trans-unit id="1552" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U4_Un">
          <source>If overflow occurs, an exception is thrown.</source>
          <target state="translated">Se ocorrer estouro, uma exceção será lançada.</target>       </trans-unit>
        <trans-unit id="1553" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U4_Un">
          <source>If the conversion is successful, the resulting value is pushed onto the stack.</source>
          <target state="translated">Se a conversão for bem-sucedida, o valor resultante é inserido na pilha.</target>       </trans-unit>
        <trans-unit id="1554" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U4_Un">
          <source>The <ph id="ph1">`conv.ovf.u4.un`</ph> opcode converts the <ph id="ph2">`value`</ph> on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack.</source>
          <target state="translated">O <ph id="ph1">`conv.ovf.u4.un`</ph> opcode converte o <ph id="ph2">`value`</ph> na parte superior da pilha para o tipo especificado no opcode e coloca convertidos valor na parte superior da pilha.</target>       </trans-unit>
        <trans-unit id="1555" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U4_Un">
          <source>If the value is too large or too small to be represented by the target type, an exception is thrown.</source>
          <target state="translated">Se o valor for muito grande ou muito pequeno para ser representado pelo tipo de destino, uma exceção será lançada.</target>       </trans-unit>
        <trans-unit id="1556" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U4_Un">
          <source>Conversions from floating-point numbers to integer values truncate the number toward zero.</source>
          <target state="translated">Conversões de números de ponto flutuante para valores inteiros truncam o número em direção a zero.</target>       </trans-unit>
        <trans-unit id="1557" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U4_Un">
          <source>Note that integer values of less than 4 bytes are extended to <ph id="ph1">`int32`</ph> when they are loaded onto the evaluation stack (unless <ph id="ph2">`conv.ovf.i`</ph> or <ph id="ph3">`conv.ovf.u`</ph> are used, in which case the result is also <ph id="ph4">`native int`</ph>).</source>
          <target state="translated">Observe que os valores inteiros de menos de 4 bytes são estendidos para <ph id="ph1">`int32`</ph> quando eles são carregados para a pilha de avaliação (a menos que <ph id="ph2">`conv.ovf.i`</ph> ou <ph id="ph3">`conv.ovf.u`</ph> forem usados, caso em que o resultado é também <ph id="ph4">`native int`</ph>).</target>       </trans-unit>
        <trans-unit id="1558" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U4_Un">
          <source><ph id="ph1">&lt;xref:System.OverflowException&gt;</ph> is thrown if the result can not be represented in the result type.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.OverflowException&gt;</ph> é gerada se o resultado não pode ser representado no tipo de resultado.</target>       </trans-unit>
        <trans-unit id="1559" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U4_Un">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`conv.ovf.u4.un`</ph> opcode:</source>
          <target state="translated">O seguinte <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> sobrecarga de método pode usar o <ph id="ph2">`conv.ovf.u4.un`</ph> opcode:</target>       </trans-unit>
        <trans-unit id="1560" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U4_Un">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="1561" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U8">
          <source>Converts the signed value on top of the evaluation stack to <ph id="ph1">&lt;see langword="unsigned int64" /&gt;</ph>, throwing <ph id="ph2">&lt;see cref="T:System.OverflowException" /&gt;</ph> on overflow.</source>
          <target state="translated">Converte o valor com sinal no topo da pilha de avaliação em <ph id="ph1">&lt;see langword="unsigned int64" /&gt;</ph>, gerando <ph id="ph2">&lt;see cref="T:System.OverflowException" /&gt;</ph> no estouro.</target>       </trans-unit>
        <trans-unit id="1562" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U8">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">A tabela a seguir lista as instruções hexadecimal e formato de assembly do Microsoft Intermediate Language (MSIL), junto com um resumo breve de referência:</target>       </trans-unit>
        <trans-unit id="1563" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U8">
          <source>Format</source>
          <target state="translated">Formatar</target>       </trans-unit>
        <trans-unit id="1564" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U8">
          <source>Assembly Format</source>
          <target state="translated">Formato de assembly</target>       </trans-unit>
        <trans-unit id="1565" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U8">
          <source>Description</source>
          <target state="translated">Descrição</target>       </trans-unit>
        <trans-unit id="1566" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U8">
          <source>BA</source>
          <target state="translated">BA</target>       </trans-unit>
        <trans-unit id="1567" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U8">
          <source>conv.ovf.u8</source>
          <target state="translated">conv.ovf.u8</target>       </trans-unit>
        <trans-unit id="1568" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U8">
          <source>Convert to an <ph id="ph1">`unsigned int64`</ph> (on the stack as <ph id="ph2">`int64`</ph>) and throw an exception on overflow.</source>
          <target state="translated">Converter em um <ph id="ph1">`unsigned int64`</ph> (na pilha como <ph id="ph2">`int64`</ph>) e gerará uma exceção no estouro.</target>       </trans-unit>
        <trans-unit id="1569" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U8">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">O comportamento de transição de pilha, em ordem sequencial, é:</target>       </trans-unit>
        <trans-unit id="1570" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U8">
          <source><ph id="ph1">`value`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value`</ph> é inserido na pilha.</target>       </trans-unit>
        <trans-unit id="1571" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U8">
          <source><ph id="ph1">`value`</ph> is popped from the stack and the conversion operation is attempted.</source>
          <target state="translated"><ph id="ph1">`value`</ph> é exibido na pilha e a conversão de tentativa de operação.</target>       </trans-unit>
        <trans-unit id="1572" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U8">
          <source>If overflow occurs, an exception is thrown.</source>
          <target state="translated">Se ocorrer estouro, uma exceção será lançada.</target>       </trans-unit>
        <trans-unit id="1573" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U8">
          <source>If the conversion is successful, the resulting value is pushed onto the stack.</source>
          <target state="translated">Se a conversão for bem-sucedida, o valor resultante é inserido na pilha.</target>       </trans-unit>
        <trans-unit id="1574" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U8">
          <source>The <ph id="ph1">`conv.ovf.u8`</ph> opcode converts the <ph id="ph2">`value`</ph> on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack.</source>
          <target state="translated">O <ph id="ph1">`conv.ovf.u8`</ph> opcode converte o <ph id="ph2">`value`</ph> na parte superior da pilha para o tipo especificado no opcode e coloca convertidos valor na parte superior da pilha.</target>       </trans-unit>
        <trans-unit id="1575" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U8">
          <source>If the value is too large or too small to be represented by the target type, an exception is thrown.</source>
          <target state="translated">Se o valor for muito grande ou muito pequeno para ser representado pelo tipo de destino, uma exceção será lançada.</target>       </trans-unit>
        <trans-unit id="1576" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U8">
          <source>Conversions from floating-point numbers to integer values truncate the number toward zero.</source>
          <target state="translated">Conversões de números de ponto flutuante para valores inteiros truncam o número em direção a zero.</target>       </trans-unit>
        <trans-unit id="1577" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U8">
          <source>Note that integer values of less than 4 bytes are extended to <ph id="ph1">`int32`</ph> when they are loaded onto the evaluation stack (unless <ph id="ph2">`conv.ovf.i`</ph> or <ph id="ph3">`conv.ovf.u`</ph> are used, in which case the result is also <ph id="ph4">`native int`</ph>).</source>
          <target state="translated">Observe que os valores inteiros de menos de 4 bytes são estendidos para <ph id="ph1">`int32`</ph> quando eles são carregados para a pilha de avaliação (a menos que <ph id="ph2">`conv.ovf.i`</ph> ou <ph id="ph3">`conv.ovf.u`</ph> forem usados, caso em que o resultado é também <ph id="ph4">`native int`</ph>).</target>       </trans-unit>
        <trans-unit id="1578" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U8">
          <source><ph id="ph1">&lt;xref:System.OverflowException&gt;</ph> is thrown if the result can not be represented in the result type.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.OverflowException&gt;</ph> é gerada se o resultado não pode ser representado no tipo de resultado.</target>       </trans-unit>
        <trans-unit id="1579" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U8">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`conv.ovf.u8`</ph> opcode:</source>
          <target state="translated">O seguinte <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> sobrecarga de método pode usar o <ph id="ph2">`conv.ovf.u8`</ph> opcode:</target>       </trans-unit>
        <trans-unit id="1580" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U8">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="1581" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U8_Un">
          <source>Converts the unsigned value on top of the evaluation stack to <ph id="ph1">&lt;see langword="unsigned int64" /&gt;</ph>, throwing <ph id="ph2">&lt;see cref="T:System.OverflowException" /&gt;</ph> on overflow.</source>
          <target state="translated">Converte o valor sem sinal no topo da pilha de avaliação em <ph id="ph1">&lt;see langword="unsigned int64" /&gt;</ph>, gerando <ph id="ph2">&lt;see cref="T:System.OverflowException" /&gt;</ph> no estouro.</target>       </trans-unit>
        <trans-unit id="1582" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U8_Un">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">A tabela a seguir lista as instruções hexadecimal e formato de assembly do Microsoft Intermediate Language (MSIL), junto com um resumo breve de referência:</target>       </trans-unit>
        <trans-unit id="1583" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U8_Un">
          <source>Format</source>
          <target state="translated">Formatar</target>       </trans-unit>
        <trans-unit id="1584" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U8_Un">
          <source>Assembly Format</source>
          <target state="translated">Formato de assembly</target>       </trans-unit>
        <trans-unit id="1585" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U8_Un">
          <source>Description</source>
          <target state="translated">Descrição</target>       </trans-unit>
        <trans-unit id="1586" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U8_Un">
          <source>89</source>
          <target state="translated">89</target>       </trans-unit>
        <trans-unit id="1587" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U8_Un">
          <source>conv.ovf.u8.un</source>
          <target state="translated">conv.ovf.u8.un</target>       </trans-unit>
        <trans-unit id="1588" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U8_Un">
          <source>Converts an unsigned value to an <ph id="ph1">`unsigned int64`</ph> (on the stack as <ph id="ph2">`int64`</ph>) and throw an exception on overflow.</source>
          <target state="translated">Converte um valor sem sinal em um <ph id="ph1">`unsigned int64`</ph> (na pilha como <ph id="ph2">`int64`</ph>) e gerará uma exceção no estouro.</target>       </trans-unit>
        <trans-unit id="1589" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U8_Un">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">O comportamento de transição de pilha, em ordem sequencial, é:</target>       </trans-unit>
        <trans-unit id="1590" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U8_Un">
          <source><ph id="ph1">`value`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value`</ph> é inserido na pilha.</target>       </trans-unit>
        <trans-unit id="1591" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U8_Un">
          <source><ph id="ph1">`value`</ph> is popped from the stack and the conversion operation is attempted.</source>
          <target state="translated"><ph id="ph1">`value`</ph> é exibido na pilha e a conversão de tentativa de operação.</target>       </trans-unit>
        <trans-unit id="1592" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U8_Un">
          <source>If overflow occurs, an exception is thrown.</source>
          <target state="translated">Se ocorrer estouro, uma exceção será lançada.</target>       </trans-unit>
        <trans-unit id="1593" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U8_Un">
          <source>If the conversion is successful, the resulting value is pushed onto the stack.</source>
          <target state="translated">Se a conversão for bem-sucedida, o valor resultante é inserido na pilha.</target>       </trans-unit>
        <trans-unit id="1594" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U8_Un">
          <source>The <ph id="ph1">`conv.ovf.u8.un`</ph> opcode converts the <ph id="ph2">`value`</ph> on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack.</source>
          <target state="translated">O <ph id="ph1">`conv.ovf.u8.un`</ph> opcode converte o <ph id="ph2">`value`</ph> na parte superior da pilha para o tipo especificado no opcode e coloca convertidos valor na parte superior da pilha.</target>       </trans-unit>
        <trans-unit id="1595" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U8_Un">
          <source>If the value is too large or too small to be represented by the target type, an exception is thrown.</source>
          <target state="translated">Se o valor for muito grande ou muito pequeno para ser representado pelo tipo de destino, uma exceção será lançada.</target>       </trans-unit>
        <trans-unit id="1596" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U8_Un">
          <source>Conversions from floating-point numbers to integer values truncate the number toward zero.</source>
          <target state="translated">Conversões de números de ponto flutuante para valores inteiros truncam o número em direção a zero.</target>       </trans-unit>
        <trans-unit id="1597" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U8_Un">
          <source>Note that integer values of less than 4 bytes are extended to <ph id="ph1">`int32`</ph> when they are loaded onto the evaluation stack (unless <ph id="ph2">`conv.ovf.i`</ph> or <ph id="ph3">`conv.ovf.u`</ph> are used, in which case the result is also <ph id="ph4">`native int`</ph>).</source>
          <target state="translated">Observe que os valores inteiros de menos de 4 bytes são estendidos para <ph id="ph1">`int32`</ph> quando eles são carregados para a pilha de avaliação (a menos que <ph id="ph2">`conv.ovf.i`</ph> ou <ph id="ph3">`conv.ovf.u`</ph> forem usados, caso em que o resultado é também <ph id="ph4">`native int`</ph>).</target>       </trans-unit>
        <trans-unit id="1598" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U8_Un">
          <source><ph id="ph1">&lt;xref:System.OverflowException&gt;</ph> is thrown if the result can not be represented in the result type.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.OverflowException&gt;</ph> é gerada se o resultado não pode ser representado no tipo de resultado.</target>       </trans-unit>
        <trans-unit id="1599" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U8_Un">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`conv.ovf.u8.un`</ph> opcode:</source>
          <target state="translated">O seguinte <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> sobrecarga de método pode usar o <ph id="ph2">`conv.ovf.u8.un`</ph> opcode:</target>       </trans-unit>
        <trans-unit id="1600" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U8_Un">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="1601" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Conv_R_Un">
          <source>Converts the unsigned integer value on top of the evaluation stack to <ph id="ph1">&lt;see langword="float32" /&gt;</ph>.</source>
          <target state="translated">Converte o valor de inteiro sem sinal na parte superior da pilha de avaliação em <ph id="ph1">&lt;see langword="float32" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1602" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_R_Un">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">A tabela a seguir lista as instruções hexadecimal e formato de assembly do Microsoft Intermediate Language (MSIL), junto com um resumo breve de referência:</target>       </trans-unit>
        <trans-unit id="1603" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_R_Un">
          <source>Format</source>
          <target state="translated">Formatar</target>       </trans-unit>
        <trans-unit id="1604" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_R_Un">
          <source>Assembly Format</source>
          <target state="translated">Formato de assembly</target>       </trans-unit>
        <trans-unit id="1605" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_R_Un">
          <source>Description</source>
          <target state="translated">Descrição</target>       </trans-unit>
        <trans-unit id="1606" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_R_Un">
          <source>76</source>
          <target state="translated">76</target>       </trans-unit>
        <trans-unit id="1607" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_R_Un">
          <source>conv.r.un</source>
          <target state="translated">conv.r.un</target>       </trans-unit>
        <trans-unit id="1608" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_R_Un">
          <source>Convert unsigned integer to floating-point, pushing <ph id="ph1">`F`</ph> on stack.</source>
          <target state="translated">Converter inteiro sem sinal de ponto flutuante, enviar por push <ph id="ph1">`F`</ph> na pilha.</target>       </trans-unit>
        <trans-unit id="1609" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_R_Un">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">O comportamento de transição de pilha, em ordem sequencial, é:</target>       </trans-unit>
        <trans-unit id="1610" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_R_Un">
          <source><ph id="ph1">`value`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value`</ph> é inserido na pilha.</target>       </trans-unit>
        <trans-unit id="1611" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_R_Un">
          <source><ph id="ph1">`value`</ph> is popped from the stack and the conversion operation is attempted.</source>
          <target state="translated"><ph id="ph1">`value`</ph> é exibido na pilha e a conversão de tentativa de operação.</target>       </trans-unit>
        <trans-unit id="1612" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_R_Un">
          <source>If the conversion is successful, the resulting value is pushed onto the stack.</source>
          <target state="translated">Se a conversão for bem-sucedida, o valor resultante é inserido na pilha.</target>       </trans-unit>
        <trans-unit id="1613" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_R_Un">
          <source>The <ph id="ph1">`conv.r.un`</ph> opcode converts the <ph id="ph2">`value`</ph> on top of the stack to the type specified in the opcode, and leave that converted value on the top of the stack.</source>
          <target state="translated">O <ph id="ph1">`conv.r.un`</ph> opcode converte o <ph id="ph2">`value`</ph> na parte superior da pilha para o tipo especificado no opcode e deixe que converter o valor no topo da pilha.</target>       </trans-unit>
        <trans-unit id="1614" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_R_Un">
          <source>Integer values of less than 4 bytes are extended to <ph id="ph1">`int32`</ph> when they are loaded onto the evaluation stack (unless <ph id="ph2">`conv.i`</ph> or <ph id="ph3">`conv.u`</ph> is used, in which case the result is also <ph id="ph4">`native int`</ph>).</source>
          <target state="translated">Valores de inteiro de menos de 4 bytes são estendidos para <ph id="ph1">`int32`</ph> quando eles são carregados para a pilha de avaliação (a menos que <ph id="ph2">`conv.i`</ph> ou <ph id="ph3">`conv.u`</ph> for usado, caso em que o resultado é também <ph id="ph4">`native int`</ph>).</target>       </trans-unit>
        <trans-unit id="1615" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_R_Un">
          <source>Floating-point values are converted to the <ph id="ph1">`F`</ph> type.</source>
          <target state="translated">Valores de ponto flutuante são convertidos para o <ph id="ph1">`F`</ph> tipo.</target>       </trans-unit>
        <trans-unit id="1616" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_R_Un">
          <source>Conversion from floating-point numbers to integer values truncates the number toward zero.</source>
          <target state="translated">A conversão de números de ponto flutuante em valores inteiros trunca o número em direção a zero.</target>       </trans-unit>
        <trans-unit id="1617" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_R_Un">
          <source>When converting from a <ph id="ph1">`float64`</ph> to a <ph id="ph2">`float32`</ph>, precision can be lost.</source>
          <target state="translated">Ao converter de um <ph id="ph1">`float64`</ph> para um <ph id="ph2">`float32`</ph>, precisão pode ser perdida.</target>       </trans-unit>
        <trans-unit id="1618" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_R_Un">
          <source>If <ph id="ph1">`value`</ph> is too large to fit in a <ph id="ph2">`float32 (F)`</ph>, positive infinity (if <ph id="ph3">`value`</ph> is positive) or negative infinity (if <ph id="ph4">`value`</ph> is negative) is returned.</source>
          <target state="translated">Se <ph id="ph1">`value`</ph> é muito grande para caber em uma <ph id="ph2">`float32 (F)`</ph>, infinito positivo (se <ph id="ph3">`value`</ph> for positivo) ou negativo infinito (se <ph id="ph4">`value`</ph> for negativo) será retornado.</target>       </trans-unit>
        <trans-unit id="1619" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_R_Un">
          <source>If overflow occurs converting one integer type to another, the high order bits are truncated.</source>
          <target state="translated">Se estouro ocorre conversão de tipo de um inteiro para outro, os bits de ordem mais alta serão truncados.</target>       </trans-unit>
        <trans-unit id="1620" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_R_Un">
          <source>If the result is smaller than an <ph id="ph1">`int32`</ph>, the value is sign-extended to fill the slot.</source>
          <target state="translated">Se o resultado for menor do que um <ph id="ph1">`int32`</ph>, o valor é de assinatura estendida para preencher o slot.</target>       </trans-unit>
        <trans-unit id="1621" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_R_Un">
          <source>If overflow occurs converting a floating-point type to an integer the <ph id="ph1">`result`</ph> returned is unspecified.</source>
          <target state="translated">Se ocorrer estouro de converter um tipo de ponto flutuante para um inteiro de <ph id="ph1">`result`</ph> retornado é especificado.</target>       </trans-unit>
        <trans-unit id="1622" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_R_Un">
          <source>The <ph id="ph1">`conv.r.un`</ph> operation takes an integer off the stack, interprets it as unsigned, and replaces it with a floating-point number to represent the integer: either a <ph id="ph2">`float32`</ph>, if this is wide enough to represent the integer without loss of precision, or else a <ph id="ph3">`float64`</ph>.</source>
          <target state="translated">O <ph id="ph1">`conv.r.un`</ph> operação assume um número inteiro na pilha, interpreta como não assinado e o substitui por um número de ponto flutuante para representar o número inteiro: ou um <ph id="ph2">`float32`</ph>, se isso for grande o suficiente para representar o inteiro sem perda de precisão, ou então um <ph id="ph3">`float64`</ph>.</target>       </trans-unit>
        <trans-unit id="1623" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_R_Un">
          <source>No exceptions are ever thrown when using this field.</source>
          <target state="translated">Nenhuma exceção nunca é geradas quando o uso desse campo.</target>       </trans-unit>
        <trans-unit id="1624" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_R_Un">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`conv.r.un`</ph> opcode:</source>
          <target state="translated">O seguinte <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> sobrecarga de método pode usar o <ph id="ph2">`conv.r.un`</ph> opcode:</target>       </trans-unit>
        <trans-unit id="1625" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_R_Un">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="1626" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Conv_R4">
          <source>Converts the value on top of the evaluation stack to <ph id="ph1">&lt;see langword="float32" /&gt;</ph>.</source>
          <target state="translated">Converte o valor na parte superior da pilha de avaliação em <ph id="ph1">&lt;see langword="float32" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1627" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_R4">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">A tabela a seguir lista as instruções hexadecimal e formato de assembly do Microsoft Intermediate Language (MSIL), junto com um resumo breve de referência:</target>       </trans-unit>
        <trans-unit id="1628" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_R4">
          <source>Format</source>
          <target state="translated">Formatar</target>       </trans-unit>
        <trans-unit id="1629" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_R4">
          <source>Assembly Format</source>
          <target state="translated">Formato de assembly</target>       </trans-unit>
        <trans-unit id="1630" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_R4">
          <source>Description</source>
          <target state="translated">Descrição</target>       </trans-unit>
        <trans-unit id="1631" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_R4">
          <source>6B</source>
          <target state="translated">6B</target>       </trans-unit>
        <trans-unit id="1632" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_R4">
          <source>conv.r4</source>
          <target state="translated">conv.r4</target>       </trans-unit>
        <trans-unit id="1633" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_R4">
          <source>Convert to <ph id="ph1">`float32`</ph>, pushing <ph id="ph2">`F`</ph> on stack.</source>
          <target state="translated">Converter em <ph id="ph1">`float32`</ph>, envio <ph id="ph2">`F`</ph> na pilha.</target>       </trans-unit>
        <trans-unit id="1634" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_R4">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">O comportamento de transição de pilha, em ordem sequencial, é:</target>       </trans-unit>
        <trans-unit id="1635" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_R4">
          <source><ph id="ph1">`value`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value`</ph> é inserido na pilha.</target>       </trans-unit>
        <trans-unit id="1636" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_R4">
          <source><ph id="ph1">`value`</ph> is popped from the stack and the conversion operation is attempted.</source>
          <target state="translated"><ph id="ph1">`value`</ph> é exibido na pilha e a conversão de tentativa de operação.</target>       </trans-unit>
        <trans-unit id="1637" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_R4">
          <source>If the conversion is successful, the resulting value is pushed onto the stack.</source>
          <target state="translated">Se a conversão for bem-sucedida, o valor resultante é inserido na pilha.</target>       </trans-unit>
        <trans-unit id="1638" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_R4">
          <source>The <ph id="ph1">`conv.r4`</ph> opcode converts the <ph id="ph2">`value`</ph> on top of the stack to the type specified in the opcode, and leave that converted value on the top of the stack.</source>
          <target state="translated">O <ph id="ph1">`conv.r4`</ph> opcode converte o <ph id="ph2">`value`</ph> na parte superior da pilha para o tipo especificado no opcode e deixe que converter o valor no topo da pilha.</target>       </trans-unit>
        <trans-unit id="1639" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_R4">
          <source>Integer values of less than 4 bytes are extended to <ph id="ph1">`int32`</ph> when they are loaded onto the evaluation stack (unless <ph id="ph2">`conv.i`</ph> or <ph id="ph3">`conv.u`</ph> is used, in which case the result is also <ph id="ph4">`native int`</ph>).</source>
          <target state="translated">Valores de inteiro de menos de 4 bytes são estendidos para <ph id="ph1">`int32`</ph> quando eles são carregados para a pilha de avaliação (a menos que <ph id="ph2">`conv.i`</ph> ou <ph id="ph3">`conv.u`</ph> for usado, caso em que o resultado é também <ph id="ph4">`native int`</ph>).</target>       </trans-unit>
        <trans-unit id="1640" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_R4">
          <source>Floating-point values are converted to the <ph id="ph1">`F`</ph> type.</source>
          <target state="translated">Valores de ponto flutuante são convertidos para o <ph id="ph1">`F`</ph> tipo.</target>       </trans-unit>
        <trans-unit id="1641" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_R4">
          <source>Conversion from floating-point numbers to integer values truncates the number toward zero.</source>
          <target state="translated">A conversão de números de ponto flutuante em valores inteiros trunca o número em direção a zero.</target>       </trans-unit>
        <trans-unit id="1642" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_R4">
          <source>When converting from an <ph id="ph1">`float64`</ph> to an <ph id="ph2">`float32`</ph>, precision can be lost.</source>
          <target state="translated">Ao converter de um <ph id="ph1">`float64`</ph> para um <ph id="ph2">`float32`</ph>, precisão pode ser perdida.</target>       </trans-unit>
        <trans-unit id="1643" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_R4">
          <source>If <ph id="ph1">`value`</ph> is too large to fit in a <ph id="ph2">`float32 (F)`</ph>, positive infinity (if <ph id="ph3">`value`</ph> is positive) or negative infinity (if <ph id="ph4">`value`</ph> is negative) is returned.</source>
          <target state="translated">Se <ph id="ph1">`value`</ph> é muito grande para caber em uma <ph id="ph2">`float32 (F)`</ph>, infinito positivo (se <ph id="ph3">`value`</ph> for positivo) ou negativo infinito (se <ph id="ph4">`value`</ph> for negativo) será retornado.</target>       </trans-unit>
        <trans-unit id="1644" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_R4">
          <source>If overflow occurs converting one integer type to another, the high order bits are truncated.</source>
          <target state="translated">Se estouro ocorre conversão de tipo de um inteiro para outro, os bits de ordem mais alta serão truncados.</target>       </trans-unit>
        <trans-unit id="1645" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_R4">
          <source>If the result is smaller than an <ph id="ph1">`int32`</ph>, the value is sign-extended to fill the slot.</source>
          <target state="translated">Se o resultado for menor do que um <ph id="ph1">`int32`</ph>, o valor é de assinatura estendida para preencher o slot.</target>       </trans-unit>
        <trans-unit id="1646" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_R4">
          <source>If overflow occurs converting a floating-point type to an integer the value returned is unspecified.</source>
          <target state="translated">Se ocorrer estouro de converter um tipo de ponto flutuante para um inteiro, o valor retornado é especificada.</target>       </trans-unit>
        <trans-unit id="1647" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_R4">
          <source>No exceptions are ever thrown when using this field.</source>
          <target state="translated">Nenhuma exceção nunca é geradas quando o uso desse campo.</target>       </trans-unit>
        <trans-unit id="1648" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_R4">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`conv.r4`</ph> opcode:</source>
          <target state="translated">O seguinte <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> sobrecarga de método pode usar o <ph id="ph2">`conv.r4`</ph> opcode:</target>       </trans-unit>
        <trans-unit id="1649" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_R4">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="1650" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Conv_R8">
          <source>Converts the value on top of the evaluation stack to <ph id="ph1">&lt;see langword="float64" /&gt;</ph>.</source>
          <target state="translated">Converte o valor na parte superior da pilha de avaliação em <ph id="ph1">&lt;see langword="float64" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1651" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_R8">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">A tabela a seguir lista as instruções hexadecimal e formato de assembly do Microsoft Intermediate Language (MSIL), junto com um resumo breve de referência:</target>       </trans-unit>
        <trans-unit id="1652" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_R8">
          <source>Format</source>
          <target state="translated">Formatar</target>       </trans-unit>
        <trans-unit id="1653" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_R8">
          <source>Assembly Format</source>
          <target state="translated">Formato de assembly</target>       </trans-unit>
        <trans-unit id="1654" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_R8">
          <source>Description</source>
          <target state="translated">Descrição</target>       </trans-unit>
        <trans-unit id="1655" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_R8">
          <source>6C</source>
          <target state="translated">6C</target>       </trans-unit>
        <trans-unit id="1656" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_R8">
          <source>conv.r8</source>
          <target state="translated">conv.r8</target>       </trans-unit>
        <trans-unit id="1657" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_R8">
          <source>Convert to <ph id="ph1">`float64`</ph>, pushing <ph id="ph2">`F`</ph> on stack.</source>
          <target state="translated">Converter em <ph id="ph1">`float64`</ph>, envio <ph id="ph2">`F`</ph> na pilha.</target>       </trans-unit>
        <trans-unit id="1658" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_R8">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">O comportamento de transição de pilha, em ordem sequencial, é:</target>       </trans-unit>
        <trans-unit id="1659" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_R8">
          <source><ph id="ph1">`value`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value`</ph> é inserido na pilha.</target>       </trans-unit>
        <trans-unit id="1660" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_R8">
          <source><ph id="ph1">`value`</ph> is popped from the stack and the conversion operation is attempted.</source>
          <target state="translated"><ph id="ph1">`value`</ph> é exibido na pilha e a conversão de tentativa de operação.</target>       </trans-unit>
        <trans-unit id="1661" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_R8">
          <source>If the conversion is successful, the resulting value is pushed onto the stack.</source>
          <target state="translated">Se a conversão for bem-sucedida, o valor resultante é inserido na pilha.</target>       </trans-unit>
        <trans-unit id="1662" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_R8">
          <source>The <ph id="ph1">`conv.r8`</ph> opcode converts the <ph id="ph2">`value`</ph> on top of the stack to the type specified in the opcode, and leave that converted value on the top of the stack.</source>
          <target state="translated">O <ph id="ph1">`conv.r8`</ph> opcode converte o <ph id="ph2">`value`</ph> na parte superior da pilha para o tipo especificado no opcode e deixe que converter o valor no topo da pilha.</target>       </trans-unit>
        <trans-unit id="1663" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_R8">
          <source>Integer values of less than 4 bytes are extended to <ph id="ph1">`int32`</ph> when they are loaded onto the evaluation stack (unless <ph id="ph2">`conv.i`</ph> or <ph id="ph3">`conv.u`</ph> is used, in which case the result is also <ph id="ph4">`native int`</ph>).</source>
          <target state="translated">Valores de inteiro de menos de 4 bytes são estendidos para <ph id="ph1">`int32`</ph> quando eles são carregados para a pilha de avaliação (a menos que <ph id="ph2">`conv.i`</ph> ou <ph id="ph3">`conv.u`</ph> for usado, caso em que o resultado é também <ph id="ph4">`native int`</ph>).</target>       </trans-unit>
        <trans-unit id="1664" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_R8">
          <source>Floating-point values are converted to the <ph id="ph1">`F`</ph> type.</source>
          <target state="translated">Valores de ponto flutuante são convertidos para o <ph id="ph1">`F`</ph> tipo.</target>       </trans-unit>
        <trans-unit id="1665" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_R8">
          <source>Conversion from floating-point numbers to integer values truncates the number toward zero.</source>
          <target state="translated">A conversão de números de ponto flutuante em valores inteiros trunca o número em direção a zero.</target>       </trans-unit>
        <trans-unit id="1666" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_R8">
          <source>When converting from an <ph id="ph1">`float64`</ph> to an <ph id="ph2">`float32`</ph>, precision can be lost.</source>
          <target state="translated">Ao converter de um <ph id="ph1">`float64`</ph> para um <ph id="ph2">`float32`</ph>, precisão pode ser perdida.</target>       </trans-unit>
        <trans-unit id="1667" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_R8">
          <source>If <ph id="ph1">`value`</ph> is too large to fit in a <ph id="ph2">`float32 (F)`</ph>, positive infinity (if <ph id="ph3">`value`</ph> is positive) or negative infinity (if <ph id="ph4">`value`</ph> is negative) is returned.</source>
          <target state="translated">Se <ph id="ph1">`value`</ph> é muito grande para caber em uma <ph id="ph2">`float32 (F)`</ph>, infinito positivo (se <ph id="ph3">`value`</ph> for positivo) ou negativo infinito (se <ph id="ph4">`value`</ph> for negativo) será retornado.</target>       </trans-unit>
        <trans-unit id="1668" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_R8">
          <source>If overflow occurs converting one integer type to another, the high order bits are truncated.</source>
          <target state="translated">Se estouro ocorre conversão de tipo de um inteiro para outro, os bits de ordem mais alta serão truncados.</target>       </trans-unit>
        <trans-unit id="1669" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_R8">
          <source>If the result is smaller than an <ph id="ph1">`int32`</ph>, the value is sign-extended to fill the slot.</source>
          <target state="translated">Se o resultado for menor do que um <ph id="ph1">`int32`</ph>, o valor é de assinatura estendida para preencher o slot.</target>       </trans-unit>
        <trans-unit id="1670" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_R8">
          <source>If overflow occurs converting a floating-point type to an integer the value returned is unspecified.</source>
          <target state="translated">Se ocorrer estouro de converter um tipo de ponto flutuante para um inteiro, o valor retornado é especificada.</target>       </trans-unit>
        <trans-unit id="1671" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_R8">
          <source>No exceptions are ever thrown when using this field.</source>
          <target state="translated">Nenhuma exceção nunca é geradas quando o uso desse campo.</target>       </trans-unit>
        <trans-unit id="1672" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_R8">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`conv.r8`</ph> opcode:</source>
          <target state="translated">O seguinte <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> sobrecarga de método pode usar o <ph id="ph2">`conv.r8`</ph> opcode:</target>       </trans-unit>
        <trans-unit id="1673" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_R8">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="1674" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Conv_U">
          <source>Converts the value on top of the evaluation stack to <ph id="ph1">&lt;see langword="unsigned native int" /&gt;</ph>, and extends it to <ph id="ph2">&lt;see langword="native int" /&gt;</ph>.</source>
          <target state="translated">Converte o valor na parte superior da pilha de avaliação em <ph id="ph1">&lt;see langword="unsigned native int" /&gt;</ph> e estende-o para <ph id="ph2">&lt;see langword="native int" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1675" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">A tabela a seguir lista as instruções hexadecimal e formato de assembly do Microsoft Intermediate Language (MSIL), junto com um resumo breve de referência:</target>       </trans-unit>
        <trans-unit id="1676" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U">
          <source>Format</source>
          <target state="translated">Formatar</target>       </trans-unit>
        <trans-unit id="1677" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U">
          <source>Assembly Format</source>
          <target state="translated">Formato de assembly</target>       </trans-unit>
        <trans-unit id="1678" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U">
          <source>Description</source>
          <target state="translated">Descrição</target>       </trans-unit>
        <trans-unit id="1679" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U">
          <source>E0</source>
          <target state="translated">E0</target>       </trans-unit>
        <trans-unit id="1680" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U">
          <source>conv.u</source>
          <target state="translated">conv.u</target>       </trans-unit>
        <trans-unit id="1681" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U">
          <source>Convert to <ph id="ph1">`unsigned native int`</ph>, pushing <ph id="ph2">`native int`</ph> on stack.</source>
          <target state="translated">Converter em <ph id="ph1">`unsigned native int`</ph>, envio <ph id="ph2">`native int`</ph> na pilha.</target>       </trans-unit>
        <trans-unit id="1682" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">O comportamento de transição de pilha, em ordem sequencial, é:</target>       </trans-unit>
        <trans-unit id="1683" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U">
          <source><ph id="ph1">`value`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value`</ph> é inserido na pilha.</target>       </trans-unit>
        <trans-unit id="1684" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U">
          <source><ph id="ph1">`value`</ph> is popped from the stack and the conversion operation is attempted.</source>
          <target state="translated"><ph id="ph1">`value`</ph> é exibido na pilha e a conversão de tentativa de operação.</target>       </trans-unit>
        <trans-unit id="1685" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U">
          <source>If the conversion is successful, the resulting value is pushed onto the stack.</source>
          <target state="translated">Se a conversão for bem-sucedida, o valor resultante é inserido na pilha.</target>       </trans-unit>
        <trans-unit id="1686" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U">
          <source>The <ph id="ph1">`conv.u`</ph> opcode converts the <ph id="ph2">`value`</ph> on top of the stack to the type specified in the opcode, and leave that converted value on the top of the stack.</source>
          <target state="translated">O <ph id="ph1">`conv.u`</ph> opcode converte o <ph id="ph2">`value`</ph> na parte superior da pilha para o tipo especificado no opcode e deixe que converter o valor no topo da pilha.</target>       </trans-unit>
        <trans-unit id="1687" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U">
          <source>Integer values of less than 4 bytes are extended to <ph id="ph1">`int32`</ph> when they are loaded onto the evaluation stack (unless <ph id="ph2">`conv.i`</ph> or <ph id="ph3">`conv.u`</ph> is used, in which case the result is also <ph id="ph4">`native int`</ph>).</source>
          <target state="translated">Valores de inteiro de menos de 4 bytes são estendidos para <ph id="ph1">`int32`</ph> quando eles são carregados para a pilha de avaliação (a menos que <ph id="ph2">`conv.i`</ph> ou <ph id="ph3">`conv.u`</ph> for usado, caso em que o resultado é também <ph id="ph4">`native int`</ph>).</target>       </trans-unit>
        <trans-unit id="1688" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U">
          <source>Floating-point values are converted to the <ph id="ph1">`F`</ph> type.</source>
          <target state="translated">Valores de ponto flutuante são convertidos para o <ph id="ph1">`F`</ph> tipo.</target>       </trans-unit>
        <trans-unit id="1689" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U">
          <source>Conversion from floating-point numbers to integer values truncates the number toward zero.</source>
          <target state="translated">A conversão de números de ponto flutuante em valores inteiros trunca o número em direção a zero.</target>       </trans-unit>
        <trans-unit id="1690" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U">
          <source>When converting from an <ph id="ph1">`float64`</ph> to an <ph id="ph2">`float32`</ph>, precision can be lost.</source>
          <target state="translated">Ao converter de um <ph id="ph1">`float64`</ph> para um <ph id="ph2">`float32`</ph>, precisão pode ser perdida.</target>       </trans-unit>
        <trans-unit id="1691" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U">
          <source>If <ph id="ph1">`value`</ph> is too large to fit in a <ph id="ph2">`float32 (F)`</ph>, positive infinity (if <ph id="ph3">`value`</ph> is positive) or negative infinity (if <ph id="ph4">`value`</ph> is negative) is returned.</source>
          <target state="translated">Se <ph id="ph1">`value`</ph> é muito grande para caber em uma <ph id="ph2">`float32 (F)`</ph>, infinito positivo (se <ph id="ph3">`value`</ph> for positivo) ou negativo infinito (se <ph id="ph4">`value`</ph> for negativo) será retornado.</target>       </trans-unit>
        <trans-unit id="1692" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U">
          <source>If overflow occurs converting one integer type to another, the high order bits are truncated.</source>
          <target state="translated">Se estouro ocorre conversão de tipo de um inteiro para outro, os bits de ordem mais alta serão truncados.</target>       </trans-unit>
        <trans-unit id="1693" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U">
          <source>If the result is smaller than an <ph id="ph1">`int32`</ph>, the value is sign-extended to fill the slot.</source>
          <target state="translated">Se o resultado for menor do que um <ph id="ph1">`int32`</ph>, o valor é de assinatura estendida para preencher o slot.</target>       </trans-unit>
        <trans-unit id="1694" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U">
          <source>If overflow occurs converting a floating-point type to an integer the value returned is unspecified.</source>
          <target state="translated">Se ocorrer estouro de converter um tipo de ponto flutuante para um inteiro, o valor retornado é especificada.</target>       </trans-unit>
        <trans-unit id="1695" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U">
          <source>No exceptions are ever thrown when using this field.</source>
          <target state="translated">Nenhuma exceção nunca é geradas quando o uso desse campo.</target>       </trans-unit>
        <trans-unit id="1696" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U">
          <source>See <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I&gt;</ph> and <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I_Un&gt;</ph> for equivalent instructions that will throw an exception when the result type can not properly represent the result value.</source>
          <target state="translated">Consulte <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I&gt;</ph> e <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I_Un&gt;</ph> para obter instruções equivalentes que lançará uma exceção quando o tipo de resultado pode não representar corretamente o valor do resultado.</target>       </trans-unit>
        <trans-unit id="1697" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`conv.u`</ph> opcode:</source>
          <target state="translated">O seguinte <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> sobrecarga de método pode usar o <ph id="ph2">`conv.u`</ph> opcode:</target>       </trans-unit>
        <trans-unit id="1698" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="1699" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Conv_U1">
          <source>Converts the value on top of the evaluation stack to <ph id="ph1">&lt;see langword="unsigned int8" /&gt;</ph>, and extends it to <ph id="ph2">&lt;see langword="int32" /&gt;</ph>.</source>
          <target state="translated">Converte o valor na parte superior da pilha de avaliação em <ph id="ph1">&lt;see langword="unsigned int8" /&gt;</ph> e estende-o para <ph id="ph2">&lt;see langword="int32" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1700" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U1">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">A tabela a seguir lista as instruções hexadecimal e formato de assembly do Microsoft Intermediate Language (MSIL), junto com um resumo breve de referência:</target>       </trans-unit>
        <trans-unit id="1701" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U1">
          <source>Format</source>
          <target state="translated">Formatar</target>       </trans-unit>
        <trans-unit id="1702" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U1">
          <source>Assembly Format</source>
          <target state="translated">Formato de assembly</target>       </trans-unit>
        <trans-unit id="1703" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U1">
          <source>Description</source>
          <target state="translated">Descrição</target>       </trans-unit>
        <trans-unit id="1704" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U1">
          <source>D2</source>
          <target state="translated">D2</target>       </trans-unit>
        <trans-unit id="1705" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U1">
          <source>conv.u1</source>
          <target state="translated">Conv.U1</target>       </trans-unit>
        <trans-unit id="1706" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U1">
          <source>Convert to <ph id="ph1">`int8`</ph>, pushing <ph id="ph2">`int32`</ph> on stack.</source>
          <target state="translated">Converter em <ph id="ph1">`int8`</ph>, envio <ph id="ph2">`int32`</ph> na pilha.</target>       </trans-unit>
        <trans-unit id="1707" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U1">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">O comportamento de transição de pilha, em ordem sequencial, é:</target>       </trans-unit>
        <trans-unit id="1708" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U1">
          <source><ph id="ph1">`value`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value`</ph> é inserido na pilha.</target>       </trans-unit>
        <trans-unit id="1709" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U1">
          <source><ph id="ph1">`value`</ph> is popped from the stack and the conversion operation is attempted.</source>
          <target state="translated"><ph id="ph1">`value`</ph> é exibido na pilha e a conversão de tentativa de operação.</target>       </trans-unit>
        <trans-unit id="1710" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U1">
          <source>If the conversion is successful, the resulting value is pushed onto the stack.</source>
          <target state="translated">Se a conversão for bem-sucedida, o valor resultante é inserido na pilha.</target>       </trans-unit>
        <trans-unit id="1711" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U1">
          <source>The <ph id="ph1">`conv.u1`</ph> opcode converts the <ph id="ph2">`value`</ph> on top of the stack to the type specified in the opcode, and leave that converted value on the top of the stack.</source>
          <target state="translated">O <ph id="ph1">`conv.u1`</ph> opcode converte o <ph id="ph2">`value`</ph> na parte superior da pilha para o tipo especificado no opcode e deixe que converter o valor no topo da pilha.</target>       </trans-unit>
        <trans-unit id="1712" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U1">
          <source>Integer values of less than 4 bytes are extended to <ph id="ph1">`int32`</ph> when they are loaded onto the evaluation stack (unless <ph id="ph2">`conv.i`</ph> or <ph id="ph3">`conv.u`</ph> is used, in which case the result is also <ph id="ph4">`native int`</ph>).</source>
          <target state="translated">Valores de inteiro de menos de 4 bytes são estendidos para <ph id="ph1">`int32`</ph> quando eles são carregados para a pilha de avaliação (a menos que <ph id="ph2">`conv.i`</ph> ou <ph id="ph3">`conv.u`</ph> for usado, caso em que o resultado é também <ph id="ph4">`native int`</ph>).</target>       </trans-unit>
        <trans-unit id="1713" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U1">
          <source>Floating-point values are converted to the <ph id="ph1">`F`</ph> type.</source>
          <target state="translated">Valores de ponto flutuante são convertidos para o <ph id="ph1">`F`</ph> tipo.</target>       </trans-unit>
        <trans-unit id="1714" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U1">
          <source>Conversion from floating-point numbers to integer values truncates the number toward zero.</source>
          <target state="translated">A conversão de números de ponto flutuante em valores inteiros trunca o número em direção a zero.</target>       </trans-unit>
        <trans-unit id="1715" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U1">
          <source>When converting from an <ph id="ph1">`float64`</ph> to an <ph id="ph2">`float32`</ph>, precision can be lost.</source>
          <target state="translated">Ao converter de um <ph id="ph1">`float64`</ph> para um <ph id="ph2">`float32`</ph>, precisão pode ser perdida.</target>       </trans-unit>
        <trans-unit id="1716" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U1">
          <source>If <ph id="ph1">`value`</ph> is too large to fit in a <ph id="ph2">`float32 (F)`</ph>, positive infinity (if <ph id="ph3">`value`</ph> is positive) or negative infinity (if <ph id="ph4">`value`</ph> is negative) is returned.</source>
          <target state="translated">Se <ph id="ph1">`value`</ph> é muito grande para caber em uma <ph id="ph2">`float32 (F)`</ph>, infinito positivo (se <ph id="ph3">`value`</ph> for positivo) ou negativo infinito (se <ph id="ph4">`value`</ph> for negativo) será retornado.</target>       </trans-unit>
        <trans-unit id="1717" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U1">
          <source>If overflow occurs converting one integer type to another, the high order bits are truncated.</source>
          <target state="translated">Se estouro ocorre conversão de tipo de um inteiro para outro, os bits de ordem mais alta serão truncados.</target>       </trans-unit>
        <trans-unit id="1718" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U1">
          <source>If the result is smaller than an <ph id="ph1">`int32`</ph>, the value is sign-extended to fill the slot.</source>
          <target state="translated">Se o resultado for menor do que um <ph id="ph1">`int32`</ph>, o valor é de assinatura estendida para preencher o slot.</target>       </trans-unit>
        <trans-unit id="1719" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U1">
          <source>If overflow occurs converting a floating-point type to an integer the value returned is unspecified.</source>
          <target state="translated">Se ocorrer estouro de converter um tipo de ponto flutuante para um inteiro, o valor retornado é especificada.</target>       </trans-unit>
        <trans-unit id="1720" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U1">
          <source>No exceptions are ever thrown when using this field.</source>
          <target state="translated">Nenhuma exceção nunca é geradas quando o uso desse campo.</target>       </trans-unit>
        <trans-unit id="1721" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U1">
          <source>See <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I1&gt;</ph> and <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I1_Un&gt;</ph> for equivalent instructions that will throw an exception when the result type can not properly represent the result value.</source>
          <target state="translated">Consulte <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I1&gt;</ph> e <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I1_Un&gt;</ph> para obter instruções equivalentes que lançará uma exceção quando o tipo de resultado pode não representar corretamente o valor do resultado.</target>       </trans-unit>
        <trans-unit id="1722" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U1">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`conv.u1`</ph> opcode:</source>
          <target state="translated">O seguinte <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> sobrecarga de método pode usar o <ph id="ph2">`conv.u1`</ph> opcode:</target>       </trans-unit>
        <trans-unit id="1723" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U1">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="1724" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Conv_U2">
          <source>Converts the value on top of the evaluation stack to <ph id="ph1">&lt;see langword="unsigned int16" /&gt;</ph>, and extends it to <ph id="ph2">&lt;see langword="int32" /&gt;</ph>.</source>
          <target state="translated">Converte o valor na parte superior da pilha de avaliação em <ph id="ph1">&lt;see langword="unsigned int16" /&gt;</ph> e estende-o para <ph id="ph2">&lt;see langword="int32" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1725" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U2">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">A tabela a seguir lista as instruções hexadecimal e formato de assembly do Microsoft Intermediate Language (MSIL), junto com um resumo breve de referência:</target>       </trans-unit>
        <trans-unit id="1726" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U2">
          <source>Format</source>
          <target state="translated">Formatar</target>       </trans-unit>
        <trans-unit id="1727" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U2">
          <source>Assembly Format</source>
          <target state="translated">Formato de assembly</target>       </trans-unit>
        <trans-unit id="1728" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U2">
          <source>Description</source>
          <target state="translated">Descrição</target>       </trans-unit>
        <trans-unit id="1729" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U2">
          <source>D1</source>
          <target state="translated">D1</target>       </trans-unit>
        <trans-unit id="1730" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U2">
          <source>conv.u2</source>
          <target state="translated">conv.u2</target>       </trans-unit>
        <trans-unit id="1731" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U2">
          <source>Convert to <ph id="ph1">`int16`</ph>, pushing <ph id="ph2">`int32`</ph> on stack.</source>
          <target state="translated">Converter em <ph id="ph1">`int16`</ph>, envio <ph id="ph2">`int32`</ph> na pilha.</target>       </trans-unit>
        <trans-unit id="1732" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U2">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">O comportamento de transição de pilha, em ordem sequencial, é:</target>       </trans-unit>
        <trans-unit id="1733" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U2">
          <source><ph id="ph1">`value`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value`</ph> é inserido na pilha.</target>       </trans-unit>
        <trans-unit id="1734" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U2">
          <source><ph id="ph1">`value`</ph> is popped from the stack and the conversion operation is attempted.</source>
          <target state="translated"><ph id="ph1">`value`</ph> é exibido na pilha e a conversão de tentativa de operação.</target>       </trans-unit>
        <trans-unit id="1735" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U2">
          <source>If the conversion is successful, the resulting value is pushed onto the stack.</source>
          <target state="translated">Se a conversão for bem-sucedida, o valor resultante é inserido na pilha.</target>       </trans-unit>
        <trans-unit id="1736" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U2">
          <source>The <ph id="ph1">`conv.u2`</ph> opcode converts the <ph id="ph2">`value`</ph> on top of the stack to the type specified in the opcode, and leave that converted value on the top of the stack.</source>
          <target state="translated">O <ph id="ph1">`conv.u2`</ph> opcode converte o <ph id="ph2">`value`</ph> na parte superior da pilha para o tipo especificado no opcode e deixe que converter o valor no topo da pilha.</target>       </trans-unit>
        <trans-unit id="1737" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U2">
          <source>Integer values of less than 4 bytes are extended to <ph id="ph1">`int32`</ph> when they are loaded onto the evaluation stack (unless <ph id="ph2">`conv.i`</ph> or <ph id="ph3">`conv.u`</ph> is used, in which case the result is also <ph id="ph4">`native int`</ph>).</source>
          <target state="translated">Valores de inteiro de menos de 4 bytes são estendidos para <ph id="ph1">`int32`</ph> quando eles são carregados para a pilha de avaliação (a menos que <ph id="ph2">`conv.i`</ph> ou <ph id="ph3">`conv.u`</ph> for usado, caso em que o resultado é também <ph id="ph4">`native int`</ph>).</target>       </trans-unit>
        <trans-unit id="1738" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U2">
          <source>Floating-point values are converted to the <ph id="ph1">`F`</ph> type.</source>
          <target state="translated">Valores de ponto flutuante são convertidos para o <ph id="ph1">`F`</ph> tipo.</target>       </trans-unit>
        <trans-unit id="1739" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U2">
          <source>Conversion from floating-point numbers to integer values truncates the number toward zero.</source>
          <target state="translated">A conversão de números de ponto flutuante em valores inteiros trunca o número em direção a zero.</target>       </trans-unit>
        <trans-unit id="1740" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U2">
          <source>When converting from an <ph id="ph1">`float64`</ph> to an <ph id="ph2">`float32`</ph>, precision can be lost.</source>
          <target state="translated">Ao converter de um <ph id="ph1">`float64`</ph> para um <ph id="ph2">`float32`</ph>, precisão pode ser perdida.</target>       </trans-unit>
        <trans-unit id="1741" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U2">
          <source>If <ph id="ph1">`value`</ph> is too large to fit in a <ph id="ph2">`float32 (F)`</ph>, positive infinity (if <ph id="ph3">`value`</ph> is positive) or negative infinity (if <ph id="ph4">`value`</ph> is negative) is returned.</source>
          <target state="translated">Se <ph id="ph1">`value`</ph> é muito grande para caber em uma <ph id="ph2">`float32 (F)`</ph>, infinito positivo (se <ph id="ph3">`value`</ph> for positivo) ou negativo infinito (se <ph id="ph4">`value`</ph> for negativo) será retornado.</target>       </trans-unit>
        <trans-unit id="1742" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U2">
          <source>If overflow occurs converting one integer type to another, the high order bits are truncated.</source>
          <target state="translated">Se estouro ocorre conversão de tipo de um inteiro para outro, os bits de ordem mais alta serão truncados.</target>       </trans-unit>
        <trans-unit id="1743" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U2">
          <source>If the result is smaller than an <ph id="ph1">`int32`</ph>, the value is sign-extended to fill the slot.</source>
          <target state="translated">Se o resultado for menor do que um <ph id="ph1">`int32`</ph>, o valor é de assinatura estendida para preencher o slot.</target>       </trans-unit>
        <trans-unit id="1744" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U2">
          <source>If overflow occurs converting a floating-point type to an integer the value returned is unspecified.</source>
          <target state="translated">Se ocorrer estouro de converter um tipo de ponto flutuante para um inteiro, o valor retornado é especificada.</target>       </trans-unit>
        <trans-unit id="1745" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U2">
          <source>No exceptions are ever thrown when using this field.</source>
          <target state="translated">Nenhuma exceção nunca é geradas quando o uso desse campo.</target>       </trans-unit>
        <trans-unit id="1746" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U2">
          <source>See <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I2&gt;</ph> and <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I2_Un&gt;</ph> for equivalent instructions that will throw an exception when the result type can not properly represent the result value.</source>
          <target state="translated">Consulte <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I2&gt;</ph> e <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I2_Un&gt;</ph> para obter instruções equivalentes que lançará uma exceção quando o tipo de resultado pode não representar corretamente o valor do resultado.</target>       </trans-unit>
        <trans-unit id="1747" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U2">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`conv.u2`</ph> opcode:</source>
          <target state="translated">O seguinte <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> sobrecarga de método pode usar o <ph id="ph2">`conv.u2`</ph> opcode:</target>       </trans-unit>
        <trans-unit id="1748" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U2">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="1749" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Conv_U4">
          <source>Converts the value on top of the evaluation stack to <ph id="ph1">&lt;see langword="unsigned int32" /&gt;</ph>, and extends it to <ph id="ph2">&lt;see langword="int32" /&gt;</ph>.</source>
          <target state="translated">Converte o valor na parte superior da pilha de avaliação em <ph id="ph1">&lt;see langword="unsigned int32" /&gt;</ph> e estende-o para <ph id="ph2">&lt;see langword="int32" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1750" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U4">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">A tabela a seguir lista as instruções hexadecimal e formato de assembly do Microsoft Intermediate Language (MSIL), junto com um resumo breve de referência:</target>       </trans-unit>
        <trans-unit id="1751" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U4">
          <source>Format</source>
          <target state="translated">Formatar</target>       </trans-unit>
        <trans-unit id="1752" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U4">
          <source>Assembly Format</source>
          <target state="translated">Formato de assembly</target>       </trans-unit>
        <trans-unit id="1753" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U4">
          <source>Description</source>
          <target state="translated">Descrição</target>       </trans-unit>
        <trans-unit id="1754" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U4">
          <source>6D</source>
          <target state="translated">6D</target>       </trans-unit>
        <trans-unit id="1755" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U4">
          <source>conv.u4</source>
          <target state="translated">conv.u4</target>       </trans-unit>
        <trans-unit id="1756" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U4">
          <source>Convert to <ph id="ph1">`unsigned int32`</ph>, pushing <ph id="ph2">`int32`</ph> on stack.</source>
          <target state="translated">Converter em <ph id="ph1">`unsigned int32`</ph>, envio <ph id="ph2">`int32`</ph> na pilha.</target>       </trans-unit>
        <trans-unit id="1757" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U4">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">O comportamento de transição de pilha, em ordem sequencial, é:</target>       </trans-unit>
        <trans-unit id="1758" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U4">
          <source><ph id="ph1">`value`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value`</ph> é inserido na pilha.</target>       </trans-unit>
        <trans-unit id="1759" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U4">
          <source><ph id="ph1">`value`</ph> is popped from the stack and the conversion operation is attempted.</source>
          <target state="translated"><ph id="ph1">`value`</ph> é exibido na pilha e a conversão de tentativa de operação.</target>       </trans-unit>
        <trans-unit id="1760" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U4">
          <source>If the conversion is successful, the resulting value is pushed onto the stack.</source>
          <target state="translated">Se a conversão for bem-sucedida, o valor resultante é inserido na pilha.</target>       </trans-unit>
        <trans-unit id="1761" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U4">
          <source>The <ph id="ph1">`conv.u4`</ph> opcode converts the <ph id="ph2">`value`</ph> on top of the stack to the type specified in the opcode, and leave that converted value on the top of the stack.</source>
          <target state="translated">O <ph id="ph1">`conv.u4`</ph> opcode converte o <ph id="ph2">`value`</ph> na parte superior da pilha para o tipo especificado no opcode e deixe que converter o valor no topo da pilha.</target>       </trans-unit>
        <trans-unit id="1762" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U4">
          <source>Integer values of less than 4 bytes are extended to <ph id="ph1">`int32`</ph> when they are loaded onto the evaluation stack (unless <ph id="ph2">`conv.i`</ph> or <ph id="ph3">`conv.u`</ph> is used, in which case the result is also <ph id="ph4">`native int`</ph>).</source>
          <target state="translated">Valores de inteiro de menos de 4 bytes são estendidos para <ph id="ph1">`int32`</ph> quando eles são carregados para a pilha de avaliação (a menos que <ph id="ph2">`conv.i`</ph> ou <ph id="ph3">`conv.u`</ph> for usado, caso em que o resultado é também <ph id="ph4">`native int`</ph>).</target>       </trans-unit>
        <trans-unit id="1763" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U4">
          <source>Floating-point values are converted to the <ph id="ph1">`F`</ph> type.</source>
          <target state="translated">Valores de ponto flutuante são convertidos para o <ph id="ph1">`F`</ph> tipo.</target>       </trans-unit>
        <trans-unit id="1764" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U4">
          <source>Conversion from floating-point numbers to integer values truncates the number toward zero.</source>
          <target state="translated">A conversão de números de ponto flutuante em valores inteiros trunca o número em direção a zero.</target>       </trans-unit>
        <trans-unit id="1765" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U4">
          <source>When converting from an <ph id="ph1">`float64`</ph> to an <ph id="ph2">`float32`</ph>, precision can be lost.</source>
          <target state="translated">Ao converter de um <ph id="ph1">`float64`</ph> para um <ph id="ph2">`float32`</ph>, precisão pode ser perdida.</target>       </trans-unit>
        <trans-unit id="1766" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U4">
          <source>If <ph id="ph1">`value`</ph> is too large to fit in a <ph id="ph2">`float32 (F)`</ph>, positive infinity (if <ph id="ph3">`value`</ph> is positive) or negative infinity (if <ph id="ph4">`value`</ph> is negative) is returned.</source>
          <target state="translated">Se <ph id="ph1">`value`</ph> é muito grande para caber em uma <ph id="ph2">`float32 (F)`</ph>, infinito positivo (se <ph id="ph3">`value`</ph> for positivo) ou negativo infinito (se <ph id="ph4">`value`</ph> for negativo) será retornado.</target>       </trans-unit>
        <trans-unit id="1767" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U4">
          <source>If overflow occurs converting one integer type to another, the high order bits are truncated.</source>
          <target state="translated">Se estouro ocorre conversão de tipo de um inteiro para outro, os bits de ordem mais alta serão truncados.</target>       </trans-unit>
        <trans-unit id="1768" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U4">
          <source>If the result is smaller than an <ph id="ph1">`int32`</ph>, the value is sign-extended to fill the slot.</source>
          <target state="translated">Se o resultado for menor do que um <ph id="ph1">`int32`</ph>, o valor é de assinatura estendida para preencher o slot.</target>       </trans-unit>
        <trans-unit id="1769" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U4">
          <source>If overflow occurs converting a floating-point type to an integer the value returned is unspecified.</source>
          <target state="translated">Se ocorrer estouro de converter um tipo de ponto flutuante para um inteiro, o valor retornado é especificada.</target>       </trans-unit>
        <trans-unit id="1770" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U4">
          <source>No exceptions are ever thrown when using this field.</source>
          <target state="translated">Nenhuma exceção nunca é geradas quando o uso desse campo.</target>       </trans-unit>
        <trans-unit id="1771" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U4">
          <source>See <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I4&gt;</ph> and <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I4_Un&gt;</ph> for equivalent instructions that will throw an exception when the result type can not properly represent the result value.</source>
          <target state="translated">Consulte <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I4&gt;</ph> e <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I4_Un&gt;</ph> para obter instruções equivalentes que lançará uma exceção quando o tipo de resultado pode não representar corretamente o valor do resultado.</target>       </trans-unit>
        <trans-unit id="1772" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U4">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`conv.u4`</ph> opcode:</source>
          <target state="translated">O seguinte <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> sobrecarga de método pode usar o <ph id="ph2">`conv.u4`</ph> opcode:</target>       </trans-unit>
        <trans-unit id="1773" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U4">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="1774" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Conv_U8">
          <source>Converts the value on top of the evaluation stack to <ph id="ph1">&lt;see langword="unsigned int64" /&gt;</ph>, and extends it to <ph id="ph2">&lt;see langword="int64" /&gt;</ph>.</source>
          <target state="translated">Converte o valor na parte superior da pilha de avaliação em <ph id="ph1">&lt;see langword="unsigned int64" /&gt;</ph> e estende-o para <ph id="ph2">&lt;see langword="int64" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1775" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U8">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">A tabela a seguir lista as instruções hexadecimal e formato de assembly do Microsoft Intermediate Language (MSIL), junto com um resumo breve de referência:</target>       </trans-unit>
        <trans-unit id="1776" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U8">
          <source>Format</source>
          <target state="translated">Formatar</target>       </trans-unit>
        <trans-unit id="1777" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U8">
          <source>Assembly Format</source>
          <target state="translated">Formato de assembly</target>       </trans-unit>
        <trans-unit id="1778" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U8">
          <source>Description</source>
          <target state="translated">Descrição</target>       </trans-unit>
        <trans-unit id="1779" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U8">
          <source>6E</source>
          <target state="translated">6E</target>       </trans-unit>
        <trans-unit id="1780" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U8">
          <source>conv.u8</source>
          <target state="translated">Conv.U8</target>       </trans-unit>
        <trans-unit id="1781" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U8">
          <source>Convert to <ph id="ph1">`int64`</ph>, pushing <ph id="ph2">`int64`</ph> on stack.</source>
          <target state="translated">Converter em <ph id="ph1">`int64`</ph>, envio <ph id="ph2">`int64`</ph> na pilha.</target>       </trans-unit>
        <trans-unit id="1782" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U8">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">O comportamento de transição de pilha, em ordem sequencial, é:</target>       </trans-unit>
        <trans-unit id="1783" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U8">
          <source><ph id="ph1">`value`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value`</ph> é inserido na pilha.</target>       </trans-unit>
        <trans-unit id="1784" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U8">
          <source><ph id="ph1">`value`</ph> is popped from the stack and the conversion operation is attempted.</source>
          <target state="translated"><ph id="ph1">`value`</ph> é exibido na pilha e a conversão de tentativa de operação.</target>       </trans-unit>
        <trans-unit id="1785" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U8">
          <source>If the conversion is successful, the resulting value is pushed onto the stack.</source>
          <target state="translated">Se a conversão for bem-sucedida, o valor resultante é inserido na pilha.</target>       </trans-unit>
        <trans-unit id="1786" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U8">
          <source>The <ph id="ph1">`conv.u8`</ph> opcode converts the <ph id="ph2">`value`</ph> on top of the stack to the type specified in the opcode, and leave that converted value on the top of the stack.</source>
          <target state="translated">O <ph id="ph1">`conv.u8`</ph> opcode converte o <ph id="ph2">`value`</ph> na parte superior da pilha para o tipo especificado no opcode e deixe que converter o valor no topo da pilha.</target>       </trans-unit>
        <trans-unit id="1787" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U8">
          <source>Integer values of less than 4 bytes are extended to <ph id="ph1">`int32`</ph> when they are loaded onto the evaluation stack (unless <ph id="ph2">`conv.i`</ph> or <ph id="ph3">`conv.u`</ph> is used, in which case the result is also <ph id="ph4">`native int`</ph>).</source>
          <target state="translated">Valores de inteiro de menos de 4 bytes são estendidos para <ph id="ph1">`int32`</ph> quando eles são carregados para a pilha de avaliação (a menos que <ph id="ph2">`conv.i`</ph> ou <ph id="ph3">`conv.u`</ph> for usado, caso em que o resultado é também <ph id="ph4">`native int`</ph>).</target>       </trans-unit>
        <trans-unit id="1788" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U8">
          <source>Floating-point values are converted to the <ph id="ph1">`F`</ph> type.</source>
          <target state="translated">Valores de ponto flutuante são convertidos para o <ph id="ph1">`F`</ph> tipo.</target>       </trans-unit>
        <trans-unit id="1789" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U8">
          <source>Conversion from floating-point numbers to integer values truncates the number toward zero.</source>
          <target state="translated">A conversão de números de ponto flutuante em valores inteiros trunca o número em direção a zero.</target>       </trans-unit>
        <trans-unit id="1790" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U8">
          <source>When converting from an <ph id="ph1">`float64`</ph> to an <ph id="ph2">`float32`</ph>, precision can be lost.</source>
          <target state="translated">Ao converter de um <ph id="ph1">`float64`</ph> para um <ph id="ph2">`float32`</ph>, precisão pode ser perdida.</target>       </trans-unit>
        <trans-unit id="1791" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U8">
          <source>If <ph id="ph1">`value`</ph> is too large to fit in a <ph id="ph2">`float32 (F)`</ph>, positive infinity (if <ph id="ph3">`value`</ph> is positive) or negative infinity (if <ph id="ph4">`value`</ph> is negative) is returned.</source>
          <target state="translated">Se <ph id="ph1">`value`</ph> é muito grande para caber em uma <ph id="ph2">`float32 (F)`</ph>, infinito positivo (se <ph id="ph3">`value`</ph> for positivo) ou negativo infinito (se <ph id="ph4">`value`</ph> for negativo) será retornado.</target>       </trans-unit>
        <trans-unit id="1792" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U8">
          <source>If overflow occurs converting one integer type to another, the high order bits are truncated.</source>
          <target state="translated">Se estouro ocorre conversão de tipo de um inteiro para outro, os bits de ordem mais alta serão truncados.</target>       </trans-unit>
        <trans-unit id="1793" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U8">
          <source>If the result is smaller than an <ph id="ph1">`int32`</ph>, the value is sign-extended to fill the slot.</source>
          <target state="translated">Se o resultado for menor do que um <ph id="ph1">`int32`</ph>, o valor é de assinatura estendida para preencher o slot.</target>       </trans-unit>
        <trans-unit id="1794" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U8">
          <source>If overflow occurs converting a floating-point type to an integer the value returned is unspecified.</source>
          <target state="translated">Se ocorrer estouro de converter um tipo de ponto flutuante para um inteiro, o valor retornado é especificada.</target>       </trans-unit>
        <trans-unit id="1795" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U8">
          <source>No exceptions are ever thrown when using this field.</source>
          <target state="translated">Nenhuma exceção nunca é geradas quando o uso desse campo.</target>       </trans-unit>
        <trans-unit id="1796" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U8">
          <source>See <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I8&gt;</ph> and <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I8_Un&gt;</ph> for equivalent instructions that will throw an exception when the result type can not properly represent the result value.</source>
          <target state="translated">Consulte <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I8&gt;</ph> e <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I8_Un&gt;</ph> para obter instruções equivalentes que lançará uma exceção quando o tipo de resultado pode não representar corretamente o valor do resultado.</target>       </trans-unit>
        <trans-unit id="1797" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U8">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`conv.u8`</ph> opcode:</source>
          <target state="translated">O seguinte <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> sobrecarga de método pode usar o <ph id="ph2">`conv.u8`</ph> opcode:</target>       </trans-unit>
        <trans-unit id="1798" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U8">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="1799" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Cpblk">
          <source>Copies a specified number bytes from a source address to a destination address.</source>
          <target state="translated">Copia bytes de número especificados de um endereço de origem para um endereço de destino.</target>       </trans-unit>
        <trans-unit id="1800" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Cpblk">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">A tabela a seguir lista as instruções hexadecimal e formato de assembly do Microsoft Intermediate Language (MSIL), junto com um resumo breve de referência:</target>       </trans-unit>
        <trans-unit id="1801" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Cpblk">
          <source>Format</source>
          <target state="translated">Formatar</target>       </trans-unit>
        <trans-unit id="1802" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Cpblk">
          <source>Assembly Format</source>
          <target state="translated">Formato de assembly</target>       </trans-unit>
        <trans-unit id="1803" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Cpblk">
          <source>Description</source>
          <target state="translated">Descrição</target>       </trans-unit>
        <trans-unit id="1804" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Cpblk">
          <source>FE 17</source>
          <target state="translated">FE 17</target>       </trans-unit>
        <trans-unit id="1805" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Cpblk">
          <source>cpblk</source>
          <target state="translated">cpblk</target>       </trans-unit>
        <trans-unit id="1806" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Cpblk">
          <source>Copy data from one memory block to another.</source>
          <target state="translated">Copie dados do bloco de memória para outra.</target>       </trans-unit>
        <trans-unit id="1807" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Cpblk">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">O comportamento de transição de pilha, em ordem sequencial, é:</target>       </trans-unit>
        <trans-unit id="1808" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Cpblk">
          <source>The destination address is pushed onto the stack.</source>
          <target state="translated">O endereço de destino é inserido na pilha.</target>       </trans-unit>
        <trans-unit id="1809" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Cpblk">
          <source>The source address is pushed onto the stack.</source>
          <target state="translated">O endereço de origem é inserido na pilha.</target>       </trans-unit>
        <trans-unit id="1810" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Cpblk">
          <source>The number of bytes to copy is pushed onto the stack.</source>
          <target state="translated">O número de bytes a serem copiados é inserido na pilha.</target>       </trans-unit>
        <trans-unit id="1811" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Cpblk">
          <source>The number of bytes, the source address, and the destination address are popped from the stack; the specified number of bytes are copied from the source address to the destination address.</source>
          <target state="translated">O número de bytes, o endereço de origem e o endereço de destino é disparado da pilha; o número especificado de bytes é copiado do endereço de origem para o endereço de destino.</target>       </trans-unit>
        <trans-unit id="1812" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Cpblk">
          <source>The <ph id="ph1">`cpblk`</ph> instruction copies a number (type <ph id="ph2">`unsigned int32`</ph>) of bytes from a source address (of type <ph id="ph3">`*`</ph>, <ph id="ph4">`native int`</ph>, or <ph id="ph5">`&amp;`</ph>) to a destination address (of type <ph id="ph6">`*`</ph>, <ph id="ph7">`native int`</ph>, or <ph id="ph8">`&amp;`</ph>).</source>
          <target state="translated">O <ph id="ph1">`cpblk`</ph> instrução copia um número (tipo <ph id="ph2">`unsigned int32`</ph>) de bytes de um endereço de origem (do tipo <ph id="ph3">`*`</ph>, <ph id="ph4">`native int`</ph>, ou <ph id="ph5">`&amp;`</ph>) para um endereço de destino (do tipo <ph id="ph6">`*`</ph>, <ph id="ph7">`native int`</ph>, ou <ph id="ph8">`&amp;`</ph>).</target>       </trans-unit>
        <trans-unit id="1813" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Cpblk">
          <source>The behavior of <ph id="ph1">`cpblk`</ph> is unspecified if the source and destination areas overlap.</source>
          <target state="translated">O comportamento de <ph id="ph1">`cpblk`</ph> for especificado, se as áreas de origem e de destino se sobrepõem.</target>       </trans-unit>
        <trans-unit id="1814" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Cpblk">
          <source><ph id="ph1">`cpblk`</ph> assumes that both the source and destination addressed are aligned to the natural size of the machine.</source>
          <target state="translated"><ph id="ph1">`cpblk`</ph> pressupõe-se de que a origem e destino endereçado são alinhados com o tamanho natural da máquina.</target>       </trans-unit>
        <trans-unit id="1815" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Cpblk">
          <source>The <ph id="ph1">`cpblk`</ph> instruction can be immediately preceded by the <ph id="ph2">`unaligned.&lt;prefix&gt;`</ph> instruction to indicate that either the source or the destination is unaligned.</source>
          <target state="translated">O <ph id="ph1">`cpblk`</ph> instrução pode ser imediatamente precedida pelo <ph id="ph2">`unaligned.&lt;prefix&gt;`</ph> instrução para indicar que a origem ou o destino é não alinhado.</target>       </trans-unit>
        <trans-unit id="1816" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Cpblk">
          <source>The operation of the <ph id="ph1">`cpblk`</ph> instruction can be altered by an immediately preceding <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Volatile&gt;</ph> or <ph id="ph3">&lt;xref:System.Reflection.Emit.OpCodes.Unaligned&gt;</ph> prefix instruction.</source>
          <target state="translated">A operação do <ph id="ph1">`cpblk`</ph> instrução pode ser alterada por um imediatamente anterior <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Volatile&gt;</ph> ou <ph id="ph3">&lt;xref:System.Reflection.Emit.OpCodes.Unaligned&gt;</ph> prefixo instrução.</target>       </trans-unit>
        <trans-unit id="1817" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Cpblk">
          <source><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> may be thrown if an invalid address is detected.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> pode ser gerada se um endereço inválido foi detectado.</target>       </trans-unit>
        <trans-unit id="1818" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Cpblk">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`cpblk`</ph> opcode:</source>
          <target state="translated">O seguinte <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> sobrecarga de método pode usar o <ph id="ph2">`cpblk`</ph> opcode:</target>       </trans-unit>
        <trans-unit id="1819" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Cpblk">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="1820" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Cpobj">
          <source>Copies the value type located at the address of an object (type <ph id="ph1">&lt;see langword="&amp;amp;" /&gt;</ph>, <ph id="ph2">&lt;see langword="*" /&gt;</ph> or <ph id="ph3">&lt;see langword="native int" /&gt;</ph>) to the address of the destination object (type <ph id="ph4">&lt;see langword="&amp;amp;" /&gt;</ph>, <ph id="ph5">&lt;see langword="*" /&gt;</ph> or <ph id="ph6">&lt;see langword="native int" /&gt;</ph>).</source>
          <target state="translated">Copia o tipo de valor localizado no endereço de um objeto de (tipo <ph id="ph1">&lt;see langword="&amp;amp;" /&gt;</ph>, <ph id="ph2">&lt;see langword="*" /&gt;</ph> ou <ph id="ph3">&lt;see langword="native int" /&gt;</ph>) para o endereço do objeto de destino (tipo <ph id="ph4">&lt;see langword="&amp;amp;" /&gt;</ph>, <ph id="ph5">&lt;see langword="*" /&gt;</ph> ou <ph id="ph6">&lt;see langword="native int" /&gt;</ph>).</target>       </trans-unit>
        <trans-unit id="1821" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Cpobj">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">A tabela a seguir lista as instruções hexadecimal e formato de assembly do Microsoft Intermediate Language (MSIL), junto com um resumo breve de referência:</target>       </trans-unit>
        <trans-unit id="1822" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Cpobj">
          <source>Format</source>
          <target state="translated">Formatar</target>       </trans-unit>
        <trans-unit id="1823" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Cpobj">
          <source>Assembly Format</source>
          <target state="translated">Formato de assembly</target>       </trans-unit>
        <trans-unit id="1824" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Cpobj">
          <source>Description</source>
          <target state="translated">Descrição</target>       </trans-unit>
        <trans-unit id="1825" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Cpobj">
          <source>70 &lt; <ph id="ph1">`T`</ph><ph id="ph2"> &gt;</ph></source>
          <target state="translated">70 &lt; <ph id="ph1">`T`</ph><ph id="ph2"> &gt;</ph></target>       </trans-unit>
        <trans-unit id="1826" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Cpobj">
          <source>cpobj <ph id="ph1">`classTok`</ph></source>
          <target state="translated">cpobj <ph id="ph1">`classTok`</ph></target>       </trans-unit>
        <trans-unit id="1827" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Cpobj">
          <source>Copies a value type from a source object to a destination object.</source>
          <target state="translated">Cópias de um valor de tipo de um objeto de origem para um objeto de destino.</target>       </trans-unit>
        <trans-unit id="1828" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Cpobj">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">O comportamento de transição de pilha, em ordem sequencial, é:</target>       </trans-unit>
        <trans-unit id="1829" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Cpobj">
          <source>The destination object reference is pushed onto the stack.</source>
          <target state="translated">A referência de objeto de destino é inserida na pilha.</target>       </trans-unit>
        <trans-unit id="1830" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Cpobj">
          <source>The source object reference is pushed onto the stack.</source>
          <target state="translated">A referência de objeto de origem é inserida na pilha.</target>       </trans-unit>
        <trans-unit id="1831" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Cpobj">
          <source>The two object references are popped from the stack; the value type at the address of the source object is copied to the address of the destination object.</source>
          <target state="translated">As duas referências de objeto são disparadas da pilha; o tipo de valor no endereço do objeto de origem é copiado para o endereço do objeto de destino.</target>       </trans-unit>
        <trans-unit id="1832" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Cpobj">
          <source>The behavior of <ph id="ph1">`cpobj`</ph> is unspecified if the source and destination object references are not pointers to instances of the class represented by the class token <ph id="ph2">`classTok`</ph> (a <ph id="ph3">`typeref`</ph> or <ph id="ph4">`typedef`</ph>), or if <ph id="ph5">`classTok`</ph> does not represent a value type.</source>
          <target state="translated">O comportamento de <ph id="ph1">`cpobj`</ph> for especificado, se as referências não são ponteiros para instâncias da classe representada pelo token de classe de objeto de origem e destino <ph id="ph2">`classTok`</ph> (uma <ph id="ph3">`typeref`</ph> ou <ph id="ph4">`typedef`</ph>), ou se <ph id="ph5">`classTok`</ph> não representa um tipo de valor.</target>       </trans-unit>
        <trans-unit id="1833" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Cpobj">
          <source><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> may be thrown if an invalid address is detected.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> pode ser gerada se um endereço inválido foi detectado.</target>       </trans-unit>
        <trans-unit id="1834" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Cpobj">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`cpobj`</ph> opcode:</source>
          <target state="translated">O seguinte <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> sobrecarga de método pode usar o <ph id="ph2">`cpobj`</ph> opcode:</target>       </trans-unit>
        <trans-unit id="1835" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Cpobj">
          <source>ILGenerator.Emit(OpCode, Type)</source>
          <target state="translated">ILGenerator.Emit(OpCode, Type)</target>       </trans-unit>
        <trans-unit id="1836" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Div">
          <source>Divides two values and pushes the result as a floating-point (type <ph id="ph1">&lt;see langword="F" /&gt;</ph>) or quotient (type <ph id="ph2">&lt;see langword="int32" /&gt;</ph>) onto the evaluation stack.</source>
          <target state="translated">Divide dois valores e efetua o push do resultado como um ponto flutuante (tipo <ph id="ph1">&lt;see langword="F" /&gt;</ph>) ou quociente (tipo <ph id="ph2">&lt;see langword="int32" /&gt;</ph>) para a pilha de avaliação.</target>       </trans-unit>
        <trans-unit id="1837" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Div">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">A tabela a seguir lista as instruções hexadecimal e formato de assembly do Microsoft Intermediate Language (MSIL), junto com um resumo breve de referência:</target>       </trans-unit>
        <trans-unit id="1838" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Div">
          <source>Format</source>
          <target state="translated">Formatar</target>       </trans-unit>
        <trans-unit id="1839" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Div">
          <source>Assembly Format</source>
          <target state="translated">Formato de assembly</target>       </trans-unit>
        <trans-unit id="1840" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Div">
          <source>Description</source>
          <target state="translated">Descrição</target>       </trans-unit>
        <trans-unit id="1841" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Div">
          <source>5B</source>
          <target state="translated">5B</target>       </trans-unit>
        <trans-unit id="1842" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Div">
          <source>div</source>
          <target state="translated">div</target>       </trans-unit>
        <trans-unit id="1843" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Div">
          <source>Divides two values to return a quotient or floating-point result.</source>
          <target state="translated">Divide dois valores para retornar um resultado de ponto flutuante ou o quociente.</target>       </trans-unit>
        <trans-unit id="1844" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Div">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">O comportamento de transição de pilha, em ordem sequencial, é:</target>       </trans-unit>
        <trans-unit id="1845" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Div">
          <source><ph id="ph1">`value1`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value1`</ph> é inserido na pilha.</target>       </trans-unit>
        <trans-unit id="1846" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Div">
          <source><ph id="ph1">`value2`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value2`</ph> é inserido na pilha.</target>       </trans-unit>
        <trans-unit id="1847" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Div">
          <source><ph id="ph1">`value2`</ph> and <ph id="ph2">`value1`</ph> are popped from the stack; <ph id="ph3">`value1`</ph> is divided by <ph id="ph4">`value2`</ph>.</source>
          <target state="translated"><ph id="ph1">`value2`</ph> e <ph id="ph2">`value1`</ph> são disparados da pilha; <ph id="ph3">`value1`</ph> é dividida por <ph id="ph4">`value2`</ph>.</target>       </trans-unit>
        <trans-unit id="1848" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Div">
          <source>The result is pushed onto the stack.</source>
          <target state="translated">O resultado é inserido na pilha.</target>       </trans-unit>
        <trans-unit id="1849" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Div">
          <source><ph id="ph1">`result`</ph><ph id="ph2"> = </ph><ph id="ph3">`value1`</ph> div value2 satisfies the following conditions:</source>
          <target state="translated"><ph id="ph1">`result`</ph><ph id="ph2"> = </ph><ph id="ph3">`value1`</ph> div value2 satisfaz as condições a seguir:</target>       </trans-unit>
        <trans-unit id="1850" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Div">
          <source>&amp;#124; <ph id="ph1">`result`</ph> &amp;#124; = &amp;#124; <ph id="ph2">`value1`</ph> &amp;#124; / &amp;#124; <ph id="ph3">`value2`</ph> &amp;#124;, and:</source>
          <target state="translated">&amp;#124;<ph id="ph1">`result`</ph> &amp;#124; = &amp;#124; <ph id="ph2">`value1`</ph> &amp;#124; / &amp;#124; <ph id="ph3">`value2`</ph> &amp;#124;, e:</target>       </trans-unit>
        <trans-unit id="1851" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Div">
          <source>sign(<ph id="ph1">`result`</ph>) = +, if sign(<ph id="ph2">`value1`</ph>) = sign(<ph id="ph3">`value2`</ph>), or -, if sign(<ph id="ph4">`value1`</ph>) ~= sign(<ph id="ph5">`value2`</ph>)</source>
          <target state="translated">sinal (<ph id="ph1">`result`</ph>) = +, se entrar (<ph id="ph2">`value1`</ph>) = sinal (<ph id="ph3">`value2`</ph>), ou-, se sinal (<ph id="ph4">`value1`</ph>) ~ = sinal (<ph id="ph5">`value2`</ph>)</target>       </trans-unit>
        <trans-unit id="1852" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Div">
          <source>The <ph id="ph1">`div`</ph> instruction computes the result and pushes it on the stack.</source>
          <target state="translated">O <ph id="ph1">`div`</ph> instrução calcula o resultado e envia por push na pilha.</target>       </trans-unit>
        <trans-unit id="1853" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Div">
          <source>Integer division truncates towards zero.</source>
          <target state="translated">Divisão de inteiro trunca em direção a zero.</target>       </trans-unit>
        <trans-unit id="1854" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Div">
          <source>Division of a finite number by zero produces the correctly signed infinite value.</source>
          <target state="translated">Divisão de um número finito por zero produz o valor infinito assinado corretamente.</target>       </trans-unit>
        <trans-unit id="1855" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Div">
          <source>Dividing zero by zero or infinity by infinity produces the NaN (Not-A-Number) value.</source>
          <target state="translated">Dividindo o zero por zero ou infinito por infinito produz o valor NaN (não-um número).</target>       </trans-unit>
        <trans-unit id="1856" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Div">
          <source>Any number divided by infinity will produce a zero value.</source>
          <target state="translated">Qualquer número dividido por infinito produzirá um valor igual a zero.</target>       </trans-unit>
        <trans-unit id="1857" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Div">
          <source>Integral operations throw <ph id="ph1">&lt;xref:System.ArithmeticException&gt;</ph> if the result cannot be represented in the result type.</source>
          <target state="translated">Operações integrais lançam <ph id="ph1">&lt;xref:System.ArithmeticException&gt;</ph> se o resultado não pode ser representado no tipo de resultado.</target>       </trans-unit>
        <trans-unit id="1858" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Div">
          <source>This can happen if <ph id="ph1">`value1`</ph> is the maximum negative value, and <ph id="ph2">`value2`</ph> is -1.</source>
          <target state="translated">Isso pode acontecer se <ph id="ph1">`value1`</ph> é o valor negativo máximo, e <ph id="ph2">`value2`</ph> é -1.</target>       </trans-unit>
        <trans-unit id="1859" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Div">
          <source>Integral operations throw <ph id="ph1">&lt;xref:System.DivideByZeroException&gt;</ph> if <ph id="ph2">`value2`</ph> is zero.</source>
          <target state="translated">Operações integrais lançam <ph id="ph1">&lt;xref:System.DivideByZeroException&gt;</ph> se <ph id="ph2">`value2`</ph> é zero.</target>       </trans-unit>
        <trans-unit id="1860" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Div">
          <source>Note that on Intel-based platforms an <ph id="ph1">&lt;xref:System.OverflowException&gt;</ph> is thrown when computing (minint div -1).</source>
          <target state="translated">Observe que em plataformas baseadas em Intel em um <ph id="ph1">&lt;xref:System.OverflowException&gt;</ph> é gerada quando a computação (minint div -1).</target>       </trans-unit>
        <trans-unit id="1861" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Div">
          <source>Floating-point operations never throw an exception (they produce NaNs or infinities instead).</source>
          <target state="translated">Operações de ponto flutuante nunca lançam uma exceção (geram NaNs ou pontos em vez disso).</target>       </trans-unit>
        <trans-unit id="1862" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Div">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`div`</ph> opcode:</source>
          <target state="translated">O seguinte <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> sobrecarga de método pode usar o <ph id="ph2">`div`</ph> opcode:</target>       </trans-unit>
        <trans-unit id="1863" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Div">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="1864" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Div_Un">
          <source>Divides two unsigned integer values and pushes the result (<ph id="ph1">&lt;see langword="int32" /&gt;</ph>) onto the evaluation stack.</source>
          <target state="translated">Divide dois valores de inteiro sem sinal e envia o resultado (<ph id="ph1">&lt;see langword="int32" /&gt;</ph>) para a pilha de avaliação.</target>       </trans-unit>
        <trans-unit id="1865" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Div_Un">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">A tabela a seguir lista as instruções hexadecimal e formato de assembly do Microsoft Intermediate Language (MSIL), junto com um resumo breve de referência:</target>       </trans-unit>
        <trans-unit id="1866" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Div_Un">
          <source>Format</source>
          <target state="translated">Formatar</target>       </trans-unit>
        <trans-unit id="1867" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Div_Un">
          <source>Assembly Format</source>
          <target state="translated">Formato de assembly</target>       </trans-unit>
        <trans-unit id="1868" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Div_Un">
          <source>Description</source>
          <target state="translated">Descrição</target>       </trans-unit>
        <trans-unit id="1869" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Div_Un">
          <source>5C</source>
          <target state="translated">5C</target>       </trans-unit>
        <trans-unit id="1870" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Div_Un">
          <source>div.un</source>
          <target state="translated">div.un</target>       </trans-unit>
        <trans-unit id="1871" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Div_Un">
          <source>Divides two values, unsigned, returning a quotient.</source>
          <target state="translated">Divide dois valores, não assinados, retornando um quociente.</target>       </trans-unit>
        <trans-unit id="1872" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Div_Un">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">O comportamento de transição de pilha, em ordem sequencial, é:</target>       </trans-unit>
        <trans-unit id="1873" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Div_Un">
          <source><ph id="ph1">`value1`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value1`</ph> é inserido na pilha.</target>       </trans-unit>
        <trans-unit id="1874" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Div_Un">
          <source><ph id="ph1">`value2`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value2`</ph> é inserido na pilha.</target>       </trans-unit>
        <trans-unit id="1875" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Div_Un">
          <source><ph id="ph1">`value2`</ph> and <ph id="ph2">`value1`</ph> are popped from the stack; <ph id="ph3">`value1`</ph> is divided by <ph id="ph4">`value2`</ph>.</source>
          <target state="translated"><ph id="ph1">`value2`</ph> e <ph id="ph2">`value1`</ph> são disparados da pilha; <ph id="ph3">`value1`</ph> é dividida por <ph id="ph4">`value2`</ph>.</target>       </trans-unit>
        <trans-unit id="1876" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Div_Un">
          <source>The result is pushed onto the stack.</source>
          <target state="translated">O resultado é inserido na pilha.</target>       </trans-unit>
        <trans-unit id="1877" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Div_Un">
          <source>The <ph id="ph1">`div.un`</ph> instruction computes <ph id="ph2">`value1`</ph> divided by <ph id="ph3">`value2`</ph>, both taken as unsigned integers, and pushes the <ph id="ph4">`result`</ph> on the stack.</source>
          <target state="translated">O <ph id="ph1">`div.un`</ph> calcula a instrução <ph id="ph2">`value1`</ph> dividido por <ph id="ph3">`value2`</ph>, ambos assumida como inteiros sem sinal e coloca o <ph id="ph4">`result`</ph> na pilha.</target>       </trans-unit>
        <trans-unit id="1878" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Div_Un">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`div.un`</ph> opcode:</source>
          <target state="translated">O seguinte <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> sobrecarga de método pode usar o <ph id="ph2">`div.un`</ph> opcode:</target>       </trans-unit>
        <trans-unit id="1879" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Div_Un">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="1880" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Dup">
          <source>Copies the current topmost value on the evaluation stack, and then pushes the copy onto the evaluation stack.</source>
          <target state="translated">Copia o valor atual mais alto na pilha de avaliação e, em seguida, envia a cópia para a pilha de avaliação.</target>       </trans-unit>
        <trans-unit id="1881" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Dup">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">A tabela a seguir lista as instruções hexadecimal e formato de assembly do Microsoft Intermediate Language (MSIL), junto com um resumo breve de referência:</target>       </trans-unit>
        <trans-unit id="1882" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Dup">
          <source>Format</source>
          <target state="translated">Formatar</target>       </trans-unit>
        <trans-unit id="1883" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Dup">
          <source>Assembly Format</source>
          <target state="translated">Formato de assembly</target>       </trans-unit>
        <trans-unit id="1884" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Dup">
          <source>Description</source>
          <target state="translated">Descrição</target>       </trans-unit>
        <trans-unit id="1885" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Dup">
          <source>25</source>
          <target state="translated">25</target>       </trans-unit>
        <trans-unit id="1886" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Dup">
          <source>dup</source>
          <target state="translated">DUP</target>       </trans-unit>
        <trans-unit id="1887" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Dup">
          <source>Duplicates the value on the top of the stack.</source>
          <target state="translated">Duplica o valor na parte superior da pilha.</target>       </trans-unit>
        <trans-unit id="1888" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Dup">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">O comportamento de transição de pilha, em ordem sequencial, é:</target>       </trans-unit>
        <trans-unit id="1889" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Dup">
          <source><ph id="ph1">`value`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value`</ph> é inserido na pilha.</target>       </trans-unit>
        <trans-unit id="1890" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Dup">
          <source><ph id="ph1">`value`</ph> is popped off of the stack for duplication.</source>
          <target state="translated"><ph id="ph1">`value`</ph> é exibido fora a pilha para eliminação de duplicação.</target>       </trans-unit>
        <trans-unit id="1891" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Dup">
          <source><ph id="ph1">`value`</ph> is pushed back onto the stack.</source>
          <target state="translated"><ph id="ph1">`value`</ph> é enviada de volta para a pilha.</target>       </trans-unit>
        <trans-unit id="1892" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Dup">
          <source>A duplicate value is pushed onto the stack.</source>
          <target state="translated">Um valor duplicado é inserido na pilha.</target>       </trans-unit>
        <trans-unit id="1893" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Dup">
          <source>The <ph id="ph1">`dup`</ph> instruction duplicates the top element of the stack, and leaves two identical values atop it.</source>
          <target state="translated">O <ph id="ph1">`dup`</ph> instrução duplica o elemento superior da pilha e deixa de dois valores idênticos sobre ele.</target>       </trans-unit>
        <trans-unit id="1894" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Dup">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`dup`</ph> opcode:</source>
          <target state="translated">O seguinte <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> sobrecarga de método pode usar o <ph id="ph2">`dup`</ph> opcode:</target>       </trans-unit>
        <trans-unit id="1895" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Dup">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="1896" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Endfilter">
          <source>Transfers control from the <ph id="ph1">&lt;see langword="filter" /&gt;</ph> clause of an exception back to the Common Language Infrastructure (CLI) exception handler.</source>
          <target state="translated">Transfere o controle da cláusula <ph id="ph1">&lt;see langword="filter" /&gt;</ph> de uma exceção para o manipulador de exceção da CLI (Common Language Infrastructure).</target>       </trans-unit>
        <trans-unit id="1897" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Endfilter">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">A tabela a seguir lista as instruções hexadecimal e formato de assembly do Microsoft Intermediate Language (MSIL), junto com um resumo breve de referência:</target>       </trans-unit>
        <trans-unit id="1898" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Endfilter">
          <source>Format</source>
          <target state="translated">Formatar</target>       </trans-unit>
        <trans-unit id="1899" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Endfilter">
          <source>Assembly Format</source>
          <target state="translated">Formato de assembly</target>       </trans-unit>
        <trans-unit id="1900" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Endfilter">
          <source>Description</source>
          <target state="translated">Descrição</target>       </trans-unit>
        <trans-unit id="1901" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Endfilter">
          <source>FE 11</source>
          <target state="translated">FE 11</target>       </trans-unit>
        <trans-unit id="1902" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Endfilter">
          <source>endfilter</source>
          <target state="translated">endfilter</target>       </trans-unit>
        <trans-unit id="1903" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Endfilter">
          <source>End filter clause of SEH exception handling.</source>
          <target state="translated">Cláusula de filtro de final de tratamento de exceções de SEH.</target>       </trans-unit>
        <trans-unit id="1904" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Endfilter">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">O comportamento de transição de pilha, em ordem sequencial, é:</target>       </trans-unit>
        <trans-unit id="1905" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Endfilter">
          <source><ph id="ph1">`value`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value`</ph> é inserido na pilha.</target>       </trans-unit>
        <trans-unit id="1906" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Endfilter">
          <source><ph id="ph1">`value`</ph> is popped from the stack; <ph id="ph2">`endfilter`</ph> is executed and control is transferred to the exception handler.</source>
          <target state="translated"><ph id="ph1">`value`</ph> é exibido da pilha; <ph id="ph2">`endfilter`</ph> é executado e o controle é transferido para o manipulador de exceção.</target>       </trans-unit>
        <trans-unit id="1907" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Endfilter">
          <source><ph id="ph1">`Value`</ph> (which must be of type <ph id="ph2">`int32`</ph> and is one of a specific set of values) is returned from the filter clause.</source>
          <target state="translated"><ph id="ph1">`Value`</ph> (que deve ser do tipo <ph id="ph2">`int32`</ph> e é parte de um conjunto específico de valores) é retornado na cláusula de filtro.</target>       </trans-unit>
        <trans-unit id="1908" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Endfilter">
          <source>It should be one of:</source>
          <target state="translated">Ele deve ser um destes:</target>       </trans-unit>
        <trans-unit id="1909" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Endfilter">
          <source><ph id="ph1">`exception_continue_search`</ph> (<ph id="ph2">`value`</ph> = 0) to continue searching for an exception handler</source>
          <target state="translated"><ph id="ph1">`exception_continue_search`</ph> (<ph id="ph2">`value`</ph> = 0) para continuar a pesquisa de um manipulador de exceção</target>       </trans-unit>
        <trans-unit id="1910" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Endfilter">
          <source><ph id="ph1">`exception_execute_handler`</ph> (<ph id="ph2">`value`</ph> = 1) to start the second phase of exception handling where finally blocks are run until the handler associated with this filter clause is located.</source>
          <target state="translated"><ph id="ph1">`exception_execute_handler`</ph> (<ph id="ph2">`value`</ph> = 1) para iniciar a segunda fase da manipulação de exceção onde finalmente blocos são executados até que o manipulador associado a essa cláusula de filtro está localizado.</target>       </trans-unit>
        <trans-unit id="1911" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Endfilter">
          <source>Upon discovery, the handler is executed.</source>
          <target state="translated">Após a descoberta, o manipulador é executado.</target>       </trans-unit>
        <trans-unit id="1912" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Endfilter">
          <source>Other integer values will produce unspecified results.</source>
          <target state="translated">Outros valores inteiros produzirá resultados não especificados.</target>       </trans-unit>
        <trans-unit id="1913" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Endfilter">
          <source>The entry point of a filter, as shown in the method's exception table, must be the first instruction in the filter's code block.</source>
          <target state="translated">O ponto de entrada de um filtro, como mostrado na tabela de exceção do método, deve ser a primeira instrução no bloco de código do filtro.</target>       </trans-unit>
        <trans-unit id="1914" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Endfilter">
          <source>The <ph id="ph1">`endfilter`</ph> instruction must be the last instruction in the filter's code block (hence there can only be one <ph id="ph2">`endfilter`</ph> for any single filter block).</source>
          <target state="translated">O <ph id="ph1">`endfilter`</ph> instrução deve ser a última instrução no bloco de código do filtro (portanto, pode haver apenas um <ph id="ph2">`endfilter`</ph> para qualquer bloco único filtro).</target>       </trans-unit>
        <trans-unit id="1915" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Endfilter">
          <source>After executing the <ph id="ph1">`endfilter`</ph> instruction, control logically flows back to the CLI exception handling mechanism.</source>
          <target state="translated">Depois de executar o <ph id="ph1">`endfilter`</ph> instrução, logicamente fluxos de controle para o mecanismo de tratamento de exceções de CLI.</target>       </trans-unit>
        <trans-unit id="1916" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Endfilter">
          <source>Control cannot be transferred into a filter block except through the exception mechanism.</source>
          <target state="translated">Controle não pode ser transferido para um bloco de filtro, exceto pelo mecanismo de exceção.</target>       </trans-unit>
        <trans-unit id="1917" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Endfilter">
          <source>Control cannot be transferred out of a filter block except through the use of a <ph id="ph1">`throw`</ph> instruction or by executing the final <ph id="ph2">`endfilter`</ph> instruction.</source>
          <target state="translated">Não é possível transferir controle fora de um bloco de filtro, exceto por meio do uso de um <ph id="ph1">`throw`</ph> instrução ou executando o último <ph id="ph2">`endfilter`</ph> instrução.</target>       </trans-unit>
        <trans-unit id="1918" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Endfilter">
          <source>You cannot embed a <ph id="ph1">`try`</ph> block within a <ph id="ph2">`filter`</ph> block.</source>
          <target state="translated">Não é possível inserir um <ph id="ph1">`try`</ph> bloquear dentro de um <ph id="ph2">`filter`</ph> bloco.</target>       </trans-unit>
        <trans-unit id="1919" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Endfilter">
          <source>If an exception is thrown inside the <ph id="ph1">`filter`</ph> block, it is intercepted and a value of 0 (<ph id="ph2">`exception_continue_search`</ph>) is returned.</source>
          <target state="translated">Se uma exceção é gerada dentro de <ph id="ph1">`filter`</ph> bloco, isso será interceptado e um valor de 0 (<ph id="ph2">`exception_continue_search`</ph>) será retornado.</target>       </trans-unit>
        <trans-unit id="1920" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Endfilter">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`endfilter`</ph> opcode:</source>
          <target state="translated">O seguinte <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> sobrecarga de método pode usar o <ph id="ph2">`endfilter`</ph> opcode:</target>       </trans-unit>
        <trans-unit id="1921" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Endfilter">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="1922" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Endfinally">
          <source>Transfers control from the <ph id="ph1">&lt;see langword="fault" /&gt;</ph> or <ph id="ph2">&lt;see langword="finally" /&gt;</ph> clause of an exception block back to the Common Language Infrastructure (CLI) exception handler.</source>
          <target state="translated">Transfere o controle da cláusula <ph id="ph1">&lt;see langword="fault" /&gt;</ph> ou <ph id="ph2">&lt;see langword="finally" /&gt;</ph> de um bloco de exceção de volta para o manipulador de exceção da CLI (Common Language Infrastructure).</target>       </trans-unit>
        <trans-unit id="1923" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Endfinally">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">A tabela a seguir lista as instruções hexadecimal e formato de assembly do Microsoft Intermediate Language (MSIL), junto com um resumo breve de referência:</target>       </trans-unit>
        <trans-unit id="1924" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Endfinally">
          <source>Format</source>
          <target state="translated">Formatar</target>       </trans-unit>
        <trans-unit id="1925" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Endfinally">
          <source>Assembly Format</source>
          <target state="translated">Formato de assembly</target>       </trans-unit>
        <trans-unit id="1926" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Endfinally">
          <source>Description</source>
          <target state="translated">Descrição</target>       </trans-unit>
        <trans-unit id="1927" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Endfinally">
          <source>DC</source>
          <target state="translated">DC</target>       </trans-unit>
        <trans-unit id="1928" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Endfinally">
          <source>endfinally</source>
          <target state="translated">Endfinally</target>       </trans-unit>
        <trans-unit id="1929" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Endfinally">
          <source>endfault</source>
          <target state="translated">endfault</target>       </trans-unit>
        <trans-unit id="1930" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Endfinally">
          <source>Ends the <ph id="ph1">`finally`</ph> or <ph id="ph2">`fault`</ph> clause of an exception block.</source>
          <target state="translated">Termina o <ph id="ph1">`finally`</ph> ou <ph id="ph2">`fault`</ph> cláusula de um bloco de exceção.</target>       </trans-unit>
        <trans-unit id="1931" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Endfinally">
          <source>There are no stack transition behaviors for this instruction.</source>
          <target state="translated">Não há nenhuma pilha comportamentos de transição para essa instrução.</target>       </trans-unit>
        <trans-unit id="1932" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Endfinally">
          <source><ph id="ph1">`Endfinally`</ph> and <ph id="ph2">`endfault`</ph> signal the end of the <ph id="ph3">`finally`</ph> or <ph id="ph4">`fault`</ph> clause so that stack unwinding can continue until the exception handler is invoked.</source>
          <target state="translated"><ph id="ph1">`Endfinally`</ph> e <ph id="ph2">`endfault`</ph> sinalizar o final do <ph id="ph3">`finally`</ph> ou <ph id="ph4">`fault`</ph> cláusula para que o desenrolamento de pilha pode continuar até que o manipulador de exceção é invocado.</target>       </trans-unit>
        <trans-unit id="1933" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Endfinally">
          <source>The <ph id="ph1">`endfinally`</ph> or <ph id="ph2">`endfault`</ph> instruction transfers control back to the CLI exception mechanism.</source>
          <target state="translated">O <ph id="ph1">`endfinally`</ph> ou <ph id="ph2">`endfault`</ph> instrução transfere o controle volta para o mecanismo de exceção CLI.</target>       </trans-unit>
        <trans-unit id="1934" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Endfinally">
          <source>The mechanism then searches for the next <ph id="ph1">`finally`</ph> clause in the chain if the protected block was exited with a leave instruction.</source>
          <target state="translated">Em seguida, o mecanismo procura a próxima <ph id="ph1">`finally`</ph> cláusula na cadeia se o bloco protegido foi encerrado com uma instrução de licença.</target>       </trans-unit>
        <trans-unit id="1935" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Endfinally">
          <source>If the protected block was exited with an exception, the CLI will search for the next <ph id="ph1">`finally`</ph> or <ph id="ph2">`fault`</ph>, or enter the exception handler chosen during the first pass of exception handling.</source>
          <target state="translated">Se o bloco protegido foi encerrado com uma exceção, a CLI procurará o próximo <ph id="ph1">`finally`</ph> ou <ph id="ph2">`fault`</ph>, ou insira o manipulador de exceção escolhido durante a primeira passagem de manipulação de exceção.</target>       </trans-unit>
        <trans-unit id="1936" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Endfinally">
          <source>An <ph id="ph1">`endfinally`</ph> instruction might only appear lexically within a <ph id="ph2">`finally`</ph> block.</source>
          <target state="translated">Um <ph id="ph1">`endfinally`</ph> instrução só pode aparecer lexicalmente dentro um <ph id="ph2">`finally`</ph> bloco.</target>       </trans-unit>
        <trans-unit id="1937" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Endfinally">
          <source>Unlike the <ph id="ph1">`endfilter`</ph> instruction, there is no requirement that the block end with an <ph id="ph2">`endfinally`</ph> instruction, and there can be as many <ph id="ph3">`endfinally`</ph> instructions within the block as required.</source>
          <target state="translated">Diferentemente de <ph id="ph1">`endfilter`</ph> instrução, não há nenhum requisito para que o bloco terminar com um <ph id="ph2">`endfinally`</ph> instrução e pode haver tantos <ph id="ph3">`endfinally`</ph> instruções dentro do bloco conforme necessário.</target>       </trans-unit>
        <trans-unit id="1938" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Endfinally">
          <source>These same restrictions apply to the <ph id="ph1">`endfault`</ph> instruction and the <ph id="ph2">`fault`</ph> block.</source>
          <target state="translated">Essas restrições se aplicam ao <ph id="ph1">`endfault`</ph> instrução e o <ph id="ph2">`fault`</ph> bloco.</target>       </trans-unit>
        <trans-unit id="1939" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Endfinally">
          <source>Control cannot be transferred into a <ph id="ph1">`finally`</ph> (or <ph id="ph2">`fault`</ph>) block except through the exception mechanism.</source>
          <target state="translated">Controle não pode ser transferido em uma <ph id="ph1">`finally`</ph> (ou <ph id="ph2">`fault`</ph>) bloquear exceto pelo mecanismo de exceção.</target>       </trans-unit>
        <trans-unit id="1940" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Endfinally">
          <source>Control cannot be transferred out of a <ph id="ph1">`finally`</ph> (or <ph id="ph2">`fault`</ph>) block except through the use of a <ph id="ph3">`throw`</ph> instruction or executing the <ph id="ph4">`endfinally`</ph> (or <ph id="ph5">`endfault`</ph>) instruction.</source>
          <target state="translated">Não é possível transferir controle fora de um <ph id="ph1">`finally`</ph> (ou <ph id="ph2">`fault`</ph>) bloquear exceto por meio do uso de um <ph id="ph3">`throw`</ph> instruções ou executar o <ph id="ph4">`endfinally`</ph> (ou <ph id="ph5">`endfault`</ph>) instrução.</target>       </trans-unit>
        <trans-unit id="1941" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Endfinally">
          <source>In particular, you cannot "fall out" of a <ph id="ph1">`finally`</ph> (or <ph id="ph2">`fault`</ph>) block or to execute a <ph id="ph3">&lt;xref:System.Reflection.Emit.OpCodes.Ret&gt;</ph> or <ph id="ph4">&lt;xref:System.Reflection.Emit.OpCodes.Leave&gt;</ph> instruction within a <ph id="ph5">`finally`</ph> (or <ph id="ph6">`fault`</ph>) block.</source>
          <target state="translated">Em particular, você não pode "se" de um <ph id="ph1">`finally`</ph> (ou <ph id="ph2">`fault`</ph>) bloco ou execute um <ph id="ph3">&lt;xref:System.Reflection.Emit.OpCodes.Ret&gt;</ph> ou <ph id="ph4">&lt;xref:System.Reflection.Emit.OpCodes.Leave&gt;</ph> instrução dentro de um <ph id="ph5">`finally`</ph> (ou <ph id="ph6">`fault`</ph>) bloco.</target>       </trans-unit>
        <trans-unit id="1942" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Endfinally">
          <source>Note that the <ph id="ph1">`endfault`</ph> and <ph id="ph2">`endfinally`</ph> instructions are aliases - they correspond to the same opcode.</source>
          <target state="translated">Observe que o <ph id="ph1">`endfault`</ph> e <ph id="ph2">`endfinally`</ph> instruções são aliases - elas correspondem ao mesmo código.</target>       </trans-unit>
        <trans-unit id="1943" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Endfinally">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`endfinally`</ph> (<ph id="ph3">`endfault`</ph>) opcode, as well as the <ph id="ph4">`ILGenerator`</ph> method <ph id="ph5">&lt;xref:System.Reflection.Emit.ILGenerator.EndExceptionBlock%2A&gt;</ph>.</source>
          <target state="translated">O seguinte <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> sobrecarga de método pode usar o <ph id="ph2">`endfinally`</ph> (<ph id="ph3">`endfault`</ph>) opcode, bem como o <ph id="ph4">`ILGenerator`</ph> método <ph id="ph5">&lt;xref:System.Reflection.Emit.ILGenerator.EndExceptionBlock%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1944" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Endfinally">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="1945" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Endfinally">
          <source>ILGenerator.EndExceptionBlock()</source>
          <target state="translated">ILGenerator.EndExceptionBlock()</target>       </trans-unit>
        <trans-unit id="1946" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Initblk">
          <source>Initializes a specified block of memory at a specific address to a given size and initial value.</source>
          <target state="translated">Inicializa um bloco de memória especificado em um endereço específico e em um tamanho e valor inicial especificados.</target>       </trans-unit>
        <trans-unit id="1947" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Initblk">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">A tabela a seguir lista as instruções hexadecimal e formato de assembly do Microsoft Intermediate Language (MSIL), junto com um resumo breve de referência:</target>       </trans-unit>
        <trans-unit id="1948" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Initblk">
          <source>Format</source>
          <target state="translated">Formatar</target>       </trans-unit>
        <trans-unit id="1949" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Initblk">
          <source>Assembly Format</source>
          <target state="translated">Formato de assembly</target>       </trans-unit>
        <trans-unit id="1950" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Initblk">
          <source>Description</source>
          <target state="translated">Descrição</target>       </trans-unit>
        <trans-unit id="1951" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Initblk">
          <source>FE 18</source>
          <target state="translated">FE 18</target>       </trans-unit>
        <trans-unit id="1952" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Initblk">
          <source>initblk</source>
          <target state="translated">initblk</target>       </trans-unit>
        <trans-unit id="1953" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Initblk">
          <source>Set each location in a block of memory to a given value.</source>
          <target state="translated">Defina cada local em um bloco de memória para um determinado valor.</target>       </trans-unit>
        <trans-unit id="1954" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Initblk">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">O comportamento de transição de pilha, em ordem sequencial, é:</target>       </trans-unit>
        <trans-unit id="1955" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Initblk">
          <source>A starting address is pushed onto the stack.</source>
          <target state="translated">Um endereço inicial é inserido na pilha.</target>       </trans-unit>
        <trans-unit id="1956" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Initblk">
          <source>An initialization value is pushed onto the stack.</source>
          <target state="translated">Um valor de inicialização é inserido na pilha.</target>       </trans-unit>
        <trans-unit id="1957" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Initblk">
          <source>The number of bytes to initialize is pushed onto the stack.</source>
          <target state="translated">O número de bytes para inicializar é inserido na pilha.</target>       </trans-unit>
        <trans-unit id="1958" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Initblk">
          <source>The number of bytes, the initialization value, and the starting address are popped from the stack, and the initialization is performed as per their values.</source>
          <target state="translated">O número de bytes, o valor de inicialização e o endereço inicial é disparado da pilha e a inicialização é executada de acordo com seus valores.</target>       </trans-unit>
        <trans-unit id="1959" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Initblk">
          <source>The <ph id="ph1">`initblk`</ph> instruction sets the number (<ph id="ph2">`unsigned int32`</ph>) of bytes starting at the specified address (of type <ph id="ph3">`native int`</ph>, <ph id="ph4">`&amp;`</ph>, or <ph id="ph5">`*`</ph>) to the initialization value (of type <ph id="ph6">`unsigned int8`</ph>).</source>
          <target state="translated">O <ph id="ph1">`initblk`</ph> instrução define o número (<ph id="ph2">`unsigned int32`</ph>) de bytes, começando no endereço especificado (do tipo <ph id="ph3">`native int`</ph>, <ph id="ph4">`&amp;`</ph>, ou <ph id="ph5">`*`</ph>) para o valor de inicialização (do tipo <ph id="ph6">`unsigned int8`</ph>).</target>       </trans-unit>
        <trans-unit id="1960" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Initblk">
          <source><ph id="ph1">`initblk`</ph> assumes that the starting address is aligned to the natural size of the machine.</source>
          <target state="translated"><ph id="ph1">`initblk`</ph> pressupõe-se de que o endereço inicial é alinhado ao tamanho natural da máquina.</target>       </trans-unit>
        <trans-unit id="1961" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Initblk">
          <source>The operation of the <ph id="ph1">`initblk`</ph> instructions can be altered by an immediately preceding <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Volatile&gt;</ph> or <ph id="ph3">&lt;xref:System.Reflection.Emit.OpCodes.Unaligned&gt;</ph> prefix instruction.</source>
          <target state="translated">A operação do <ph id="ph1">`initblk`</ph> instruções podem ser alteradas por um imediatamente anterior <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Volatile&gt;</ph> ou <ph id="ph3">&lt;xref:System.Reflection.Emit.OpCodes.Unaligned&gt;</ph> prefixo instrução.</target>       </trans-unit>
        <trans-unit id="1962" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Initblk">
          <source><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> may be thrown if an invalid address is detected.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> pode ser gerada se um endereço inválido foi detectado.</target>       </trans-unit>
        <trans-unit id="1963" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Initblk">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`initblk`</ph> opcode:</source>
          <target state="translated">O seguinte <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> sobrecarga de método pode usar o <ph id="ph2">`initblk`</ph> opcode:</target>       </trans-unit>
        <trans-unit id="1964" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Initblk">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="1965" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Initobj">
          <source>Initializes each field of the value type at a specified address to a null reference or a 0 of the appropriate primitive type.</source>
          <target state="translated">Inicializa cada campo do tipo de valor em um endereço especificado como uma referência nula ou 0 do tipo primitivo apropriado.</target>       </trans-unit>
        <trans-unit id="1966" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Initobj">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">A tabela a seguir lista as instruções hexadecimal e formato de assembly do Microsoft Intermediate Language (MSIL), junto com um resumo breve de referência:</target>       </trans-unit>
        <trans-unit id="1967" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Initobj">
          <source>Format</source>
          <target state="translated">Formatar</target>       </trans-unit>
        <trans-unit id="1968" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Initobj">
          <source>Assembly Format</source>
          <target state="translated">Formato de assembly</target>       </trans-unit>
        <trans-unit id="1969" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Initobj">
          <source>Description</source>
          <target state="translated">Descrição</target>       </trans-unit>
        <trans-unit id="1970" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Initobj">
          <source>FE 15 &lt; <ph id="ph1">`T`</ph><ph id="ph2"> &gt;</ph></source>
          <target state="translated">FE 15 &lt; <ph id="ph1">`T`</ph><ph id="ph2"> &gt;</ph></target>       </trans-unit>
        <trans-unit id="1971" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Initobj">
          <source><ph id="ph1">`initobj`</ph> <ph id="ph2">`typeTok`</ph></source>
          <target state="translated"><ph id="ph1">`initobj`</ph> <ph id="ph2">`typeTok`</ph></target>       </trans-unit>
        <trans-unit id="1972" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Initobj">
          <source>Initializes a value type.</source>
          <target state="translated">Inicializa um tipo de valor.</target>       </trans-unit>
        <trans-unit id="1973" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Initobj">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">O comportamento de transição de pilha, em ordem sequencial, é:</target>       </trans-unit>
        <trans-unit id="1974" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Initobj">
          <source>The address of the value type to initialize is pushed onto the stack.</source>
          <target state="translated">O endereço do tipo de valor para inicializar é inserido na pilha.</target>       </trans-unit>
        <trans-unit id="1975" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Initobj">
          <source>The address is popped from the stack; the value type at the specified address is initialized as type <ph id="ph1">`typeTok`</ph>.</source>
          <target state="translated">O endereço é exibido da pilha; o tipo de valor no endereço especificado é inicializado como tipo <ph id="ph1">`typeTok`</ph>.</target>       </trans-unit>
        <trans-unit id="1976" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Initobj">
          <source>The <ph id="ph1">`initobj`</ph> instruction initializes each field of the value type specified by the pushed address (of type <ph id="ph2">`native int`</ph>, <ph id="ph3">`&amp;`</ph>, or <ph id="ph4">`*`</ph>) to a null reference or a 0 of the appropriate primitive type.</source>
          <target state="translated">O <ph id="ph1">`initobj`</ph> instrução inicializa cada campo do tipo de valor especificado pelo endereço enviadas por push (do tipo <ph id="ph2">`native int`</ph>, <ph id="ph3">`&amp;`</ph>, ou <ph id="ph4">`*`</ph>) para uma referência nula ou 0 do tipo primitivo apropriado.</target>       </trans-unit>
        <trans-unit id="1977" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Initobj">
          <source>After this method is called, the instance is ready for a constructor method to be called.</source>
          <target state="translated">Depois que este método é chamado, a instância está pronta para um método de construtor a ser chamado.</target>       </trans-unit>
        <trans-unit id="1978" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Initobj">
          <source>If <ph id="ph1">`typeTok`</ph> is a reference type, this instruction has the same effect as <ph id="ph2">`ldnull`</ph> followed by <ph id="ph3">`stind.ref`</ph>.</source>
          <target state="translated">Se <ph id="ph1">`typeTok`</ph> é um tipo de referência, esta instrução tem o mesmo efeito que <ph id="ph2">`ldnull`</ph> seguido por <ph id="ph3">`stind.ref`</ph>.</target>       </trans-unit>
        <trans-unit id="1979" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Initobj">
          <source>Unlike <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Newobj&gt;</ph>, <ph id="ph2">`initobj`</ph> does not call the constructor method.</source>
          <target state="translated">Ao contrário de <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Newobj&gt;</ph>, <ph id="ph2">`initobj`</ph> não chama o método de construtor.</target>       </trans-unit>
        <trans-unit id="1980" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Initobj">
          <source><ph id="ph1">`Initobj`</ph> is intended for initializing value types, while <ph id="ph2">`newobj`</ph> is used to allocate and initialize objects.</source>
          <target state="translated"><ph id="ph1">`Initobj`</ph> é destinado ao inicializar os tipos de valor, enquanto <ph id="ph2">`newobj`</ph> é usada para alocar e inicializar objetos.</target>       </trans-unit>
        <trans-unit id="1981" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Initobj">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`initobj`</ph> opcode:</source>
          <target state="translated">O seguinte <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> sobrecarga de método pode usar o <ph id="ph2">`initobj`</ph> opcode:</target>       </trans-unit>
        <trans-unit id="1982" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Initobj">
          <source>ILGenerator.Emit(OpCode, Type)</source>
          <target state="translated">ILGenerator.Emit(OpCode, Type)</target>       </trans-unit>
        <trans-unit id="1983" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Isinst">
          <source>Tests whether an object reference (type <ph id="ph1">&lt;see langword="O" /&gt;</ph>) is an instance of a particular class.</source>
          <target state="translated">Testa se uma referência de objeto (tipo <ph id="ph1">&lt;see langword="O" /&gt;</ph>) é uma instância de uma classe específica.</target>       </trans-unit>
        <trans-unit id="1984" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Isinst">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">A tabela a seguir lista as instruções hexadecimal e formato de assembly do Microsoft Intermediate Language (MSIL), junto com um resumo breve de referência:</target>       </trans-unit>
        <trans-unit id="1985" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Isinst">
          <source>Format</source>
          <target state="translated">Formatar</target>       </trans-unit>
        <trans-unit id="1986" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Isinst">
          <source>Assembly Format</source>
          <target state="translated">Formato de assembly</target>       </trans-unit>
        <trans-unit id="1987" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Isinst">
          <source>Description</source>
          <target state="translated">Descrição</target>       </trans-unit>
        <trans-unit id="1988" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Isinst">
          <source>75 &lt; <ph id="ph1">`T`</ph><ph id="ph2"> &gt;</ph></source>
          <target state="translated">75 &lt; <ph id="ph1">`T`</ph><ph id="ph2"> &gt;</ph></target>       </trans-unit>
        <trans-unit id="1989" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Isinst">
          <source>isinst <ph id="ph1">`class`</ph></source>
          <target state="translated">isinst <ph id="ph1">`class`</ph></target>       </trans-unit>
        <trans-unit id="1990" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Isinst">
          <source>Tests if an object reference is an instance of <ph id="ph1">`class`</ph>, returning either a null reference or an instance of that class or interface.</source>
          <target state="translated">Testa se uma referência de objeto é uma instância de <ph id="ph1">`class`</ph>, retornando uma referência nula ou uma instância dessa classe ou interface.</target>       </trans-unit>
        <trans-unit id="1991" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Isinst">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">O comportamento de transição de pilha, em ordem sequencial, é:</target>       </trans-unit>
        <trans-unit id="1992" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Isinst">
          <source>An object reference is pushed onto the stack.</source>
          <target state="translated">Uma referência de objeto é inserida na pilha.</target>       </trans-unit>
        <trans-unit id="1993" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Isinst">
          <source>The object reference is popped from the stack and tested to see if it is an instance of the class passed in <ph id="ph1">`class`</ph>.</source>
          <target state="translated">A referência de objeto é exibida da pilha e testada para ver se ele é uma instância da classe passada <ph id="ph1">`class`</ph>.</target>       </trans-unit>
        <trans-unit id="1994" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Isinst">
          <source>The result (either an object reference or a null reference) is pushed onto the stack.</source>
          <target state="translated">O resultado (uma referência de objeto ou uma referência nula) é inserido na pilha.</target>       </trans-unit>
        <trans-unit id="1995" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Isinst">
          <source><ph id="ph1">`Class`</ph> is a metadata token indicating the desired class.</source>
          <target state="translated"><ph id="ph1">`Class`</ph> um token de metadados que indica a classe desejada.</target>       </trans-unit>
        <trans-unit id="1996" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Isinst">
          <source>If the class of the object on the top of the stack implements <ph id="ph1">`class`</ph> (if <ph id="ph2">`class`</ph> is an interface) or is a derived class of <ph id="ph3">`class`</ph> (if <ph id="ph4">`class`</ph> is a regular class) then it is cast to type <ph id="ph5">`class`</ph> and the result is pushed on the stack, exactly as though <ph id="ph6">&lt;xref:System.Reflection.Emit.OpCodes.Castclass&gt;</ph> had been called.</source>
          <target state="translated">Se a classe do objeto no topo da pilha implementa <ph id="ph1">`class`</ph> (se <ph id="ph2">`class`</ph> é uma interface) ou é uma classe derivada de <ph id="ph3">`class`</ph> (se <ph id="ph4">`class`</ph> é uma classe regular), em seguida, ela será convertida para o tipo <ph id="ph5">`class`</ph> e o resultado é enviada por push na pilha, exatamente como se <ph id="ph6">&lt;xref:System.Reflection.Emit.OpCodes.Castclass&gt;</ph> tivesse sido chamada.</target>       </trans-unit>
        <trans-unit id="1997" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Isinst">
          <source>Otherwise, a null reference is pushed on the stack.</source>
          <target state="translated">Caso contrário, uma referência nula é enviada por push na pilha.</target>       </trans-unit>
        <trans-unit id="1998" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Isinst">
          <source>If the object reference itself is a null reference, then <ph id="ph1">`isinst`</ph> likewise returns a null reference.</source>
          <target state="translated">Se a referência de objeto é uma referência nula, em seguida, <ph id="ph1">`isinst`</ph> da mesma forma, retorna uma referência nula.</target>       </trans-unit>
        <trans-unit id="1999" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Isinst">
          <source><ph id="ph1">&lt;xref:System.TypeLoadException&gt;</ph> is thrown if class cannot be found.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.TypeLoadException&gt;</ph> é gerada se a classe não pode ser encontrada.</target>       </trans-unit>
        <trans-unit id="2000" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Isinst">
          <source>This is typically detected when the Microsoft Intermediate Language (MSIL) instructions are converted to native code rather than at runtime.</source>
          <target state="translated">Normalmente, isso é detectado quando as instruções da Microsoft Intermediate Language (MSIL) são convertidas em código nativo em vez de em tempo de execução.</target>       </trans-unit>
        <trans-unit id="2001" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Isinst">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`isinst`</ph> opcode:</source>
          <target state="translated">O seguinte <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> sobrecarga de método pode usar o <ph id="ph2">`isinst`</ph> opcode:</target>       </trans-unit>
        <trans-unit id="2002" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Isinst">
          <source>ILGenerator.Emit(OpCode, Type)</source>
          <target state="translated">ILGenerator.Emit(OpCode, Type)</target>       </trans-unit>
        <trans-unit id="2003" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Jmp">
          <source>Exits current method and jumps to specified method.</source>
          <target state="translated">Sai do método atual e vai para o método especificado.</target>       </trans-unit>
        <trans-unit id="2004" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Jmp">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">A tabela a seguir lista as instruções hexadecimal e formato de assembly do Microsoft Intermediate Language (MSIL), junto com um resumo breve de referência:</target>       </trans-unit>
        <trans-unit id="2005" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Jmp">
          <source>Format</source>
          <target state="translated">Formatar</target>       </trans-unit>
        <trans-unit id="2006" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Jmp">
          <source>Assembly Format</source>
          <target state="translated">Formato de assembly</target>       </trans-unit>
        <trans-unit id="2007" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Jmp">
          <source>Description</source>
          <target state="translated">Descrição</target>       </trans-unit>
        <trans-unit id="2008" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Jmp">
          <source>27 &lt; <ph id="ph1">`T`</ph><ph id="ph2"> &gt;</ph></source>
          <target state="translated">27 &lt; <ph id="ph1">`T`</ph><ph id="ph2"> &gt;</ph></target>       </trans-unit>
        <trans-unit id="2009" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Jmp">
          <source>jmp <ph id="ph1">`method`</ph></source>
          <target state="translated">jmp <ph id="ph1">`method`</ph></target>       </trans-unit>
        <trans-unit id="2010" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Jmp">
          <source>Exit current method and jump to specified method.</source>
          <target state="translated">Saia do método atual e ir para o método especificado.</target>       </trans-unit>
        <trans-unit id="2011" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Jmp">
          <source>There are no stack transition behaviors for this instruction.</source>
          <target state="translated">Não há nenhuma pilha comportamentos de transição para essa instrução.</target>       </trans-unit>
        <trans-unit id="2012" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Jmp">
          <source>The <ph id="ph1">`jmp`</ph> (jump) instruction transfers control to the method specified by <ph id="ph2">`method`</ph>, which is a metadata token for a method reference.</source>
          <target state="translated">O <ph id="ph1">`jmp`</ph> instrução (salto) transfere o controle para o método especificado pelo <ph id="ph2">`method`</ph>, que é um token de metadados para uma referência de método.</target>       </trans-unit>
        <trans-unit id="2013" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Jmp">
          <source>The current arguments are transferred to the destination method.</source>
          <target state="translated">Os argumentos atuais são transferidos para o método de destino.</target>       </trans-unit>
        <trans-unit id="2014" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Jmp">
          <source>The evaluation stack must be empty when this instruction is executed.</source>
          <target state="translated">A pilha de avaliação deve estar vazia quando essa instrução é executada.</target>       </trans-unit>
        <trans-unit id="2015" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Jmp">
          <source>The calling convention, number and type of arguments at the destination address must match that of the current method.</source>
          <target state="translated">A chamada convenção, número e tipo de argumentos no endereço de destino devem corresponder do método atual.</target>       </trans-unit>
        <trans-unit id="2016" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Jmp">
          <source>The <ph id="ph1">`jmp`</ph> instruction cannot be used to transferred control out of a <ph id="ph2">`try`</ph>, <ph id="ph3">`filter`</ph>, <ph id="ph4">`catch`</ph>, or <ph id="ph5">`finally`</ph> block.</source>
          <target state="translated">O <ph id="ph1">`jmp`</ph> instrução não pode ser usada transferido controle fora de um <ph id="ph2">`try`</ph>, <ph id="ph3">`filter`</ph>, <ph id="ph4">`catch`</ph>, ou <ph id="ph5">`finally`</ph> bloco.</target>       </trans-unit>
        <trans-unit id="2017" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Jmp">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`jmp`</ph> opcode:</source>
          <target state="translated">O seguinte <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> sobrecarga de método pode usar o <ph id="ph2">`jmp`</ph> opcode:</target>       </trans-unit>
        <trans-unit id="2018" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Jmp">
          <source>ILGenerator.Emit(OpCode, MethodInfo)</source>
          <target state="translated">ILGenerator.Emit(OpCode, MethodInfo)</target>       </trans-unit>
        <trans-unit id="2019" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Ldarg">
          <source>Loads an argument (referenced by a specified index value) onto the stack.</source>
          <target state="translated">Carrega um argumento (referenciado por um valor de índice especificado) na pilha.</target>       </trans-unit>
        <trans-unit id="2020" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarg">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">A tabela a seguir lista as instruções hexadecimal e formato de assembly do Microsoft Intermediate Language (MSIL), junto com um resumo breve de referência:</target>       </trans-unit>
        <trans-unit id="2021" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarg">
          <source>Format</source>
          <target state="translated">Formatar</target>       </trans-unit>
        <trans-unit id="2022" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarg">
          <source>Assembly Format</source>
          <target state="translated">Formato de assembly</target>       </trans-unit>
        <trans-unit id="2023" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarg">
          <source>Description</source>
          <target state="translated">Descrição</target>       </trans-unit>
        <trans-unit id="2024" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarg">
          <source>FE 09 &lt; <ph id="ph1">`unsigned int16`</ph><ph id="ph2"> &gt;</ph></source>
          <target state="translated">FE 09 &lt; <ph id="ph1">`unsigned int16`</ph><ph id="ph2"> &gt;</ph></target>       </trans-unit>
        <trans-unit id="2025" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarg">
          <source>ldarg <ph id="ph1">`index`</ph></source>
          <target state="translated">ldarg <ph id="ph1">`index`</ph></target>       </trans-unit>
        <trans-unit id="2026" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarg">
          <source>Load argument at <ph id="ph1">`index`</ph> onto stack.</source>
          <target state="translated">Carregar o argumento na <ph id="ph1">`index`</ph> na pilha.</target>       </trans-unit>
        <trans-unit id="2027" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarg">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">O comportamento de transição de pilha, em ordem sequencial, é:</target>       </trans-unit>
        <trans-unit id="2028" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarg">
          <source>The argument value at <ph id="ph1">`index`</ph> is pushed onto the stack.</source>
          <target state="translated">O valor de argumento <ph id="ph1">`index`</ph> é inserido na pilha.</target>       </trans-unit>
        <trans-unit id="2029" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarg">
          <source>The <ph id="ph1">`ldarg`</ph> instruction pushes the argument indexed at <ph id="ph2">`index`</ph>, where arguments are indexed from 0 onwards, onto the evaluation stack.</source>
          <target state="translated">O <ph id="ph1">`ldarg`</ph> instrução envia o argumento indexado em <ph id="ph2">`index`</ph>, em que os argumentos são indexados de 0 em diante, para a pilha de avaliação.</target>       </trans-unit>
        <trans-unit id="2030" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarg">
          <source>The <ph id="ph1">`ldarg`</ph> instruction can be used to load a value type or a primitive value onto the stack by copying it from an incoming argument.</source>
          <target state="translated">O <ph id="ph1">`ldarg`</ph> instrução pode ser usada para carregar um tipo de valor ou um valor primitivo na pilha, copiando-os de um argumento de entrada.</target>       </trans-unit>
        <trans-unit id="2031" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarg">
          <source>The type of the argument value is the same as the type of the argument, as specified by the current method's signature.</source>
          <target state="translated">O tipo do valor do argumento é o mesmo que o tipo do argumento, conforme especificado pela assinatura do método atual.</target>       </trans-unit>
        <trans-unit id="2032" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarg">
          <source>For procedures that take a variable-length argument list, the <ph id="ph1">`ldarg`</ph> instruction can be used only for the initial fixed arguments, not those in the variable part of the signature (see the <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Arglist&gt;</ph> instruction for more details).</source>
          <target state="translated">Para procedimentos que usam uma lista de argumentos de comprimento variável, o <ph id="ph1">`ldarg`</ph> instrução pode ser usada apenas para inicial fixa argumentos, não os na variável parte da assinatura (consulte o <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Arglist&gt;</ph> instrução para obter mais detalhes).</target>       </trans-unit>
        <trans-unit id="2033" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarg">
          <source>Arguments that hold an integer value smaller than 4 bytes long are expanded to type <ph id="ph1">`int32`</ph> when they are loaded onto the stack.</source>
          <target state="translated">Argumentos que contêm um valor inteiro menor que 4 bytes de comprimento são expandidos para o tipo <ph id="ph1">`int32`</ph> quando eles são carregados para a pilha.</target>       </trans-unit>
        <trans-unit id="2034" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarg">
          <source>Floating-point values are expanded to their native size (type <ph id="ph1">`F`</ph>).</source>
          <target state="translated">Valores de ponto flutuante são expandidos para seu tamanho nativo (tipo <ph id="ph1">`F`</ph>).</target>       </trans-unit>
        <trans-unit id="2035" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarg">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`ldarg`</ph> opcode:</source>
          <target state="translated">O seguinte <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> sobrecarga de método pode usar o <ph id="ph2">`ldarg`</ph> opcode:</target>       </trans-unit>
        <trans-unit id="2036" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarg">
          <source>ILGenerator.Emit(OpCode, short)</source>
          <target state="translated">ILGenerator.Emit (OpCode, short)</target>       </trans-unit>
        <trans-unit id="2037" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Ldarg_0">
          <source>Loads the argument at index 0 onto the evaluation stack.</source>
          <target state="translated">Carrega o argumento no índice 0 na pilha de avaliação.</target>       </trans-unit>
        <trans-unit id="2038" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarg_0">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">A tabela a seguir lista as instruções hexadecimal e formato de assembly do Microsoft Intermediate Language (MSIL), junto com um resumo breve de referência:</target>       </trans-unit>
        <trans-unit id="2039" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarg_0">
          <source>Format</source>
          <target state="translated">Formatar</target>       </trans-unit>
        <trans-unit id="2040" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarg_0">
          <source>Assembly Format</source>
          <target state="translated">Formato de assembly</target>       </trans-unit>
        <trans-unit id="2041" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarg_0">
          <source>Description</source>
          <target state="translated">Descrição</target>       </trans-unit>
        <trans-unit id="2042" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarg_0">
          <source>02</source>
          <target state="translated">02</target>       </trans-unit>
        <trans-unit id="2043" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarg_0">
          <source>ldarg.0</source>
          <target state="translated">ldarg.0</target>       </trans-unit>
        <trans-unit id="2044" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarg_0">
          <source>Load argument 0 onto stack</source>
          <target state="translated">Carregar o argumento 0 para pilha</target>       </trans-unit>
        <trans-unit id="2045" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarg_0">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">O comportamento de transição de pilha, em ordem sequencial, é:</target>       </trans-unit>
        <trans-unit id="2046" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarg_0">
          <source>The argument value at index 0 is pushed onto the stack.</source>
          <target state="translated">O valor do argumento no índice 0 é inserido na pilha.</target>       </trans-unit>
        <trans-unit id="2047" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarg_0">
          <source>The <ph id="ph1">`ldarg.0`</ph> instruction is an efficient encoding for loading the argument value at index 0.</source>
          <target state="translated">O <ph id="ph1">`ldarg.0`</ph> instrução é uma codificação eficiente para carregar o valor do argumento no índice 0.</target>       </trans-unit>
        <trans-unit id="2048" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarg_0">
          <source>The <ph id="ph1">`ldarg.0`</ph> instruction pushes the argument indexed at 0 onto the evaluation stack.</source>
          <target state="translated">O <ph id="ph1">`ldarg.0`</ph> instrução envia o argumento indexado a 0 para a pilha de avaliação.</target>       </trans-unit>
        <trans-unit id="2049" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarg_0">
          <source>The <ph id="ph1">`ldarg.0`</ph> instruction can be used to load a value type or a primitive value onto the stack by copying it from an incoming argument.</source>
          <target state="translated">O <ph id="ph1">`ldarg.0`</ph> instrução pode ser usada para carregar um tipo de valor ou um valor primitivo na pilha, copiando-os de um argumento de entrada.</target>       </trans-unit>
        <trans-unit id="2050" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarg_0">
          <source>The type of the argument value is the same as the type of the argument, as specified by the current method's signature.</source>
          <target state="translated">O tipo do valor do argumento é o mesmo que o tipo do argumento, conforme especificado pela assinatura do método atual.</target>       </trans-unit>
        <trans-unit id="2051" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarg_0">
          <source>Arguments that hold an integer value smaller than 4 bytes long are expanded to type <ph id="ph1">`int32`</ph> when they are loaded onto the stack.</source>
          <target state="translated">Argumentos que contêm um valor inteiro menor que 4 bytes de comprimento são expandidos para o tipo <ph id="ph1">`int32`</ph> quando eles são carregados para a pilha.</target>       </trans-unit>
        <trans-unit id="2052" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarg_0">
          <source>Floating-point values are expanded to their native size (type <ph id="ph1">`F`</ph>).</source>
          <target state="translated">Valores de ponto flutuante são expandidos para seu tamanho nativo (tipo <ph id="ph1">`F`</ph>).</target>       </trans-unit>
        <trans-unit id="2053" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarg_0">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`ldarg.0`</ph> opcode:</source>
          <target state="translated">O seguinte <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> sobrecarga de método pode usar o <ph id="ph2">`ldarg.0`</ph> opcode:</target>       </trans-unit>
        <trans-unit id="2054" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarg_0">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="2055" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Ldarg_1">
          <source>Loads the argument at index 1 onto the evaluation stack.</source>
          <target state="translated">Carrega o argumento no índice 1 na pilha de avaliação.</target>       </trans-unit>
        <trans-unit id="2056" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarg_1">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">A tabela a seguir lista as instruções hexadecimal e formato de assembly do Microsoft Intermediate Language (MSIL), junto com um resumo breve de referência:</target>       </trans-unit>
        <trans-unit id="2057" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarg_1">
          <source>Format</source>
          <target state="translated">Formatar</target>       </trans-unit>
        <trans-unit id="2058" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarg_1">
          <source>Assembly Format</source>
          <target state="translated">Formato de assembly</target>       </trans-unit>
        <trans-unit id="2059" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarg_1">
          <source>Description</source>
          <target state="translated">Descrição</target>       </trans-unit>
        <trans-unit id="2060" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarg_1">
          <source>03</source>
          <target state="translated">03</target>       </trans-unit>
        <trans-unit id="2061" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarg_1">
          <source>ldarg.1</source>
          <target state="translated">ldarg.1</target>       </trans-unit>
        <trans-unit id="2062" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarg_1">
          <source>Load argument 1 onto stack.</source>
          <target state="translated">Carregar o argumento 1 na pilha.</target>       </trans-unit>
        <trans-unit id="2063" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarg_1">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">O comportamento de transição de pilha, em ordem sequencial, é:</target>       </trans-unit>
        <trans-unit id="2064" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarg_1">
          <source>The argument value at index 1 is pushed onto the stack.</source>
          <target state="translated">O valor do argumento no índice 1 é inserido na pilha.</target>       </trans-unit>
        <trans-unit id="2065" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarg_1">
          <source>The <ph id="ph1">`ldarg.1`</ph> instruction is an efficient encoding for loading the argument value at index 1.</source>
          <target state="translated">O <ph id="ph1">`ldarg.1`</ph> instrução é uma codificação eficiente para carregar o valor do argumento no índice 1.</target>       </trans-unit>
        <trans-unit id="2066" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarg_1">
          <source>The <ph id="ph1">`ldarg.1`</ph> instruction pushes the argument indexed at 1 onto the evaluation stack.</source>
          <target state="translated">O <ph id="ph1">`ldarg.1`</ph> instrução envia o argumento indexado em 1 para a pilha de avaliação.</target>       </trans-unit>
        <trans-unit id="2067" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarg_1">
          <source>The <ph id="ph1">`ldarg.1`</ph> instruction can be used to load a value type or a primitive value onto the stack by copying it from an incoming argument.</source>
          <target state="translated">O <ph id="ph1">`ldarg.1`</ph> instrução pode ser usada para carregar um tipo de valor ou um valor primitivo na pilha, copiando-os de um argumento de entrada.</target>       </trans-unit>
        <trans-unit id="2068" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarg_1">
          <source>The type of the argument value is the same as the type of the argument, as specified by the current method's signature.</source>
          <target state="translated">O tipo do valor do argumento é o mesmo que o tipo do argumento, conforme especificado pela assinatura do método atual.</target>       </trans-unit>
        <trans-unit id="2069" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarg_1">
          <source>Arguments that hold an integer value smaller than 4 bytes long are expanded to type <ph id="ph1">`int32`</ph> when they are loaded onto the stack.</source>
          <target state="translated">Argumentos que contêm um valor inteiro menor que 4 bytes de comprimento são expandidos para o tipo <ph id="ph1">`int32`</ph> quando eles são carregados para a pilha.</target>       </trans-unit>
        <trans-unit id="2070" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarg_1">
          <source>Floating-point values are expanded to their native size (type <ph id="ph1">`F`</ph>).</source>
          <target state="translated">Valores de ponto flutuante são expandidos para seu tamanho nativo (tipo <ph id="ph1">`F`</ph>).</target>       </trans-unit>
        <trans-unit id="2071" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarg_1">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`ldarg.1`</ph> opcode:</source>
          <target state="translated">O seguinte <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> sobrecarga de método pode usar o <ph id="ph2">`ldarg.1`</ph> opcode:</target>       </trans-unit>
        <trans-unit id="2072" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarg_1">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="2073" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Ldarg_2">
          <source>Loads the argument at index 2 onto the evaluation stack.</source>
          <target state="translated">Carrega o argumento no índice 2 na pilha de avaliação.</target>       </trans-unit>
        <trans-unit id="2074" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarg_2">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">A tabela a seguir lista as instruções hexadecimal e formato de assembly do Microsoft Intermediate Language (MSIL), junto com um resumo breve de referência:</target>       </trans-unit>
        <trans-unit id="2075" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarg_2">
          <source>Format</source>
          <target state="translated">Formatar</target>       </trans-unit>
        <trans-unit id="2076" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarg_2">
          <source>Assembly Format</source>
          <target state="translated">Formato de assembly</target>       </trans-unit>
        <trans-unit id="2077" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarg_2">
          <source>Description</source>
          <target state="translated">Descrição</target>       </trans-unit>
        <trans-unit id="2078" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarg_2">
          <source>04</source>
          <target state="translated">04</target>       </trans-unit>
        <trans-unit id="2079" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarg_2">
          <source>ldarg.2</source>
          <target state="translated">ldarg.2</target>       </trans-unit>
        <trans-unit id="2080" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarg_2">
          <source>Load argument 2 onto stack.</source>
          <target state="translated">Carregar argumento 2 na pilha.</target>       </trans-unit>
        <trans-unit id="2081" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarg_2">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">O comportamento de transição de pilha, em ordem sequencial, é:</target>       </trans-unit>
        <trans-unit id="2082" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarg_2">
          <source>The argument value at index 2 is pushed onto the stack.</source>
          <target state="translated">O valor do argumento no índice 2 é inserido na pilha.</target>       </trans-unit>
        <trans-unit id="2083" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarg_2">
          <source>The <ph id="ph1">`ldarg.2`</ph> instruction is an efficient encoding for loading the argument value at index 2.</source>
          <target state="translated">O <ph id="ph1">`ldarg.2`</ph> instrução é uma codificação eficiente para carregar o valor do argumento no índice 2.</target>       </trans-unit>
        <trans-unit id="2084" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarg_2">
          <source>The <ph id="ph1">`ldarg.2`</ph> instruction pushes the argument indexed at 2 onto the evaluation stack.</source>
          <target state="translated">O <ph id="ph1">`ldarg.2`</ph> instrução envia o argumento indexado em 2 para a pilha de avaliação.</target>       </trans-unit>
        <trans-unit id="2085" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarg_2">
          <source>The <ph id="ph1">`ldarg.2`</ph> instruction can be used to load a value type or a primitive value onto the stack by copying it from an incoming argument.</source>
          <target state="translated">O <ph id="ph1">`ldarg.2`</ph> instrução pode ser usada para carregar um tipo de valor ou um valor primitivo na pilha, copiando-os de um argumento de entrada.</target>       </trans-unit>
        <trans-unit id="2086" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarg_2">
          <source>The type of the argument value is the same as the type of the argument, as specified by the current method's signature.</source>
          <target state="translated">O tipo do valor do argumento é o mesmo que o tipo do argumento, conforme especificado pela assinatura do método atual.</target>       </trans-unit>
        <trans-unit id="2087" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarg_2">
          <source>Arguments that hold an integer value smaller than 4 bytes long are expanded to type <ph id="ph1">`int32`</ph> when they are loaded onto the stack.</source>
          <target state="translated">Argumentos que contêm um valor inteiro menor que 4 bytes de comprimento são expandidos para o tipo <ph id="ph1">`int32`</ph> quando eles são carregados para a pilha.</target>       </trans-unit>
        <trans-unit id="2088" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarg_2">
          <source>Floating-point values are expanded to their native size (type <ph id="ph1">`F`</ph>).</source>
          <target state="translated">Valores de ponto flutuante são expandidos para seu tamanho nativo (tipo <ph id="ph1">`F`</ph>).</target>       </trans-unit>
        <trans-unit id="2089" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarg_2">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`ldarg.2`</ph> opcode:</source>
          <target state="translated">O seguinte <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> sobrecarga de método pode usar o <ph id="ph2">`ldarg.2`</ph> opcode:</target>       </trans-unit>
        <trans-unit id="2090" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarg_2">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="2091" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Ldarg_3">
          <source>Loads the argument at index 3 onto the evaluation stack.</source>
          <target state="translated">Carrega o argumento no índice 3 na pilha de avaliação.</target>       </trans-unit>
        <trans-unit id="2092" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarg_3">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">A tabela a seguir lista as instruções hexadecimal e formato de assembly do Microsoft Intermediate Language (MSIL), junto com um resumo breve de referência:</target>       </trans-unit>
        <trans-unit id="2093" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarg_3">
          <source>Format</source>
          <target state="translated">Formatar</target>       </trans-unit>
        <trans-unit id="2094" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarg_3">
          <source>Assembly Format</source>
          <target state="translated">Formato de assembly</target>       </trans-unit>
        <trans-unit id="2095" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarg_3">
          <source>Description</source>
          <target state="translated">Descrição</target>       </trans-unit>
        <trans-unit id="2096" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarg_3">
          <source>05</source>
          <target state="translated">05</target>       </trans-unit>
        <trans-unit id="2097" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarg_3">
          <source>ldarg.3</source>
          <target state="translated">ldarg.3</target>       </trans-unit>
        <trans-unit id="2098" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarg_3">
          <source>Load argument 3 onto stack.</source>
          <target state="translated">Carregar argumento 3 na pilha.</target>       </trans-unit>
        <trans-unit id="2099" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarg_3">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">O comportamento de transição de pilha, em ordem sequencial, é:</target>       </trans-unit>
        <trans-unit id="2100" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarg_3">
          <source>The argument value at index 3 is pushed onto the stack.</source>
          <target state="translated">O valor do argumento no índice 3 é inserido na pilha.</target>       </trans-unit>
        <trans-unit id="2101" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarg_3">
          <source>The <ph id="ph1">`ldarg.3`</ph> instruction is an efficient encoding for loading the argument value at index 3.</source>
          <target state="translated">O <ph id="ph1">`ldarg.3`</ph> instrução é uma codificação eficiente para carregar o valor do argumento no índice 3.</target>       </trans-unit>
        <trans-unit id="2102" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarg_3">
          <source>The <ph id="ph1">`ldarg.3`</ph> instruction pushes the argument indexed at 3 onto the evaluation stack.</source>
          <target state="translated">O <ph id="ph1">`ldarg.3`</ph> instrução envia o argumento indexado em 3 para a pilha de avaliação.</target>       </trans-unit>
        <trans-unit id="2103" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarg_3">
          <source>The <ph id="ph1">`ldarg.3`</ph> instruction can be used to load a value type or a primitive value onto the stack by copying it from an incoming argument.</source>
          <target state="translated">O <ph id="ph1">`ldarg.3`</ph> instrução pode ser usada para carregar um tipo de valor ou um valor primitivo na pilha, copiando-os de um argumento de entrada.</target>       </trans-unit>
        <trans-unit id="2104" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarg_3">
          <source>The type of the argument value is the same as the type of the argument, as specified by the current method's signature.</source>
          <target state="translated">O tipo do valor do argumento é o mesmo que o tipo do argumento, conforme especificado pela assinatura do método atual.</target>       </trans-unit>
        <trans-unit id="2105" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarg_3">
          <source>Arguments that hold an integer value smaller than 4 bytes long are expanded to type <ph id="ph1">`int32`</ph> when they are loaded onto the stack.</source>
          <target state="translated">Argumentos que contêm um valor inteiro menor que 4 bytes de comprimento são expandidos para o tipo <ph id="ph1">`int32`</ph> quando eles são carregados para a pilha.</target>       </trans-unit>
        <trans-unit id="2106" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarg_3">
          <source>Floating-point values are expanded to their native size (type <ph id="ph1">`F`</ph>).</source>
          <target state="translated">Valores de ponto flutuante são expandidos para seu tamanho nativo (tipo <ph id="ph1">`F`</ph>).</target>       </trans-unit>
        <trans-unit id="2107" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarg_3">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`ldarg.3`</ph> opcode:</source>
          <target state="translated">O seguinte <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> sobrecarga de método pode usar o <ph id="ph2">`ldarg.3`</ph> opcode:</target>       </trans-unit>
        <trans-unit id="2108" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarg_3">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="2109" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Ldarg_S">
          <source>Loads the argument (referenced by a specified short form index) onto the evaluation stack.</source>
          <target state="translated">Carrega o argumento (referenciado por um índice de forma curta especificado) para a pilha de avaliação.</target>       </trans-unit>
        <trans-unit id="2110" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarg_S">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">A tabela a seguir lista as instruções hexadecimal e formato de assembly do Microsoft Intermediate Language (MSIL), junto com um resumo breve de referência:</target>       </trans-unit>
        <trans-unit id="2111" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarg_S">
          <source>Format</source>
          <target state="translated">Formatar</target>       </trans-unit>
        <trans-unit id="2112" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarg_S">
          <source>Assembly Format</source>
          <target state="translated">Formato de assembly</target>       </trans-unit>
        <trans-unit id="2113" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarg_S">
          <source>Description</source>
          <target state="translated">Descrição</target>       </trans-unit>
        <trans-unit id="2114" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarg_S">
          <source>0E &lt; <ph id="ph1">`unsigned int8`</ph><ph id="ph2"> &gt;</ph></source>
          <target state="translated">0E &lt; <ph id="ph1">`unsigned int8`</ph><ph id="ph2"> &gt;</ph></target>       </trans-unit>
        <trans-unit id="2115" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarg_S">
          <source>ldarg.s <ph id="ph1">`index`</ph></source>
          <target state="translated">ldarg.s <ph id="ph1">`index`</ph></target>       </trans-unit>
        <trans-unit id="2116" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarg_S">
          <source>Load argument at <ph id="ph1">`index`</ph> onto stack, short form.</source>
          <target state="translated">Carregar o argumento na <ph id="ph1">`index`</ph> na pilha, de forma abreviada.</target>       </trans-unit>
        <trans-unit id="2117" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarg_S">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">O comportamento de transição de pilha, em ordem sequencial, é:</target>       </trans-unit>
        <trans-unit id="2118" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarg_S">
          <source>The argument value at <ph id="ph1">`index`</ph> is pushed onto the stack.</source>
          <target state="translated">O valor de argumento <ph id="ph1">`index`</ph> é inserido na pilha.</target>       </trans-unit>
        <trans-unit id="2119" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarg_S">
          <source>The <ph id="ph1">`ldarg.s`</ph> instruction is an efficient encoding for loading arguments indexed from 4 through 255.</source>
          <target state="translated">O <ph id="ph1">`ldarg.s`</ph> instrução é uma codificação eficiente para carregar argumentos indexados de 4 a 255.</target>       </trans-unit>
        <trans-unit id="2120" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarg_S">
          <source>The <ph id="ph1">`ldarg.s`</ph> instruction pushes the argument indexed at <ph id="ph2">`index`</ph>, where arguments are indexed from 0 onwards, onto the evaluation stack.</source>
          <target state="translated">O <ph id="ph1">`ldarg.s`</ph> instrução envia o argumento indexado em <ph id="ph2">`index`</ph>, em que os argumentos são indexados de 0 em diante, para a pilha de avaliação.</target>       </trans-unit>
        <trans-unit id="2121" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarg_S">
          <source>The <ph id="ph1">`ldarg.s`</ph> instruction can be used to load a value type or a primitive value onto the stack by copying it from an incoming argument.</source>
          <target state="translated">O <ph id="ph1">`ldarg.s`</ph> instrução pode ser usada para carregar um tipo de valor ou um valor primitivo na pilha, copiando-os de um argumento de entrada.</target>       </trans-unit>
        <trans-unit id="2122" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarg_S">
          <source>The type of the argument value is the same as the type of the argument, as specified by the current method's signature.</source>
          <target state="translated">O tipo do valor do argumento é o mesmo que o tipo do argumento, conforme especificado pela assinatura do método atual.</target>       </trans-unit>
        <trans-unit id="2123" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarg_S">
          <source>For procedures that take a variable-length argument list, the <ph id="ph1">`ldarg.s`</ph> instruction can be used only for the initial fixed arguments, not those in the variable part of the signature (see the <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Arglist&gt;</ph> instruction for more details).</source>
          <target state="translated">Para procedimentos que usam uma lista de argumentos de comprimento variável, o <ph id="ph1">`ldarg.s`</ph> instrução pode ser usada apenas para inicial fixa argumentos, não os na variável parte da assinatura (consulte o <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Arglist&gt;</ph> instrução para obter mais detalhes).</target>       </trans-unit>
        <trans-unit id="2124" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarg_S">
          <source>Arguments that hold an integer value smaller than 4 bytes long are expanded to type <ph id="ph1">`int32`</ph> when they are loaded onto the stack.</source>
          <target state="translated">Argumentos que contêm um valor inteiro menor que 4 bytes de comprimento são expandidos para o tipo <ph id="ph1">`int32`</ph> quando eles são carregados para a pilha.</target>       </trans-unit>
        <trans-unit id="2125" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarg_S">
          <source>Floating-point values are expanded to their native size (type <ph id="ph1">`F`</ph>).</source>
          <target state="translated">Valores de ponto flutuante são expandidos para seu tamanho nativo (tipo <ph id="ph1">`F`</ph>).</target>       </trans-unit>
        <trans-unit id="2126" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarg_S">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`ldarg.s`</ph> opcode:</source>
          <target state="translated">O seguinte <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> sobrecarga de método pode usar o <ph id="ph2">`ldarg.s`</ph> opcode:</target>       </trans-unit>
        <trans-unit id="2127" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarg_S">
          <source>ILGenerator.Emit(OpCode, byte)</source>
          <target state="translated">ILGenerator.Emit (OpCode, byte)</target>       </trans-unit>
        <trans-unit id="2128" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Ldarga">
          <source>Load an argument address onto the evaluation stack.</source>
          <target state="translated">Carregar um endereço de argumento para a pilha de avaliação.</target>       </trans-unit>
        <trans-unit id="2129" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarga">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">A tabela a seguir lista as instruções hexadecimal e formato de assembly do Microsoft Intermediate Language (MSIL), junto com um resumo breve de referência:</target>       </trans-unit>
        <trans-unit id="2130" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarga">
          <source>Format</source>
          <target state="translated">Formatar</target>       </trans-unit>
        <trans-unit id="2131" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarga">
          <source>Assembly Format</source>
          <target state="translated">Formato de assembly</target>       </trans-unit>
        <trans-unit id="2132" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarga">
          <source>Description</source>
          <target state="translated">Descrição</target>       </trans-unit>
        <trans-unit id="2133" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarga">
          <source>FE 0A &lt; <ph id="ph1">`unsigned int16`</ph><ph id="ph2"> &gt;</ph></source>
          <target state="translated">FE 0A &lt; <ph id="ph1">`unsigned int16`</ph><ph id="ph2"> &gt;</ph></target>       </trans-unit>
        <trans-unit id="2134" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarga">
          <source>ldarga <ph id="ph1">`index`</ph></source>
          <target state="translated">ldarga <ph id="ph1">`index`</ph></target>       </trans-unit>
        <trans-unit id="2135" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarga">
          <source>Fetch the address of argument indexed by <ph id="ph1">`index`</ph>.</source>
          <target state="translated">Obter o endereço do argumento indexado por <ph id="ph1">`index`</ph>.</target>       </trans-unit>
        <trans-unit id="2136" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarga">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">O comportamento de transição de pilha, em ordem sequencial, é:</target>       </trans-unit>
        <trans-unit id="2137" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarga">
          <source>The address <ph id="ph1">`addr`</ph> of the argument indexed by <ph id="ph2">`index`</ph> is pushed onto the stack.</source>
          <target state="translated">O endereço <ph id="ph1">`addr`</ph> do argumento indexado por <ph id="ph2">`index`</ph> é inserido na pilha.</target>       </trans-unit>
        <trans-unit id="2138" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarga">
          <source>The <ph id="ph1">`ldarga`</ph> instruction fetches the address (of type <ph id="ph2">`*`</ph>) of the argument indexed by <ph id="ph3">`index`</ph>, where arguments are indexed from 0 onwards.</source>
          <target state="translated">O <ph id="ph1">`ldarga`</ph> instrução busca o endereço (do tipo <ph id="ph2">`*`</ph>) do argumento indexado por <ph id="ph3">`index`</ph>, em que os argumentos são indexados de 0 em diante.</target>       </trans-unit>
        <trans-unit id="2139" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarga">
          <source>The address <ph id="ph1">`addr`</ph> is always aligned to a natural boundary on the target machine.</source>
          <target state="translated">O endereço <ph id="ph1">`addr`</ph> sempre é alinhada a um limite natural no computador de destino.</target>       </trans-unit>
        <trans-unit id="2140" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarga">
          <source>For procedures that take a variable-length argument list, the <ph id="ph1">`ldarga`</ph> instruction can be used only for the initial fixed arguments, not those in the variable part of the signature.</source>
          <target state="translated">Para procedimentos que usam uma lista de argumentos de comprimento variável, o <ph id="ph1">`ldarga`</ph> instrução pode ser usada apenas para inicial fixa argumentos, não os na variável parte da assinatura.</target>       </trans-unit>
        <trans-unit id="2141" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarga">
          <source><ph id="ph1">`ldarga`</ph> is used for by-ref parameter passing.</source>
          <target state="translated"><ph id="ph1">`ldarga`</ph> é usado para a passagem de parâmetro pelo ref.</target>       </trans-unit>
        <trans-unit id="2142" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarga">
          <source>For other cases, <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Ldarg&gt;</ph> and <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Starg&gt;</ph> should be used.</source>
          <target state="translated">Em outros casos, <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Ldarg&gt;</ph> e <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Starg&gt;</ph> devem ser usados.</target>       </trans-unit>
        <trans-unit id="2143" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarga">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`ldarga`</ph> opcode:</source>
          <target state="translated">O seguinte <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> sobrecarga de método pode usar o <ph id="ph2">`ldarga`</ph> opcode:</target>       </trans-unit>
        <trans-unit id="2144" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarga">
          <source>ILGenerator.Emit(OpCode, short)</source>
          <target state="translated">ILGenerator.Emit (OpCode, short)</target>       </trans-unit>
        <trans-unit id="2145" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Ldarga_S">
          <source>Load an argument address, in short form, onto the evaluation stack.</source>
          <target state="translated">Carregar um endereço de argumento, na forma abreviada, para a pilha de avaliação.</target>       </trans-unit>
        <trans-unit id="2146" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarga_S">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">A tabela a seguir lista as instruções hexadecimal e formato de assembly do Microsoft Intermediate Language (MSIL), junto com um resumo breve de referência:</target>       </trans-unit>
        <trans-unit id="2147" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarga_S">
          <source>Format</source>
          <target state="translated">Formatar</target>       </trans-unit>
        <trans-unit id="2148" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarga_S">
          <source>Assembly Format</source>
          <target state="translated">Formato de assembly</target>       </trans-unit>
        <trans-unit id="2149" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarga_S">
          <source>Description</source>
          <target state="translated">Descrição</target>       </trans-unit>
        <trans-unit id="2150" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarga_S">
          <source>0F &lt; <ph id="ph1">`unsigned int8`</ph><ph id="ph2"> &gt;</ph></source>
          <target state="translated">0F &lt; <ph id="ph1">`unsigned int8`</ph><ph id="ph2"> &gt;</ph></target>       </trans-unit>
        <trans-unit id="2151" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarga_S">
          <source>ldarga.s <ph id="ph1">`index`</ph></source>
          <target state="translated">ldarga.s <ph id="ph1">`index`</ph></target>       </trans-unit>
        <trans-unit id="2152" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarga_S">
          <source>Fetch the address of argument indexed by <ph id="ph1">`index`</ph>, short form.</source>
          <target state="translated">Obter o endereço do argumento indexado por <ph id="ph1">`index`</ph>, forma abreviada.</target>       </trans-unit>
        <trans-unit id="2153" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarga_S">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">O comportamento de transição de pilha, em ordem sequencial, é:</target>       </trans-unit>
        <trans-unit id="2154" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarga_S">
          <source>The address <ph id="ph1">`addr`</ph> of the argument indexed by <ph id="ph2">`index`</ph> is pushed onto the stack.</source>
          <target state="translated">O endereço <ph id="ph1">`addr`</ph> do argumento indexado por <ph id="ph2">`index`</ph> é inserido na pilha.</target>       </trans-unit>
        <trans-unit id="2155" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarga_S">
          <source><ph id="ph1">`ldarga.s`</ph> (the short form of <ph id="ph2">`ldarga`</ph>) should be used for argument numbers 0 through 255, and is a more efficient encoding.</source>
          <target state="translated"><ph id="ph1">`ldarga.s`</ph> (a forma abreviada <ph id="ph2">`ldarga`</ph>) deve ser usado para números de argumento de 0 a 255, e é uma codificação mais eficiente.</target>       </trans-unit>
        <trans-unit id="2156" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarga_S">
          <source>The <ph id="ph1">`ldarga.s`</ph> instruction fetches the address (of type<ph id="ph2">`*`</ph>) of the argument indexed by <ph id="ph3">`index`</ph>, where arguments are indexed from 0 onwards.</source>
          <target state="translated">O <ph id="ph1">`ldarga.s`</ph> instrução busca o endereço (do tipo<ph id="ph2">`*`</ph>) do argumento indexado por <ph id="ph3">`index`</ph>, em que os argumentos são indexados de 0 em diante.</target>       </trans-unit>
        <trans-unit id="2157" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarga_S">
          <source>The address <ph id="ph1">`addr`</ph> is always aligned to a natural boundary on the target machine.</source>
          <target state="translated">O endereço <ph id="ph1">`addr`</ph> sempre é alinhada a um limite natural no computador de destino.</target>       </trans-unit>
        <trans-unit id="2158" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarga_S">
          <source>For procedures that take a variable-length argument list, the <ph id="ph1">`ldarga.s`</ph> instruction can be used only for the initial fixed arguments, not those in the variable part of the signature.</source>
          <target state="translated">Para procedimentos que usam uma lista de argumentos de comprimento variável, o <ph id="ph1">`ldarga.s`</ph> instrução pode ser usada apenas para inicial fixa argumentos, não os na variável parte da assinatura.</target>       </trans-unit>
        <trans-unit id="2159" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarga_S">
          <source><ph id="ph1">`ldarga.s`</ph> is used for by-ref parameter passing.</source>
          <target state="translated"><ph id="ph1">`ldarga.s`</ph> é usado para a passagem de parâmetro pelo ref.</target>       </trans-unit>
        <trans-unit id="2160" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarga_S">
          <source>For other cases, <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Ldarg_S&gt;</ph> and <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Starg_S&gt;</ph> should be used.</source>
          <target state="translated">Em outros casos, <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Ldarg_S&gt;</ph> e <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Starg_S&gt;</ph> devem ser usados.</target>       </trans-unit>
        <trans-unit id="2161" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarga_S">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`ldarga.s`</ph> opcode:</source>
          <target state="translated">O seguinte <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> sobrecarga de método pode usar o <ph id="ph2">`ldarga.s`</ph> opcode:</target>       </trans-unit>
        <trans-unit id="2162" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarga_S">
          <source>ILGenerator.Emit(OpCode, byte)</source>
          <target state="translated">ILGenerator.Emit (OpCode, byte)</target>       </trans-unit>
        <trans-unit id="2163" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4">
          <source>Pushes a supplied value of type <ph id="ph1">&lt;see langword="int32" /&gt;</ph> onto the evaluation stack as an <ph id="ph2">&lt;see langword="int32" /&gt;</ph>.</source>
          <target state="translated">Envia por push um valor do tipo <ph id="ph1">&lt;see langword="int32" /&gt;</ph> fornecido para a pilha de avaliação como um <ph id="ph2">&lt;see langword="int32" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2164" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">A tabela a seguir lista as instruções hexadecimal e formato de assembly do Microsoft Intermediate Language (MSIL), junto com um resumo breve de referência:</target>       </trans-unit>
        <trans-unit id="2165" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4">
          <source>Format</source>
          <target state="translated">Formatar</target>       </trans-unit>
        <trans-unit id="2166" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4">
          <source>Assembly Format</source>
          <target state="translated">Formato de assembly</target>       </trans-unit>
        <trans-unit id="2167" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4">
          <source>Description</source>
          <target state="translated">Descrição</target>       </trans-unit>
        <trans-unit id="2168" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4">
          <source>20 &lt; <ph id="ph1">`int32`</ph><ph id="ph2"> &gt;</ph></source>
          <target state="translated">20 &lt; <ph id="ph1">`int32`</ph><ph id="ph2"> &gt;</ph></target>       </trans-unit>
        <trans-unit id="2169" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4">
          <source>ldc.i4 <ph id="ph1">`num`</ph></source>
          <target state="translated">ldc.i4 <ph id="ph1">`num`</ph></target>       </trans-unit>
        <trans-unit id="2170" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4">
          <source>Pushes the value <ph id="ph1">`num`</ph> onto the stack.</source>
          <target state="translated">Envia o valor <ph id="ph1">`num`</ph> na pilha.</target>       </trans-unit>
        <trans-unit id="2171" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">O comportamento de transição de pilha, em ordem sequencial, é:</target>       </trans-unit>
        <trans-unit id="2172" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4">
          <source>The value <ph id="ph1">`num`</ph> is pushed onto the stack.</source>
          <target state="translated">O valor <ph id="ph1">`num`</ph> é inserido na pilha.</target>       </trans-unit>
        <trans-unit id="2173" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4">
          <source>Note that there are special short (and hence more efficient) encodings for the integers -128 through 127, and especially short encodings for -1 through 8.</source>
          <target state="translated">Observe que há codificações curtas (e, portanto, é mais eficientes) especiais para inteiros de -128 através de 127 e especialmente curtos codificações de -1 a 8.</target>       </trans-unit>
        <trans-unit id="2174" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4">
          <source>All short encodings push 4 byte integers on the stack.</source>
          <target state="translated">Todas as codificações curtas push inteiros de 4 bytes na pilha.</target>       </trans-unit>
        <trans-unit id="2175" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4">
          <source>Longer encodings are used for 8 byte integers and 4 and 8 byte floating-point numbers, as well as 4-byte values that do not fit in the short forms.</source>
          <target state="translated">Codificações mais são usadas para números inteiros de 8 bytes e 4 e 8 bytes, bem como valores de 4 bytes que não cabem em formulários de curto.</target>       </trans-unit>
        <trans-unit id="2176" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4">
          <source>There are three ways to push an 8 byte integer constant onto the stack</source>
          <target state="translated">Há três maneiras de enviar por push uma constante de inteiro de 8 bytes para a pilha</target>       </trans-unit>
        <trans-unit id="2177" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4">
          <source>Use the <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Ldc_I8&gt;</ph> instruction for constants that must be expressed in more than 32 bits.</source>
          <target state="translated">Use o <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Ldc_I8&gt;</ph> instruções para constantes que deve ser expressa em mais de 32 bits.</target>       </trans-unit>
        <trans-unit id="2178" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4">
          <source>Use the <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Ldc_I4&gt;</ph> instruction followed by a <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Conv_I8&gt;</ph> for constants that require 9 to 32 bits.</source>
          <target state="translated">Use o <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Ldc_I4&gt;</ph> instrução seguida por um <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Conv_I8&gt;</ph> para constantes que exigem 9 de 32 bits.</target>       </trans-unit>
        <trans-unit id="2179" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4">
          <source>Use a short form instruction followed by a <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Conv_I8&gt;</ph> for constants that can be expressed in 8 or fewer bits.</source>
          <target state="translated">Use uma instrução de forma abreviada, seguida por um <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Conv_I8&gt;</ph> para constantes que podem ser expressos em 8 ou menos bits.</target>       </trans-unit>
        <trans-unit id="2180" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`ldc.i4`</ph> opcode:</source>
          <target state="translated">O seguinte <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> sobrecarga de método pode usar o <ph id="ph2">`ldc.i4`</ph> opcode:</target>       </trans-unit>
        <trans-unit id="2181" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4">
          <source>ILGenerator.Emit(OpCode, int)</source>
          <target state="translated">ILGenerator.Emit (código de operação, int)</target>       </trans-unit>
        <trans-unit id="2182" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_0">
          <source>Pushes the integer value of 0 onto the evaluation stack as an <ph id="ph1">&lt;see langword="int32" /&gt;</ph>.</source>
          <target state="translated">Envia o valor inteiro de 0 para a pilha de avaliação como um <ph id="ph1">&lt;see langword="int32" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2183" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_0">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">A tabela a seguir lista as instruções hexadecimal e formato de assembly do Microsoft Intermediate Language (MSIL), junto com um resumo breve de referência:</target>       </trans-unit>
        <trans-unit id="2184" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_0">
          <source>Format</source>
          <target state="translated">Formatar</target>       </trans-unit>
        <trans-unit id="2185" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_0">
          <source>Assembly Format</source>
          <target state="translated">Formato de assembly</target>       </trans-unit>
        <trans-unit id="2186" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_0">
          <source>Description</source>
          <target state="translated">Descrição</target>       </trans-unit>
        <trans-unit id="2187" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_0">
          <source>16</source>
          <target state="translated">16</target>       </trans-unit>
        <trans-unit id="2188" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_0">
          <source>ldc.i4.0</source>
          <target state="translated">ldc.i4.0</target>       </trans-unit>
        <trans-unit id="2189" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_0">
          <source>Pushes 0 onto the stack.</source>
          <target state="translated">Envia 0 para a pilha.</target>       </trans-unit>
        <trans-unit id="2190" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_0">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">O comportamento de transição de pilha, em ordem sequencial, é:</target>       </trans-unit>
        <trans-unit id="2191" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_0">
          <source>The value 0 is pushed onto the stack.</source>
          <target state="translated">O valor 0 é inserido na pilha.</target>       </trans-unit>
        <trans-unit id="2192" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_0">
          <source>This is a special short encoding for the push of the integer value 0.</source>
          <target state="translated">Isso é uma codificação especial curto para o envio por push de valor inteiro de 0.</target>       </trans-unit>
        <trans-unit id="2193" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_0">
          <source>All special short encodings push 4 byte integers on the stack.</source>
          <target state="translated">Todas as codificações curtas especiais push inteiros de 4 bytes na pilha.</target>       </trans-unit>
        <trans-unit id="2194" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_0">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`ldc.i4.0`</ph> opcode:</source>
          <target state="translated">O seguinte <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> sobrecarga de método pode usar o <ph id="ph2">`ldc.i4.0`</ph> opcode:</target>       </trans-unit>
        <trans-unit id="2195" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_0">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="2196" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_1">
          <source>Pushes the integer value of 1 onto the evaluation stack as an <ph id="ph1">&lt;see langword="int32" /&gt;</ph>.</source>
          <target state="translated">Envia o valor inteiro 1 por push para a pilha de avaliação como um <ph id="ph1">&lt;see langword="int32" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2197" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_1">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">A tabela a seguir lista as instruções hexadecimal e formato de assembly do Microsoft Intermediate Language (MSIL), junto com um resumo breve de referência:</target>       </trans-unit>
        <trans-unit id="2198" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_1">
          <source>Format</source>
          <target state="translated">Formatar</target>       </trans-unit>
        <trans-unit id="2199" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_1">
          <source>Assembly Format</source>
          <target state="translated">Formato de assembly</target>       </trans-unit>
        <trans-unit id="2200" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_1">
          <source>Description</source>
          <target state="translated">Descrição</target>       </trans-unit>
        <trans-unit id="2201" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_1">
          <source>17</source>
          <target state="translated">17</target>       </trans-unit>
        <trans-unit id="2202" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_1">
          <source>ldc.i4.1</source>
          <target state="translated">ldc.i4.1</target>       </trans-unit>
        <trans-unit id="2203" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_1">
          <source>Pushes 1 onto the stack.</source>
          <target state="translated">Verificações em 1 para a pilha.</target>       </trans-unit>
        <trans-unit id="2204" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_1">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">O comportamento de transição de pilha, em ordem sequencial, é:</target>       </trans-unit>
        <trans-unit id="2205" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_1">
          <source>The value 1 is pushed onto the stack.</source>
          <target state="translated">O valor 1 é inserido na pilha.</target>       </trans-unit>
        <trans-unit id="2206" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_1">
          <source>This is a special short encoding for the push of the integer value 0.</source>
          <target state="translated">Isso é uma codificação especial curto para o envio por push de valor inteiro de 0.</target>       </trans-unit>
        <trans-unit id="2207" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_1">
          <source>All special short encodings push 4 byte integers on the stack.</source>
          <target state="translated">Todas as codificações curtas especiais push inteiros de 4 bytes na pilha.</target>       </trans-unit>
        <trans-unit id="2208" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_1">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`ldc.i4.1`</ph> opcode:</source>
          <target state="translated">O seguinte <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> sobrecarga de método pode usar o <ph id="ph2">`ldc.i4.1`</ph> opcode:</target>       </trans-unit>
        <trans-unit id="2209" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_1">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="2210" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_2">
          <source>Pushes the integer value of 2 onto the evaluation stack as an <ph id="ph1">&lt;see langword="int32" /&gt;</ph>.</source>
          <target state="translated">Efetua o push do valor inteiro de 2 para a pilha de avaliação como um <ph id="ph1">&lt;see langword="int32" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2211" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_2">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">A tabela a seguir lista as instruções hexadecimal e formato de assembly do Microsoft Intermediate Language (MSIL), junto com um resumo breve de referência:</target>       </trans-unit>
        <trans-unit id="2212" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_2">
          <source>Format</source>
          <target state="translated">Formatar</target>       </trans-unit>
        <trans-unit id="2213" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_2">
          <source>Assembly Format</source>
          <target state="translated">Formato de assembly</target>       </trans-unit>
        <trans-unit id="2214" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_2">
          <source>Description</source>
          <target state="translated">Descrição</target>       </trans-unit>
        <trans-unit id="2215" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_2">
          <source>18</source>
          <target state="translated">18</target>       </trans-unit>
        <trans-unit id="2216" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_2">
          <source>ldc.i4.2</source>
          <target state="translated">ldc.i4.2</target>       </trans-unit>
        <trans-unit id="2217" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_2">
          <source>Pushes 2 onto the stack.</source>
          <target state="translated">Envia o 2 na pilha.</target>       </trans-unit>
        <trans-unit id="2218" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_2">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">O comportamento de transição de pilha, em ordem sequencial, é:</target>       </trans-unit>
        <trans-unit id="2219" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_2">
          <source>The value 2 is pushed onto the stack.</source>
          <target state="translated">O valor 2 é inserido na pilha.</target>       </trans-unit>
        <trans-unit id="2220" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_2">
          <source>This is a special short encoding for the push of the integer value 0.</source>
          <target state="translated">Isso é uma codificação especial curto para o envio por push de valor inteiro de 0.</target>       </trans-unit>
        <trans-unit id="2221" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_2">
          <source>All special short encodings push 4 byte integers on the stack.</source>
          <target state="translated">Todas as codificações curtas especiais push inteiros de 4 bytes na pilha.</target>       </trans-unit>
        <trans-unit id="2222" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_2">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`ldc.i4.2`</ph> opcode:</source>
          <target state="translated">O seguinte <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> sobrecarga de método pode usar o <ph id="ph2">`ldc.i4.2`</ph> opcode:</target>       </trans-unit>
        <trans-unit id="2223" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_2">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="2224" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_3">
          <source>Pushes the integer value of 3 onto the evaluation stack as an <ph id="ph1">&lt;see langword="int32" /&gt;</ph>.</source>
          <target state="translated">Efetua o push do valor inteiro de 3 para a pilha de avaliação como um <ph id="ph1">&lt;see langword="int32" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2225" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_3">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">A tabela a seguir lista as instruções hexadecimal e formato de assembly do Microsoft Intermediate Language (MSIL), junto com um resumo breve de referência:</target>       </trans-unit>
        <trans-unit id="2226" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_3">
          <source>Format</source>
          <target state="translated">Formatar</target>       </trans-unit>
        <trans-unit id="2227" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_3">
          <source>Assembly Format</source>
          <target state="translated">Formato de assembly</target>       </trans-unit>
        <trans-unit id="2228" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_3">
          <source>Description</source>
          <target state="translated">Descrição</target>       </trans-unit>
        <trans-unit id="2229" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_3">
          <source>19</source>
          <target state="translated">19</target>       </trans-unit>
        <trans-unit id="2230" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_3">
          <source>ldc.i4.3</source>
          <target state="translated">ldc.i4.3</target>       </trans-unit>
        <trans-unit id="2231" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_3">
          <source>Pushes 3 onto the stack.</source>
          <target state="translated">Envia 3 para a pilha.</target>       </trans-unit>
        <trans-unit id="2232" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_3">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">O comportamento de transição de pilha, em ordem sequencial, é:</target>       </trans-unit>
        <trans-unit id="2233" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_3">
          <source>The value 3 is pushed onto the stack.</source>
          <target state="translated">O valor 3 é inserido na pilha.</target>       </trans-unit>
        <trans-unit id="2234" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_3">
          <source>This is a special short encoding for the push of the integer value 0.</source>
          <target state="translated">Isso é uma codificação especial curto para o envio por push de valor inteiro de 0.</target>       </trans-unit>
        <trans-unit id="2235" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_3">
          <source>All special short encodings push 4 byte integers on the stack.</source>
          <target state="translated">Todas as codificações curtas especiais push inteiros de 4 bytes na pilha.</target>       </trans-unit>
        <trans-unit id="2236" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_3">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`ldc.i4.3`</ph> opcode:</source>
          <target state="translated">O seguinte <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> sobrecarga de método pode usar o <ph id="ph2">`ldc.i4.3`</ph> opcode:</target>       </trans-unit>
        <trans-unit id="2237" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_3">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="2238" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_4">
          <source>Pushes the integer value of 4 onto the evaluation stack as an <ph id="ph1">&lt;see langword="int32" /&gt;</ph>.</source>
          <target state="translated">Efetua o push do valor inteiro de 4 para a pilha de avaliação como um <ph id="ph1">&lt;see langword="int32" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2239" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_4">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">A tabela a seguir lista as instruções hexadecimal e formato de assembly do Microsoft Intermediate Language (MSIL), junto com um resumo breve de referência:</target>       </trans-unit>
        <trans-unit id="2240" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_4">
          <source>Format</source>
          <target state="translated">Formatar</target>       </trans-unit>
        <trans-unit id="2241" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_4">
          <source>Assembly Format</source>
          <target state="translated">Formato de assembly</target>       </trans-unit>
        <trans-unit id="2242" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_4">
          <source>Description</source>
          <target state="translated">Descrição</target>       </trans-unit>
        <trans-unit id="2243" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_4">
          <source>1A</source>
          <target state="translated">1A</target>       </trans-unit>
        <trans-unit id="2244" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_4">
          <source>ldc.i4.4</source>
          <target state="translated">ldc.i4.4</target>       </trans-unit>
        <trans-unit id="2245" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_4">
          <source>Pushes 4 onto the stack.</source>
          <target state="translated">Envia 4 na pilha.</target>       </trans-unit>
        <trans-unit id="2246" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_4">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">O comportamento de transição de pilha, em ordem sequencial, é:</target>       </trans-unit>
        <trans-unit id="2247" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_4">
          <source>The value 4 is pushed onto the stack.</source>
          <target state="translated">O valor 4 é inserido na pilha.</target>       </trans-unit>
        <trans-unit id="2248" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_4">
          <source>This is a special short encoding for the push of the integer value 0.</source>
          <target state="translated">Isso é uma codificação especial curto para o envio por push de valor inteiro de 0.</target>       </trans-unit>
        <trans-unit id="2249" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_4">
          <source>All special short encodings push 4 byte integers on the stack.</source>
          <target state="translated">Todas as codificações curtas especiais push inteiros de 4 bytes na pilha.</target>       </trans-unit>
        <trans-unit id="2250" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_4">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`ldc.i4.4`</ph> opcode:</source>
          <target state="translated">O seguinte <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> sobrecarga de método pode usar o <ph id="ph2">`ldc.i4.4`</ph> opcode:</target>       </trans-unit>
        <trans-unit id="2251" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_4">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="2252" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_5">
          <source>Pushes the integer value of 5 onto the evaluation stack as an <ph id="ph1">&lt;see langword="int32" /&gt;</ph>.</source>
          <target state="translated">Efetua o push do valor inteiro de 5 para a pilha de avaliação como um <ph id="ph1">&lt;see langword="int32" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2253" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_5">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">A tabela a seguir lista as instruções hexadecimal e formato de assembly do Microsoft Intermediate Language (MSIL), junto com um resumo breve de referência:</target>       </trans-unit>
        <trans-unit id="2254" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_5">
          <source>Format</source>
          <target state="translated">Formatar</target>       </trans-unit>
        <trans-unit id="2255" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_5">
          <source>Assembly Format</source>
          <target state="translated">Formato de assembly</target>       </trans-unit>
        <trans-unit id="2256" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_5">
          <source>Description</source>
          <target state="translated">Descrição</target>       </trans-unit>
        <trans-unit id="2257" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_5">
          <source>1B</source>
          <target state="translated">1B</target>       </trans-unit>
        <trans-unit id="2258" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_5">
          <source>ldc.i4.5</source>
          <target state="translated">ldc.i4.5</target>       </trans-unit>
        <trans-unit id="2259" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_5">
          <source>Pushes 5 onto the stack.</source>
          <target state="translated">Envia a 5 para a pilha.</target>       </trans-unit>
        <trans-unit id="2260" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_5">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">O comportamento de transição de pilha, em ordem sequencial, é:</target>       </trans-unit>
        <trans-unit id="2261" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_5">
          <source>The value 5 is pushed onto the stack.</source>
          <target state="translated">O valor 5 é inserido na pilha.</target>       </trans-unit>
        <trans-unit id="2262" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_5">
          <source>This is a special short encoding for the push of the integer value 0.</source>
          <target state="translated">Isso é uma codificação especial curto para o envio por push de valor inteiro de 0.</target>       </trans-unit>
        <trans-unit id="2263" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_5">
          <source>All special short encodings push 4 byte integers on the stack.</source>
          <target state="translated">Todas as codificações curtas especiais push inteiros de 4 bytes na pilha.</target>       </trans-unit>
        <trans-unit id="2264" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_5">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`ldc.i4.5`</ph> opcode:</source>
          <target state="translated">O seguinte <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> sobrecarga de método pode usar o <ph id="ph2">`ldc.i4.5`</ph> opcode:</target>       </trans-unit>
        <trans-unit id="2265" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_5">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="2266" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_6">
          <source>Pushes the integer value of 6 onto the evaluation stack as an <ph id="ph1">&lt;see langword="int32" /&gt;</ph>.</source>
          <target state="translated">Efetua o push do valor inteiro de 6 para a pilha de avaliação como um <ph id="ph1">&lt;see langword="int32" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2267" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_6">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">A tabela a seguir lista as instruções hexadecimal e formato de assembly do Microsoft Intermediate Language (MSIL), junto com um resumo breve de referência:</target>       </trans-unit>
        <trans-unit id="2268" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_6">
          <source>Format</source>
          <target state="translated">Formatar</target>       </trans-unit>
        <trans-unit id="2269" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_6">
          <source>Assembly Format</source>
          <target state="translated">Formato de assembly</target>       </trans-unit>
        <trans-unit id="2270" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_6">
          <source>Description</source>
          <target state="translated">Descrição</target>       </trans-unit>
        <trans-unit id="2271" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_6">
          <source>1C</source>
          <target state="translated">1C</target>       </trans-unit>
        <trans-unit id="2272" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_6">
          <source>ldc.i4.6</source>
          <target state="translated">ldc.i4.6</target>       </trans-unit>
        <trans-unit id="2273" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_6">
          <source>Pushes 6 onto the stack.</source>
          <target state="translated">Envia a 6 para a pilha.</target>       </trans-unit>
        <trans-unit id="2274" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_6">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">O comportamento de transição de pilha, em ordem sequencial, é:</target>       </trans-unit>
        <trans-unit id="2275" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_6">
          <source>The value 6 is pushed onto the stack.</source>
          <target state="translated">O valor 6 é inserido na pilha.</target>       </trans-unit>
        <trans-unit id="2276" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_6">
          <source>This is a special short encoding for the push of the integer value 0.</source>
          <target state="translated">Isso é uma codificação especial curto para o envio por push de valor inteiro de 0.</target>       </trans-unit>
        <trans-unit id="2277" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_6">
          <source>All special short encodings push 4 byte integers on the stack.</source>
          <target state="translated">Todas as codificações curtas especiais push inteiros de 4 bytes na pilha.</target>       </trans-unit>
        <trans-unit id="2278" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_6">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`ldc.i4.6`</ph> opcode:</source>
          <target state="translated">O seguinte <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> sobrecarga de método pode usar o <ph id="ph2">`ldc.i4.6`</ph> opcode:</target>       </trans-unit>
        <trans-unit id="2279" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_6">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="2280" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_7">
          <source>Pushes the integer value of 7 onto the evaluation stack as an <ph id="ph1">&lt;see langword="int32" /&gt;</ph>.</source>
          <target state="translated">Efetua o push do valor inteiro de 7 para a pilha de avaliação como um <ph id="ph1">&lt;see langword="int32" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2281" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_7">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">A tabela a seguir lista as instruções hexadecimal e formato de assembly do Microsoft Intermediate Language (MSIL), junto com um resumo breve de referência:</target>       </trans-unit>
        <trans-unit id="2282" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_7">
          <source>Format</source>
          <target state="translated">Formatar</target>       </trans-unit>
        <trans-unit id="2283" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_7">
          <source>Assembly Format</source>
          <target state="translated">Formato de assembly</target>       </trans-unit>
        <trans-unit id="2284" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_7">
          <source>Description</source>
          <target state="translated">Descrição</target>       </trans-unit>
        <trans-unit id="2285" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_7">
          <source>1D</source>
          <target state="translated">1D</target>       </trans-unit>
        <trans-unit id="2286" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_7">
          <source>ldc.i4.7</source>
          <target state="translated">ldc.i4.7</target>       </trans-unit>
        <trans-unit id="2287" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_7">
          <source>Pushes 7 onto the stack.</source>
          <target state="translated">Envia a 7 na pilha.</target>       </trans-unit>
        <trans-unit id="2288" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_7">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">O comportamento de transição de pilha, em ordem sequencial, é:</target>       </trans-unit>
        <trans-unit id="2289" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_7">
          <source>The value 7 is pushed onto the stack.</source>
          <target state="translated">O valor 7 é inserido na pilha.</target>       </trans-unit>
        <trans-unit id="2290" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_7">
          <source>This is a special short encoding for the push of the integer value 0.</source>
          <target state="translated">Isso é uma codificação especial curto para o envio por push de valor inteiro de 0.</target>       </trans-unit>
        <trans-unit id="2291" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_7">
          <source>All special short encodings push 4 byte integers on the stack.</source>
          <target state="translated">Todas as codificações curtas especiais push inteiros de 4 bytes na pilha.</target>       </trans-unit>
        <trans-unit id="2292" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_7">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`ldc.i4.7`</ph> opcode:</source>
          <target state="translated">O seguinte <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> sobrecarga de método pode usar o <ph id="ph2">`ldc.i4.7`</ph> opcode:</target>       </trans-unit>
        <trans-unit id="2293" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_7">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="2294" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_8">
          <source>Pushes the integer value of 8 onto the evaluation stack as an <ph id="ph1">&lt;see langword="int32" /&gt;</ph>.</source>
          <target state="translated">Efetua o push do valor inteiro de 8 para a pilha de avaliação como um <ph id="ph1">&lt;see langword="int32" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2295" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_8">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">A tabela a seguir lista as instruções hexadecimal e formato de assembly do Microsoft Intermediate Language (MSIL), junto com um resumo breve de referência:</target>       </trans-unit>
        <trans-unit id="2296" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_8">
          <source>Format</source>
          <target state="translated">Formatar</target>       </trans-unit>
        <trans-unit id="2297" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_8">
          <source>Assembly Format</source>
          <target state="translated">Formato de assembly</target>       </trans-unit>
        <trans-unit id="2298" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_8">
          <source>Description</source>
          <target state="translated">Descrição</target>       </trans-unit>
        <trans-unit id="2299" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_8">
          <source>1E</source>
          <target state="translated">1E</target>       </trans-unit>
        <trans-unit id="2300" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_8">
          <source>ldc.i4.8</source>
          <target state="translated">ldc.i4.8</target>       </trans-unit>
        <trans-unit id="2301" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_8">
          <source>Pushes 8 onto the stack.</source>
          <target state="translated">Envia a 8 para a pilha.</target>       </trans-unit>
        <trans-unit id="2302" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_8">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">O comportamento de transição de pilha, em ordem sequencial, é:</target>       </trans-unit>
        <trans-unit id="2303" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_8">
          <source>The value 8 is pushed onto the stack.</source>
          <target state="translated">O valor 8 é inserido na pilha.</target>       </trans-unit>
        <trans-unit id="2304" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_8">
          <source>This is a special short encoding for the push of the integer value 0.</source>
          <target state="translated">Isso é uma codificação especial curto para o envio por push de valor inteiro de 0.</target>       </trans-unit>
        <trans-unit id="2305" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_8">
          <source>All special short encodings push 4 byte integers on the stack.</source>
          <target state="translated">Todas as codificações curtas especiais push inteiros de 4 bytes na pilha.</target>       </trans-unit>
        <trans-unit id="2306" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_8">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`ldc.i4.8`</ph> opcode:</source>
          <target state="translated">O seguinte <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> sobrecarga de método pode usar o <ph id="ph2">`ldc.i4.8`</ph> opcode:</target>       </trans-unit>
        <trans-unit id="2307" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_8">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="2308" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_M1">
          <source>Pushes the integer value of -1 onto the evaluation stack as an <ph id="ph1">&lt;see langword="int32" /&gt;</ph>.</source>
          <target state="translated">Efetua o push do valor de inteiro de -1 para a pilha de avaliação como um <ph id="ph1">&lt;see langword="int32" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2309" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_M1">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">A tabela a seguir lista as instruções hexadecimal e formato de assembly do Microsoft Intermediate Language (MSIL), junto com um resumo breve de referência:</target>       </trans-unit>
        <trans-unit id="2310" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_M1">
          <source>Format</source>
          <target state="translated">Formatar</target>       </trans-unit>
        <trans-unit id="2311" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_M1">
          <source>Assembly Format</source>
          <target state="translated">Formato de assembly</target>       </trans-unit>
        <trans-unit id="2312" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_M1">
          <source>Description</source>
          <target state="translated">Descrição</target>       </trans-unit>
        <trans-unit id="2313" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_M1">
          <source>15</source>
          <target state="translated">15</target>       </trans-unit>
        <trans-unit id="2314" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_M1">
          <source>ldc.i4.m1</source>
          <target state="translated">ldc.i4.m1</target>       </trans-unit>
        <trans-unit id="2315" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_M1">
          <source>Pushes -1 onto the stack.</source>
          <target state="translated">Envia -1 para a pilha.</target>       </trans-unit>
        <trans-unit id="2316" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_M1">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">O comportamento de transição de pilha, em ordem sequencial, é:</target>       </trans-unit>
        <trans-unit id="2317" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_M1">
          <source>The value -1 is pushed onto the stack.</source>
          <target state="translated">O valor -1 é inserido na pilha.</target>       </trans-unit>
        <trans-unit id="2318" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_M1">
          <source>This is a special short encoding for the push of the integer value 0.</source>
          <target state="translated">Isso é uma codificação especial curto para o envio por push de valor inteiro de 0.</target>       </trans-unit>
        <trans-unit id="2319" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_M1">
          <source>All special short encodings push 4 byte integers on the stack.</source>
          <target state="translated">Todas as codificações curtas especiais push inteiros de 4 bytes na pilha.</target>       </trans-unit>
        <trans-unit id="2320" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_M1">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`ldc.i4.m1`</ph> opcode:</source>
          <target state="translated">O seguinte <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> sobrecarga de método pode usar o <ph id="ph2">`ldc.i4.m1`</ph> opcode:</target>       </trans-unit>
        <trans-unit id="2321" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_M1">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="2322" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_S">
          <source>Pushes the supplied <ph id="ph1">&lt;see langword="int8" /&gt;</ph> value onto the evaluation stack as an <ph id="ph2">&lt;see langword="int32" /&gt;</ph>, short form.</source>
          <target state="translated">Envia o valor de <ph id="ph1">&lt;see langword="int8" /&gt;</ph> fornecido para a pilha de avaliação como um <ph id="ph2">&lt;see langword="int32" /&gt;</ph>, na forma abreviada.</target>       </trans-unit>
        <trans-unit id="2323" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_S">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">A tabela a seguir lista as instruções hexadecimal e formato de assembly do Microsoft Intermediate Language (MSIL), junto com um resumo breve de referência:</target>       </trans-unit>
        <trans-unit id="2324" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_S">
          <source>Format</source>
          <target state="translated">Formatar</target>       </trans-unit>
        <trans-unit id="2325" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_S">
          <source>Assembly Format</source>
          <target state="translated">Formato de assembly</target>       </trans-unit>
        <trans-unit id="2326" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_S">
          <source>Description</source>
          <target state="translated">Descrição</target>       </trans-unit>
        <trans-unit id="2327" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_S">
          <source>1F &lt; <ph id="ph1">`int8`</ph><ph id="ph2"> &gt;</ph></source>
          <target state="translated">1F &lt; <ph id="ph1">`int8`</ph><ph id="ph2"> &gt;</ph></target>       </trans-unit>
        <trans-unit id="2328" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_S">
          <source>ldc.i4.s <ph id="ph1">`num`</ph></source>
          <target state="translated">ldc.i4.s <ph id="ph1">`num`</ph></target>       </trans-unit>
        <trans-unit id="2329" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_S">
          <source>Pushes <ph id="ph1">`num`</ph> onto the stack as <ph id="ph2">`int32`</ph>, short form.</source>
          <target state="translated">Envia <ph id="ph1">`num`</ph> na pilha como <ph id="ph2">`int32`</ph>, forma abreviada.</target>       </trans-unit>
        <trans-unit id="2330" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_S">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">O comportamento de transição de pilha, em ordem sequencial, é:</target>       </trans-unit>
        <trans-unit id="2331" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_S">
          <source>The value <ph id="ph1">`num`</ph> is pushed onto the stack.</source>
          <target state="translated">O valor <ph id="ph1">`num`</ph> é inserido na pilha.</target>       </trans-unit>
        <trans-unit id="2332" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_S">
          <source><ph id="ph1">`ldc.i4.s`</ph> is a more efficient encoding for pushing the integers from -128 to 127 onto the evaluation stack.</source>
          <target state="translated"><ph id="ph1">`ldc.i4.s`</ph> é uma codificação mais eficiente para enviar os inteiros de -128 a 127 para a pilha de avaliação.</target>       </trans-unit>
        <trans-unit id="2333" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_S">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`ldc.i4.s`</ph> opcode:</source>
          <target state="translated">O seguinte <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> sobrecarga de método pode usar o <ph id="ph2">`ldc.i4.s`</ph> opcode:</target>       </trans-unit>
        <trans-unit id="2334" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_S">
          <source>ILGenerator.Emit(OpCode, byte)</source>
          <target state="translated">ILGenerator.Emit (OpCode, byte)</target>       </trans-unit>
        <trans-unit id="2335" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Ldc_I8">
          <source>Pushes a supplied value of type <ph id="ph1">&lt;see langword="int64" /&gt;</ph> onto the evaluation stack as an <ph id="ph2">&lt;see langword="int64" /&gt;</ph>.</source>
          <target state="translated">Envia por push um valor do tipo <ph id="ph1">&lt;see langword="int64" /&gt;</ph> fornecido para a pilha de avaliação como um <ph id="ph2">&lt;see langword="int64" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2336" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I8">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">A tabela a seguir lista as instruções hexadecimal e formato de assembly do Microsoft Intermediate Language (MSIL), junto com um resumo breve de referência:</target>       </trans-unit>
        <trans-unit id="2337" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I8">
          <source>Format</source>
          <target state="translated">Formatar</target>       </trans-unit>
        <trans-unit id="2338" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I8">
          <source>Assembly Format</source>
          <target state="translated">Formato de assembly</target>       </trans-unit>
        <trans-unit id="2339" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I8">
          <source>Description</source>
          <target state="translated">Descrição</target>       </trans-unit>
        <trans-unit id="2340" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I8">
          <source>21 &lt; <ph id="ph1">`int64`</ph><ph id="ph2"> &gt;</ph></source>
          <target state="translated">21 &lt; <ph id="ph1">`int64`</ph><ph id="ph2"> &gt;</ph></target>       </trans-unit>
        <trans-unit id="2341" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I8">
          <source>ldc.i8 <ph id="ph1">`num`</ph></source>
          <target state="translated">ldc.I8 <ph id="ph1">`num`</ph></target>       </trans-unit>
        <trans-unit id="2342" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I8">
          <source>Pushes <ph id="ph1">`num`</ph> onto the stack as <ph id="ph2">`int64`</ph>.</source>
          <target state="translated">Envia <ph id="ph1">`num`</ph> na pilha como <ph id="ph2">`int64`</ph>.</target>       </trans-unit>
        <trans-unit id="2343" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I8">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">O comportamento de transição de pilha, em ordem sequencial, é:</target>       </trans-unit>
        <trans-unit id="2344" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I8">
          <source>The value <ph id="ph1">`num`</ph> is pushed onto the stack.</source>
          <target state="translated">O valor <ph id="ph1">`num`</ph> é inserido na pilha.</target>       </trans-unit>
        <trans-unit id="2345" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I8">
          <source>This encoding pushes an <ph id="ph1">`int64`</ph> value onto the stack.</source>
          <target state="translated">Essa codificação envia um <ph id="ph1">`int64`</ph> valor para a pilha.</target>       </trans-unit>
        <trans-unit id="2346" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I8">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`ldc.i8`</ph> opcode:</source>
          <target state="translated">O seguinte <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> sobrecarga de método pode usar o <ph id="ph2">`ldc.i8`</ph> opcode:</target>       </trans-unit>
        <trans-unit id="2347" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I8">
          <source>ILGenerator.Emit(OpCode, long)</source>
          <target state="translated">ILGenerator.Emit (OpCode, long)</target>       </trans-unit>
        <trans-unit id="2348" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Ldc_R4">
          <source>Pushes a supplied value of type <ph id="ph1">&lt;see langword="float32" /&gt;</ph> onto the evaluation stack as type <ph id="ph2">&lt;see langword="F" /&gt;</ph> (float).</source>
          <target state="translated">Efetua o push de um valor fornecido do tipo <ph id="ph1">&lt;see langword="float32" /&gt;</ph> para a pilha de avaliação como tipo <ph id="ph2">&lt;see langword="F" /&gt;</ph> (float).</target>       </trans-unit>
        <trans-unit id="2349" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_R4">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">A tabela a seguir lista as instruções hexadecimal e formato de assembly do Microsoft Intermediate Language (MSIL), junto com um resumo breve de referência:</target>       </trans-unit>
        <trans-unit id="2350" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_R4">
          <source>Format</source>
          <target state="translated">Formatar</target>       </trans-unit>
        <trans-unit id="2351" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_R4">
          <source>Assembly Format</source>
          <target state="translated">Formato de assembly</target>       </trans-unit>
        <trans-unit id="2352" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_R4">
          <source>Description</source>
          <target state="translated">Descrição</target>       </trans-unit>
        <trans-unit id="2353" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_R4">
          <source>22 &lt; <ph id="ph1">`float32`</ph><ph id="ph2"> &gt;</ph></source>
          <target state="translated">22 &lt; <ph id="ph1">`float32`</ph><ph id="ph2"> &gt;</ph></target>       </trans-unit>
        <trans-unit id="2354" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_R4">
          <source>ldc.r4 <ph id="ph1">`num`</ph></source>
          <target state="translated">ldc.r4 <ph id="ph1">`num`</ph></target>       </trans-unit>
        <trans-unit id="2355" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_R4">
          <source>Pushes <ph id="ph1">`num`</ph> onto the stack as <ph id="ph2">`F`</ph>.</source>
          <target state="translated">Envia <ph id="ph1">`num`</ph> na pilha como <ph id="ph2">`F`</ph>.</target>       </trans-unit>
        <trans-unit id="2356" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_R4">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">O comportamento de transição de pilha, em ordem sequencial, é:</target>       </trans-unit>
        <trans-unit id="2357" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_R4">
          <source>The value <ph id="ph1">`num`</ph> is pushed onto the stack.</source>
          <target state="translated">O valor <ph id="ph1">`num`</ph> é inserido na pilha.</target>       </trans-unit>
        <trans-unit id="2358" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_R4">
          <source>This encoding pushes a <ph id="ph1">`float32`</ph> value onto the stack.</source>
          <target state="translated">Essa codificação envia um <ph id="ph1">`float32`</ph> valor para a pilha.</target>       </trans-unit>
        <trans-unit id="2359" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_R4">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`ldc.r4`</ph> opcode:</source>
          <target state="translated">O seguinte <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> sobrecarga de método pode usar o <ph id="ph2">`ldc.r4`</ph> opcode:</target>       </trans-unit>
        <trans-unit id="2360" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_R4">
          <source>ILGenerator.Emit(OpCode, single)</source>
          <target state="translated">ILGenerator.Emit (OpCode, único)</target>       </trans-unit>
        <trans-unit id="2361" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Ldc_R8">
          <source>Pushes a supplied value of type <ph id="ph1">&lt;see langword="float64" /&gt;</ph> onto the evaluation stack as type <ph id="ph2">&lt;see langword="F" /&gt;</ph> (float).</source>
          <target state="translated">Efetua o push de um valor fornecido do tipo <ph id="ph1">&lt;see langword="float64" /&gt;</ph> para a pilha de avaliação como tipo <ph id="ph2">&lt;see langword="F" /&gt;</ph> (float).</target>       </trans-unit>
        <trans-unit id="2362" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_R8">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">A tabela a seguir lista as instruções hexadecimal e formato de assembly do Microsoft Intermediate Language (MSIL), junto com um resumo breve de referência:</target>       </trans-unit>
        <trans-unit id="2363" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_R8">
          <source>Format</source>
          <target state="translated">Formatar</target>       </trans-unit>
        <trans-unit id="2364" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_R8">
          <source>Assembly Format</source>
          <target state="translated">Formato de assembly</target>       </trans-unit>
        <trans-unit id="2365" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_R8">
          <source>Description</source>
          <target state="translated">Descrição</target>       </trans-unit>
        <trans-unit id="2366" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_R8">
          <source>23 &lt; <ph id="ph1">`float64`</ph><ph id="ph2"> &gt;</ph></source>
          <target state="translated">23 &lt; <ph id="ph1">`float64`</ph><ph id="ph2"> &gt;</ph></target>       </trans-unit>
        <trans-unit id="2367" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_R8">
          <source>ldc.r8 <ph id="ph1">`num`</ph></source>
          <target state="translated">ldc.r8 <ph id="ph1">`num`</ph></target>       </trans-unit>
        <trans-unit id="2368" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_R8">
          <source>Pushes <ph id="ph1">`num`</ph> onto the stack as <ph id="ph2">`F`</ph>.</source>
          <target state="translated">Envia <ph id="ph1">`num`</ph> na pilha como <ph id="ph2">`F`</ph>.</target>       </trans-unit>
        <trans-unit id="2369" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_R8">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">O comportamento de transição de pilha, em ordem sequencial, é:</target>       </trans-unit>
        <trans-unit id="2370" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_R8">
          <source>The value <ph id="ph1">`num`</ph> is pushed onto the stack.</source>
          <target state="translated">O valor <ph id="ph1">`num`</ph> é inserido na pilha.</target>       </trans-unit>
        <trans-unit id="2371" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_R8">
          <source>This encoding pushes a <ph id="ph1">`float64`</ph> value onto the stack.</source>
          <target state="translated">Essa codificação envia um <ph id="ph1">`float64`</ph> valor para a pilha.</target>       </trans-unit>
        <trans-unit id="2372" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_R8">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`ldc.r8`</ph> opcode:</source>
          <target state="translated">O seguinte <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> sobrecarga de método pode usar o <ph id="ph2">`ldc.r8`</ph> opcode:</target>       </trans-unit>
        <trans-unit id="2373" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_R8">
          <source>ILGenerator.Emit(OpCode, double)</source>
          <target state="translated">ILGenerator.Emit (OpCode, double)</target>       </trans-unit>
        <trans-unit id="2374" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Ldelem">
          <source>Loads the element at a specified array index onto the top of the evaluation stack as the type specified in the instruction.</source>
          <target state="translated">Carrega o elemento a um índice de matriz especificado na parte superior da pilha de avaliação como o tipo especificado na instrução.</target>       </trans-unit>
        <trans-unit id="2375" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem">
          <source>The following table lists the instruction's hexadecimal and Microsoft intermediate language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">A tabela a seguir lista a instrução hexadecimal e formato de assembly Microsoft intermediate language (MSIL), junto com um resumo breve de referência:</target>       </trans-unit>
        <trans-unit id="2376" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem">
          <source>Format</source>
          <target state="translated">Formatar</target>       </trans-unit>
        <trans-unit id="2377" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem">
          <source>Assembly Format</source>
          <target state="translated">Formato de assembly</target>       </trans-unit>
        <trans-unit id="2378" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem">
          <source>Description</source>
          <target state="translated">Descrição</target>       </trans-unit>
        <trans-unit id="2379" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem">
          <source>A3 &lt; <ph id="ph1">`T`</ph><ph id="ph2"> &gt;</ph></source>
          <target state="translated">A3 &lt; <ph id="ph1">`T`</ph><ph id="ph2"> &gt;</ph></target>       </trans-unit>
        <trans-unit id="2380" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem">
          <source>ldelem <ph id="ph1">`typeTok`</ph></source>
          <target state="translated">Ldelem <ph id="ph1">`typeTok`</ph></target>       </trans-unit>
        <trans-unit id="2381" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem">
          <source>Loads the element at <ph id="ph1">`index`</ph> onto the top of the stack as type <ph id="ph2">`typeTok`</ph>.</source>
          <target state="translated">Carrega o elemento no <ph id="ph1">`index`</ph> na parte superior da pilha como tipo <ph id="ph2">`typeTok`</ph>.</target>       </trans-unit>
        <trans-unit id="2382" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">O comportamento de transição de pilha, em ordem sequencial, é:</target>       </trans-unit>
        <trans-unit id="2383" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem">
          <source>An object reference <ph id="ph1">`array`</ph> is pushed onto the stack.</source>
          <target state="translated">Uma referência de objeto <ph id="ph1">`array`</ph> é inserido na pilha.</target>       </trans-unit>
        <trans-unit id="2384" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem">
          <source>An index value <ph id="ph1">`index`</ph> is pushed onto the stack.</source>
          <target state="translated">Um valor de índice <ph id="ph1">`index`</ph> é inserido na pilha.</target>       </trans-unit>
        <trans-unit id="2385" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem">
          <source><ph id="ph1">`index`</ph> and <ph id="ph2">`array`</ph> are popped from the stack; the value stored at position <ph id="ph3">`index`</ph> in <ph id="ph4">`array`</ph> is looked up.</source>
          <target state="translated"><ph id="ph1">`index`</ph> e <ph id="ph2">`array`</ph> são disparados da pilha; o valor armazenado na posição <ph id="ph3">`index`</ph> em <ph id="ph4">`array`</ph> é pesquisada.</target>       </trans-unit>
        <trans-unit id="2386" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem">
          <source>The value is pushed onto the stack.</source>
          <target state="translated">O valor é inserido na pilha.</target>       </trans-unit>
        <trans-unit id="2387" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem">
          <source>The <ph id="ph1">`ldelem`</ph> instruction loads the value of the element with index <ph id="ph2">`index`</ph> (type <ph id="ph3">`native int`</ph>) in the zero-based one-dimensional array <ph id="ph4">`array`</ph> and places it on the top of the stack.</source>
          <target state="translated">O <ph id="ph1">`ldelem`</ph> instrução carrega o valor do elemento com index <ph id="ph2">`index`</ph> (tipo <ph id="ph3">`native int`</ph>) na matriz unidimensional de base zero <ph id="ph4">`array`</ph> e o coloca na parte superior da pilha.</target>       </trans-unit>
        <trans-unit id="2388" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem">
          <source>Arrays are objects, and hence represented by a value of type <ph id="ph1">`O`</ph>.</source>
          <target state="translated">Matrizes de objetos e, portanto, é representado por um valor do tipo <ph id="ph1">`O`</ph>.</target>       </trans-unit>
        <trans-unit id="2389" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem">
          <source>The type of the return value is specified by the token <ph id="ph1">`typeTok`</ph> in the instruction.</source>
          <target state="translated">O tipo do valor de retorno é especificado pelo token <ph id="ph1">`typeTok`</ph> na instrução.</target>       </trans-unit>
        <trans-unit id="2390" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem">
          <source><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> is thrown if <ph id="ph2">`array`</ph> is a null reference.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> será gerada se <ph id="ph2">`array`</ph> é uma referência nula.</target>       </trans-unit>
        <trans-unit id="2391" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem">
          <source><ph id="ph1">&lt;xref:System.IndexOutOfRangeException&gt;</ph> is thrown if <ph id="ph2">`index`</ph> is negative, or larger than the upper bound of <ph id="ph3">`array`</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.IndexOutOfRangeException&gt;</ph> será gerada se <ph id="ph2">`index`</ph> é negativo ou maior que o limite superior de <ph id="ph3">`array`</ph>.</target>       </trans-unit>
        <trans-unit id="2392" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`ldelem`</ph> opcode:</source>
          <target state="translated">O seguinte <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> sobrecarga de método pode usar o <ph id="ph2">`ldelem`</ph> opcode:</target>       </trans-unit>
        <trans-unit id="2393" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem">
          <source>ILGenerator.Emit(OpCode, Type)</source>
          <target state="translated">ILGenerator.Emit(OpCode, Type)</target>       </trans-unit>
        <trans-unit id="2394" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I">
          <source>Loads the element with type <ph id="ph1">&lt;see langword="native int" /&gt;</ph> at a specified array index onto the top of the evaluation stack as a <ph id="ph2">&lt;see langword="native int" /&gt;</ph>.</source>
          <target state="translated">Carrega o elemento com o tipo <ph id="ph1">&lt;see langword="native int" /&gt;</ph> em um índice de matriz especificado para o topo da pilha de avaliação como um <ph id="ph2">&lt;see langword="native int" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2395" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">A tabela a seguir lista as instruções hexadecimal e formato de assembly do Microsoft Intermediate Language (MSIL), junto com um resumo breve de referência:</target>       </trans-unit>
        <trans-unit id="2396" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I">
          <source>Format</source>
          <target state="translated">Formatar</target>       </trans-unit>
        <trans-unit id="2397" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I">
          <source>Assembly Format</source>
          <target state="translated">Formato de assembly</target>       </trans-unit>
        <trans-unit id="2398" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I">
          <source>Description</source>
          <target state="translated">Descrição</target>       </trans-unit>
        <trans-unit id="2399" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I">
          <source>97</source>
          <target state="translated">97</target>       </trans-unit>
        <trans-unit id="2400" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I">
          <source>ldelem.i</source>
          <target state="translated">ldelem.i</target>       </trans-unit>
        <trans-unit id="2401" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I">
          <source>Loads the element with type <ph id="ph1">`native int`</ph> at <ph id="ph2">`index`</ph> onto the top of the stack as a <ph id="ph3">`native int`</ph>.</source>
          <target state="translated">Carrega o elemento com o tipo <ph id="ph1">`native int`</ph> em <ph id="ph2">`index`</ph> na parte superior da pilha de como um <ph id="ph3">`native int`</ph>.</target>       </trans-unit>
        <trans-unit id="2402" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">O comportamento de transição de pilha, em ordem sequencial, é:</target>       </trans-unit>
        <trans-unit id="2403" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I">
          <source>An object reference <ph id="ph1">`array`</ph> is pushed onto the stack.</source>
          <target state="translated">Uma referência de objeto <ph id="ph1">`array`</ph> é inserido na pilha.</target>       </trans-unit>
        <trans-unit id="2404" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I">
          <source>An index value <ph id="ph1">`index`</ph> is pushed onto the stack.</source>
          <target state="translated">Um valor de índice <ph id="ph1">`index`</ph> é inserido na pilha.</target>       </trans-unit>
        <trans-unit id="2405" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I">
          <source><ph id="ph1">`index`</ph> and <ph id="ph2">`array`</ph> are popped from the stack; the value stored at position <ph id="ph3">`index`</ph> in <ph id="ph4">`array`</ph> is looked up.</source>
          <target state="translated"><ph id="ph1">`index`</ph> e <ph id="ph2">`array`</ph> são disparados da pilha; o valor armazenado na posição <ph id="ph3">`index`</ph> em <ph id="ph4">`array`</ph> é pesquisada.</target>       </trans-unit>
        <trans-unit id="2406" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I">
          <source>The value is pushed onto the stack.</source>
          <target state="translated">O valor é inserido na pilha.</target>       </trans-unit>
        <trans-unit id="2407" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I">
          <source>The <ph id="ph1">`ldelem.i`</ph> instruction loads the value of the element with index <ph id="ph2">`index`</ph> (type <ph id="ph3">`native int`</ph>) in the zero-based one-dimensional array <ph id="ph4">`array`</ph> and places it on the top of the stack.</source>
          <target state="translated">O <ph id="ph1">`ldelem.i`</ph> instrução carrega o valor do elemento com index <ph id="ph2">`index`</ph> (tipo <ph id="ph3">`native int`</ph>) na matriz unidimensional de base zero <ph id="ph4">`array`</ph> e o coloca na parte superior da pilha.</target>       </trans-unit>
        <trans-unit id="2408" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I">
          <source>Arrays are objects and hence represented by a value of type <ph id="ph1">`O`</ph>.</source>
          <target state="translated">Matrizes de objetos e, portanto, é representado por um valor do tipo <ph id="ph1">`O`</ph>.</target>       </trans-unit>
        <trans-unit id="2409" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I">
          <source>The return value for <ph id="ph1">`ldelem.i`</ph> is <ph id="ph2">`native int`</ph>.</source>
          <target state="translated">O valor de retorno <ph id="ph1">`ldelem.i`</ph> é <ph id="ph2">`native int`</ph>.</target>       </trans-unit>
        <trans-unit id="2410" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I">
          <source>Note that integer values of less than 4 bytes are extended to <ph id="ph1">`int32`</ph> (not <ph id="ph2">`native int`</ph>) when they are loaded onto the evaluation stack.</source>
          <target state="translated">Observe que os valores inteiros de menos de 4 bytes são estendidos para <ph id="ph1">`int32`</ph> (não <ph id="ph2">`native int`</ph>) quando eles são carregados para a pilha de avaliação.</target>       </trans-unit>
        <trans-unit id="2411" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I">
          <source><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> is thrown if <ph id="ph2">`array`</ph> is a null reference.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> será gerada se <ph id="ph2">`array`</ph> é uma referência nula.</target>       </trans-unit>
        <trans-unit id="2412" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I">
          <source><ph id="ph1">&lt;xref:System.ArrayTypeMismatchException&gt;</ph> is thrown if <ph id="ph2">`array`</ph> does not hold elements of the required type.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.ArrayTypeMismatchException&gt;</ph> será gerada se <ph id="ph2">`array`</ph> não contém elementos do tipo necessário.</target>       </trans-unit>
        <trans-unit id="2413" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I">
          <source><ph id="ph1">&lt;xref:System.IndexOutOfRangeException&gt;</ph> is thrown if <ph id="ph2">`index`</ph> is negative, or larger than the bound of <ph id="ph3">`array`</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.IndexOutOfRangeException&gt;</ph> será gerada se <ph id="ph2">`index`</ph> é negativo ou maior que o limite de <ph id="ph3">`array`</ph>.</target>       </trans-unit>
        <trans-unit id="2414" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`ldelem.i`</ph> opcode:</source>
          <target state="translated">O seguinte <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> sobrecarga de método pode usar o <ph id="ph2">`ldelem.i`</ph> opcode:</target>       </trans-unit>
        <trans-unit id="2415" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="2416" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I1">
          <source>Loads the element with type <ph id="ph1">&lt;see langword="int8" /&gt;</ph> at a specified array index onto the top of the evaluation stack as an <ph id="ph2">&lt;see langword="int32" /&gt;</ph>.</source>
          <target state="translated">Carrega o elemento com o tipo <ph id="ph1">&lt;see langword="int8" /&gt;</ph> em um índice de matriz especificado para o topo da pilha de avaliação como um <ph id="ph2">&lt;see langword="int32" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2417" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I1">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">A tabela a seguir lista as instruções hexadecimal e formato de assembly do Microsoft Intermediate Language (MSIL), junto com um resumo breve de referência:</target>       </trans-unit>
        <trans-unit id="2418" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I1">
          <source>Format</source>
          <target state="translated">Formatar</target>       </trans-unit>
        <trans-unit id="2419" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I1">
          <source>Assembly Format</source>
          <target state="translated">Formato de assembly</target>       </trans-unit>
        <trans-unit id="2420" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I1">
          <source>Description</source>
          <target state="translated">Descrição</target>       </trans-unit>
        <trans-unit id="2421" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I1">
          <source>90</source>
          <target state="translated">90</target>       </trans-unit>
        <trans-unit id="2422" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I1">
          <source>ldelem.i1</source>
          <target state="translated">ldelem.i1</target>       </trans-unit>
        <trans-unit id="2423" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I1">
          <source>Loads the element with type <ph id="ph1">`int8`</ph> at <ph id="ph2">`index`</ph> onto the top of the stack as an <ph id="ph3">`int32`</ph>.</source>
          <target state="translated">Carrega o elemento com o tipo <ph id="ph1">`int8`</ph> em <ph id="ph2">`index`</ph> na parte superior da pilha de como um <ph id="ph3">`int32`</ph>.</target>       </trans-unit>
        <trans-unit id="2424" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I1">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">O comportamento de transição de pilha, em ordem sequencial, é:</target>       </trans-unit>
        <trans-unit id="2425" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I1">
          <source>An object reference <ph id="ph1">`array`</ph> is pushed onto the stack.</source>
          <target state="translated">Uma referência de objeto <ph id="ph1">`array`</ph> é inserido na pilha.</target>       </trans-unit>
        <trans-unit id="2426" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I1">
          <source>An index value <ph id="ph1">`index`</ph> is pushed onto the stack.</source>
          <target state="translated">Um valor de índice <ph id="ph1">`index`</ph> é inserido na pilha.</target>       </trans-unit>
        <trans-unit id="2427" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I1">
          <source><ph id="ph1">`index`</ph> and <ph id="ph2">`array`</ph> are popped from the stack; the value stored at position <ph id="ph3">`index`</ph> in <ph id="ph4">`array`</ph> is looked up.</source>
          <target state="translated"><ph id="ph1">`index`</ph> e <ph id="ph2">`array`</ph> são disparados da pilha; o valor armazenado na posição <ph id="ph3">`index`</ph> em <ph id="ph4">`array`</ph> é pesquisada.</target>       </trans-unit>
        <trans-unit id="2428" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I1">
          <source>The value is pushed onto the stack.</source>
          <target state="translated">O valor é inserido na pilha.</target>       </trans-unit>
        <trans-unit id="2429" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I1">
          <source>The <ph id="ph1">`ldelem.i1`</ph> instruction loads the value of the element with index <ph id="ph2">`index`</ph> (type <ph id="ph3">`native int`</ph>) in the zero-based one-dimensional array <ph id="ph4">`array`</ph> and places it on the top of the stack.</source>
          <target state="translated">O <ph id="ph1">`ldelem.i1`</ph> instrução carrega o valor do elemento com index <ph id="ph2">`index`</ph> (tipo <ph id="ph3">`native int`</ph>) na matriz unidimensional de base zero <ph id="ph4">`array`</ph> e o coloca na parte superior da pilha.</target>       </trans-unit>
        <trans-unit id="2430" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I1">
          <source>Arrays are objects and hence represented by a value of type <ph id="ph1">`O`</ph>.</source>
          <target state="translated">Matrizes de objetos e, portanto, é representado por um valor do tipo <ph id="ph1">`O`</ph>.</target>       </trans-unit>
        <trans-unit id="2431" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I1">
          <source>The return value for <ph id="ph1">`ldelem.i1`</ph> is <ph id="ph2">`int8`</ph>.</source>
          <target state="translated">O valor de retorno <ph id="ph1">`ldelem.i1`</ph> é <ph id="ph2">`int8`</ph>.</target>       </trans-unit>
        <trans-unit id="2432" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I1">
          <source>Note that integer values of less than 4 bytes are extended to <ph id="ph1">`int32`</ph> (not <ph id="ph2">`native int`</ph>) when they are loaded onto the evaluation stack.</source>
          <target state="translated">Observe que os valores inteiros de menos de 4 bytes são estendidos para <ph id="ph1">`int32`</ph> (não <ph id="ph2">`native int`</ph>) quando eles são carregados para a pilha de avaliação.</target>       </trans-unit>
        <trans-unit id="2433" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I1">
          <source><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> is thrown if <ph id="ph2">`array`</ph> is a null reference.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> será gerada se <ph id="ph2">`array`</ph> é uma referência nula.</target>       </trans-unit>
        <trans-unit id="2434" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I1">
          <source><ph id="ph1">&lt;xref:System.ArrayTypeMismatchException&gt;</ph> is thrown if <ph id="ph2">`array`</ph> does not hold elements of the required type.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.ArrayTypeMismatchException&gt;</ph> será gerada se <ph id="ph2">`array`</ph> não contém elementos do tipo necessário.</target>       </trans-unit>
        <trans-unit id="2435" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I1">
          <source><ph id="ph1">&lt;xref:System.IndexOutOfRangeException&gt;</ph> is thrown if <ph id="ph2">`index`</ph> is negative, or larger than the bound of <ph id="ph3">`array`</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.IndexOutOfRangeException&gt;</ph> será gerada se <ph id="ph2">`index`</ph> é negativo ou maior que o limite de <ph id="ph3">`array`</ph>.</target>       </trans-unit>
        <trans-unit id="2436" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I1">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`ldelem.i1`</ph> opcode:</source>
          <target state="translated">O seguinte <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> sobrecarga de método pode usar o <ph id="ph2">`ldelem.i1`</ph> opcode:</target>       </trans-unit>
        <trans-unit id="2437" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I1">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="2438" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I2">
          <source>Loads the element with type <ph id="ph1">&lt;see langword="int16" /&gt;</ph> at a specified array index onto the top of the evaluation stack as an <ph id="ph2">&lt;see langword="int32" /&gt;</ph>.</source>
          <target state="translated">Carrega o elemento com o tipo <ph id="ph1">&lt;see langword="int16" /&gt;</ph> em um índice de matriz especificado para o topo da pilha de avaliação como um <ph id="ph2">&lt;see langword="int32" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2439" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I2">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">A tabela a seguir lista as instruções hexadecimal e formato de assembly do Microsoft Intermediate Language (MSIL), junto com um resumo breve de referência:</target>       </trans-unit>
        <trans-unit id="2440" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I2">
          <source>Format</source>
          <target state="translated">Formatar</target>       </trans-unit>
        <trans-unit id="2441" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I2">
          <source>Assembly Format</source>
          <target state="translated">Formato de assembly</target>       </trans-unit>
        <trans-unit id="2442" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I2">
          <source>Description</source>
          <target state="translated">Descrição</target>       </trans-unit>
        <trans-unit id="2443" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I2">
          <source>92</source>
          <target state="translated">92</target>       </trans-unit>
        <trans-unit id="2444" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I2">
          <source>ldelem.i2</source>
          <target state="translated">ldelem.i2</target>       </trans-unit>
        <trans-unit id="2445" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I2">
          <source>Loads the element with type <ph id="ph1">`int16`</ph> at <ph id="ph2">`index`</ph> onto the top of the stack as an <ph id="ph3">`int32`</ph>.</source>
          <target state="translated">Carrega o elemento com o tipo <ph id="ph1">`int16`</ph> em <ph id="ph2">`index`</ph> na parte superior da pilha de como um <ph id="ph3">`int32`</ph>.</target>       </trans-unit>
        <trans-unit id="2446" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I2">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">O comportamento de transição de pilha, em ordem sequencial, é:</target>       </trans-unit>
        <trans-unit id="2447" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I2">
          <source>An object reference <ph id="ph1">`array`</ph> is pushed onto the stack.</source>
          <target state="translated">Uma referência de objeto <ph id="ph1">`array`</ph> é inserido na pilha.</target>       </trans-unit>
        <trans-unit id="2448" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I2">
          <source>An index value <ph id="ph1">`index`</ph> is pushed onto the stack.</source>
          <target state="translated">Um valor de índice <ph id="ph1">`index`</ph> é inserido na pilha.</target>       </trans-unit>
        <trans-unit id="2449" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I2">
          <source><ph id="ph1">`index`</ph> and <ph id="ph2">`array`</ph> are popped from the stack; the value stored at position <ph id="ph3">`index`</ph> in <ph id="ph4">`array`</ph> is looked up.</source>
          <target state="translated"><ph id="ph1">`index`</ph> e <ph id="ph2">`array`</ph> são disparados da pilha; o valor armazenado na posição <ph id="ph3">`index`</ph> em <ph id="ph4">`array`</ph> é pesquisada.</target>       </trans-unit>
        <trans-unit id="2450" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I2">
          <source>The value is pushed onto the stack.</source>
          <target state="translated">O valor é inserido na pilha.</target>       </trans-unit>
        <trans-unit id="2451" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I2">
          <source>The <ph id="ph1">`ldelem.i2`</ph> instruction loads the value of the element with index <ph id="ph2">`index`</ph> (type <ph id="ph3">`native int`</ph>) in the zero-based one-dimensional array <ph id="ph4">`array`</ph> and places it on the top of the stack.</source>
          <target state="translated">O <ph id="ph1">`ldelem.i2`</ph> instrução carrega o valor do elemento com index <ph id="ph2">`index`</ph> (tipo <ph id="ph3">`native int`</ph>) na matriz unidimensional de base zero <ph id="ph4">`array`</ph> e o coloca na parte superior da pilha.</target>       </trans-unit>
        <trans-unit id="2452" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I2">
          <source>Arrays are objects and hence represented by a value of type <ph id="ph1">`O`</ph>.</source>
          <target state="translated">Matrizes de objetos e, portanto, é representado por um valor do tipo <ph id="ph1">`O`</ph>.</target>       </trans-unit>
        <trans-unit id="2453" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I2">
          <source>The return value for <ph id="ph1">`ldelem.i2`</ph> is <ph id="ph2">`int16`</ph>.</source>
          <target state="translated">O valor de retorno <ph id="ph1">`ldelem.i2`</ph> é <ph id="ph2">`int16`</ph>.</target>       </trans-unit>
        <trans-unit id="2454" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I2">
          <source>Note that integer values of less than 4 bytes are extended to <ph id="ph1">`int32`</ph> (not <ph id="ph2">`native int`</ph>) when they are loaded onto the evaluation stack.</source>
          <target state="translated">Observe que os valores inteiros de menos de 4 bytes são estendidos para <ph id="ph1">`int32`</ph> (não <ph id="ph2">`native int`</ph>) quando eles são carregados para a pilha de avaliação.</target>       </trans-unit>
        <trans-unit id="2455" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I2">
          <source><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> is thrown if <ph id="ph2">`array`</ph> is a null reference.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> será gerada se <ph id="ph2">`array`</ph> é uma referência nula.</target>       </trans-unit>
        <trans-unit id="2456" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I2">
          <source><ph id="ph1">&lt;xref:System.ArrayTypeMismatchException&gt;</ph> is thrown if <ph id="ph2">`array`</ph> does not hold elements of the required type.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.ArrayTypeMismatchException&gt;</ph> será gerada se <ph id="ph2">`array`</ph> não contém elementos do tipo necessário.</target>       </trans-unit>
        <trans-unit id="2457" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I2">
          <source><ph id="ph1">&lt;xref:System.IndexOutOfRangeException&gt;</ph> is thrown if <ph id="ph2">`index`</ph> is negative, or larger than the bound of <ph id="ph3">`array`</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.IndexOutOfRangeException&gt;</ph> será gerada se <ph id="ph2">`index`</ph> é negativo ou maior que o limite de <ph id="ph3">`array`</ph>.</target>       </trans-unit>
        <trans-unit id="2458" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I2">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`ldelem.i2`</ph> opcode:</source>
          <target state="translated">O seguinte <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> sobrecarga de método pode usar o <ph id="ph2">`ldelem.i2`</ph> opcode:</target>       </trans-unit>
        <trans-unit id="2459" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I2">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="2460" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I4">
          <source>Loads the element with type <ph id="ph1">&lt;see langword="int32" /&gt;</ph> at a specified array index onto the top of the evaluation stack as an <ph id="ph2">&lt;see langword="int32" /&gt;</ph>.</source>
          <target state="translated">Carrega o elemento com o tipo <ph id="ph1">&lt;see langword="int32" /&gt;</ph> em um índice de matriz especificado para o topo da pilha de avaliação como um <ph id="ph2">&lt;see langword="int32" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2461" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I4">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">A tabela a seguir lista as instruções hexadecimal e formato de assembly do Microsoft Intermediate Language (MSIL), junto com um resumo breve de referência:</target>       </trans-unit>
        <trans-unit id="2462" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I4">
          <source>Format</source>
          <target state="translated">Formatar</target>       </trans-unit>
        <trans-unit id="2463" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I4">
          <source>Assembly Format</source>
          <target state="translated">Formato de assembly</target>       </trans-unit>
        <trans-unit id="2464" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I4">
          <source>Description</source>
          <target state="translated">Descrição</target>       </trans-unit>
        <trans-unit id="2465" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I4">
          <source>94</source>
          <target state="translated">94</target>       </trans-unit>
        <trans-unit id="2466" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I4">
          <source>ldelem.i4</source>
          <target state="translated">ldelem.i4</target>       </trans-unit>
        <trans-unit id="2467" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I4">
          <source>Loads the element with type <ph id="ph1">`int32`</ph> at <ph id="ph2">`index`</ph> onto the top of the stack as an <ph id="ph3">`int32`</ph>.</source>
          <target state="translated">Carrega o elemento com o tipo <ph id="ph1">`int32`</ph> em <ph id="ph2">`index`</ph> na parte superior da pilha de como um <ph id="ph3">`int32`</ph>.</target>       </trans-unit>
        <trans-unit id="2468" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I4">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">O comportamento de transição de pilha, em ordem sequencial, é:</target>       </trans-unit>
        <trans-unit id="2469" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I4">
          <source>An object reference <ph id="ph1">`array`</ph> is pushed onto the stack.</source>
          <target state="translated">Uma referência de objeto <ph id="ph1">`array`</ph> é inserido na pilha.</target>       </trans-unit>
        <trans-unit id="2470" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I4">
          <source>An index value <ph id="ph1">`index`</ph> is pushed onto the stack.</source>
          <target state="translated">Um valor de índice <ph id="ph1">`index`</ph> é inserido na pilha.</target>       </trans-unit>
        <trans-unit id="2471" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I4">
          <source><ph id="ph1">`index`</ph> and <ph id="ph2">`array`</ph> are popped from the stack; the value stored at position <ph id="ph3">`index`</ph> in <ph id="ph4">`array`</ph> is looked up.</source>
          <target state="translated"><ph id="ph1">`index`</ph> e <ph id="ph2">`array`</ph> são disparados da pilha; o valor armazenado na posição <ph id="ph3">`index`</ph> em <ph id="ph4">`array`</ph> é pesquisada.</target>       </trans-unit>
        <trans-unit id="2472" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I4">
          <source>The value is pushed onto the stack.</source>
          <target state="translated">O valor é inserido na pilha.</target>       </trans-unit>
        <trans-unit id="2473" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I4">
          <source>The <ph id="ph1">`ldelem.i4`</ph> instruction loads the value of the element with index <ph id="ph2">`index`</ph> (type <ph id="ph3">`native int`</ph>) in the zero-based one-dimensional array <ph id="ph4">`array`</ph> and places it on the top of the stack.</source>
          <target state="translated">O <ph id="ph1">`ldelem.i4`</ph> instrução carrega o valor do elemento com index <ph id="ph2">`index`</ph> (tipo <ph id="ph3">`native int`</ph>) na matriz unidimensional de base zero <ph id="ph4">`array`</ph> e o coloca na parte superior da pilha.</target>       </trans-unit>
        <trans-unit id="2474" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I4">
          <source>Arrays are objects and hence represented by a value of type <ph id="ph1">`O`</ph>.</source>
          <target state="translated">Matrizes de objetos e, portanto, é representado por um valor do tipo <ph id="ph1">`O`</ph>.</target>       </trans-unit>
        <trans-unit id="2475" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I4">
          <source>The return value for <ph id="ph1">`ldelem.i4`</ph> is <ph id="ph2">`int32`</ph>.</source>
          <target state="translated">O valor de retorno <ph id="ph1">`ldelem.i4`</ph> é <ph id="ph2">`int32`</ph>.</target>       </trans-unit>
        <trans-unit id="2476" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I4">
          <source>Note that integer values of less than 4 bytes are extended to <ph id="ph1">`int32`</ph> (not <ph id="ph2">`native int`</ph>) when they are loaded onto the evaluation stack.</source>
          <target state="translated">Observe que os valores inteiros de menos de 4 bytes são estendidos para <ph id="ph1">`int32`</ph> (não <ph id="ph2">`native int`</ph>) quando eles são carregados para a pilha de avaliação.</target>       </trans-unit>
        <trans-unit id="2477" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I4">
          <source><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> is thrown if <ph id="ph2">`array`</ph> is a null reference.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> será gerada se <ph id="ph2">`array`</ph> é uma referência nula.</target>       </trans-unit>
        <trans-unit id="2478" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I4">
          <source><ph id="ph1">&lt;xref:System.ArrayTypeMismatchException&gt;</ph> is thrown if <ph id="ph2">`array`</ph> does not hold elements of the required type.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.ArrayTypeMismatchException&gt;</ph> será gerada se <ph id="ph2">`array`</ph> não contém elementos do tipo necessário.</target>       </trans-unit>
        <trans-unit id="2479" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I4">
          <source><ph id="ph1">&lt;xref:System.IndexOutOfRangeException&gt;</ph> is thrown if <ph id="ph2">`index`</ph> is negative, or larger than the bound of <ph id="ph3">`array`</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.IndexOutOfRangeException&gt;</ph> será gerada se <ph id="ph2">`index`</ph> é negativo ou maior que o limite de <ph id="ph3">`array`</ph>.</target>       </trans-unit>
        <trans-unit id="2480" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I4">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`ldelem.i4`</ph> opcode:</source>
          <target state="translated">O seguinte <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> sobrecarga de método pode usar o <ph id="ph2">`ldelem.i4`</ph> opcode:</target>       </trans-unit>
        <trans-unit id="2481" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I4">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="2482" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I8">
          <source>Loads the element with type <ph id="ph1">&lt;see langword="int64" /&gt;</ph> at a specified array index onto the top of the evaluation stack as an <ph id="ph2">&lt;see langword="int64" /&gt;</ph>.</source>
          <target state="translated">Carrega o elemento com o tipo <ph id="ph1">&lt;see langword="int64" /&gt;</ph> em um índice de matriz especificado para o topo da pilha de avaliação como um <ph id="ph2">&lt;see langword="int64" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2483" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I8">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">A tabela a seguir lista as instruções hexadecimal e formato de assembly do Microsoft Intermediate Language (MSIL), junto com um resumo breve de referência:</target>       </trans-unit>
        <trans-unit id="2484" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I8">
          <source>Format</source>
          <target state="translated">Formatar</target>       </trans-unit>
        <trans-unit id="2485" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I8">
          <source>Assembly Format</source>
          <target state="translated">Formato de assembly</target>       </trans-unit>
        <trans-unit id="2486" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I8">
          <source>Description</source>
          <target state="translated">Descrição</target>       </trans-unit>
        <trans-unit id="2487" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I8">
          <source>96</source>
          <target state="translated">96</target>       </trans-unit>
        <trans-unit id="2488" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I8">
          <source>ldelem.i8</source>
          <target state="translated">Ldelem.I8</target>       </trans-unit>
        <trans-unit id="2489" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I8">
          <source>Loads the element with type <ph id="ph1">`int64`</ph> at <ph id="ph2">`index`</ph> onto the top of the stack as an <ph id="ph3">`int64`</ph>.</source>
          <target state="translated">Carrega o elemento com o tipo <ph id="ph1">`int64`</ph> em <ph id="ph2">`index`</ph> na parte superior da pilha de como um <ph id="ph3">`int64`</ph>.</target>       </trans-unit>
        <trans-unit id="2490" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I8">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">O comportamento de transição de pilha, em ordem sequencial, é:</target>       </trans-unit>
        <trans-unit id="2491" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I8">
          <source>An object reference <ph id="ph1">`array`</ph> is pushed onto the stack.</source>
          <target state="translated">Uma referência de objeto <ph id="ph1">`array`</ph> é inserido na pilha.</target>       </trans-unit>
        <trans-unit id="2492" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I8">
          <source>An index value <ph id="ph1">`index`</ph> is pushed onto the stack.</source>
          <target state="translated">Um valor de índice <ph id="ph1">`index`</ph> é inserido na pilha.</target>       </trans-unit>
        <trans-unit id="2493" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I8">
          <source><ph id="ph1">`index`</ph> and <ph id="ph2">`array`</ph> are popped from the stack; the value stored at position <ph id="ph3">`index`</ph> in <ph id="ph4">`array`</ph> is looked up.</source>
          <target state="translated"><ph id="ph1">`index`</ph> e <ph id="ph2">`array`</ph> são disparados da pilha; o valor armazenado na posição <ph id="ph3">`index`</ph> em <ph id="ph4">`array`</ph> é pesquisada.</target>       </trans-unit>
        <trans-unit id="2494" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I8">
          <source>The value is pushed onto the stack.</source>
          <target state="translated">O valor é inserido na pilha.</target>       </trans-unit>
        <trans-unit id="2495" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I8">
          <source>The <ph id="ph1">`ldelem.i8`</ph> instruction loads the value of the element with index <ph id="ph2">`index`</ph> (type <ph id="ph3">`native int`</ph>) in the zero-based one-dimensional array <ph id="ph4">`array`</ph> and places it on the top of the stack.</source>
          <target state="translated">O <ph id="ph1">`ldelem.i8`</ph> instrução carrega o valor do elemento com index <ph id="ph2">`index`</ph> (tipo <ph id="ph3">`native int`</ph>) na matriz unidimensional de base zero <ph id="ph4">`array`</ph> e o coloca na parte superior da pilha.</target>       </trans-unit>
        <trans-unit id="2496" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I8">
          <source>Arrays are objects and hence represented by a value of type <ph id="ph1">`O`</ph>.</source>
          <target state="translated">Matrizes de objetos e, portanto, é representado por um valor do tipo <ph id="ph1">`O`</ph>.</target>       </trans-unit>
        <trans-unit id="2497" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I8">
          <source>The return value for <ph id="ph1">`ldelem.i8`</ph> is <ph id="ph2">`int64`</ph>.</source>
          <target state="translated">O valor de retorno <ph id="ph1">`ldelem.i8`</ph> é <ph id="ph2">`int64`</ph>.</target>       </trans-unit>
        <trans-unit id="2498" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I8">
          <source>Note that integer values of less than 4 bytes are extended to <ph id="ph1">`int32`</ph> (not <ph id="ph2">`native int`</ph>) when they are loaded onto the evaluation stack.</source>
          <target state="translated">Observe que os valores inteiros de menos de 4 bytes são estendidos para <ph id="ph1">`int32`</ph> (não <ph id="ph2">`native int`</ph>) quando eles são carregados para a pilha de avaliação.</target>       </trans-unit>
        <trans-unit id="2499" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I8">
          <source><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> is thrown if <ph id="ph2">`array`</ph> is a null reference.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> será gerada se <ph id="ph2">`array`</ph> é uma referência nula.</target>       </trans-unit>
        <trans-unit id="2500" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I8">
          <source><ph id="ph1">&lt;xref:System.ArrayTypeMismatchException&gt;</ph> is thrown if <ph id="ph2">`array`</ph> does not hold elements of the required type.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.ArrayTypeMismatchException&gt;</ph> será gerada se <ph id="ph2">`array`</ph> não contém elementos do tipo necessário.</target>       </trans-unit>
        <trans-unit id="2501" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I8">
          <source><ph id="ph1">&lt;xref:System.IndexOutOfRangeException&gt;</ph> is thrown if <ph id="ph2">`index`</ph> is negative, or larger than the bound of <ph id="ph3">`array`</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.IndexOutOfRangeException&gt;</ph> será gerada se <ph id="ph2">`index`</ph> é negativo ou maior que o limite de <ph id="ph3">`array`</ph>.</target>       </trans-unit>
        <trans-unit id="2502" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I8">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`ldelem.i8`</ph> opcode:</source>
          <target state="translated">O seguinte <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> sobrecarga de método pode usar o <ph id="ph2">`ldelem.i8`</ph> opcode:</target>       </trans-unit>
        <trans-unit id="2503" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I8">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="2504" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Ldelem_R4">
          <source>Loads the element with type <ph id="ph1">&lt;see langword="float32" /&gt;</ph> at a specified array index onto the top of the evaluation stack as type <ph id="ph2">&lt;see langword="F" /&gt;</ph> (float).</source>
          <target state="translated">Carrega o elemento com o tipo <ph id="ph1">&lt;see langword="float32" /&gt;</ph> em um índice de matriz especificado para o topo da pilha de avaliação como um tipo <ph id="ph2">&lt;see langword="F" /&gt;</ph> (float).</target>       </trans-unit>
        <trans-unit id="2505" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_R4">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">A tabela a seguir lista as instruções hexadecimal e formato de assembly do Microsoft Intermediate Language (MSIL), junto com um resumo breve de referência:</target>       </trans-unit>
        <trans-unit id="2506" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_R4">
          <source>Format</source>
          <target state="translated">Formatar</target>       </trans-unit>
        <trans-unit id="2507" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_R4">
          <source>Assembly Format</source>
          <target state="translated">Formato de assembly</target>       </trans-unit>
        <trans-unit id="2508" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_R4">
          <source>Description</source>
          <target state="translated">Descrição</target>       </trans-unit>
        <trans-unit id="2509" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_R4">
          <source>98</source>
          <target state="translated">98</target>       </trans-unit>
        <trans-unit id="2510" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_R4">
          <source>ldelem.r4</source>
          <target state="translated">Ldelem.R4</target>       </trans-unit>
        <trans-unit id="2511" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_R4">
          <source>Loads the element with type <ph id="ph1">`float32`</ph> at <ph id="ph2">`index`</ph> onto the top of the stack as a type <ph id="ph3">`F`</ph>.</source>
          <target state="translated">Carrega o elemento com o tipo <ph id="ph1">`float32`</ph> em <ph id="ph2">`index`</ph> na parte superior da pilha de como um tipo <ph id="ph3">`F`</ph>.</target>       </trans-unit>
        <trans-unit id="2512" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_R4">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">O comportamento de transição de pilha, em ordem sequencial, é:</target>       </trans-unit>
        <trans-unit id="2513" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_R4">
          <source>An object reference <ph id="ph1">`array`</ph> is pushed onto the stack.</source>
          <target state="translated">Uma referência de objeto <ph id="ph1">`array`</ph> é inserido na pilha.</target>       </trans-unit>
        <trans-unit id="2514" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_R4">
          <source>An index value <ph id="ph1">`index`</ph> is pushed onto the stack.</source>
          <target state="translated">Um valor de índice <ph id="ph1">`index`</ph> é inserido na pilha.</target>       </trans-unit>
        <trans-unit id="2515" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_R4">
          <source><ph id="ph1">`index`</ph> and <ph id="ph2">`array`</ph> are popped from the stack; the value stored at position <ph id="ph3">`index`</ph> in <ph id="ph4">`array`</ph> is looked up.</source>
          <target state="translated"><ph id="ph1">`index`</ph> e <ph id="ph2">`array`</ph> são disparados da pilha; o valor armazenado na posição <ph id="ph3">`index`</ph> em <ph id="ph4">`array`</ph> é pesquisada.</target>       </trans-unit>
        <trans-unit id="2516" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_R4">
          <source>The value is pushed onto the stack.</source>
          <target state="translated">O valor é inserido na pilha.</target>       </trans-unit>
        <trans-unit id="2517" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_R4">
          <source>The <ph id="ph1">`ldelem.r4`</ph> instruction loads the value of the element with index <ph id="ph2">`index`</ph> (type <ph id="ph3">`native int`</ph>) in the zero-based one-dimensional array <ph id="ph4">`array`</ph> and places it on the top of the stack.</source>
          <target state="translated">O <ph id="ph1">`ldelem.r4`</ph> instrução carrega o valor do elemento com index <ph id="ph2">`index`</ph> (tipo <ph id="ph3">`native int`</ph>) na matriz unidimensional de base zero <ph id="ph4">`array`</ph> e o coloca na parte superior da pilha.</target>       </trans-unit>
        <trans-unit id="2518" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_R4">
          <source>Arrays are objects and hence represented by a value of type <ph id="ph1">`O`</ph>.</source>
          <target state="translated">Matrizes de objetos e, portanto, é representado por um valor do tipo <ph id="ph1">`O`</ph>.</target>       </trans-unit>
        <trans-unit id="2519" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_R4">
          <source>The return value for <ph id="ph1">`ldelem.r4`</ph> is <ph id="ph2">`float32`</ph>.</source>
          <target state="translated">O valor de retorno <ph id="ph1">`ldelem.r4`</ph> é <ph id="ph2">`float32`</ph>.</target>       </trans-unit>
        <trans-unit id="2520" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_R4">
          <source>Floating-point values are converted to type <ph id="ph1">`F`</ph> when loaded onto the evaluation stack.</source>
          <target state="translated">Valores de ponto flutuante são convertidos para o tipo <ph id="ph1">`F`</ph> quando carregado para a pilha de avaliação.</target>       </trans-unit>
        <trans-unit id="2521" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_R4">
          <source><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> is thrown if <ph id="ph2">`array`</ph> is a null reference.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> será gerada se <ph id="ph2">`array`</ph> é uma referência nula.</target>       </trans-unit>
        <trans-unit id="2522" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_R4">
          <source><ph id="ph1">&lt;xref:System.ArrayTypeMismatchException&gt;</ph> is thrown if <ph id="ph2">`array`</ph> does not hold elements of the required type.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.ArrayTypeMismatchException&gt;</ph> será gerada se <ph id="ph2">`array`</ph> não contém elementos do tipo necessário.</target>       </trans-unit>
        <trans-unit id="2523" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_R4">
          <source><ph id="ph1">&lt;xref:System.IndexOutOfRangeException&gt;</ph> is thrown if <ph id="ph2">`index`</ph> is negative, or larger than the bound of <ph id="ph3">`array`</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.IndexOutOfRangeException&gt;</ph> será gerada se <ph id="ph2">`index`</ph> é negativo ou maior que o limite de <ph id="ph3">`array`</ph>.</target>       </trans-unit>
        <trans-unit id="2524" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_R4">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`ldelem.r4`</ph> opcode:</source>
          <target state="translated">O seguinte <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> sobrecarga de método pode usar o <ph id="ph2">`ldelem.r4`</ph> opcode:</target>       </trans-unit>
        <trans-unit id="2525" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_R4">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="2526" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Ldelem_R8">
          <source>Loads the element with type <ph id="ph1">&lt;see langword="float64" /&gt;</ph> at a specified array index onto the top of the evaluation stack as type <ph id="ph2">&lt;see langword="F" /&gt;</ph> (float).</source>
          <target state="translated">Carrega o elemento com o tipo <ph id="ph1">&lt;see langword="float64" /&gt;</ph> em um índice de matriz especificado para o topo da pilha de avaliação como um tipo <ph id="ph2">&lt;see langword="F" /&gt;</ph> (float).</target>       </trans-unit>
        <trans-unit id="2527" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_R8">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">A tabela a seguir lista as instruções hexadecimal e formato de assembly do Microsoft Intermediate Language (MSIL), junto com um resumo breve de referência:</target>       </trans-unit>
        <trans-unit id="2528" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_R8">
          <source>Format</source>
          <target state="translated">Formatar</target>       </trans-unit>
        <trans-unit id="2529" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_R8">
          <source>Assembly Format</source>
          <target state="translated">Formato de assembly</target>       </trans-unit>
        <trans-unit id="2530" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_R8">
          <source>Description</source>
          <target state="translated">Descrição</target>       </trans-unit>
        <trans-unit id="2531" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_R8">
          <source>99</source>
          <target state="translated">99</target>       </trans-unit>
        <trans-unit id="2532" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_R8">
          <source>ldelem.r8</source>
          <target state="translated">Ldelem.R8</target>       </trans-unit>
        <trans-unit id="2533" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_R8">
          <source>Loads the element with type <ph id="ph1">`float64`</ph> at <ph id="ph2">`index`</ph> onto the top of the stack as type <ph id="ph3">`F`</ph>.</source>
          <target state="translated">Carrega o elemento com o tipo <ph id="ph1">`float64`</ph> em <ph id="ph2">`index`</ph> na parte superior da pilha como tipo <ph id="ph3">`F`</ph>.</target>       </trans-unit>
        <trans-unit id="2534" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_R8">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">O comportamento de transição de pilha, em ordem sequencial, é:</target>       </trans-unit>
        <trans-unit id="2535" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_R8">
          <source>An object reference <ph id="ph1">`array`</ph> is pushed onto the stack.</source>
          <target state="translated">Uma referência de objeto <ph id="ph1">`array`</ph> é inserido na pilha.</target>       </trans-unit>
        <trans-unit id="2536" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_R8">
          <source>An index value <ph id="ph1">`index`</ph> is pushed onto the stack.</source>
          <target state="translated">Um valor de índice <ph id="ph1">`index`</ph> é inserido na pilha.</target>       </trans-unit>
        <trans-unit id="2537" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_R8">
          <source><ph id="ph1">`index`</ph> and <ph id="ph2">`array`</ph> are popped from the stack; the value stored at position <ph id="ph3">`index`</ph> in <ph id="ph4">`array`</ph> is looked up.</source>
          <target state="translated"><ph id="ph1">`index`</ph> e <ph id="ph2">`array`</ph> são disparados da pilha; o valor armazenado na posição <ph id="ph3">`index`</ph> em <ph id="ph4">`array`</ph> é pesquisada.</target>       </trans-unit>
        <trans-unit id="2538" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_R8">
          <source>The value is pushed onto the stack.</source>
          <target state="translated">O valor é inserido na pilha.</target>       </trans-unit>
        <trans-unit id="2539" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_R8">
          <source>The <ph id="ph1">`ldelem.r8`</ph> instruction loads the value of the element with index <ph id="ph2">`index`</ph> (type <ph id="ph3">`native int`</ph>) in the zero-based one-dimensional array <ph id="ph4">`array`</ph> and places it on the top of the stack.</source>
          <target state="translated">O <ph id="ph1">`ldelem.r8`</ph> instrução carrega o valor do elemento com index <ph id="ph2">`index`</ph> (tipo <ph id="ph3">`native int`</ph>) na matriz unidimensional de base zero <ph id="ph4">`array`</ph> e o coloca na parte superior da pilha.</target>       </trans-unit>
        <trans-unit id="2540" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_R8">
          <source>Arrays are objects and hence represented by a value of type <ph id="ph1">`O`</ph>.</source>
          <target state="translated">Matrizes de objetos e, portanto, é representado por um valor do tipo <ph id="ph1">`O`</ph>.</target>       </trans-unit>
        <trans-unit id="2541" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_R8">
          <source>The return value for <ph id="ph1">`ldelem.r8`</ph> is <ph id="ph2">`float64`</ph>.</source>
          <target state="translated">O valor de retorno <ph id="ph1">`ldelem.r8`</ph> é <ph id="ph2">`float64`</ph>.</target>       </trans-unit>
        <trans-unit id="2542" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_R8">
          <source>Floating-point values are converted to type <ph id="ph1">`F`</ph> when loaded onto the evaluation stack.</source>
          <target state="translated">Valores de ponto flutuante são convertidos para o tipo <ph id="ph1">`F`</ph> quando carregado para a pilha de avaliação.</target>       </trans-unit>
        <trans-unit id="2543" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_R8">
          <source><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> is thrown if <ph id="ph2">`array`</ph> is a null reference.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> será gerada se <ph id="ph2">`array`</ph> é uma referência nula.</target>       </trans-unit>
        <trans-unit id="2544" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_R8">
          <source><ph id="ph1">&lt;xref:System.ArrayTypeMismatchException&gt;</ph> is thrown if <ph id="ph2">`array`</ph> does not hold elements of the required type.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.ArrayTypeMismatchException&gt;</ph> será gerada se <ph id="ph2">`array`</ph> não contém elementos do tipo necessário.</target>       </trans-unit>
        <trans-unit id="2545" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_R8">
          <source><ph id="ph1">&lt;xref:System.IndexOutOfRangeException&gt;</ph> is thrown if <ph id="ph2">`index`</ph> is negative, or larger than the bound of <ph id="ph3">`array`</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.IndexOutOfRangeException&gt;</ph> será gerada se <ph id="ph2">`index`</ph> é negativo ou maior que o limite de <ph id="ph3">`array`</ph>.</target>       </trans-unit>
        <trans-unit id="2546" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_R8">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`ldelem.r8`</ph> opcode:</source>
          <target state="translated">O seguinte <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> sobrecarga de método pode usar o <ph id="ph2">`ldelem.r8`</ph> opcode:</target>       </trans-unit>
        <trans-unit id="2547" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_R8">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="2548" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Ldelem_Ref">
          <source>Loads the element containing an object reference at a specified array index onto the top of the evaluation stack as type <ph id="ph1">&lt;see langword="O" /&gt;</ph> (object reference).</source>
          <target state="translated">Carrega o elemento que contém uma referência de objeto em um índice de matriz especificado para o topo da pilha de avaliação como tipo <ph id="ph1">&lt;see langword="O" /&gt;</ph> (referência de objeto).</target>       </trans-unit>
        <trans-unit id="2549" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_Ref">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">A tabela a seguir lista as instruções hexadecimal e formato de assembly do Microsoft Intermediate Language (MSIL), junto com um resumo breve de referência:</target>       </trans-unit>
        <trans-unit id="2550" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_Ref">
          <source>Format</source>
          <target state="translated">Formatar</target>       </trans-unit>
        <trans-unit id="2551" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_Ref">
          <source>Assembly Format</source>
          <target state="translated">Formato de assembly</target>       </trans-unit>
        <trans-unit id="2552" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_Ref">
          <source>Description</source>
          <target state="translated">Descrição</target>       </trans-unit>
        <trans-unit id="2553" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_Ref">
          <source>9A</source>
          <target state="translated">9A</target>       </trans-unit>
        <trans-unit id="2554" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_Ref">
          <source>ldelem.ref</source>
          <target state="translated">ldelem.ref</target>       </trans-unit>
        <trans-unit id="2555" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_Ref">
          <source>Loads the element with an object reference at <ph id="ph1">`index`</ph> onto the top of the stack as type <ph id="ph2">`O`</ph>.</source>
          <target state="translated">Carrega o elemento com uma referência de objeto em <ph id="ph1">`index`</ph> na parte superior da pilha como tipo <ph id="ph2">`O`</ph>.</target>       </trans-unit>
        <trans-unit id="2556" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_Ref">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">O comportamento de transição de pilha, em ordem sequencial, é:</target>       </trans-unit>
        <trans-unit id="2557" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_Ref">
          <source>An object reference <ph id="ph1">`array`</ph> is pushed onto the stack.</source>
          <target state="translated">Uma referência de objeto <ph id="ph1">`array`</ph> é inserido na pilha.</target>       </trans-unit>
        <trans-unit id="2558" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_Ref">
          <source>An index value <ph id="ph1">`index`</ph> is pushed onto the stack.</source>
          <target state="translated">Um valor de índice <ph id="ph1">`index`</ph> é inserido na pilha.</target>       </trans-unit>
        <trans-unit id="2559" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_Ref">
          <source><ph id="ph1">`index`</ph> and <ph id="ph2">`array`</ph> are popped from the stack; the value stored at position <ph id="ph3">`index`</ph> in <ph id="ph4">`array`</ph> is looked up.</source>
          <target state="translated"><ph id="ph1">`index`</ph> e <ph id="ph2">`array`</ph> são disparados da pilha; o valor armazenado na posição <ph id="ph3">`index`</ph> em <ph id="ph4">`array`</ph> é pesquisada.</target>       </trans-unit>
        <trans-unit id="2560" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_Ref">
          <source>The value is pushed onto the stack.</source>
          <target state="translated">O valor é inserido na pilha.</target>       </trans-unit>
        <trans-unit id="2561" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_Ref">
          <source>The <ph id="ph1">`ldelem.ref`</ph> instruction loads the value of the element with index <ph id="ph2">`index`</ph> (type <ph id="ph3">`native int`</ph>) in the zero-based one-dimensional array <ph id="ph4">`array`</ph> and places it on the top of the stack.</source>
          <target state="translated">O <ph id="ph1">`ldelem.ref`</ph> instrução carrega o valor do elemento com index <ph id="ph2">`index`</ph> (tipo <ph id="ph3">`native int`</ph>) na matriz unidimensional de base zero <ph id="ph4">`array`</ph> e o coloca na parte superior da pilha.</target>       </trans-unit>
        <trans-unit id="2562" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_Ref">
          <source>Arrays are objects and hence represented by a value of type <ph id="ph1">`O`</ph>.</source>
          <target state="translated">Matrizes de objetos e, portanto, é representado por um valor do tipo <ph id="ph1">`O`</ph>.</target>       </trans-unit>
        <trans-unit id="2563" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_Ref">
          <source>The return value for <ph id="ph1">`ldelem.ref`</ph> is type <ph id="ph2">`O`</ph> (object reference).</source>
          <target state="translated">O valor de retorno <ph id="ph1">`ldelem.ref`</ph> é do tipo <ph id="ph2">`O`</ph> (referência de objeto).</target>       </trans-unit>
        <trans-unit id="2564" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_Ref">
          <source><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> is thrown if <ph id="ph2">`array`</ph> is a null reference.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> será gerada se <ph id="ph2">`array`</ph> é uma referência nula.</target>       </trans-unit>
        <trans-unit id="2565" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_Ref">
          <source><ph id="ph1">&lt;xref:System.ArrayTypeMismatchException&gt;</ph> is thrown if <ph id="ph2">`array`</ph> does not hold elements of the required type.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.ArrayTypeMismatchException&gt;</ph> será gerada se <ph id="ph2">`array`</ph> não contém elementos do tipo necessário.</target>       </trans-unit>
        <trans-unit id="2566" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_Ref">
          <source><ph id="ph1">&lt;xref:System.IndexOutOfRangeException&gt;</ph> is thrown if <ph id="ph2">`index`</ph> is negative, or larger than the bound of <ph id="ph3">`array`</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.IndexOutOfRangeException&gt;</ph> será gerada se <ph id="ph2">`index`</ph> é negativo ou maior que o limite de <ph id="ph3">`array`</ph>.</target>       </trans-unit>
        <trans-unit id="2567" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_Ref">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`ldelem.ref`</ph> opcode:</source>
          <target state="translated">O seguinte <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> sobrecarga de método pode usar o <ph id="ph2">`ldelem.ref`</ph> opcode:</target>       </trans-unit>
        <trans-unit id="2568" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_Ref">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="2569" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Ldelem_U1">
          <source>Loads the element with type <ph id="ph1">&lt;see langword="unsigned int8" /&gt;</ph> at a specified array index onto the top of the evaluation stack as an <ph id="ph2">&lt;see langword="int32" /&gt;</ph>.</source>
          <target state="translated">Carrega o elemento com o tipo <ph id="ph1">&lt;see langword="unsigned int8" /&gt;</ph> em um índice de matriz especificado para o topo da pilha de avaliação como um <ph id="ph2">&lt;see langword="int32" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2570" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_U1">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">A tabela a seguir lista as instruções hexadecimal e formato de assembly do Microsoft Intermediate Language (MSIL), junto com um resumo breve de referência:</target>       </trans-unit>
        <trans-unit id="2571" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_U1">
          <source>Format</source>
          <target state="translated">Formatar</target>       </trans-unit>
        <trans-unit id="2572" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_U1">
          <source>Assembly Format</source>
          <target state="translated">Formato de assembly</target>       </trans-unit>
        <trans-unit id="2573" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_U1">
          <source>Description</source>
          <target state="translated">Descrição</target>       </trans-unit>
        <trans-unit id="2574" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_U1">
          <source>91</source>
          <target state="translated">91</target>       </trans-unit>
        <trans-unit id="2575" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_U1">
          <source>ldelem.u1</source>
          <target state="translated">ldelem.u1</target>       </trans-unit>
        <trans-unit id="2576" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_U1">
          <source>Loads the element with type <ph id="ph1">`unsigned int8`</ph> at <ph id="ph2">`index`</ph> onto the top of the stack as an <ph id="ph3">`int32`</ph>.</source>
          <target state="translated">Carrega o elemento com o tipo <ph id="ph1">`unsigned int8`</ph> em <ph id="ph2">`index`</ph> na parte superior da pilha de como um <ph id="ph3">`int32`</ph>.</target>       </trans-unit>
        <trans-unit id="2577" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_U1">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">O comportamento de transição de pilha, em ordem sequencial, é:</target>       </trans-unit>
        <trans-unit id="2578" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_U1">
          <source>An object reference <ph id="ph1">`array`</ph> is pushed onto the stack.</source>
          <target state="translated">Uma referência de objeto <ph id="ph1">`array`</ph> é inserido na pilha.</target>       </trans-unit>
        <trans-unit id="2579" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_U1">
          <source>An index value <ph id="ph1">`index`</ph> is pushed onto the stack.</source>
          <target state="translated">Um valor de índice <ph id="ph1">`index`</ph> é inserido na pilha.</target>       </trans-unit>
        <trans-unit id="2580" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_U1">
          <source><ph id="ph1">`index`</ph> and <ph id="ph2">`array`</ph> are popped from the stack; the value stored at position <ph id="ph3">`index`</ph> in <ph id="ph4">`array`</ph> is looked up.</source>
          <target state="translated"><ph id="ph1">`index`</ph> e <ph id="ph2">`array`</ph> são disparados da pilha; o valor armazenado na posição <ph id="ph3">`index`</ph> em <ph id="ph4">`array`</ph> é pesquisada.</target>       </trans-unit>
        <trans-unit id="2581" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_U1">
          <source>The value is pushed onto the stack.</source>
          <target state="translated">O valor é inserido na pilha.</target>       </trans-unit>
        <trans-unit id="2582" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_U1">
          <source>The <ph id="ph1">`ldelem.u1`</ph> instruction loads the value of the element with index <ph id="ph2">`index`</ph> (type <ph id="ph3">`native int`</ph>) in the zero-based one-dimensional array <ph id="ph4">`array`</ph> and places it on the top of the stack.</source>
          <target state="translated">O <ph id="ph1">`ldelem.u1`</ph> instrução carrega o valor do elemento com index <ph id="ph2">`index`</ph> (tipo <ph id="ph3">`native int`</ph>) na matriz unidimensional de base zero <ph id="ph4">`array`</ph> e o coloca na parte superior da pilha.</target>       </trans-unit>
        <trans-unit id="2583" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_U1">
          <source>Arrays are objects and hence represented by a value of type <ph id="ph1">`O`</ph>.</source>
          <target state="translated">Matrizes de objetos e, portanto, é representado por um valor do tipo <ph id="ph1">`O`</ph>.</target>       </trans-unit>
        <trans-unit id="2584" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_U1">
          <source>The return value for <ph id="ph1">`ldelem.u1`</ph> is <ph id="ph2">`int8`</ph>.</source>
          <target state="translated">O valor de retorno <ph id="ph1">`ldelem.u1`</ph> é <ph id="ph2">`int8`</ph>.</target>       </trans-unit>
        <trans-unit id="2585" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_U1">
          <source>Note that integer values of less than 4 bytes are extended to <ph id="ph1">`int32`</ph> (not <ph id="ph2">`native int`</ph>) when they are loaded onto the evaluation stack.</source>
          <target state="translated">Observe que os valores inteiros de menos de 4 bytes são estendidos para <ph id="ph1">`int32`</ph> (não <ph id="ph2">`native int`</ph>) quando eles são carregados para a pilha de avaliação.</target>       </trans-unit>
        <trans-unit id="2586" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_U1">
          <source><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> is thrown if <ph id="ph2">`array`</ph> is a null reference.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> será gerada se <ph id="ph2">`array`</ph> é uma referência nula.</target>       </trans-unit>
        <trans-unit id="2587" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_U1">
          <source><ph id="ph1">&lt;xref:System.ArrayTypeMismatchException&gt;</ph> is thrown if <ph id="ph2">`array`</ph> does not hold elements of the required type.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.ArrayTypeMismatchException&gt;</ph> será gerada se <ph id="ph2">`array`</ph> não contém elementos do tipo necessário.</target>       </trans-unit>
        <trans-unit id="2588" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_U1">
          <source><ph id="ph1">&lt;xref:System.IndexOutOfRangeException&gt;</ph> is thrown if <ph id="ph2">`index`</ph> is negative, or larger than the bound of <ph id="ph3">`array`</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.IndexOutOfRangeException&gt;</ph> será gerada se <ph id="ph2">`index`</ph> é negativo ou maior que o limite de <ph id="ph3">`array`</ph>.</target>       </trans-unit>
        <trans-unit id="2589" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_U1">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`ldelem.u1`</ph> opcode:</source>
          <target state="translated">O seguinte <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> sobrecarga de método pode usar o <ph id="ph2">`ldelem.u1`</ph> opcode:</target>       </trans-unit>
        <trans-unit id="2590" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_U1">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="2591" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Ldelem_U2">
          <source>Loads the element with type <ph id="ph1">&lt;see langword="unsigned int16" /&gt;</ph> at a specified array index onto the top of the evaluation stack as an <ph id="ph2">&lt;see langword="int32" /&gt;</ph>.</source>
          <target state="translated">Carrega o elemento com o tipo <ph id="ph1">&lt;see langword="unsigned int16" /&gt;</ph> em um índice de matriz especificado para o topo da pilha de avaliação como um <ph id="ph2">&lt;see langword="int32" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2592" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_U2">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">A tabela a seguir lista as instruções hexadecimal e formato de assembly do Microsoft Intermediate Language (MSIL), junto com um resumo breve de referência:</target>       </trans-unit>
        <trans-unit id="2593" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_U2">
          <source>Format</source>
          <target state="translated">Formatar</target>       </trans-unit>
        <trans-unit id="2594" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_U2">
          <source>Assembly Format</source>
          <target state="translated">Formato de assembly</target>       </trans-unit>
        <trans-unit id="2595" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_U2">
          <source>Description</source>
          <target state="translated">Descrição</target>       </trans-unit>
        <trans-unit id="2596" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_U2">
          <source>93</source>
          <target state="translated">93</target>       </trans-unit>
        <trans-unit id="2597" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_U2">
          <source>ldelem.u2</source>
          <target state="translated">ldelem.u2</target>       </trans-unit>
        <trans-unit id="2598" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_U2">
          <source>Loads the element with type <ph id="ph1">`unsigned int16`</ph> at index onto the top of the stack as an <ph id="ph2">`int32`</ph>.</source>
          <target state="translated">Carrega o elemento com o tipo <ph id="ph1">`unsigned int16`</ph> no índice para o topo da pilha de como um <ph id="ph2">`int32`</ph>.</target>       </trans-unit>
        <trans-unit id="2599" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_U2">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">O comportamento de transição de pilha, em ordem sequencial, é:</target>       </trans-unit>
        <trans-unit id="2600" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_U2">
          <source>An object reference <ph id="ph1">`array`</ph> is pushed onto the stack.</source>
          <target state="translated">Uma referência de objeto <ph id="ph1">`array`</ph> é inserido na pilha.</target>       </trans-unit>
        <trans-unit id="2601" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_U2">
          <source>An index value <ph id="ph1">`index`</ph> is pushed onto the stack.</source>
          <target state="translated">Um valor de índice <ph id="ph1">`index`</ph> é inserido na pilha.</target>       </trans-unit>
        <trans-unit id="2602" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_U2">
          <source><ph id="ph1">`index`</ph> and <ph id="ph2">`array`</ph> are popped from the stack; the value stored at position <ph id="ph3">`index`</ph> in <ph id="ph4">`array`</ph> is looked up.</source>
          <target state="translated"><ph id="ph1">`index`</ph> e <ph id="ph2">`array`</ph> são disparados da pilha; o valor armazenado na posição <ph id="ph3">`index`</ph> em <ph id="ph4">`array`</ph> é pesquisada.</target>       </trans-unit>
        <trans-unit id="2603" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_U2">
          <source>The value is pushed onto the stack.</source>
          <target state="translated">O valor é inserido na pilha.</target>       </trans-unit>
        <trans-unit id="2604" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_U2">
          <source>The <ph id="ph1">`ldelem.u2`</ph> instruction loads the value of the element with index <ph id="ph2">`index`</ph> (type <ph id="ph3">`native int`</ph>) in the zero-based one-dimensional array <ph id="ph4">`array`</ph> and places it on the top of the stack.</source>
          <target state="translated">O <ph id="ph1">`ldelem.u2`</ph> instrução carrega o valor do elemento com index <ph id="ph2">`index`</ph> (tipo <ph id="ph3">`native int`</ph>) na matriz unidimensional de base zero <ph id="ph4">`array`</ph> e o coloca na parte superior da pilha.</target>       </trans-unit>
        <trans-unit id="2605" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_U2">
          <source>Arrays are objects and hence represented by a value of type <ph id="ph1">`O`</ph>.</source>
          <target state="translated">Matrizes de objetos e, portanto, é representado por um valor do tipo <ph id="ph1">`O`</ph>.</target>       </trans-unit>
        <trans-unit id="2606" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_U2">
          <source>The return value for <ph id="ph1">`ldelem.u2`</ph> is <ph id="ph2">`int16`</ph>.</source>
          <target state="translated">O valor de retorno <ph id="ph1">`ldelem.u2`</ph> é <ph id="ph2">`int16`</ph>.</target>       </trans-unit>
        <trans-unit id="2607" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_U2">
          <source>Note that integer values of less than 4 bytes are extended to <ph id="ph1">`int32`</ph> (not <ph id="ph2">`native int`</ph>) when they are loaded onto the evaluation stack.</source>
          <target state="translated">Observe que os valores inteiros de menos de 4 bytes são estendidos para <ph id="ph1">`int32`</ph> (não <ph id="ph2">`native int`</ph>) quando eles são carregados para a pilha de avaliação.</target>       </trans-unit>
        <trans-unit id="2608" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_U2">
          <source><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> is thrown if <ph id="ph2">`array`</ph> is a null reference.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> será gerada se <ph id="ph2">`array`</ph> é uma referência nula.</target>       </trans-unit>
        <trans-unit id="2609" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_U2">
          <source><ph id="ph1">&lt;xref:System.ArrayTypeMismatchException&gt;</ph> is thrown if <ph id="ph2">`array`</ph> does not hold elements of the required type.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.ArrayTypeMismatchException&gt;</ph> será gerada se <ph id="ph2">`array`</ph> não contém elementos do tipo necessário.</target>       </trans-unit>
        <trans-unit id="2610" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_U2">
          <source><ph id="ph1">&lt;xref:System.IndexOutOfRangeException&gt;</ph> is thrown if <ph id="ph2">`index`</ph> is negative, or larger than the bound of <ph id="ph3">`array`</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.IndexOutOfRangeException&gt;</ph> será gerada se <ph id="ph2">`index`</ph> é negativo ou maior que o limite de <ph id="ph3">`array`</ph>.</target>       </trans-unit>
        <trans-unit id="2611" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_U2">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`ldelem.u2`</ph> opcode:</source>
          <target state="translated">O seguinte <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> sobrecarga de método pode usar o <ph id="ph2">`ldelem.u2`</ph> opcode:</target>       </trans-unit>
        <trans-unit id="2612" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_U2">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="2613" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Ldelem_U4">
          <source>Loads the element with type <ph id="ph1">&lt;see langword="unsigned int32" /&gt;</ph> at a specified array index onto the top of the evaluation stack as an <ph id="ph2">&lt;see langword="int32" /&gt;</ph>.</source>
          <target state="translated">Carrega o elemento com o tipo <ph id="ph1">&lt;see langword="unsigned int32" /&gt;</ph> em um índice de matriz especificado para o topo da pilha de avaliação como um <ph id="ph2">&lt;see langword="int32" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2614" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_U4">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">A tabela a seguir lista as instruções hexadecimal e formato de assembly do Microsoft Intermediate Language (MSIL), junto com um resumo breve de referência:</target>       </trans-unit>
        <trans-unit id="2615" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_U4">
          <source>Format</source>
          <target state="translated">Formatar</target>       </trans-unit>
        <trans-unit id="2616" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_U4">
          <source>Assembly Format</source>
          <target state="translated">Formato de assembly</target>       </trans-unit>
        <trans-unit id="2617" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_U4">
          <source>Description</source>
          <target state="translated">Descrição</target>       </trans-unit>
        <trans-unit id="2618" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_U4">
          <source>95</source>
          <target state="translated">95</target>       </trans-unit>
        <trans-unit id="2619" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_U4">
          <source>ldelem.u4</source>
          <target state="translated">Ldelem.U4</target>       </trans-unit>
        <trans-unit id="2620" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_U4">
          <source>Loads the element with type <ph id="ph1">`unsigned int32`</ph> at index onto the top of the stack as an <ph id="ph2">`int32`</ph>.</source>
          <target state="translated">Carrega o elemento com o tipo <ph id="ph1">`unsigned int32`</ph> no índice para o topo da pilha de como um <ph id="ph2">`int32`</ph>.</target>       </trans-unit>
        <trans-unit id="2621" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_U4">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">O comportamento de transição de pilha, em ordem sequencial, é:</target>       </trans-unit>
        <trans-unit id="2622" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_U4">
          <source>An object reference <ph id="ph1">`array`</ph> is pushed onto the stack.</source>
          <target state="translated">Uma referência de objeto <ph id="ph1">`array`</ph> é inserido na pilha.</target>       </trans-unit>
        <trans-unit id="2623" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_U4">
          <source>An index value <ph id="ph1">`index`</ph> is pushed onto the stack.</source>
          <target state="translated">Um valor de índice <ph id="ph1">`index`</ph> é inserido na pilha.</target>       </trans-unit>
        <trans-unit id="2624" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_U4">
          <source><ph id="ph1">`index`</ph> and <ph id="ph2">`array`</ph> are popped from the stack; the value stored at position <ph id="ph3">`index`</ph> in <ph id="ph4">`array`</ph> is looked up.</source>
          <target state="translated"><ph id="ph1">`index`</ph> e <ph id="ph2">`array`</ph> são disparados da pilha; o valor armazenado na posição <ph id="ph3">`index`</ph> em <ph id="ph4">`array`</ph> é pesquisada.</target>       </trans-unit>
        <trans-unit id="2625" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_U4">
          <source>The value is pushed onto the stack.</source>
          <target state="translated">O valor é inserido na pilha.</target>       </trans-unit>
        <trans-unit id="2626" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_U4">
          <source>The <ph id="ph1">`ldelem.u4`</ph> instruction loads the value of the element with index <ph id="ph2">`index`</ph> (type <ph id="ph3">`native int`</ph>) in the zero-based one-dimensional array <ph id="ph4">`array`</ph> and places it on the top of the stack.</source>
          <target state="translated">O <ph id="ph1">`ldelem.u4`</ph> instrução carrega o valor do elemento com index <ph id="ph2">`index`</ph> (tipo <ph id="ph3">`native int`</ph>) na matriz unidimensional de base zero <ph id="ph4">`array`</ph> e o coloca na parte superior da pilha.</target>       </trans-unit>
        <trans-unit id="2627" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_U4">
          <source>Arrays are objects and hence represented by a value of type <ph id="ph1">`O`</ph>.</source>
          <target state="translated">Matrizes de objetos e, portanto, é representado por um valor do tipo <ph id="ph1">`O`</ph>.</target>       </trans-unit>
        <trans-unit id="2628" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_U4">
          <source>The return value for <ph id="ph1">`ldelem.u4`</ph> is <ph id="ph2">`int32`</ph>.</source>
          <target state="translated">O valor de retorno <ph id="ph1">`ldelem.u4`</ph> é <ph id="ph2">`int32`</ph>.</target>       </trans-unit>
        <trans-unit id="2629" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_U4">
          <source>Note that integer values of less than 4 bytes are extended to <ph id="ph1">`int32`</ph> (not <ph id="ph2">`native int`</ph>) when they are loaded onto the evaluation stack.</source>
          <target state="translated">Observe que os valores inteiros de menos de 4 bytes são estendidos para <ph id="ph1">`int32`</ph> (não <ph id="ph2">`native int`</ph>) quando eles são carregados para a pilha de avaliação.</target>       </trans-unit>
        <trans-unit id="2630" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_U4">
          <source><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> is thrown if <ph id="ph2">`array`</ph> is a null reference.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> será gerada se <ph id="ph2">`array`</ph> é uma referência nula.</target>       </trans-unit>
        <trans-unit id="2631" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_U4">
          <source><ph id="ph1">&lt;xref:System.ArrayTypeMismatchException&gt;</ph> is thrown if array does not hold elements of the required type.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.ArrayTypeMismatchException&gt;</ph> é gerada se a matriz não contém elementos do tipo necessário.</target>       </trans-unit>
        <trans-unit id="2632" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_U4">
          <source><ph id="ph1">&lt;xref:System.IndexOutOfRangeException&gt;</ph> is thrown if <ph id="ph2">`index`</ph> is negative, or larger than the bound of <ph id="ph3">`array`</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.IndexOutOfRangeException&gt;</ph> será gerada se <ph id="ph2">`index`</ph> é negativo ou maior que o limite de <ph id="ph3">`array`</ph>.</target>       </trans-unit>
        <trans-unit id="2633" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_U4">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`ldelem.u4`</ph> opcode:</source>
          <target state="translated">O seguinte <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> sobrecarga de método pode usar o <ph id="ph2">`ldelem.u4`</ph> opcode:</target>       </trans-unit>
        <trans-unit id="2634" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_U4">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="2635" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Ldelema">
          <source>Loads the address of the array element at a specified array index onto the top of the evaluation stack as type <ph id="ph1">&lt;see langword="&amp;amp;" /&gt;</ph> (managed pointer).</source>
          <target state="translated">Carrega o endereço do elemento da matriz em um índice de matriz especificado no topo da pilha de avaliação como o tipo <ph id="ph1">&lt;see langword="&amp;amp;" /&gt;</ph> (ponteiro gerenciado).</target>       </trans-unit>
        <trans-unit id="2636" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelema">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">A tabela a seguir lista as instruções hexadecimal e formato de assembly do Microsoft Intermediate Language (MSIL), junto com um resumo breve de referência:</target>       </trans-unit>
        <trans-unit id="2637" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelema">
          <source>Format</source>
          <target state="translated">Formatar</target>       </trans-unit>
        <trans-unit id="2638" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelema">
          <source>Assembly Format</source>
          <target state="translated">Formato de assembly</target>       </trans-unit>
        <trans-unit id="2639" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelema">
          <source>Description</source>
          <target state="translated">Descrição</target>       </trans-unit>
        <trans-unit id="2640" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelema">
          <source>8F &lt; <ph id="ph1">`T`</ph><ph id="ph2"> &gt;</ph></source>
          <target state="translated">8F &lt; <ph id="ph1">`T`</ph><ph id="ph2"> &gt;</ph></target>       </trans-unit>
        <trans-unit id="2641" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelema">
          <source>ldelema <ph id="ph1">`class`</ph></source>
          <target state="translated">faltando ldelema <ph id="ph1">`class`</ph></target>       </trans-unit>
        <trans-unit id="2642" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelema">
          <source>Loads the address of the array element at <ph id="ph1">`index`</ph> onto the top of the evaluation stack as type <ph id="ph2">`&amp;`</ph> (managed pointer).</source>
          <target state="translated">Carrega o endereço do elemento da matriz em <ph id="ph1">`index`</ph> na parte superior da pilha de avaliação como tipo <ph id="ph2">`&amp;`</ph> (ponteiro gerenciado).</target>       </trans-unit>
        <trans-unit id="2643" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelema">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">O comportamento de transição de pilha, em ordem sequencial, é:</target>       </trans-unit>
        <trans-unit id="2644" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelema">
          <source>An object reference <ph id="ph1">`array`</ph> is pushed onto the stack.</source>
          <target state="translated">Uma referência de objeto <ph id="ph1">`array`</ph> é inserido na pilha.</target>       </trans-unit>
        <trans-unit id="2645" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelema">
          <source>An index value <ph id="ph1">`index`</ph> is pushed onto the stack.</source>
          <target state="translated">Um valor de índice <ph id="ph1">`index`</ph> é inserido na pilha.</target>       </trans-unit>
        <trans-unit id="2646" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelema">
          <source><ph id="ph1">`index`</ph> and <ph id="ph2">`array`</ph> are popped from the stack; the address stored at position <ph id="ph3">`index`</ph> in <ph id="ph4">`array`</ph> is looked up.</source>
          <target state="translated"><ph id="ph1">`index`</ph> e <ph id="ph2">`array`</ph> são disparados da pilha; o endereço armazenado na posição <ph id="ph3">`index`</ph> em <ph id="ph4">`array`</ph> é pesquisada.</target>       </trans-unit>
        <trans-unit id="2647" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelema">
          <source>The address is pushed onto the stack.</source>
          <target state="translated">O endereço é inserido na pilha.</target>       </trans-unit>
        <trans-unit id="2648" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelema">
          <source>The <ph id="ph1">`ldelema`</ph> is used to retrieve the address of an object at a particular index in an array of objects (of type <ph id="ph2">`class`</ph>).</source>
          <target state="translated">O <ph id="ph1">`ldelema`</ph> é usado para recuperar o endereço de um objeto em um determinado índice em uma matriz de objetos (do tipo <ph id="ph2">`class`</ph>).</target>       </trans-unit>
        <trans-unit id="2649" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelema">
          <source>The <ph id="ph1">`ldelema`</ph> instruction loads the address of the value at index <ph id="ph2">`index`</ph> (type <ph id="ph3">`native int`</ph>) in the zero-based one-dimensional array <ph id="ph4">`array`</ph> and places it on the top of the stack.</source>
          <target state="translated">O <ph id="ph1">`ldelema`</ph> instrução carrega o endereço do valor de índice <ph id="ph2">`index`</ph> (tipo <ph id="ph3">`native int`</ph>) na matriz unidimensional de base zero <ph id="ph4">`array`</ph> e o coloca na parte superior da pilha.</target>       </trans-unit>
        <trans-unit id="2650" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelema">
          <source>Arrays are objects and hence represented by a value of type <ph id="ph1">`O`</ph>.</source>
          <target state="translated">Matrizes de objetos e, portanto, é representado por um valor do tipo <ph id="ph1">`O`</ph>.</target>       </trans-unit>
        <trans-unit id="2651" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelema">
          <source>The value must be of type <ph id="ph1">`class`</ph> passed with the instruction.</source>
          <target state="translated">O valor deve ser do tipo <ph id="ph1">`class`</ph> passado com a instrução.</target>       </trans-unit>
        <trans-unit id="2652" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelema">
          <source>The return value for <ph id="ph1">`ldelema`</ph> is a managed pointer (type <ph id="ph2">`&amp;`</ph>).</source>
          <target state="translated">O valor de retorno <ph id="ph1">`ldelema`</ph> é um ponteiro gerenciado (tipo <ph id="ph2">`&amp;`</ph>).</target>       </trans-unit>
        <trans-unit id="2653" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelema">
          <source>Note that integer values of less than 4 bytes are extended to <ph id="ph1">`int32`</ph> (not <ph id="ph2">`native int`</ph>) when they are loaded onto the evaluation stack.</source>
          <target state="translated">Observe que os valores inteiros de menos de 4 bytes são estendidos para <ph id="ph1">`int32`</ph> (não <ph id="ph2">`native int`</ph>) quando eles são carregados para a pilha de avaliação.</target>       </trans-unit>
        <trans-unit id="2654" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelema">
          <source><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> is thrown if <ph id="ph2">`array`</ph> is a null reference.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> será gerada se <ph id="ph2">`array`</ph> é uma referência nula.</target>       </trans-unit>
        <trans-unit id="2655" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelema">
          <source><ph id="ph1">&lt;xref:System.ArrayTypeMismatchException&gt;</ph> is thrown if <ph id="ph2">`array`</ph> does not hold elements of the required type.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.ArrayTypeMismatchException&gt;</ph> será gerada se <ph id="ph2">`array`</ph> não contém elementos do tipo necessário.</target>       </trans-unit>
        <trans-unit id="2656" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelema">
          <source><ph id="ph1">&lt;xref:System.IndexOutOfRangeException&gt;</ph> is thrown if <ph id="ph2">`index`</ph> is negative, or larger than the bound of <ph id="ph3">`array`</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.IndexOutOfRangeException&gt;</ph> será gerada se <ph id="ph2">`index`</ph> é negativo ou maior que o limite de <ph id="ph3">`array`</ph>.</target>       </trans-unit>
        <trans-unit id="2657" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelema">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`ldelema`</ph> opcode:</source>
          <target state="translated">O seguinte <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> sobrecarga de método pode usar o <ph id="ph2">`ldelema`</ph> opcode:</target>       </trans-unit>
        <trans-unit id="2658" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelema">
          <source>ILGenerator.Emit(OpCode, Type)</source>
          <target state="translated">ILGenerator.Emit(OpCode, Type)</target>       </trans-unit>
        <trans-unit id="2659" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Ldfld">
          <source>Finds the value of a field in the object whose reference is currently on the evaluation stack.</source>
          <target state="translated">Localiza o valor de um campo no objeto cuja referência está na pilha de avaliação no momento.</target>       </trans-unit>
        <trans-unit id="2660" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldfld">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">A tabela a seguir lista as instruções hexadecimal e formato de assembly do Microsoft Intermediate Language (MSIL), junto com um resumo breve de referência:</target>       </trans-unit>
        <trans-unit id="2661" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldfld">
          <source>Format</source>
          <target state="translated">Formatar</target>       </trans-unit>
        <trans-unit id="2662" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldfld">
          <source>Assembly Format</source>
          <target state="translated">Formato de assembly</target>       </trans-unit>
        <trans-unit id="2663" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldfld">
          <source>Description</source>
          <target state="translated">Descrição</target>       </trans-unit>
        <trans-unit id="2664" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldfld">
          <source>7B &lt; <ph id="ph1">`T`</ph><ph id="ph2"> &gt;</ph></source>
          <target state="translated">7B &lt; <ph id="ph1">`T`</ph><ph id="ph2"> &gt;</ph></target>       </trans-unit>
        <trans-unit id="2665" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldfld">
          <source>ldfld <ph id="ph1">`field`</ph></source>
          <target state="translated">ldfld <ph id="ph1">`field`</ph></target>       </trans-unit>
        <trans-unit id="2666" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldfld">
          <source>Pushes the value of a field in a specified object onto the stack.</source>
          <target state="translated">Envia o valor de um campo em um objeto especificado para a pilha.</target>       </trans-unit>
        <trans-unit id="2667" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldfld">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">O comportamento de transição de pilha, em ordem sequencial, é:</target>       </trans-unit>
        <trans-unit id="2668" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldfld">
          <source>An object reference (or pointer) is pushed onto the stack.</source>
          <target state="translated">Uma referência de objeto (ou o ponteiro) é inserido na pilha.</target>       </trans-unit>
        <trans-unit id="2669" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldfld">
          <source>The object reference (or pointer) is popped from the stack; the value of the specified field in the object is found.</source>
          <target state="translated">A referência de objeto (ou o ponteiro) é exibido da pilha; o valor do campo especificado no objeto está localizado.</target>       </trans-unit>
        <trans-unit id="2670" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldfld">
          <source>The value stored in the field is pushed onto the stack.</source>
          <target state="translated">O valor armazenado no campo é inserido na pilha.</target>       </trans-unit>
        <trans-unit id="2671" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldfld">
          <source>The <ph id="ph1">`ldfld`</ph> instruction pushes the value of a field located in an object onto the stack.</source>
          <target state="translated">O <ph id="ph1">`ldfld`</ph> instrução envia o valor de um campo localizado em um objeto para a pilha.</target>       </trans-unit>
        <trans-unit id="2672" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldfld">
          <source>The object must be on the stack as an object reference (type <ph id="ph1">`O`</ph>), a managed pointer (type <ph id="ph2">`&amp;`</ph>), an unmanaged pointer (type <ph id="ph3">`native int`</ph>), a transient pointer (type <ph id="ph4">`*`</ph>), or an instance of a value type.</source>
          <target state="translated">O objeto deve estar na pilha como uma referência de objeto (tipo <ph id="ph1">`O`</ph>), um ponteiro gerenciado (tipo <ph id="ph2">`&amp;`</ph>), um ponteiro não gerenciado (tipo <ph id="ph3">`native int`</ph>), um ponteiro transitório (tipo <ph id="ph4">`*`</ph>), ou uma instância de um tipo de valor.</target>       </trans-unit>
        <trans-unit id="2673" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldfld">
          <source>The use of an unmanaged pointer is not permitted in verifiable code.</source>
          <target state="translated">O uso de um ponteiro não gerenciado não é permitido no código verificável.</target>       </trans-unit>
        <trans-unit id="2674" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldfld">
          <source>The object's field is specified by a metadata token that must refer to a field member.</source>
          <target state="translated">Campo do objeto é especificado por um token de metadados que deve se referir a um membro de campo.</target>       </trans-unit>
        <trans-unit id="2675" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldfld">
          <source>The return type is the same as the one associated with the field.</source>
          <target state="translated">O tipo de retorno é o mesmo que o associados ao campo.</target>       </trans-unit>
        <trans-unit id="2676" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldfld">
          <source>The field may be either an instance field (in which case the object must not be a null reference) or a static field.</source>
          <target state="translated">O campo pode ser um campo de instância (caso o objeto não deve ser uma referência nula) ou um campo estático.</target>       </trans-unit>
        <trans-unit id="2677" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldfld">
          <source>The <ph id="ph1">`ldfld`</ph> instruction can be preceded by either or both of the <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Unaligned&gt;</ph> and <ph id="ph3">&lt;xref:System.Reflection.Emit.OpCodes.Volatile&gt;</ph> prefixes.</source>
          <target state="translated">O <ph id="ph1">`ldfld`</ph> instruções podem ser precedidas por uma ou ambas as <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Unaligned&gt;</ph> e <ph id="ph3">&lt;xref:System.Reflection.Emit.OpCodes.Volatile&gt;</ph> prefixos.</target>       </trans-unit>
        <trans-unit id="2678" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldfld">
          <source><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> is thrown if the object is null and the field is not static.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> é gerada se o objeto é nulo e o campo não é estático.</target>       </trans-unit>
        <trans-unit id="2679" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldfld">
          <source><ph id="ph1">&lt;xref:System.MissingFieldException&gt;</ph> is thrown if the specified field is not found in the metadata.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.MissingFieldException&gt;</ph> é gerada se o campo especificado não foi encontrado nos metadados.</target>       </trans-unit>
        <trans-unit id="2680" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldfld">
          <source>This is typically checked when Microsoft Intermediate Language (MSIL) instructions are converted to native code, not at run time.</source>
          <target state="translated">Normalmente, isso é verificado quando instruções Microsoft Intermediate Language (MSIL) são convertidas em código nativo, não em tempo de execução.</target>       </trans-unit>
        <trans-unit id="2681" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldfld">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`ldfld`</ph> opcode:</source>
          <target state="translated">O seguinte <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> sobrecarga de método pode usar o <ph id="ph2">`ldfld`</ph> opcode:</target>       </trans-unit>
        <trans-unit id="2682" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldfld">
          <source>ILGenerator.Emit(OpCode, FieldInfo)</source>
          <target state="translated">ILGenerator.Emit(OpCode, FieldInfo)</target>       </trans-unit>
        <trans-unit id="2683" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Ldflda">
          <source>Finds the address of a field in the object whose reference is currently on the evaluation stack.</source>
          <target state="translated">Localiza o endereço de um campo no objeto cuja referência está na pilha de avaliação no momento.</target>       </trans-unit>
        <trans-unit id="2684" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldflda">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">A tabela a seguir lista as instruções hexadecimal e formato de assembly do Microsoft Intermediate Language (MSIL), junto com um resumo breve de referência:</target>       </trans-unit>
        <trans-unit id="2685" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldflda">
          <source>Format</source>
          <target state="translated">Formatar</target>       </trans-unit>
        <trans-unit id="2686" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldflda">
          <source>Assembly Format</source>
          <target state="translated">Formato de assembly</target>       </trans-unit>
        <trans-unit id="2687" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldflda">
          <source>Description</source>
          <target state="translated">Descrição</target>       </trans-unit>
        <trans-unit id="2688" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldflda">
          <source>7C &lt; <ph id="ph1">`T`</ph><ph id="ph2"> &gt;</ph></source>
          <target state="translated">7C &lt; <ph id="ph1">`T`</ph><ph id="ph2"> &gt;</ph></target>       </trans-unit>
        <trans-unit id="2689" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldflda">
          <source>ldflda <ph id="ph1">`field`</ph></source>
          <target state="translated">ldflda <ph id="ph1">`field`</ph></target>       </trans-unit>
        <trans-unit id="2690" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldflda">
          <source>Pushes the address of <ph id="ph1">`field`</ph> in a specified object onto the stack.</source>
          <target state="translated">Envia o endereço de <ph id="ph1">`field`</ph> em um objeto especificado para a pilha.</target>       </trans-unit>
        <trans-unit id="2691" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldflda">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">O comportamento de transição de pilha, em ordem sequencial, é:</target>       </trans-unit>
        <trans-unit id="2692" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldflda">
          <source>An object reference (or pointer) is pushed onto the stack.</source>
          <target state="translated">Uma referência de objeto (ou o ponteiro) é inserido na pilha.</target>       </trans-unit>
        <trans-unit id="2693" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldflda">
          <source>The object reference (or pointer) is popped from the stack; the address of the specified field in the object is found.</source>
          <target state="translated">A referência de objeto (ou o ponteiro) é exibido da pilha; o endereço do campo especificado no objeto foi encontrado.</target>       </trans-unit>
        <trans-unit id="2694" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldflda">
          <source>The address of the specified field is pushed onto the stack.</source>
          <target state="translated">O endereço do campo especificado é inserido na pilha.</target>       </trans-unit>
        <trans-unit id="2695" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldflda">
          <source>The <ph id="ph1">`ldflda`</ph> instruction pushes the address of a field located in an object onto the stack.</source>
          <target state="translated">O <ph id="ph1">`ldflda`</ph> instrução envia o endereço de um campo localizado em um objeto para a pilha.</target>       </trans-unit>
        <trans-unit id="2696" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldflda">
          <source>The object must be on the stack as an object reference (type <ph id="ph1">`O`</ph>), a managed pointer (type <ph id="ph2">`&amp;`</ph>), an unmanaged pointer (type <ph id="ph3">`native int`</ph>), a transient pointer (type <ph id="ph4">`*`</ph>), or an instance of a value type.</source>
          <target state="translated">O objeto deve estar na pilha como uma referência de objeto (tipo <ph id="ph1">`O`</ph>), um ponteiro gerenciado (tipo <ph id="ph2">`&amp;`</ph>), um ponteiro não gerenciado (tipo <ph id="ph3">`native int`</ph>), um ponteiro transitório (tipo <ph id="ph4">`*`</ph>), ou uma instância de um tipo de valor.</target>       </trans-unit>
        <trans-unit id="2697" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldflda">
          <source>The use of an unmanaged pointer is not permitted in verifiable code.</source>
          <target state="translated">O uso de um ponteiro não gerenciado não é permitido no código verificável.</target>       </trans-unit>
        <trans-unit id="2698" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldflda">
          <source>The object's field is specified by a metadata token that must refer to a field member.</source>
          <target state="translated">Campo do objeto é especificado por um token de metadados que deve se referir a um membro de campo.</target>       </trans-unit>
        <trans-unit id="2699" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldflda">
          <source>The value returned by <ph id="ph1">`ldflda`</ph> is a managed pointer (type <ph id="ph2">`&amp;`</ph>) unless the object is pushed onto the stack as an unmanaged pointer, in which case the return address is also an unmanaged pointer (type <ph id="ph3">`native int`</ph>).</source>
          <target state="translated">O valor retornado por <ph id="ph1">`ldflda`</ph> é um ponteiro gerenciado (tipo <ph id="ph2">`&amp;`</ph>), a menos que o objeto é inserido na pilha como um ponteiro não gerenciado, caso em que o endereço de retorno também é um ponteiro não gerenciado (tipo <ph id="ph3">`native int`</ph>).</target>       </trans-unit>
        <trans-unit id="2700" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldflda">
          <source>The <ph id="ph1">`ldflda`</ph> instruction can be preceded by either or both of the <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Unaligned&gt;</ph> and <ph id="ph3">&lt;xref:System.Reflection.Emit.OpCodes.Volatile&gt;</ph> prefixes.</source>
          <target state="translated">O <ph id="ph1">`ldflda`</ph> instruções podem ser precedidas por uma ou ambas as <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Unaligned&gt;</ph> e <ph id="ph3">&lt;xref:System.Reflection.Emit.OpCodes.Volatile&gt;</ph> prefixos.</target>       </trans-unit>
        <trans-unit id="2701" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldflda">
          <source><ph id="ph1">&lt;xref:System.InvalidOperationException&gt;</ph> is thrown if the object is not within the application domain from which it is being accessed.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.InvalidOperationException&gt;</ph> é gerada se o objeto não está dentro do domínio de aplicativo do qual ele está sendo acessado.</target>       </trans-unit>
        <trans-unit id="2702" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldflda">
          <source>The address of a field that is not inside the accessing application domain cannot be loaded.</source>
          <target state="translated">Não é possível carregar o endereço de um campo que não está dentro do domínio de aplicativo ao acessar.</target>       </trans-unit>
        <trans-unit id="2703" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldflda">
          <source><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> is thrown if the object is null and the field is not static.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> é gerada se o objeto é nulo e o campo não é estático.</target>       </trans-unit>
        <trans-unit id="2704" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldflda">
          <source><ph id="ph1">&lt;xref:System.MissingFieldException&gt;</ph> is thrown if the specified field is not found in the metadata.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.MissingFieldException&gt;</ph> é gerada se o campo especificado não foi encontrado nos metadados.</target>       </trans-unit>
        <trans-unit id="2705" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldflda">
          <source>This is typically checked when Microsoft Intermediate Language (MSIL) instructions are converted to native code, not at run time.</source>
          <target state="translated">Normalmente, isso é verificado quando instruções Microsoft Intermediate Language (MSIL) são convertidas em código nativo, não em tempo de execução.</target>       </trans-unit>
        <trans-unit id="2706" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldflda">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`ldflda`</ph> opcode:</source>
          <target state="translated">O seguinte <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> sobrecarga de método pode usar o <ph id="ph2">`ldflda`</ph> opcode:</target>       </trans-unit>
        <trans-unit id="2707" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldflda">
          <source>ILGenerator.Emit(OpCode, FieldInfo)</source>
          <target state="translated">ILGenerator.Emit(OpCode, FieldInfo)</target>       </trans-unit>
        <trans-unit id="2708" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Ldftn">
          <source>Pushes an unmanaged pointer (type <ph id="ph1">&lt;see langword="native int" /&gt;</ph>) to the native code implementing a specific method onto the evaluation stack.</source>
          <target state="translated">Envia um ponteiro não gerenciado (tipo <ph id="ph1">&lt;see langword="native int" /&gt;</ph>) para o código nativo implementando um método específico na pilha de avaliação.</target>       </trans-unit>
        <trans-unit id="2709" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldftn">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">A tabela a seguir lista as instruções hexadecimal e formato de assembly do Microsoft Intermediate Language (MSIL), junto com um resumo breve de referência:</target>       </trans-unit>
        <trans-unit id="2710" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldftn">
          <source>Format</source>
          <target state="translated">Formatar</target>       </trans-unit>
        <trans-unit id="2711" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldftn">
          <source>Assembly Format</source>
          <target state="translated">Formato de assembly</target>       </trans-unit>
        <trans-unit id="2712" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldftn">
          <source>Description</source>
          <target state="translated">Descrição</target>       </trans-unit>
        <trans-unit id="2713" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldftn">
          <source>FE 06 &lt; <ph id="ph1">`T`</ph><ph id="ph2"> &gt;</ph></source>
          <target state="translated">FE 06 &lt; <ph id="ph1">`T`</ph><ph id="ph2"> &gt;</ph></target>       </trans-unit>
        <trans-unit id="2714" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldftn">
          <source>ldftn <ph id="ph1">`method`</ph></source>
          <target state="translated">ldftn <ph id="ph1">`method`</ph></target>       </trans-unit>
        <trans-unit id="2715" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldftn">
          <source>Pushes a pointer to a method referenced by <ph id="ph1">`method`</ph> on the stack.</source>
          <target state="translated">Envia um ponteiro para um método referenciado por <ph id="ph1">`method`</ph> na pilha.</target>       </trans-unit>
        <trans-unit id="2716" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldftn">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">O comportamento de transição de pilha, em ordem sequencial, é:</target>       </trans-unit>
        <trans-unit id="2717" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldftn">
          <source>The unmanaged pointer to a specific method is pushed onto the stack.</source>
          <target state="translated">O ponteiro não gerenciado para um método específico é inserido na pilha.</target>       </trans-unit>
        <trans-unit id="2718" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldftn">
          <source>The specific method (<ph id="ph1">`method`</ph>) can be called using the <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Calli&gt;</ph> instruction if it references a managed method (or a stub that transitions from managed to unmanaged code).</source>
          <target state="translated">O método específico (<ph id="ph1">`method`</ph>) pode ser chamado usando o <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Calli&gt;</ph> instrução se faz referência a um método gerenciado (ou um stub que faz a transição de código gerenciado para código não gerenciado).</target>       </trans-unit>
        <trans-unit id="2719" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldftn">
          <source>The value returned points to native code using the CLR calling convention.</source>
          <target state="translated">O valor retornado pontos para código nativo usando a convenção de chamada de CLR.</target>       </trans-unit>
        <trans-unit id="2720" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldftn">
          <source>This method pointer should not be passed to unmanaged native code as a callback routine.</source>
          <target state="translated">Este ponteiro de método não deve ser passado para código nativo não gerenciado, como uma rotina de retorno de chamada.</target>       </trans-unit>
        <trans-unit id="2721" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldftn">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`ldftn`</ph> opcode:</source>
          <target state="translated">O seguinte <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> sobrecarga de método pode usar o <ph id="ph2">`ldftn`</ph> opcode:</target>       </trans-unit>
        <trans-unit id="2722" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldftn">
          <source>ILGenerator.Emit(OpCode, MethodInfo)</source>
          <target state="translated">ILGenerator.Emit(OpCode, MethodInfo)</target>       </trans-unit>
        <trans-unit id="2723" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Ldind_I">
          <source>Loads a value of type <ph id="ph1">&lt;see langword="native int" /&gt;</ph> as a <ph id="ph2">&lt;see langword="native int" /&gt;</ph> onto the evaluation stack indirectly.</source>
          <target state="translated">Carrega um valor do tipo <ph id="ph1">&lt;see langword="native int" /&gt;</ph> como um <ph id="ph2">&lt;see langword="native int" /&gt;</ph> na pilha de avaliação indiretamente.</target>       </trans-unit>
        <trans-unit id="2724" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">A tabela a seguir lista as instruções hexadecimal e formato de assembly do Microsoft Intermediate Language (MSIL), junto com um resumo breve de referência:</target>       </trans-unit>
        <trans-unit id="2725" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I">
          <source>Format</source>
          <target state="translated">Formatar</target>       </trans-unit>
        <trans-unit id="2726" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I">
          <source>Assembly Format</source>
          <target state="translated">Formato de assembly</target>       </trans-unit>
        <trans-unit id="2727" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I">
          <source>Description</source>
          <target state="translated">Descrição</target>       </trans-unit>
        <trans-unit id="2728" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I">
          <source>4D</source>
          <target state="translated">4D</target>       </trans-unit>
        <trans-unit id="2729" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I">
          <source>ldind.i</source>
          <target state="translated">ldind.i</target>       </trans-unit>
        <trans-unit id="2730" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I">
          <source>Loads the <ph id="ph1">`native int`</ph> value at address <ph id="ph2">`addr`</ph> onto the stack as a <ph id="ph3">`native int`</ph>.</source>
          <target state="translated">Carrega o <ph id="ph1">`native int`</ph> valor no endereço <ph id="ph2">`addr`</ph> na pilha como um <ph id="ph3">`native int`</ph>.</target>       </trans-unit>
        <trans-unit id="2731" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">O comportamento de transição de pilha, em ordem sequencial, é:</target>       </trans-unit>
        <trans-unit id="2732" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I">
          <source>An address is pushed onto the stack.</source>
          <target state="translated">Um endereço é inserido na pilha.</target>       </trans-unit>
        <trans-unit id="2733" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I">
          <source>The address is popped from the stack; the value located at the address is fetched.</source>
          <target state="translated">O endereço é exibido da pilha; o valor localizado no endereço é buscado.</target>       </trans-unit>
        <trans-unit id="2734" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I">
          <source>The fetched value is pushed onto the stack.</source>
          <target state="translated">O valor de busca é inserido na pilha.</target>       </trans-unit>
        <trans-unit id="2735" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I">
          <source>The <ph id="ph1">`ldind.i`</ph> instruction indirectly loads a <ph id="ph2">`native int`</ph> value from the specified address (of type <ph id="ph3">`native int`</ph>, <ph id="ph4">`&amp;`</ph>, or *) onto the stack as a <ph id="ph5">`native int`</ph>.</source>
          <target state="translated">O <ph id="ph1">`ldind.i`</ph> instrução indiretamente carrega um <ph id="ph2">`native int`</ph> valor do endereço especificado (do tipo <ph id="ph3">`native int`</ph>, <ph id="ph4">`&amp;`</ph>, ou *) para a pilha como um <ph id="ph5">`native int`</ph>.</target>       </trans-unit>
        <trans-unit id="2736" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I">
          <source>All of the <ph id="ph1">`ldind`</ph> instructions are shortcuts for a <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Ldobj&gt;</ph> instruction that specifies the corresponding built-in value class.</source>
          <target state="translated">Todos os <ph id="ph1">`ldind`</ph> instruções são atalhos para um <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Ldobj&gt;</ph> instrução que especifica a classe de valor interna correspondente.</target>       </trans-unit>
        <trans-unit id="2737" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I">
          <source>Note that integer values of less than 4 bytes are extended to <ph id="ph1">`int32`</ph> (not <ph id="ph2">`native int`</ph>) when they are loaded onto the evaluation stack.</source>
          <target state="translated">Observe que os valores inteiros de menos de 4 bytes são estendidos para <ph id="ph1">`int32`</ph> (não <ph id="ph2">`native int`</ph>) quando eles são carregados para a pilha de avaliação.</target>       </trans-unit>
        <trans-unit id="2738" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I">
          <source>Floating-point values are converted to <ph id="ph1">`F`</ph> type when loaded onto the evaluation stack.</source>
          <target state="translated">Valores de ponto flutuante são convertidos em <ph id="ph1">`F`</ph> digite quando carregado para a pilha de avaliação.</target>       </trans-unit>
        <trans-unit id="2739" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I">
          <source>Correctly-formed Microsoft Intermediate Language (MSIL) ensures that the <ph id="ph1">`ldind`</ph> instructions are used in a manner consistent with the type of the pointer.</source>
          <target state="translated">Corretamente formado idioma MSIL (Microsoft Intermediate) garante que o <ph id="ph1">`ldind`</ph> instruções são usadas de maneira consistente com o tipo do ponteiro.</target>       </trans-unit>
        <trans-unit id="2740" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I">
          <source>The address initially pushed onto the stack must be aligned to the natural size of objects on the machine or a <ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> can occur (see the <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Unaligned&gt;</ph> prefix instruction for preventative measures).</source>
          <target state="translated">O endereço inserido inicialmente na pilha deve estar alinhado para o tamanho natural dos objetos no computador ou um <ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> pode ocorrer (consulte o <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Unaligned&gt;</ph> prefixo instruções para medidas preventivas).</target>       </trans-unit>
        <trans-unit id="2741" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I">
          <source>The results of all MSIL instructions that return addresses (for example, <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Ldloca&gt;</ph> and <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Ldarga&gt;</ph>) are safely aligned.</source>
          <target state="translated">Os resultados de todas as instruções da MSIL que retornam endereços (por exemplo, <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Ldloca&gt;</ph> e <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Ldarga&gt;</ph>) são alinhados com segurança.</target>       </trans-unit>
        <trans-unit id="2742" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I">
          <source>For datatypes larger than 1 byte, the byte ordering is dependent on the target CPU.</source>
          <target state="translated">Para tipos de dados maiores do que 1 byte, a ordenação de bytes é dependente de CPU de destino.</target>       </trans-unit>
        <trans-unit id="2743" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I">
          <source>Code that depends on byte ordering might not run on all platforms.</source>
          <target state="translated">Código que depende da ordem de bytes não pode ser executado em todas as plataformas.</target>       </trans-unit>
        <trans-unit id="2744" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I">
          <source><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> can be thrown if an invalid address is detected.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> pode ser gerada se um endereço inválido foi detectado.</target>       </trans-unit>
        <trans-unit id="2745" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`ldind.i`</ph> opcode:</source>
          <target state="translated">O seguinte <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> sobrecarga de método pode usar o <ph id="ph2">`ldind.i`</ph> opcode:</target>       </trans-unit>
        <trans-unit id="2746" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="2747" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Ldind_I1">
          <source>Loads a value of type <ph id="ph1">&lt;see langword="int8" /&gt;</ph> as an <ph id="ph2">&lt;see langword="int32" /&gt;</ph> onto the evaluation stack indirectly.</source>
          <target state="translated">Carrega um valor do tipo <ph id="ph1">&lt;see langword="int8" /&gt;</ph> como um <ph id="ph2">&lt;see langword="int32" /&gt;</ph> na pilha de avaliação indiretamente.</target>       </trans-unit>
        <trans-unit id="2748" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I1">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">A tabela a seguir lista as instruções hexadecimal e formato de assembly do Microsoft Intermediate Language (MSIL), junto com um resumo breve de referência:</target>       </trans-unit>
        <trans-unit id="2749" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I1">
          <source>Format</source>
          <target state="translated">Formatar</target>       </trans-unit>
        <trans-unit id="2750" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I1">
          <source>Assembly Format</source>
          <target state="translated">Formato de assembly</target>       </trans-unit>
        <trans-unit id="2751" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I1">
          <source>Description</source>
          <target state="translated">Descrição</target>       </trans-unit>
        <trans-unit id="2752" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I1">
          <source>46</source>
          <target state="translated">46</target>       </trans-unit>
        <trans-unit id="2753" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I1">
          <source>ldind.i1</source>
          <target state="translated">ldind.i1</target>       </trans-unit>
        <trans-unit id="2754" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I1">
          <source>Loads the <ph id="ph1">`int8`</ph> value at address <ph id="ph2">`addr`</ph> onto the stack as an <ph id="ph3">`int32`</ph>.</source>
          <target state="translated">Carrega o <ph id="ph1">`int8`</ph> valor no endereço <ph id="ph2">`addr`</ph> na pilha como um <ph id="ph3">`int32`</ph>.</target>       </trans-unit>
        <trans-unit id="2755" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I1">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">O comportamento de transição de pilha, em ordem sequencial, é:</target>       </trans-unit>
        <trans-unit id="2756" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I1">
          <source>An address is pushed onto the stack.</source>
          <target state="translated">Um endereço é inserido na pilha.</target>       </trans-unit>
        <trans-unit id="2757" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I1">
          <source>The address is popped from the stack; the value located at the address is fetched.</source>
          <target state="translated">O endereço é exibido da pilha; o valor localizado no endereço é buscado.</target>       </trans-unit>
        <trans-unit id="2758" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I1">
          <source>The fetched value is pushed onto the stack..</source>
          <target state="translated">O valor de busca é inserido na pilha.</target>       </trans-unit>
        <trans-unit id="2759" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I1">
          <source>The <ph id="ph1">`ldind.i1`</ph> instruction indirectly loads an <ph id="ph2">`int8`</ph> value from the specified address (of type <ph id="ph3">`native int`</ph>, <ph id="ph4">`&amp;`</ph>, or *) onto the stack as an <ph id="ph5">`int32`</ph>.</source>
          <target state="translated">O <ph id="ph1">`ldind.i1`</ph> instrução indiretamente carrega um <ph id="ph2">`int8`</ph> valor do endereço especificado (do tipo <ph id="ph3">`native int`</ph>, <ph id="ph4">`&amp;`</ph>, ou *) para a pilha como um <ph id="ph5">`int32`</ph>.</target>       </trans-unit>
        <trans-unit id="2760" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I1">
          <source>All of the <ph id="ph1">`ldind`</ph> instructions are shortcuts for a <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Ldobj&gt;</ph> instruction that specifies the corresponding built-in value class.</source>
          <target state="translated">Todos os <ph id="ph1">`ldind`</ph> instruções são atalhos para um <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Ldobj&gt;</ph> instrução que especifica a classe de valor interna correspondente.</target>       </trans-unit>
        <trans-unit id="2761" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I1">
          <source>Note that integer values of less than 4 bytes are extended to <ph id="ph1">`int32`</ph> (not <ph id="ph2">`native int`</ph>) when they are loaded onto the evaluation stack.</source>
          <target state="translated">Observe que os valores inteiros de menos de 4 bytes são estendidos para <ph id="ph1">`int32`</ph> (não <ph id="ph2">`native int`</ph>) quando eles são carregados para a pilha de avaliação.</target>       </trans-unit>
        <trans-unit id="2762" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I1">
          <source>Floating-point values are converted to <ph id="ph1">`F`</ph> type when loaded onto the evaluation stack.</source>
          <target state="translated">Valores de ponto flutuante são convertidos em <ph id="ph1">`F`</ph> digite quando carregado para a pilha de avaliação.</target>       </trans-unit>
        <trans-unit id="2763" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I1">
          <source>Correctly-formed Microsoft Intermediate Language (MSIL) ensures that the <ph id="ph1">`ldind`</ph> instructions are used in a manner consistent with the type of the pointer.</source>
          <target state="translated">Corretamente formado idioma MSIL (Microsoft Intermediate) garante que o <ph id="ph1">`ldind`</ph> instruções são usadas de maneira consistente com o tipo do ponteiro.</target>       </trans-unit>
        <trans-unit id="2764" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I1">
          <source>The address initially pushed onto the stack must be aligned to the natural size of objects on the machine or a <ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> can occur (see the <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Unaligned&gt;</ph> prefix instruction for preventative measures).</source>
          <target state="translated">O endereço inserido inicialmente na pilha deve estar alinhado para o tamanho natural dos objetos no computador ou um <ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> pode ocorrer (consulte o <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Unaligned&gt;</ph> prefixo instruções para medidas preventivas).</target>       </trans-unit>
        <trans-unit id="2765" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I1">
          <source>The results of all MSIL instructions that return addresses (for example, <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Ldloca&gt;</ph> and <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Ldarga&gt;</ph>) are safely aligned.</source>
          <target state="translated">Os resultados de todas as instruções da MSIL que retornam endereços (por exemplo, <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Ldloca&gt;</ph> e <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Ldarga&gt;</ph>) são alinhados com segurança.</target>       </trans-unit>
        <trans-unit id="2766" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I1">
          <source>For datatypes larger than 1 byte, the byte ordering is dependent on the target CPU.</source>
          <target state="translated">Para tipos de dados maiores do que 1 byte, a ordenação de bytes é dependente de CPU de destino.</target>       </trans-unit>
        <trans-unit id="2767" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I1">
          <source>Code that depends on byte ordering might not run on all platforms.</source>
          <target state="translated">Código que depende da ordem de bytes não pode ser executado em todas as plataformas.</target>       </trans-unit>
        <trans-unit id="2768" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I1">
          <source><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> can be thrown if an invalid address is detected.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> pode ser gerada se um endereço inválido foi detectado.</target>       </trans-unit>
        <trans-unit id="2769" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I1">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`ldind.i1`</ph> opcode:</source>
          <target state="translated">O seguinte <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> sobrecarga de método pode usar o <ph id="ph2">`ldind.i1`</ph> opcode:</target>       </trans-unit>
        <trans-unit id="2770" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I1">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="2771" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Ldind_I2">
          <source>Loads a value of type <ph id="ph1">&lt;see langword="int16" /&gt;</ph> as an <ph id="ph2">&lt;see langword="int32" /&gt;</ph> onto the evaluation stack indirectly.</source>
          <target state="translated">Carrega um valor do tipo <ph id="ph1">&lt;see langword="int16" /&gt;</ph> como um <ph id="ph2">&lt;see langword="int32" /&gt;</ph> na pilha de avaliação indiretamente.</target>       </trans-unit>
        <trans-unit id="2772" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I2">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">A tabela a seguir lista as instruções hexadecimal e formato de assembly do Microsoft Intermediate Language (MSIL), junto com um resumo breve de referência:</target>       </trans-unit>
        <trans-unit id="2773" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I2">
          <source>Format</source>
          <target state="translated">Formatar</target>       </trans-unit>
        <trans-unit id="2774" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I2">
          <source>Assembly Format</source>
          <target state="translated">Formato de assembly</target>       </trans-unit>
        <trans-unit id="2775" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I2">
          <source>Description</source>
          <target state="translated">Descrição</target>       </trans-unit>
        <trans-unit id="2776" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I2">
          <source>48</source>
          <target state="translated">48</target>       </trans-unit>
        <trans-unit id="2777" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I2">
          <source>ldind.i2</source>
          <target state="translated">ldind.i2</target>       </trans-unit>
        <trans-unit id="2778" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I2">
          <source>Loads the <ph id="ph1">`int16`</ph> value at address <ph id="ph2">`addr`</ph> onto the stack as an <ph id="ph3">`int32`</ph>.</source>
          <target state="translated">Carrega o <ph id="ph1">`int16`</ph> valor no endereço <ph id="ph2">`addr`</ph> na pilha como um <ph id="ph3">`int32`</ph>.</target>       </trans-unit>
        <trans-unit id="2779" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I2">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">O comportamento de transição de pilha, em ordem sequencial, é:</target>       </trans-unit>
        <trans-unit id="2780" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I2">
          <source>An address is pushed onto the stack.</source>
          <target state="translated">Um endereço é inserido na pilha.</target>       </trans-unit>
        <trans-unit id="2781" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I2">
          <source>The address is popped from the stack; the value located at the address is fetched.</source>
          <target state="translated">O endereço é exibido da pilha; o valor localizado no endereço é buscado.</target>       </trans-unit>
        <trans-unit id="2782" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I2">
          <source>The fetched value is pushed onto the stack.</source>
          <target state="translated">O valor de busca é inserido na pilha.</target>       </trans-unit>
        <trans-unit id="2783" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I2">
          <source>The <ph id="ph1">`ldind.i2`</ph> instruction indirectly loads an <ph id="ph2">`int16`</ph> value from the specified address (of type <ph id="ph3">`native int`</ph>, <ph id="ph4">`&amp;`</ph>, or *) onto the stack as an <ph id="ph5">`int32`</ph>.</source>
          <target state="translated">O <ph id="ph1">`ldind.i2`</ph> instrução indiretamente carrega um <ph id="ph2">`int16`</ph> valor do endereço especificado (do tipo <ph id="ph3">`native int`</ph>, <ph id="ph4">`&amp;`</ph>, ou *) para a pilha como um <ph id="ph5">`int32`</ph>.</target>       </trans-unit>
        <trans-unit id="2784" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I2">
          <source>All of the <ph id="ph1">`ldind`</ph> instructions are shortcuts for a <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Ldobj&gt;</ph> instruction that specifies the corresponding built-in value class.</source>
          <target state="translated">Todos os <ph id="ph1">`ldind`</ph> instruções são atalhos para um <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Ldobj&gt;</ph> instrução que especifica a classe de valor interna correspondente.</target>       </trans-unit>
        <trans-unit id="2785" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I2">
          <source>Note that integer values of less than 4 bytes are extended to <ph id="ph1">`int32`</ph> (not <ph id="ph2">`native int`</ph>) when they are loaded onto the evaluation stack.</source>
          <target state="translated">Observe que os valores inteiros de menos de 4 bytes são estendidos para <ph id="ph1">`int32`</ph> (não <ph id="ph2">`native int`</ph>) quando eles são carregados para a pilha de avaliação.</target>       </trans-unit>
        <trans-unit id="2786" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I2">
          <source>Floating-point values are converted to <ph id="ph1">`F`</ph> type when loaded onto the evaluation stack.</source>
          <target state="translated">Valores de ponto flutuante são convertidos em <ph id="ph1">`F`</ph> digite quando carregado para a pilha de avaliação.</target>       </trans-unit>
        <trans-unit id="2787" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I2">
          <source>Correctly-formed Microsoft Intermediate Language (MSIL) ensures that the <ph id="ph1">`ldind`</ph> instructions are used in a manner consistent with the type of the pointer.</source>
          <target state="translated">Corretamente formado idioma MSIL (Microsoft Intermediate) garante que o <ph id="ph1">`ldind`</ph> instruções são usadas de maneira consistente com o tipo do ponteiro.</target>       </trans-unit>
        <trans-unit id="2788" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I2">
          <source>The address initially pushed onto the stack must be aligned to the natural size of objects on the machine or a <ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> can occur (see the <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Unaligned&gt;</ph> prefix instruction for preventative measures).</source>
          <target state="translated">O endereço inserido inicialmente na pilha deve estar alinhado para o tamanho natural dos objetos no computador ou um <ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> pode ocorrer (consulte o <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Unaligned&gt;</ph> prefixo instruções para medidas preventivas).</target>       </trans-unit>
        <trans-unit id="2789" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I2">
          <source>The results of all MSIL instructions that return addresses (for example, <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Ldloca&gt;</ph> and <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Ldarga&gt;</ph>) are safely aligned.</source>
          <target state="translated">Os resultados de todas as instruções da MSIL que retornam endereços (por exemplo, <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Ldloca&gt;</ph> e <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Ldarga&gt;</ph>) são alinhados com segurança.</target>       </trans-unit>
        <trans-unit id="2790" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I2">
          <source>For datatypes larger than 1 byte, the byte ordering is dependent on the target CPU.</source>
          <target state="translated">Para tipos de dados maiores do que 1 byte, a ordenação de bytes é dependente de CPU de destino.</target>       </trans-unit>
        <trans-unit id="2791" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I2">
          <source>Code that depends on byte ordering might not run on all platforms.</source>
          <target state="translated">Código que depende da ordem de bytes não pode ser executado em todas as plataformas.</target>       </trans-unit>
        <trans-unit id="2792" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I2">
          <source><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> can be thrown if an invalid address is detected.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> pode ser gerada se um endereço inválido foi detectado.</target>       </trans-unit>
        <trans-unit id="2793" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I2">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`ldind.i2`</ph> opcode:</source>
          <target state="translated">O seguinte <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> sobrecarga de método pode usar o <ph id="ph2">`ldind.i2`</ph> opcode:</target>       </trans-unit>
        <trans-unit id="2794" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I2">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="2795" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Ldind_I4">
          <source>Loads a value of type <ph id="ph1">&lt;see langword="int32" /&gt;</ph> as an <ph id="ph2">&lt;see langword="int32" /&gt;</ph> onto the evaluation stack indirectly.</source>
          <target state="translated">Carrega um valor do tipo <ph id="ph1">&lt;see langword="int32" /&gt;</ph> como um <ph id="ph2">&lt;see langword="int32" /&gt;</ph> na pilha de avaliação indiretamente.</target>       </trans-unit>
        <trans-unit id="2796" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I4">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">A tabela a seguir lista as instruções hexadecimal e formato de assembly do Microsoft Intermediate Language (MSIL), junto com um resumo breve de referência:</target>       </trans-unit>
        <trans-unit id="2797" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I4">
          <source>Format</source>
          <target state="translated">Formatar</target>       </trans-unit>
        <trans-unit id="2798" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I4">
          <source>Assembly Format</source>
          <target state="translated">Formato de assembly</target>       </trans-unit>
        <trans-unit id="2799" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I4">
          <source>Description</source>
          <target state="translated">Descrição</target>       </trans-unit>
        <trans-unit id="2800" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I4">
          <source>4A</source>
          <target state="translated">4A</target>       </trans-unit>
        <trans-unit id="2801" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I4">
          <source>ldind.i4</source>
          <target state="translated">ldind.i4</target>       </trans-unit>
        <trans-unit id="2802" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I4">
          <source>Loads the <ph id="ph1">`int32`</ph> value at address <ph id="ph2">`addr`</ph> onto the stack as an <ph id="ph3">`int32`</ph>.</source>
          <target state="translated">Carrega o <ph id="ph1">`int32`</ph> valor no endereço <ph id="ph2">`addr`</ph> na pilha como um <ph id="ph3">`int32`</ph>.</target>       </trans-unit>
        <trans-unit id="2803" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I4">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">O comportamento de transição de pilha, em ordem sequencial, é:</target>       </trans-unit>
        <trans-unit id="2804" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I4">
          <source>An address is pushed onto the stack.</source>
          <target state="translated">Um endereço é inserido na pilha.</target>       </trans-unit>
        <trans-unit id="2805" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I4">
          <source>The address is popped from the stack; the value located at the address is fetched.</source>
          <target state="translated">O endereço é exibido da pilha; o valor localizado no endereço é buscado.</target>       </trans-unit>
        <trans-unit id="2806" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I4">
          <source>The fetched value is pushed onto the stack.</source>
          <target state="translated">O valor de busca é inserido na pilha.</target>       </trans-unit>
        <trans-unit id="2807" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I4">
          <source>The <ph id="ph1">`ldind.i4`</ph> instruction indirectly loads an <ph id="ph2">`int32`</ph> value from the specified address (of type <ph id="ph3">`native int`</ph>, <ph id="ph4">`&amp;`</ph>, or *) onto the stack as an <ph id="ph5">`int32`</ph>.</source>
          <target state="translated">O <ph id="ph1">`ldind.i4`</ph> instrução indiretamente carrega um <ph id="ph2">`int32`</ph> valor do endereço especificado (do tipo <ph id="ph3">`native int`</ph>, <ph id="ph4">`&amp;`</ph>, ou *) para a pilha como um <ph id="ph5">`int32`</ph>.</target>       </trans-unit>
        <trans-unit id="2808" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I4">
          <source>All of the <ph id="ph1">`ldind`</ph> instructions are shortcuts for a <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Ldobj&gt;</ph> instruction that specifies the corresponding built-in value class.</source>
          <target state="translated">Todos os <ph id="ph1">`ldind`</ph> instruções são atalhos para um <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Ldobj&gt;</ph> instrução que especifica a classe de valor interna correspondente.</target>       </trans-unit>
        <trans-unit id="2809" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I4">
          <source>Note that integer values of less than 4 bytes are extended to <ph id="ph1">`int32`</ph> (not <ph id="ph2">`native int`</ph>) when they are loaded onto the evaluation stack.</source>
          <target state="translated">Observe que os valores inteiros de menos de 4 bytes são estendidos para <ph id="ph1">`int32`</ph> (não <ph id="ph2">`native int`</ph>) quando eles são carregados para a pilha de avaliação.</target>       </trans-unit>
        <trans-unit id="2810" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I4">
          <source>Floating-point values are converted to <ph id="ph1">`F`</ph> type when loaded onto the evaluation stack.</source>
          <target state="translated">Valores de ponto flutuante são convertidos em <ph id="ph1">`F`</ph> digite quando carregado para a pilha de avaliação.</target>       </trans-unit>
        <trans-unit id="2811" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I4">
          <source>Correctly-formed Microsoft Intermediate Language (MSIL) ensures that the <ph id="ph1">`ldind`</ph> instructions are used in a manner consistent with the type of the pointer.</source>
          <target state="translated">Corretamente formado idioma MSIL (Microsoft Intermediate) garante que o <ph id="ph1">`ldind`</ph> instruções são usadas de maneira consistente com o tipo do ponteiro.</target>       </trans-unit>
        <trans-unit id="2812" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I4">
          <source>The address initially pushed onto the stack must be aligned to the natural size of objects on the machine or a <ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> can occur (see the <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Unaligned&gt;</ph> prefix instruction for preventative measures).</source>
          <target state="translated">O endereço inserido inicialmente na pilha deve estar alinhado para o tamanho natural dos objetos no computador ou um <ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> pode ocorrer (consulte o <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Unaligned&gt;</ph> prefixo instruções para medidas preventivas).</target>       </trans-unit>
        <trans-unit id="2813" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I4">
          <source>The results of all MSIL instructions that return addresses (for example, <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Ldloca&gt;</ph> and <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Ldarga&gt;</ph>) are safely aligned.</source>
          <target state="translated">Os resultados de todas as instruções da MSIL que retornam endereços (por exemplo, <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Ldloca&gt;</ph> e <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Ldarga&gt;</ph>) são alinhados com segurança.</target>       </trans-unit>
        <trans-unit id="2814" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I4">
          <source>For datatypes larger than 1 byte, the byte ordering is dependent on the target CPU.</source>
          <target state="translated">Para tipos de dados maiores do que 1 byte, a ordenação de bytes é dependente de CPU de destino.</target>       </trans-unit>
        <trans-unit id="2815" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I4">
          <source>Code that depends on byte ordering might not run on all platforms.</source>
          <target state="translated">Código que depende da ordem de bytes não pode ser executado em todas as plataformas.</target>       </trans-unit>
        <trans-unit id="2816" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I4">
          <source><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> can be thrown if an invalid address is detected.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> pode ser gerada se um endereço inválido foi detectado.</target>       </trans-unit>
        <trans-unit id="2817" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I4">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`ldind.i4`</ph> opcode:</source>
          <target state="translated">O seguinte <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> sobrecarga de método pode usar o <ph id="ph2">`ldind.i4`</ph> opcode:</target>       </trans-unit>
        <trans-unit id="2818" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I4">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="2819" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Ldind_I8">
          <source>Loads a value of type <ph id="ph1">&lt;see langword="int64" /&gt;</ph> as an <ph id="ph2">&lt;see langword="int64" /&gt;</ph> onto the evaluation stack indirectly.</source>
          <target state="translated">Carrega um valor do tipo <ph id="ph1">&lt;see langword="int64" /&gt;</ph> como um <ph id="ph2">&lt;see langword="int64" /&gt;</ph> na pilha de avaliação indiretamente.</target>       </trans-unit>
        <trans-unit id="2820" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I8">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">A tabela a seguir lista as instruções hexadecimal e formato de assembly do Microsoft Intermediate Language (MSIL), junto com um resumo breve de referência:</target>       </trans-unit>
        <trans-unit id="2821" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I8">
          <source>Format</source>
          <target state="translated">Formatar</target>       </trans-unit>
        <trans-unit id="2822" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I8">
          <source>Assembly Format</source>
          <target state="translated">Formato de assembly</target>       </trans-unit>
        <trans-unit id="2823" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I8">
          <source>Description</source>
          <target state="translated">Descrição</target>       </trans-unit>
        <trans-unit id="2824" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I8">
          <source>4C</source>
          <target state="translated">4C</target>       </trans-unit>
        <trans-unit id="2825" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I8">
          <source>ldind.i8</source>
          <target state="translated">ldind.i8</target>       </trans-unit>
        <trans-unit id="2826" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I8">
          <source>Loads the <ph id="ph1">`int64`</ph> value at address <ph id="ph2">`addr`</ph> onto the stack as an <ph id="ph3">`int64`</ph>.</source>
          <target state="translated">Carrega o <ph id="ph1">`int64`</ph> valor no endereço <ph id="ph2">`addr`</ph> na pilha como um <ph id="ph3">`int64`</ph>.</target>       </trans-unit>
        <trans-unit id="2827" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I8">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">O comportamento de transição de pilha, em ordem sequencial, é:</target>       </trans-unit>
        <trans-unit id="2828" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I8">
          <source>An address is pushed onto the stack.</source>
          <target state="translated">Um endereço é inserido na pilha.</target>       </trans-unit>
        <trans-unit id="2829" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I8">
          <source>The address is popped from the stack; the value located at the address is fetched.</source>
          <target state="translated">O endereço é exibido da pilha; o valor localizado no endereço é buscado.</target>       </trans-unit>
        <trans-unit id="2830" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I8">
          <source>The fetched value is pushed onto the stack.</source>
          <target state="translated">O valor de busca é inserido na pilha.</target>       </trans-unit>
        <trans-unit id="2831" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I8">
          <source>The <ph id="ph1">`ldind.i8`</ph> instruction indirectly loads an <ph id="ph2">`int64`</ph> value from the specified address (of type <ph id="ph3">`native int`</ph>, <ph id="ph4">`&amp;`</ph>, or *) onto the stack as an <ph id="ph5">`int64`</ph>.</source>
          <target state="translated">O <ph id="ph1">`ldind.i8`</ph> instrução indiretamente carrega um <ph id="ph2">`int64`</ph> valor do endereço especificado (do tipo <ph id="ph3">`native int`</ph>, <ph id="ph4">`&amp;`</ph>, ou *) para a pilha como um <ph id="ph5">`int64`</ph>.</target>       </trans-unit>
        <trans-unit id="2832" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I8">
          <source>All of the <ph id="ph1">`ldind`</ph> instructions are shortcuts for a <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Ldobj&gt;</ph> instruction that specifies the corresponding built-in value class.</source>
          <target state="translated">Todos os <ph id="ph1">`ldind`</ph> instruções são atalhos para um <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Ldobj&gt;</ph> instrução que especifica a classe de valor interna correspondente.</target>       </trans-unit>
        <trans-unit id="2833" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I8">
          <source>Note that integer values of less than 4 bytes are extended to <ph id="ph1">`int32`</ph> (not <ph id="ph2">`native int`</ph>) when they are loaded onto the evaluation stack.</source>
          <target state="translated">Observe que os valores inteiros de menos de 4 bytes são estendidos para <ph id="ph1">`int32`</ph> (não <ph id="ph2">`native int`</ph>) quando eles são carregados para a pilha de avaliação.</target>       </trans-unit>
        <trans-unit id="2834" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I8">
          <source>Floating-point values are converted to <ph id="ph1">`F`</ph> type when loaded onto the evaluation stack.</source>
          <target state="translated">Valores de ponto flutuante são convertidos em <ph id="ph1">`F`</ph> digite quando carregado para a pilha de avaliação.</target>       </trans-unit>
        <trans-unit id="2835" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I8">
          <source>Correctly-formed Microsoft Intermediate Language (MSIL) ensures that the <ph id="ph1">`ldind`</ph> instructions are used in a manner consistent with the type of the pointer.</source>
          <target state="translated">Corretamente formado idioma MSIL (Microsoft Intermediate) garante que o <ph id="ph1">`ldind`</ph> instruções são usadas de maneira consistente com o tipo do ponteiro.</target>       </trans-unit>
        <trans-unit id="2836" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I8">
          <source>The address initially pushed onto the stack must be aligned to the natural size of objects on the machine or a <ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> can occur (see the <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Unaligned&gt;</ph> prefix instruction for preventative measures).</source>
          <target state="translated">O endereço inserido inicialmente na pilha deve estar alinhado para o tamanho natural dos objetos no computador ou um <ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> pode ocorrer (consulte o <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Unaligned&gt;</ph> prefixo instruções para medidas preventivas).</target>       </trans-unit>
        <trans-unit id="2837" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I8">
          <source>The results of all MSIL instructions that return addresses (for example, <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Ldloca&gt;</ph> and <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Ldarga&gt;</ph>) are safely aligned.</source>
          <target state="translated">Os resultados de todas as instruções da MSIL que retornam endereços (por exemplo, <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Ldloca&gt;</ph> e <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Ldarga&gt;</ph>) são alinhados com segurança.</target>       </trans-unit>
        <trans-unit id="2838" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I8">
          <source>For datatypes larger than 1 byte, the byte ordering is dependent on the target CPU.</source>
          <target state="translated">Para tipos de dados maiores do que 1 byte, a ordenação de bytes é dependente de CPU de destino.</target>       </trans-unit>
        <trans-unit id="2839" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I8">
          <source>Code that depends on byte ordering might not run on all platforms.</source>
          <target state="translated">Código que depende da ordem de bytes não pode ser executado em todas as plataformas.</target>       </trans-unit>
        <trans-unit id="2840" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I8">
          <source><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> can be thrown if an invalid address is detected.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> pode ser gerada se um endereço inválido foi detectado.</target>       </trans-unit>
        <trans-unit id="2841" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I8">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`ldind.i8`</ph> opcode:</source>
          <target state="translated">O seguinte <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> sobrecarga de método pode usar o <ph id="ph2">`ldind.i8`</ph> opcode:</target>       </trans-unit>
        <trans-unit id="2842" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I8">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="2843" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Ldind_R4">
          <source>Loads a value of type <ph id="ph1">&lt;see langword="float32" /&gt;</ph> as a type <ph id="ph2">&lt;see langword="F" /&gt;</ph> (float) onto the evaluation stack indirectly.</source>
          <target state="translated">Carrega um valor do tipo <ph id="ph1">&lt;see langword="float32" /&gt;</ph> como um tipo <ph id="ph2">&lt;see langword="F" /&gt;</ph> (float) para a pilha de avaliação indiretamente.</target>       </trans-unit>
        <trans-unit id="2844" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_R4">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">A tabela a seguir lista as instruções hexadecimal e formato de assembly do Microsoft Intermediate Language (MSIL), junto com um resumo breve de referência:</target>       </trans-unit>
        <trans-unit id="2845" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_R4">
          <source>Format</source>
          <target state="translated">Formatar</target>       </trans-unit>
        <trans-unit id="2846" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_R4">
          <source>Assembly Format</source>
          <target state="translated">Formato de assembly</target>       </trans-unit>
        <trans-unit id="2847" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_R4">
          <source>Description</source>
          <target state="translated">Descrição</target>       </trans-unit>
        <trans-unit id="2848" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_R4">
          <source>4E</source>
          <target state="translated">4E</target>       </trans-unit>
        <trans-unit id="2849" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_R4">
          <source>ldind.r4</source>
          <target state="translated">ldind.r4</target>       </trans-unit>
        <trans-unit id="2850" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_R4">
          <source>Loads the <ph id="ph1">`float32`</ph> value at address <ph id="ph2">`addr`</ph> onto the stack as a type <ph id="ph3">`F`</ph>.</source>
          <target state="translated">Carrega o <ph id="ph1">`float32`</ph> valor no endereço <ph id="ph2">`addr`</ph> na pilha como um tipo <ph id="ph3">`F`</ph>.</target>       </trans-unit>
        <trans-unit id="2851" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_R4">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">O comportamento de transição de pilha, em ordem sequencial, é:</target>       </trans-unit>
        <trans-unit id="2852" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_R4">
          <source>An address is pushed onto the stack.</source>
          <target state="translated">Um endereço é inserido na pilha.</target>       </trans-unit>
        <trans-unit id="2853" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_R4">
          <source>The address is popped from the stack; the value located at the address is fetched.</source>
          <target state="translated">O endereço é exibido da pilha; o valor localizado no endereço é buscado.</target>       </trans-unit>
        <trans-unit id="2854" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_R4">
          <source>The fetched value is pushed onto the stack.</source>
          <target state="translated">O valor de busca é inserido na pilha.</target>       </trans-unit>
        <trans-unit id="2855" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_R4">
          <source>The <ph id="ph1">`ldind.r4`</ph> instruction indirectly loads a <ph id="ph2">`float32`</ph> value from the specified address (of type <ph id="ph3">`native int`</ph>, <ph id="ph4">`&amp;`</ph>, or *) onto the stack as a type <ph id="ph5">`F`</ph>.</source>
          <target state="translated">O <ph id="ph1">`ldind.r4`</ph> instrução indiretamente carrega um <ph id="ph2">`float32`</ph> valor do endereço especificado (do tipo <ph id="ph3">`native int`</ph>, <ph id="ph4">`&amp;`</ph>, ou *) para a pilha como um tipo <ph id="ph5">`F`</ph>.</target>       </trans-unit>
        <trans-unit id="2856" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_R4">
          <source>All of the <ph id="ph1">`ldind`</ph> instructions are shortcuts for a <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Ldobj&gt;</ph> instruction that specifies the corresponding built-in value class.</source>
          <target state="translated">Todos os <ph id="ph1">`ldind`</ph> instruções são atalhos para um <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Ldobj&gt;</ph> instrução que especifica a classe de valor interna correspondente.</target>       </trans-unit>
        <trans-unit id="2857" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_R4">
          <source>Note that integer values of less than 4 bytes are extended to <ph id="ph1">`int32`</ph> (not <ph id="ph2">`native int`</ph>) when they are loaded onto the evaluation stack.</source>
          <target state="translated">Observe que os valores inteiros de menos de 4 bytes são estendidos para <ph id="ph1">`int32`</ph> (não <ph id="ph2">`native int`</ph>) quando eles são carregados para a pilha de avaliação.</target>       </trans-unit>
        <trans-unit id="2858" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_R4">
          <source>Floating-point values are converted to <ph id="ph1">`F`</ph> type when loaded onto the evaluation stack.</source>
          <target state="translated">Valores de ponto flutuante são convertidos em <ph id="ph1">`F`</ph> digite quando carregado para a pilha de avaliação.</target>       </trans-unit>
        <trans-unit id="2859" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_R4">
          <source>Correctly-formed Microsoft Intermediate Language (MSIL) ensures that the <ph id="ph1">`ldind`</ph> instructions are used in a manner consistent with the type of the pointer.</source>
          <target state="translated">Corretamente formado idioma MSIL (Microsoft Intermediate) garante que o <ph id="ph1">`ldind`</ph> instruções são usadas de maneira consistente com o tipo do ponteiro.</target>       </trans-unit>
        <trans-unit id="2860" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_R4">
          <source>The address initially pushed onto the stack must be aligned to the natural size of objects on the machine or a <ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> can occur (see the <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Unaligned&gt;</ph> prefix instruction for preventative measures).</source>
          <target state="translated">O endereço inserido inicialmente na pilha deve estar alinhado para o tamanho natural dos objetos no computador ou um <ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> pode ocorrer (consulte o <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Unaligned&gt;</ph> prefixo instruções para medidas preventivas).</target>       </trans-unit>
        <trans-unit id="2861" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_R4">
          <source>The results of all MSIL instructions that return addresses (for example, <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Ldloca&gt;</ph> and <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Ldarga&gt;</ph>) are safely aligned.</source>
          <target state="translated">Os resultados de todas as instruções da MSIL que retornam endereços (por exemplo, <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Ldloca&gt;</ph> e <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Ldarga&gt;</ph>) são alinhados com segurança.</target>       </trans-unit>
        <trans-unit id="2862" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_R4">
          <source>For datatypes larger than 1 byte, the byte ordering is dependent on the target CPU.</source>
          <target state="translated">Para tipos de dados maiores do que 1 byte, a ordenação de bytes é dependente de CPU de destino.</target>       </trans-unit>
        <trans-unit id="2863" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_R4">
          <source>Code that depends on byte ordering might not run on all platforms.</source>
          <target state="translated">Código que depende da ordem de bytes não pode ser executado em todas as plataformas.</target>       </trans-unit>
        <trans-unit id="2864" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_R4">
          <source><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> can be thrown if an invalid address is detected.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> pode ser gerada se um endereço inválido foi detectado.</target>       </trans-unit>
        <trans-unit id="2865" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_R4">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`ldind.r4`</ph> opcode:</source>
          <target state="translated">O seguinte <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> sobrecarga de método pode usar o <ph id="ph2">`ldind.r4`</ph> opcode:</target>       </trans-unit>
        <trans-unit id="2866" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_R4">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="2867" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Ldind_R8">
          <source>Loads a value of type <ph id="ph1">&lt;see langword="float64" /&gt;</ph> as a type <ph id="ph2">&lt;see langword="F" /&gt;</ph> (float) onto the evaluation stack indirectly.</source>
          <target state="translated">Carrega um valor do tipo <ph id="ph1">&lt;see langword="float64" /&gt;</ph> como um tipo <ph id="ph2">&lt;see langword="F" /&gt;</ph> (float) para a pilha de avaliação indiretamente.</target>       </trans-unit>
        <trans-unit id="2868" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_R8">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">A tabela a seguir lista as instruções hexadecimal e formato de assembly do Microsoft Intermediate Language (MSIL), junto com um resumo breve de referência:</target>       </trans-unit>
        <trans-unit id="2869" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_R8">
          <source>Format</source>
          <target state="translated">Formatar</target>       </trans-unit>
        <trans-unit id="2870" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_R8">
          <source>Assembly Format</source>
          <target state="translated">Formato de assembly</target>       </trans-unit>
        <trans-unit id="2871" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_R8">
          <source>Description</source>
          <target state="translated">Descrição</target>       </trans-unit>
        <trans-unit id="2872" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_R8">
          <source>4F</source>
          <target state="translated">4F</target>       </trans-unit>
        <trans-unit id="2873" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_R8">
          <source>ldind.r8</source>
          <target state="translated">ldind.r8</target>       </trans-unit>
        <trans-unit id="2874" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_R8">
          <source>Loads the <ph id="ph1">`float64`</ph> value at address <ph id="ph2">`addr`</ph> onto the stack as a type <ph id="ph3">`F`</ph>.</source>
          <target state="translated">Carrega o <ph id="ph1">`float64`</ph> valor no endereço <ph id="ph2">`addr`</ph> na pilha como um tipo <ph id="ph3">`F`</ph>.</target>       </trans-unit>
        <trans-unit id="2875" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_R8">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">O comportamento de transição de pilha, em ordem sequencial, é:</target>       </trans-unit>
        <trans-unit id="2876" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_R8">
          <source>An address is pushed onto the stack.</source>
          <target state="translated">Um endereço é inserido na pilha.</target>       </trans-unit>
        <trans-unit id="2877" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_R8">
          <source>The address is popped from the stack; the value located at the address is fetched.</source>
          <target state="translated">O endereço é exibido da pilha; o valor localizado no endereço é buscado.</target>       </trans-unit>
        <trans-unit id="2878" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_R8">
          <source>The fetched value is pushed onto the stack.</source>
          <target state="translated">O valor de busca é inserido na pilha.</target>       </trans-unit>
        <trans-unit id="2879" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_R8">
          <source>The <ph id="ph1">`ldind.r8`</ph> instruction indirectly loads a <ph id="ph2">`float64`</ph> value from the specified address (of type <ph id="ph3">`native int`</ph>, <ph id="ph4">`&amp;`</ph>, or *) onto the stack as a <ph id="ph5">`float64`</ph>.</source>
          <target state="translated">O <ph id="ph1">`ldind.r8`</ph> instrução indiretamente carrega um <ph id="ph2">`float64`</ph> valor do endereço especificado (do tipo <ph id="ph3">`native int`</ph>, <ph id="ph4">`&amp;`</ph>, ou *) para a pilha como um <ph id="ph5">`float64`</ph>.</target>       </trans-unit>
        <trans-unit id="2880" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_R8">
          <source>All of the <ph id="ph1">`ldind`</ph> instructions are shortcuts for a <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Ldobj&gt;</ph> instruction that specifies the corresponding built-in value class.</source>
          <target state="translated">Todos os <ph id="ph1">`ldind`</ph> instruções são atalhos para um <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Ldobj&gt;</ph> instrução que especifica a classe de valor interna correspondente.</target>       </trans-unit>
        <trans-unit id="2881" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_R8">
          <source>Note that integer values of less than 4 bytes are extended to <ph id="ph1">`int32`</ph> (not <ph id="ph2">`native int`</ph>) when they are loaded onto the evaluation stack.</source>
          <target state="translated">Observe que os valores inteiros de menos de 4 bytes são estendidos para <ph id="ph1">`int32`</ph> (não <ph id="ph2">`native int`</ph>) quando eles são carregados para a pilha de avaliação.</target>       </trans-unit>
        <trans-unit id="2882" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_R8">
          <source>Floating-point values are converted to <ph id="ph1">`F`</ph> type when loaded onto the evaluation stack.</source>
          <target state="translated">Valores de ponto flutuante são convertidos em <ph id="ph1">`F`</ph> digite quando carregado para a pilha de avaliação.</target>       </trans-unit>
        <trans-unit id="2883" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_R8">
          <source>Correctly-formed Microsoft Intermediate Language (MSIL) ensures that the <ph id="ph1">`ldind`</ph> instructions are used in a manner consistent with the type of the pointer.</source>
          <target state="translated">Corretamente formado idioma MSIL (Microsoft Intermediate) garante que o <ph id="ph1">`ldind`</ph> instruções são usadas de maneira consistente com o tipo do ponteiro.</target>       </trans-unit>
        <trans-unit id="2884" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_R8">
          <source>The address initially pushed onto the stack must be aligned to the natural size of objects on the machine or a <ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> can occur (see the <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Unaligned&gt;</ph> prefix instruction for preventative measures).</source>
          <target state="translated">O endereço inserido inicialmente na pilha deve estar alinhado para o tamanho natural dos objetos no computador ou um <ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> pode ocorrer (consulte o <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Unaligned&gt;</ph> prefixo instruções para medidas preventivas).</target>       </trans-unit>
        <trans-unit id="2885" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_R8">
          <source>The results of all MSIL instructions that return addresses (for example, <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Ldloca&gt;</ph> and <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Ldarga&gt;</ph>) are safely aligned.</source>
          <target state="translated">Os resultados de todas as instruções da MSIL que retornam endereços (por exemplo, <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Ldloca&gt;</ph> e <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Ldarga&gt;</ph>) são alinhados com segurança.</target>       </trans-unit>
        <trans-unit id="2886" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_R8">
          <source>For datatypes larger than 1 byte, the byte ordering is dependent on the target CPU.</source>
          <target state="translated">Para tipos de dados maiores do que 1 byte, a ordenação de bytes é dependente de CPU de destino.</target>       </trans-unit>
        <trans-unit id="2887" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_R8">
          <source>Code that depends on byte ordering might not run on all platforms.</source>
          <target state="translated">Código que depende da ordem de bytes não pode ser executado em todas as plataformas.</target>       </trans-unit>
        <trans-unit id="2888" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_R8">
          <source><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> can be thrown if an invalid address is detected.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> pode ser gerada se um endereço inválido foi detectado.</target>       </trans-unit>
        <trans-unit id="2889" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_R8">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`ldind.r8`</ph> opcode:</source>
          <target state="translated">O seguinte <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> sobrecarga de método pode usar o <ph id="ph2">`ldind.r8`</ph> opcode:</target>       </trans-unit>
        <trans-unit id="2890" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_R8">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="2891" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Ldind_Ref">
          <source>Loads an object reference as a type <ph id="ph1">&lt;see langword="O" /&gt;</ph> (object reference) onto the evaluation stack indirectly.</source>
          <target state="translated">Carrega uma referência de objeto como um tipo <ph id="ph1">&lt;see langword="O" /&gt;</ph> (referência de objeto) para a pilha de avaliação indiretamente.</target>       </trans-unit>
        <trans-unit id="2892" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_Ref">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">A tabela a seguir lista as instruções hexadecimal e formato de assembly do Microsoft Intermediate Language (MSIL), junto com um resumo breve de referência:</target>       </trans-unit>
        <trans-unit id="2893" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_Ref">
          <source>Format</source>
          <target state="translated">Formatar</target>       </trans-unit>
        <trans-unit id="2894" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_Ref">
          <source>Assembly Format</source>
          <target state="translated">Formato de assembly</target>       </trans-unit>
        <trans-unit id="2895" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_Ref">
          <source>Description</source>
          <target state="translated">Descrição</target>       </trans-unit>
        <trans-unit id="2896" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_Ref">
          <source>50</source>
          <target state="translated">50</target>       </trans-unit>
        <trans-unit id="2897" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_Ref">
          <source>ldind.ref</source>
          <target state="translated">ldind.ref</target>       </trans-unit>
        <trans-unit id="2898" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_Ref">
          <source>Loads the object reference at address <ph id="ph1">`addr`</ph> onto the stack as a type <ph id="ph2">`O`</ph></source>
          <target state="translated">Carrega a referência de objeto no endereço <ph id="ph1">`addr`</ph> para a pilha como um tipo <ph id="ph2">`O`</ph></target>       </trans-unit>
        <trans-unit id="2899" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_Ref">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">O comportamento de transição de pilha, em ordem sequencial, é:</target>       </trans-unit>
        <trans-unit id="2900" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_Ref">
          <source>An address is pushed onto the stack.</source>
          <target state="translated">Um endereço é inserido na pilha.</target>       </trans-unit>
        <trans-unit id="2901" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_Ref">
          <source>The address is popped from the stack; the object reference located at the address is fetched.</source>
          <target state="translated">O endereço é exibido da pilha; a referência de objeto localizada no endereço é buscada.</target>       </trans-unit>
        <trans-unit id="2902" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_Ref">
          <source>The fetched reference is pushed onto the stack.</source>
          <target state="translated">A referência de busca é inserida na pilha.</target>       </trans-unit>
        <trans-unit id="2903" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_Ref">
          <source>The <ph id="ph1">`ldind.ref`</ph> instruction indirectly loads the object reference the specified address (of type <ph id="ph2">`native int`</ph>, <ph id="ph3">`&amp;`</ph>, or *) onto the stack as type <ph id="ph4">`O`</ph>.</source>
          <target state="translated">O <ph id="ph1">`ldind.ref`</ph> instrução indiretamente carrega a referência de objeto, o endereço especificado (do tipo <ph id="ph2">`native int`</ph>, <ph id="ph3">`&amp;`</ph>, ou *) para a pilha como tipo <ph id="ph4">`O`</ph>.</target>       </trans-unit>
        <trans-unit id="2904" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_Ref">
          <source>All of the <ph id="ph1">`ldind`</ph> instructions are shortcuts for a <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Ldobj&gt;</ph> instruction that specifies the corresponding built-in value class.</source>
          <target state="translated">Todos os <ph id="ph1">`ldind`</ph> instruções são atalhos para um <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Ldobj&gt;</ph> instrução que especifica a classe de valor interna correspondente.</target>       </trans-unit>
        <trans-unit id="2905" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_Ref">
          <source>Note that integer values of less than 4 bytes are extended to <ph id="ph1">`int32`</ph> (not <ph id="ph2">`native int`</ph>) when they are loaded onto the evaluation stack.</source>
          <target state="translated">Observe que os valores inteiros de menos de 4 bytes são estendidos para <ph id="ph1">`int32`</ph> (não <ph id="ph2">`native int`</ph>) quando eles são carregados para a pilha de avaliação.</target>       </trans-unit>
        <trans-unit id="2906" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_Ref">
          <source>Floating-point values are converted to <ph id="ph1">`F`</ph> type when loaded onto the evaluation stack.</source>
          <target state="translated">Valores de ponto flutuante são convertidos em <ph id="ph1">`F`</ph> digite quando carregado para a pilha de avaliação.</target>       </trans-unit>
        <trans-unit id="2907" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_Ref">
          <source>Correctly-formed Microsoft Intermediate Language (MSIL) ensures that the <ph id="ph1">`ldind`</ph> instructions are used in a manner consistent with the type of the pointer.</source>
          <target state="translated">Corretamente formado idioma MSIL (Microsoft Intermediate) garante que o <ph id="ph1">`ldind`</ph> instruções são usadas de maneira consistente com o tipo do ponteiro.</target>       </trans-unit>
        <trans-unit id="2908" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_Ref">
          <source>The address initially pushed onto the stack must be aligned to the natural size of objects on the machine or a <ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> can occur (see the <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Unaligned&gt;</ph> prefix instruction for preventative measures).</source>
          <target state="translated">O endereço inserido inicialmente na pilha deve estar alinhado para o tamanho natural dos objetos no computador ou um <ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> pode ocorrer (consulte o <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Unaligned&gt;</ph> prefixo instruções para medidas preventivas).</target>       </trans-unit>
        <trans-unit id="2909" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_Ref">
          <source>The results of all MSIL instructions that return addresses (for example, <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Ldloca&gt;</ph> and <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Ldarga&gt;</ph>) are safely aligned.</source>
          <target state="translated">Os resultados de todas as instruções da MSIL que retornam endereços (por exemplo, <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Ldloca&gt;</ph> e <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Ldarga&gt;</ph>) são alinhados com segurança.</target>       </trans-unit>
        <trans-unit id="2910" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_Ref">
          <source>For datatypes larger than 1 byte, the byte ordering is dependent on the target CPU.</source>
          <target state="translated">Para tipos de dados maiores do que 1 byte, a ordenação de bytes é dependente de CPU de destino.</target>       </trans-unit>
        <trans-unit id="2911" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_Ref">
          <source>Code that depends on byte ordering might not run on all platforms.</source>
          <target state="translated">Código que depende da ordem de bytes não pode ser executado em todas as plataformas.</target>       </trans-unit>
        <trans-unit id="2912" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_Ref">
          <source><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> can be thrown if an invalid address is detected.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> pode ser gerada se um endereço inválido foi detectado.</target>       </trans-unit>
        <trans-unit id="2913" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_Ref">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`ldind.ref`</ph> opcode:</source>
          <target state="translated">O seguinte <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> sobrecarga de método pode usar o <ph id="ph2">`ldind.ref`</ph> opcode:</target>       </trans-unit>
        <trans-unit id="2914" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_Ref">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="2915" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Ldind_U1">
          <source>Loads a value of type <ph id="ph1">&lt;see langword="unsigned int8" /&gt;</ph> as an <ph id="ph2">&lt;see langword="int32" /&gt;</ph> onto the evaluation stack indirectly.</source>
          <target state="translated">Carrega um valor do tipo <ph id="ph1">&lt;see langword="unsigned int8" /&gt;</ph> como um <ph id="ph2">&lt;see langword="int32" /&gt;</ph> na pilha de avaliação indiretamente.</target>       </trans-unit>
        <trans-unit id="2916" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_U1">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">A tabela a seguir lista as instruções hexadecimal e formato de assembly do Microsoft Intermediate Language (MSIL), junto com um resumo breve de referência:</target>       </trans-unit>
        <trans-unit id="2917" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_U1">
          <source>Format</source>
          <target state="translated">Formatar</target>       </trans-unit>
        <trans-unit id="2918" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_U1">
          <source>Assembly Format</source>
          <target state="translated">Formato de assembly</target>       </trans-unit>
        <trans-unit id="2919" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_U1">
          <source>Description</source>
          <target state="translated">Descrição</target>       </trans-unit>
        <trans-unit id="2920" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_U1">
          <source>47</source>
          <target state="translated">47</target>       </trans-unit>
        <trans-unit id="2921" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_U1">
          <source>ldind.u1</source>
          <target state="translated">ldind.u1</target>       </trans-unit>
        <trans-unit id="2922" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_U1">
          <source>Loads the <ph id="ph1">`unsigned int8`</ph> value at address <ph id="ph2">`addr`</ph> onto the stack as an <ph id="ph3">`int32`</ph>.</source>
          <target state="translated">Carrega o <ph id="ph1">`unsigned int8`</ph> valor no endereço <ph id="ph2">`addr`</ph> na pilha como um <ph id="ph3">`int32`</ph>.</target>       </trans-unit>
        <trans-unit id="2923" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_U1">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">O comportamento de transição de pilha, em ordem sequencial, é:</target>       </trans-unit>
        <trans-unit id="2924" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_U1">
          <source>An address is pushed onto the stack.</source>
          <target state="translated">Um endereço é inserido na pilha.</target>       </trans-unit>
        <trans-unit id="2925" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_U1">
          <source>The address is popped from the stack; the value located at the address is fetched.</source>
          <target state="translated">O endereço é exibido da pilha; o valor localizado no endereço é buscado.</target>       </trans-unit>
        <trans-unit id="2926" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_U1">
          <source>The fetched value is pushed onto the stack.</source>
          <target state="translated">O valor de busca é inserido na pilha.</target>       </trans-unit>
        <trans-unit id="2927" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_U1">
          <source>The <ph id="ph1">`ldind.u1`</ph> instruction indirectly loads an <ph id="ph2">`unsigned int8`</ph> value from the specified address (of type<ph id="ph3">`native int`</ph>, <ph id="ph4">`&amp;`</ph>, or *) onto the stack as an <ph id="ph5">`int32`</ph>.</source>
          <target state="translated">O <ph id="ph1">`ldind.u1`</ph> instrução indiretamente carrega um <ph id="ph2">`unsigned int8`</ph> valor do endereço especificado (do tipo<ph id="ph3">`native int`</ph>, <ph id="ph4">`&amp;`</ph>, ou *) para a pilha como um <ph id="ph5">`int32`</ph>.</target>       </trans-unit>
        <trans-unit id="2928" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_U1">
          <source>All of the <ph id="ph1">`ldind`</ph> instructions are shortcuts for a <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Ldobj&gt;</ph> instruction that specifies the corresponding built-in value class.</source>
          <target state="translated">Todos os <ph id="ph1">`ldind`</ph> instruções são atalhos para um <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Ldobj&gt;</ph> instrução que especifica a classe de valor interna correspondente.</target>       </trans-unit>
        <trans-unit id="2929" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_U1">
          <source>Note that integer values of less than 4 bytes are extended to <ph id="ph1">`int32`</ph> (not <ph id="ph2">`native int`</ph>) when they are loaded onto the evaluation stack.</source>
          <target state="translated">Observe que os valores inteiros de menos de 4 bytes são estendidos para <ph id="ph1">`int32`</ph> (não <ph id="ph2">`native int`</ph>) quando eles são carregados para a pilha de avaliação.</target>       </trans-unit>
        <trans-unit id="2930" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_U1">
          <source>Floating-point values are converted to <ph id="ph1">`F`</ph> type when loaded onto the evaluation stack.</source>
          <target state="translated">Valores de ponto flutuante são convertidos em <ph id="ph1">`F`</ph> digite quando carregado para a pilha de avaliação.</target>       </trans-unit>
        <trans-unit id="2931" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_U1">
          <source>Correctly-formed Microsoft Intermediate Language (MSIL) ensures that the <ph id="ph1">`ldind`</ph> instructions are used in a manner consistent with the type of the pointer.</source>
          <target state="translated">Corretamente formado idioma MSIL (Microsoft Intermediate) garante que o <ph id="ph1">`ldind`</ph> instruções são usadas de maneira consistente com o tipo do ponteiro.</target>       </trans-unit>
        <trans-unit id="2932" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_U1">
          <source>The address initially pushed onto the stack must be aligned to the natural size of objects on the machine or a <ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> can occur (see the <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Unaligned&gt;</ph> prefix instruction for preventative measures).</source>
          <target state="translated">O endereço inserido inicialmente na pilha deve estar alinhado para o tamanho natural dos objetos no computador ou um <ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> pode ocorrer (consulte o <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Unaligned&gt;</ph> prefixo instruções para medidas preventivas).</target>       </trans-unit>
        <trans-unit id="2933" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_U1">
          <source>The results of all MSIL instructions that return addresses (for example, <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Ldloca&gt;</ph> and <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Ldarga&gt;</ph>) are safely aligned.</source>
          <target state="translated">Os resultados de todas as instruções da MSIL que retornam endereços (por exemplo, <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Ldloca&gt;</ph> e <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Ldarga&gt;</ph>) são alinhados com segurança.</target>       </trans-unit>
        <trans-unit id="2934" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_U1">
          <source>For datatypes larger than 1 byte, the byte ordering is dependent on the target CPU.</source>
          <target state="translated">Para tipos de dados maiores do que 1 byte, a ordenação de bytes é dependente de CPU de destino.</target>       </trans-unit>
        <trans-unit id="2935" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_U1">
          <source>Code that depends on byte ordering might not run on all platforms.</source>
          <target state="translated">Código que depende da ordem de bytes não pode ser executado em todas as plataformas.</target>       </trans-unit>
        <trans-unit id="2936" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_U1">
          <source><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> can be thrown if an invalid address is detected.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> pode ser gerada se um endereço inválido foi detectado.</target>       </trans-unit>
        <trans-unit id="2937" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_U1">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`ldind.u1`</ph> opcode:</source>
          <target state="translated">O seguinte <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> sobrecarga de método pode usar o <ph id="ph2">`ldind.u1`</ph> opcode:</target>       </trans-unit>
        <trans-unit id="2938" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_U1">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="2939" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Ldind_U2">
          <source>Loads a value of type <ph id="ph1">&lt;see langword="unsigned int16" /&gt;</ph> as an <ph id="ph2">&lt;see langword="int32" /&gt;</ph> onto the evaluation stack indirectly.</source>
          <target state="translated">Carrega um valor do tipo <ph id="ph1">&lt;see langword="unsigned int16" /&gt;</ph> como um <ph id="ph2">&lt;see langword="int32" /&gt;</ph> na pilha de avaliação indiretamente.</target>       </trans-unit>
        <trans-unit id="2940" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_U2">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">A tabela a seguir lista as instruções hexadecimal e formato de assembly do Microsoft Intermediate Language (MSIL), junto com um resumo breve de referência:</target>       </trans-unit>
        <trans-unit id="2941" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_U2">
          <source>Format</source>
          <target state="translated">Formatar</target>       </trans-unit>
        <trans-unit id="2942" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_U2">
          <source>Assembly Format</source>
          <target state="translated">Formato de assembly</target>       </trans-unit>
        <trans-unit id="2943" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_U2">
          <source>Description</source>
          <target state="translated">Descrição</target>       </trans-unit>
        <trans-unit id="2944" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_U2">
          <source>49</source>
          <target state="translated">49</target>       </trans-unit>
        <trans-unit id="2945" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_U2">
          <source>ldind.u2</source>
          <target state="translated">ldind.u2</target>       </trans-unit>
        <trans-unit id="2946" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_U2">
          <source>Loads the <ph id="ph1">`unsigned int16`</ph> value at address <ph id="ph2">`addr`</ph> onto the stack as an <ph id="ph3">`int32`</ph>.</source>
          <target state="translated">Carrega o <ph id="ph1">`unsigned int16`</ph> valor no endereço <ph id="ph2">`addr`</ph> na pilha como um <ph id="ph3">`int32`</ph>.</target>       </trans-unit>
        <trans-unit id="2947" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_U2">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">O comportamento de transição de pilha, em ordem sequencial, é:</target>       </trans-unit>
        <trans-unit id="2948" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_U2">
          <source>An address is pushed onto the stack.</source>
          <target state="translated">Um endereço é inserido na pilha.</target>       </trans-unit>
        <trans-unit id="2949" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_U2">
          <source>The address is popped from the stack; the value located at the address is fetched.</source>
          <target state="translated">O endereço é exibido da pilha; o valor localizado no endereço é buscado.</target>       </trans-unit>
        <trans-unit id="2950" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_U2">
          <source>The fetched value is pushed onto the stack.</source>
          <target state="translated">O valor de busca é inserido na pilha.</target>       </trans-unit>
        <trans-unit id="2951" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_U2">
          <source>The <ph id="ph1">`ldind.u2`</ph> instruction indirectly loads an <ph id="ph2">`unsigned int16`</ph> value from the specified address (of type <ph id="ph3">`native int`</ph>, <ph id="ph4">`&amp;`</ph>, or *) onto the stack as an <ph id="ph5">`int32`</ph>.</source>
          <target state="translated">O <ph id="ph1">`ldind.u2`</ph> instrução indiretamente carrega um <ph id="ph2">`unsigned int16`</ph> valor do endereço especificado (do tipo <ph id="ph3">`native int`</ph>, <ph id="ph4">`&amp;`</ph>, ou *) para a pilha como um <ph id="ph5">`int32`</ph>.</target>       </trans-unit>
        <trans-unit id="2952" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_U2">
          <source>All of the <ph id="ph1">`ldind`</ph> instructions are shortcuts for a <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Ldobj&gt;</ph> instruction that specifies the corresponding built-in value class.</source>
          <target state="translated">Todos os <ph id="ph1">`ldind`</ph> instruções são atalhos para um <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Ldobj&gt;</ph> instrução que especifica a classe de valor interna correspondente.</target>       </trans-unit>
        <trans-unit id="2953" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_U2">
          <source>Note that integer values of less than 4 bytes are extended to <ph id="ph1">`int32`</ph> (not <ph id="ph2">`native int`</ph>) when they are loaded onto the evaluation stack.</source>
          <target state="translated">Observe que os valores inteiros de menos de 4 bytes são estendidos para <ph id="ph1">`int32`</ph> (não <ph id="ph2">`native int`</ph>) quando eles são carregados para a pilha de avaliação.</target>       </trans-unit>
        <trans-unit id="2954" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_U2">
          <source>Floating-point values are converted to <ph id="ph1">`F`</ph> type when loaded onto the evaluation stack.</source>
          <target state="translated">Valores de ponto flutuante são convertidos em <ph id="ph1">`F`</ph> digite quando carregado para a pilha de avaliação.</target>       </trans-unit>
        <trans-unit id="2955" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_U2">
          <source>Correctly-formed Microsoft Intermediate Language (MSIL) ensures that the <ph id="ph1">`ldind`</ph> instructions are used in a manner consistent with the type of the pointer.</source>
          <target state="translated">Corretamente formado idioma MSIL (Microsoft Intermediate) garante que o <ph id="ph1">`ldind`</ph> instruções são usadas de maneira consistente com o tipo do ponteiro.</target>       </trans-unit>
        <trans-unit id="2956" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_U2">
          <source>The address initially pushed onto the stack must be aligned to the natural size of objects on the machine or a <ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> can occur (see the <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Unaligned&gt;</ph> prefix instruction for preventative measures).</source>
          <target state="translated">O endereço inserido inicialmente na pilha deve estar alinhado para o tamanho natural dos objetos no computador ou um <ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> pode ocorrer (consulte o <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Unaligned&gt;</ph> prefixo instruções para medidas preventivas).</target>       </trans-unit>
        <trans-unit id="2957" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_U2">
          <source>The results of all MSIL instructions that return addresses (for example, <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Ldloca&gt;</ph> and <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Ldarga&gt;</ph>) are safely aligned.</source>
          <target state="translated">Os resultados de todas as instruções da MSIL que retornam endereços (por exemplo, <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Ldloca&gt;</ph> e <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Ldarga&gt;</ph>) são alinhados com segurança.</target>       </trans-unit>
        <trans-unit id="2958" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_U2">
          <source>For datatypes larger than 1 byte, the byte ordering is dependent on the target CPU.</source>
          <target state="translated">Para tipos de dados maiores do que 1 byte, a ordenação de bytes é dependente de CPU de destino.</target>       </trans-unit>
        <trans-unit id="2959" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_U2">
          <source>Code that depends on byte ordering might not run on all platforms.</source>
          <target state="translated">Código que depende da ordem de bytes não pode ser executado em todas as plataformas.</target>       </trans-unit>
        <trans-unit id="2960" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_U2">
          <source><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> can be thrown if an invalid address is detected.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> pode ser gerada se um endereço inválido foi detectado.</target>       </trans-unit>
        <trans-unit id="2961" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_U2">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`ldind.u2`</ph> opcode:</source>
          <target state="translated">O seguinte <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> sobrecarga de método pode usar o <ph id="ph2">`ldind.u2`</ph> opcode:</target>       </trans-unit>
        <trans-unit id="2962" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_U2">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="2963" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Ldind_U4">
          <source>Loads a value of type <ph id="ph1">&lt;see langword="unsigned int32" /&gt;</ph> as an <ph id="ph2">&lt;see langword="int32" /&gt;</ph> onto the evaluation stack indirectly.</source>
          <target state="translated">Carrega um valor do tipo <ph id="ph1">&lt;see langword="unsigned int32" /&gt;</ph> como um <ph id="ph2">&lt;see langword="int32" /&gt;</ph> na pilha de avaliação indiretamente.</target>       </trans-unit>
        <trans-unit id="2964" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_U4">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">A tabela a seguir lista as instruções hexadecimal e formato de assembly do Microsoft Intermediate Language (MSIL), junto com um resumo breve de referência:</target>       </trans-unit>
        <trans-unit id="2965" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_U4">
          <source>Format</source>
          <target state="translated">Formatar</target>       </trans-unit>
        <trans-unit id="2966" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_U4">
          <source>Assembly Format</source>
          <target state="translated">Formato de assembly</target>       </trans-unit>
        <trans-unit id="2967" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_U4">
          <source>Description</source>
          <target state="translated">Descrição</target>       </trans-unit>
        <trans-unit id="2968" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_U4">
          <source>4B</source>
          <target state="translated">4B</target>       </trans-unit>
        <trans-unit id="2969" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_U4">
          <source>ldind.u4</source>
          <target state="translated">ldind.u4</target>       </trans-unit>
        <trans-unit id="2970" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_U4">
          <source>Loads the <ph id="ph1">`unsigned int32`</ph> value at address <ph id="ph2">`addr`</ph> onto the stack as an <ph id="ph3">`int32`</ph>.</source>
          <target state="translated">Carrega o <ph id="ph1">`unsigned int32`</ph> valor no endereço <ph id="ph2">`addr`</ph> na pilha como um <ph id="ph3">`int32`</ph>.</target>       </trans-unit>
        <trans-unit id="2971" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_U4">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">O comportamento de transição de pilha, em ordem sequencial, é:</target>       </trans-unit>
        <trans-unit id="2972" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_U4">
          <source>An address is pushed onto the stack.</source>
          <target state="translated">Um endereço é inserido na pilha.</target>       </trans-unit>
        <trans-unit id="2973" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_U4">
          <source>The address is popped from the stack; the value located at the address is fetched.</source>
          <target state="translated">O endereço é exibido da pilha; o valor localizado no endereço é buscado.</target>       </trans-unit>
        <trans-unit id="2974" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_U4">
          <source>The fetched value is pushed onto the stack.</source>
          <target state="translated">O valor de busca é inserido na pilha.</target>       </trans-unit>
        <trans-unit id="2975" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_U4">
          <source>The <ph id="ph1">`ldind.u4`</ph> instruction indirectly loads an <ph id="ph2">`unsigned int32`</ph> value from the specified address (of type <ph id="ph3">`native int`</ph>, <ph id="ph4">`&amp;`</ph>, or *) onto the stack as an <ph id="ph5">`int32`</ph>.</source>
          <target state="translated">O <ph id="ph1">`ldind.u4`</ph> instrução indiretamente carrega um <ph id="ph2">`unsigned int32`</ph> valor do endereço especificado (do tipo <ph id="ph3">`native int`</ph>, <ph id="ph4">`&amp;`</ph>, ou *) para a pilha como um <ph id="ph5">`int32`</ph>.</target>       </trans-unit>
        <trans-unit id="2976" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_U4">
          <source>All of the <ph id="ph1">`ldind`</ph> instructions are shortcuts for a <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Ldobj&gt;</ph> instruction that specifies the corresponding built-in value class.</source>
          <target state="translated">Todos os <ph id="ph1">`ldind`</ph> instruções são atalhos para um <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Ldobj&gt;</ph> instrução que especifica a classe de valor interna correspondente.</target>       </trans-unit>
        <trans-unit id="2977" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_U4">
          <source>Note that integer values of less than 4 bytes are extended to <ph id="ph1">`int32`</ph> (not <ph id="ph2">`native int`</ph>) when they are loaded onto the evaluation stack.</source>
          <target state="translated">Observe que os valores inteiros de menos de 4 bytes são estendidos para <ph id="ph1">`int32`</ph> (não <ph id="ph2">`native int`</ph>) quando eles são carregados para a pilha de avaliação.</target>       </trans-unit>
        <trans-unit id="2978" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_U4">
          <source>Floating-point values are converted to <ph id="ph1">`F`</ph> type when loaded onto the evaluation stack.</source>
          <target state="translated">Valores de ponto flutuante são convertidos em <ph id="ph1">`F`</ph> digite quando carregado para a pilha de avaliação.</target>       </trans-unit>
        <trans-unit id="2979" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_U4">
          <source>Correctly-formed Microsoft Intermediate Language (MSIL) ensures that the <ph id="ph1">`ldind`</ph> instructions are used in a manner consistent with the type of the pointer.</source>
          <target state="translated">Corretamente formado idioma MSIL (Microsoft Intermediate) garante que o <ph id="ph1">`ldind`</ph> instruções são usadas de maneira consistente com o tipo do ponteiro.</target>       </trans-unit>
        <trans-unit id="2980" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_U4">
          <source>The address initially pushed onto the stack must be aligned to the natural size of objects on the machine or a <ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> can occur (see the <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Unaligned&gt;</ph> prefix instruction for preventative measures).</source>
          <target state="translated">O endereço inserido inicialmente na pilha deve estar alinhado para o tamanho natural dos objetos no computador ou um <ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> pode ocorrer (consulte o <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Unaligned&gt;</ph> prefixo instruções para medidas preventivas).</target>       </trans-unit>
        <trans-unit id="2981" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_U4">
          <source>The results of all MSIL instructions that return addresses (for example, <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Ldloca&gt;</ph> and <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Ldarga&gt;</ph>) are safely aligned.</source>
          <target state="translated">Os resultados de todas as instruções da MSIL que retornam endereços (por exemplo, <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Ldloca&gt;</ph> e <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Ldarga&gt;</ph>) são alinhados com segurança.</target>       </trans-unit>
        <trans-unit id="2982" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_U4">
          <source>For datatypes larger than 1 byte, the byte ordering is dependent on the target CPU.</source>
          <target state="translated">Para tipos de dados maiores do que 1 byte, a ordenação de bytes é dependente de CPU de destino.</target>       </trans-unit>
        <trans-unit id="2983" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_U4">
          <source>Code that depends on byte ordering might not run on all platforms.</source>
          <target state="translated">Código que depende da ordem de bytes não pode ser executado em todas as plataformas.</target>       </trans-unit>
        <trans-unit id="2984" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_U4">
          <source><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> can be thrown if an invalid address is detected.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> pode ser gerada se um endereço inválido foi detectado.</target>       </trans-unit>
        <trans-unit id="2985" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_U4">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`ldind.u4`</ph> opcode:</source>
          <target state="translated">O seguinte <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> sobrecarga de método pode usar o <ph id="ph2">`ldind.u4`</ph> opcode:</target>       </trans-unit>
        <trans-unit id="2986" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_U4">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="2987" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Ldlen">
          <source>Pushes the number of elements of a zero-based, one-dimensional array onto the evaluation stack.</source>
          <target state="translated">Efetua o push do número de elementos de uma matriz unidimensional de base zero para a pilha de avaliação.</target>       </trans-unit>
        <trans-unit id="2988" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldlen">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">A tabela a seguir lista as instruções hexadecimal e formato de assembly do Microsoft Intermediate Language (MSIL), junto com um resumo breve de referência:</target>       </trans-unit>
        <trans-unit id="2989" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldlen">
          <source>Format</source>
          <target state="translated">Formatar</target>       </trans-unit>
        <trans-unit id="2990" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldlen">
          <source>Assembly Format</source>
          <target state="translated">Formato de assembly</target>       </trans-unit>
        <trans-unit id="2991" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldlen">
          <source>Description</source>
          <target state="translated">Descrição</target>       </trans-unit>
        <trans-unit id="2992" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldlen">
          <source>8E</source>
          <target state="translated">8E</target>       </trans-unit>
        <trans-unit id="2993" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldlen">
          <source>ldlen</source>
          <target state="translated">ldlen</target>       </trans-unit>
        <trans-unit id="2994" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldlen">
          <source>Pushes the length (of type <ph id="ph1">`natural unsigned int`</ph>) of an array on the stack.</source>
          <target state="translated">Envia o comprimento (do tipo <ph id="ph1">`natural unsigned int`</ph>) de uma matriz na pilha.</target>       </trans-unit>
        <trans-unit id="2995" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldlen">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">O comportamento de transição de pilha, em ordem sequencial, é:</target>       </trans-unit>
        <trans-unit id="2996" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldlen">
          <source>An object reference to an array is pushed onto the stack.</source>
          <target state="translated">Uma referência de objeto para uma matriz é inserida na pilha.</target>       </trans-unit>
        <trans-unit id="2997" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldlen">
          <source>The array reference is popped from the stack and the length is computed.</source>
          <target state="translated">A referência da matriz é exibida da pilha e o comprimento é calculado.</target>       </trans-unit>
        <trans-unit id="2998" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldlen">
          <source>The length is pushed onto the stack.</source>
          <target state="translated">O comprimento é inserido na pilha.</target>       </trans-unit>
        <trans-unit id="2999" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldlen">
          <source>Arrays are objects and hence represented by a value of type <ph id="ph1">`O`</ph>.</source>
          <target state="translated">Matrizes de objetos e, portanto, é representado por um valor do tipo <ph id="ph1">`O`</ph>.</target>       </trans-unit>
        <trans-unit id="3000" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldlen">
          <source>The length is returned as a <ph id="ph1">`natural unsigned int`</ph>.</source>
          <target state="translated">O comprimento é retornado como um <ph id="ph1">`natural unsigned int`</ph>.</target>       </trans-unit>
        <trans-unit id="3001" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldlen">
          <source><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> is thrown if the array reference is a null reference.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> é gerada se a referência da matriz é uma referência nula.</target>       </trans-unit>
        <trans-unit id="3002" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldlen">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`ldlen`</ph> opcode:</source>
          <target state="translated">O seguinte <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> sobrecarga de método pode usar o <ph id="ph2">`ldlen`</ph> opcode:</target>       </trans-unit>
        <trans-unit id="3003" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldlen">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="3004" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Ldloc">
          <source>Loads the local variable at a specific index onto the evaluation stack.</source>
          <target state="translated">Carrega a variável local em um índice específico na pilha de avaliação.</target>       </trans-unit>
        <trans-unit id="3005" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloc">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">A tabela a seguir lista as instruções hexadecimal e formato de assembly do Microsoft Intermediate Language (MSIL), junto com um resumo breve de referência:</target>       </trans-unit>
        <trans-unit id="3006" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloc">
          <source>Format</source>
          <target state="translated">Formatar</target>       </trans-unit>
        <trans-unit id="3007" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloc">
          <source>Assembly Format</source>
          <target state="translated">Formato de assembly</target>       </trans-unit>
        <trans-unit id="3008" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloc">
          <source>Description</source>
          <target state="translated">Descrição</target>       </trans-unit>
        <trans-unit id="3009" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloc">
          <source>FE 0C &lt; <ph id="ph1">`unsigned int16`</ph><ph id="ph2"> &gt;</ph></source>
          <target state="translated">FE 0C &amp;LT; <ph id="ph1">`unsigned int16`</ph><ph id="ph2"> &gt;</ph></target>       </trans-unit>
        <trans-unit id="3010" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloc">
          <source>ldloc <ph id="ph1">`index`</ph></source>
          <target state="translated">ldloc <ph id="ph1">`index`</ph></target>       </trans-unit>
        <trans-unit id="3011" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloc">
          <source>Loads the local variable at index <ph id="ph1">`index`</ph> onto stack.</source>
          <target state="translated">Carrega a variável local no índice <ph id="ph1">`index`</ph> na pilha.</target>       </trans-unit>
        <trans-unit id="3012" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloc">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">O comportamento de transição de pilha, em ordem sequencial, é:</target>       </trans-unit>
        <trans-unit id="3013" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloc">
          <source>The local variable value at the specified index is pushed onto the stack.</source>
          <target state="translated">O valor da variável local no índice especificado é inserido na pilha.</target>       </trans-unit>
        <trans-unit id="3014" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloc">
          <source>The <ph id="ph1">`ldloc`</ph> instruction pushes the contents of the local variable number at the passed index onto the evaluation stack, where the local variables are numbered 0 onwards.</source>
          <target state="translated">O <ph id="ph1">`ldloc`</ph> instrução envia o conteúdo do número de variável local no índice passado para a pilha de avaliação, em que as variáveis locais são numerados de 0 em diante.</target>       </trans-unit>
        <trans-unit id="3015" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloc">
          <source>Local variables are initialized to 0 before entering the method only if the initialize flag on the method is true.</source>
          <target state="translated">Variáveis locais são inicializadas para 0 antes de inserir o método somente se o sinalizador de inicialização no método for verdadeiro.</target>       </trans-unit>
        <trans-unit id="3016" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloc">
          <source>There are 65,535 (2^16-1) local variables possible (0-65,534).</source>
          <target state="translated">Há 65.535 (2 ^ 16 - 1) variáveis locais possíveis (0-65.534).</target>       </trans-unit>
        <trans-unit id="3017" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloc">
          <source>Index 65,535 is not valid since likely implementations will use a 2-byte integer to track both a local's index, along with the total number of locals for a given method.</source>
          <target state="translated">65.535 de índice não é válido porque implementações provavelmente usará um inteiro de 2 bytes para controlar o índice de um locais, juntamente com o número total de locais para um determinado método.</target>       </trans-unit>
        <trans-unit id="3018" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloc">
          <source>If an index of 65535 had been made valid, it would require a wider integer to track the number of locals in such a method.</source>
          <target state="translated">Se um índice de 65535 tinha sido feito válido, ela requer um inteiro maior para controlar o número de locais em tal método.</target>       </trans-unit>
        <trans-unit id="3019" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloc">
          <source>The <ph id="ph1">`ldloc.0`</ph>, <ph id="ph2">`ldloc.1`</ph>, <ph id="ph3">`ldloc.2`</ph>, and <ph id="ph4">`ldloc.3`</ph> instructions provide an efficient encoding for accessing the first four local variables.</source>
          <target state="translated">O <ph id="ph1">`ldloc.0`</ph>, <ph id="ph2">`ldloc.1`</ph>, <ph id="ph3">`ldloc.2`</ph>, e <ph id="ph4">`ldloc.3`</ph> instruções fornecem uma codificação eficiente para acessar as primeiras quatro variáveis locais.</target>       </trans-unit>
        <trans-unit id="3020" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloc">
          <source>The type of the value is the same as the type of the local variable, which is specified in the method header.</source>
          <target state="translated">O tipo do valor é o mesmo que o tipo da variável local, que é especificado no cabeçalho de método.</target>       </trans-unit>
        <trans-unit id="3021" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloc">
          <source>See Partition I. Local variables that are smaller than 4 bytes long are expanded to type <ph id="ph1">`int32`</ph> when they are loaded onto the stack.</source>
          <target state="translated">Consulte partição I. Local variáveis que são menores que 4 bytes de comprimento é expandido para o tipo <ph id="ph1">`int32`</ph> quando eles são carregados para a pilha.</target>       </trans-unit>
        <trans-unit id="3022" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloc">
          <source>Floating-point values are expanded to their native size (type <ph id="ph1">`F`</ph>).</source>
          <target state="translated">Valores de ponto flutuante são expandidos para seu tamanho nativo (tipo <ph id="ph1">`F`</ph>).</target>       </trans-unit>
        <trans-unit id="3023" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloc">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overloads can use the <ph id="ph2">`ldloc`</ph> opcode:</source>
          <target state="translated">O seguinte <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> sobrecargas de método podem usar o <ph id="ph2">`ldloc`</ph> opcode:</target>       </trans-unit>
        <trans-unit id="3024" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloc">
          <source>ILGenerator.Emit(OpCode, LocalBuilder)</source>
          <target state="translated">ILGenerator.Emit(OpCode, LocalBuilder)</target>       </trans-unit>
        <trans-unit id="3025" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloc">
          <source>ILGenerator.Emit(OpCode, short)</source>
          <target state="translated">ILGenerator.Emit (OpCode, short)</target>       </trans-unit>
        <trans-unit id="3026" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Ldloc_0">
          <source>Loads the local variable at index 0 onto the evaluation stack.</source>
          <target state="translated">Carrega a variável local no índice 0 na pilha de avaliação.</target>       </trans-unit>
        <trans-unit id="3027" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloc_0">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">A tabela a seguir lista as instruções hexadecimal e formato de assembly do Microsoft Intermediate Language (MSIL), junto com um resumo breve de referência:</target>       </trans-unit>
        <trans-unit id="3028" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloc_0">
          <source>Format</source>
          <target state="translated">Formatar</target>       </trans-unit>
        <trans-unit id="3029" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloc_0">
          <source>Assembly Format</source>
          <target state="translated">Formato de assembly</target>       </trans-unit>
        <trans-unit id="3030" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloc_0">
          <source>Description</source>
          <target state="translated">Descrição</target>       </trans-unit>
        <trans-unit id="3031" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloc_0">
          <source>06</source>
          <target state="translated">06</target>       </trans-unit>
        <trans-unit id="3032" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloc_0">
          <source>ldloc.0</source>
          <target state="translated">ldloc.0</target>       </trans-unit>
        <trans-unit id="3033" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloc_0">
          <source>Loads the local variable at index 0 onto the evaluation stack.</source>
          <target state="translated">Carrega a variável local no índice 0 na pilha de avaliação.</target>       </trans-unit>
        <trans-unit id="3034" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloc_0">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">O comportamento de transição de pilha, em ordem sequencial, é:</target>       </trans-unit>
        <trans-unit id="3035" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloc_0">
          <source>The local variable value at the index 0 is pushed onto the stack.</source>
          <target state="translated">O valor da variável local no índice 0 é inserido na pilha.</target>       </trans-unit>
        <trans-unit id="3036" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloc_0">
          <source><ph id="ph1">`ldloc.0`</ph> is an especially efficient encoding for <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Ldloc&gt;</ph>, allowing access to the local variable at index 0.</source>
          <target state="translated"><ph id="ph1">`ldloc.0`</ph> é uma codificação especialmente eficiente para <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Ldloc&gt;</ph>, permitindo o acesso à variável local no índice 0.</target>       </trans-unit>
        <trans-unit id="3037" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloc_0">
          <source>The type of the value is the same as the type of the local variable, which is specified in the method header.</source>
          <target state="translated">O tipo do valor é o mesmo que o tipo da variável local, que é especificado no cabeçalho de método.</target>       </trans-unit>
        <trans-unit id="3038" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloc_0">
          <source>Local variables that are smaller than 4 bytes long are expanded to type <ph id="ph1">`int32`</ph> when they are loaded onto the stack.</source>
          <target state="translated">Variáveis locais que são menores que 4 bytes de comprimento são expandidas para o tipo <ph id="ph1">`int32`</ph> quando eles são carregados para a pilha.</target>       </trans-unit>
        <trans-unit id="3039" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloc_0">
          <source>Floating-point values are expanded to their native size (type <ph id="ph1">`F`</ph>).</source>
          <target state="translated">Valores de ponto flutuante são expandidos para seu tamanho nativo (tipo <ph id="ph1">`F`</ph>).</target>       </trans-unit>
        <trans-unit id="3040" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloc_0">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`ldloc.0`</ph> opcode:</source>
          <target state="translated">O seguinte <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> sobrecarga de método pode usar o <ph id="ph2">`ldloc.0`</ph> opcode:</target>       </trans-unit>
        <trans-unit id="3041" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloc_0">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="3042" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Ldloc_1">
          <source>Loads the local variable at index 1 onto the evaluation stack.</source>
          <target state="translated">Carrega a variável local no índice 1 para a pilha de avaliação.</target>       </trans-unit>
        <trans-unit id="3043" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloc_1">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">A tabela a seguir lista as instruções hexadecimal e formato de assembly do Microsoft Intermediate Language (MSIL), junto com um resumo breve de referência:</target>       </trans-unit>
        <trans-unit id="3044" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloc_1">
          <source>Format</source>
          <target state="translated">Formatar</target>       </trans-unit>
        <trans-unit id="3045" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloc_1">
          <source>Assembly Format</source>
          <target state="translated">Formato de assembly</target>       </trans-unit>
        <trans-unit id="3046" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloc_1">
          <source>Description</source>
          <target state="translated">Descrição</target>       </trans-unit>
        <trans-unit id="3047" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloc_1">
          <source>07</source>
          <target state="translated">07</target>       </trans-unit>
        <trans-unit id="3048" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloc_1">
          <source>ldloc.1</source>
          <target state="translated">ldloc.1</target>       </trans-unit>
        <trans-unit id="3049" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloc_1">
          <source>Loads the local variable at index 1 onto the evaluation stack.</source>
          <target state="translated">Carrega a variável local no índice 1 para a pilha de avaliação.</target>       </trans-unit>
        <trans-unit id="3050" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloc_1">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">O comportamento de transição de pilha, em ordem sequencial, é:</target>       </trans-unit>
        <trans-unit id="3051" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloc_1">
          <source>The local variable value at the index 1 is pushed onto the stack.</source>
          <target state="translated">O valor da variável local no índice 1 é inserido na pilha.</target>       </trans-unit>
        <trans-unit id="3052" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloc_1">
          <source><ph id="ph1">`ldloc.1`</ph> is an especially efficient encoding for <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Ldloc&gt;</ph>, allowing access to the local variable at index 1.</source>
          <target state="translated"><ph id="ph1">`ldloc.1`</ph> é uma codificação especialmente eficiente para <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Ldloc&gt;</ph>, permitindo o acesso à variável local no índice 1.</target>       </trans-unit>
        <trans-unit id="3053" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloc_1">
          <source>The type of the value is the same as the type of the local variable, which is specified in the method header.</source>
          <target state="translated">O tipo do valor é o mesmo que o tipo da variável local, que é especificado no cabeçalho de método.</target>       </trans-unit>
        <trans-unit id="3054" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloc_1">
          <source>Local variables that are smaller than 4 bytes long are expanded to type <ph id="ph1">`int32`</ph> when they are loaded onto the stack.</source>
          <target state="translated">Variáveis locais que são menores que 4 bytes de comprimento são expandidas para o tipo <ph id="ph1">`int32`</ph> quando eles são carregados para a pilha.</target>       </trans-unit>
        <trans-unit id="3055" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloc_1">
          <source>Floating-point values are expanded to their native size (type <ph id="ph1">`F`</ph>).</source>
          <target state="translated">Valores de ponto flutuante são expandidos para seu tamanho nativo (tipo <ph id="ph1">`F`</ph>).</target>       </trans-unit>
        <trans-unit id="3056" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloc_1">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`ldloc.1`</ph> opcode:</source>
          <target state="translated">O seguinte <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> sobrecarga de método pode usar o <ph id="ph2">`ldloc.1`</ph> opcode:</target>       </trans-unit>
        <trans-unit id="3057" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloc_1">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="3058" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Ldloc_2">
          <source>Loads the local variable at index 2 onto the evaluation stack.</source>
          <target state="translated">Carrega a variável local no índice 2 para a pilha de avaliação.</target>       </trans-unit>
        <trans-unit id="3059" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloc_2">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">A tabela a seguir lista as instruções hexadecimal e formato de assembly do Microsoft Intermediate Language (MSIL), junto com um resumo breve de referência:</target>       </trans-unit>
        <trans-unit id="3060" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloc_2">
          <source>Format</source>
          <target state="translated">Formatar</target>       </trans-unit>
        <trans-unit id="3061" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloc_2">
          <source>Assembly Format</source>
          <target state="translated">Formato de assembly</target>       </trans-unit>
        <trans-unit id="3062" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloc_2">
          <source>Description</source>
          <target state="translated">Descrição</target>       </trans-unit>
        <trans-unit id="3063" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloc_2">
          <source>08</source>
          <target state="translated">08</target>       </trans-unit>
        <trans-unit id="3064" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloc_2">
          <source>ldloc.2</source>
          <target state="translated">ldloc.2</target>       </trans-unit>
        <trans-unit id="3065" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloc_2">
          <source>Loads the local variable at index 2 onto the evaluation stack.</source>
          <target state="translated">Carrega a variável local no índice 2 para a pilha de avaliação.</target>       </trans-unit>
        <trans-unit id="3066" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloc_2">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">O comportamento de transição de pilha, em ordem sequencial, é:</target>       </trans-unit>
        <trans-unit id="3067" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloc_2">
          <source>The local variable value at the index 2 is pushed onto the stack.</source>
          <target state="translated">O valor da variável local no índice 2 é inserido na pilha.</target>       </trans-unit>
        <trans-unit id="3068" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloc_2">
          <source><ph id="ph1">`ldloc.2`</ph> is an especially efficient encoding for <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Ldloc&gt;</ph>, allowing access to the local variable at index 2.</source>
          <target state="translated"><ph id="ph1">`ldloc.2`</ph> é uma codificação especialmente eficiente para <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Ldloc&gt;</ph>, permitindo o acesso à variável local no índice 2.</target>       </trans-unit>
        <trans-unit id="3069" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloc_2">
          <source>The type of the value is the same as the type of the local variable, which is specified in the method header.</source>
          <target state="translated">O tipo do valor é o mesmo que o tipo da variável local, que é especificado no cabeçalho de método.</target>       </trans-unit>
        <trans-unit id="3070" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloc_2">
          <source>Local variables that are smaller than 4 bytes long are expanded to type <ph id="ph1">`int32`</ph> when they are loaded onto the stack.</source>
          <target state="translated">Variáveis locais que são menores que 4 bytes de comprimento são expandidas para o tipo <ph id="ph1">`int32`</ph> quando eles são carregados para a pilha.</target>       </trans-unit>
        <trans-unit id="3071" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloc_2">
          <source>Floating-point values are expanded to their native size (type <ph id="ph1">`F`</ph>).</source>
          <target state="translated">Valores de ponto flutuante são expandidos para seu tamanho nativo (tipo <ph id="ph1">`F`</ph>).</target>       </trans-unit>
        <trans-unit id="3072" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloc_2">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`ldloc.2`</ph> opcode:</source>
          <target state="translated">O seguinte <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> sobrecarga de método pode usar o <ph id="ph2">`ldloc.2`</ph> opcode:</target>       </trans-unit>
        <trans-unit id="3073" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloc_2">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="3074" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Ldloc_3">
          <source>Loads the local variable at index 3 onto the evaluation stack.</source>
          <target state="translated">Carrega a variável local no índice 3 para a pilha de avaliação.</target>       </trans-unit>
        <trans-unit id="3075" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloc_3">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">A tabela a seguir lista as instruções hexadecimal e formato de assembly do Microsoft Intermediate Language (MSIL), junto com um resumo breve de referência:</target>       </trans-unit>
        <trans-unit id="3076" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloc_3">
          <source>Format</source>
          <target state="translated">Formatar</target>       </trans-unit>
        <trans-unit id="3077" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloc_3">
          <source>Assembly Format</source>
          <target state="translated">Formato de assembly</target>       </trans-unit>
        <trans-unit id="3078" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloc_3">
          <source>Description</source>
          <target state="translated">Descrição</target>       </trans-unit>
        <trans-unit id="3079" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloc_3">
          <source>09</source>
          <target state="translated">09</target>       </trans-unit>
        <trans-unit id="3080" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloc_3">
          <source>ldloc.3</source>
          <target state="translated">ldloc.3</target>       </trans-unit>
        <trans-unit id="3081" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloc_3">
          <source>Loads the local variable at index 3 onto the evaluation stack.</source>
          <target state="translated">Carrega a variável local no índice 3 para a pilha de avaliação.</target>       </trans-unit>
        <trans-unit id="3082" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloc_3">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">O comportamento de transição de pilha, em ordem sequencial, é:</target>       </trans-unit>
        <trans-unit id="3083" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloc_3">
          <source>The local variable value at the index 3 is pushed onto the stack.</source>
          <target state="translated">O valor da variável local no índice 3 é inserido na pilha.</target>       </trans-unit>
        <trans-unit id="3084" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloc_3">
          <source><ph id="ph1">`ldloc.3`</ph> is an especially efficient encoding for <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Ldloc&gt;</ph>, allowing access to the local variable at index 3.</source>
          <target state="translated"><ph id="ph1">`ldloc.3`</ph> é uma codificação especialmente eficiente para <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Ldloc&gt;</ph>, permitindo o acesso à variável local no índice 3.</target>       </trans-unit>
        <trans-unit id="3085" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloc_3">
          <source>The type of the value is the same as the type of the local variable, which is specified in the method header.</source>
          <target state="translated">O tipo do valor é o mesmo que o tipo da variável local, que é especificado no cabeçalho de método.</target>       </trans-unit>
        <trans-unit id="3086" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloc_3">
          <source>Local variables that are smaller than 4 bytes long are expanded to type <ph id="ph1">`int32`</ph> when they are loaded onto the stack.</source>
          <target state="translated">Variáveis locais que são menores que 4 bytes de comprimento são expandidas para o tipo <ph id="ph1">`int32`</ph> quando eles são carregados para a pilha.</target>       </trans-unit>
        <trans-unit id="3087" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloc_3">
          <source>Floating-point values are expanded to their native size (type <ph id="ph1">`F`</ph>).</source>
          <target state="translated">Valores de ponto flutuante são expandidos para seu tamanho nativo (tipo <ph id="ph1">`F`</ph>).</target>       </trans-unit>
        <trans-unit id="3088" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloc_3">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`ldloc.3`</ph> opcode:</source>
          <target state="translated">O seguinte <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> sobrecarga de método pode usar o <ph id="ph2">`ldloc.3`</ph> opcode:</target>       </trans-unit>
        <trans-unit id="3089" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloc_3">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="3090" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Ldloc_S">
          <source>Loads the local variable at a specific index onto the evaluation stack, short form.</source>
          <target state="translated">Carrega a variável local em um índice específico na pilha de avaliação, de forma abreviada.</target>       </trans-unit>
        <trans-unit id="3091" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloc_S">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">A tabela a seguir lista as instruções hexadecimal e formato de assembly do Microsoft Intermediate Language (MSIL), junto com um resumo breve de referência:</target>       </trans-unit>
        <trans-unit id="3092" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloc_S">
          <source>Format</source>
          <target state="translated">Formatar</target>       </trans-unit>
        <trans-unit id="3093" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloc_S">
          <source>Assembly Format</source>
          <target state="translated">Formato de assembly</target>       </trans-unit>
        <trans-unit id="3094" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloc_S">
          <source>Description</source>
          <target state="translated">Descrição</target>       </trans-unit>
        <trans-unit id="3095" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloc_S">
          <source>11 &lt; <ph id="ph1">`unsigned int8`</ph><ph id="ph2"> &gt;</ph></source>
          <target state="translated">11 &lt; <ph id="ph1">`unsigned int8`</ph><ph id="ph2"> &gt;</ph></target>       </trans-unit>
        <trans-unit id="3096" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloc_S">
          <source>ldloc.s <ph id="ph1">`index`</ph></source>
          <target state="translated">Ldloc.s <ph id="ph1">`index`</ph></target>       </trans-unit>
        <trans-unit id="3097" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloc_S">
          <source>Loads the local variable at index <ph id="ph1">`index`</ph> onto stack, short form.</source>
          <target state="translated">Carrega a variável local no índice <ph id="ph1">`index`</ph> na pilha, de forma abreviada.</target>       </trans-unit>
        <trans-unit id="3098" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloc_S">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">O comportamento de transição de pilha, em ordem sequencial, é:</target>       </trans-unit>
        <trans-unit id="3099" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloc_S">
          <source>The local variable value at the specified index is pushed onto the stack.</source>
          <target state="translated">O valor da variável local no índice especificado é inserido na pilha.</target>       </trans-unit>
        <trans-unit id="3100" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloc_S">
          <source>The <ph id="ph1">`ldloc.s`</ph> instruction pushes the contents of the local variable number at the passed index onto the evaluation stack, where the local variables are numbered 0 onwards.</source>
          <target state="translated">O <ph id="ph1">`ldloc.s`</ph> instrução envia o conteúdo do número de variável local no índice passado para a pilha de avaliação, em que as variáveis locais são numerados de 0 em diante.</target>       </trans-unit>
        <trans-unit id="3101" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloc_S">
          <source>Local variables are initialized to 0 before entering the method if the initialize flag on the method is true.</source>
          <target state="translated">Variáveis locais são inicializadas para 0 antes de inserir o método se o sinalizador de inicialização no método for true.</target>       </trans-unit>
        <trans-unit id="3102" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloc_S">
          <source>There are 256 (2^8) local variables possible (0-255) in the short form, which is a more efficient encoding than <ph id="ph1">`ldloc`</ph>.</source>
          <target state="translated">Há 256 (2 ^ 8) variáveis locais possíveis (0-255) em forma abreviada, que é uma codificação mais eficiente que <ph id="ph1">`ldloc`</ph>.</target>       </trans-unit>
        <trans-unit id="3103" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloc_S">
          <source>The type of the value is the same as the type of the local variable, which is specified in the method header.</source>
          <target state="translated">O tipo do valor é o mesmo que o tipo da variável local, que é especificado no cabeçalho de método.</target>       </trans-unit>
        <trans-unit id="3104" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloc_S">
          <source>See Partition I. Local variables that are smaller than 4 bytes long are expanded to type <ph id="ph1">`int32`</ph> when they are loaded onto the stack.</source>
          <target state="translated">Consulte partição I. Local variáveis que são menores que 4 bytes de comprimento é expandido para o tipo <ph id="ph1">`int32`</ph> quando eles são carregados para a pilha.</target>       </trans-unit>
        <trans-unit id="3105" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloc_S">
          <source>Floating-point values are expanded to their native size (type <ph id="ph1">`F`</ph>).</source>
          <target state="translated">Valores de ponto flutuante são expandidos para seu tamanho nativo (tipo <ph id="ph1">`F`</ph>).</target>       </trans-unit>
        <trans-unit id="3106" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloc_S">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overloads can use the <ph id="ph2">`ldloc.s`</ph> opcode:</source>
          <target state="translated">O seguinte <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> sobrecargas de método podem usar o <ph id="ph2">`ldloc.s`</ph> opcode:</target>       </trans-unit>
        <trans-unit id="3107" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloc_S">
          <source>ILGenerator.Emit(OpCode, LocalBuilder)</source>
          <target state="translated">ILGenerator.Emit(OpCode, LocalBuilder)</target>       </trans-unit>
        <trans-unit id="3108" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloc_S">
          <source>ILGenerator.Emit(OpCode, byte)</source>
          <target state="translated">ILGenerator.Emit (OpCode, byte)</target>       </trans-unit>
        <trans-unit id="3109" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Ldloca">
          <source>Loads the address of the local variable at a specific index onto the evaluation stack.</source>
          <target state="translated">Carrega o endereço da variável local em um índice específico para a pilha de avaliação.</target>       </trans-unit>
        <trans-unit id="3110" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloca">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">A tabela a seguir lista as instruções hexadecimal e formato de assembly do Microsoft Intermediate Language (MSIL), junto com um resumo breve de referência:</target>       </trans-unit>
        <trans-unit id="3111" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloca">
          <source>Format</source>
          <target state="translated">Formatar</target>       </trans-unit>
        <trans-unit id="3112" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloca">
          <source>Assembly Format</source>
          <target state="translated">Formato de assembly</target>       </trans-unit>
        <trans-unit id="3113" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloca">
          <source>Description</source>
          <target state="translated">Descrição</target>       </trans-unit>
        <trans-unit id="3114" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloca">
          <source>FE OD &lt; <ph id="ph1">`unsigned int16`</ph><ph id="ph2"> &gt;</ph></source>
          <target state="translated">FE OD &amp;LT; <ph id="ph1">`unsigned int16`</ph><ph id="ph2"> &gt;</ph></target>       </trans-unit>
        <trans-unit id="3115" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloca">
          <source>ldloca <ph id="ph1">`index`</ph></source>
          <target state="translated">ldloca <ph id="ph1">`index`</ph></target>       </trans-unit>
        <trans-unit id="3116" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloca">
          <source>Loads the address of the local variable at <ph id="ph1">`index`</ph> onto the evaluation stack.</source>
          <target state="translated">Carrega o endereço da variável local no <ph id="ph1">`index`</ph> para a pilha de avaliação.</target>       </trans-unit>
        <trans-unit id="3117" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloca">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">O comportamento de transição de pilha, em ordem sequencial, é:</target>       </trans-unit>
        <trans-unit id="3118" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloca">
          <source>The address stored in the local variable at the specified index is pushed onto the stack.</source>
          <target state="translated">O endereço armazenado na variável local no índice especificado é inserido na pilha.</target>       </trans-unit>
        <trans-unit id="3119" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloca">
          <source>The <ph id="ph1">`ldloca`</ph> instruction pushes the address of the local variable number at the passed index onto the stack, where local variables are numbered 0 onwards.</source>
          <target state="translated">O <ph id="ph1">`ldloca`</ph> instrução envia o endereço do número de variável local no índice passado para a pilha, em que as variáveis locais são numerados de 0 em diante.</target>       </trans-unit>
        <trans-unit id="3120" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloca">
          <source>The value pushed on the stack is already aligned correctly for use with instructions like <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Ldind_I&gt;</ph> and <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Stind_I&gt;</ph>.</source>
          <target state="translated">O valor enviado na pilha é já alinhado corretamente para uso com instruções de como <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Ldind_I&gt;</ph> e <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Stind_I&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3121" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloca">
          <source>The result is a transient pointer (type <ph id="ph1">`*`</ph>).</source>
          <target state="translated">O resultado é um ponteiro transitório (tipo <ph id="ph1">`*`</ph>).</target>       </trans-unit>
        <trans-unit id="3122" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloca">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`ldloca`</ph> opcode:</source>
          <target state="translated">O seguinte <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> sobrecarga de método pode usar o <ph id="ph2">`ldloca`</ph> opcode:</target>       </trans-unit>
        <trans-unit id="3123" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloca">
          <source>ILGenerator.Emit(OpCode, short)</source>
          <target state="translated">ILGenerator.Emit (OpCode, short)</target>       </trans-unit>
        <trans-unit id="3124" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Ldloca_S">
          <source>Loads the address of the local variable at a specific index onto the evaluation stack, short form.</source>
          <target state="translated">Carrega o endereço da variável local em um índice específico para a pilha de avaliação, em forma abreviada.</target>       </trans-unit>
        <trans-unit id="3125" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloca_S">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">A tabela a seguir lista as instruções hexadecimal e formato de assembly do Microsoft Intermediate Language (MSIL), junto com um resumo breve de referência:</target>       </trans-unit>
        <trans-unit id="3126" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloca_S">
          <source>Format</source>
          <target state="translated">Formatar</target>       </trans-unit>
        <trans-unit id="3127" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloca_S">
          <source>Assembly Format</source>
          <target state="translated">Formato de assembly</target>       </trans-unit>
        <trans-unit id="3128" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloca_S">
          <source>Description</source>
          <target state="translated">Descrição</target>       </trans-unit>
        <trans-unit id="3129" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloca_S">
          <source>12 &lt; <ph id="ph1">`unsigned int8`</ph><ph id="ph2"> &gt;</ph></source>
          <target state="translated">12 &lt; <ph id="ph1">`unsigned int8`</ph><ph id="ph2"> &gt;</ph></target>       </trans-unit>
        <trans-unit id="3130" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloca_S">
          <source>ldloca.s <ph id="ph1">`index`</ph></source>
          <target state="translated">ldloca.s <ph id="ph1">`index`</ph></target>       </trans-unit>
        <trans-unit id="3131" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloca_S">
          <source>Loads the address of the local variable at <ph id="ph1">`index`</ph> onto the evaluation stack, short form.</source>
          <target state="translated">Carrega o endereço da variável local no <ph id="ph1">`index`</ph> para a pilha de avaliação, de forma abreviada.</target>       </trans-unit>
        <trans-unit id="3132" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloca_S">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">O comportamento de transição de pilha, em ordem sequencial, é:</target>       </trans-unit>
        <trans-unit id="3133" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloca_S">
          <source>The address stored in the local variable at the specified index is pushed onto the stack.</source>
          <target state="translated">O endereço armazenado na variável local no índice especificado é inserido na pilha.</target>       </trans-unit>
        <trans-unit id="3134" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloca_S">
          <source>The <ph id="ph1">`ldloca.s`</ph> instruction pushes the address of the local variable number at the passed index onto the stack, where local variables are numbered 0 onwards.</source>
          <target state="translated">O <ph id="ph1">`ldloca.s`</ph> instrução envia o endereço do número de variável local no índice passado para a pilha, em que as variáveis locais são numerados de 0 em diante.</target>       </trans-unit>
        <trans-unit id="3135" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloca_S">
          <source>The value pushed on the stack is already aligned correctly for use with instructions like <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Ldind_I&gt;</ph> and <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Stind_I&gt;</ph>.</source>
          <target state="translated">O valor enviado na pilha é já alinhado corretamente para uso com instruções de como <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Ldind_I&gt;</ph> e <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Stind_I&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3136" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloca_S">
          <source>The result is a transient pointer (type <ph id="ph1">`*`</ph>).</source>
          <target state="translated">O resultado é um ponteiro transitório (tipo <ph id="ph1">`*`</ph>).</target>       </trans-unit>
        <trans-unit id="3137" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloca_S">
          <source>The <ph id="ph1">`ldloca.s`</ph> instruction provides an efficient encoding for use with the local variables 0 through 255.</source>
          <target state="translated">O <ph id="ph1">`ldloca.s`</ph> instrução fornece uma codificação eficiente para uso com as variáveis locais de 0 a 255.</target>       </trans-unit>
        <trans-unit id="3138" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloca_S">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`ldloca.s`</ph> opcode:</source>
          <target state="translated">O seguinte <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> sobrecarga de método pode usar o <ph id="ph2">`ldloca.s`</ph> opcode:</target>       </trans-unit>
        <trans-unit id="3139" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloca_S">
          <source>ILGenerator.Emit(OpCode, byte)</source>
          <target state="translated">ILGenerator.Emit (OpCode, byte)</target>       </trans-unit>
        <trans-unit id="3140" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Ldnull">
          <source>Pushes a null reference (type <ph id="ph1">&lt;see langword="O" /&gt;</ph>) onto the evaluation stack.</source>
          <target state="translated">Envia uma referência nula (tipo <ph id="ph1">&lt;see langword="O" /&gt;</ph>) para a pilha de avaliação.</target>       </trans-unit>
        <trans-unit id="3141" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldnull">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">A tabela a seguir lista as instruções hexadecimal e formato de assembly do Microsoft Intermediate Language (MSIL), junto com um resumo breve de referência:</target>       </trans-unit>
        <trans-unit id="3142" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldnull">
          <source>Format</source>
          <target state="translated">Formatar</target>       </trans-unit>
        <trans-unit id="3143" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldnull">
          <source>Assembly Format</source>
          <target state="translated">Formato de assembly</target>       </trans-unit>
        <trans-unit id="3144" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldnull">
          <source>Description</source>
          <target state="translated">Descrição</target>       </trans-unit>
        <trans-unit id="3145" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldnull">
          <source>14</source>
          <target state="translated">14</target>       </trans-unit>
        <trans-unit id="3146" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldnull">
          <source>ldnull</source>
          <target state="translated">ldnull</target>       </trans-unit>
        <trans-unit id="3147" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldnull">
          <source>push a null reference onto the stack</source>
          <target state="translated">Enviar por push uma referência nula para a pilha</target>       </trans-unit>
        <trans-unit id="3148" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldnull">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">O comportamento de transição de pilha, em ordem sequencial, é:</target>       </trans-unit>
        <trans-unit id="3149" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldnull">
          <source>A null object reference is pushed onto the stack.</source>
          <target state="translated">Uma referência de objeto nulo é inserida na pilha.</target>       </trans-unit>
        <trans-unit id="3150" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldnull">
          <source><ph id="ph1">`ldnull`</ph> pushes a null reference (type <ph id="ph2">`O`</ph>) on the stack.</source>
          <target state="translated"><ph id="ph1">`ldnull`</ph> envia uma referência nula (tipo <ph id="ph2">`O`</ph>) na pilha.</target>       </trans-unit>
        <trans-unit id="3151" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldnull">
          <source>This is used to initialize locations before they are populated with data, or when they become deprecated.</source>
          <target state="translated">Isso é usado para inicializar locais antes de serem populados com dados, ou quando eles preterida.</target>       </trans-unit>
        <trans-unit id="3152" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldnull">
          <source><ph id="ph1">`ldnull`</ph> provides a null reference that is size-independent.</source>
          <target state="translated"><ph id="ph1">`ldnull`</ph> Fornece uma referência nula é independente de tamanho.</target>       </trans-unit>
        <trans-unit id="3153" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldnull">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`ldnull`</ph> opcode:</source>
          <target state="translated">O seguinte <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> sobrecarga de método pode usar o <ph id="ph2">`ldnull`</ph> opcode:</target>       </trans-unit>
        <trans-unit id="3154" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldnull">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="3155" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Ldobj">
          <source>Copies the value type object pointed to by an address to the top of the evaluation stack.</source>
          <target state="translated">Copia o objeto de tipo de valor apontado por um endereço na parte superior da pilha de avaliação.</target>       </trans-unit>
        <trans-unit id="3156" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldobj">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">A tabela a seguir lista as instruções hexadecimal e formato de assembly do Microsoft Intermediate Language (MSIL), junto com um resumo breve de referência:</target>       </trans-unit>
        <trans-unit id="3157" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldobj">
          <source>Format</source>
          <target state="translated">Formatar</target>       </trans-unit>
        <trans-unit id="3158" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldobj">
          <source>Assembly Format</source>
          <target state="translated">Formato de assembly</target>       </trans-unit>
        <trans-unit id="3159" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldobj">
          <source>Description</source>
          <target state="translated">Descrição</target>       </trans-unit>
        <trans-unit id="3160" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldobj">
          <source>71 &lt; <ph id="ph1">`T`</ph><ph id="ph2"> &gt;</ph></source>
          <target state="translated">71 &lt; <ph id="ph1">`T`</ph><ph id="ph2"> &gt;</ph></target>       </trans-unit>
        <trans-unit id="3161" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldobj">
          <source>ldobj <ph id="ph1">`class`</ph></source>
          <target state="translated">ldobj <ph id="ph1">`class`</ph></target>       </trans-unit>
        <trans-unit id="3162" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldobj">
          <source>Copy instance of value type <ph id="ph1">`class`</ph> to the stack.</source>
          <target state="translated">Instância de cópia do tipo de valor <ph id="ph1">`class`</ph> para a pilha.</target>       </trans-unit>
        <trans-unit id="3163" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldobj">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">O comportamento de transição de pilha, em ordem sequencial, é:</target>       </trans-unit>
        <trans-unit id="3164" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldobj">
          <source>The address of a value type object is pushed onto the stack.</source>
          <target state="translated">O endereço de um objeto de tipo de valor é inserido na pilha.</target>       </trans-unit>
        <trans-unit id="3165" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldobj">
          <source>The address is popped from the stack and the instance at that particular address is looked up.</source>
          <target state="translated">O endereço é exibido da pilha e a instância nesse endereço específico é pesquisada.</target>       </trans-unit>
        <trans-unit id="3166" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldobj">
          <source>The value of the object stored at that address is pushed onto the stack.</source>
          <target state="translated">O valor do objeto armazenado nesse endereço é inserido na pilha.</target>       </trans-unit>
        <trans-unit id="3167" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldobj">
          <source>The <ph id="ph1">`ldobj`</ph> instruction is used to pass a value type as a parameter.</source>
          <target state="translated">O <ph id="ph1">`ldobj`</ph> instrução é usada para passar um tipo de valor como um parâmetro.</target>       </trans-unit>
        <trans-unit id="3168" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldobj">
          <source>The <ph id="ph1">`ldobj`</ph> instruction copies the value pointed to by <ph id="ph2">`addrOfValObj`</ph> (of type <ph id="ph3">`&amp;`</ph>, <ph id="ph4">`*`</ph>, or <ph id="ph5">`native int`</ph>) to the top of the stack.</source>
          <target state="translated">O <ph id="ph1">`ldobj`</ph> instrução copia o valor apontado por <ph id="ph2">`addrOfValObj`</ph> (do tipo <ph id="ph3">`&amp;`</ph>, <ph id="ph4">`*`</ph>, ou <ph id="ph5">`native int`</ph>) para a parte superior da pilha.</target>       </trans-unit>
        <trans-unit id="3169" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldobj">
          <source>The number of bytes copied depends on the size of the class (as specified by the <ph id="ph1">`class`</ph> parameter).</source>
          <target state="translated">O número de bytes copiados depende do tamanho da classe (conforme especificado pelo <ph id="ph1">`class`</ph> parâmetro).</target>       </trans-unit>
        <trans-unit id="3170" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldobj">
          <source>The <ph id="ph1">`class`</ph> parameter is a metadata token representing the value type.</source>
          <target state="translated">O <ph id="ph1">`class`</ph> parâmetro é um token de metadados que representa o tipo de valor.</target>       </trans-unit>
        <trans-unit id="3171" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldobj">
          <source>The operation of the <ph id="ph1">`ldobj`</ph> instruction can be altered by an immediately preceding <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Volatile&gt;</ph> or <ph id="ph3">&lt;xref:System.Reflection.Emit.OpCodes.Unaligned&gt;</ph> prefix instruction.</source>
          <target state="translated">A operação do <ph id="ph1">`ldobj`</ph> instrução pode ser alterada por um imediatamente anterior <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Volatile&gt;</ph> ou <ph id="ph3">&lt;xref:System.Reflection.Emit.OpCodes.Unaligned&gt;</ph> prefixo instrução.</target>       </trans-unit>
        <trans-unit id="3172" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldobj">
          <source><ph id="ph1">&lt;xref:System.TypeLoadException&gt;</ph> is thrown if class cannot be found.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.TypeLoadException&gt;</ph> é gerada se a classe não pode ser encontrada.</target>       </trans-unit>
        <trans-unit id="3173" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldobj">
          <source>This is typically detected when the Microsoft Intermediate Language (MSIL) instruction is converted to native code rather than at runtime.</source>
          <target state="translated">Normalmente, isso é detectado quando a instrução Microsoft Intermediate Language (MSIL) é convertida em código nativo em vez de em tempo de execução.</target>       </trans-unit>
        <trans-unit id="3174" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldobj">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`ldobj`</ph> opcode:</source>
          <target state="translated">O seguinte <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> sobrecarga de método pode usar o <ph id="ph2">`ldobj`</ph> opcode:</target>       </trans-unit>
        <trans-unit id="3175" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldobj">
          <source>ILGenerator.Emit(OpCode, Type)</source>
          <target state="translated">ILGenerator.Emit(OpCode, Type)</target>       </trans-unit>
        <trans-unit id="3176" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Ldsfld">
          <source>Pushes the value of a static field onto the evaluation stack.</source>
          <target state="translated">Envia por push o valor de um campo estático para a pilha de avaliação.</target>       </trans-unit>
        <trans-unit id="3177" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldsfld">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">A tabela a seguir lista as instruções hexadecimal e formato de assembly do Microsoft Intermediate Language (MSIL), junto com um resumo breve de referência:</target>       </trans-unit>
        <trans-unit id="3178" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldsfld">
          <source>Format</source>
          <target state="translated">Formatar</target>       </trans-unit>
        <trans-unit id="3179" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldsfld">
          <source>Assembly Format</source>
          <target state="translated">Formato de assembly</target>       </trans-unit>
        <trans-unit id="3180" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldsfld">
          <source>Description</source>
          <target state="translated">Descrição</target>       </trans-unit>
        <trans-unit id="3181" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldsfld">
          <source>7E &lt; <ph id="ph1">`T`</ph><ph id="ph2"> &gt;</ph></source>
          <target state="translated">7E &lt; <ph id="ph1">`T`</ph><ph id="ph2"> &gt;</ph></target>       </trans-unit>
        <trans-unit id="3182" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldsfld">
          <source>ldsfld <ph id="ph1">`field`</ph></source>
          <target state="translated">ldsfld <ph id="ph1">`field`</ph></target>       </trans-unit>
        <trans-unit id="3183" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldsfld">
          <source>Push the value of <ph id="ph1">`field`</ph> on the stack.</source>
          <target state="translated">Enviar por push o valor de <ph id="ph1">`field`</ph> na pilha.</target>       </trans-unit>
        <trans-unit id="3184" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldsfld">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">O comportamento de transição de pilha, em ordem sequencial, é:</target>       </trans-unit>
        <trans-unit id="3185" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldsfld">
          <source>The value of the specific field is pushed onto the stack.</source>
          <target state="translated">O valor do campo específico é inserido na pilha.</target>       </trans-unit>
        <trans-unit id="3186" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldsfld">
          <source>The <ph id="ph1">`ldsfld`</ph> instruction pushes the value of a static (shared among all instances of a class) field on the stack.</source>
          <target state="translated">O <ph id="ph1">`ldsfld`</ph> instrução envia o valor estático (compartilhado entre todas as instâncias de uma classe) campo na pilha.</target>       </trans-unit>
        <trans-unit id="3187" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldsfld">
          <source>The return type is that associated with the passed metadata token <ph id="ph1">`field`</ph>.</source>
          <target state="translated">O tipo de retorno é associado ao token de metadados passado <ph id="ph1">`field`</ph>.</target>       </trans-unit>
        <trans-unit id="3188" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldsfld">
          <source>The <ph id="ph1">`ldsfld`</ph> instruction can have a <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Volatile&gt;</ph> prefix.</source>
          <target state="translated">O <ph id="ph1">`ldsfld`</ph> instrução pode ter um <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Volatile&gt;</ph> prefixo.</target>       </trans-unit>
        <trans-unit id="3189" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldsfld">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`ldsfld`</ph> opcode:</source>
          <target state="translated">O seguinte <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> sobrecarga de método pode usar o <ph id="ph2">`ldsfld`</ph> opcode:</target>       </trans-unit>
        <trans-unit id="3190" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldsfld">
          <source>ILGenerator.Emit(OpCode, FieldInfo)</source>
          <target state="translated">ILGenerator.Emit(OpCode, FieldInfo)</target>       </trans-unit>
        <trans-unit id="3191" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Ldsflda">
          <source>Pushes the address of a static field onto the evaluation stack.</source>
          <target state="translated">Efetua o push do endereço de um campo estático para a pilha de avaliação.</target>       </trans-unit>
        <trans-unit id="3192" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldsflda">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">A tabela a seguir lista as instruções hexadecimal e formato de assembly do Microsoft Intermediate Language (MSIL), junto com um resumo breve de referência:</target>       </trans-unit>
        <trans-unit id="3193" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldsflda">
          <source>Format</source>
          <target state="translated">Formatar</target>       </trans-unit>
        <trans-unit id="3194" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldsflda">
          <source>Assembly Format</source>
          <target state="translated">Formato de assembly</target>       </trans-unit>
        <trans-unit id="3195" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldsflda">
          <source>Description</source>
          <target state="translated">Descrição</target>       </trans-unit>
        <trans-unit id="3196" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldsflda">
          <source>7F &lt; <ph id="ph1">`T`</ph><ph id="ph2"> &gt;</ph></source>
          <target state="translated">7F &lt; <ph id="ph1">`T`</ph><ph id="ph2"> &gt;</ph></target>       </trans-unit>
        <trans-unit id="3197" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldsflda">
          <source>ldsflda <ph id="ph1">`field`</ph></source>
          <target state="translated">ldsflda <ph id="ph1">`field`</ph></target>       </trans-unit>
        <trans-unit id="3198" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldsflda">
          <source>Push the address of <ph id="ph1">`field`</ph> on the stack</source>
          <target state="translated">Enviar por push o endereço do <ph id="ph1">`field`</ph> na pilha</target>       </trans-unit>
        <trans-unit id="3199" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldsflda">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">O comportamento de transição de pilha, em ordem sequencial, é:</target>       </trans-unit>
        <trans-unit id="3200" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldsflda">
          <source>The address of a specific field is pushed onto the stack.</source>
          <target state="translated">O endereço de um campo específico é inserido na pilha.</target>       </trans-unit>
        <trans-unit id="3201" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldsflda">
          <source>The <ph id="ph1">`ldsflda`</ph> instruction pushes the address of a static (shared among all instances of a class) field on the stack.</source>
          <target state="translated">O <ph id="ph1">`ldsflda`</ph> instrução envia o endereço de um estático (compartilhado entre todas as instâncias de uma classe) campo na pilha.</target>       </trans-unit>
        <trans-unit id="3202" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldsflda">
          <source>The address may be represented as a transient pointer (type <ph id="ph1">`*`</ph>) if the metadata token <ph id="ph2">`field`</ph> refers to a type whose memory is managed.</source>
          <target state="translated">O endereço pode ser representado como um ponteiro transitório (tipo <ph id="ph1">`*`</ph>) se o token de metadados <ph id="ph2">`field`</ph> se refere a um tipo cuja memória é gerenciada.</target>       </trans-unit>
        <trans-unit id="3203" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldsflda">
          <source>Otherwise, it corresponds to an unmanaged pointer (type <ph id="ph1">`native int`</ph>).</source>
          <target state="translated">Caso contrário, ele corresponde a um ponteiro não gerenciado (tipo <ph id="ph1">`native int`</ph>).</target>       </trans-unit>
        <trans-unit id="3204" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldsflda">
          <source>Note that <ph id="ph1">`field`</ph> may be a static global with an assigned relative virtual address (the offset of the field from the base address at which its containing PE file is loaded into memory) where the memory is unmanaged.</source>
          <target state="translated">Observe que <ph id="ph1">`field`</ph> pode ser static global, com um endereço relativo virtual (o deslocamento do campo do endereço base no qual o arquivo PE contendo é carregado na memória) atribuído em que a memória é não gerenciada.</target>       </trans-unit>
        <trans-unit id="3205" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldsflda">
          <source>The <ph id="ph1">`ldsflda`</ph> instruction can have a <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Volatile&gt;</ph> prefix.</source>
          <target state="translated">O <ph id="ph1">`ldsflda`</ph> instrução pode ter um <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Volatile&gt;</ph> prefixo.</target>       </trans-unit>
        <trans-unit id="3206" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldsflda">
          <source><ph id="ph1">&lt;xref:System.MissingFieldException&gt;</ph> is thrown if field is not found in the metadata.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.MissingFieldException&gt;</ph> é gerada se o campo não for encontrado nos metadados.</target>       </trans-unit>
        <trans-unit id="3207" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldsflda">
          <source>This is typically checked when Microsoft Intermediate Language (MSIL) instructions are converted to native code, not at runtime.</source>
          <target state="translated">Normalmente, isso é verificado quando instruções Microsoft Intermediate Language (MSIL) são convertidas em código nativo, não em tempo de execução.</target>       </trans-unit>
        <trans-unit id="3208" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldsflda">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`ldsflda`</ph> opcode:</source>
          <target state="translated">O seguinte <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> sobrecarga de método pode usar o <ph id="ph2">`ldsflda`</ph> opcode:</target>       </trans-unit>
        <trans-unit id="3209" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldsflda">
          <source>ILGenerator.Emit(OpCode, FieldInfo)</source>
          <target state="translated">ILGenerator.Emit(OpCode, FieldInfo)</target>       </trans-unit>
        <trans-unit id="3210" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Ldstr">
          <source>Pushes a new object reference to a string literal stored in the metadata.</source>
          <target state="translated">Envia por push uma nova referência de objeto para uma literal de cadeia de caracteres armazenada nos metadados.</target>       </trans-unit>
        <trans-unit id="3211" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldstr">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">A tabela a seguir lista as instruções hexadecimal e formato de assembly do Microsoft Intermediate Language (MSIL), junto com um resumo breve de referência:</target>       </trans-unit>
        <trans-unit id="3212" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldstr">
          <source>Format</source>
          <target state="translated">Formatar</target>       </trans-unit>
        <trans-unit id="3213" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldstr">
          <source>Assembly Format</source>
          <target state="translated">Formato de assembly</target>       </trans-unit>
        <trans-unit id="3214" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldstr">
          <source>Description</source>
          <target state="translated">Descrição</target>       </trans-unit>
        <trans-unit id="3215" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldstr">
          <source>72 &lt; <ph id="ph1">`T`</ph><ph id="ph2"> &gt;</ph></source>
          <target state="translated">72 &lt; <ph id="ph1">`T`</ph><ph id="ph2"> &gt;</ph></target>       </trans-unit>
        <trans-unit id="3216" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldstr">
          <source>ldstr <ph id="ph1">`mdToken`</ph></source>
          <target state="translated">ldstr <ph id="ph1">`mdToken`</ph></target>       </trans-unit>
        <trans-unit id="3217" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldstr">
          <source>Pushes a string object for the metadata string token <ph id="ph1">`mdToken`</ph>.</source>
          <target state="translated">Envia um objeto de cadeia de caracteres para o token de cadeia de caracteres de metadados <ph id="ph1">`mdToken`</ph>.</target>       </trans-unit>
        <trans-unit id="3218" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldstr">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">O comportamento de transição de pilha, em ordem sequencial, é:</target>       </trans-unit>
        <trans-unit id="3219" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldstr">
          <source>An object reference to a string is pushed onto the stack.</source>
          <target state="translated">Uma referência de objeto para uma cadeia de caracteres é inserida na pilha.</target>       </trans-unit>
        <trans-unit id="3220" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldstr">
          <source>The <ph id="ph1">`ldstr`</ph> instruction pushes an object reference (type <ph id="ph2">`O`</ph>) to a new string object representing the specific string literal stored in the metadata.</source>
          <target state="translated">O <ph id="ph1">`ldstr`</ph> instrução envia uma referência de objeto (tipo <ph id="ph2">`O`</ph>) para um novo objeto de cadeia de caracteres que representa a cadeia de caracteres literal armazenada nos metadados.</target>       </trans-unit>
        <trans-unit id="3221" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldstr">
          <source>The <ph id="ph1">`ldstr`</ph> instruction allocates the requisite amount of memory and performs any format conversion required to convert the string literal from the form used in the file to the string format required at runtime.</source>
          <target state="translated">O <ph id="ph1">`ldstr`</ph> instrução aloca a quantidade necessária de memória e executa qualquer conversão de formato necessária para converter a literal de cadeia de caracteres de formato usado no arquivo para o formato de cadeia de caracteres necessário em tempo de execução.</target>       </trans-unit>
        <trans-unit id="3222" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldstr">
          <source>The Common Language Infrastructure (CLI) guarantees that the result of two <ph id="ph1">`ldstr`</ph> instructions referring to two metadata tokens that have the same sequence of characters return precisely the same string object (a process known as "string interning").</source>
          <target state="translated">A infraestrutura de linguagem comum (CLI) garante que o resultado de dois <ph id="ph1">`ldstr`</ph> instruções que faz referência a dois tokens de metadados que têm a mesma sequência de caracteres de retorno exatamente o mesmo objeto de cadeia de caracteres (um processo conhecido como "cadeia de caracteres como internos").</target>       </trans-unit>
        <trans-unit id="3223" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldstr">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`ldstr`</ph> opcode:</source>
          <target state="translated">O seguinte <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> sobrecarga de método pode usar o <ph id="ph2">`ldstr`</ph> opcode:</target>       </trans-unit>
        <trans-unit id="3224" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldstr">
          <source>ILGenerator.Emit(OpCode, string)</source>
          <target state="translated">ILGenerator.Emit (código de operação, cadeia de caracteres)</target>       </trans-unit>
        <trans-unit id="3225" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Ldtoken">
          <source>Converts a metadata token to its runtime representation, pushing it onto the evaluation stack.</source>
          <target state="translated">Converte um token de metadados em sua representação de tempo de execução, enviando-o por push para a pilha de avaliação.</target>       </trans-unit>
        <trans-unit id="3226" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldtoken">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">A tabela a seguir lista as instruções hexadecimal e formato de assembly do Microsoft Intermediate Language (MSIL), junto com um resumo breve de referência:</target>       </trans-unit>
        <trans-unit id="3227" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldtoken">
          <source>Format</source>
          <target state="translated">Formatar</target>       </trans-unit>
        <trans-unit id="3228" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldtoken">
          <source>Assembly Format</source>
          <target state="translated">Formato de assembly</target>       </trans-unit>
        <trans-unit id="3229" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldtoken">
          <source>Description</source>
          <target state="translated">Descrição</target>       </trans-unit>
        <trans-unit id="3230" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldtoken">
          <source>D0 &lt; <ph id="ph1">`T`</ph><ph id="ph2"> &gt;</ph></source>
          <target state="translated">D0 &lt; <ph id="ph1">`T`</ph><ph id="ph2"> &gt;</ph></target>       </trans-unit>
        <trans-unit id="3231" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldtoken">
          <source>ldtoken <ph id="ph1">`token`</ph></source>
          <target state="translated">Ldtoken <ph id="ph1">`token`</ph></target>       </trans-unit>
        <trans-unit id="3232" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldtoken">
          <source>Converts a metadata token to its runtime representation.</source>
          <target state="translated">Converte um token de metadados em sua representação de tempo de execução.</target>       </trans-unit>
        <trans-unit id="3233" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldtoken">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">O comportamento de transição de pilha, em ordem sequencial, é:</target>       </trans-unit>
        <trans-unit id="3234" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldtoken">
          <source>The passed token is converted to a <ph id="ph1">`RuntimeHandle`</ph> and pushed onto the stack.</source>
          <target state="translated">O token passado é convertido em um <ph id="ph1">`RuntimeHandle`</ph> e inserido na pilha.</target>       </trans-unit>
        <trans-unit id="3235" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldtoken">
          <source>The <ph id="ph1">`ldtoken`</ph> instruction pushes a <ph id="ph2">`RuntimeHandle`</ph> for the specified metadata token.</source>
          <target state="translated">O <ph id="ph1">`ldtoken`</ph> instrução coloca um <ph id="ph2">`RuntimeHandle`</ph> para o token de metadados especificado.</target>       </trans-unit>
        <trans-unit id="3236" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldtoken">
          <source>A <ph id="ph1">`RuntimeHandle`</ph> can be a <ph id="ph2">`fieldref/fielddef`</ph>, a <ph id="ph3">`methodref/methoddef`</ph>, or a <ph id="ph4">`typeref/typedef`</ph>.</source>
          <target state="translated">Um <ph id="ph1">`RuntimeHandle`</ph> pode ser um <ph id="ph2">`fieldref/fielddef`</ph>, um <ph id="ph3">`methodref/methoddef`</ph>, ou um <ph id="ph4">`typeref/typedef`</ph>.</target>       </trans-unit>
        <trans-unit id="3237" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldtoken">
          <source>The value pushed on the stack can be used in calls to <ph id="ph1">`Reflection`</ph> methods in the system class library.</source>
          <target state="translated">O valor enviado na pilha pode ser usado em chamadas para <ph id="ph1">`Reflection`</ph> métodos na biblioteca de classe do sistema.</target>       </trans-unit>
        <trans-unit id="3238" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldtoken">
          <source>For information on runtime handles, see the following classes: <ph id="ph1">&lt;xref:System.RuntimeFieldHandle&gt;</ph>, <ph id="ph2">&lt;xref:System.RuntimeTypeHandle&gt;</ph>, and <ph id="ph3">&lt;xref:System.RuntimeMethodHandle&gt;</ph>.</source>
          <target state="translated">Para obter informações sobre identificadores de tempo de execução, consulte as seguintes classes: <ph id="ph1">&lt;xref:System.RuntimeFieldHandle&gt;</ph>, <ph id="ph2">&lt;xref:System.RuntimeTypeHandle&gt;</ph>, e <ph id="ph3">&lt;xref:System.RuntimeMethodHandle&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3239" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldtoken">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overloads can use the <ph id="ph2">`ldtoken`</ph> opcode:</source>
          <target state="translated">O seguinte <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> sobrecargas de método podem usar o <ph id="ph2">`ldtoken`</ph> opcode:</target>       </trans-unit>
        <trans-unit id="3240" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldtoken">
          <source>ILGenerator.Emit(OpCode, MethodInfo)</source>
          <target state="translated">ILGenerator.Emit(OpCode, MethodInfo)</target>       </trans-unit>
        <trans-unit id="3241" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldtoken">
          <source>ILGenerator.Emit(OpCode, FieldInfo)</source>
          <target state="translated">ILGenerator.Emit(OpCode, FieldInfo)</target>       </trans-unit>
        <trans-unit id="3242" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldtoken">
          <source>ILGenerator.Emit(OpCode, Type)</source>
          <target state="translated">ILGenerator.Emit(OpCode, Type)</target>       </trans-unit>
        <trans-unit id="3243" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Ldvirtftn">
          <source>Pushes an unmanaged pointer (type <ph id="ph1">&lt;see langword="native int" /&gt;</ph>) to the native code implementing a particular virtual method associated with a specified object onto the evaluation stack.</source>
          <target state="translated">Efetua o push de um ponteiro não gerenciado (tipo <ph id="ph1">&lt;see langword="native int" /&gt;</ph>) para o código nativo implementando um método virtual específico associado ao objeto especificado para a pilha de avaliação.</target>       </trans-unit>
        <trans-unit id="3244" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldvirtftn">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">A tabela a seguir lista as instruções hexadecimal e formato de assembly do Microsoft Intermediate Language (MSIL), junto com um resumo breve de referência:</target>       </trans-unit>
        <trans-unit id="3245" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldvirtftn">
          <source>Format</source>
          <target state="translated">Formatar</target>       </trans-unit>
        <trans-unit id="3246" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldvirtftn">
          <source>Assembly Format</source>
          <target state="translated">Formato de assembly</target>       </trans-unit>
        <trans-unit id="3247" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldvirtftn">
          <source>Description</source>
          <target state="translated">Descrição</target>       </trans-unit>
        <trans-unit id="3248" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldvirtftn">
          <source>FE 07 &lt; <ph id="ph1">`T`</ph><ph id="ph2"> &gt;</ph></source>
          <target state="translated">FE 07 &lt; <ph id="ph1">`T`</ph><ph id="ph2"> &gt;</ph></target>       </trans-unit>
        <trans-unit id="3249" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldvirtftn">
          <source>ldvirtftn <ph id="ph1">`method`</ph></source>
          <target state="translated">ldvirtftn <ph id="ph1">`method`</ph></target>       </trans-unit>
        <trans-unit id="3250" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldvirtftn">
          <source>Pushes the pointer to an object's virtual method <ph id="ph1">`method`</ph> on the stack.</source>
          <target state="translated">Envia o ponteiro para um método do objeto virtual <ph id="ph1">`method`</ph> na pilha.</target>       </trans-unit>
        <trans-unit id="3251" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldvirtftn">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">O comportamento de transição de pilha, em ordem sequencial, é:</target>       </trans-unit>
        <trans-unit id="3252" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldvirtftn">
          <source>An object reference is pushed onto the stack.</source>
          <target state="translated">Uma referência de objeto é inserida na pilha.</target>       </trans-unit>
        <trans-unit id="3253" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldvirtftn">
          <source>The object reference is popped from the stack and the address of the entry point to the method (as specified by the metadata token <ph id="ph1">`method`</ph>) is looked up.</source>
          <target state="translated">A referência de objeto é exibida na pilha e o endereço do ponto de entrada para o método (conforme especificado pelo token de metadados <ph id="ph1">`method`</ph>) é pesquisada.</target>       </trans-unit>
        <trans-unit id="3254" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldvirtftn">
          <source>The pointer to <ph id="ph1">`method`</ph> is pushed onto the stack.</source>
          <target state="translated">O ponteiro para <ph id="ph1">`method`</ph> é inserido na pilha.</target>       </trans-unit>
        <trans-unit id="3255" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldvirtftn">
          <source>The resulting unmanaged pointer pushed onto the stack by the <ph id="ph1">`ldvirtftn`</ph> instruction can be called using the <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Calli&gt;</ph> instruction if it references a managed method (or a stub that transitions from managed to unmanaged code).</source>
          <target state="translated">O ponteiro não gerenciado resultante é inserido na pilha, o <ph id="ph1">`ldvirtftn`</ph> instrução pode ser chamada usando o <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Calli&gt;</ph> instrução se faz referência a um método gerenciado (ou um stub que faz a transição de código gerenciado para código não gerenciado).</target>       </trans-unit>
        <trans-unit id="3256" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldvirtftn">
          <source>The unmanaged pointer points to native code using the CLR calling convention.</source>
          <target state="translated">Pontos do ponteiro não gerenciado para código nativo usando a convenção de chamada de CLR.</target>       </trans-unit>
        <trans-unit id="3257" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldvirtftn">
          <source>This method pointer should not be passed to unmanaged native code as a callback routine.</source>
          <target state="translated">Este ponteiro de método não deve ser passado para código nativo não gerenciado, como uma rotina de retorno de chamada.</target>       </trans-unit>
        <trans-unit id="3258" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldvirtftn">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`ldvirtftn`</ph> opcode:</source>
          <target state="translated">O seguinte <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> sobrecarga de método pode usar o <ph id="ph2">`ldvirtftn`</ph> opcode:</target>       </trans-unit>
        <trans-unit id="3259" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldvirtftn">
          <source>ILGenerator.Emit(OpCode, MethodInfo)</source>
          <target state="translated">ILGenerator.Emit(OpCode, MethodInfo)</target>       </trans-unit>
        <trans-unit id="3260" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Leave">
          <source>Exits a protected region of code, unconditionally transferring control to a specific target instruction.</source>
          <target state="translated">Sai de uma região protegida de código, transferindo o controle incondicionalmente para uma instrução de destino específica.</target>       </trans-unit>
        <trans-unit id="3261" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Leave">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">A tabela a seguir lista as instruções hexadecimal e formato de assembly do Microsoft Intermediate Language (MSIL), junto com um resumo breve de referência:</target>       </trans-unit>
        <trans-unit id="3262" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Leave">
          <source>Format</source>
          <target state="translated">Formatar</target>       </trans-unit>
        <trans-unit id="3263" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Leave">
          <source>Assembly Format</source>
          <target state="translated">Formato de assembly</target>       </trans-unit>
        <trans-unit id="3264" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Leave">
          <source>Description</source>
          <target state="translated">Descrição</target>       </trans-unit>
        <trans-unit id="3265" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Leave">
          <source>DD &lt; <ph id="ph1">`int32`</ph><ph id="ph2"> &gt;</ph></source>
          <target state="translated">DD &lt; <ph id="ph1">`int32`</ph><ph id="ph2"> &gt;</ph></target>       </trans-unit>
        <trans-unit id="3266" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Leave">
          <source>leave <ph id="ph1">`target`</ph></source>
          <target state="translated">sair <ph id="ph1">`target`</ph></target>       </trans-unit>
        <trans-unit id="3267" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Leave">
          <source>Exits a protected region of code.</source>
          <target state="translated">Fecha uma área protegida de código.</target>       </trans-unit>
        <trans-unit id="3268" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Leave">
          <source>There is no stack transition behavior specified for this instruction.</source>
          <target state="translated">Não há nenhum comportamento de transição de pilha especificado para essa instrução.</target>       </trans-unit>
        <trans-unit id="3269" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Leave">
          <source>The <ph id="ph1">`leave`</ph> instruction unconditionally transfers control to the specific target instruction, represented as a 4-byte signed offset from the beginning of the instruction following the current instruction.</source>
          <target state="translated">O <ph id="ph1">`leave`</ph> instrução incondicionalmente transfere o controle para a instrução de destino específico, representada como um deslocamento assinado de 4 bytes do início da instrução após a instrução atual.</target>       </trans-unit>
        <trans-unit id="3270" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Leave">
          <source>The <ph id="ph1">`leave`</ph> instruction is similar to the <ph id="ph2">`br`</ph> instruction, but it can be used to exit a <ph id="ph3">`try`</ph>, <ph id="ph4">`filter`</ph>, or <ph id="ph5">`catch`</ph> block whereas the ordinary branch instructions can only be used in such a block to transfer control within it.</source>
          <target state="translated">O <ph id="ph1">`leave`</ph> instrução é semelhante do <ph id="ph2">`br`</ph> instrução, mas ele pode ser usado para sair uma <ph id="ph3">`try`</ph>, <ph id="ph4">`filter`</ph>, ou <ph id="ph5">`catch`</ph> bloquear enquanto as instruções de ramificação comum só podem ser usadas em tal um bloco para transferir controle dentro dele.</target>       </trans-unit>
        <trans-unit id="3271" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Leave">
          <source>The <ph id="ph1">`leave`</ph> instruction empties the evaluation stack and ensures that the appropriate surrounding <ph id="ph2">`finally`</ph> blocks are executed.</source>
          <target state="translated">O <ph id="ph1">`leave`</ph> instrução esvazia a pilha de avaliação e garante que o valor apropriado ao redor <ph id="ph2">`finally`</ph> os blocos são executados.</target>       </trans-unit>
        <trans-unit id="3272" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Leave">
          <source>You cannot use a <ph id="ph1">`leave`</ph> instruction to exit a <ph id="ph2">`finally`</ph> block.</source>
          <target state="translated">Não é possível usar um <ph id="ph1">`leave`</ph> instruções para sair um <ph id="ph2">`finally`</ph> bloco.</target>       </trans-unit>
        <trans-unit id="3273" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Leave">
          <source>To ease code generation for exception handlers it is valid from within a catch block to use a <ph id="ph1">`leave`</ph> instruction to transfer control to any instruction within the associated <ph id="ph2">`try`</ph> block.</source>
          <target state="translated">Para facilitar a geração de código para manipuladores de exceção é válido a partir de um bloco catch para usar um <ph id="ph1">`leave`</ph> instrução para transferir controle para qualquer instrução em associado <ph id="ph2">`try`</ph> bloco.</target>       </trans-unit>
        <trans-unit id="3274" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Leave">
          <source>If an instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</source>
          <target state="translated">Se uma instrução tem um ou mais códigos de prefixo, o controle só pode ser transferido para o primeiro desses prefixos.</target>       </trans-unit>
        <trans-unit id="3275" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Leave">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overloads can use the <ph id="ph2">`leave`</ph> opcode:</source>
          <target state="translated">O seguinte <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> sobrecargas de método podem usar o <ph id="ph2">`leave`</ph> opcode:</target>       </trans-unit>
        <trans-unit id="3276" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Leave">
          <source>ILGenerator.Emit(OpCode, Label)</source>
          <target state="translated">ILGenerator.Emit(OpCode, Label)</target>       </trans-unit>
        <trans-unit id="3277" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Leave_S">
          <source>Exits a protected region of code, unconditionally transferring control to a target instruction (short form).</source>
          <target state="translated">Sai de uma região protegida de código, transferindo o controle incondicionalmente para uma instrução de destino (forma abreviada).</target>       </trans-unit>
        <trans-unit id="3278" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Leave_S">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">A tabela a seguir lista as instruções hexadecimal e formato de assembly do Microsoft Intermediate Language (MSIL), junto com um resumo breve de referência:</target>       </trans-unit>
        <trans-unit id="3279" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Leave_S">
          <source>Format</source>
          <target state="translated">Formatar</target>       </trans-unit>
        <trans-unit id="3280" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Leave_S">
          <source>Assembly Format</source>
          <target state="translated">Formato de assembly</target>       </trans-unit>
        <trans-unit id="3281" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Leave_S">
          <source>Description</source>
          <target state="translated">Descrição</target>       </trans-unit>
        <trans-unit id="3282" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Leave_S">
          <source>DE &lt; <ph id="ph1">`int8`</ph><ph id="ph2"> &gt;</ph></source>
          <target state="translated">DE &lt; <ph id="ph1">`int8`</ph><ph id="ph2"> &gt;</ph></target>       </trans-unit>
        <trans-unit id="3283" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Leave_S">
          <source>leave.s <ph id="ph1">`target`</ph></source>
          <target state="translated">Leave <ph id="ph1">`target`</ph></target>       </trans-unit>
        <trans-unit id="3284" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Leave_S">
          <source>Exit a protected region of code, short form.</source>
          <target state="translated">Sair de uma região protegida do código, de forma abreviada.</target>       </trans-unit>
        <trans-unit id="3285" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Leave_S">
          <source>There is no stack transition behavior specified for this instruction.</source>
          <target state="translated">Não há nenhum comportamento de transição de pilha especificado para essa instrução.</target>       </trans-unit>
        <trans-unit id="3286" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Leave_S">
          <source>The <ph id="ph1">`leave.s`</ph> instruction unconditionally transfers control to the passed target instruction, represented as a 1-byte signed offset from the beginning of the instruction following the current instruction.</source>
          <target state="translated">O <ph id="ph1">`leave.s`</ph> instrução incondicionalmente transfere o controle para a instrução de destino passado, representada como um deslocamento de 1 byte assinado desde o início da instrução após a instrução atual.</target>       </trans-unit>
        <trans-unit id="3287" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Leave_S">
          <source>The <ph id="ph1">`leave.s`</ph> instruction is similar to the <ph id="ph2">`br`</ph> instruction, but it can be used to exit a <ph id="ph3">`try`</ph>, <ph id="ph4">`filter`</ph>, or <ph id="ph5">`catch`</ph> block whereas the ordinary branch instructions can only be used in such a block to transfer control within it.</source>
          <target state="translated">O <ph id="ph1">`leave.s`</ph> instrução é semelhante do <ph id="ph2">`br`</ph> instrução, mas ele pode ser usado para sair uma <ph id="ph3">`try`</ph>, <ph id="ph4">`filter`</ph>, ou <ph id="ph5">`catch`</ph> bloquear enquanto as instruções de ramificação comum só podem ser usadas em tal um bloco para transferir controle dentro dele.</target>       </trans-unit>
        <trans-unit id="3288" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Leave_S">
          <source>The <ph id="ph1">`leave.s`</ph> instruction empties the evaluation stack and ensures that the appropriate surrounding <ph id="ph2">`finally`</ph> blocks are executed.</source>
          <target state="translated">O <ph id="ph1">`leave.s`</ph> instrução esvazia a pilha de avaliação e garante que o valor apropriado ao redor <ph id="ph2">`finally`</ph> os blocos são executados.</target>       </trans-unit>
        <trans-unit id="3289" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Leave_S">
          <source>You cannot use a <ph id="ph1">`leave.s`</ph> instruction to exit a <ph id="ph2">`finally`</ph> block.</source>
          <target state="translated">Não é possível usar um <ph id="ph1">`leave.s`</ph> instruções para sair um <ph id="ph2">`finally`</ph> bloco.</target>       </trans-unit>
        <trans-unit id="3290" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Leave_S">
          <source>To ease code generation for exception handlers it is valid from within a catch block to use a <ph id="ph1">`leave.s`</ph> instruction to transfer control to any instruction within the associated <ph id="ph2">`try`</ph> block.</source>
          <target state="translated">Para facilitar a geração de código para manipuladores de exceção é válido a partir de um bloco catch para usar um <ph id="ph1">`leave.s`</ph> instrução para transferir controle para qualquer instrução em associado <ph id="ph2">`try`</ph> bloco.</target>       </trans-unit>
        <trans-unit id="3291" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Leave_S">
          <source>If an instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</source>
          <target state="translated">Se uma instrução tem um ou mais códigos de prefixo, o controle só pode ser transferido para o primeiro desses prefixos.</target>       </trans-unit>
        <trans-unit id="3292" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Leave_S">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`leave.s`</ph> opcode:</source>
          <target state="translated">O seguinte <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> sobrecarga de método pode usar o <ph id="ph2">`leave.s`</ph> opcode:</target>       </trans-unit>
        <trans-unit id="3293" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Leave_S">
          <source>ILGenerator.Emit(OpCode, Label)</source>
          <target state="translated">ILGenerator.Emit(OpCode, Label)</target>       </trans-unit>
        <trans-unit id="3294" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Localloc">
          <source>Allocates a certain number of bytes from the local dynamic memory pool and pushes the address (a transient pointer, type <ph id="ph1">&lt;see langword="*" /&gt;</ph>) of the first allocated byte onto the evaluation stack.</source>
          <target state="translated">Aloca um determinado número de bytes do pool de memória dinâmica local e envia o endereço (um ponteiro transitório, tipo <ph id="ph1">&lt;see langword="*" /&gt;</ph>) do primeiro byte alocado à pilha de avaliação.</target>       </trans-unit>
        <trans-unit id="3295" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Localloc">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">A tabela a seguir lista as instruções hexadecimal e formato de assembly do Microsoft Intermediate Language (MSIL), junto com um resumo breve de referência:</target>       </trans-unit>
        <trans-unit id="3296" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Localloc">
          <source>Format</source>
          <target state="translated">Formatar</target>       </trans-unit>
        <trans-unit id="3297" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Localloc">
          <source>Assembly Format</source>
          <target state="translated">Formato de assembly</target>       </trans-unit>
        <trans-unit id="3298" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Localloc">
          <source>Description</source>
          <target state="translated">Descrição</target>       </trans-unit>
        <trans-unit id="3299" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Localloc">
          <source>FE 0F</source>
          <target state="translated">FE 0F</target>       </trans-unit>
        <trans-unit id="3300" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Localloc">
          <source>localloc</source>
          <target state="translated">localloc</target>       </trans-unit>
        <trans-unit id="3301" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Localloc">
          <source>Allocate space from the local heap.</source>
          <target state="translated">Alocar espaço de heap local.</target>       </trans-unit>
        <trans-unit id="3302" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Localloc">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">O comportamento de transição de pilha, em ordem sequencial, é:</target>       </trans-unit>
        <trans-unit id="3303" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Localloc">
          <source>The number of bytes to be allocated is pushed onto the stack.</source>
          <target state="translated">O número de bytes a ser alocada é inserido na pilha.</target>       </trans-unit>
        <trans-unit id="3304" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Localloc">
          <source>The number of bytes is popped from the stack; an amount of memory corresponding to the size is allocated from the local heap.</source>
          <target state="translated">É exibido o número de bytes da pilha; é alocada uma quantidade de memória correspondente ao tamanho do heap local.</target>       </trans-unit>
        <trans-unit id="3305" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Localloc">
          <source>A pointer to the first byte of the allocated memory is pushed onto the stack.</source>
          <target state="translated">Um ponteiro para o primeiro byte da memória alocada é inserido na pilha.</target>       </trans-unit>
        <trans-unit id="3306" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Localloc">
          <source>The <ph id="ph1">`localloc`</ph> instruction allocates <ph id="ph2">`size`</ph> (type <ph id="ph3">`natural unsigned int`</ph>) bytes from the local dynamic memory pool and returns the address (a transient pointer, type <ph id="ph4">`*`</ph>) of the first allocated byte.</source>
          <target state="translated">O <ph id="ph1">`localloc`</ph> instrução aloca <ph id="ph2">`size`</ph> (tipo <ph id="ph3">`natural unsigned int`</ph>) pool de bytes de memória dinâmica local e retorna o endereço (um ponteiro transitório, o tipo <ph id="ph4">`*`</ph>) do primeiro byte alocado.</target>       </trans-unit>
        <trans-unit id="3307" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Localloc">
          <source>The block of memory returned is initialized to 0 only if the initialize flag on the method is <ph id="ph1">`true`</ph>.</source>
          <target state="translated">O bloco de memória retornado é inicializada em 0, apenas se o sinalizador de inicialização no método <ph id="ph1">`true`</ph>.</target>       </trans-unit>
        <trans-unit id="3308" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Localloc">
          <source>When the current method executes a <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Ret&gt;</ph>, the local memory pool is made available for reuse.</source>
          <target state="translated">Quando o método atual executa um <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Ret&gt;</ph>, o pool de memória local é disponibilizado para reutilização.</target>       </trans-unit>
        <trans-unit id="3309" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Localloc">
          <source>The resulting address is aligned so that any primitive data type can be stored there using the <ph id="ph1">`stind`</ph> instructions (such as <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Stind_I4&gt;</ph>) and loaded using the <ph id="ph3">`ldind`</ph> instructions (such as <ph id="ph4">&lt;xref:System.Reflection.Emit.OpCodes.Ldind_I4&gt;</ph>).</source>
          <target state="translated">O endereço resultante é alinhado para que qualquer tipo de dados primitivos pode ser armazenado lá usando o <ph id="ph1">`stind`</ph> instruções (como <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Stind_I4&gt;</ph>) e carregados usando o <ph id="ph3">`ldind`</ph> instruções (como <ph id="ph4">&lt;xref:System.Reflection.Emit.OpCodes.Ldind_I4&gt;</ph>).</target>       </trans-unit>
        <trans-unit id="3310" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Localloc">
          <source>The <ph id="ph1">`localloc`</ph> instruction cannot occur within a <ph id="ph2">`filter`</ph>, <ph id="ph3">`catch`</ph>, <ph id="ph4">`finally`</ph>, or <ph id="ph5">`fault`</ph> block.</source>
          <target state="translated">O <ph id="ph1">`localloc`</ph> instrução não pode ocorrer dentro de um <ph id="ph2">`filter`</ph>, <ph id="ph3">`catch`</ph>, <ph id="ph4">`finally`</ph>, ou <ph id="ph5">`fault`</ph> bloco.</target>       </trans-unit>
        <trans-unit id="3311" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Localloc">
          <source><ph id="ph1">&lt;xref:System.StackOverflowException&gt;</ph> is thrown if there is insufficient memory to service the request.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.StackOverflowException&gt;</ph> é gerada se há memória suficiente para atender à solicitação.</target>       </trans-unit>
        <trans-unit id="3312" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Localloc">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`localloc`</ph> opcode:</source>
          <target state="translated">O seguinte <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> sobrecarga de método pode usar o <ph id="ph2">`localloc`</ph> opcode:</target>       </trans-unit>
        <trans-unit id="3313" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Localloc">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="3314" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Mkrefany">
          <source>Pushes a typed reference to an instance of a specific type onto the evaluation stack.</source>
          <target state="translated">Envia uma referência tipada a uma instância de um tipo específico para a pilha de avaliação.</target>       </trans-unit>
        <trans-unit id="3315" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Mkrefany">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">A tabela a seguir lista as instruções hexadecimal e formato de assembly do Microsoft Intermediate Language (MSIL), junto com um resumo breve de referência:</target>       </trans-unit>
        <trans-unit id="3316" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Mkrefany">
          <source>Format</source>
          <target state="translated">Formatar</target>       </trans-unit>
        <trans-unit id="3317" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Mkrefany">
          <source>Assembly Format</source>
          <target state="translated">Formato de assembly</target>       </trans-unit>
        <trans-unit id="3318" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Mkrefany">
          <source>Description</source>
          <target state="translated">Descrição</target>       </trans-unit>
        <trans-unit id="3319" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Mkrefany">
          <source>C6 &lt; <ph id="ph1">`T`</ph><ph id="ph2"> &gt;</ph></source>
          <target state="translated">C6 &lt; <ph id="ph1">`T`</ph><ph id="ph2"> &gt;</ph></target>       </trans-unit>
        <trans-unit id="3320" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Mkrefany">
          <source>mkrefany <ph id="ph1">`class`</ph></source>
          <target state="translated">Mkrefany <ph id="ph1">`class`</ph></target>       </trans-unit>
        <trans-unit id="3321" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Mkrefany">
          <source>Pushes a typed reference of type <ph id="ph1">`class`</ph> onto the stack.</source>
          <target state="translated">Envia uma referência de tipo do tipo <ph id="ph1">`class`</ph> na pilha.</target>       </trans-unit>
        <trans-unit id="3322" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Mkrefany">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">O comportamento de transição de pilha, em ordem sequencial, é:</target>       </trans-unit>
        <trans-unit id="3323" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Mkrefany">
          <source>A pointer to piece of data is pushed onto the stack.</source>
          <target state="translated">Um ponteiro para dados é inserido na pilha.</target>       </trans-unit>
        <trans-unit id="3324" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Mkrefany">
          <source>The pointer is popped and converted to a typed reference of type <ph id="ph1">`class`</ph>.</source>
          <target state="translated">O ponteiro é exibido e convertido em uma referência de tipo do tipo <ph id="ph1">`class`</ph>.</target>       </trans-unit>
        <trans-unit id="3325" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Mkrefany">
          <source>The typed reference is pushed onto the stack.</source>
          <target state="translated">A referência de tipo é inserida na pilha.</target>       </trans-unit>
        <trans-unit id="3326" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Mkrefany">
          <source>The <ph id="ph1">`mkrefany`</ph> instruction supports the passing of dynamically typed references.</source>
          <target state="translated">O <ph id="ph1">`mkrefany`</ph> instrução dá suporte à passagem de Referências tipadas dinamicamente.</target>       </trans-unit>
        <trans-unit id="3327" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Mkrefany">
          <source>The pointer must be of type <ph id="ph1">`&amp;`</ph>, <ph id="ph2">`*`</ph>, or <ph id="ph3">`native int`</ph>, and hold the valid address of a piece of data.</source>
          <target state="translated">O ponteiro deve ser do tipo <ph id="ph1">`&amp;`</ph>, <ph id="ph2">`*`</ph>, ou <ph id="ph3">`native int`</ph>, mantenha o endereço válido de uma parte dos dados.</target>       </trans-unit>
        <trans-unit id="3328" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Mkrefany">
          <source><ph id="ph1">`Class`</ph> is the class token describing the type of the data referenced by the pointer.</source>
          <target state="translated"><ph id="ph1">`Class`</ph> o token de classe que descreve o tipo de dados referenciados pelo ponteiro.</target>       </trans-unit>
        <trans-unit id="3329" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Mkrefany">
          <source><ph id="ph1">`Mkrefany`</ph> pushes a typed reference on the stack, providing an opaque descriptor of the pointer and the type <ph id="ph2">`class`</ph>.</source>
          <target state="translated"><ph id="ph1">`Mkrefany`</ph> envia uma referência de tipo na pilha, fornecendo um descritor opaco do ponteiro e o tipo <ph id="ph2">`class`</ph>.</target>       </trans-unit>
        <trans-unit id="3330" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Mkrefany">
          <source>The only valid operation permitted upon a typed reference is to pass it to a method that requires a typed reference as a parameter.</source>
          <target state="translated">A operação válida somente permitida em uma referência de tipo é passá-lo para um método que requer uma referência de tipo como um parâmetro.</target>       </trans-unit>
        <trans-unit id="3331" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Mkrefany">
          <source>The callee can then use the <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Refanytype&gt;</ph> and <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Refanyval&gt;</ph> instructions to retrieve the type (class) and the address respectively.</source>
          <target state="translated">O receptor pode usar o <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Refanytype&gt;</ph> e <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Refanyval&gt;</ph> instruções para recuperar o tipo (classe) e o endereço, respectivamente.</target>       </trans-unit>
        <trans-unit id="3332" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Mkrefany">
          <source><ph id="ph1">&lt;xref:System.TypeLoadException&gt;</ph> is thrown if <ph id="ph2">`class`</ph> cannot be found.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.TypeLoadException&gt;</ph> será gerada se <ph id="ph2">`class`</ph> não pode ser encontrado.</target>       </trans-unit>
        <trans-unit id="3333" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Mkrefany">
          <source>This is typically detected when Microsoft Intermediate Language (MSIL) instructions are converted to native code rather than at runtime.</source>
          <target state="translated">Normalmente, isso é detectado quando instruções Microsoft Intermediate Language (MSIL) são convertidas em código nativo em vez de em tempo de execução.</target>       </trans-unit>
        <trans-unit id="3334" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Mkrefany">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`mkrefany`</ph> opcode:</source>
          <target state="translated">O seguinte <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> sobrecarga de método pode usar o <ph id="ph2">`mkrefany`</ph> opcode:</target>       </trans-unit>
        <trans-unit id="3335" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Mkrefany">
          <source>ILGenerator.Emit(OpCode, Type)</source>
          <target state="translated">ILGenerator.Emit(OpCode, Type)</target>       </trans-unit>
        <trans-unit id="3336" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Mul">
          <source>Multiplies two values and pushes the result on the evaluation stack.</source>
          <target state="translated">Multiplica dois valores e efetua o push do resultado na pilha de avaliação.</target>       </trans-unit>
        <trans-unit id="3337" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Mul">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">A tabela a seguir lista as instruções hexadecimal e formato de assembly do Microsoft Intermediate Language (MSIL), junto com um resumo breve de referência:</target>       </trans-unit>
        <trans-unit id="3338" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Mul">
          <source>Format</source>
          <target state="translated">Formatar</target>       </trans-unit>
        <trans-unit id="3339" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Mul">
          <source>Assembly Format</source>
          <target state="translated">Formato de assembly</target>       </trans-unit>
        <trans-unit id="3340" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Mul">
          <source>Description</source>
          <target state="translated">Descrição</target>       </trans-unit>
        <trans-unit id="3341" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Mul">
          <source>5A</source>
          <target state="translated">5A</target>       </trans-unit>
        <trans-unit id="3342" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Mul">
          <source>mul</source>
          <target state="translated">mul</target>       </trans-unit>
        <trans-unit id="3343" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Mul">
          <source>Multiplies two values on the stack.</source>
          <target state="translated">Multiplica dois valores na pilha.</target>       </trans-unit>
        <trans-unit id="3344" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Mul">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">O comportamento de transição de pilha, em ordem sequencial, é:</target>       </trans-unit>
        <trans-unit id="3345" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Mul">
          <source><ph id="ph1">`value1`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value1`</ph> é inserido na pilha.</target>       </trans-unit>
        <trans-unit id="3346" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Mul">
          <source><ph id="ph1">`value2`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value2`</ph> é inserido na pilha.</target>       </trans-unit>
        <trans-unit id="3347" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Mul">
          <source><ph id="ph1">`value2`</ph> and <ph id="ph2">`value1`</ph> are popped from the stack; <ph id="ph3">`value1`</ph> is multiplied by <ph id="ph4">`value2`</ph>.</source>
          <target state="translated"><ph id="ph1">`value2`</ph> e <ph id="ph2">`value1`</ph> são disparados da pilha; <ph id="ph3">`value1`</ph> é multiplicada por <ph id="ph4">`value2`</ph>.</target>       </trans-unit>
        <trans-unit id="3348" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Mul">
          <source>The result is pushed onto the stack.</source>
          <target state="translated">O resultado é inserido na pilha.</target>       </trans-unit>
        <trans-unit id="3349" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Mul">
          <source>The <ph id="ph1">`mul`</ph> instruction multiplies <ph id="ph2">`value1`</ph> by <ph id="ph3">`value2`</ph> and pushes the result on the stack.</source>
          <target state="translated">O <ph id="ph1">`mul`</ph> instrução multiplica <ph id="ph2">`value1`</ph> por <ph id="ph3">`value2`</ph> e envia o resultado na pilha.</target>       </trans-unit>
        <trans-unit id="3350" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Mul">
          <source>Integer operations silently truncate the upper bits on overflow.</source>
          <target state="translated">Operações de inteiro truncam silenciosamente bits superiores no estouro.</target>       </trans-unit>
        <trans-unit id="3351" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Mul">
          <source>See <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Mul_Ovf&gt;</ph> for an integer-specific multiply operation with overflow handling.</source>
          <target state="translated">Consulte <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Mul_Ovf&gt;</ph> para um determinado inteiro multiplicar operação com a manipulação de estouro.</target>       </trans-unit>
        <trans-unit id="3352" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Mul">
          <source>For floating-point types, 0 * infinity = NaN.</source>
          <target state="translated">Para tipos de ponto flutuantes, 0 * infinito = NaN.</target>       </trans-unit>
        <trans-unit id="3353" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Mul">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`mul`</ph> opcode:</source>
          <target state="translated">O seguinte <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> sobrecarga de método pode usar o <ph id="ph2">`mul`</ph> opcode:</target>       </trans-unit>
        <trans-unit id="3354" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Mul">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="3355" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Mul_Ovf">
          <source>Multiplies two integer values, performs an overflow check, and pushes the result onto the evaluation stack.</source>
          <target state="translated">Multiplica dois valores inteiros, executa uma verificação de estouro e envia por push o resultado na pilha de avaliação.</target>       </trans-unit>
        <trans-unit id="3356" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Mul_Ovf">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">A tabela a seguir lista as instruções hexadecimal e formato de assembly do Microsoft Intermediate Language (MSIL), junto com um resumo breve de referência:</target>       </trans-unit>
        <trans-unit id="3357" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Mul_Ovf">
          <source>Format</source>
          <target state="translated">Formatar</target>       </trans-unit>
        <trans-unit id="3358" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Mul_Ovf">
          <source>Assembly Format</source>
          <target state="translated">Formato de assembly</target>       </trans-unit>
        <trans-unit id="3359" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Mul_Ovf">
          <source>Description</source>
          <target state="translated">Descrição</target>       </trans-unit>
        <trans-unit id="3360" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Mul_Ovf">
          <source>D8</source>
          <target state="translated">D8</target>       </trans-unit>
        <trans-unit id="3361" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Mul_Ovf">
          <source>mul.ovf</source>
          <target state="translated">mul.ovf</target>       </trans-unit>
        <trans-unit id="3362" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Mul_Ovf">
          <source>Multiplies two integer values on the stack with an overflow check.</source>
          <target state="translated">Multiplica dois valores inteiros na pilha com uma verificação de estouro.</target>       </trans-unit>
        <trans-unit id="3363" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Mul_Ovf">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">O comportamento de transição de pilha, em ordem sequencial, é:</target>       </trans-unit>
        <trans-unit id="3364" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Mul_Ovf">
          <source><ph id="ph1">`value1`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value1`</ph> é inserido na pilha.</target>       </trans-unit>
        <trans-unit id="3365" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Mul_Ovf">
          <source><ph id="ph1">`value2`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value2`</ph> é inserido na pilha.</target>       </trans-unit>
        <trans-unit id="3366" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Mul_Ovf">
          <source><ph id="ph1">`value2`</ph> and <ph id="ph2">`value1`</ph> are popped from the stack; <ph id="ph3">`value1`</ph> is multiplied by <ph id="ph4">`value2`</ph>, with an overflow check.</source>
          <target state="translated"><ph id="ph1">`value2`</ph> e <ph id="ph2">`value1`</ph> são disparados da pilha; <ph id="ph3">`value1`</ph> é multiplicada por <ph id="ph4">`value2`</ph>, com uma verificação de estouro.</target>       </trans-unit>
        <trans-unit id="3367" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Mul_Ovf">
          <source>The result is pushed onto the stack.</source>
          <target state="translated">O resultado é inserido na pilha.</target>       </trans-unit>
        <trans-unit id="3368" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Mul_Ovf">
          <source>The <ph id="ph1">`mul.ovf`</ph> instruction multiplies integer <ph id="ph2">`value1`</ph> by integer <ph id="ph3">`value2`</ph> and pushes the result on the stack.</source>
          <target state="translated">O <ph id="ph1">`mul.ovf`</ph> instrução multiplica inteiro <ph id="ph2">`value1`</ph> por inteiro <ph id="ph3">`value2`</ph> e envia o resultado na pilha.</target>       </trans-unit>
        <trans-unit id="3369" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Mul_Ovf">
          <source>An exception is thrown if the result will not fit in the result type.</source>
          <target state="translated">Uma exceção é gerada se o resultado não cabe no tipo de resultado.</target>       </trans-unit>
        <trans-unit id="3370" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Mul_Ovf">
          <source><ph id="ph1">&lt;xref:System.OverflowException&gt;</ph> is thrown if the result can not be represented in the result type.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.OverflowException&gt;</ph> é gerada se o resultado não pode ser representado no tipo de resultado.</target>       </trans-unit>
        <trans-unit id="3371" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Mul_Ovf">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`mul.ovf`</ph> opcode:</source>
          <target state="translated">O seguinte <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> sobrecarga de método pode usar o <ph id="ph2">`mul.ovf`</ph> opcode:</target>       </trans-unit>
        <trans-unit id="3372" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Mul_Ovf">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="3373" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Mul_Ovf_Un">
          <source>Multiplies two unsigned integer values, performs an overflow check, and pushes the result onto the evaluation stack.</source>
          <target state="translated">Multiplica dois valores de inteiro sem sinal, executa uma verificação de estouro e efetua o push do resultado para a pilha de avaliação.</target>       </trans-unit>
        <trans-unit id="3374" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Mul_Ovf_Un">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">A tabela a seguir lista as instruções hexadecimal e formato de assembly do Microsoft Intermediate Language (MSIL), junto com um resumo breve de referência:</target>       </trans-unit>
        <trans-unit id="3375" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Mul_Ovf_Un">
          <source>Format</source>
          <target state="translated">Formatar</target>       </trans-unit>
        <trans-unit id="3376" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Mul_Ovf_Un">
          <source>Assembly Format</source>
          <target state="translated">Formato de assembly</target>       </trans-unit>
        <trans-unit id="3377" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Mul_Ovf_Un">
          <source>Description</source>
          <target state="translated">Descrição</target>       </trans-unit>
        <trans-unit id="3378" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Mul_Ovf_Un">
          <source>D9</source>
          <target state="translated">D9</target>       </trans-unit>
        <trans-unit id="3379" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Mul_Ovf_Un">
          <source>mul.ovf.un</source>
          <target state="translated">mul.ovf.un</target>       </trans-unit>
        <trans-unit id="3380" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Mul_Ovf_Un">
          <source>Multiplies two unsigned values on the stack with an overflow check.</source>
          <target state="translated">Multiplica dois valores não assinados na pilha com uma verificação de estouro.</target>       </trans-unit>
        <trans-unit id="3381" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Mul_Ovf_Un">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">O comportamento de transição de pilha, em ordem sequencial, é:</target>       </trans-unit>
        <trans-unit id="3382" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Mul_Ovf_Un">
          <source><ph id="ph1">`value1`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value1`</ph> é inserido na pilha.</target>       </trans-unit>
        <trans-unit id="3383" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Mul_Ovf_Un">
          <source><ph id="ph1">`value2`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value2`</ph> é inserido na pilha.</target>       </trans-unit>
        <trans-unit id="3384" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Mul_Ovf_Un">
          <source><ph id="ph1">`value2`</ph> and <ph id="ph2">`value1`</ph> are popped from the stack; <ph id="ph3">`value1`</ph> is multiplied by <ph id="ph4">`value2`</ph>, with an overflow check.</source>
          <target state="translated"><ph id="ph1">`value2`</ph> e <ph id="ph2">`value1`</ph> são disparados da pilha; <ph id="ph3">`value1`</ph> é multiplicada por <ph id="ph4">`value2`</ph>, com uma verificação de estouro.</target>       </trans-unit>
        <trans-unit id="3385" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Mul_Ovf_Un">
          <source>The result is pushed onto the stack.</source>
          <target state="translated">O resultado é inserido na pilha.</target>       </trans-unit>
        <trans-unit id="3386" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Mul_Ovf_Un">
          <source>The <ph id="ph1">`mul.ovf.un`</ph> instruction multiplies unsigned integer <ph id="ph2">`value1`</ph> by unsigned integer <ph id="ph3">`value2`</ph> and pushes the result on the stack.</source>
          <target state="translated">O <ph id="ph1">`mul.ovf.un`</ph> instrução multiplica inteiro sem sinal <ph id="ph2">`value1`</ph> por inteiro sem sinal <ph id="ph3">`value2`</ph> e envia o resultado na pilha.</target>       </trans-unit>
        <trans-unit id="3387" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Mul_Ovf_Un">
          <source>An exception is thrown if the result will not fit in the result type.</source>
          <target state="translated">Uma exceção é gerada se o resultado não cabe no tipo de resultado.</target>       </trans-unit>
        <trans-unit id="3388" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Mul_Ovf_Un">
          <source><ph id="ph1">&lt;xref:System.OverflowException&gt;</ph> is thrown if the result can not be represented in the result type.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.OverflowException&gt;</ph> é gerada se o resultado não pode ser representado no tipo de resultado.</target>       </trans-unit>
        <trans-unit id="3389" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Mul_Ovf_Un">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`mul.ovf.un`</ph> opcode:</source>
          <target state="translated">O seguinte <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> sobrecarga de método pode usar o <ph id="ph2">`mul.ovf.un`</ph> opcode:</target>       </trans-unit>
        <trans-unit id="3390" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Mul_Ovf_Un">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="3391" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Neg">
          <source>Negates a value and pushes the result onto the evaluation stack.</source>
          <target state="translated">Nega um valor e efetua o push do resultado para a pilha de avaliação.</target>       </trans-unit>
        <trans-unit id="3392" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Neg">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">A tabela a seguir lista as instruções hexadecimal e formato de assembly do Microsoft Intermediate Language (MSIL), junto com um resumo breve de referência:</target>       </trans-unit>
        <trans-unit id="3393" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Neg">
          <source>Format</source>
          <target state="translated">Formatar</target>       </trans-unit>
        <trans-unit id="3394" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Neg">
          <source>Assembly Format</source>
          <target state="translated">Formato de assembly</target>       </trans-unit>
        <trans-unit id="3395" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Neg">
          <source>Description</source>
          <target state="translated">Descrição</target>       </trans-unit>
        <trans-unit id="3396" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Neg">
          <source>65</source>
          <target state="translated">65</target>       </trans-unit>
        <trans-unit id="3397" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Neg">
          <source>neg</source>
          <target state="translated">Neg</target>       </trans-unit>
        <trans-unit id="3398" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Neg">
          <source>Negates the value currently on top of the stack.</source>
          <target state="translated">Nega o valor atualmente na parte superior da pilha.</target>       </trans-unit>
        <trans-unit id="3399" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Neg">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">O comportamento de transição de pilha, em ordem sequencial, é:</target>       </trans-unit>
        <trans-unit id="3400" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Neg">
          <source>A value is pushed onto the stack.</source>
          <target state="translated">Um valor é inserido na pilha.</target>       </trans-unit>
        <trans-unit id="3401" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Neg">
          <source>A value is popped from the stack and negated.</source>
          <target state="translated">Um valor é exibido da pilha e negado.</target>       </trans-unit>
        <trans-unit id="3402" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Neg">
          <source>The result is pushed onto the stack.</source>
          <target state="translated">O resultado é inserido na pilha.</target>       </trans-unit>
        <trans-unit id="3403" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Neg">
          <source>The <ph id="ph1">`neg`</ph> instruction negates value and pushes the result on top of the stack.</source>
          <target state="translated">O <ph id="ph1">`neg`</ph> nega o valor de instrução e envia o resultado na parte superior da pilha.</target>       </trans-unit>
        <trans-unit id="3404" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Neg">
          <source>The return type is the same as the operand type.</source>
          <target state="translated">O tipo de retorno é o mesmo que o tipo de operando.</target>       </trans-unit>
        <trans-unit id="3405" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Neg">
          <source>Negation of integral values is standard two's complement negation.</source>
          <target state="translated">Negação de valores integrais é o padrão do complemento de dois negação.</target>       </trans-unit>
        <trans-unit id="3406" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Neg">
          <source>In particular, negating the most negative number (which does not have a positive counterpart) yields the most negative number.</source>
          <target state="translated">Em particular, eliminando o número mais negativo (que não tem um equivalente positivo) produz o número mais negativo.</target>       </trans-unit>
        <trans-unit id="3407" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Neg">
          <source>To detect this overflow use the <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Sub_Ovf&gt;</ph> instruction instead (that is, subtract from 0).</source>
          <target state="translated">Para detectar esse uso de estouro de <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Sub_Ovf&gt;</ph> instrução em vez disso (ou seja, subtrair de 0).</target>       </trans-unit>
        <trans-unit id="3408" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Neg">
          <source>Negating a floating-point number cannot overflow, and negating NaN returns NaN.</source>
          <target state="translated">Eliminando o número de ponto flutuante não será possível estourar e negar NaN retorna NaN.</target>       </trans-unit>
        <trans-unit id="3409" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Neg">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`neg`</ph> opcode:</source>
          <target state="translated">O seguinte <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> sobrecarga de método pode usar o <ph id="ph2">`neg`</ph> opcode:</target>       </trans-unit>
        <trans-unit id="3410" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Neg">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="3411" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Newarr">
          <source>Pushes an object reference to a new zero-based, one-dimensional array whose elements are of a specific type onto the evaluation stack.</source>
          <target state="translated">Envia por push uma referência de objeto para uma nova matriz unidimensional baseada em zero, cujos elementos são de um tipo específico na pilha de avaliação.</target>       </trans-unit>
        <trans-unit id="3412" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Newarr">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">A tabela a seguir lista as instruções hexadecimal e formato de assembly do Microsoft Intermediate Language (MSIL), junto com um resumo breve de referência:</target>       </trans-unit>
        <trans-unit id="3413" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Newarr">
          <source>Format</source>
          <target state="translated">Formatar</target>       </trans-unit>
        <trans-unit id="3414" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Newarr">
          <source>Assembly Format</source>
          <target state="translated">Formato de assembly</target>       </trans-unit>
        <trans-unit id="3415" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Newarr">
          <source>Description</source>
          <target state="translated">Descrição</target>       </trans-unit>
        <trans-unit id="3416" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Newarr">
          <source>8D &lt; <ph id="ph1">`T`</ph><ph id="ph2"> &gt;</ph></source>
          <target state="translated">8D &lt; <ph id="ph1">`T`</ph><ph id="ph2"> &gt;</ph></target>       </trans-unit>
        <trans-unit id="3417" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Newarr">
          <source>newarr <ph id="ph1">`etype`</ph></source>
          <target state="translated">newarr <ph id="ph1">`etype`</ph></target>       </trans-unit>
        <trans-unit id="3418" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Newarr">
          <source>Creates a new array with elements of type <ph id="ph1">`etype`</ph>.</source>
          <target state="translated">Cria uma nova matriz com elementos do tipo <ph id="ph1">`etype`</ph>.</target>       </trans-unit>
        <trans-unit id="3419" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Newarr">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">O comportamento de transição de pilha, em ordem sequencial, é:</target>       </trans-unit>
        <trans-unit id="3420" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Newarr">
          <source>The number of elements in the array is pushed onto the stack.</source>
          <target state="translated">O número de elementos na matriz é inserido na pilha.</target>       </trans-unit>
        <trans-unit id="3421" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Newarr">
          <source>The number of elements is popped from the stack and the array is created.</source>
          <target state="translated">É exibido o número de elementos da pilha e a matriz é criada.</target>       </trans-unit>
        <trans-unit id="3422" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Newarr">
          <source>An object reference to the new array is pushed onto the stack.</source>
          <target state="translated">Uma referência de objeto para a nova matriz é inserida na pilha.</target>       </trans-unit>
        <trans-unit id="3423" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Newarr">
          <source>The <ph id="ph1">`newarr`</ph> instruction pushes an object reference (type <ph id="ph2">`O`</ph>) to a new zero-based, one-dimensional array whose elements are of type <ph id="ph3">`etype`</ph> (a metadata token describing the type).</source>
          <target state="translated">O <ph id="ph1">`newarr`</ph> instrução envia uma referência de objeto (tipo <ph id="ph2">`O`</ph>) para uma nova matriz unidimensional, com base em zero cujos elementos são do tipo <ph id="ph3">`etype`</ph> (um token de metadados que descreve o tipo).</target>       </trans-unit>
        <trans-unit id="3424" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Newarr">
          <source>The number of elements in the new array should be specified as a <ph id="ph1">`native int`</ph>.</source>
          <target state="translated">O número de elementos na nova matriz deve ser especificado como um <ph id="ph1">`native int`</ph>.</target>       </trans-unit>
        <trans-unit id="3425" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Newarr">
          <source>Valid array indexes range from zero to the maximum number of elements minus one.</source>
          <target state="translated">Intervalo de índices de matriz válida de zero para o número máximo de elementos menos um.</target>       </trans-unit>
        <trans-unit id="3426" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Newarr">
          <source>The elements of an array can be any type, including value types.</source>
          <target state="translated">Os elementos de uma matriz podem ser qualquer tipo, incluindo tipos de valor.</target>       </trans-unit>
        <trans-unit id="3427" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Newarr">
          <source>Zero-based, one-dimensional arrays of numbers are created using a metadata token referencing the appropriate value type (<ph id="ph1">&lt;xref:System.Int32&gt;</ph>, and so on).</source>
          <target state="translated">Matrizes unidimensionais, com base em zero de números são criados usando um token de metadados, fazendo referência ao tipo de valor apropriado (<ph id="ph1">&lt;xref:System.Int32&gt;</ph>, e assim por diante).</target>       </trans-unit>
        <trans-unit id="3428" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Newarr">
          <source>Elements of the array are initialized to 0 of the appropriate type.</source>
          <target state="translated">Elementos da matriz são inicializados como 0 do tipo apropriado.</target>       </trans-unit>
        <trans-unit id="3429" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Newarr">
          <source>Nonzero-based one-dimensional arrays and multidimensional arrays are created using <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Newobj&gt;</ph> rather than <ph id="ph2">`newarr`</ph>.</source>
          <target state="translated">Matrizes unidimensionais NonZero-com base e matrizes multidimensionais são criados usando <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Newobj&gt;</ph> em vez de <ph id="ph2">`newarr`</ph>.</target>       </trans-unit>
        <trans-unit id="3430" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Newarr">
          <source>More commonly, they are created using the methods of the <ph id="ph1">&lt;xref:System.Array&gt;</ph> class in the .NET Framework.</source>
          <target state="translated">Mais comumente, eles são criados usando os métodos do <ph id="ph1">&lt;xref:System.Array&gt;</ph> classe do .NET Framework.</target>       </trans-unit>
        <trans-unit id="3431" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Newarr">
          <source><ph id="ph1">&lt;xref:System.OutOfMemoryException&gt;</ph> is thrown if there is insufficient memory to satisfy the request.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.OutOfMemoryException&gt;</ph> é gerada se há memória suficiente para atender à solicitação.</target>       </trans-unit>
        <trans-unit id="3432" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Newarr">
          <source><ph id="ph1">&lt;xref:System.OverflowException&gt;</ph> is thrown if <ph id="ph2">`numElems`</ph> is less than 0.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.OverflowException&gt;</ph> será gerada se <ph id="ph2">`numElems`</ph> é menor que 0.</target>       </trans-unit>
        <trans-unit id="3433" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Newarr">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`newarr`</ph> opcode:</source>
          <target state="translated">O seguinte <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> sobrecarga de método pode usar o <ph id="ph2">`newarr`</ph> opcode:</target>       </trans-unit>
        <trans-unit id="3434" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Newarr">
          <source>ILGenerator.Emit(OpCode, Type)</source>
          <target state="translated">ILGenerator.Emit(OpCode, Type)</target>       </trans-unit>
        <trans-unit id="3435" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Newobj">
          <source>Creates a new object or a new instance of a value type, pushing an object reference (type <ph id="ph1">&lt;see langword="O" /&gt;</ph>) onto the evaluation stack.</source>
          <target state="translated">Cria um novo objeto ou uma nova instância de um tipo de valor, enviando por push uma referência de objeto (tipo <ph id="ph1">&lt;see langword="O" /&gt;</ph>) para a pilha de avaliação.</target>       </trans-unit>
        <trans-unit id="3436" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Newobj">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">A tabela a seguir lista as instruções hexadecimal e formato de assembly do Microsoft Intermediate Language (MSIL), junto com um resumo breve de referência:</target>       </trans-unit>
        <trans-unit id="3437" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Newobj">
          <source>Format</source>
          <target state="translated">Formatar</target>       </trans-unit>
        <trans-unit id="3438" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Newobj">
          <source>Assembly Format</source>
          <target state="translated">Formato de assembly</target>       </trans-unit>
        <trans-unit id="3439" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Newobj">
          <source>Description</source>
          <target state="translated">Descrição</target>       </trans-unit>
        <trans-unit id="3440" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Newobj">
          <source>73 &lt; <ph id="ph1">`T`</ph><ph id="ph2"> &gt;</ph></source>
          <target state="translated">73 &lt; <ph id="ph1">`T`</ph><ph id="ph2"> &gt;</ph></target>       </trans-unit>
        <trans-unit id="3441" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Newobj">
          <source>newobj <ph id="ph1">`ctor`</ph></source>
          <target state="translated">newobj <ph id="ph1">`ctor`</ph></target>       </trans-unit>
        <trans-unit id="3442" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Newobj">
          <source>Allocates an uninitialized object or value type and calls the constructor method <ph id="ph1">`ctor`</ph>.</source>
          <target state="translated">Aloca um tipo de objeto ou valor não inicializado e chama o método de construtor <ph id="ph1">`ctor`</ph>.</target>       </trans-unit>
        <trans-unit id="3443" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Newobj">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">O comportamento de transição de pilha, em ordem sequencial, é:</target>       </trans-unit>
        <trans-unit id="3444" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Newobj">
          <source>Arguments <ph id="ph1">`arg1`</ph> through <ph id="ph2">`argn`</ph> are pushed on the stack in sequence.</source>
          <target state="translated">Argumentos <ph id="ph1">`arg1`</ph> por meio de <ph id="ph2">`argn`</ph> são enviados por push na pilha na sequência.</target>       </trans-unit>
        <trans-unit id="3445" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Newobj">
          <source>Arguments <ph id="ph1">`argn`</ph> through <ph id="ph2">`arg1`</ph> are popped from the stack and passed to <ph id="ph3">`ctor`</ph> for object creation.</source>
          <target state="translated">Argumentos <ph id="ph1">`argn`</ph> por meio de <ph id="ph2">`arg1`</ph> são disparados da pilha e passados para <ph id="ph3">`ctor`</ph> para a criação do objeto.</target>       </trans-unit>
        <trans-unit id="3446" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Newobj">
          <source>A reference to the new object is pushed onto the stack.</source>
          <target state="translated">Uma referência ao novo objeto é inserida na pilha.</target>       </trans-unit>
        <trans-unit id="3447" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Newobj">
          <source>The <ph id="ph1">`newobj`</ph> instruction creates a new object or a new instance of a value type.</source>
          <target state="translated">O <ph id="ph1">`newobj`</ph> instrução cria um novo objeto ou uma nova instância de um tipo de valor.</target>       </trans-unit>
        <trans-unit id="3448" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Newobj">
          <source><ph id="ph1">`Ctor`</ph> is a metadata token (a <ph id="ph2">`methodref`</ph> or <ph id="ph3">`methoddef`</ph> that must be marked as a constructor) that indicates the name, class and signature of the constructor to call.</source>
          <target state="translated"><ph id="ph1">`Ctor`</ph> é um token de metadados (uma <ph id="ph2">`methodref`</ph> ou <ph id="ph3">`methoddef`</ph> que deve ser marcada como um construtor) que indica o nome, a classe e a assinatura de construtor para chamar.</target>       </trans-unit>
        <trans-unit id="3449" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Newobj">
          <source>The <ph id="ph1">`newobj`</ph> instruction allocates a new instance of the class associated with <ph id="ph2">`ctor`</ph> and initializes all the fields in the new instance to 0 (of the proper type) or null references as appropriate.</source>
          <target state="translated">O <ph id="ph1">`newobj`</ph> instrução aloca uma nova instância da classe associada a <ph id="ph2">`ctor`</ph> e inicializa todos os campos na nova instância como 0 (do tipo correto) ou referências nulas conforme apropriado.</target>       </trans-unit>
        <trans-unit id="3450" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Newobj">
          <source>It then calls the constructor <ph id="ph1">`ctor`</ph> with the given arguments along with the newly created instance.</source>
          <target state="translated">Depois, ele chama o construtor <ph id="ph1">`ctor`</ph> com os argumentos fornecidos junto com a instância recém criada.</target>       </trans-unit>
        <trans-unit id="3451" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Newobj">
          <source>After the constructor has been called, the now initialized object reference (type <ph id="ph1">`O`</ph>) is pushed on the stack.</source>
          <target state="translated">Depois que o construtor foi chamado, o agora inicializado referência de objeto (tipo <ph id="ph1">`O`</ph>) é enviada por push na pilha.</target>       </trans-unit>
        <trans-unit id="3452" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Newobj">
          <source>From the constructor's point of view, the uninitialized object is argument 0 and the other arguments passed to newobj follow in order.</source>
          <target state="translated">Do ponto de vista do construtor, o objeto não inicializado é o argumento 0 e os outros argumentos passados para newobj siga na ordem.</target>       </trans-unit>
        <trans-unit id="3453" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Newobj">
          <source>All zero-based, one-dimensional arrays are created using <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Newarr&gt;</ph>, not <ph id="ph2">`newobj`</ph>.</source>
          <target state="translated">Todas as matrizes unidimensionais, com base em zero são criadas usando <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Newarr&gt;</ph>, não <ph id="ph2">`newobj`</ph>.</target>       </trans-unit>
        <trans-unit id="3454" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Newobj">
          <source>On the other hand, all other arrays (more than one dimension, or one-dimensional but not zero-based) are created using <ph id="ph1">`newobj`</ph>.</source>
          <target state="translated">Por outro lado, todas as outras matrizes (mais de uma dimensão, ou unidimensional, mas não com base em zero) são criados usando <ph id="ph1">`newobj`</ph>.</target>       </trans-unit>
        <trans-unit id="3455" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Newobj">
          <source>Value types are not usually created using <ph id="ph1">`newobj`</ph>.</source>
          <target state="translated">Tipos de valor não são geralmente criados usando <ph id="ph1">`newobj`</ph>.</target>       </trans-unit>
        <trans-unit id="3456" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Newobj">
          <source>They are usually allocated either as arguments or local variables, using <ph id="ph1">`newarr`</ph> (for zero-based, one-dimensional arrays), or as fields of objects.</source>
          <target state="translated">Elas geralmente são alocadas como argumentos ou variáveis locais, usando <ph id="ph1">`newarr`</ph> (para matrizes unidimensionais, com base em zero), ou como campos de objetos.</target>       </trans-unit>
        <trans-unit id="3457" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Newobj">
          <source>Once allocated, they are initialized using <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Initobj&gt;</ph>.</source>
          <target state="translated">Uma vez alocada, eles são iniciados usando <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Initobj&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3458" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Newobj">
          <source>However, the <ph id="ph1">`newobj`</ph> instruction can be used to create a new instance of a value type on the stack, that can then be passed as an argument, stored in a local, and so on.</source>
          <target state="translated">No entanto, o <ph id="ph1">`newobj`</ph> instrução pode ser usada para criar uma nova instância de um tipo de valor na pilha, que pode ser passada como um argumento, armazenado em um local e assim por diante.</target>       </trans-unit>
        <trans-unit id="3459" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Newobj">
          <source><ph id="ph1">&lt;xref:System.OutOfMemoryException&gt;</ph> is thrown if there is insufficient memory to satisfy the request.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.OutOfMemoryException&gt;</ph> é gerada se há memória suficiente para atender à solicitação.</target>       </trans-unit>
        <trans-unit id="3460" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Newobj">
          <source><ph id="ph1">&lt;xref:System.MissingMethodException&gt;</ph> is thrown if a constructor method <ph id="ph2">`ctor`</ph> with the indicated name, class and signature could not be found.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.MissingMethodException&gt;</ph> será gerada se um método de construtor <ph id="ph2">`ctor`</ph> com o nome indicado, classe e a assinatura não podem ser encontrados.</target>       </trans-unit>
        <trans-unit id="3461" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Newobj">
          <source>This is typically detected when Microsoft Intermediate Language (MSIL) instructions are converted to native code, rather than at runtime.</source>
          <target state="translated">Normalmente, isso é detectado quando instruções Microsoft Intermediate Language (MSIL) são convertidas em código nativo, em vez de em tempo de execução.</target>       </trans-unit>
        <trans-unit id="3462" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Newobj">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`newobj`</ph> opcode:</source>
          <target state="translated">O seguinte <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> sobrecarga de método pode usar o <ph id="ph2">`newobj`</ph> opcode:</target>       </trans-unit>
        <trans-unit id="3463" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Newobj">
          <source>ILGenerator.Emit(OpCode, ConstructorInfo)</source>
          <target state="translated">ILGenerator.Emit(OpCode, ConstructorInfo)</target>       </trans-unit>
        <trans-unit id="3464" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Nop">
          <source>Fills space if opcodes are patched.</source>
          <target state="translated">Preencherá o espaço se os opcodes forem corrigidos.</target>       </trans-unit>
        <trans-unit id="3465" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Nop">
          <source>No meaningful operation is performed although a processing cycle can be consumed.</source>
          <target state="translated">Nenhuma operação significativa será executada, embora um ciclo de processamento possa ser consumido.</target>       </trans-unit>
        <trans-unit id="3466" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Nop">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">A tabela a seguir lista as instruções hexadecimal e formato de assembly do Microsoft Intermediate Language (MSIL), junto com um resumo breve de referência:</target>       </trans-unit>
        <trans-unit id="3467" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Nop">
          <source>Format</source>
          <target state="translated">Formatar</target>       </trans-unit>
        <trans-unit id="3468" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Nop">
          <source>Assembly Format</source>
          <target state="translated">Formato de assembly</target>       </trans-unit>
        <trans-unit id="3469" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Nop">
          <source>Description</source>
          <target state="translated">Descrição</target>       </trans-unit>
        <trans-unit id="3470" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Nop">
          <source>00</source>
          <target state="translated">00</target>       </trans-unit>
        <trans-unit id="3471" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Nop">
          <source>nop</source>
          <target state="translated">Nop</target>       </trans-unit>
        <trans-unit id="3472" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Nop">
          <source>Performs an operation without behavior.</source>
          <target state="translated">Executa uma operação sem comportamento.</target>       </trans-unit>
        <trans-unit id="3473" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Nop">
          <source>There is no stack transitional behavior defined for this instruction.</source>
          <target state="translated">Há um comportamento de transição de pilha definido para essa instrução.</target>       </trans-unit>
        <trans-unit id="3474" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Nop">
          <source>The <ph id="ph1">`nop`</ph> operation does nothing.</source>
          <target state="translated">O <ph id="ph1">`nop`</ph> operação não fará nada.</target>       </trans-unit>
        <trans-unit id="3475" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Nop">
          <source>It is intended to fill in space if opcodes are patched.</source>
          <target state="translated">Ele destina-se para preencher o espaço se opcodes sejam corrigidos.</target>       </trans-unit>
        <trans-unit id="3476" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Nop">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`nop`</ph> opcode:</source>
          <target state="translated">O seguinte <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> sobrecarga de método pode usar o <ph id="ph2">`nop`</ph> opcode:</target>       </trans-unit>
        <trans-unit id="3477" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Nop">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="3478" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Not">
          <source>Computes the bitwise complement of the integer value on top of the stack and pushes the result onto the evaluation stack as the same type.</source>
          <target state="translated">Calcula o complemento bit a bit do valor de inteiro na parte superior da pilha e efetua o push o resultado para a pilha de avaliação como o mesmo tipo.</target>       </trans-unit>
        <trans-unit id="3479" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Not">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">A tabela a seguir lista as instruções hexadecimal e formato de assembly do Microsoft Intermediate Language (MSIL), junto com um resumo breve de referência:</target>       </trans-unit>
        <trans-unit id="3480" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Not">
          <source>Format</source>
          <target state="translated">Formatar</target>       </trans-unit>
        <trans-unit id="3481" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Not">
          <source>Assembly Format</source>
          <target state="translated">Formato de assembly</target>       </trans-unit>
        <trans-unit id="3482" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Not">
          <source>Description</source>
          <target state="translated">Descrição</target>       </trans-unit>
        <trans-unit id="3483" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Not">
          <source>66</source>
          <target state="translated">66</target>       </trans-unit>
        <trans-unit id="3484" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Not">
          <source>not</source>
          <target state="translated">not</target>       </trans-unit>
        <trans-unit id="3485" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Not">
          <source>Computes the bitwise complement of a value.</source>
          <target state="translated">Calcula o complemento bit a bit de um valor.</target>       </trans-unit>
        <trans-unit id="3486" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Not">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">O comportamento de transição de pilha, em ordem sequencial, é:</target>       </trans-unit>
        <trans-unit id="3487" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Not">
          <source><ph id="ph1">`value`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value`</ph> é inserido na pilha.</target>       </trans-unit>
        <trans-unit id="3488" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Not">
          <source><ph id="ph1">`value`</ph> is popped from the stack and its bitwise complement computed.</source>
          <target state="translated"><ph id="ph1">`value`</ph> é exibido na pilha e o bit a bit complemento computado.</target>       </trans-unit>
        <trans-unit id="3489" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Not">
          <source>The result is pushed onto the stack.</source>
          <target state="translated">O resultado é inserido na pilha.</target>       </trans-unit>
        <trans-unit id="3490" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Not">
          <source>The <ph id="ph1">`not`</ph> instruction computes the bitwise complement of an integer value and pushes the result onto the stack.</source>
          <target state="translated">O <ph id="ph1">`not`</ph> instrução calcula o complemento bit a bit de um valor inteiro e envia o resultado para a pilha.</target>       </trans-unit>
        <trans-unit id="3491" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Not">
          <source>The return type is the same as the operand type.</source>
          <target state="translated">O tipo de retorno é o mesmo que o tipo de operando.</target>       </trans-unit>
        <trans-unit id="3492" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Not">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`not`</ph> opcode:</source>
          <target state="translated">O seguinte <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> sobrecarga de método pode usar o <ph id="ph2">`not`</ph> opcode:</target>       </trans-unit>
        <trans-unit id="3493" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Not">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="3494" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Or">
          <source>Compute the bitwise complement of the two integer values on top of the stack and pushes the result onto the evaluation stack.</source>
          <target state="translated">Computa o complemento bit a bit dos dois valores de inteiro na parte superior da pilha e efetua o push do resultado para a pilha de avaliação.</target>       </trans-unit>
        <trans-unit id="3495" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Or">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">A tabela a seguir lista as instruções hexadecimal e formato de assembly do Microsoft Intermediate Language (MSIL), junto com um resumo breve de referência:</target>       </trans-unit>
        <trans-unit id="3496" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Or">
          <source>Format</source>
          <target state="translated">Formatar</target>       </trans-unit>
        <trans-unit id="3497" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Or">
          <source>Assembly Format</source>
          <target state="translated">Formato de assembly</target>       </trans-unit>
        <trans-unit id="3498" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Or">
          <source>Description</source>
          <target state="translated">Descrição</target>       </trans-unit>
        <trans-unit id="3499" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Or">
          <source>60</source>
          <target state="translated">60</target>       </trans-unit>
        <trans-unit id="3500" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Or">
          <source>or</source>
          <target state="translated">ou</target>       </trans-unit>
        <trans-unit id="3501" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Or">
          <source>Computes the bitwise OR of two integer values, returns an integer.</source>
          <target state="translated">Calcula o bit a bit ou de dois valores inteiros, retorna um inteiro.</target>       </trans-unit>
        <trans-unit id="3502" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Or">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">O comportamento de transição de pilha, em ordem sequencial, é:</target>       </trans-unit>
        <trans-unit id="3503" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Or">
          <source><ph id="ph1">`value1`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value1`</ph> é inserido na pilha.</target>       </trans-unit>
        <trans-unit id="3504" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Or">
          <source><ph id="ph1">`value2`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value2`</ph> é inserido na pilha.</target>       </trans-unit>
        <trans-unit id="3505" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Or">
          <source><ph id="ph1">`value2`</ph> and <ph id="ph2">`value1`</ph> are popped from the stack and their bitwise OR computed.</source>
          <target state="translated"><ph id="ph1">`value2`</ph> e <ph id="ph2">`value1`</ph> são disparados de pilha e seu OR bit a bit computada.</target>       </trans-unit>
        <trans-unit id="3506" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Or">
          <source>The result is pushed onto the stack.</source>
          <target state="translated">O resultado é inserido na pilha.</target>       </trans-unit>
        <trans-unit id="3507" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Or">
          <source>The <ph id="ph1">`or`</ph> instruction computes the bitwise OR of two values atop the stack, pushing the result onto the stack.</source>
          <target state="translated">O <ph id="ph1">`or`</ph> instrução calcula o OR bit a bit de dois valores acima da pilha de envio por push o resultado para a pilha.</target>       </trans-unit>
        <trans-unit id="3508" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Or">
          <source><ph id="ph1">`Or`</ph> is an integer-specific operation.</source>
          <target state="translated"><ph id="ph1">`Or`</ph> é uma operação de inteiro específico.</target>       </trans-unit>
        <trans-unit id="3509" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Or">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`or`</ph> opcode:</source>
          <target state="translated">O seguinte <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> sobrecarga de método pode usar o <ph id="ph2">`or`</ph> opcode:</target>       </trans-unit>
        <trans-unit id="3510" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Or">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="3511" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Pop">
          <source>Removes the value currently on top of the evaluation stack.</source>
          <target state="translated">Remove o valor atualmente no topo da pilha de avaliação.</target>       </trans-unit>
        <trans-unit id="3512" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Pop">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">A tabela a seguir lista as instruções hexadecimal e formato de assembly do Microsoft Intermediate Language (MSIL), junto com um resumo breve de referência:</target>       </trans-unit>
        <trans-unit id="3513" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Pop">
          <source>Format</source>
          <target state="translated">Formatar</target>       </trans-unit>
        <trans-unit id="3514" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Pop">
          <source>Assembly Format</source>
          <target state="translated">Formato de assembly</target>       </trans-unit>
        <trans-unit id="3515" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Pop">
          <source>Description</source>
          <target state="translated">Descrição</target>       </trans-unit>
        <trans-unit id="3516" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Pop">
          <source>26</source>
          <target state="translated">26</target>       </trans-unit>
        <trans-unit id="3517" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Pop">
          <source>pop</source>
          <target state="translated">pop</target>       </trans-unit>
        <trans-unit id="3518" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Pop">
          <source>Pops the top value from the stack.</source>
          <target state="translated">Exibe o valor de nível superior da pilha.</target>       </trans-unit>
        <trans-unit id="3519" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Pop">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">O comportamento de transição de pilha, em ordem sequencial, é:</target>       </trans-unit>
        <trans-unit id="3520" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Pop">
          <source>The top value is popped from the stack.</source>
          <target state="translated">O valor de nível superior é exibido da pilha.</target>       </trans-unit>
        <trans-unit id="3521" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Pop">
          <source>The <ph id="ph1">`pop`</ph> instruction removes the top element from the stack.</source>
          <target state="translated">O <ph id="ph1">`pop`</ph> instrução remove o elemento superior da pilha.</target>       </trans-unit>
        <trans-unit id="3522" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Pop">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`pop`</ph> opcode:</source>
          <target state="translated">O seguinte <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> sobrecarga de método pode usar o <ph id="ph2">`pop`</ph> opcode:</target>       </trans-unit>
        <trans-unit id="3523" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Pop">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="3524" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Prefix1">
          <source>This is a reserved instruction.</source>
          <target state="translated">Esta é uma instrução reservada.</target>       </trans-unit>
        <trans-unit id="3525" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Prefix2">
          <source>This is a reserved instruction.</source>
          <target state="translated">Esta é uma instrução reservada.</target>       </trans-unit>
        <trans-unit id="3526" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Prefix3">
          <source>This is a reserved instruction.</source>
          <target state="translated">Esta é uma instrução reservada.</target>       </trans-unit>
        <trans-unit id="3527" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Prefix4">
          <source>This is a reserved instruction.</source>
          <target state="translated">Esta é uma instrução reservada.</target>       </trans-unit>
        <trans-unit id="3528" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Prefix5">
          <source>This is a reserved instruction.</source>
          <target state="translated">Esta é uma instrução reservada.</target>       </trans-unit>
        <trans-unit id="3529" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Prefix6">
          <source>This is a reserved instruction.</source>
          <target state="translated">Esta é uma instrução reservada.</target>       </trans-unit>
        <trans-unit id="3530" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Prefix7">
          <source>This is a reserved instruction.</source>
          <target state="translated">Esta é uma instrução reservada.</target>       </trans-unit>
        <trans-unit id="3531" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Prefixref">
          <source>This is a reserved instruction.</source>
          <target state="translated">Esta é uma instrução reservada.</target>       </trans-unit>
        <trans-unit id="3532" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Readonly">
          <source>Specifies that the subsequent array address operation performs no type check at run time, and that it returns a managed pointer whose mutability is restricted.</source>
          <target state="translated">Especifica que a operação de endereço da matriz subsequente não executa nenhuma verificação de tipo no tempo de execução e que ela retorna um ponteiro gerenciado cuja mutabilidade é restrita.</target>       </trans-unit>
        <trans-unit id="3533" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Readonly">
          <source>The following table lists the instruction's hexadecimal and Microsoft intermediate language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">A tabela a seguir lista a instrução hexadecimal e formato de assembly Microsoft intermediate language (MSIL), junto com um resumo breve de referência:</target>       </trans-unit>
        <trans-unit id="3534" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Readonly">
          <source>Format</source>
          <target state="translated">Formatar</target>       </trans-unit>
        <trans-unit id="3535" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Readonly">
          <source>Assembly Format</source>
          <target state="translated">Formato de assembly</target>       </trans-unit>
        <trans-unit id="3536" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Readonly">
          <source>Description</source>
          <target state="translated">Descrição</target>       </trans-unit>
        <trans-unit id="3537" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Readonly">
          <source>FE 1E</source>
          <target state="translated">FE 1E</target>       </trans-unit>
        <trans-unit id="3538" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Readonly">
          <source>readonly.</source>
          <target state="translated">somente leitura.</target>       </trans-unit>
        <trans-unit id="3539" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Readonly">
          <source>Specify that the subsequent array address operation performs no type check at run time, and that it returns a managed pointer with restricted mutability.</source>
          <target state="translated">Especifique que a operação de endereço da matriz subsequentes não executa nenhuma verificação de tipo em tempo de execução e que ela retorna um ponteiro gerenciado com Mutabilidade restrita.</target>       </trans-unit>
        <trans-unit id="3540" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Readonly">
          <source>This prefix can only appear immediately preceding the <ph id="ph1">`ldelema`</ph> instruction and calls to the special <ph id="ph2">`Address`</ph> method on arrays.</source>
          <target state="translated">Esse prefixo só pode aparecer imediatamente anterior a <ph id="ph1">`ldelema`</ph> instrução e chamadas especiais <ph id="ph2">`Address`</ph> método em matrizes.</target>       </trans-unit>
        <trans-unit id="3541" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Readonly">
          <source>Its effect on the subsequent operation is twofold:</source>
          <target state="translated">Seu efeito sobre a operação subsequente é dupla:</target>       </trans-unit>
        <trans-unit id="3542" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Readonly">
          <source>At run time, no type check operation is performed.</source>
          <target state="translated">Em tempo de execução, nenhuma operação de verificação de tipo é executada.</target>       </trans-unit>
        <trans-unit id="3543" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Readonly">
          <source>Note that there is normally an implicit type check for the <ph id="ph1">`ldelema`</ph> and <ph id="ph2">`stelem`</ph> instructions when used on reference type arrays.</source>
          <target state="translated">Observe que, normalmente, há uma verificação de tipo implícito para o <ph id="ph1">`ldelema`</ph> e <ph id="ph2">`stelem`</ph> instruções quando usado em referência matrizes de tipo.</target>       </trans-unit>
        <trans-unit id="3544" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Readonly">
          <source>There is never a run-time type check for value classes, so <ph id="ph1">`readonly`</ph> is a no-op in that case.</source>
          <target state="translated">Nunca há uma verificação de tipo de tempo de execução para classes de valor, portanto <ph id="ph1">`readonly`</ph> é não operacional nesse caso.</target>       </trans-unit>
        <trans-unit id="3545" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Readonly">
          <source>The verifier treats the result of the address-of operation as a managed pointer with restricted mutability.</source>
          <target state="translated">O verificador trata o resultado da operação de endereço como um ponteiro gerenciado com Mutabilidade restrita.</target>       </trans-unit>
        <trans-unit id="3546" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Readonly">
          <source>The pointer is said to have restricted mutability because the defining type controls whether the value can be mutated.</source>
          <target state="translated">O ponteiro deve ter restringido Mutabilidade porque a definição de tipo controla se o valor pode ser modificado.</target>       </trans-unit>
        <trans-unit id="3547" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Readonly">
          <source>For value classes that expose no public fields or methods that update the value in place, the pointer is read-only (hence the name of the prefix).</source>
          <target state="translated">Para classes de valor que expõem sem campos públicos ou métodos que atualizam o valor em vigor, o ponteiro é somente leitura (portanto, o nome do prefixo).</target>       </trans-unit>
        <trans-unit id="3548" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Readonly">
          <source>In particular, the classes representing primitive types (for example, System.Int32) do not expose mutators and thus are read-only.</source>
          <target state="translated">Em particular, as classes que representam tipos primitivos (por exemplo, System. Int32) não expõem modificadores e, portanto, são somente leitura.</target>       </trans-unit>
        <trans-unit id="3549" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Readonly">
          <source>A managed pointer restricted in this fashion can be used only in the following ways:</source>
          <target state="translated">Um ponteiro gerenciado restringido dessa maneira pode ser usado somente em das seguintes maneiras:</target>       </trans-unit>
        <trans-unit id="3550" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Readonly">
          <source>As the <ph id="ph1">`object`</ph> parameter for the <ph id="ph2">`ldfld`</ph>, <ph id="ph3">`ldflda`</ph>, <ph id="ph4">`stfld`</ph>, <ph id="ph5">`call`</ph>, or<ph id="ph6">`constrained callvirt`</ph> instructions.</source>
          <target state="translated">Como o <ph id="ph1">`object`</ph> parâmetro para o <ph id="ph2">`ldfld`</ph>, <ph id="ph3">`ldflda`</ph>, <ph id="ph4">`stfld`</ph>, <ph id="ph5">`call`</ph>, ou<ph id="ph6">`constrained callvirt`</ph> instruções.</target>       </trans-unit>
        <trans-unit id="3551" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Readonly">
          <source>As the <ph id="ph1">`pointer`</ph> parameter to the <ph id="ph2">`ldobj`</ph> instruction or to one of the <ph id="ph3">`ldind`</ph> instructions.</source>
          <target state="translated">Como o <ph id="ph1">`pointer`</ph> parâmetro para o <ph id="ph2">`ldobj`</ph> instrução ou a uma da <ph id="ph3">`ldind`</ph> instruções.</target>       </trans-unit>
        <trans-unit id="3552" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Readonly">
          <source>As the <ph id="ph1">`source`</ph> parameter to the <ph id="ph2">`cpobj`</ph> instruction.</source>
          <target state="translated">Como o <ph id="ph1">`source`</ph> parâmetro para o <ph id="ph2">`cpobj`</ph> instrução.</target>       </trans-unit>
        <trans-unit id="3553" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Readonly">
          <source>All other operations disallowed, including the <ph id="ph1">`stobj`</ph>, <ph id="ph2">`initobj`</ph>, or <ph id="ph3">`mkrefany`</ph> operations, or any of the <ph id="ph4">`stind`</ph> instructions.</source>
          <target state="translated">Todas as outras operações não permitidas, incluindo o <ph id="ph1">`stobj`</ph>, <ph id="ph2">`initobj`</ph>, ou <ph id="ph3">`mkrefany`</ph> operações ou qualquer o <ph id="ph4">`stind`</ph> instruções.</target>       </trans-unit>
        <trans-unit id="3554" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Readonly">
          <source>The purpose of the <ph id="ph1">`readonly`</ph> prefix is to avoid a type check when fetching an element from an array in generic code.</source>
          <target state="translated">A finalidade de <ph id="ph1">`readonly`</ph> prefixo é para evitar uma verificação de tipo ao buscar um elemento de uma matriz em código genérico.</target>       </trans-unit>
        <trans-unit id="3555" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Readonly">
          <source>For example, the expression <ph id="ph1">`arr[i].m()`</ph>, where the element type of the array <ph id="ph2">`arr`</ph> is a generic type that has been constrained to have an interface with method <ph id="ph3">`m`</ph>, might compile to the following MSIL.</source>
          <target state="translated">Por exemplo, a expressão <ph id="ph1">`arr[i].m()`</ph>, onde o tipo de elemento da matriz <ph id="ph2">`arr`</ph> é um tipo genérico foi restringido para que uma interface com o método <ph id="ph3">`m`</ph>, pode compilar a seguir MSIL.</target>       </trans-unit>
        <trans-unit id="3556" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Readonly">
          <source>Without the <ph id="ph1">`readonly`</ph> prefix, the <ph id="ph2">`ldelema`</ph> instruction would perform a type check in the case where !0 was a reference type.</source>
          <target state="translated">Sem o <ph id="ph1">`readonly`</ph> prefixo, o <ph id="ph2">`ldelema`</ph> instrução executará uma verificação de tipo no caso onde! 0 era de um tipo de referência.</target>       </trans-unit>
        <trans-unit id="3557" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Readonly">
          <source>Not only is this type check inefficient, but it is semantically incorrect.</source>
          <target state="translated">Não só é essa verificação de tipo ineficientes, mas é semanticamente incorreto.</target>       </trans-unit>
        <trans-unit id="3558" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Readonly">
          <source>The type check for <ph id="ph1">`ldelema`</ph> is an exact match, which is too strong.</source>
          <target state="translated">A verificação de tipo para <ph id="ph1">`ldelema`</ph> é uma correspondência exata, que é muito forte.</target>       </trans-unit>
        <trans-unit id="3559" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Readonly">
          <source>If the array held subclasses of type !0, the code above would fail the type check.</source>
          <target state="translated">Se a matriz mantidos subclasses de tipo! 0, o código acima falhará na verificação de tipo.</target>       </trans-unit>
        <trans-unit id="3560" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Readonly">
          <source>The address of the array element is fetched, instead of the element itself, in order to have a handle for <ph id="ph1">`arr[i]`</ph> that works for both value types and reference types, and thus can be passed to the <ph id="ph2">`constrained callvirt`</ph> instruction.</source>
          <target state="translated">O endereço do elemento da matriz é buscado, em vez do elemento em si, para ter um identificador para o <ph id="ph1">`arr[i]`</ph> que funciona para ambos os tipos de valor e tipos de referência e, portanto, pode ser passada para o <ph id="ph2">`constrained callvirt`</ph> instrução.</target>       </trans-unit>
        <trans-unit id="3561" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Readonly">
          <source>In general it would be unsafe to skip the run-time check if the array held elements of a reference type.</source>
          <target state="translated">Em geral seria inseguro para ignorar a verificação de tempo de execução se a matriz de elementos de um tipo de referência.</target>       </trans-unit>
        <trans-unit id="3562" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Readonly">
          <source>To be safe, it is necessary to ensure that no modifications to the array are made through this pointer.</source>
          <target state="translated">Para ter segurança, é necessário garantir que nenhuma modificação para a matriz é feitas por este ponteiro.</target>       </trans-unit>
        <trans-unit id="3563" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Readonly">
          <source>The verifier rules ensure this.</source>
          <target state="translated">As regras de verificação garantem isso.</target>       </trans-unit>
        <trans-unit id="3564" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Readonly">
          <source>The restricted managed pointer can be passed as the object of instance method calls, so it is not strictly speaking read-only for value types, but there is no type safety problem for value types.</source>
          <target state="translated">O ponteiro gerenciado restrito pode ser passado como o objeto de chamadas de método de instância, portanto ele não é estritamente somente leitura para tipos de valor, mas não há nenhum problema de segurança de tipo para tipos de valor.</target>       </trans-unit>
        <trans-unit id="3565" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Readonly">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`readonly`</ph> opcode:</source>
          <target state="translated">O seguinte <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> sobrecarga de método pode usar o <ph id="ph2">`readonly`</ph> opcode:</target>       </trans-unit>
        <trans-unit id="3566" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Readonly">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="3567" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Refanytype">
          <source>Retrieves the type token embedded in a typed reference.</source>
          <target state="translated">Recupera o token de tipo inserido em uma referência tipada.</target>       </trans-unit>
        <trans-unit id="3568" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Refanytype">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">A tabela a seguir lista as instruções hexadecimal e formato de assembly do Microsoft Intermediate Language (MSIL), junto com um resumo breve de referência:</target>       </trans-unit>
        <trans-unit id="3569" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Refanytype">
          <source>Format</source>
          <target state="translated">Formatar</target>       </trans-unit>
        <trans-unit id="3570" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Refanytype">
          <source>Assembly Format</source>
          <target state="translated">Formato de assembly</target>       </trans-unit>
        <trans-unit id="3571" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Refanytype">
          <source>Description</source>
          <target state="translated">Descrição</target>       </trans-unit>
        <trans-unit id="3572" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Refanytype">
          <source>FE 1D</source>
          <target state="translated">FE 1D</target>       </trans-unit>
        <trans-unit id="3573" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Refanytype">
          <source>refanytype</source>
          <target state="translated">refanytype</target>       </trans-unit>
        <trans-unit id="3574" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Refanytype">
          <source>Pushes the type token stored in a typed reference.</source>
          <target state="translated">Envia o token de tipo armazenado em uma referência de tipo.</target>       </trans-unit>
        <trans-unit id="3575" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Refanytype">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">O comportamento de transição de pilha, em ordem sequencial, é:</target>       </trans-unit>
        <trans-unit id="3576" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Refanytype">
          <source>A value type reference is pushed onto the stack.</source>
          <target state="translated">Uma referência de tipo de valor é inserida na pilha.</target>       </trans-unit>
        <trans-unit id="3577" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Refanytype">
          <source>The typed reference is popped from the stack and its corresponding type token retrieved.</source>
          <target state="translated">A referência de tipo é exibida da pilha e recuperado de seu token de tipo correspondente.</target>       </trans-unit>
        <trans-unit id="3578" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Refanytype">
          <source>The type token is pushed onto the stack.</source>
          <target state="translated">O token de tipo é inserido na pilha.</target>       </trans-unit>
        <trans-unit id="3579" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Refanytype">
          <source>A typed reference contains a type token and an address to an object instance.</source>
          <target state="translated">Uma referência de tipo contém um token de tipo e um endereço para uma instância do objeto.</target>       </trans-unit>
        <trans-unit id="3580" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Refanytype">
          <source>The <ph id="ph1">`refanytype`</ph> instruction retrieves the type token embedded in the typed reference.</source>
          <target state="translated">O <ph id="ph1">`refanytype`</ph> instrução recupera o token de tipo incorporado na referência de tipo.</target>       </trans-unit>
        <trans-unit id="3581" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Refanytype">
          <source>See the <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Mkrefany&gt;</ph> instruction for information on creating typed references.</source>
          <target state="translated">Consulte o <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Mkrefany&gt;</ph> referências de tipo de instrução para obter informações sobre a criação.</target>       </trans-unit>
        <trans-unit id="3582" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Refanytype">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`refanytype`</ph> opcode:</source>
          <target state="translated">O seguinte <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> sobrecarga de método pode usar o <ph id="ph2">`refanytype`</ph> opcode:</target>       </trans-unit>
        <trans-unit id="3583" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Refanytype">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="3584" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Refanyval">
          <source>Retrieves the address (type <ph id="ph1">&lt;see langword="&amp;amp;" /&gt;</ph>) embedded in a typed reference.</source>
          <target state="translated">Recupera o endereço (tipo <ph id="ph1">&lt;see langword="&amp;amp;" /&gt;</ph>) inserido em uma referência tipada.</target>       </trans-unit>
        <trans-unit id="3585" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Refanyval">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">A tabela a seguir lista as instruções hexadecimal e formato de assembly do Microsoft Intermediate Language (MSIL), junto com um resumo breve de referência:</target>       </trans-unit>
        <trans-unit id="3586" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Refanyval">
          <source>Format</source>
          <target state="translated">Formatar</target>       </trans-unit>
        <trans-unit id="3587" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Refanyval">
          <source>Assembly Format</source>
          <target state="translated">Formato de assembly</target>       </trans-unit>
        <trans-unit id="3588" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Refanyval">
          <source>Description</source>
          <target state="translated">Descrição</target>       </trans-unit>
        <trans-unit id="3589" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Refanyval">
          <source>C2 &lt; <ph id="ph1">`T`</ph><ph id="ph2"> &gt;</ph></source>
          <target state="translated">C2 &lt; <ph id="ph1">`T`</ph><ph id="ph2"> &gt;</ph></target>       </trans-unit>
        <trans-unit id="3590" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Refanyval">
          <source>refanyval <ph id="ph1">`type`</ph></source>
          <target state="translated">refanyval <ph id="ph1">`type`</ph></target>       </trans-unit>
        <trans-unit id="3591" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Refanyval">
          <source>Pushes the address stored in a typed reference.</source>
          <target state="translated">Envia o endereço armazenado em uma referência de tipo.</target>       </trans-unit>
        <trans-unit id="3592" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Refanyval">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">O comportamento de transição de pilha, em ordem sequencial, é:</target>       </trans-unit>
        <trans-unit id="3593" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Refanyval">
          <source>A value type reference is pushed onto the stack.</source>
          <target state="translated">Uma referência de tipo de valor é inserida na pilha.</target>       </trans-unit>
        <trans-unit id="3594" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Refanyval">
          <source>The typed reference is popped from the stack and the corresponding address retrieved.</source>
          <target state="translated">A referência de tipo é exibida da pilha e recuperar o endereço correspondente.</target>       </trans-unit>
        <trans-unit id="3595" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Refanyval">
          <source>The address is pushed onto the stack.</source>
          <target state="translated">O endereço é inserido na pilha.</target>       </trans-unit>
        <trans-unit id="3596" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Refanyval">
          <source>A typed reference contains a type token and an address to an object instance.</source>
          <target state="translated">Uma referência de tipo contém um token de tipo e um endereço para uma instância do objeto.</target>       </trans-unit>
        <trans-unit id="3597" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Refanyval">
          <source>The <ph id="ph1">`refanyval`</ph> instruction retrieves the address embedded in the a typed reference.</source>
          <target state="translated">O <ph id="ph1">`refanyval`</ph> instrução recupera o endereço inserido na uma referência de tipo.</target>       </trans-unit>
        <trans-unit id="3598" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Refanyval">
          <source>The type embedded in the typed reference supplied on the stack must match the type specified by <ph id="ph1">`type`</ph> (a metadata token, either a <ph id="ph2">`typedef`</ph> or a <ph id="ph3">`typeref`</ph>).</source>
          <target state="translated">O tipo inserido na referência do tipo fornecida na pilha deve corresponder ao tipo especificado pelo <ph id="ph1">`type`</ph> (token de metadados, ou um <ph id="ph2">`typedef`</ph> ou <ph id="ph3">`typeref`</ph>).</target>       </trans-unit>
        <trans-unit id="3599" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Refanyval">
          <source>See the <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Mkrefany&gt;</ph> instruction for related content.</source>
          <target state="translated">Consulte o <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Mkrefany&gt;</ph> a instrução para o conteúdo relacionado.</target>       </trans-unit>
        <trans-unit id="3600" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Refanyval">
          <source><ph id="ph1">&lt;xref:System.InvalidCastException&gt;</ph> is thrown if <ph id="ph2">`type`</ph> is not identical to the type stored in the type reference (in this case, <ph id="ph3">`type`</ph> is the class supplied to the <ph id="ph4">&lt;xref:System.Reflection.Emit.OpCodes.Mkrefany&gt;</ph> instruction that constructed said typed reference).</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.InvalidCastException&gt;</ph> será gerada se <ph id="ph2">`type`</ph> não é idêntico para o tipo armazenado na referência de tipo (nesse caso, <ph id="ph3">`type`</ph> a classe que é fornecida para o <ph id="ph4">&lt;xref:System.Reflection.Emit.OpCodes.Mkrefany&gt;</ph> instrução construído disse referência de tipo).</target>       </trans-unit>
        <trans-unit id="3601" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Refanyval">
          <source><ph id="ph1">&lt;xref:System.TypeLoadException&gt;</ph> is thrown if <ph id="ph2">`type`</ph> cannot be found.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.TypeLoadException&gt;</ph> será gerada se <ph id="ph2">`type`</ph> não pode ser encontrado.</target>       </trans-unit>
        <trans-unit id="3602" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Refanyval">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`refanyval`</ph> opcode:</source>
          <target state="translated">O seguinte <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> sobrecarga de método pode usar o <ph id="ph2">`refanyval`</ph> opcode:</target>       </trans-unit>
        <trans-unit id="3603" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Refanyval">
          <source>ILGenerator.Emit(OpCode, Type)</source>
          <target state="translated">ILGenerator.Emit(OpCode, Type)</target>       </trans-unit>
        <trans-unit id="3604" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Rem">
          <source>Divides two values and pushes the remainder onto the evaluation stack.</source>
          <target state="translated">Divide dois valores e efetua o push do restante para a pilha de avaliação.</target>       </trans-unit>
        <trans-unit id="3605" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Rem">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">A tabela a seguir lista as instruções hexadecimal e formato de assembly do Microsoft Intermediate Language (MSIL), junto com um resumo breve de referência:</target>       </trans-unit>
        <trans-unit id="3606" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Rem">
          <source>Format</source>
          <target state="translated">Formatar</target>       </trans-unit>
        <trans-unit id="3607" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Rem">
          <source>Assembly Format</source>
          <target state="translated">Formato de assembly</target>       </trans-unit>
        <trans-unit id="3608" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Rem">
          <source>Description</source>
          <target state="translated">Descrição</target>       </trans-unit>
        <trans-unit id="3609" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Rem">
          <source>5D</source>
          <target state="translated">5D</target>       </trans-unit>
        <trans-unit id="3610" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Rem">
          <source>rem</source>
          <target state="translated">REM</target>       </trans-unit>
        <trans-unit id="3611" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Rem">
          <source>Pushes the remainder of dividing <ph id="ph1">`value1`</ph> by <ph id="ph2">`value2`</ph> onto the stack.</source>
          <target state="translated">Envia o resto da divisão <ph id="ph1">`value1`</ph> por <ph id="ph2">`value2`</ph> na pilha.</target>       </trans-unit>
        <trans-unit id="3612" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Rem">
          <source>ReplaceThisText</source>
          <target state="translated">ReplaceThisText</target>       </trans-unit>
        <trans-unit id="3613" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Rem">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">O comportamento de transição de pilha, em ordem sequencial, é:</target>       </trans-unit>
        <trans-unit id="3614" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Rem">
          <source>A <ph id="ph1">`value1`</ph> is pushed onto the stack.</source>
          <target state="translated">Um <ph id="ph1">`value1`</ph> é inserido na pilha.</target>       </trans-unit>
        <trans-unit id="3615" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Rem">
          <source><ph id="ph1">`value2`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value2`</ph> é inserido na pilha.</target>       </trans-unit>
        <trans-unit id="3616" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Rem">
          <source><ph id="ph1">`value2`</ph> and <ph id="ph2">`value1`</ph> are popped from the stack and the remainder of <ph id="ph3">`value1`</ph> <ph id="ph4">`div`</ph> <ph id="ph5">`value2`</ph> computed.</source>
          <target state="translated"><ph id="ph1">`value2`</ph> e <ph id="ph2">`value1`</ph> são disparados de pilha e o restante do <ph id="ph3">`value1`</ph> <ph id="ph4">`div`</ph> <ph id="ph5">`value2`</ph> computada.</target>       </trans-unit>
        <trans-unit id="3617" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Rem">
          <source>The result is pushed onto the stack.</source>
          <target state="translated">O resultado é inserido na pilha.</target>       </trans-unit>
        <trans-unit id="3618" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Rem">
          <source><ph id="ph1">`result`</ph><ph id="ph2"> = </ph><ph id="ph3">`value1`</ph> <ph id="ph4">`rem`</ph> <ph id="ph5">`value2`</ph> satisfies the following conditions:</source>
          <target state="translated"><ph id="ph1">`result`</ph><ph id="ph2"> = </ph><ph id="ph3">`value1`</ph> <ph id="ph4">`rem`</ph> <ph id="ph5">`value2`</ph> satisfaz as condições a seguir:</target>       </trans-unit>
        <trans-unit id="3619" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Rem">
          <source><ph id="ph1">`result`</ph><ph id="ph2"> = </ph><ph id="ph3">`value1`</ph><ph id="ph4"> - </ph><ph id="ph5">`value2`</ph> <ph id="ph6">`×`</ph> (<ph id="ph7">`value1`</ph> <ph id="ph8">`div`</ph> <ph id="ph9">`value2`</ph>), and:</source>
          <target state="translated"><ph id="ph1">`result`</ph><ph id="ph2"> = </ph><ph id="ph3">`value1`</ph><ph id="ph4"> - </ph><ph id="ph5">`value2`</ph> <ph id="ph6">`×`</ph> (<ph id="ph7">`value1`</ph> <ph id="ph8">`div`</ph> <ph id="ph9">`value2`</ph>), e:</target>       </trans-unit>
        <trans-unit id="3620" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Rem">
          <source>0 = &amp;#124; <ph id="ph1">`result`</ph> &amp;#124; &lt; &amp;#124; <ph id="ph2">`value2`</ph> &amp;#124;, sign(<ph id="ph3">`result`</ph>) = sign(<ph id="ph4">`value1`</ph>), where <ph id="ph5">`div`</ph> is the division instruction that truncates towards zero.</source>
          <target state="translated">0 = &amp;#124; <ph id="ph1">`result`</ph> &amp;#124; &lt; &amp;#124; <ph id="ph2">`value2`</ph> &amp;#124;, sinal (<ph id="ph3">`result`</ph>) = sinal (<ph id="ph4">`value1`</ph>), onde <ph id="ph5">`div`</ph> é a instrução de divisão que trunca em direção a zero.</target>       </trans-unit>
        <trans-unit id="3621" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Rem">
          <source>If <ph id="ph1">`value2`</ph> is zero or <ph id="ph2">`value1`</ph> is infinity the result is NaN.</source>
          <target state="translated">Se <ph id="ph1">`value2`</ph> for zero ou <ph id="ph2">`value1`</ph> é infinito, o resultado é NaN.</target>       </trans-unit>
        <trans-unit id="3622" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Rem">
          <source>If <ph id="ph1">`value2`</ph> is infinity, the result is <ph id="ph2">`value1`</ph> (negated for <ph id="ph3">`-infinity`</ph>).</source>
          <target state="translated">Se <ph id="ph1">`value2`</ph> é infinito, o resultado é <ph id="ph2">`value1`</ph> (negadas para <ph id="ph3">`-infinity`</ph>).</target>       </trans-unit>
        <trans-unit id="3623" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Rem">
          <source>Integral operations throw <ph id="ph1">&lt;xref:System.DivideByZeroException&gt;</ph> if <ph id="ph2">`value2`</ph> is zero.</source>
          <target state="translated">Operações integrais lançam <ph id="ph1">&lt;xref:System.DivideByZeroException&gt;</ph> se <ph id="ph2">`value2`</ph> é zero.</target>       </trans-unit>
        <trans-unit id="3624" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Rem">
          <source>Note that on the Intel-based platforms an <ph id="ph1">&lt;xref:System.OverflowException&gt;</ph> is thrown when computing (minint <ph id="ph2">`rem`</ph> -1).</source>
          <target state="translated">Observe que nas plataformas baseados no Intel um <ph id="ph1">&lt;xref:System.OverflowException&gt;</ph> é gerada quando a computação (minint <ph id="ph2">`rem`</ph> -1).</target>       </trans-unit>
        <trans-unit id="3625" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Rem">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`rem`</ph> opcode:</source>
          <target state="translated">O seguinte <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> sobrecarga de método pode usar o <ph id="ph2">`rem`</ph> opcode:</target>       </trans-unit>
        <trans-unit id="3626" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Rem">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="3627" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Rem_Un">
          <source>Divides two unsigned values and pushes the remainder onto the evaluation stack.</source>
          <target state="translated">Divide dois valores sem sinal e efetua o push do restante para a pilha de avaliação.</target>       </trans-unit>
        <trans-unit id="3628" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Rem_Un">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">A tabela a seguir lista as instruções hexadecimal e formato de assembly do Microsoft Intermediate Language (MSIL), junto com um resumo breve de referência:</target>       </trans-unit>
        <trans-unit id="3629" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Rem_Un">
          <source>Format</source>
          <target state="translated">Formatar</target>       </trans-unit>
        <trans-unit id="3630" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Rem_Un">
          <source>Assembly Format</source>
          <target state="translated">Formato de assembly</target>       </trans-unit>
        <trans-unit id="3631" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Rem_Un">
          <source>Description</source>
          <target state="translated">Descrição</target>       </trans-unit>
        <trans-unit id="3632" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Rem_Un">
          <source>5E</source>
          <target state="translated">5E</target>       </trans-unit>
        <trans-unit id="3633" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Rem_Un">
          <source>rem.un</source>
          <target state="translated">rem.un</target>       </trans-unit>
        <trans-unit id="3634" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Rem_Un">
          <source>Pushes the remainder of dividing unsigned <ph id="ph1">`value1`</ph> by unsigned <ph id="ph2">`value2`</ph> onto the stack.</source>
          <target state="translated">Envia o resto da divisão não assinados <ph id="ph1">`value1`</ph> por não assinados <ph id="ph2">`value2`</ph> na pilha.</target>       </trans-unit>
        <trans-unit id="3635" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Rem_Un">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">O comportamento de transição de pilha, em ordem sequencial, é:</target>       </trans-unit>
        <trans-unit id="3636" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Rem_Un">
          <source><ph id="ph1">`value1`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value1`</ph> é inserido na pilha.</target>       </trans-unit>
        <trans-unit id="3637" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Rem_Un">
          <source><ph id="ph1">`value2`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value2`</ph> é inserido na pilha.</target>       </trans-unit>
        <trans-unit id="3638" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Rem_Un">
          <source><ph id="ph1">`value2`</ph> and <ph id="ph2">`value1`</ph> are popped from the stack and the remainder of <ph id="ph3">`value1`</ph> <ph id="ph4">`div`</ph> <ph id="ph5">`value2`</ph> computed.</source>
          <target state="translated"><ph id="ph1">`value2`</ph> e <ph id="ph2">`value1`</ph> são disparados de pilha e o restante do <ph id="ph3">`value1`</ph> <ph id="ph4">`div`</ph> <ph id="ph5">`value2`</ph> computada.</target>       </trans-unit>
        <trans-unit id="3639" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Rem_Un">
          <source>The result is pushed onto the stack.</source>
          <target state="translated">O resultado é inserido na pilha.</target>       </trans-unit>
        <trans-unit id="3640" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Rem_Un">
          <source><ph id="ph1">`result`</ph><ph id="ph2"> = </ph><ph id="ph3">`value1`</ph> <ph id="ph4">`rem.un`</ph> <ph id="ph5">`value2`</ph> satisfies the following conditions:</source>
          <target state="translated"><ph id="ph1">`result`</ph><ph id="ph2"> = </ph><ph id="ph3">`value1`</ph> <ph id="ph4">`rem.un`</ph> <ph id="ph5">`value2`</ph> satisfaz as condições a seguir:</target>       </trans-unit>
        <trans-unit id="3641" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Rem_Un">
          <source><ph id="ph1">`result`</ph><ph id="ph2"> = </ph><ph id="ph3">`value1`</ph><ph id="ph4"> - </ph><ph id="ph5">`value2`</ph> x(<ph id="ph6">`value1`</ph> <ph id="ph7">`div.un`</ph> <ph id="ph8">`value2`</ph>), and:</source>
          <target state="translated"><ph id="ph1">`result`</ph><ph id="ph2"> = </ph><ph id="ph3">`value1`</ph><ph id="ph4"> - </ph><ph id="ph5">`value2`</ph> x (<ph id="ph6">`value1`</ph> <ph id="ph7">`div.un`</ph> <ph id="ph8">`value2`</ph>), e:</target>       </trans-unit>
        <trans-unit id="3642" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Rem_Un">
          <source>0 = <ph id="ph1">`result`</ph><ph id="ph2"> &lt; </ph><ph id="ph3">`value2`</ph>, where <ph id="ph4">`div.un`</ph> is the unsigned division instruction.</source>
          <target state="translated">0 = <ph id="ph1">`result`</ph> <ph id="ph2"> &lt; </ph> <ph id="ph3">`value2`</ph>, onde <ph id="ph4">`div.un`</ph> é a instrução de divisão não assinados.</target>       </trans-unit>
        <trans-unit id="3643" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Rem_Un">
          <source>The <ph id="ph1">`rem.un`</ph> instruction computes <ph id="ph2">`result`</ph> and pushes it on the stack.</source>
          <target state="translated">O <ph id="ph1">`rem.un`</ph> calcula a instrução <ph id="ph2">`result`</ph> e envia por push na pilha.</target>       </trans-unit>
        <trans-unit id="3644" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Rem_Un">
          <source><ph id="ph1">`Rem.un`</ph> treats its arguments as unsigned integers, while <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Rem&gt;</ph> treats them as signed integers.</source>
          <target state="translated"><ph id="ph1">`Rem.un`</ph> trata os argumentos como inteiros sem sinal, enquanto <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Rem&gt;</ph> trata assinados como inteiros.</target>       </trans-unit>
        <trans-unit id="3645" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Rem_Un">
          <source><ph id="ph1">`Rem.un`</ph> is unspecified for floating-point numbers.</source>
          <target state="translated"><ph id="ph1">`Rem.un`</ph> não é especificado para números de ponto flutuante.</target>       </trans-unit>
        <trans-unit id="3646" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Rem_Un">
          <source>Integral operations throw <ph id="ph1">&lt;xref:System.DivideByZeroException&gt;</ph> if <ph id="ph2">`value2`</ph> is zero.</source>
          <target state="translated">Operações integrais lançam <ph id="ph1">&lt;xref:System.DivideByZeroException&gt;</ph> se <ph id="ph2">`value2`</ph> é zero.</target>       </trans-unit>
        <trans-unit id="3647" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Rem_Un">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`rem.un`</ph> opcode:</source>
          <target state="translated">O seguinte <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> sobrecarga de método pode usar o <ph id="ph2">`rem.un`</ph> opcode:</target>       </trans-unit>
        <trans-unit id="3648" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Rem_Un">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="3649" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Ret">
          <source>Returns from the current method, pushing a return value (if present) from the callee's evaluation stack onto the caller's evaluation stack.</source>
          <target state="translated">Retorna do método atual, enviando um valor retornado (se houver) da pilha de avaliação do computador chamado para a pilha de avaliação do chamador.</target>       </trans-unit>
        <trans-unit id="3650" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ret">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">A tabela a seguir lista as instruções hexadecimal e formato de assembly do Microsoft Intermediate Language (MSIL), junto com um resumo breve de referência:</target>       </trans-unit>
        <trans-unit id="3651" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ret">
          <source>Format</source>
          <target state="translated">Formatar</target>       </trans-unit>
        <trans-unit id="3652" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ret">
          <source>Assembly Format</source>
          <target state="translated">Formato de assembly</target>       </trans-unit>
        <trans-unit id="3653" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ret">
          <source>Description</source>
          <target state="translated">Descrição</target>       </trans-unit>
        <trans-unit id="3654" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ret">
          <source>2A</source>
          <target state="translated">2A</target>       </trans-unit>
        <trans-unit id="3655" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ret">
          <source>ret</source>
          <target state="translated">RET</target>       </trans-unit>
        <trans-unit id="3656" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ret">
          <source>Returns from method, possibly returning a value.</source>
          <target state="translated">Retorna um método, possivelmente, retornando um valor.</target>       </trans-unit>
        <trans-unit id="3657" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ret">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">O comportamento de transição de pilha, em ordem sequencial, é:</target>       </trans-unit>
        <trans-unit id="3658" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ret">
          <source>The return value is popped from the callee evaluation stack.</source>
          <target state="translated">O valor de retorno é exibido da pilha de avaliação do receptor.</target>       </trans-unit>
        <trans-unit id="3659" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ret">
          <source>The return value obtained in step 1 is pushed onto the caller evaluation stack.</source>
          <target state="translated">O valor de retorno obtido na etapa 1 é enviado para a pilha de avaliação do chamador.</target>       </trans-unit>
        <trans-unit id="3660" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ret">
          <source>If the return value is not present on the callee evaluation stack, no value is returned (no stack transition behaviors for either the callee or caller method).</source>
          <target state="translated">Se o valor de retorno não está presente na pilha de avaliação de receptor, nenhum valor será retornado (nenhum comportamentos de transição de pilha para o chamador ou receptor de método).</target>       </trans-unit>
        <trans-unit id="3661" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ret">
          <source>The type of the return value, if any, of the current method determines the type of value to be fetched from the top of the stack and copied onto the stack of the method that called the current method.</source>
          <target state="translated">O tipo do valor de retorno, se houver, do método atual determina o tipo de valor a ser obtido da parte superior da pilha e copiado para a pilha do método que chamou o método atual.</target>       </trans-unit>
        <trans-unit id="3662" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ret">
          <source>The evaluation stack for the current method must be empty except for the value to be returned.</source>
          <target state="translated">A pilha de avaliação para o método atual deve ser vazia, exceto o valor a ser retornado.</target>       </trans-unit>
        <trans-unit id="3663" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ret">
          <source>The <ph id="ph1">`ret`</ph> instruction cannot be used to transfer control out of a<ph id="ph2">`try`</ph>, <ph id="ph3">`filter`</ph>, <ph id="ph4">`catch`</ph>, or <ph id="ph5">`finally`</ph> block.</source>
          <target state="translated">O <ph id="ph1">`ret`</ph> instrução não pode ser usada para transferir controle fora de um<ph id="ph2">`try`</ph>, <ph id="ph3">`filter`</ph>, <ph id="ph4">`catch`</ph>, ou <ph id="ph5">`finally`</ph> bloco.</target>       </trans-unit>
        <trans-unit id="3664" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ret">
          <source>From within a <ph id="ph1">`try`</ph> or <ph id="ph2">`catch`</ph>, use the <ph id="ph3">&lt;xref:System.Reflection.Emit.OpCodes.Leave&gt;</ph> instruction with a destination of a <ph id="ph4">`ret`</ph> instruction that is outside all enclosing exception blocks.</source>
          <target state="translated">De dentro uma <ph id="ph1">`try`</ph> ou <ph id="ph2">`catch`</ph>, use o <ph id="ph3">&lt;xref:System.Reflection.Emit.OpCodes.Leave&gt;</ph> instrução com um destino de um <ph id="ph4">`ret`</ph> instrução que está fora do delimitador de todos os blocos de exceção.</target>       </trans-unit>
        <trans-unit id="3665" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ret">
          <source>Because the <ph id="ph1">`filter`</ph> and <ph id="ph2">`finally`</ph> blocks are logically part of exception handling and not the method in which their code is embedded, correctly generated Microsoft Intermediate Language (MSIL) instructions do not perform a method return from within a <ph id="ph3">`filter`</ph> or <ph id="ph4">`finally`</ph>.</source>
          <target state="translated">Porque o <ph id="ph1">`filter`</ph> e <ph id="ph2">`finally`</ph> blocos logicamente fazem parte da manipulação de exceção e não o método no qual o código é inserido, instruções de linguagem intermediária da Microsoft (MSIL) corretamente geradas não executam um método de retorno de dentro de um <ph id="ph3">`filter`</ph> ou <ph id="ph4">`finally`</ph>.</target>       </trans-unit>
        <trans-unit id="3666" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ret">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`ret`</ph> opcode:</source>
          <target state="translated">O seguinte <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> sobrecarga de método pode usar o <ph id="ph2">`ret`</ph> opcode:</target>       </trans-unit>
        <trans-unit id="3667" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ret">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="3668" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Rethrow">
          <source>Rethrows the current exception.</source>
          <target state="translated">Gera novamente a exceção atual.</target>       </trans-unit>
        <trans-unit id="3669" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Rethrow">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">A tabela a seguir lista as instruções hexadecimal e formato de assembly do Microsoft Intermediate Language (MSIL), junto com um resumo breve de referência:</target>       </trans-unit>
        <trans-unit id="3670" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Rethrow">
          <source>Format</source>
          <target state="translated">Formatar</target>       </trans-unit>
        <trans-unit id="3671" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Rethrow">
          <source>Assembly Format</source>
          <target state="translated">Formato de assembly</target>       </trans-unit>
        <trans-unit id="3672" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Rethrow">
          <source>Description</source>
          <target state="translated">Descrição</target>       </trans-unit>
        <trans-unit id="3673" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Rethrow">
          <source>FE 1A</source>
          <target state="translated">FE 1A</target>       </trans-unit>
        <trans-unit id="3674" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Rethrow">
          <source>rethrow</source>
          <target state="translated">relançar</target>       </trans-unit>
        <trans-unit id="3675" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Rethrow">
          <source>Rethrows the current exception</source>
          <target state="translated">Lança novamente a exceção atual</target>       </trans-unit>
        <trans-unit id="3676" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Rethrow">
          <source>No stack transition behavior is defined for this instruction.</source>
          <target state="translated">Nenhum comportamento de transição de pilha é definido para essa instrução.</target>       </trans-unit>
        <trans-unit id="3677" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Rethrow">
          <source>The <ph id="ph1">`rethrow`</ph> instruction is only permitted within the body of a <ph id="ph2">`catch`</ph> handler.</source>
          <target state="translated">O <ph id="ph1">`rethrow`</ph> instrução só é permitida dentro do corpo de um <ph id="ph2">`catch`</ph> manipulador.</target>       </trans-unit>
        <trans-unit id="3678" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Rethrow">
          <source>It throws the same exception that was caught by this handler.</source>
          <target state="translated">Ele gera a mesma exceção foi detectada para este manipulador.</target>       </trans-unit>
        <trans-unit id="3679" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Rethrow">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`rethrow`</ph> opcode:</source>
          <target state="translated">O seguinte <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> sobrecarga de método pode usar o <ph id="ph2">`rethrow`</ph> opcode:</target>       </trans-unit>
        <trans-unit id="3680" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Rethrow">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="3681" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Shl">
          <source>Shifts an integer value to the left (in zeroes) by a specified number of bits, pushing the result onto the evaluation stack.</source>
          <target state="translated">Desloca um valor de inteiro para a esquerda (em zeros) por um número especificado de bits, efetuando o push do resultado para a pilha de avaliação.</target>       </trans-unit>
        <trans-unit id="3682" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Shl">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">A tabela a seguir lista as instruções hexadecimal e formato de assembly do Microsoft Intermediate Language (MSIL), junto com um resumo breve de referência:</target>       </trans-unit>
        <trans-unit id="3683" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Shl">
          <source>Format</source>
          <target state="translated">Formatar</target>       </trans-unit>
        <trans-unit id="3684" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Shl">
          <source>Assembly Format</source>
          <target state="translated">Formato de assembly</target>       </trans-unit>
        <trans-unit id="3685" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Shl">
          <source>Description</source>
          <target state="translated">Descrição</target>       </trans-unit>
        <trans-unit id="3686" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Shl">
          <source>62</source>
          <target state="translated">62</target>       </trans-unit>
        <trans-unit id="3687" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Shl">
          <source>shl</source>
          <target state="translated">Shl</target>       </trans-unit>
        <trans-unit id="3688" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Shl">
          <source>Shifts an integer to the left (shifting in zeros).</source>
          <target state="translated">Desloca um número inteiro para a esquerda (deslocamento em zeros).</target>       </trans-unit>
        <trans-unit id="3689" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Shl">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">O comportamento de transição de pilha, em ordem sequencial, é:</target>       </trans-unit>
        <trans-unit id="3690" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Shl">
          <source>A value is pushed onto the stack.</source>
          <target state="translated">Um valor é inserido na pilha.</target>       </trans-unit>
        <trans-unit id="3691" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Shl">
          <source>The amount of bits to be shifted is pushed onto the stack.</source>
          <target state="translated">A quantidade de bits a ser deslocado é inserida na pilha.</target>       </trans-unit>
        <trans-unit id="3692" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Shl">
          <source>The number of bits to be shifted and the value are popped from the stack; the value is shifted left by the specified number of bits.</source>
          <target state="translated">O número de bits a ser deslocado e o valor são disparados da pilha; o valor é deslocado à esquerda pelo número especificado de bits.</target>       </trans-unit>
        <trans-unit id="3693" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Shl">
          <source>The result is pushed onto the stack.</source>
          <target state="translated">O resultado é inserido na pilha.</target>       </trans-unit>
        <trans-unit id="3694" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Shl">
          <source>The <ph id="ph1">`shl`</ph> instruction shifts the value (type <ph id="ph2">`int32`</ph>, <ph id="ph3">`int64`</ph> or <ph id="ph4">`native int`</ph>) left by the specified number of bits.</source>
          <target state="translated">O <ph id="ph1">`shl`</ph> instrução desloca o valor (tipo <ph id="ph2">`int32`</ph>, <ph id="ph3">`int64`</ph> ou <ph id="ph4">`native int`</ph>) à esquerda pelo número especificado de bits.</target>       </trans-unit>
        <trans-unit id="3695" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Shl">
          <source>The number of bits is a value of type <ph id="ph1">`int32`</ph> or <ph id="ph2">`native int`</ph>.</source>
          <target state="translated">O número de bits é um valor do tipo <ph id="ph1">`int32`</ph> ou <ph id="ph2">`native int`</ph>.</target>       </trans-unit>
        <trans-unit id="3696" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Shl">
          <source>The return value is unspecified if the number of bits to be shifted is greater than or equal to the width (in bits) of the supplied value.</source>
          <target state="translated">O valor de retorno não for especificado, se o número de bits de deslocamento é maior que ou igual à largura (em bits) do valor fornecido.</target>       </trans-unit>
        <trans-unit id="3697" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Shl">
          <source><ph id="ph1">`Shl`</ph> inserts a zero bit in the lowest position on each shift.</source>
          <target state="translated"><ph id="ph1">`Shl`</ph> Insere um bit zero na posição mais baixa em cada turno.</target>       </trans-unit>
        <trans-unit id="3698" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Shl">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`shl`</ph> opcode:</source>
          <target state="translated">O seguinte <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> sobrecarga de método pode usar o <ph id="ph2">`shl`</ph> opcode:</target>       </trans-unit>
        <trans-unit id="3699" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Shl">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="3700" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Shr">
          <source>Shifts an integer value (in sign) to the right by a specified number of bits, pushing the result onto the evaluation stack.</source>
          <target state="translated">Desloca um valor de inteiro (no logon) para a direita em um número especificado de bits, efetuando o push do resultado para a pilha de avaliação.</target>       </trans-unit>
        <trans-unit id="3701" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Shr">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">A tabela a seguir lista as instruções hexadecimal e formato de assembly do Microsoft Intermediate Language (MSIL), junto com um resumo breve de referência:</target>       </trans-unit>
        <trans-unit id="3702" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Shr">
          <source>Format</source>
          <target state="translated">Formatar</target>       </trans-unit>
        <trans-unit id="3703" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Shr">
          <source>Assembly Format</source>
          <target state="translated">Formato de assembly</target>       </trans-unit>
        <trans-unit id="3704" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Shr">
          <source>Description</source>
          <target state="translated">Descrição</target>       </trans-unit>
        <trans-unit id="3705" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Shr">
          <source>63</source>
          <target state="translated">63</target>       </trans-unit>
        <trans-unit id="3706" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Shr">
          <source>shr</source>
          <target state="translated">SHR</target>       </trans-unit>
        <trans-unit id="3707" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Shr">
          <source>Shifts an integer to the right (shifting in sign).</source>
          <target state="translated">Desloca um número inteiro para a direita (deslocado no logon).</target>       </trans-unit>
        <trans-unit id="3708" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Shr">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">O comportamento de transição de pilha, em ordem sequencial, é:</target>       </trans-unit>
        <trans-unit id="3709" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Shr">
          <source>A value is pushed onto the stack.</source>
          <target state="translated">Um valor é inserido na pilha.</target>       </trans-unit>
        <trans-unit id="3710" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Shr">
          <source>The amount of bits to be shifted is pushed onto the stack.</source>
          <target state="translated">A quantidade de bits a ser deslocado é inserida na pilha.</target>       </trans-unit>
        <trans-unit id="3711" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Shr">
          <source>The number of bits to be shifted and the value are popped from the stack; the value is shifted right by the specified number of bits.</source>
          <target state="translated">O número de bits a ser deslocado e o valor são disparados da pilha; o valor é deslocado à direita pelo número especificado de bits.</target>       </trans-unit>
        <trans-unit id="3712" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Shr">
          <source>The result is pushed onto the stack.</source>
          <target state="translated">O resultado é inserido na pilha.</target>       </trans-unit>
        <trans-unit id="3713" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Shr">
          <source>The <ph id="ph1">`shr.un`</ph> instruction shifts the value (type <ph id="ph2">`int32`</ph>, <ph id="ph3">`int64`</ph> or <ph id="ph4">`native int`</ph>) right by the specified number of bits.</source>
          <target state="translated">O <ph id="ph1">`shr.un`</ph> instrução desloca o valor (tipo <ph id="ph2">`int32`</ph>, <ph id="ph3">`int64`</ph> ou <ph id="ph4">`native int`</ph>) à direita pelo número especificado de bits.</target>       </trans-unit>
        <trans-unit id="3714" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Shr">
          <source>The number of bits is a value of type <ph id="ph1">`int32`</ph> or <ph id="ph2">`native int`</ph>.</source>
          <target state="translated">O número de bits é um valor do tipo <ph id="ph1">`int32`</ph> ou <ph id="ph2">`native int`</ph>.</target>       </trans-unit>
        <trans-unit id="3715" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Shr">
          <source>The return value is unspecified if the number of bits to be shifted is greater than or equal to the width (in bits) of the supplied value.</source>
          <target state="translated">O valor de retorno não for especificado, se o número de bits de deslocamento é maior que ou igual à largura (em bits) do valor fornecido.</target>       </trans-unit>
        <trans-unit id="3716" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Shr">
          <source><ph id="ph1">`Shr`</ph> replicates the high order bit on each shift, preserving the sign of the original value in the <ph id="ph2">`result`</ph>.</source>
          <target state="translated"><ph id="ph1">`Shr`</ph> replica a ordem de alto bit em cada turno, preservando o sinal do valor original no <ph id="ph2">`result`</ph>.</target>       </trans-unit>
        <trans-unit id="3717" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Shr">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`shr`</ph> opcode:</source>
          <target state="translated">O seguinte <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> sobrecarga de método pode usar o <ph id="ph2">`shr`</ph> opcode:</target>       </trans-unit>
        <trans-unit id="3718" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Shr">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="3719" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Shr_Un">
          <source>Shifts an unsigned integer value (in zeroes) to the right by a specified number of bits, pushing the result onto the evaluation stack.</source>
          <target state="translated">Desloca um valor inteiro sem sinal (em zeros) para a direita em um número especificado de bits, efetuando o push do resultado para a pilha de avaliação.</target>       </trans-unit>
        <trans-unit id="3720" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Shr_Un">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">A tabela a seguir lista as instruções hexadecimal e formato de assembly do Microsoft Intermediate Language (MSIL), junto com um resumo breve de referência:</target>       </trans-unit>
        <trans-unit id="3721" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Shr_Un">
          <source>Format</source>
          <target state="translated">Formatar</target>       </trans-unit>
        <trans-unit id="3722" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Shr_Un">
          <source>Assembly Format</source>
          <target state="translated">Formato de assembly</target>       </trans-unit>
        <trans-unit id="3723" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Shr_Un">
          <source>Description</source>
          <target state="translated">Descrição</target>       </trans-unit>
        <trans-unit id="3724" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Shr_Un">
          <source>64</source>
          <target state="translated">64</target>       </trans-unit>
        <trans-unit id="3725" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Shr_Un">
          <source>shr.un</source>
          <target state="translated">shr.un</target>       </trans-unit>
        <trans-unit id="3726" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Shr_Un">
          <source>Shifts an integer to the right (shifting in zeroes).</source>
          <target state="translated">Desloca um número inteiro para a direita (deslocamento em zeros).</target>       </trans-unit>
        <trans-unit id="3727" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Shr_Un">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">O comportamento de transição de pilha, em ordem sequencial, é:</target>       </trans-unit>
        <trans-unit id="3728" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Shr_Un">
          <source>A value is pushed onto the stack.</source>
          <target state="translated">Um valor é inserido na pilha.</target>       </trans-unit>
        <trans-unit id="3729" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Shr_Un">
          <source>The amount of bits to be shifted is pushed onto the stack.</source>
          <target state="translated">A quantidade de bits a ser deslocado é inserida na pilha.</target>       </trans-unit>
        <trans-unit id="3730" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Shr_Un">
          <source>The number of bits to be shifted and the value are popped from the stack; the value is shifted right by the specified number of bits.</source>
          <target state="translated">O número de bits a ser deslocado e o valor são disparados da pilha; o valor é deslocado à direita pelo número especificado de bits.</target>       </trans-unit>
        <trans-unit id="3731" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Shr_Un">
          <source>The result is pushed onto the stack.</source>
          <target state="translated">O resultado é inserido na pilha.</target>       </trans-unit>
        <trans-unit id="3732" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Shr_Un">
          <source>The <ph id="ph1">`shr.un`</ph> instruction shifts the value (type <ph id="ph2">`int32`</ph>, <ph id="ph3">`int64`</ph> or <ph id="ph4">`native int`</ph>) right by the specified number of bits.</source>
          <target state="translated">O <ph id="ph1">`shr.un`</ph> instrução desloca o valor (tipo <ph id="ph2">`int32`</ph>, <ph id="ph3">`int64`</ph> ou <ph id="ph4">`native int`</ph>) à direita pelo número especificado de bits.</target>       </trans-unit>
        <trans-unit id="3733" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Shr_Un">
          <source>The number of bits is a value of type <ph id="ph1">`int32`</ph>, <ph id="ph2">`int64`</ph> or <ph id="ph3">`native int`</ph>.</source>
          <target state="translated">O número de bits é um valor do tipo <ph id="ph1">`int32`</ph>, <ph id="ph2">`int64`</ph> ou <ph id="ph3">`native int`</ph>.</target>       </trans-unit>
        <trans-unit id="3734" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Shr_Un">
          <source>The return value is unspecified if the number of bits to be shifted is greater than or equal to the width (in bits) of the supplied value.</source>
          <target state="translated">O valor de retorno não for especificado, se o número de bits de deslocamento é maior que ou igual à largura (em bits) do valor fornecido.</target>       </trans-unit>
        <trans-unit id="3735" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Shr_Un">
          <source><ph id="ph1">`Shr.un`</ph> inserts a zero bit in the highest position on each shift.</source>
          <target state="translated"><ph id="ph1">`Shr.un`</ph> Insere um bit zero na posição mais alta em cada turno.</target>       </trans-unit>
        <trans-unit id="3736" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Shr_Un">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`shr.un`</ph> opcode:</source>
          <target state="translated">O seguinte <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> sobrecarga de método pode usar o <ph id="ph2">`shr.un`</ph> opcode:</target>       </trans-unit>
        <trans-unit id="3737" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Shr_Un">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="3738" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Sizeof">
          <source>Pushes the size, in bytes, of a supplied value type onto the evaluation stack.</source>
          <target state="translated">Envia o tamanho, em bytes, de um tipo de valor fornecido para a pilha de avaliação.</target>       </trans-unit>
        <trans-unit id="3739" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Sizeof">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">A tabela a seguir lista as instruções hexadecimal e formato de assembly do Microsoft Intermediate Language (MSIL), junto com um resumo breve de referência:</target>       </trans-unit>
        <trans-unit id="3740" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Sizeof">
          <source>Format</source>
          <target state="translated">Formatar</target>       </trans-unit>
        <trans-unit id="3741" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Sizeof">
          <source>Assembly Format</source>
          <target state="translated">Formato de assembly</target>       </trans-unit>
        <trans-unit id="3742" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Sizeof">
          <source>Description</source>
          <target state="translated">Descrição</target>       </trans-unit>
        <trans-unit id="3743" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Sizeof">
          <source>FE 1C &lt; <ph id="ph1">`T`</ph><ph id="ph2"> &gt;</ph></source>
          <target state="translated">FE 1C &amp;LT; <ph id="ph1">`T`</ph><ph id="ph2"> &gt;</ph></target>       </trans-unit>
        <trans-unit id="3744" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Sizeof">
          <source>sizeof <ph id="ph1">`valType`</ph></source>
          <target state="translated">sizeof <ph id="ph1">`valType`</ph></target>       </trans-unit>
        <trans-unit id="3745" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Sizeof">
          <source>Push the size, in bytes, of a value type as an <ph id="ph1">`unsigned int32`</ph>.</source>
          <target state="translated">Enviar por push o tamanho, em bytes, de um tipo de valor como um <ph id="ph1">`unsigned int32`</ph>.</target>       </trans-unit>
        <trans-unit id="3746" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Sizeof">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">O comportamento de transição de pilha, em ordem sequencial, é:</target>       </trans-unit>
        <trans-unit id="3747" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Sizeof">
          <source>The size (in bytes) of the supplied value type (<ph id="ph1">`valType`</ph>) is pushed onto the stack.</source>
          <target state="translated">O tamanho (em bytes) do tipo de valor fornecido (<ph id="ph1">`valType`</ph>) é inserido na pilha.</target>       </trans-unit>
        <trans-unit id="3748" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Sizeof">
          <source><ph id="ph1">`valType`</ph> must be a metadata token (a <ph id="ph2">`typeref`</ph> or <ph id="ph3">`typedef`</ph>) that specifies a value type, reference type, or generic type parameter.</source>
          <target state="translated"><ph id="ph1">`valType`</ph> deve ser um token de metadados (uma <ph id="ph2">`typeref`</ph> ou <ph id="ph3">`typedef`</ph>) que especifica um tipo de valor, o tipo de referência ou o parâmetro de tipo genérico.</target>       </trans-unit>
        <trans-unit id="3749" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Sizeof">
          <source>For a reference type, the size returned is the size of a reference value of the corresponding type (4 bytes on 32-bit systems), not the size of the data stored in objects referred to by the reference value.</source>
          <target state="translated">Para um tipo de referência, o tamanho retornado é o tamanho de um valor de referência do tipo (4 bytes em sistemas de 32 bits), não o tamanho dos dados armazenados em objetos referenciados pelo valor de referência.</target>       </trans-unit>
        <trans-unit id="3750" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Sizeof">
          <source>A generic type parameter can be used only in the body of the type or method that defines it.</source>
          <target state="translated">Um parâmetro de tipo genérico pode ser usado apenas no corpo do tipo ou método que o define.</target>       </trans-unit>
        <trans-unit id="3751" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Sizeof">
          <source>When that type or method is instantiated, the generic type parameter is replaced by a value type or reference type.</source>
          <target state="translated">Quando o tipo ou método é instanciado, o parâmetro de tipo genérico é substituído por um tipo de valor ou tipo de referência.</target>       </trans-unit>
        <trans-unit id="3752" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Sizeof">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`sizeof`</ph> opcode:</source>
          <target state="translated">O seguinte <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> sobrecarga de método pode usar o <ph id="ph2">`sizeof`</ph> opcode:</target>       </trans-unit>
        <trans-unit id="3753" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Sizeof">
          <source>ILGenerator.Emit(OpCode, Type)</source>
          <target state="translated">ILGenerator.Emit(OpCode, Type)</target>       </trans-unit>
        <trans-unit id="3754" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Starg">
          <source>Stores the value on top of the evaluation stack in the argument slot at a specified index.</source>
          <target state="translated">Armazena o valor localizado no topo da pilha de avaliação no slot de argumento em um índice especificado.</target>       </trans-unit>
        <trans-unit id="3755" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Starg">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">A tabela a seguir lista as instruções hexadecimal e formato de assembly do Microsoft Intermediate Language (MSIL), junto com um resumo breve de referência:</target>       </trans-unit>
        <trans-unit id="3756" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Starg">
          <source>Format</source>
          <target state="translated">Formatar</target>       </trans-unit>
        <trans-unit id="3757" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Starg">
          <source>Assembly Format</source>
          <target state="translated">Formato de assembly</target>       </trans-unit>
        <trans-unit id="3758" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Starg">
          <source>Description</source>
          <target state="translated">Descrição</target>       </trans-unit>
        <trans-unit id="3759" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Starg">
          <source>FE 0B &lt; <ph id="ph1">`unsigned int16`</ph><ph id="ph2"> &gt;</ph></source>
          <target state="translated">FE 0B &amp;LT; <ph id="ph1">`unsigned int16`</ph><ph id="ph2"> &gt;</ph></target>       </trans-unit>
        <trans-unit id="3760" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Starg">
          <source>starg <ph id="ph1">`num`</ph></source>
          <target state="translated">StarG <ph id="ph1">`num`</ph></target>       </trans-unit>
        <trans-unit id="3761" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Starg">
          <source>Pops the top value from the stack and stores it in argument slot <ph id="ph1">`num`</ph>.</source>
          <target state="translated">Aparece o valor de nível superior da pilha e a armazena no slot de argumento <ph id="ph1">`num`</ph>.</target>       </trans-unit>
        <trans-unit id="3762" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Starg">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">O comportamento de transição de pilha, em ordem sequencial, é:</target>       </trans-unit>
        <trans-unit id="3763" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Starg">
          <source>The value currently on top of the stack is popped and placed in argument slot <ph id="ph1">`num`</ph>.</source>
          <target state="translated">O valor atualmente na parte superior da pilha é exibido e colocado no slot de argumento <ph id="ph1">`num`</ph>.</target>       </trans-unit>
        <trans-unit id="3764" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Starg">
          <source>The <ph id="ph1">`starg`</ph> instruction pops a value from the stack and places it in argument slot <ph id="ph2">`num`</ph>.</source>
          <target state="translated">O <ph id="ph1">`starg`</ph> instrução aparece um valor da pilha e o coloca no slot de argumento <ph id="ph2">`num`</ph>.</target>       </trans-unit>
        <trans-unit id="3765" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Starg">
          <source>The type of the value must match the type of the argument, as specified in the current method's signature.</source>
          <target state="translated">O tipo do valor deve corresponder ao tipo do argumento, conforme especificado na assinatura do método atual.</target>       </trans-unit>
        <trans-unit id="3766" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Starg">
          <source>For procedures that take a variable argument list, the <ph id="ph1">`starg`</ph> instruction can be used only for the initial fixed arguments, not those in the variable part of the signature.</source>
          <target state="translated">Para procedimentos que usam uma lista de argumentos de variável, o <ph id="ph1">`starg`</ph> instrução pode ser usada apenas para inicial fixa argumentos, não os na variável parte da assinatura.</target>       </trans-unit>
        <trans-unit id="3767" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Starg">
          <source>Performing a store into arguments that hold an integer value smaller than 4 bytes long truncates the value as it moves from the stack to the argument.</source>
          <target state="translated">Execução de um repositório para argumentos que contêm um valor inteiro menor que 4 bytes de comprimento trunca o valor e avança da pilha para o argumento.</target>       </trans-unit>
        <trans-unit id="3768" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Starg">
          <source>Floating-point values are rounded from their native size (type <ph id="ph1">`F`</ph>) to the size associated with the argument.</source>
          <target state="translated">Valores de ponto flutuante são arredondados de seu tamanho nativo (tipo <ph id="ph1">`F`</ph>) para o tamanho associado com o argumento.</target>       </trans-unit>
        <trans-unit id="3769" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Starg">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`starg`</ph> opcode:</source>
          <target state="translated">O seguinte <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> sobrecarga de método pode usar o <ph id="ph2">`starg`</ph> opcode:</target>       </trans-unit>
        <trans-unit id="3770" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Starg">
          <source>ILGenerator.Emit(OpCode, short)</source>
          <target state="translated">ILGenerator.Emit (OpCode, short)</target>       </trans-unit>
        <trans-unit id="3771" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Starg_S">
          <source>Stores the value on top of the evaluation stack in the argument slot at a specified index, short form.</source>
          <target state="translated">Armazena o valor localizado no topo da pilha de avaliação no slot de argumento em um índice especificado, de forma abreviada.</target>       </trans-unit>
        <trans-unit id="3772" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Starg_S">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">A tabela a seguir lista as instruções hexadecimal e formato de assembly do Microsoft Intermediate Language (MSIL), junto com um resumo breve de referência:</target>       </trans-unit>
        <trans-unit id="3773" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Starg_S">
          <source>Format</source>
          <target state="translated">Formatar</target>       </trans-unit>
        <trans-unit id="3774" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Starg_S">
          <source>Assembly Format</source>
          <target state="translated">Formato de assembly</target>       </trans-unit>
        <trans-unit id="3775" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Starg_S">
          <source>Description</source>
          <target state="translated">Descrição</target>       </trans-unit>
        <trans-unit id="3776" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Starg_S">
          <source>10 &lt; <ph id="ph1">`unsigned int8`</ph><ph id="ph2"> &gt;</ph></source>
          <target state="translated">10 &lt; <ph id="ph1">`unsigned int8`</ph><ph id="ph2"> &gt;</ph></target>       </trans-unit>
        <trans-unit id="3777" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Starg_S">
          <source>starg.s <ph id="ph1">`num`</ph></source>
          <target state="translated">StarG.s <ph id="ph1">`num`</ph></target>       </trans-unit>
        <trans-unit id="3778" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Starg_S">
          <source>Pops the top value from the stack and stores it in argument slot <ph id="ph1">`num`</ph>, short form.</source>
          <target state="translated">Aparece o valor de nível superior da pilha e a armazena no slot de argumento <ph id="ph1">`num`</ph>, forma abreviada.</target>       </trans-unit>
        <trans-unit id="3779" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Starg_S">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">O comportamento de transição de pilha, em ordem sequencial, é:</target>       </trans-unit>
        <trans-unit id="3780" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Starg_S">
          <source>The value currently on top of the stack is popped and placed in argument slot <ph id="ph1">`num`</ph>.</source>
          <target state="translated">O valor atualmente na parte superior da pilha é exibido e colocado no slot de argumento <ph id="ph1">`num`</ph>.</target>       </trans-unit>
        <trans-unit id="3781" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Starg_S">
          <source>The <ph id="ph1">`starg.s`</ph> instruction pops a value from the stack and places it in argument slot <ph id="ph2">`num`</ph>.</source>
          <target state="translated">O <ph id="ph1">`starg.s`</ph> instrução aparece um valor da pilha e o coloca no slot de argumento <ph id="ph2">`num`</ph>.</target>       </trans-unit>
        <trans-unit id="3782" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Starg_S">
          <source>The type of the value must match the type of the argument, as specified in the current method's signature.</source>
          <target state="translated">O tipo do valor deve corresponder ao tipo do argumento, conforme especificado na assinatura do método atual.</target>       </trans-unit>
        <trans-unit id="3783" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Starg_S">
          <source>The <ph id="ph1">`starg.s`</ph> instruction provides an efficient encoding for use with the first 256 arguments.</source>
          <target state="translated">O <ph id="ph1">`starg.s`</ph> instrução fornece uma codificação eficiente para uso com os primeiros 256 argumentos.</target>       </trans-unit>
        <trans-unit id="3784" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Starg_S">
          <source>For procedures that take a variable argument list, the <ph id="ph1">`starg.s`</ph> instruction can be used only for the initial fixed arguments, not those in the variable part of the signature.</source>
          <target state="translated">Para procedimentos que usam uma lista de argumentos de variável, o <ph id="ph1">`starg.s`</ph> instrução pode ser usada apenas para inicial fixa argumentos, não os na variável parte da assinatura.</target>       </trans-unit>
        <trans-unit id="3785" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Starg_S">
          <source>Performing a store into arguments that hold an integer value smaller than 4 bytes long truncates the value as it moves from the stack to the argument.</source>
          <target state="translated">Execução de um repositório para argumentos que contêm um valor inteiro menor que 4 bytes de comprimento trunca o valor e avança da pilha para o argumento.</target>       </trans-unit>
        <trans-unit id="3786" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Starg_S">
          <source>Floating-point values are rounded from their native size (type <ph id="ph1">`F`</ph>) to the size associated with the argument.</source>
          <target state="translated">Valores de ponto flutuante são arredondados de seu tamanho nativo (tipo <ph id="ph1">`F`</ph>) para o tamanho associado com o argumento.</target>       </trans-unit>
        <trans-unit id="3787" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Starg_S">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`starg.s`</ph> opcode:</source>
          <target state="translated">O seguinte <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> sobrecarga de método pode usar o <ph id="ph2">`starg.s`</ph> opcode:</target>       </trans-unit>
        <trans-unit id="3788" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Starg_S">
          <source>ILGenerator.Emit(OpCode, byte)</source>
          <target state="translated">ILGenerator.Emit (OpCode, byte)</target>       </trans-unit>
        <trans-unit id="3789" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Stelem">
          <source>Replaces the array element at a given index with the value on the evaluation stack, whose type is specified in the instruction.</source>
          <target state="translated">Substitui o elemento de matriz de um índice especificado pelo valor na pilha de avaliação, cujo tipo é especificado na instrução.</target>       </trans-unit>
        <trans-unit id="3790" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem">
          <source>The following table lists the instruction's hexadecimal and Microsoft intermediate language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">A tabela a seguir lista a instrução hexadecimal e formato de assembly Microsoft intermediate language (MSIL), junto com um resumo breve de referência:</target>       </trans-unit>
        <trans-unit id="3791" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem">
          <source>Format</source>
          <target state="translated">Formatar</target>       </trans-unit>
        <trans-unit id="3792" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem">
          <source>Assembly Format</source>
          <target state="translated">Formato de assembly</target>       </trans-unit>
        <trans-unit id="3793" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem">
          <source>Description</source>
          <target state="translated">Descrição</target>       </trans-unit>
        <trans-unit id="3794" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem">
          <source>A4 &lt; <ph id="ph1">`T`</ph><ph id="ph2"> &gt;</ph></source>
          <target state="translated">A4 &lt; <ph id="ph1">`T`</ph><ph id="ph2"> &gt;</ph></target>       </trans-unit>
        <trans-unit id="3795" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem">
          <source>stelem <ph id="ph1">`typeTok`</ph></source>
          <target state="translated">Stelem <ph id="ph1">`typeTok`</ph></target>       </trans-unit>
        <trans-unit id="3796" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem">
          <source>Replaces the array element at the supplied index with a value of type <ph id="ph1">`typeTok`</ph> on the stack.</source>
          <target state="translated">Substitui o elemento de matriz no índice fornecido com um valor do tipo <ph id="ph1">`typeTok`</ph> na pilha.</target>       </trans-unit>
        <trans-unit id="3797" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">O comportamento de transição de pilha, em ordem sequencial, é:</target>       </trans-unit>
        <trans-unit id="3798" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem">
          <source>An object reference to an array, <ph id="ph1">`array`</ph>, is pushed onto the stack.</source>
          <target state="translated">Uma referência de objeto para uma matriz, <ph id="ph1">`array`</ph>, é inserido na pilha.</target>       </trans-unit>
        <trans-unit id="3799" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem">
          <source>An index value, <ph id="ph1">`index`</ph>, to an element in <ph id="ph2">`array`</ph> is pushed onto the stack.</source>
          <target state="translated">Um valor de índice, <ph id="ph1">`index`</ph>, para um elemento <ph id="ph2">`array`</ph> é inserido na pilha.</target>       </trans-unit>
        <trans-unit id="3800" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem">
          <source>A value of the type specified in the instruction is pushed onto the stack.</source>
          <target state="translated">Um valor do tipo especificado na instrução é inserido na pilha.</target>       </trans-unit>
        <trans-unit id="3801" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem">
          <source>The value, the index, and the array reference are popped from the stack; the value is put into the array element at the given index.</source>
          <target state="translated">O valor, o índice e a referência da matriz são disparados da pilha; o valor é colocado no elemento de matriz no índice especificado.</target>       </trans-unit>
        <trans-unit id="3802" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem">
          <source>The <ph id="ph1">`stelem`</ph> instruction replaces the value of the element at the supplied zero-based index in the one-dimensional array <ph id="ph2">`array`</ph> with the value.</source>
          <target state="translated">O <ph id="ph1">`stelem`</ph> instrução substitui o valor do elemento no índice fornecido com base em zero na matriz unidimensional <ph id="ph2">`array`</ph> com o valor.</target>       </trans-unit>
        <trans-unit id="3803" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem">
          <source>The value has the type specified by the token <ph id="ph1">`typeTok`</ph> in the instruction.</source>
          <target state="translated">O valor tem o tipo especificado pelo token <ph id="ph1">`typeTok`</ph> na instrução.</target>       </trans-unit>
        <trans-unit id="3804" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem">
          <source>Arrays are objects, and hence represented by a value of type <ph id="ph1">`O`</ph>.</source>
          <target state="translated">Matrizes de objetos e, portanto, é representado por um valor do tipo <ph id="ph1">`O`</ph>.</target>       </trans-unit>
        <trans-unit id="3805" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem">
          <source>The index is type <ph id="ph1">`native int`</ph>.</source>
          <target state="translated">O índice é tipo <ph id="ph1">`native int`</ph>.</target>       </trans-unit>
        <trans-unit id="3806" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem">
          <source><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> is thrown if <ph id="ph2">`array`</ph> is a null reference.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> será gerada se <ph id="ph2">`array`</ph> é uma referência nula.</target>       </trans-unit>
        <trans-unit id="3807" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem">
          <source><ph id="ph1">&lt;xref:System.IndexOutOfRangeException&gt;</ph> is thrown if <ph id="ph2">`index`</ph> is negative, or larger than the bound of <ph id="ph3">`array`</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.IndexOutOfRangeException&gt;</ph> será gerada se <ph id="ph2">`index`</ph> é negativo ou maior que o limite de <ph id="ph3">`array`</ph>.</target>       </trans-unit>
        <trans-unit id="3808" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem">
          <source><ph id="ph1">&lt;xref:System.ArrayTypeMismatchException&gt;</ph> is thrown if <ph id="ph2">`array`</ph> does not hold elements of the required type.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.ArrayTypeMismatchException&gt;</ph> será gerada se <ph id="ph2">`array`</ph> não contém elementos do tipo necessário.</target>       </trans-unit>
        <trans-unit id="3809" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`stelem`</ph> opcode:</source>
          <target state="translated">O seguinte <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> sobrecarga de método pode usar o <ph id="ph2">`stelem`</ph> opcode:</target>       </trans-unit>
        <trans-unit id="3810" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem">
          <source>ILGenerator.Emit(OpCode, Type)</source>
          <target state="translated">ILGenerator.Emit(OpCode, Type)</target>       </trans-unit>
        <trans-unit id="3811" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Stelem_I">
          <source>Replaces the array element at a given index with the <ph id="ph1">&lt;see langword="native int" /&gt;</ph> value on the evaluation stack.</source>
          <target state="translated">Substitui o elemento de matriz em um determinado índice pelo valor <ph id="ph1">&lt;see langword="native int" /&gt;</ph> na pilha de avaliação.</target>       </trans-unit>
        <trans-unit id="3812" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_I">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">A tabela a seguir lista as instruções hexadecimal e formato de assembly do Microsoft Intermediate Language (MSIL), junto com um resumo breve de referência:</target>       </trans-unit>
        <trans-unit id="3813" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_I">
          <source>Format</source>
          <target state="translated">Formatar</target>       </trans-unit>
        <trans-unit id="3814" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_I">
          <source>Assembly Format</source>
          <target state="translated">Formato de assembly</target>       </trans-unit>
        <trans-unit id="3815" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_I">
          <source>Description</source>
          <target state="translated">Descrição</target>       </trans-unit>
        <trans-unit id="3816" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_I">
          <source>9B</source>
          <target state="translated">9B</target>       </trans-unit>
        <trans-unit id="3817" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_I">
          <source>stelem.i</source>
          <target state="translated">stelem.i</target>       </trans-unit>
        <trans-unit id="3818" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_I">
          <source>Replaces an array element at the supplied index with the <ph id="ph1">`native int`</ph> value on the stack.</source>
          <target state="translated">Substitui um elemento de matriz no índice fornecido com o <ph id="ph1">`native int`</ph> valor na pilha.</target>       </trans-unit>
        <trans-unit id="3819" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_I">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">O comportamento de transição de pilha, em ordem sequencial, é:</target>       </trans-unit>
        <trans-unit id="3820" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_I">
          <source>An object reference to an array, <ph id="ph1">`array`</ph>, is pushed onto the stack.</source>
          <target state="translated">Uma referência de objeto para uma matriz, <ph id="ph1">`array`</ph>, é inserido na pilha.</target>       </trans-unit>
        <trans-unit id="3821" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_I">
          <source>A valid index to an element in <ph id="ph1">`array`</ph> is pushed onto the stack.</source>
          <target state="translated">Um índice válido para um elemento <ph id="ph1">`array`</ph> é inserido na pilha.</target>       </trans-unit>
        <trans-unit id="3822" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_I">
          <source>A value is pushed onto the stack.</source>
          <target state="translated">Um valor é inserido na pilha.</target>       </trans-unit>
        <trans-unit id="3823" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_I">
          <source>The value, the index, and the array reference are popped from the stack; the value is put into the array element at the given index.</source>
          <target state="translated">O valor, o índice e a referência da matriz são disparados da pilha; o valor é colocado no elemento de matriz no índice especificado.</target>       </trans-unit>
        <trans-unit id="3824" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_I">
          <source>The <ph id="ph1">`stelem.i`</ph> instruction replaces the value of the element <ph id="ph2">`index`</ph> in the one-dimensional array <ph id="ph3">`array`</ph> with the <ph id="ph4">`native int`</ph> value pushed onto the stack.</source>
          <target state="translated">O <ph id="ph1">`stelem.i`</ph> instrução substitui o valor do elemento <ph id="ph2">`index`</ph> na matriz unidimensional <ph id="ph3">`array`</ph> com o <ph id="ph4">`native int`</ph> valor inserido na pilha.</target>       </trans-unit>
        <trans-unit id="3825" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_I">
          <source>Arrays are objects and hence represented by a value of type <ph id="ph1">`O`</ph>.</source>
          <target state="translated">Matrizes de objetos e, portanto, é representado por um valor do tipo <ph id="ph1">`O`</ph>.</target>       </trans-unit>
        <trans-unit id="3826" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_I">
          <source>The index is type <ph id="ph1">`native int`</ph>.</source>
          <target state="translated">O índice é tipo <ph id="ph1">`native int`</ph>.</target>       </trans-unit>
        <trans-unit id="3827" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_I">
          <source><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> is thrown if <ph id="ph2">`array`</ph> is a null reference.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> será gerada se <ph id="ph2">`array`</ph> é uma referência nula.</target>       </trans-unit>
        <trans-unit id="3828" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_I">
          <source><ph id="ph1">&lt;xref:System.IndexOutOfRangeException&gt;</ph> is thrown if <ph id="ph2">`index`</ph> is negative, or larger than the bound of <ph id="ph3">`array`</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.IndexOutOfRangeException&gt;</ph> será gerada se <ph id="ph2">`index`</ph> é negativo ou maior que o limite de <ph id="ph3">`array`</ph>.</target>       </trans-unit>
        <trans-unit id="3829" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_I">
          <source><ph id="ph1">&lt;xref:System.ArrayTypeMismatchException&gt;</ph> is thrown if <ph id="ph2">`array`</ph> does not hold elements of the required type.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.ArrayTypeMismatchException&gt;</ph> será gerada se <ph id="ph2">`array`</ph> não contém elementos do tipo necessário.</target>       </trans-unit>
        <trans-unit id="3830" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_I">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`stelem.i`</ph> opcode:</source>
          <target state="translated">O seguinte <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> sobrecarga de método pode usar o <ph id="ph2">`stelem.i`</ph> opcode:</target>       </trans-unit>
        <trans-unit id="3831" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_I">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="3832" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Stelem_I1">
          <source>Replaces the array element at a given index with the <ph id="ph1">&lt;see langword="int8" /&gt;</ph> value on the evaluation stack.</source>
          <target state="translated">Substitui o elemento de matriz em um determinado índice pelo valor <ph id="ph1">&lt;see langword="int8" /&gt;</ph> na pilha de avaliação.</target>       </trans-unit>
        <trans-unit id="3833" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_I1">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">A tabela a seguir lista as instruções hexadecimal e formato de assembly do Microsoft Intermediate Language (MSIL), junto com um resumo breve de referência:</target>       </trans-unit>
        <trans-unit id="3834" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_I1">
          <source>Format</source>
          <target state="translated">Formatar</target>       </trans-unit>
        <trans-unit id="3835" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_I1">
          <source>Assembly Format</source>
          <target state="translated">Formato de assembly</target>       </trans-unit>
        <trans-unit id="3836" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_I1">
          <source>Description</source>
          <target state="translated">Descrição</target>       </trans-unit>
        <trans-unit id="3837" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_I1">
          <source>9C</source>
          <target state="translated">9C</target>       </trans-unit>
        <trans-unit id="3838" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_I1">
          <source>stelem.i1</source>
          <target state="translated">stelem.i1</target>       </trans-unit>
        <trans-unit id="3839" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_I1">
          <source>Replaces an array element at the supplied index with the <ph id="ph1">`int8`</ph> value on the stack.</source>
          <target state="translated">Substitui um elemento de matriz no índice fornecido com o <ph id="ph1">`int8`</ph> valor na pilha.</target>       </trans-unit>
        <trans-unit id="3840" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_I1">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">O comportamento de transição de pilha, em ordem sequencial, é:</target>       </trans-unit>
        <trans-unit id="3841" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_I1">
          <source>An object reference to an array, <ph id="ph1">`array`</ph>, is pushed onto the stack.</source>
          <target state="translated">Uma referência de objeto para uma matriz, <ph id="ph1">`array`</ph>, é inserido na pilha.</target>       </trans-unit>
        <trans-unit id="3842" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_I1">
          <source>A valid index to an element in <ph id="ph1">`array`</ph> is pushed onto the stack.</source>
          <target state="translated">Um índice válido para um elemento <ph id="ph1">`array`</ph> é inserido na pilha.</target>       </trans-unit>
        <trans-unit id="3843" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_I1">
          <source>A value is pushed onto the stack.</source>
          <target state="translated">Um valor é inserido na pilha.</target>       </trans-unit>
        <trans-unit id="3844" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_I1">
          <source>The value, the index, and the array reference are popped from the stack; the value is put into the array element at the given index.</source>
          <target state="translated">O valor, o índice e a referência da matriz são disparados da pilha; o valor é colocado no elemento de matriz no índice especificado.</target>       </trans-unit>
        <trans-unit id="3845" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_I1">
          <source>The <ph id="ph1">`stelem.i1`</ph> instruction replaces the value of the element <ph id="ph2">`index`</ph> in the one-dimensional array <ph id="ph3">`array`</ph> with the <ph id="ph4">`int8`</ph> value pushed onto the stack.</source>
          <target state="translated">O <ph id="ph1">`stelem.i1`</ph> instrução substitui o valor do elemento <ph id="ph2">`index`</ph> na matriz unidimensional <ph id="ph3">`array`</ph> com o <ph id="ph4">`int8`</ph> valor inserido na pilha.</target>       </trans-unit>
        <trans-unit id="3846" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_I1">
          <source>Arrays are objects and hence represented by a value of type <ph id="ph1">`O`</ph>.</source>
          <target state="translated">Matrizes de objetos e, portanto, é representado por um valor do tipo <ph id="ph1">`O`</ph>.</target>       </trans-unit>
        <trans-unit id="3847" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_I1">
          <source>The index is type <ph id="ph1">`native int`</ph>.</source>
          <target state="translated">O índice é tipo <ph id="ph1">`native int`</ph>.</target>       </trans-unit>
        <trans-unit id="3848" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_I1">
          <source><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> is thrown if <ph id="ph2">`array`</ph> is a null reference.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> será gerada se <ph id="ph2">`array`</ph> é uma referência nula.</target>       </trans-unit>
        <trans-unit id="3849" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_I1">
          <source><ph id="ph1">&lt;xref:System.IndexOutOfRangeException&gt;</ph> is thrown if <ph id="ph2">`index`</ph> is negative, or larger than the bound of <ph id="ph3">`array`</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.IndexOutOfRangeException&gt;</ph> será gerada se <ph id="ph2">`index`</ph> é negativo ou maior que o limite de <ph id="ph3">`array`</ph>.</target>       </trans-unit>
        <trans-unit id="3850" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_I1">
          <source><ph id="ph1">&lt;xref:System.ArrayTypeMismatchException&gt;</ph> is thrown if <ph id="ph2">`array`</ph> does not hold elements of the required type.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.ArrayTypeMismatchException&gt;</ph> será gerada se <ph id="ph2">`array`</ph> não contém elementos do tipo necessário.</target>       </trans-unit>
        <trans-unit id="3851" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_I1">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`stelem.i1`</ph> opcode:</source>
          <target state="translated">O seguinte <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> sobrecarga de método pode usar o <ph id="ph2">`stelem.i1`</ph> opcode:</target>       </trans-unit>
        <trans-unit id="3852" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_I1">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="3853" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Stelem_I2">
          <source>Replaces the array element at a given index with the <ph id="ph1">&lt;see langword="int16" /&gt;</ph> value on the evaluation stack.</source>
          <target state="translated">Substitui o elemento de matriz em um determinado índice pelo valor <ph id="ph1">&lt;see langword="int16" /&gt;</ph> na pilha de avaliação.</target>       </trans-unit>
        <trans-unit id="3854" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_I2">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">A tabela a seguir lista as instruções hexadecimal e formato de assembly do Microsoft Intermediate Language (MSIL), junto com um resumo breve de referência:</target>       </trans-unit>
        <trans-unit id="3855" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_I2">
          <source>Format</source>
          <target state="translated">Formatar</target>       </trans-unit>
        <trans-unit id="3856" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_I2">
          <source>Assembly Format</source>
          <target state="translated">Formato de assembly</target>       </trans-unit>
        <trans-unit id="3857" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_I2">
          <source>Description</source>
          <target state="translated">Descrição</target>       </trans-unit>
        <trans-unit id="3858" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_I2">
          <source>9D</source>
          <target state="translated">9D</target>       </trans-unit>
        <trans-unit id="3859" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_I2">
          <source>stelem.i2</source>
          <target state="translated">stelem.i2</target>       </trans-unit>
        <trans-unit id="3860" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_I2">
          <source>Replaces an array element at the supplied index with the <ph id="ph1">`int16`</ph> value on the stack.</source>
          <target state="translated">Substitui um elemento de matriz no índice fornecido com o <ph id="ph1">`int16`</ph> valor na pilha.</target>       </trans-unit>
        <trans-unit id="3861" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_I2">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">O comportamento de transição de pilha, em ordem sequencial, é:</target>       </trans-unit>
        <trans-unit id="3862" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_I2">
          <source>An object reference to an array, <ph id="ph1">`array`</ph>, is pushed onto the stack.</source>
          <target state="translated">Uma referência de objeto para uma matriz, <ph id="ph1">`array`</ph>, é inserido na pilha.</target>       </trans-unit>
        <trans-unit id="3863" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_I2">
          <source>A valid index to an element in <ph id="ph1">`array`</ph> is pushed onto the stack.</source>
          <target state="translated">Um índice válido para um elemento <ph id="ph1">`array`</ph> é inserido na pilha.</target>       </trans-unit>
        <trans-unit id="3864" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_I2">
          <source>A value is pushed onto the stack.</source>
          <target state="translated">Um valor é inserido na pilha.</target>       </trans-unit>
        <trans-unit id="3865" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_I2">
          <source>The value, the index, and the array reference are popped from the stack; the value is put into the array element at the given index.</source>
          <target state="translated">O valor, o índice e a referência da matriz são disparados da pilha; o valor é colocado no elemento de matriz no índice especificado.</target>       </trans-unit>
        <trans-unit id="3866" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_I2">
          <source>The <ph id="ph1">`stelem.i2`</ph> instruction replaces the value of the element <ph id="ph2">`index`</ph> in the one-dimensional array <ph id="ph3">`array`</ph> with the <ph id="ph4">`int16`</ph> value pushed onto the stack.</source>
          <target state="translated">O <ph id="ph1">`stelem.i2`</ph> instrução substitui o valor do elemento <ph id="ph2">`index`</ph> na matriz unidimensional <ph id="ph3">`array`</ph> com o <ph id="ph4">`int16`</ph> valor inserido na pilha.</target>       </trans-unit>
        <trans-unit id="3867" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_I2">
          <source>Arrays are objects and hence represented by a value of type <ph id="ph1">`O`</ph>.</source>
          <target state="translated">Matrizes de objetos e, portanto, é representado por um valor do tipo <ph id="ph1">`O`</ph>.</target>       </trans-unit>
        <trans-unit id="3868" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_I2">
          <source>The index is type <ph id="ph1">`native int`</ph>.</source>
          <target state="translated">O índice é tipo <ph id="ph1">`native int`</ph>.</target>       </trans-unit>
        <trans-unit id="3869" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_I2">
          <source><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> is thrown if <ph id="ph2">`array`</ph> is a null reference.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> será gerada se <ph id="ph2">`array`</ph> é uma referência nula.</target>       </trans-unit>
        <trans-unit id="3870" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_I2">
          <source><ph id="ph1">&lt;xref:System.IndexOutOfRangeException&gt;</ph> is thrown if <ph id="ph2">`index`</ph> is negative, or larger than the bound of <ph id="ph3">`array`</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.IndexOutOfRangeException&gt;</ph> será gerada se <ph id="ph2">`index`</ph> é negativo ou maior que o limite de <ph id="ph3">`array`</ph>.</target>       </trans-unit>
        <trans-unit id="3871" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_I2">
          <source><ph id="ph1">&lt;xref:System.ArrayTypeMismatchException&gt;</ph> is thrown if <ph id="ph2">`array`</ph> does not hold elements of the required type.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.ArrayTypeMismatchException&gt;</ph> será gerada se <ph id="ph2">`array`</ph> não contém elementos do tipo necessário.</target>       </trans-unit>
        <trans-unit id="3872" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_I2">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`stelem.i2`</ph> opcode:</source>
          <target state="translated">O seguinte <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> sobrecarga de método pode usar o <ph id="ph2">`stelem.i2`</ph> opcode:</target>       </trans-unit>
        <trans-unit id="3873" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_I2">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="3874" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Stelem_I4">
          <source>Replaces the array element at a given index with the <ph id="ph1">&lt;see langword="int32" /&gt;</ph> value on the evaluation stack.</source>
          <target state="translated">Substitui o elemento de matriz em um determinado índice pelo valor <ph id="ph1">&lt;see langword="int32" /&gt;</ph> na pilha de avaliação.</target>       </trans-unit>
        <trans-unit id="3875" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_I4">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">A tabela a seguir lista as instruções hexadecimal e formato de assembly do Microsoft Intermediate Language (MSIL), junto com um resumo breve de referência:</target>       </trans-unit>
        <trans-unit id="3876" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_I4">
          <source>Format</source>
          <target state="translated">Formatar</target>       </trans-unit>
        <trans-unit id="3877" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_I4">
          <source>Assembly Format</source>
          <target state="translated">Formato de assembly</target>       </trans-unit>
        <trans-unit id="3878" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_I4">
          <source>Description</source>
          <target state="translated">Descrição</target>       </trans-unit>
        <trans-unit id="3879" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_I4">
          <source>9E</source>
          <target state="translated">9E</target>       </trans-unit>
        <trans-unit id="3880" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_I4">
          <source>stelem.i4</source>
          <target state="translated">stelem.i4</target>       </trans-unit>
        <trans-unit id="3881" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_I4">
          <source>Replaces an array element at the supplied index with the <ph id="ph1">`int32`</ph> value on the stack.</source>
          <target state="translated">Substitui um elemento de matriz no índice fornecido com o <ph id="ph1">`int32`</ph> valor na pilha.</target>       </trans-unit>
        <trans-unit id="3882" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_I4">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">O comportamento de transição de pilha, em ordem sequencial, é:</target>       </trans-unit>
        <trans-unit id="3883" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_I4">
          <source>An object reference to an array, <ph id="ph1">`array`</ph>, is pushed onto the stack.</source>
          <target state="translated">Uma referência de objeto para uma matriz, <ph id="ph1">`array`</ph>, é inserido na pilha.</target>       </trans-unit>
        <trans-unit id="3884" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_I4">
          <source>A valid index to an element in <ph id="ph1">`array`</ph> is pushed onto the stack.</source>
          <target state="translated">Um índice válido para um elemento <ph id="ph1">`array`</ph> é inserido na pilha.</target>       </trans-unit>
        <trans-unit id="3885" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_I4">
          <source>A value is pushed onto the stack.</source>
          <target state="translated">Um valor é inserido na pilha.</target>       </trans-unit>
        <trans-unit id="3886" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_I4">
          <source>The value, the index, and the array reference are popped from the stack; the value is put into the array element at the given index.</source>
          <target state="translated">O valor, o índice e a referência da matriz são disparados da pilha; o valor é colocado no elemento de matriz no índice especificado.</target>       </trans-unit>
        <trans-unit id="3887" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_I4">
          <source>The <ph id="ph1">`stelem.i4`</ph> instruction replaces the value of the element <ph id="ph2">`index`</ph> in the one-dimensional array <ph id="ph3">`array`</ph> with the <ph id="ph4">`int32`</ph> value pushed onto the stack.</source>
          <target state="translated">O <ph id="ph1">`stelem.i4`</ph> instrução substitui o valor do elemento <ph id="ph2">`index`</ph> na matriz unidimensional <ph id="ph3">`array`</ph> com o <ph id="ph4">`int32`</ph> valor inserido na pilha.</target>       </trans-unit>
        <trans-unit id="3888" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_I4">
          <source>Arrays are objects and hence represented by a value of type <ph id="ph1">`O`</ph>.</source>
          <target state="translated">Matrizes de objetos e, portanto, é representado por um valor do tipo <ph id="ph1">`O`</ph>.</target>       </trans-unit>
        <trans-unit id="3889" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_I4">
          <source>The index is type <ph id="ph1">`native int`</ph>.</source>
          <target state="translated">O índice é tipo <ph id="ph1">`native int`</ph>.</target>       </trans-unit>
        <trans-unit id="3890" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_I4">
          <source><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> is thrown if <ph id="ph2">`array`</ph> is a null reference.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> será gerada se <ph id="ph2">`array`</ph> é uma referência nula.</target>       </trans-unit>
        <trans-unit id="3891" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_I4">
          <source><ph id="ph1">&lt;xref:System.IndexOutOfRangeException&gt;</ph> is thrown if <ph id="ph2">`index`</ph> is negative, or larger than the bound of <ph id="ph3">`array`</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.IndexOutOfRangeException&gt;</ph> será gerada se <ph id="ph2">`index`</ph> é negativo ou maior que o limite de <ph id="ph3">`array`</ph>.</target>       </trans-unit>
        <trans-unit id="3892" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_I4">
          <source><ph id="ph1">&lt;xref:System.ArrayTypeMismatchException&gt;</ph> is thrown if <ph id="ph2">`array`</ph> does not hold elements of the required type.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.ArrayTypeMismatchException&gt;</ph> será gerada se <ph id="ph2">`array`</ph> não contém elementos do tipo necessário.</target>       </trans-unit>
        <trans-unit id="3893" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_I4">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`stelem.i4`</ph> opcode:</source>
          <target state="translated">O seguinte <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> sobrecarga de método pode usar o <ph id="ph2">`stelem.i4`</ph> opcode:</target>       </trans-unit>
        <trans-unit id="3894" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_I4">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="3895" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Stelem_I8">
          <source>Replaces the array element at a given index with the <ph id="ph1">&lt;see langword="int64" /&gt;</ph> value on the evaluation stack.</source>
          <target state="translated">Substitui o elemento de matriz em um determinado índice pelo valor <ph id="ph1">&lt;see langword="int64" /&gt;</ph> na pilha de avaliação.</target>       </trans-unit>
        <trans-unit id="3896" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_I8">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">A tabela a seguir lista as instruções hexadecimal e formato de assembly do Microsoft Intermediate Language (MSIL), junto com um resumo breve de referência:</target>       </trans-unit>
        <trans-unit id="3897" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_I8">
          <source>Format</source>
          <target state="translated">Formatar</target>       </trans-unit>
        <trans-unit id="3898" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_I8">
          <source>Assembly Format</source>
          <target state="translated">Formato de assembly</target>       </trans-unit>
        <trans-unit id="3899" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_I8">
          <source>Description</source>
          <target state="translated">Descrição</target>       </trans-unit>
        <trans-unit id="3900" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_I8">
          <source>9F</source>
          <target state="translated">9F</target>       </trans-unit>
        <trans-unit id="3901" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_I8">
          <source>stelem.i8</source>
          <target state="translated">stelem.i8</target>       </trans-unit>
        <trans-unit id="3902" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_I8">
          <source>Replaces an array element at the supplied index with the <ph id="ph1">`int64`</ph> value on the stack.</source>
          <target state="translated">Substitui um elemento de matriz no índice fornecido com o <ph id="ph1">`int64`</ph> valor na pilha.</target>       </trans-unit>
        <trans-unit id="3903" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_I8">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">O comportamento de transição de pilha, em ordem sequencial, é:</target>       </trans-unit>
        <trans-unit id="3904" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_I8">
          <source>An object reference to an array, <ph id="ph1">`array`</ph>, is pushed onto the stack.</source>
          <target state="translated">Uma referência de objeto para uma matriz, <ph id="ph1">`array`</ph>, é inserido na pilha.</target>       </trans-unit>
        <trans-unit id="3905" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_I8">
          <source>A valid index to an element in <ph id="ph1">`array`</ph> is pushed onto the stack.</source>
          <target state="translated">Um índice válido para um elemento <ph id="ph1">`array`</ph> é inserido na pilha.</target>       </trans-unit>
        <trans-unit id="3906" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_I8">
          <source>A value is pushed onto the stack.</source>
          <target state="translated">Um valor é inserido na pilha.</target>       </trans-unit>
        <trans-unit id="3907" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_I8">
          <source>The value, the index, and the array reference are popped from the stack; the value is put into the array element at the given index.</source>
          <target state="translated">O valor, o índice e a referência da matriz são disparados da pilha; o valor é colocado no elemento de matriz no índice especificado.</target>       </trans-unit>
        <trans-unit id="3908" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_I8">
          <source>The <ph id="ph1">`stelem.i8`</ph> instruction replaces the value of the element <ph id="ph2">`index`</ph> in the one-dimensional array <ph id="ph3">`array`</ph> with the <ph id="ph4">`int64`</ph> value pushed onto the stack.</source>
          <target state="translated">O <ph id="ph1">`stelem.i8`</ph> instrução substitui o valor do elemento <ph id="ph2">`index`</ph> na matriz unidimensional <ph id="ph3">`array`</ph> com o <ph id="ph4">`int64`</ph> valor inserido na pilha.</target>       </trans-unit>
        <trans-unit id="3909" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_I8">
          <source>Arrays are objects and hence represented by a value of type <ph id="ph1">`O`</ph>.</source>
          <target state="translated">Matrizes de objetos e, portanto, é representado por um valor do tipo <ph id="ph1">`O`</ph>.</target>       </trans-unit>
        <trans-unit id="3910" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_I8">
          <source>The index is type <ph id="ph1">`native int`</ph>.</source>
          <target state="translated">O índice é tipo <ph id="ph1">`native int`</ph>.</target>       </trans-unit>
        <trans-unit id="3911" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_I8">
          <source><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> is thrown if <ph id="ph2">`array`</ph> is a null reference.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> será gerada se <ph id="ph2">`array`</ph> é uma referência nula.</target>       </trans-unit>
        <trans-unit id="3912" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_I8">
          <source><ph id="ph1">&lt;xref:System.IndexOutOfRangeException&gt;</ph> is thrown if <ph id="ph2">`index`</ph> is negative, or larger than the bound of <ph id="ph3">`array`</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.IndexOutOfRangeException&gt;</ph> será gerada se <ph id="ph2">`index`</ph> é negativo ou maior que o limite de <ph id="ph3">`array`</ph>.</target>       </trans-unit>
        <trans-unit id="3913" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_I8">
          <source><ph id="ph1">&lt;xref:System.ArrayTypeMismatchException&gt;</ph> is thrown if <ph id="ph2">`array`</ph> does not hold elements of the required type.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.ArrayTypeMismatchException&gt;</ph> será gerada se <ph id="ph2">`array`</ph> não contém elementos do tipo necessário.</target>       </trans-unit>
        <trans-unit id="3914" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_I8">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`stelem.i8`</ph> opcode:</source>
          <target state="translated">O seguinte <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> sobrecarga de método pode usar o <ph id="ph2">`stelem.i8`</ph> opcode:</target>       </trans-unit>
        <trans-unit id="3915" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_I8">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="3916" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Stelem_R4">
          <source>Replaces the array element at a given index with the <ph id="ph1">&lt;see langword="float32" /&gt;</ph> value on the evaluation stack.</source>
          <target state="translated">Substitui o elemento de matriz em um determinado índice pelo valor <ph id="ph1">&lt;see langword="float32" /&gt;</ph> na pilha de avaliação.</target>       </trans-unit>
        <trans-unit id="3917" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_R4">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">A tabela a seguir lista as instruções hexadecimal e formato de assembly do Microsoft Intermediate Language (MSIL), junto com um resumo breve de referência:</target>       </trans-unit>
        <trans-unit id="3918" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_R4">
          <source>Format</source>
          <target state="translated">Formatar</target>       </trans-unit>
        <trans-unit id="3919" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_R4">
          <source>Assembly Format</source>
          <target state="translated">Formato de assembly</target>       </trans-unit>
        <trans-unit id="3920" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_R4">
          <source>Description</source>
          <target state="translated">Descrição</target>       </trans-unit>
        <trans-unit id="3921" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_R4">
          <source>A0</source>
          <target state="translated">A0</target>       </trans-unit>
        <trans-unit id="3922" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_R4">
          <source>stelem.r4</source>
          <target state="translated">stelem.r4</target>       </trans-unit>
        <trans-unit id="3923" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_R4">
          <source>Replaces an array element at the supplied index with the <ph id="ph1">`float32`</ph> value on the stack.</source>
          <target state="translated">Substitui um elemento de matriz no índice fornecido com o <ph id="ph1">`float32`</ph> valor na pilha.</target>       </trans-unit>
        <trans-unit id="3924" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_R4">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">O comportamento de transição de pilha, em ordem sequencial, é:</target>       </trans-unit>
        <trans-unit id="3925" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_R4">
          <source>An object reference to an array, <ph id="ph1">`array`</ph>, is pushed onto the stack.</source>
          <target state="translated">Uma referência de objeto para uma matriz, <ph id="ph1">`array`</ph>, é inserido na pilha.</target>       </trans-unit>
        <trans-unit id="3926" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_R4">
          <source>A valid index to an element in <ph id="ph1">`array`</ph> is pushed onto the stack.</source>
          <target state="translated">Um índice válido para um elemento <ph id="ph1">`array`</ph> é inserido na pilha.</target>       </trans-unit>
        <trans-unit id="3927" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_R4">
          <source>A value is pushed onto the stack.</source>
          <target state="translated">Um valor é inserido na pilha.</target>       </trans-unit>
        <trans-unit id="3928" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_R4">
          <source>The value, the index, and the array reference are popped from the stack; the value is put into the array element at the given index.</source>
          <target state="translated">O valor, o índice e a referência da matriz são disparados da pilha; o valor é colocado no elemento de matriz no índice especificado.</target>       </trans-unit>
        <trans-unit id="3929" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_R4">
          <source>The <ph id="ph1">`stelem.r4`</ph> instruction replaces the value of the element <ph id="ph2">`index`</ph> in the one-dimensional array <ph id="ph3">`array`</ph> with the <ph id="ph4">`float32`</ph> value pushed onto the stack.</source>
          <target state="translated">O <ph id="ph1">`stelem.r4`</ph> instrução substitui o valor do elemento <ph id="ph2">`index`</ph> na matriz unidimensional <ph id="ph3">`array`</ph> com o <ph id="ph4">`float32`</ph> valor inserido na pilha.</target>       </trans-unit>
        <trans-unit id="3930" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_R4">
          <source>Arrays are objects and hence represented by a value of type <ph id="ph1">`O`</ph>.</source>
          <target state="translated">Matrizes de objetos e, portanto, é representado por um valor do tipo <ph id="ph1">`O`</ph>.</target>       </trans-unit>
        <trans-unit id="3931" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_R4">
          <source>The index is type <ph id="ph1">`native int`</ph>.</source>
          <target state="translated">O índice é tipo <ph id="ph1">`native int`</ph>.</target>       </trans-unit>
        <trans-unit id="3932" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_R4">
          <source><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> is thrown if <ph id="ph2">`array`</ph> is a null reference.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> será gerada se <ph id="ph2">`array`</ph> é uma referência nula.</target>       </trans-unit>
        <trans-unit id="3933" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_R4">
          <source><ph id="ph1">&lt;xref:System.IndexOutOfRangeException&gt;</ph> is thrown if <ph id="ph2">`index`</ph> is negative, or larger than the bound of <ph id="ph3">`array`</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.IndexOutOfRangeException&gt;</ph> será gerada se <ph id="ph2">`index`</ph> é negativo ou maior que o limite de <ph id="ph3">`array`</ph>.</target>       </trans-unit>
        <trans-unit id="3934" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_R4">
          <source><ph id="ph1">&lt;xref:System.ArrayTypeMismatchException&gt;</ph> is thrown if <ph id="ph2">`array`</ph> does not hold elements of the required type.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.ArrayTypeMismatchException&gt;</ph> será gerada se <ph id="ph2">`array`</ph> não contém elementos do tipo necessário.</target>       </trans-unit>
        <trans-unit id="3935" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_R4">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`stelem.r4`</ph> opcode:</source>
          <target state="translated">O seguinte <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> sobrecarga de método pode usar o <ph id="ph2">`stelem.r4`</ph> opcode:</target>       </trans-unit>
        <trans-unit id="3936" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_R4">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="3937" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Stelem_R8">
          <source>Replaces the array element at a given index with the <ph id="ph1">&lt;see langword="float64" /&gt;</ph> value on the evaluation stack.</source>
          <target state="translated">Substitui o elemento de matriz em um determinado índice pelo valor <ph id="ph1">&lt;see langword="float64" /&gt;</ph> na pilha de avaliação.</target>       </trans-unit>
        <trans-unit id="3938" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_R8">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">A tabela a seguir lista as instruções hexadecimal e formato de assembly do Microsoft Intermediate Language (MSIL), junto com um resumo breve de referência:</target>       </trans-unit>
        <trans-unit id="3939" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_R8">
          <source>Format</source>
          <target state="translated">Formatar</target>       </trans-unit>
        <trans-unit id="3940" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_R8">
          <source>Assembly Format</source>
          <target state="translated">Formato de assembly</target>       </trans-unit>
        <trans-unit id="3941" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_R8">
          <source>Description</source>
          <target state="translated">Descrição</target>       </trans-unit>
        <trans-unit id="3942" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_R8">
          <source>A1</source>
          <target state="translated">A1</target>       </trans-unit>
        <trans-unit id="3943" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_R8">
          <source>stelem.r8</source>
          <target state="translated">stelem.r8</target>       </trans-unit>
        <trans-unit id="3944" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_R8">
          <source>Replaces an array element at the supplied index with the <ph id="ph1">`float64`</ph> value on the stack.</source>
          <target state="translated">Substitui um elemento de matriz no índice fornecido com o <ph id="ph1">`float64`</ph> valor na pilha.</target>       </trans-unit>
        <trans-unit id="3945" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_R8">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">O comportamento de transição de pilha, em ordem sequencial, é:</target>       </trans-unit>
        <trans-unit id="3946" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_R8">
          <source>An object reference to an array, <ph id="ph1">`array`</ph>, is pushed onto the stack.</source>
          <target state="translated">Uma referência de objeto para uma matriz, <ph id="ph1">`array`</ph>, é inserido na pilha.</target>       </trans-unit>
        <trans-unit id="3947" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_R8">
          <source>A valid index to an element in <ph id="ph1">`array`</ph> is pushed onto the stack.</source>
          <target state="translated">Um índice válido para um elemento <ph id="ph1">`array`</ph> é inserido na pilha.</target>       </trans-unit>
        <trans-unit id="3948" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_R8">
          <source>A value is pushed onto the stack.</source>
          <target state="translated">Um valor é inserido na pilha.</target>       </trans-unit>
        <trans-unit id="3949" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_R8">
          <source>The value, the index, and the array reference are popped from the stack; the value is put into the array element at the given index.</source>
          <target state="translated">O valor, o índice e a referência da matriz são disparados da pilha; o valor é colocado no elemento de matriz no índice especificado.</target>       </trans-unit>
        <trans-unit id="3950" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_R8">
          <source>The <ph id="ph1">`stelem.r8`</ph> instruction replaces the value of the element <ph id="ph2">`index`</ph> in the one-dimensional array <ph id="ph3">`array`</ph> with the <ph id="ph4">`float64`</ph> value pushed onto the stack.</source>
          <target state="translated">O <ph id="ph1">`stelem.r8`</ph> instrução substitui o valor do elemento <ph id="ph2">`index`</ph> na matriz unidimensional <ph id="ph3">`array`</ph> com o <ph id="ph4">`float64`</ph> valor inserido na pilha.</target>       </trans-unit>
        <trans-unit id="3951" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_R8">
          <source>Arrays are objects and hence represented by a value of type <ph id="ph1">`O`</ph>.</source>
          <target state="translated">Matrizes de objetos e, portanto, é representado por um valor do tipo <ph id="ph1">`O`</ph>.</target>       </trans-unit>
        <trans-unit id="3952" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_R8">
          <source>The index is type <ph id="ph1">`native int`</ph>.</source>
          <target state="translated">O índice é tipo <ph id="ph1">`native int`</ph>.</target>       </trans-unit>
        <trans-unit id="3953" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_R8">
          <source><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> is thrown if <ph id="ph2">`array`</ph> is a null reference.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> será gerada se <ph id="ph2">`array`</ph> é uma referência nula.</target>       </trans-unit>
        <trans-unit id="3954" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_R8">
          <source><ph id="ph1">&lt;xref:System.IndexOutOfRangeException&gt;</ph> is thrown if <ph id="ph2">`index`</ph> is negative, or larger than the bound of <ph id="ph3">`array`</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.IndexOutOfRangeException&gt;</ph> será gerada se <ph id="ph2">`index`</ph> é negativo ou maior que o limite de <ph id="ph3">`array`</ph>.</target>       </trans-unit>
        <trans-unit id="3955" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_R8">
          <source><ph id="ph1">&lt;xref:System.ArrayTypeMismatchException&gt;</ph> is thrown if <ph id="ph2">`array`</ph> does not hold elements of the required type.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.ArrayTypeMismatchException&gt;</ph> será gerada se <ph id="ph2">`array`</ph> não contém elementos do tipo necessário.</target>       </trans-unit>
        <trans-unit id="3956" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_R8">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`stelem.r8`</ph> opcode:</source>
          <target state="translated">O seguinte <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> sobrecarga de método pode usar o <ph id="ph2">`stelem.r8`</ph> opcode:</target>       </trans-unit>
        <trans-unit id="3957" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_R8">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="3958" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Stelem_Ref">
          <source>Replaces the array element at a given index with the object ref value (type <ph id="ph1">&lt;see langword="O" /&gt;</ph>) on the evaluation stack.</source>
          <target state="translated">Substitui o elemento da matriz de um determinado índice com o valor de referência de objeto (tipo <ph id="ph1">&lt;see langword="O" /&gt;</ph>) na pilha de avaliação.</target>       </trans-unit>
        <trans-unit id="3959" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_Ref">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">A tabela a seguir lista as instruções hexadecimal e formato de assembly do Microsoft Intermediate Language (MSIL), junto com um resumo breve de referência:</target>       </trans-unit>
        <trans-unit id="3960" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_Ref">
          <source>Format</source>
          <target state="translated">Formatar</target>       </trans-unit>
        <trans-unit id="3961" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_Ref">
          <source>Assembly Format</source>
          <target state="translated">Formato de assembly</target>       </trans-unit>
        <trans-unit id="3962" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_Ref">
          <source>Description</source>
          <target state="translated">Descrição</target>       </trans-unit>
        <trans-unit id="3963" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_Ref">
          <source>A2</source>
          <target state="translated">A2</target>       </trans-unit>
        <trans-unit id="3964" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_Ref">
          <source>stelem.ref</source>
          <target state="translated">stelem.ref</target>       </trans-unit>
        <trans-unit id="3965" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_Ref">
          <source>Replaces an array element at the supplied index with the <ph id="ph1">`ref`</ph> value (type <ph id="ph2">`O`</ph>) on the stack.</source>
          <target state="translated">Substitui um elemento de matriz no índice fornecido com o <ph id="ph1">`ref`</ph> valor (tipo <ph id="ph2">`O`</ph>) na pilha.</target>       </trans-unit>
        <trans-unit id="3966" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_Ref">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">O comportamento de transição de pilha, em ordem sequencial, é:</target>       </trans-unit>
        <trans-unit id="3967" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_Ref">
          <source>An object reference to an array, <ph id="ph1">`array`</ph>, is pushed onto the stack.</source>
          <target state="translated">Uma referência de objeto para uma matriz, <ph id="ph1">`array`</ph>, é inserido na pilha.</target>       </trans-unit>
        <trans-unit id="3968" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_Ref">
          <source>A valid index to an element in <ph id="ph1">`array`</ph> is pushed onto the stack.</source>
          <target state="translated">Um índice válido para um elemento <ph id="ph1">`array`</ph> é inserido na pilha.</target>       </trans-unit>
        <trans-unit id="3969" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_Ref">
          <source>A value is pushed onto the stack.</source>
          <target state="translated">Um valor é inserido na pilha.</target>       </trans-unit>
        <trans-unit id="3970" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_Ref">
          <source>The value, the index, and the array reference are popped from the stack; the value is put into the array element at the given index.</source>
          <target state="translated">O valor, o índice e a referência da matriz são disparados da pilha; o valor é colocado no elemento de matriz no índice especificado.</target>       </trans-unit>
        <trans-unit id="3971" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_Ref">
          <source>The <ph id="ph1">`stelem.ref`</ph> instruction replaces the value of the element at the supplied index in the one-dimensional array <ph id="ph2">`array`</ph> with the <ph id="ph3">`ref`</ph> (type <ph id="ph4">`O`</ph>) value pushed onto the stack.</source>
          <target state="translated">O <ph id="ph1">`stelem.ref`</ph> instrução substitui o valor do elemento no índice fornecido na matriz unidimensional <ph id="ph2">`array`</ph> com o <ph id="ph3">`ref`</ph> (tipo <ph id="ph4">`O`</ph>) valor inserido na pilha.</target>       </trans-unit>
        <trans-unit id="3972" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_Ref">
          <source>Arrays are objects and hence represented by a value of type <ph id="ph1">`O`</ph>.</source>
          <target state="translated">Matrizes de objetos e, portanto, é representado por um valor do tipo <ph id="ph1">`O`</ph>.</target>       </trans-unit>
        <trans-unit id="3973" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_Ref">
          <source>The index is type <ph id="ph1">`native int`</ph>.</source>
          <target state="translated">O índice é tipo <ph id="ph1">`native int`</ph>.</target>       </trans-unit>
        <trans-unit id="3974" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_Ref">
          <source>Note that <ph id="ph1">`stelem.ref`</ph> implicitly casts the supplied value to the element type of <ph id="ph2">`array`</ph> before assigning the value to the array element.</source>
          <target state="translated">Observe que <ph id="ph1">`stelem.ref`</ph> converte implicitamente o valor fornecido para o tipo de elemento <ph id="ph2">`array`</ph> antes de atribuir o valor para o elemento da matriz.</target>       </trans-unit>
        <trans-unit id="3975" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_Ref">
          <source>This cast can fail, even for verified code.</source>
          <target state="translated">Esta conversão pode falhar, mesmo para código verificado.</target>       </trans-unit>
        <trans-unit id="3976" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_Ref">
          <source>Thus the <ph id="ph1">`stelem.ref`</ph> instruction can throw <ph id="ph2">&lt;xref:System.InvalidCastException&gt;</ph>.</source>
          <target state="translated">Portanto, o <ph id="ph1">`stelem.ref`</ph> instrução pode lançar <ph id="ph2">&lt;xref:System.InvalidCastException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3977" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_Ref">
          <source>For one-dimensional arrays that aren't zero-based and for multidimensional arrays, the <ph id="ph1">&lt;xref:System.Array&gt;</ph> class provides a <ph id="ph2">&lt;xref:System.Array.SetValue%2A&gt;</ph> method.</source>
          <target state="translated">Para matrizes unidimensionais que não estão com base em zero e para matrizes multidimensionais, o <ph id="ph1">&lt;xref:System.Array&gt;</ph> classe fornece um <ph id="ph2">&lt;xref:System.Array.SetValue%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="3978" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_Ref">
          <source><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> is thrown if <ph id="ph2">`array`</ph> is a null reference.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> será gerada se <ph id="ph2">`array`</ph> é uma referência nula.</target>       </trans-unit>
        <trans-unit id="3979" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_Ref">
          <source><ph id="ph1">&lt;xref:System.IndexOutOfRangeException&gt;</ph> is thrown if <ph id="ph2">`index`</ph> is negative, or larger than the bound of <ph id="ph3">`array`</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.IndexOutOfRangeException&gt;</ph> será gerada se <ph id="ph2">`index`</ph> é negativo ou maior que o limite de <ph id="ph3">`array`</ph>.</target>       </trans-unit>
        <trans-unit id="3980" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_Ref">
          <source><ph id="ph1">&lt;xref:System.ArrayTypeMismatchException&gt;</ph> is thrown if <ph id="ph2">`array`</ph> does not hold elements of the required type.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.ArrayTypeMismatchException&gt;</ph> será gerada se <ph id="ph2">`array`</ph> não contém elementos do tipo necessário.</target>       </trans-unit>
        <trans-unit id="3981" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_Ref">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`stelem.ref`</ph> opcode:</source>
          <target state="translated">O seguinte <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> sobrecarga de método pode usar o <ph id="ph2">`stelem.ref`</ph> opcode:</target>       </trans-unit>
        <trans-unit id="3982" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_Ref">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="3983" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Stfld">
          <source>Replaces the value stored in the field of an object reference or pointer with a new value.</source>
          <target state="translated">Substitui o valor armazenado no campo de uma referência de objeto ou de um ponteiro por um novo valor.</target>       </trans-unit>
        <trans-unit id="3984" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stfld">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">A tabela a seguir lista as instruções hexadecimal e formato de assembly do Microsoft Intermediate Language (MSIL), junto com um resumo breve de referência:</target>       </trans-unit>
        <trans-unit id="3985" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stfld">
          <source>Format</source>
          <target state="translated">Formatar</target>       </trans-unit>
        <trans-unit id="3986" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stfld">
          <source>Assembly Format</source>
          <target state="translated">Formato de assembly</target>       </trans-unit>
        <trans-unit id="3987" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stfld">
          <source>Description</source>
          <target state="translated">Descrição</target>       </trans-unit>
        <trans-unit id="3988" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stfld">
          <source>7D &lt; <ph id="ph1">`T`</ph><ph id="ph2"> &gt;</ph></source>
          <target state="translated">7D &lt; <ph id="ph1">`T`</ph><ph id="ph2"> &gt;</ph></target>       </trans-unit>
        <trans-unit id="3989" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stfld">
          <source>stfld <ph id="ph1">`field`</ph></source>
          <target state="translated">stfld <ph id="ph1">`field`</ph></target>       </trans-unit>
        <trans-unit id="3990" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stfld">
          <source>Replaces the value of <ph id="ph1">`field`</ph> of the object with a new value.</source>
          <target state="translated">Substitui o valor de <ph id="ph1">`field`</ph> do objeto com um novo valor.</target>       </trans-unit>
        <trans-unit id="3991" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stfld">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">O comportamento de transição de pilha, em ordem sequencial, é:</target>       </trans-unit>
        <trans-unit id="3992" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stfld">
          <source>An object reference or pointer is pushed onto the stack.</source>
          <target state="translated">Uma referência de objeto ou ponteiro é inserido na pilha.</target>       </trans-unit>
        <trans-unit id="3993" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stfld">
          <source>A value is pushed onto the stack.</source>
          <target state="translated">Um valor é inserido na pilha.</target>       </trans-unit>
        <trans-unit id="3994" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stfld">
          <source>The value and the object reference/pointer are popped from the stack; the value of <ph id="ph1">`field`</ph> in the object is replaced with the supplied value.</source>
          <target state="translated">O valor e o referência de objeto/ponteiro são disparados da pilha; o valor de <ph id="ph1">`field`</ph> no objeto é substituído com o valor fornecido.</target>       </trans-unit>
        <trans-unit id="3995" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stfld">
          <source>The <ph id="ph1">`stfld`</ph> instruction replaces the value of a field of an object (type <ph id="ph2">`O`</ph>) or via a pointer (type <ph id="ph3">`native int`</ph>, <ph id="ph4">`&amp;`</ph>, or <ph id="ph5">`*`</ph>) with a given value.</source>
          <target state="translated">O <ph id="ph1">`stfld`</ph> instrução substitui o valor de um campo de um objeto (tipo <ph id="ph2">`O`</ph>) ou por meio de um ponteiro (tipo <ph id="ph3">`native int`</ph>, <ph id="ph4">`&amp;`</ph>, ou <ph id="ph5">`*`</ph>) com um determinado valor.</target>       </trans-unit>
        <trans-unit id="3996" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stfld">
          <source><ph id="ph1">`Field`</ph> is a metadata token that refers to a field member reference.</source>
          <target state="translated"><ph id="ph1">`Field`</ph> é um token de metadados que se refere a uma referência de membro do campo.</target>       </trans-unit>
        <trans-unit id="3997" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stfld">
          <source>The <ph id="ph1">`stfld`</ph> instruction can have a prefix of either or both of <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Unaligned&gt;</ph> and <ph id="ph3">&lt;xref:System.Reflection.Emit.OpCodes.Volatile&gt;</ph>.</source>
          <target state="translated">O <ph id="ph1">`stfld`</ph> instrução pode ter um prefixo de um ou ambos <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Unaligned&gt;</ph> e <ph id="ph3">&lt;xref:System.Reflection.Emit.OpCodes.Volatile&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3998" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stfld">
          <source><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> is thrown if the object reference or pointer is a null reference and the field isn't static.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> é gerada se o ponteiro ou referência de objeto é uma referência nula e o campo não é estático.</target>       </trans-unit>
        <trans-unit id="3999" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stfld">
          <source><ph id="ph1">&lt;xref:System.MissingFieldException&gt;</ph> is thrown if <ph id="ph2">`field`</ph> is not found in the metadata.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.MissingFieldException&gt;</ph> será gerada se <ph id="ph2">`field`</ph> não foi encontrado nos metadados.</target>       </trans-unit>
        <trans-unit id="4000" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stfld">
          <source>This is typically checked when the Microsoft Intermediate Language (MSIL) instruction is converted to native code, not at runtime.</source>
          <target state="translated">Normalmente, isso é verificado quando a instrução Microsoft Intermediate Language (MSIL) é convertida em código nativo, não em tempo de execução.</target>       </trans-unit>
        <trans-unit id="4001" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stfld">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`stfld`</ph> opcode:</source>
          <target state="translated">O seguinte <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> sobrecarga de método pode usar o <ph id="ph2">`stfld`</ph> opcode:</target>       </trans-unit>
        <trans-unit id="4002" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stfld">
          <source>ILGenerator.Emit(OpCode, FieldInfo)</source>
          <target state="translated">ILGenerator.Emit(OpCode, FieldInfo)</target>       </trans-unit>
        <trans-unit id="4003" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Stind_I">
          <source>Stores a value of type <ph id="ph1">&lt;see langword="native int" /&gt;</ph> at a supplied address.</source>
          <target state="translated">Armazena um valor do tipo <ph id="ph1">&lt;see langword="native int" /&gt;</ph> em um endereço fornecido.</target>       </trans-unit>
        <trans-unit id="4004" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_I">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">A tabela a seguir lista as instruções hexadecimal e formato de assembly do Microsoft Intermediate Language (MSIL), junto com um resumo breve de referência:</target>       </trans-unit>
        <trans-unit id="4005" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_I">
          <source>Format</source>
          <target state="translated">Formatar</target>       </trans-unit>
        <trans-unit id="4006" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_I">
          <source>Assembly Format</source>
          <target state="translated">Formato de assembly</target>       </trans-unit>
        <trans-unit id="4007" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_I">
          <source>Description</source>
          <target state="translated">Descrição</target>       </trans-unit>
        <trans-unit id="4008" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_I">
          <source>DF</source>
          <target state="translated">DF</target>       </trans-unit>
        <trans-unit id="4009" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_I">
          <source>stind.i</source>
          <target state="translated">stind.i</target>       </trans-unit>
        <trans-unit id="4010" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_I">
          <source>Stores a <ph id="ph1">`native int`</ph> value at a given address.</source>
          <target state="translated">Armazena um <ph id="ph1">`native int`</ph> valor em um determinado endereço.</target>       </trans-unit>
        <trans-unit id="4011" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_I">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">O comportamento de transição de pilha, em ordem sequencial, é:</target>       </trans-unit>
        <trans-unit id="4012" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_I">
          <source>An address is pushed onto the stack.</source>
          <target state="translated">Um endereço é inserido na pilha.</target>       </trans-unit>
        <trans-unit id="4013" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_I">
          <source>A value is pushed onto the stack.</source>
          <target state="translated">Um valor é inserido na pilha.</target>       </trans-unit>
        <trans-unit id="4014" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_I">
          <source>The value and the address are popped from the stack; the value is stored at the address.</source>
          <target state="translated">O valor e o endereço são disparados da pilha; o valor é armazenado no endereço.</target>       </trans-unit>
        <trans-unit id="4015" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_I">
          <source>The <ph id="ph1">`stind.i`</ph> instruction stores a <ph id="ph2">`native int`</ph> value at the supplied address (type <ph id="ph3">`native int`</ph>, <ph id="ph4">`*`</ph>, or <ph id="ph5">`&amp;`</ph>).</source>
          <target state="translated">O <ph id="ph1">`stind.i`</ph> instrução armazena um <ph id="ph2">`native int`</ph> valor no endereço fornecido (tipo <ph id="ph3">`native int`</ph>, <ph id="ph4">`*`</ph>, ou <ph id="ph5">`&amp;`</ph>).</target>       </trans-unit>
        <trans-unit id="4016" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_I">
          <source>Type safe operation requires that the <ph id="ph1">`stind.i`</ph> instruction be used in a manner consistent with the type of the pointer.</source>
          <target state="translated">Operação de tipo segura requer que o <ph id="ph1">`stind.i`</ph> instrução ser usados de maneira consistente com o tipo do ponteiro.</target>       </trans-unit>
        <trans-unit id="4017" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_I">
          <source>The operation of the <ph id="ph1">`stind.i`</ph> instruction can be altered by an immediately preceding <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Volatile&gt;</ph> or <ph id="ph3">&lt;xref:System.Reflection.Emit.OpCodes.Unaligned&gt;</ph> prefix instruction.</source>
          <target state="translated">A operação do <ph id="ph1">`stind.i`</ph> instrução pode ser alterada por um imediatamente anterior <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Volatile&gt;</ph> ou <ph id="ph3">&lt;xref:System.Reflection.Emit.OpCodes.Unaligned&gt;</ph> prefixo instrução.</target>       </trans-unit>
        <trans-unit id="4018" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_I">
          <source><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> is thrown if <ph id="ph2">`addr`</ph> is not naturally aligned for the argument type implied by the instruction suffix.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> será gerada se <ph id="ph2">`addr`</ph> naturalmente não está alinhado para o tipo de argumento indicado pelo sufixo de instrução.</target>       </trans-unit>
        <trans-unit id="4019" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_I">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`stind.i`</ph> opcode:</source>
          <target state="translated">O seguinte <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> sobrecarga de método pode usar o <ph id="ph2">`stind.i`</ph> opcode:</target>       </trans-unit>
        <trans-unit id="4020" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_I">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="4021" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Stind_I1">
          <source>Stores a value of type <ph id="ph1">&lt;see langword="int8" /&gt;</ph> at a supplied address.</source>
          <target state="translated">Armazena um valor do tipo <ph id="ph1">&lt;see langword="int8" /&gt;</ph> em um endereço fornecido.</target>       </trans-unit>
        <trans-unit id="4022" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_I1">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">A tabela a seguir lista as instruções hexadecimal e formato de assembly do Microsoft Intermediate Language (MSIL), junto com um resumo breve de referência:</target>       </trans-unit>
        <trans-unit id="4023" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_I1">
          <source>Format</source>
          <target state="translated">Formatar</target>       </trans-unit>
        <trans-unit id="4024" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_I1">
          <source>Assembly Format</source>
          <target state="translated">Formato de assembly</target>       </trans-unit>
        <trans-unit id="4025" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_I1">
          <source>Description</source>
          <target state="translated">Descrição</target>       </trans-unit>
        <trans-unit id="4026" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_I1">
          <source>52</source>
          <target state="translated">52</target>       </trans-unit>
        <trans-unit id="4027" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_I1">
          <source>stind.i1</source>
          <target state="translated">stind.i1</target>       </trans-unit>
        <trans-unit id="4028" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_I1">
          <source>Stores an <ph id="ph1">`int8`</ph> value at a given address.</source>
          <target state="translated">Armazena um <ph id="ph1">`int8`</ph> valor em um determinado endereço.</target>       </trans-unit>
        <trans-unit id="4029" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_I1">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">O comportamento de transição de pilha, em ordem sequencial, é:</target>       </trans-unit>
        <trans-unit id="4030" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_I1">
          <source>An address is pushed onto the stack.</source>
          <target state="translated">Um endereço é inserido na pilha.</target>       </trans-unit>
        <trans-unit id="4031" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_I1">
          <source>A value is pushed onto the stack.</source>
          <target state="translated">Um valor é inserido na pilha.</target>       </trans-unit>
        <trans-unit id="4032" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_I1">
          <source>The value and the address are popped from the stack; the value is stored at the address.</source>
          <target state="translated">O valor e o endereço são disparados da pilha; o valor é armazenado no endereço.</target>       </trans-unit>
        <trans-unit id="4033" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_I1">
          <source>The <ph id="ph1">`stind.i1`</ph> instruction stores an <ph id="ph2">`int8`</ph> value at the supplied address (type <ph id="ph3">`native int`</ph>, <ph id="ph4">`*`</ph>, or <ph id="ph5">`&amp;`</ph>).</source>
          <target state="translated">O <ph id="ph1">`stind.i1`</ph> instrução armazena um <ph id="ph2">`int8`</ph> valor no endereço fornecido (tipo <ph id="ph3">`native int`</ph>, <ph id="ph4">`*`</ph>, ou <ph id="ph5">`&amp;`</ph>).</target>       </trans-unit>
        <trans-unit id="4034" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_I1">
          <source>Type safe operation requires that the <ph id="ph1">`stind.i1`</ph> instruction be used in a manner consistent with the type of the pointer.</source>
          <target state="translated">Operação de tipo segura requer que o <ph id="ph1">`stind.i1`</ph> instrução ser usados de maneira consistente com o tipo do ponteiro.</target>       </trans-unit>
        <trans-unit id="4035" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_I1">
          <source>The operation of the <ph id="ph1">`stind.i1`</ph> instruction can be altered by an immediately preceding <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Volatile&gt;</ph> or <ph id="ph3">&lt;xref:System.Reflection.Emit.OpCodes.Unaligned&gt;</ph> prefix instruction.</source>
          <target state="translated">A operação do <ph id="ph1">`stind.i1`</ph> instrução pode ser alterada por um imediatamente anterior <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Volatile&gt;</ph> ou <ph id="ph3">&lt;xref:System.Reflection.Emit.OpCodes.Unaligned&gt;</ph> prefixo instrução.</target>       </trans-unit>
        <trans-unit id="4036" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_I1">
          <source><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> is thrown if <ph id="ph2">`addr`</ph> is not naturally aligned for the argument type implied by the instruction suffix.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> será gerada se <ph id="ph2">`addr`</ph> naturalmente não está alinhado para o tipo de argumento indicado pelo sufixo de instrução.</target>       </trans-unit>
        <trans-unit id="4037" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_I1">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`stind.i1`</ph> opcode:</source>
          <target state="translated">O seguinte <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> sobrecarga de método pode usar o <ph id="ph2">`stind.i1`</ph> opcode:</target>       </trans-unit>
        <trans-unit id="4038" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_I1">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="4039" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Stind_I2">
          <source>Stores a value of type <ph id="ph1">&lt;see langword="int16" /&gt;</ph> at a supplied address.</source>
          <target state="translated">Armazena um valor do tipo <ph id="ph1">&lt;see langword="int16" /&gt;</ph> em um endereço fornecido.</target>       </trans-unit>
        <trans-unit id="4040" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_I2">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">A tabela a seguir lista as instruções hexadecimal e formato de assembly do Microsoft Intermediate Language (MSIL), junto com um resumo breve de referência:</target>       </trans-unit>
        <trans-unit id="4041" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_I2">
          <source>Format</source>
          <target state="translated">Formatar</target>       </trans-unit>
        <trans-unit id="4042" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_I2">
          <source>Assembly Format</source>
          <target state="translated">Formato de assembly</target>       </trans-unit>
        <trans-unit id="4043" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_I2">
          <source>Description</source>
          <target state="translated">Descrição</target>       </trans-unit>
        <trans-unit id="4044" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_I2">
          <source>53</source>
          <target state="translated">53</target>       </trans-unit>
        <trans-unit id="4045" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_I2">
          <source>stind.i2</source>
          <target state="translated">stind.i2</target>       </trans-unit>
        <trans-unit id="4046" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_I2">
          <source>Stores an <ph id="ph1">`int16`</ph> value at a given address.</source>
          <target state="translated">Armazena um <ph id="ph1">`int16`</ph> valor em um determinado endereço.</target>       </trans-unit>
        <trans-unit id="4047" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_I2">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">O comportamento de transição de pilha, em ordem sequencial, é:</target>       </trans-unit>
        <trans-unit id="4048" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_I2">
          <source>An address is pushed onto the stack.</source>
          <target state="translated">Um endereço é inserido na pilha.</target>       </trans-unit>
        <trans-unit id="4049" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_I2">
          <source>A value is pushed onto the stack.</source>
          <target state="translated">Um valor é inserido na pilha.</target>       </trans-unit>
        <trans-unit id="4050" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_I2">
          <source>The value and the address are popped from the stack; the value is stored at the address.</source>
          <target state="translated">O valor e o endereço são disparados da pilha; o valor é armazenado no endereço.</target>       </trans-unit>
        <trans-unit id="4051" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_I2">
          <source>The <ph id="ph1">`stind.i2`</ph> instruction stores an <ph id="ph2">`int16`</ph> value at the supplied address (type <ph id="ph3">`native int`</ph>, <ph id="ph4">`*`</ph>, or <ph id="ph5">`&amp;`</ph>).</source>
          <target state="translated">O <ph id="ph1">`stind.i2`</ph> instrução armazena um <ph id="ph2">`int16`</ph> valor no endereço fornecido (tipo <ph id="ph3">`native int`</ph>, <ph id="ph4">`*`</ph>, ou <ph id="ph5">`&amp;`</ph>).</target>       </trans-unit>
        <trans-unit id="4052" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_I2">
          <source>Type safe operation requires that the <ph id="ph1">`stind.2i`</ph> instruction be used in a manner consistent with the type of the pointer.</source>
          <target state="translated">Operação de tipo segura requer que o <ph id="ph1">`stind.2i`</ph> instrução ser usados de maneira consistente com o tipo do ponteiro.</target>       </trans-unit>
        <trans-unit id="4053" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_I2">
          <source>The operation of the <ph id="ph1">`stind.i2`</ph> instruction can be altered by an immediately preceding <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Volatile&gt;</ph> or <ph id="ph3">&lt;xref:System.Reflection.Emit.OpCodes.Unaligned&gt;</ph> prefix instruction.</source>
          <target state="translated">A operação do <ph id="ph1">`stind.i2`</ph> instrução pode ser alterada por um imediatamente anterior <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Volatile&gt;</ph> ou <ph id="ph3">&lt;xref:System.Reflection.Emit.OpCodes.Unaligned&gt;</ph> prefixo instrução.</target>       </trans-unit>
        <trans-unit id="4054" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_I2">
          <source><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> is thrown if <ph id="ph2">`addr`</ph> is not naturally aligned for the argument type implied by the instruction suffix.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> será gerada se <ph id="ph2">`addr`</ph> naturalmente não está alinhado para o tipo de argumento indicado pelo sufixo de instrução.</target>       </trans-unit>
        <trans-unit id="4055" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_I2">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`stind.i2`</ph> opcode:</source>
          <target state="translated">O seguinte <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> sobrecarga de método pode usar o <ph id="ph2">`stind.i2`</ph> opcode:</target>       </trans-unit>
        <trans-unit id="4056" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_I2">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="4057" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Stind_I4">
          <source>Stores a value of type <ph id="ph1">&lt;see langword="int32" /&gt;</ph> at a supplied address.</source>
          <target state="translated">Armazena um valor do tipo <ph id="ph1">&lt;see langword="int32" /&gt;</ph> em um endereço fornecido.</target>       </trans-unit>
        <trans-unit id="4058" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_I4">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">A tabela a seguir lista as instruções hexadecimal e formato de assembly do Microsoft Intermediate Language (MSIL), junto com um resumo breve de referência:</target>       </trans-unit>
        <trans-unit id="4059" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_I4">
          <source>Format</source>
          <target state="translated">Formatar</target>       </trans-unit>
        <trans-unit id="4060" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_I4">
          <source>Assembly Format</source>
          <target state="translated">Formato de assembly</target>       </trans-unit>
        <trans-unit id="4061" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_I4">
          <source>Description</source>
          <target state="translated">Descrição</target>       </trans-unit>
        <trans-unit id="4062" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_I4">
          <source>54</source>
          <target state="translated">54</target>       </trans-unit>
        <trans-unit id="4063" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_I4">
          <source>stind.i4</source>
          <target state="translated">stind.i4</target>       </trans-unit>
        <trans-unit id="4064" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_I4">
          <source>Stores an <ph id="ph1">`int32`</ph> value at a given address.</source>
          <target state="translated">Armazena um <ph id="ph1">`int32`</ph> valor em um determinado endereço.</target>       </trans-unit>
        <trans-unit id="4065" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_I4">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">O comportamento de transição de pilha, em ordem sequencial, é:</target>       </trans-unit>
        <trans-unit id="4066" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_I4">
          <source>An address is pushed onto the stack.</source>
          <target state="translated">Um endereço é inserido na pilha.</target>       </trans-unit>
        <trans-unit id="4067" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_I4">
          <source>A value is pushed onto the stack.</source>
          <target state="translated">Um valor é inserido na pilha.</target>       </trans-unit>
        <trans-unit id="4068" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_I4">
          <source>The value and the address are popped from the stack; the value is stored at the address.</source>
          <target state="translated">O valor e o endereço são disparados da pilha; o valor é armazenado no endereço.</target>       </trans-unit>
        <trans-unit id="4069" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_I4">
          <source>The <ph id="ph1">`stind.i4`</ph> instruction stores an <ph id="ph2">`int32`</ph> value at the supplied address (type <ph id="ph3">`native int`</ph>, <ph id="ph4">`*`</ph>, or <ph id="ph5">`&amp;`</ph>).</source>
          <target state="translated">O <ph id="ph1">`stind.i4`</ph> instrução armazena um <ph id="ph2">`int32`</ph> valor no endereço fornecido (tipo <ph id="ph3">`native int`</ph>, <ph id="ph4">`*`</ph>, ou <ph id="ph5">`&amp;`</ph>).</target>       </trans-unit>
        <trans-unit id="4070" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_I4">
          <source>Type safe operation requires that the <ph id="ph1">`stind.i4`</ph> instruction be used in a manner consistent with the type of the pointer.</source>
          <target state="translated">Operação de tipo segura requer que o <ph id="ph1">`stind.i4`</ph> instrução ser usados de maneira consistente com o tipo do ponteiro.</target>       </trans-unit>
        <trans-unit id="4071" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_I4">
          <source>The operation of the <ph id="ph1">`stind.i4`</ph> instruction can be altered by an immediately preceding <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Volatile&gt;</ph> or <ph id="ph3">&lt;xref:System.Reflection.Emit.OpCodes.Unaligned&gt;</ph> prefix instruction.</source>
          <target state="translated">A operação do <ph id="ph1">`stind.i4`</ph> instrução pode ser alterada por um imediatamente anterior <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Volatile&gt;</ph> ou <ph id="ph3">&lt;xref:System.Reflection.Emit.OpCodes.Unaligned&gt;</ph> prefixo instrução.</target>       </trans-unit>
        <trans-unit id="4072" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_I4">
          <source><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> is thrown if <ph id="ph2">`addr`</ph> is not naturally aligned for the argument type implied by the instruction suffix.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> será gerada se <ph id="ph2">`addr`</ph> naturalmente não está alinhado para o tipo de argumento indicado pelo sufixo de instrução.</target>       </trans-unit>
        <trans-unit id="4073" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_I4">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`stind.i4`</ph> opcode:</source>
          <target state="translated">O seguinte <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> sobrecarga de método pode usar o <ph id="ph2">`stind.i4`</ph> opcode:</target>       </trans-unit>
        <trans-unit id="4074" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_I4">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="4075" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Stind_I8">
          <source>Stores a value of type <ph id="ph1">&lt;see langword="int64" /&gt;</ph> at a supplied address.</source>
          <target state="translated">Armazena um valor do tipo <ph id="ph1">&lt;see langword="int64" /&gt;</ph> em um endereço fornecido.</target>       </trans-unit>
        <trans-unit id="4076" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_I8">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">A tabela a seguir lista as instruções hexadecimal e formato de assembly do Microsoft Intermediate Language (MSIL), junto com um resumo breve de referência:</target>       </trans-unit>
        <trans-unit id="4077" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_I8">
          <source>Format</source>
          <target state="translated">Formatar</target>       </trans-unit>
        <trans-unit id="4078" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_I8">
          <source>Assembly Format</source>
          <target state="translated">Formato de assembly</target>       </trans-unit>
        <trans-unit id="4079" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_I8">
          <source>Description</source>
          <target state="translated">Descrição</target>       </trans-unit>
        <trans-unit id="4080" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_I8">
          <source>55</source>
          <target state="translated">55</target>       </trans-unit>
        <trans-unit id="4081" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_I8">
          <source>stind.i8</source>
          <target state="translated">stind.i8</target>       </trans-unit>
        <trans-unit id="4082" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_I8">
          <source>Stores an <ph id="ph1">`int64`</ph> value at a given address.</source>
          <target state="translated">Armazena um <ph id="ph1">`int64`</ph> valor em um determinado endereço.</target>       </trans-unit>
        <trans-unit id="4083" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_I8">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">O comportamento de transição de pilha, em ordem sequencial, é:</target>       </trans-unit>
        <trans-unit id="4084" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_I8">
          <source>An address is pushed onto the stack.</source>
          <target state="translated">Um endereço é inserido na pilha.</target>       </trans-unit>
        <trans-unit id="4085" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_I8">
          <source>A value is pushed onto the stack.</source>
          <target state="translated">Um valor é inserido na pilha.</target>       </trans-unit>
        <trans-unit id="4086" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_I8">
          <source>The value and the address are popped from the stack; the value is stored at the address.</source>
          <target state="translated">O valor e o endereço são disparados da pilha; o valor é armazenado no endereço.</target>       </trans-unit>
        <trans-unit id="4087" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_I8">
          <source>The <ph id="ph1">`stind.i8`</ph> instruction stores an <ph id="ph2">`int64`</ph> value at the supplied address (type <ph id="ph3">`native int`</ph>, <ph id="ph4">`*`</ph>, or <ph id="ph5">`&amp;`</ph>).</source>
          <target state="translated">O <ph id="ph1">`stind.i8`</ph> instrução armazena um <ph id="ph2">`int64`</ph> valor no endereço fornecido (tipo <ph id="ph3">`native int`</ph>, <ph id="ph4">`*`</ph>, ou <ph id="ph5">`&amp;`</ph>).</target>       </trans-unit>
        <trans-unit id="4088" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_I8">
          <source>Type safe operation requires that the <ph id="ph1">`stind.i8`</ph> instruction be used in a manner consistent with the type of the pointer.</source>
          <target state="translated">Operação de tipo segura requer que o <ph id="ph1">`stind.i8`</ph> instrução ser usados de maneira consistente com o tipo do ponteiro.</target>       </trans-unit>
        <trans-unit id="4089" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_I8">
          <source>The operation of the <ph id="ph1">`stind.i`</ph> instruction can be altered by an immediately preceding <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Volatile&gt;</ph> or <ph id="ph3">&lt;xref:System.Reflection.Emit.OpCodes.Unaligned&gt;</ph> prefix instruction.</source>
          <target state="translated">A operação do <ph id="ph1">`stind.i`</ph> instrução pode ser alterada por um imediatamente anterior <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Volatile&gt;</ph> ou <ph id="ph3">&lt;xref:System.Reflection.Emit.OpCodes.Unaligned&gt;</ph> prefixo instrução.</target>       </trans-unit>
        <trans-unit id="4090" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_I8">
          <source><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> is thrown if <ph id="ph2">`addr`</ph> is not naturally aligned for the argument type implied by the instruction suffix.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> será gerada se <ph id="ph2">`addr`</ph> naturalmente não está alinhado para o tipo de argumento indicado pelo sufixo de instrução.</target>       </trans-unit>
        <trans-unit id="4091" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_I8">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`stind.i8`</ph> opcode:</source>
          <target state="translated">O seguinte <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> sobrecarga de método pode usar o <ph id="ph2">`stind.i8`</ph> opcode:</target>       </trans-unit>
        <trans-unit id="4092" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_I8">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="4093" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Stind_R4">
          <source>Stores a value of type <ph id="ph1">&lt;see langword="float32" /&gt;</ph> at a supplied address.</source>
          <target state="translated">Armazena um valor do tipo <ph id="ph1">&lt;see langword="float32" /&gt;</ph> em um endereço fornecido.</target>       </trans-unit>
        <trans-unit id="4094" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_R4">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">A tabela a seguir lista as instruções hexadecimal e formato de assembly do Microsoft Intermediate Language (MSIL), junto com um resumo breve de referência:</target>       </trans-unit>
        <trans-unit id="4095" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_R4">
          <source>Format</source>
          <target state="translated">Formatar</target>       </trans-unit>
        <trans-unit id="4096" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_R4">
          <source>Assembly Format</source>
          <target state="translated">Formato de assembly</target>       </trans-unit>
        <trans-unit id="4097" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_R4">
          <source>Description</source>
          <target state="translated">Descrição</target>       </trans-unit>
        <trans-unit id="4098" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_R4">
          <source>56</source>
          <target state="translated">56</target>       </trans-unit>
        <trans-unit id="4099" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_R4">
          <source>stind.r4</source>
          <target state="translated">stind.r4</target>       </trans-unit>
        <trans-unit id="4100" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_R4">
          <source>Stores a <ph id="ph1">`float32`</ph> value at a given address.</source>
          <target state="translated">Armazena um <ph id="ph1">`float32`</ph> valor em um determinado endereço.</target>       </trans-unit>
        <trans-unit id="4101" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_R4">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">O comportamento de transição de pilha, em ordem sequencial, é:</target>       </trans-unit>
        <trans-unit id="4102" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_R4">
          <source>An address is pushed onto the stack.</source>
          <target state="translated">Um endereço é inserido na pilha.</target>       </trans-unit>
        <trans-unit id="4103" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_R4">
          <source>A value is pushed onto the stack.</source>
          <target state="translated">Um valor é inserido na pilha.</target>       </trans-unit>
        <trans-unit id="4104" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_R4">
          <source>The value and the address are popped from the stack; the value is stored at the address.</source>
          <target state="translated">O valor e o endereço são disparados da pilha; o valor é armazenado no endereço.</target>       </trans-unit>
        <trans-unit id="4105" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_R4">
          <source>The <ph id="ph1">`stind.r4`</ph> instruction stores a <ph id="ph2">`float32`</ph> value at the supplied address (type <ph id="ph3">`native int`</ph>, <ph id="ph4">`*`</ph>, or <ph id="ph5">`&amp;`</ph>).</source>
          <target state="translated">O <ph id="ph1">`stind.r4`</ph> instrução armazena um <ph id="ph2">`float32`</ph> valor no endereço fornecido (tipo <ph id="ph3">`native int`</ph>, <ph id="ph4">`*`</ph>, ou <ph id="ph5">`&amp;`</ph>).</target>       </trans-unit>
        <trans-unit id="4106" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_R4">
          <source>Type safe operation requires that the <ph id="ph1">`stind.r4`</ph> instruction be used in a manner consistent with the type of the pointer.</source>
          <target state="translated">Operação de tipo segura requer que o <ph id="ph1">`stind.r4`</ph> instrução ser usados de maneira consistente com o tipo do ponteiro.</target>       </trans-unit>
        <trans-unit id="4107" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_R4">
          <source>The operation of the <ph id="ph1">`stind.r4`</ph> instruction can be altered by an immediately preceding <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Volatile&gt;</ph> or <ph id="ph3">&lt;xref:System.Reflection.Emit.OpCodes.Unaligned&gt;</ph> prefix instruction.</source>
          <target state="translated">A operação do <ph id="ph1">`stind.r4`</ph> instrução pode ser alterada por um imediatamente anterior <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Volatile&gt;</ph> ou <ph id="ph3">&lt;xref:System.Reflection.Emit.OpCodes.Unaligned&gt;</ph> prefixo instrução.</target>       </trans-unit>
        <trans-unit id="4108" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_R4">
          <source><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> is thrown if <ph id="ph2">`addr`</ph> is not naturally aligned for the argument type implied by the instruction suffix.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> será gerada se <ph id="ph2">`addr`</ph> naturalmente não está alinhado para o tipo de argumento indicado pelo sufixo de instrução.</target>       </trans-unit>
        <trans-unit id="4109" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_R4">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`stind.r4`</ph> opcode:</source>
          <target state="translated">O seguinte <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> sobrecarga de método pode usar o <ph id="ph2">`stind.r4`</ph> opcode:</target>       </trans-unit>
        <trans-unit id="4110" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_R4">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="4111" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Stind_R8">
          <source>Stores a value of type <ph id="ph1">&lt;see langword="float64" /&gt;</ph> at a supplied address.</source>
          <target state="translated">Armazena um valor do tipo <ph id="ph1">&lt;see langword="float64" /&gt;</ph> em um endereço fornecido.</target>       </trans-unit>
        <trans-unit id="4112" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_R8">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">A tabela a seguir lista as instruções hexadecimal e formato de assembly do Microsoft Intermediate Language (MSIL), junto com um resumo breve de referência:</target>       </trans-unit>
        <trans-unit id="4113" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_R8">
          <source>Format</source>
          <target state="translated">Formatar</target>       </trans-unit>
        <trans-unit id="4114" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_R8">
          <source>Assembly Format</source>
          <target state="translated">Formato de assembly</target>       </trans-unit>
        <trans-unit id="4115" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_R8">
          <source>Description</source>
          <target state="translated">Descrição</target>       </trans-unit>
        <trans-unit id="4116" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_R8">
          <source>57</source>
          <target state="translated">57</target>       </trans-unit>
        <trans-unit id="4117" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_R8">
          <source>stind.r8</source>
          <target state="translated">stind.r8</target>       </trans-unit>
        <trans-unit id="4118" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_R8">
          <source>Stores a <ph id="ph1">`float64`</ph> value at a given address.</source>
          <target state="translated">Armazena um <ph id="ph1">`float64`</ph> valor em um determinado endereço.</target>       </trans-unit>
        <trans-unit id="4119" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_R8">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">O comportamento de transição de pilha, em ordem sequencial, é:</target>       </trans-unit>
        <trans-unit id="4120" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_R8">
          <source>An address is pushed onto the stack.</source>
          <target state="translated">Um endereço é inserido na pilha.</target>       </trans-unit>
        <trans-unit id="4121" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_R8">
          <source>A value is pushed onto the stack.</source>
          <target state="translated">Um valor é inserido na pilha.</target>       </trans-unit>
        <trans-unit id="4122" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_R8">
          <source>The value and the address are popped from the stack; the value is stored at the address.</source>
          <target state="translated">O valor e o endereço são disparados da pilha; o valor é armazenado no endereço.</target>       </trans-unit>
        <trans-unit id="4123" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_R8">
          <source>The <ph id="ph1">`stind.r8`</ph> instruction stores a <ph id="ph2">`float64`</ph> value at the supplied address (type <ph id="ph3">`native int`</ph>, <ph id="ph4">`*`</ph>, or <ph id="ph5">`&amp;`</ph>).</source>
          <target state="translated">O <ph id="ph1">`stind.r8`</ph> instrução armazena um <ph id="ph2">`float64`</ph> valor no endereço fornecido (tipo <ph id="ph3">`native int`</ph>, <ph id="ph4">`*`</ph>, ou <ph id="ph5">`&amp;`</ph>).</target>       </trans-unit>
        <trans-unit id="4124" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_R8">
          <source>Type safe operation requires that the <ph id="ph1">`stind.r8`</ph> instruction be used in a manner consistent with the type of the pointer.</source>
          <target state="translated">Operação de tipo segura requer que o <ph id="ph1">`stind.r8`</ph> instrução ser usados de maneira consistente com o tipo do ponteiro.</target>       </trans-unit>
        <trans-unit id="4125" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_R8">
          <source>The operation of the <ph id="ph1">`stind.r8`</ph> instruction can be altered by an immediately preceding <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Volatile&gt;</ph> or <ph id="ph3">&lt;xref:System.Reflection.Emit.OpCodes.Unaligned&gt;</ph> prefix instruction.</source>
          <target state="translated">A operação do <ph id="ph1">`stind.r8`</ph> instrução pode ser alterada por um imediatamente anterior <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Volatile&gt;</ph> ou <ph id="ph3">&lt;xref:System.Reflection.Emit.OpCodes.Unaligned&gt;</ph> prefixo instrução.</target>       </trans-unit>
        <trans-unit id="4126" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_R8">
          <source><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> is thrown if <ph id="ph2">`addr`</ph> is not naturally aligned for the argument type implied by the instruction suffix.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> será gerada se <ph id="ph2">`addr`</ph> naturalmente não está alinhado para o tipo de argumento indicado pelo sufixo de instrução.</target>       </trans-unit>
        <trans-unit id="4127" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_R8">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`stind.r8`</ph> opcode:</source>
          <target state="translated">O seguinte <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> sobrecarga de método pode usar o <ph id="ph2">`stind.r8`</ph> opcode:</target>       </trans-unit>
        <trans-unit id="4128" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_R8">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="4129" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Stind_Ref">
          <source>Stores a object reference value at a supplied address.</source>
          <target state="translated">Armazena um valor de referência de objeto em um endereço fornecido.</target>       </trans-unit>
        <trans-unit id="4130" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_Ref">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">A tabela a seguir lista as instruções hexadecimal e formato de assembly do Microsoft Intermediate Language (MSIL), junto com um resumo breve de referência:</target>       </trans-unit>
        <trans-unit id="4131" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_Ref">
          <source>Format</source>
          <target state="translated">Formatar</target>       </trans-unit>
        <trans-unit id="4132" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_Ref">
          <source>Assembly Format</source>
          <target state="translated">Formato de assembly</target>       </trans-unit>
        <trans-unit id="4133" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_Ref">
          <source>Description</source>
          <target state="translated">Descrição</target>       </trans-unit>
        <trans-unit id="4134" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_Ref">
          <source>51</source>
          <target state="translated">51</target>       </trans-unit>
        <trans-unit id="4135" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_Ref">
          <source>stind.ref</source>
          <target state="translated">stind.ref</target>       </trans-unit>
        <trans-unit id="4136" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_Ref">
          <source>Stores an object reference (type <ph id="ph1">`O`</ph>) value at a given address.</source>
          <target state="translated">Armazena uma referência de objeto (tipo <ph id="ph1">`O`</ph>) valor em um determinado endereço.</target>       </trans-unit>
        <trans-unit id="4137" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_Ref">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">O comportamento de transição de pilha, em ordem sequencial, é:</target>       </trans-unit>
        <trans-unit id="4138" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_Ref">
          <source>An address is pushed onto the stack.</source>
          <target state="translated">Um endereço é inserido na pilha.</target>       </trans-unit>
        <trans-unit id="4139" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_Ref">
          <source>A value is pushed onto the stack.</source>
          <target state="translated">Um valor é inserido na pilha.</target>       </trans-unit>
        <trans-unit id="4140" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_Ref">
          <source>The value and the address are popped from the stack; the value is stored at the address.</source>
          <target state="translated">O valor e o endereço são disparados da pilha; o valor é armazenado no endereço.</target>       </trans-unit>
        <trans-unit id="4141" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_Ref">
          <source>The <ph id="ph1">`stind.ref`</ph> instruction stores an object reference value at the supplied address (type <ph id="ph2">`native int`</ph>, <ph id="ph3">`*`</ph>, or <ph id="ph4">`&amp;`</ph>).</source>
          <target state="translated">O <ph id="ph1">`stind.ref`</ph> instrução armazena um valor de referência de objeto no endereço fornecido (tipo <ph id="ph2">`native int`</ph>, <ph id="ph3">`*`</ph>, ou <ph id="ph4">`&amp;`</ph>).</target>       </trans-unit>
        <trans-unit id="4142" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_Ref">
          <source>Type safe operation requires that the <ph id="ph1">`stind.ref`</ph> instruction be used in a manner consistent with the type of the pointer.</source>
          <target state="translated">Operação de tipo segura requer que o <ph id="ph1">`stind.ref`</ph> instrução ser usados de maneira consistente com o tipo do ponteiro.</target>       </trans-unit>
        <trans-unit id="4143" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_Ref">
          <source>The operation of the <ph id="ph1">`stind.ref`</ph> instruction can be altered by an immediately preceding <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Volatile&gt;</ph> or <ph id="ph3">&lt;xref:System.Reflection.Emit.OpCodes.Unaligned&gt;</ph> prefix instruction.</source>
          <target state="translated">A operação do <ph id="ph1">`stind.ref`</ph> instrução pode ser alterada por um imediatamente anterior <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Volatile&gt;</ph> ou <ph id="ph3">&lt;xref:System.Reflection.Emit.OpCodes.Unaligned&gt;</ph> prefixo instrução.</target>       </trans-unit>
        <trans-unit id="4144" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_Ref">
          <source><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> is thrown if <ph id="ph2">`addr`</ph> is not naturally aligned for the argument type implied by the instruction suffix.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> será gerada se <ph id="ph2">`addr`</ph> naturalmente não está alinhado para o tipo de argumento indicado pelo sufixo de instrução.</target>       </trans-unit>
        <trans-unit id="4145" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_Ref">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`stind.ref`</ph> opcode:</source>
          <target state="translated">O seguinte <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> sobrecarga de método pode usar o <ph id="ph2">`stind.ref`</ph> opcode:</target>       </trans-unit>
        <trans-unit id="4146" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_Ref">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="4147" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Stloc">
          <source>Pops the current value from the top of the evaluation stack and stores it in a the local variable list at a specified index.</source>
          <target state="translated">Exibe o valor atual da parte superior da pilha de avaliação e a armazena em uma lista de variáveis locais em um índice especificado.</target>       </trans-unit>
        <trans-unit id="4148" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stloc">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">A tabela a seguir lista as instruções hexadecimal e formato de assembly do Microsoft Intermediate Language (MSIL), junto com um resumo breve de referência:</target>       </trans-unit>
        <trans-unit id="4149" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stloc">
          <source>Format</source>
          <target state="translated">Formatar</target>       </trans-unit>
        <trans-unit id="4150" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stloc">
          <source>Assembly Format</source>
          <target state="translated">Formato de assembly</target>       </trans-unit>
        <trans-unit id="4151" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stloc">
          <source>Description</source>
          <target state="translated">Descrição</target>       </trans-unit>
        <trans-unit id="4152" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stloc">
          <source>FE 0E &lt; <ph id="ph1">`unsigned int16`</ph><ph id="ph2"> &gt;</ph></source>
          <target state="translated">FE 0E &lt; <ph id="ph1">`unsigned int16`</ph><ph id="ph2"> &gt;</ph></target>       </trans-unit>
        <trans-unit id="4153" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stloc">
          <source>stloc <ph id="ph1">`index`</ph></source>
          <target state="translated">stloc <ph id="ph1">`index`</ph></target>       </trans-unit>
        <trans-unit id="4154" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stloc">
          <source>Pops a value from the stack and stores it in local variable <ph id="ph1">`index`</ph>.</source>
          <target state="translated">Aparece um valor da pilha e a armazena na variável local <ph id="ph1">`index`</ph>.</target>       </trans-unit>
        <trans-unit id="4155" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stloc">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">O comportamento de transição de pilha, em ordem sequencial, é:</target>       </trans-unit>
        <trans-unit id="4156" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stloc">
          <source>A value is popped off of the stack and placed in local variable <ph id="ph1">`index`</ph>.</source>
          <target state="translated">Um valor é exibido fora da pilha e colocado na variável local <ph id="ph1">`index`</ph>.</target>       </trans-unit>
        <trans-unit id="4157" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stloc">
          <source>The <ph id="ph1">`stloc`</ph> instruction pops the top value off the evaluation stack and moves it into local variable number <ph id="ph2">`index`</ph>, where local variables are numbered 0 onwards.</source>
          <target state="translated">O <ph id="ph1">`stloc`</ph> instrução aparece o valor de nível superior na pilha de avaliação e a move para o número de variável local <ph id="ph2">`index`</ph>, onde as variáveis locais são numerados de 0 em diante.</target>       </trans-unit>
        <trans-unit id="4158" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stloc">
          <source>The type of the value must match the type of the local variable as specified in the current method's local signature.</source>
          <target state="translated">O tipo do valor deve corresponder ao tipo da variável local, conforme especificado na assinatura local do método atual.</target>       </trans-unit>
        <trans-unit id="4159" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stloc">
          <source>Storing into locals that hold an integer value smaller than 4 bytes long truncates the value as it moves from the stack to the local variable.</source>
          <target state="translated">Armazenando em locais que contêm um valor inteiro menor que 4 bytes de comprimento trunca o valor conforme avança da pilha para a variável local.</target>       </trans-unit>
        <trans-unit id="4160" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stloc">
          <source>Floating-point values are rounded from their native size (type <ph id="ph1">`F`</ph>) to the size associated with the argument.</source>
          <target state="translated">Valores de ponto flutuante são arredondados de seu tamanho nativo (tipo <ph id="ph1">`F`</ph>) para o tamanho associado com o argumento.</target>       </trans-unit>
        <trans-unit id="4161" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stloc">
          <source>Correct Microsoft Intermediate Language (MSIL) instructions require that <ph id="ph1">`index`</ph> be a valid local index.</source>
          <target state="translated">Instruções corretas do Microsoft Intermediate Language (MSIL) exigem que <ph id="ph1">`index`</ph> ser um índice de local válido.</target>       </trans-unit>
        <trans-unit id="4162" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stloc">
          <source>For the <ph id="ph1">`stloc`</ph> instruction, <ph id="ph2">`index`</ph> must lie in the range 0 to 65534 inclusive (specifically, 65535 is not valid).</source>
          <target state="translated">Para o <ph id="ph1">`stloc`</ph> instrução <ph id="ph2">`index`</ph> devem estar no intervalo de 0 a 65534 inclusiva (especificamente, 65535 não é válido).</target>       </trans-unit>
        <trans-unit id="4163" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stloc">
          <source>The reason for excluding 65535 is pragmatic: likely implementations will use a 2-byte integer to track both a local's index, as well as the total number of locals for a given method.</source>
          <target state="translated">A razão para excluir a 65535 é pragmática: implementações provavelmente usará um inteiro de 2 bytes para controlar os índice do local, bem como o número total de locais para um determinado método.</target>       </trans-unit>
        <trans-unit id="4164" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stloc">
          <source>If an index of 65535 had been made valid, it would require a wider integer to track the number of locals in such a method.</source>
          <target state="translated">Se um índice de 65535 tinha sido feito válido, ela requer um inteiro maior para controlar o número de locais em tal método.</target>       </trans-unit>
        <trans-unit id="4165" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stloc">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overloads can use the <ph id="ph2">`stloc`</ph> opcode:</source>
          <target state="translated">O seguinte <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> sobrecargas de método podem usar o <ph id="ph2">`stloc`</ph> opcode:</target>       </trans-unit>
        <trans-unit id="4166" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stloc">
          <source>ILGenerator.Emit(OpCode, LocalBuilder)</source>
          <target state="translated">ILGenerator.Emit(OpCode, LocalBuilder)</target>       </trans-unit>
        <trans-unit id="4167" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stloc">
          <source>ILGenerator.Emit(OpCode, short)</source>
          <target state="translated">ILGenerator.Emit (OpCode, short)</target>       </trans-unit>
        <trans-unit id="4168" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Stloc_0">
          <source>Pops the current value from the top of the evaluation stack and stores it in a the local variable list at index 0.</source>
          <target state="translated">Exibe o valor atual da parte superior da pilha de avaliação e armazena em uma lista de variáveis local no índice 0.</target>       </trans-unit>
        <trans-unit id="4169" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stloc_0">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">A tabela a seguir lista as instruções hexadecimal e formato de assembly do Microsoft Intermediate Language (MSIL), junto com um resumo breve de referência:</target>       </trans-unit>
        <trans-unit id="4170" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stloc_0">
          <source>Format</source>
          <target state="translated">Formatar</target>       </trans-unit>
        <trans-unit id="4171" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stloc_0">
          <source>Assembly Format</source>
          <target state="translated">Formato de assembly</target>       </trans-unit>
        <trans-unit id="4172" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stloc_0">
          <source>Description</source>
          <target state="translated">Descrição</target>       </trans-unit>
        <trans-unit id="4173" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stloc_0">
          <source>0A</source>
          <target state="translated">0A</target>       </trans-unit>
        <trans-unit id="4174" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stloc_0">
          <source>stloc.0</source>
          <target state="translated">stloc.0</target>       </trans-unit>
        <trans-unit id="4175" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stloc_0">
          <source>Pops a value from the stack into local variable 0.</source>
          <target state="translated">Exibe um valor da pilha para variável local 0.</target>       </trans-unit>
        <trans-unit id="4176" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stloc_0">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">O comportamento de transição de pilha, em ordem sequencial, é:</target>       </trans-unit>
        <trans-unit id="4177" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stloc_0">
          <source>A value is popped off of the stack and placed in the local variable indexed by 0.</source>
          <target state="translated">Um valor é exibido fora da pilha e colocado na variável local indexada por 0.</target>       </trans-unit>
        <trans-unit id="4178" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stloc_0">
          <source>The <ph id="ph1">`stloc.0`</ph> instruction pops the top value off the evaluation stack and moves it into the local variable indexed by 0.</source>
          <target state="translated">O <ph id="ph1">`stloc.0`</ph> instrução aparece o valor de nível superior na pilha de avaliação e a move para a variável local indexada por 0.</target>       </trans-unit>
        <trans-unit id="4179" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stloc_0">
          <source>The type of the value must match the type of the local variable as specified in the current method's local signature.</source>
          <target state="translated">O tipo do valor deve corresponder ao tipo da variável local, conforme especificado na assinatura local do método atual.</target>       </trans-unit>
        <trans-unit id="4180" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stloc_0">
          <source><ph id="ph1">`stloc.0`</ph> is an especially efficient encoding for storing values in local variable 0.</source>
          <target state="translated"><ph id="ph1">`stloc.0`</ph> é uma codificação especialmente eficiente para armazenar valores de variável local 0.</target>       </trans-unit>
        <trans-unit id="4181" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stloc_0">
          <source>Storing into locals that hold an integer value smaller than 4 bytes long truncates the value as it moves from the stack to the local variable.</source>
          <target state="translated">Armazenando em locais que contêm um valor inteiro menor que 4 bytes de comprimento trunca o valor conforme avança da pilha para a variável local.</target>       </trans-unit>
        <trans-unit id="4182" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stloc_0">
          <source>Floating-point values are rounded from their native size (type <ph id="ph1">`F`</ph>) to the size associated with the argument.</source>
          <target state="translated">Valores de ponto flutuante são arredondados de seu tamanho nativo (tipo <ph id="ph1">`F`</ph>) para o tamanho associado com o argumento.</target>       </trans-unit>
        <trans-unit id="4183" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stloc_0">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`stloc.0`</ph> opcode:</source>
          <target state="translated">O seguinte <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> sobrecarga de método pode usar o <ph id="ph2">`stloc.0`</ph> opcode:</target>       </trans-unit>
        <trans-unit id="4184" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stloc_0">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="4185" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Stloc_1">
          <source>Pops the current value from the top of the evaluation stack and stores it in a the local variable list at index 1.</source>
          <target state="translated">Exibe o valor atual da parte superior da pilha de avaliação e armazena em uma lista de variáveis local no índice 1.</target>       </trans-unit>
        <trans-unit id="4186" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stloc_1">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">A tabela a seguir lista as instruções hexadecimal e formato de assembly do Microsoft Intermediate Language (MSIL), junto com um resumo breve de referência:</target>       </trans-unit>
        <trans-unit id="4187" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stloc_1">
          <source>Format</source>
          <target state="translated">Formatar</target>       </trans-unit>
        <trans-unit id="4188" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stloc_1">
          <source>Assembly Format</source>
          <target state="translated">Formato de assembly</target>       </trans-unit>
        <trans-unit id="4189" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stloc_1">
          <source>Description</source>
          <target state="translated">Descrição</target>       </trans-unit>
        <trans-unit id="4190" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stloc_1">
          <source>0B</source>
          <target state="translated">0B</target>       </trans-unit>
        <trans-unit id="4191" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stloc_1">
          <source>stloc.1</source>
          <target state="translated">stloc.1</target>       </trans-unit>
        <trans-unit id="4192" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stloc_1">
          <source>Pops a value from the stack into local variable 1.</source>
          <target state="translated">Exibe um valor da pilha em 1 de variável local.</target>       </trans-unit>
        <trans-unit id="4193" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stloc_1">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">O comportamento de transição de pilha, em ordem sequencial, é:</target>       </trans-unit>
        <trans-unit id="4194" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stloc_1">
          <source>A value is popped off of the stack and placed in the local variable indexed by 1.</source>
          <target state="translated">Um valor é exibido fora da pilha e colocado na variável local indexada por 1.</target>       </trans-unit>
        <trans-unit id="4195" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stloc_1">
          <source>The <ph id="ph1">`stloc.1`</ph> instruction pops the top value off the evaluation stack and moves it into the local variable indexed by 1.</source>
          <target state="translated">O <ph id="ph1">`stloc.1`</ph> instrução aparece o valor de nível superior na pilha de avaliação e a move para a variável local indexada por 1.</target>       </trans-unit>
        <trans-unit id="4196" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stloc_1">
          <source>The type of the value must match the type of the local variable as specified in the current method's local signature.</source>
          <target state="translated">O tipo do valor deve corresponder ao tipo da variável local, conforme especificado na assinatura local do método atual.</target>       </trans-unit>
        <trans-unit id="4197" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stloc_1">
          <source><ph id="ph1">`stloc.1`</ph> is an especially efficient encoding for storing values in local variable 1.</source>
          <target state="translated"><ph id="ph1">`stloc.1`</ph> é uma codificação especialmente eficiente para armazenar valores de variável local 1.</target>       </trans-unit>
        <trans-unit id="4198" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stloc_1">
          <source>Storing into locals that hold an integer value smaller than 4 bytes long truncates the value as it moves from the stack to the local variable.</source>
          <target state="translated">Armazenando em locais que contêm um valor inteiro menor que 4 bytes de comprimento trunca o valor conforme avança da pilha para a variável local.</target>       </trans-unit>
        <trans-unit id="4199" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stloc_1">
          <source>Floating-point values are rounded from their native size (type <ph id="ph1">`F`</ph>) to the size associated with the argument.</source>
          <target state="translated">Valores de ponto flutuante são arredondados de seu tamanho nativo (tipo <ph id="ph1">`F`</ph>) para o tamanho associado com o argumento.</target>       </trans-unit>
        <trans-unit id="4200" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stloc_1">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`stloc.1`</ph> opcode:</source>
          <target state="translated">O seguinte <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> sobrecarga de método pode usar o <ph id="ph2">`stloc.1`</ph> opcode:</target>       </trans-unit>
        <trans-unit id="4201" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stloc_1">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="4202" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Stloc_2">
          <source>Pops the current value from the top of the evaluation stack and stores it in a the local variable list at index 2.</source>
          <target state="translated">Exibe o valor atual da parte superior da pilha de avaliação e armazena-o em uma lista de variáveis local no índice 2.</target>       </trans-unit>
        <trans-unit id="4203" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stloc_2">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">A tabela a seguir lista as instruções hexadecimal e formato de assembly do Microsoft Intermediate Language (MSIL), junto com um resumo breve de referência:</target>       </trans-unit>
        <trans-unit id="4204" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stloc_2">
          <source>Format</source>
          <target state="translated">Formatar</target>       </trans-unit>
        <trans-unit id="4205" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stloc_2">
          <source>Assembly Format</source>
          <target state="translated">Formato de assembly</target>       </trans-unit>
        <trans-unit id="4206" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stloc_2">
          <source>Description</source>
          <target state="translated">Descrição</target>       </trans-unit>
        <trans-unit id="4207" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stloc_2">
          <source>0C</source>
          <target state="translated">0C</target>       </trans-unit>
        <trans-unit id="4208" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stloc_2">
          <source>stloc.2</source>
          <target state="translated">stloc.2</target>       </trans-unit>
        <trans-unit id="4209" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stloc_2">
          <source>Pops a value from the stack into local variable 2</source>
          <target state="translated">Aparece um valor da pilha para variável local 2</target>       </trans-unit>
        <trans-unit id="4210" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stloc_2">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">O comportamento de transição de pilha, em ordem sequencial, é:</target>       </trans-unit>
        <trans-unit id="4211" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stloc_2">
          <source>A value is popped off of the stack and placed in the local variable indexed by 2.</source>
          <target state="translated">Um valor é exibido fora da pilha e colocado na variável local indexada por 2.</target>       </trans-unit>
        <trans-unit id="4212" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stloc_2">
          <source>The <ph id="ph1">`stloc.2`</ph> instruction pops the top value off the evaluation stack and moves it into the local variable indexed by 2.</source>
          <target state="translated">O <ph id="ph1">`stloc.2`</ph> instrução aparece o valor de nível superior na pilha de avaliação e a move para a variável local indexada por 2.</target>       </trans-unit>
        <trans-unit id="4213" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stloc_2">
          <source>The type of the value must match the type of the local variable as specified in the current method's local signature.</source>
          <target state="translated">O tipo do valor deve corresponder ao tipo da variável local, conforme especificado na assinatura local do método atual.</target>       </trans-unit>
        <trans-unit id="4214" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stloc_2">
          <source><ph id="ph1">`stloc.2`</ph> is an especially efficient encoding for storing values in local variable 2.</source>
          <target state="translated"><ph id="ph1">`stloc.2`</ph> é uma codificação especialmente eficiente para armazenar valores de variável local 2.</target>       </trans-unit>
        <trans-unit id="4215" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stloc_2">
          <source>Storing into locals that hold an integer value smaller than 4 bytes long truncates the value as it moves from the stack to the local variable.</source>
          <target state="translated">Armazenando em locais que contêm um valor inteiro menor que 4 bytes de comprimento trunca o valor conforme avança da pilha para a variável local.</target>       </trans-unit>
        <trans-unit id="4216" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stloc_2">
          <source>Floating-point values are rounded from their native size (type <ph id="ph1">`F`</ph>) to the size associated with the argument.</source>
          <target state="translated">Valores de ponto flutuante são arredondados de seu tamanho nativo (tipo <ph id="ph1">`F`</ph>) para o tamanho associado com o argumento.</target>       </trans-unit>
        <trans-unit id="4217" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stloc_2">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`stloc.2`</ph> opcode:</source>
          <target state="translated">O seguinte <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> sobrecarga de método pode usar o <ph id="ph2">`stloc.2`</ph> opcode:</target>       </trans-unit>
        <trans-unit id="4218" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stloc_2">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="4219" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Stloc_3">
          <source>Pops the current value from the top of the evaluation stack and stores it in a the local variable list at index 3.</source>
          <target state="translated">Exibe o valor atual da parte superior da pilha de avaliação e armazena-o em uma lista de variáveis local no índice 3.</target>       </trans-unit>
        <trans-unit id="4220" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stloc_3">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">A tabela a seguir lista as instruções hexadecimal e formato de assembly do Microsoft Intermediate Language (MSIL), junto com um resumo breve de referência:</target>       </trans-unit>
        <trans-unit id="4221" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stloc_3">
          <source>Format</source>
          <target state="translated">Formatar</target>       </trans-unit>
        <trans-unit id="4222" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stloc_3">
          <source>Assembly Format</source>
          <target state="translated">Formato de assembly</target>       </trans-unit>
        <trans-unit id="4223" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stloc_3">
          <source>Description</source>
          <target state="translated">Descrição</target>       </trans-unit>
        <trans-unit id="4224" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stloc_3">
          <source>0D</source>
          <target state="translated">0D</target>       </trans-unit>
        <trans-unit id="4225" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stloc_3">
          <source>stloc.3</source>
          <target state="translated">stloc.3</target>       </trans-unit>
        <trans-unit id="4226" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stloc_3">
          <source>Pops a value from the stack into local variable 3</source>
          <target state="translated">Aparece um valor da pilha para variável local 3</target>       </trans-unit>
        <trans-unit id="4227" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stloc_3">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">O comportamento de transição de pilha, em ordem sequencial, é:</target>       </trans-unit>
        <trans-unit id="4228" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stloc_3">
          <source>A value is popped off of the stack and placed in the local variable indexed by 3.</source>
          <target state="translated">Um valor é exibido fora da pilha e colocado na variável local indexada por 3.</target>       </trans-unit>
        <trans-unit id="4229" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stloc_3">
          <source>The <ph id="ph1">`stloc.3`</ph> instruction pops the top value off the evaluation stack and moves it into the local variable indexed by 3.</source>
          <target state="translated">O <ph id="ph1">`stloc.3`</ph> instrução aparece o valor de nível superior na pilha de avaliação e a move para a variável local indexada por 3.</target>       </trans-unit>
        <trans-unit id="4230" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stloc_3">
          <source>The type of the value must match the type of the local variable as specified in the current method's local signature.</source>
          <target state="translated">O tipo do valor deve corresponder ao tipo da variável local, conforme especificado na assinatura local do método atual.</target>       </trans-unit>
        <trans-unit id="4231" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stloc_3">
          <source><ph id="ph1">`stloc.3`</ph> is an especially efficient encoding for storing values in local variable 3.</source>
          <target state="translated"><ph id="ph1">`stloc.3`</ph> é uma codificação especialmente eficiente para armazenar valores em 3 de variável local.</target>       </trans-unit>
        <trans-unit id="4232" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stloc_3">
          <source>Storing into locals that hold an integer value smaller than 4 bytes long truncates the value as it moves from the stack to the local variable.</source>
          <target state="translated">Armazenando em locais que contêm um valor inteiro menor que 4 bytes de comprimento trunca o valor conforme avança da pilha para a variável local.</target>       </trans-unit>
        <trans-unit id="4233" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stloc_3">
          <source>Floating-point values are rounded from their native size (type <ph id="ph1">`F`</ph>) to the size associated with the argument.</source>
          <target state="translated">Valores de ponto flutuante são arredondados de seu tamanho nativo (tipo <ph id="ph1">`F`</ph>) para o tamanho associado com o argumento.</target>       </trans-unit>
        <trans-unit id="4234" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stloc_3">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`stloc.3`</ph> opcode:</source>
          <target state="translated">O seguinte <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> sobrecarga de método pode usar o <ph id="ph2">`stloc.3`</ph> opcode:</target>       </trans-unit>
        <trans-unit id="4235" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stloc_3">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="4236" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Stloc_S">
          <source>Pops the current value from the top of the evaluation stack and stores it in a the local variable list at <ph id="ph1">&lt;paramref name="index" /&gt;</ph> (short form).</source>
          <target state="translated">Exibe o valor atual da parte superior da pilha de avaliação e o armazena em uma lista de variáveis locais em <ph id="ph1">&lt;paramref name="index" /&gt;</ph> (forma abreviada).</target>       </trans-unit>
        <trans-unit id="4237" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stloc_S">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">A tabela a seguir lista as instruções hexadecimal e formato de assembly do Microsoft Intermediate Language (MSIL), junto com um resumo breve de referência:</target>       </trans-unit>
        <trans-unit id="4238" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stloc_S">
          <source>Format</source>
          <target state="translated">Formatar</target>       </trans-unit>
        <trans-unit id="4239" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stloc_S">
          <source>Assembly Format</source>
          <target state="translated">Formato de assembly</target>       </trans-unit>
        <trans-unit id="4240" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stloc_S">
          <source>Description</source>
          <target state="translated">Descrição</target>       </trans-unit>
        <trans-unit id="4241" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stloc_S">
          <source>13 &lt; <ph id="ph1">`unsigned int8`</ph><ph id="ph2"> &gt;</ph></source>
          <target state="translated">13 &lt; <ph id="ph1">`unsigned int8`</ph><ph id="ph2"> &gt;</ph></target>       </trans-unit>
        <trans-unit id="4242" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stloc_S">
          <source>stloc.s <ph id="ph1">`index`</ph></source>
          <target state="translated">stloc.s <ph id="ph1">`index`</ph></target>       </trans-unit>
        <trans-unit id="4243" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stloc_S">
          <source>Pops a value from the stack and stores it in local variable <ph id="ph1">`index`</ph>, short form.</source>
          <target state="translated">Aparece um valor da pilha e a armazena na variável local <ph id="ph1">`index`</ph>, forma abreviada.</target>       </trans-unit>
        <trans-unit id="4244" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stloc_S">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">O comportamento de transição de pilha, em ordem sequencial, é:</target>       </trans-unit>
        <trans-unit id="4245" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stloc_S">
          <source>A value is popped off of the stack and placed in local variable <ph id="ph1">`index`</ph>.</source>
          <target state="translated">Um valor é exibido fora da pilha e colocado na variável local <ph id="ph1">`index`</ph>.</target>       </trans-unit>
        <trans-unit id="4246" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stloc_S">
          <source>The <ph id="ph1">`stloc.s`</ph> instruction pops the top value off the evaluation stack and moves it into local variable number <ph id="ph2">`index`</ph>, where local variables are numbered 0 onwards.</source>
          <target state="translated">O <ph id="ph1">`stloc.s`</ph> instrução aparece o valor de nível superior na pilha de avaliação e a move para o número de variável local <ph id="ph2">`index`</ph>, onde as variáveis locais são numerados de 0 em diante.</target>       </trans-unit>
        <trans-unit id="4247" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stloc_S">
          <source>The type of the value must match the type of the local variable as specified in the current method's local signature.</source>
          <target state="translated">O tipo do valor deve corresponder ao tipo da variável local, conforme especificado na assinatura local do método atual.</target>       </trans-unit>
        <trans-unit id="4248" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stloc_S">
          <source>The <ph id="ph1">`stloc.s`</ph> instruction provides an efficient encoding for local variables 0 through 255.</source>
          <target state="translated">O <ph id="ph1">`stloc.s`</ph> instrução fornece uma codificação eficiente para variáveis locais 0 a 255.</target>       </trans-unit>
        <trans-unit id="4249" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stloc_S">
          <source>Storing into locals that hold an integer value smaller than 4 bytes long truncates the value as it moves from the stack to the local variable.</source>
          <target state="translated">Armazenando em locais que contêm um valor inteiro menor que 4 bytes de comprimento trunca o valor conforme avança da pilha para a variável local.</target>       </trans-unit>
        <trans-unit id="4250" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stloc_S">
          <source>Floating-point values are rounded from their native size (type <ph id="ph1">`F`</ph>) to the size associated with the argument.</source>
          <target state="translated">Valores de ponto flutuante são arredondados de seu tamanho nativo (tipo <ph id="ph1">`F`</ph>) para o tamanho associado com o argumento.</target>       </trans-unit>
        <trans-unit id="4251" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stloc_S">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overloads can use the <ph id="ph2">`stloc.s`</ph> opcode:</source>
          <target state="translated">O seguinte <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> sobrecargas de método podem usar o <ph id="ph2">`stloc.s`</ph> opcode:</target>       </trans-unit>
        <trans-unit id="4252" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stloc_S">
          <source>ILGenerator.Emit(OpCode, LocalBuilder)</source>
          <target state="translated">ILGenerator.Emit(OpCode, LocalBuilder)</target>       </trans-unit>
        <trans-unit id="4253" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stloc_S">
          <source>ILGenerator.Emit(OpCode, byte)</source>
          <target state="translated">ILGenerator.Emit (OpCode, byte)</target>       </trans-unit>
        <trans-unit id="4254" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Stobj">
          <source>Copies a value of a specified type from the evaluation stack into a supplied memory address.</source>
          <target state="translated">Copia um valor do tipo especificado da pilha de avaliação para um endereço de memória fornecido.</target>       </trans-unit>
        <trans-unit id="4255" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stobj">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">A tabela a seguir lista as instruções hexadecimal e formato de assembly do Microsoft Intermediate Language (MSIL), junto com um resumo breve de referência:</target>       </trans-unit>
        <trans-unit id="4256" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stobj">
          <source>Format</source>
          <target state="translated">Formatar</target>       </trans-unit>
        <trans-unit id="4257" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stobj">
          <source>Assembly Format</source>
          <target state="translated">Formato de assembly</target>       </trans-unit>
        <trans-unit id="4258" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stobj">
          <source>Description</source>
          <target state="translated">Descrição</target>       </trans-unit>
        <trans-unit id="4259" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stobj">
          <source>81 &lt; <ph id="ph1">`T`</ph><ph id="ph2"> &gt;</ph></source>
          <target state="translated">81 &lt; <ph id="ph1">`T`</ph><ph id="ph2"> &gt;</ph></target>       </trans-unit>
        <trans-unit id="4260" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stobj">
          <source>stobj <ph id="ph1">`class`</ph></source>
          <target state="translated">stobj <ph id="ph1">`class`</ph></target>       </trans-unit>
        <trans-unit id="4261" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stobj">
          <source>Stores a value of type <ph id="ph1">`class`</ph> from the stack into memory.</source>
          <target state="translated">Armazena um valor do tipo <ph id="ph1">`class`</ph> da pilha na memória.</target>       </trans-unit>
        <trans-unit id="4262" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stobj">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">O comportamento de transição de pilha, em ordem sequencial, é:</target>       </trans-unit>
        <trans-unit id="4263" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stobj">
          <source>An address is pushed onto the stack.</source>
          <target state="translated">Um endereço é inserido na pilha.</target>       </trans-unit>
        <trans-unit id="4264" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stobj">
          <source>A value type object of type <ph id="ph1">`class`</ph> is pushed onto the stack.</source>
          <target state="translated">Um objeto de tipo de valor do tipo <ph id="ph1">`class`</ph> é inserido na pilha.</target>       </trans-unit>
        <trans-unit id="4265" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stobj">
          <source>The object and the address are popped from the stack; the value type object is stored at the address.</source>
          <target state="translated">O objeto e o endereço são disparados da pilha; o objeto de tipo de valor é armazenado no endereço.</target>       </trans-unit>
        <trans-unit id="4266" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stobj">
          <source>The <ph id="ph1">`stobj`</ph> instruction copies the value type object into the address specified by the address (a pointer of type <ph id="ph2">`native int`</ph>, <ph id="ph3">`*`</ph>, or <ph id="ph4">`&amp;`</ph>).</source>
          <target state="translated">O <ph id="ph1">`stobj`</ph> instrução copia o objeto de tipo de valor para o endereço especificado pelo endereço (um ponteiro de tipo <ph id="ph2">`native int`</ph>, <ph id="ph3">`*`</ph>, ou <ph id="ph4">`&amp;`</ph>).</target>       </trans-unit>
        <trans-unit id="4267" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stobj">
          <source>The number of bytes copied depends on the size of the class represented by <ph id="ph1">`class`</ph>, a metadata token representing a value type.</source>
          <target state="translated">O número de bytes copiados depende do tamanho da classe representada pelo <ph id="ph1">`class`</ph>, um token de metadados que representa um tipo de valor.</target>       </trans-unit>
        <trans-unit id="4268" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stobj">
          <source>The operation of the <ph id="ph1">`stobj`</ph> instruction can be altered by an immediately preceding <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Volatile&gt;</ph> or <ph id="ph3">&lt;xref:System.Reflection.Emit.OpCodes.Unaligned&gt;</ph> prefix instruction.</source>
          <target state="translated">A operação do <ph id="ph1">`stobj`</ph> instrução pode ser alterada por um imediatamente anterior <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Volatile&gt;</ph> ou <ph id="ph3">&lt;xref:System.Reflection.Emit.OpCodes.Unaligned&gt;</ph> prefixo instrução.</target>       </trans-unit>
        <trans-unit id="4269" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stobj">
          <source><ph id="ph1">&lt;xref:System.TypeLoadException&gt;</ph> is thrown if class cannot be found.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.TypeLoadException&gt;</ph> é gerada se a classe não pode ser encontrada.</target>       </trans-unit>
        <trans-unit id="4270" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stobj">
          <source>This is typically detected when Microsoft Intermediate Language (MSIL) instructions are converted to native code rather than at run time.</source>
          <target state="translated">Normalmente, isso é detectado quando instruções Microsoft Intermediate Language (MSIL) são convertidas em código nativo em vez de em tempo de execução.</target>       </trans-unit>
        <trans-unit id="4271" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stobj">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`stobj`</ph> opcode:</source>
          <target state="translated">O seguinte <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> sobrecarga de método pode usar o <ph id="ph2">`stobj`</ph> opcode:</target>       </trans-unit>
        <trans-unit id="4272" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stobj">
          <source>ILGenerator.Emit(OpCode, Type)</source>
          <target state="translated">ILGenerator.Emit(OpCode, Type)</target>       </trans-unit>
        <trans-unit id="4273" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Stsfld">
          <source>Replaces the value of a static field with a value from the evaluation stack.</source>
          <target state="translated">Substitui o valor de um campo estático por um valor da pilha de avaliação.</target>       </trans-unit>
        <trans-unit id="4274" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stsfld">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">A tabela a seguir lista as instruções hexadecimal e formato de assembly do Microsoft Intermediate Language (MSIL), junto com um resumo breve de referência:</target>       </trans-unit>
        <trans-unit id="4275" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stsfld">
          <source>Format</source>
          <target state="translated">Formatar</target>       </trans-unit>
        <trans-unit id="4276" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stsfld">
          <source>Assembly Format</source>
          <target state="translated">Formato de assembly</target>       </trans-unit>
        <trans-unit id="4277" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stsfld">
          <source>Description</source>
          <target state="translated">Descrição</target>       </trans-unit>
        <trans-unit id="4278" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stsfld">
          <source>80 &lt; <ph id="ph1">`T`</ph><ph id="ph2"> &gt;</ph></source>
          <target state="translated">80 &lt; <ph id="ph1">`T`</ph><ph id="ph2"> &gt;</ph></target>       </trans-unit>
        <trans-unit id="4279" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stsfld">
          <source>stsfld <ph id="ph1">`field`</ph></source>
          <target state="translated">stsfld <ph id="ph1">`field`</ph></target>       </trans-unit>
        <trans-unit id="4280" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stsfld">
          <source>Replaces the value in <ph id="ph1">`field`</ph> with a supplied value.</source>
          <target state="translated">Substitui o valor em <ph id="ph1">`field`</ph> com um valor fornecido.</target>       </trans-unit>
        <trans-unit id="4281" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stsfld">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">O comportamento de transição de pilha, em ordem sequencial, é:</target>       </trans-unit>
        <trans-unit id="4282" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stsfld">
          <source>A value is pushed onto the stack.</source>
          <target state="translated">Um valor é inserido na pilha.</target>       </trans-unit>
        <trans-unit id="4283" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stsfld">
          <source>A value is popped from the stack and stored in <ph id="ph1">`field`</ph>.</source>
          <target state="translated">Um valor é exibido da pilha e armazenado em <ph id="ph1">`field`</ph>.</target>       </trans-unit>
        <trans-unit id="4284" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stsfld">
          <source>The <ph id="ph1">`stsfld`</ph> instruction replaces the value of a static field with a value from the stack.</source>
          <target state="translated">O <ph id="ph1">`stsfld`</ph> instrução substitui o valor de um campo estático com um valor da pilha.</target>       </trans-unit>
        <trans-unit id="4285" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stsfld">
          <source><ph id="ph1">`field`</ph> is a metadata token that must refer to a static field member.</source>
          <target state="translated"><ph id="ph1">`field`</ph> é um token de metadados que deve se referir a um membro do campo estático.</target>       </trans-unit>
        <trans-unit id="4286" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stsfld">
          <source>The <ph id="ph1">`stsfld`</ph> instruction may be prefixed by <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Volatile&gt;</ph>.</source>
          <target state="translated">O <ph id="ph1">`stsfld`</ph> instruções podem ser prefixadas pelo <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Volatile&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="4287" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stsfld">
          <source><ph id="ph1">&lt;xref:System.MissingFieldException&gt;</ph> is thrown if field is not found in the metadata.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.MissingFieldException&gt;</ph> é gerada se o campo não for encontrado nos metadados.</target>       </trans-unit>
        <trans-unit id="4288" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stsfld">
          <source>This is typically checked when Microsoft Intermediate Language (MSIL) instructions are converted to native code, not at run time.</source>
          <target state="translated">Normalmente, isso é verificado quando instruções Microsoft Intermediate Language (MSIL) são convertidas em código nativo, não em tempo de execução.</target>       </trans-unit>
        <trans-unit id="4289" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stsfld">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`stsfld`</ph> opcode:</source>
          <target state="translated">O seguinte <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> sobrecarga de método pode usar o <ph id="ph2">`stsfld`</ph> opcode:</target>       </trans-unit>
        <trans-unit id="4290" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stsfld">
          <source>ILGenerator.Emit(OpCode, FieldInfo)</source>
          <target state="translated">ILGenerator.Emit(OpCode, FieldInfo)</target>       </trans-unit>
        <trans-unit id="4291" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Sub">
          <source>Subtracts one value from another and pushes the result onto the evaluation stack.</source>
          <target state="translated">Subtrai um valor de outro e efetua o push do resultado para a pilha de avaliação.</target>       </trans-unit>
        <trans-unit id="4292" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Sub">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">A tabela a seguir lista as instruções hexadecimal e formato de assembly do Microsoft Intermediate Language (MSIL), junto com um resumo breve de referência:</target>       </trans-unit>
        <trans-unit id="4293" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Sub">
          <source>Format</source>
          <target state="translated">Formatar</target>       </trans-unit>
        <trans-unit id="4294" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Sub">
          <source>Assembly Format</source>
          <target state="translated">Formato de assembly</target>       </trans-unit>
        <trans-unit id="4295" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Sub">
          <source>Description</source>
          <target state="translated">Descrição</target>       </trans-unit>
        <trans-unit id="4296" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Sub">
          <source>59</source>
          <target state="translated">59</target>       </trans-unit>
        <trans-unit id="4297" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Sub">
          <source>sub</source>
          <target state="translated">sub</target>       </trans-unit>
        <trans-unit id="4298" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Sub">
          <source>Subtracts one value from another, returning a new numeric value.</source>
          <target state="translated">Subtrai um valor de outro, retornando um novo valor numérico.</target>       </trans-unit>
        <trans-unit id="4299" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Sub">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">O comportamento de transição de pilha, em ordem sequencial, é:</target>       </trans-unit>
        <trans-unit id="4300" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Sub">
          <source><ph id="ph1">`value1`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value1`</ph> é inserido na pilha.</target>       </trans-unit>
        <trans-unit id="4301" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Sub">
          <source><ph id="ph1">`value2`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value2`</ph> é inserido na pilha.</target>       </trans-unit>
        <trans-unit id="4302" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Sub">
          <source><ph id="ph1">`value2`</ph> and <ph id="ph2">`value1`</ph> are popped from the stack; <ph id="ph3">`value2`</ph> is subtracted from <ph id="ph4">`value1`</ph>.</source>
          <target state="translated"><ph id="ph1">`value2`</ph> e <ph id="ph2">`value1`</ph> são disparados da pilha; <ph id="ph3">`value2`</ph> é subtraído de <ph id="ph4">`value1`</ph>.</target>       </trans-unit>
        <trans-unit id="4303" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Sub">
          <source>The result is pushed onto the stack.</source>
          <target state="translated">O resultado é inserido na pilha.</target>       </trans-unit>
        <trans-unit id="4304" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Sub">
          <source>Overflow is not detected for integer operations (for proper overflow handling, see <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Sub_Ovf&gt;</ph>).</source>
          <target state="translated">Estouro não é detectado para operações de inteiro (para manipulação de estouro adequada, consulte <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Sub_Ovf&gt;</ph>).</target>       </trans-unit>
        <trans-unit id="4305" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Sub">
          <source>Integer subtraction wraps, rather than saturates.</source>
          <target state="translated">Subtração de inteiro é quebrada, em vez de esteja saturado.</target>       </trans-unit>
        <trans-unit id="4306" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Sub">
          <source>For example: assuming 8-bit integers, where <ph id="ph1">`value1`</ph> is set to 0 and <ph id="ph2">`value2`</ph> is set to 1, the "wrapped" result will be 255.</source>
          <target state="translated">Por exemplo: supondo inteiros de 8 bits, onde <ph id="ph1">`value1`</ph> é definido como 0 e <ph id="ph2">`value2`</ph> é definido como 1, o resultado "encapsulado" será 255.</target>       </trans-unit>
        <trans-unit id="4307" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Sub">
          <source>Floating-point overflow returns <ph id="ph1">`+inf`</ph> (<ph id="ph2">`PositiveInfinity`</ph>) or <ph id="ph3">`-inf`</ph> (<ph id="ph4">`NegativeInfinity`</ph>).</source>
          <target state="translated">Estouro de ponto flutuante retorna <ph id="ph1">`+inf`</ph> (<ph id="ph2">`PositiveInfinity`</ph>) ou <ph id="ph3">`-inf`</ph> (<ph id="ph4">`NegativeInfinity`</ph>).</target>       </trans-unit>
        <trans-unit id="4308" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Sub">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`sub`</ph> opcode:</source>
          <target state="translated">O seguinte <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> sobrecarga de método pode usar o <ph id="ph2">`sub`</ph> opcode:</target>       </trans-unit>
        <trans-unit id="4309" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Sub">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="4310" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Sub_Ovf">
          <source>Subtracts one integer value from another, performs an overflow check, and pushes the result onto the evaluation stack.</source>
          <target state="translated">Subtrai um valor de inteiro de outro, executa uma verificação de estouro e efetua o push do resultado para a pilha de avaliação.</target>       </trans-unit>
        <trans-unit id="4311" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Sub_Ovf">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">A tabela a seguir lista as instruções hexadecimal e formato de assembly do Microsoft Intermediate Language (MSIL), junto com um resumo breve de referência:</target>       </trans-unit>
        <trans-unit id="4312" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Sub_Ovf">
          <source>Format</source>
          <target state="translated">Formatar</target>       </trans-unit>
        <trans-unit id="4313" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Sub_Ovf">
          <source>Assembly Format</source>
          <target state="translated">Formato de assembly</target>       </trans-unit>
        <trans-unit id="4314" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Sub_Ovf">
          <source>Description</source>
          <target state="translated">Descrição</target>       </trans-unit>
        <trans-unit id="4315" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Sub_Ovf">
          <source>DA</source>
          <target state="translated">DA</target>       </trans-unit>
        <trans-unit id="4316" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Sub_Ovf">
          <source>sub.ovf</source>
          <target state="translated">sub.ovf</target>       </trans-unit>
        <trans-unit id="4317" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Sub_Ovf">
          <source>Subtracts one integer value from another with an overflow check.</source>
          <target state="translated">Subtrai um valor de inteiro de outro com uma verificação de estouro.</target>       </trans-unit>
        <trans-unit id="4318" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Sub_Ovf">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">O comportamento de transição de pilha, em ordem sequencial, é:</target>       </trans-unit>
        <trans-unit id="4319" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Sub_Ovf">
          <source><ph id="ph1">`value1`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value1`</ph> é inserido na pilha.</target>       </trans-unit>
        <trans-unit id="4320" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Sub_Ovf">
          <source><ph id="ph1">`value2`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value2`</ph> é inserido na pilha.</target>       </trans-unit>
        <trans-unit id="4321" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Sub_Ovf">
          <source><ph id="ph1">`value2`</ph> and <ph id="ph2">`value1`</ph> are popped from the stack; <ph id="ph3">`value2`</ph> is subtracted from <ph id="ph4">`value1`</ph> with a check for overflow.</source>
          <target state="translated"><ph id="ph1">`value2`</ph> e <ph id="ph2">`value1`</ph> são disparados da pilha; <ph id="ph3">`value2`</ph> é subtraído de <ph id="ph4">`value1`</ph> com uma verificação de estouro.</target>       </trans-unit>
        <trans-unit id="4322" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Sub_Ovf">
          <source>The result is pushed onto the stack.</source>
          <target state="translated">O resultado é inserido na pilha.</target>       </trans-unit>
        <trans-unit id="4323" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Sub_Ovf">
          <source><ph id="ph1">&lt;xref:System.OverflowException&gt;</ph> is thrown if the result can not be represented in the result type.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.OverflowException&gt;</ph> é gerada se o resultado não pode ser representado no tipo de resultado.</target>       </trans-unit>
        <trans-unit id="4324" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Sub_Ovf">
          <source>This operation is performed on signed integers; for floating-point values, use <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Sub&gt;</ph>.</source>
          <target state="translated">Esta operação é executada em inteiros com sinal; para valores de ponto flutuantes, use <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Sub&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="4325" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Sub_Ovf">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`sub.ovf`</ph> opcode:</source>
          <target state="translated">O seguinte <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> sobrecarga de método pode usar o <ph id="ph2">`sub.ovf`</ph> opcode:</target>       </trans-unit>
        <trans-unit id="4326" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Sub_Ovf">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="4327" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Sub_Ovf_Un">
          <source>Subtracts one unsigned integer value from another, performs an overflow check, and pushes the result onto the evaluation stack.</source>
          <target state="translated">Subtrai um valor de inteiro sem sinal de outro, executa uma verificação de estouro e efetua o push do resultado para a pilha de avaliação.</target>       </trans-unit>
        <trans-unit id="4328" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Sub_Ovf_Un">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">A tabela a seguir lista as instruções hexadecimal e formato de assembly do Microsoft Intermediate Language (MSIL), junto com um resumo breve de referência:</target>       </trans-unit>
        <trans-unit id="4329" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Sub_Ovf_Un">
          <source>Format</source>
          <target state="translated">Formatar</target>       </trans-unit>
        <trans-unit id="4330" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Sub_Ovf_Un">
          <source>Assembly Format</source>
          <target state="translated">Formato de assembly</target>       </trans-unit>
        <trans-unit id="4331" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Sub_Ovf_Un">
          <source>Description</source>
          <target state="translated">Descrição</target>       </trans-unit>
        <trans-unit id="4332" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Sub_Ovf_Un">
          <source>DB</source>
          <target state="translated">DB</target>       </trans-unit>
        <trans-unit id="4333" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Sub_Ovf_Un">
          <source>sub.ovf.un</source>
          <target state="translated">sub.ovf.un</target>       </trans-unit>
        <trans-unit id="4334" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Sub_Ovf_Un">
          <source>Subtracts one unsigned integer value from another with an overflow check.</source>
          <target state="translated">Subtrai um valor de inteiro não assinado de outro com uma verificação de estouro.</target>       </trans-unit>
        <trans-unit id="4335" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Sub_Ovf_Un">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">O comportamento de transição de pilha, em ordem sequencial, é:</target>       </trans-unit>
        <trans-unit id="4336" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Sub_Ovf_Un">
          <source><ph id="ph1">`value1`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value1`</ph> é inserido na pilha.</target>       </trans-unit>
        <trans-unit id="4337" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Sub_Ovf_Un">
          <source><ph id="ph1">`value2`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value2`</ph> é inserido na pilha.</target>       </trans-unit>
        <trans-unit id="4338" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Sub_Ovf_Un">
          <source><ph id="ph1">`value2`</ph> and <ph id="ph2">`value1`</ph> are popped from the stack; <ph id="ph3">`value2`</ph> is subtracted from <ph id="ph4">`value1`</ph> with a check for overflow.</source>
          <target state="translated"><ph id="ph1">`value2`</ph> e <ph id="ph2">`value1`</ph> são disparados da pilha; <ph id="ph3">`value2`</ph> é subtraído de <ph id="ph4">`value1`</ph> com uma verificação de estouro.</target>       </trans-unit>
        <trans-unit id="4339" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Sub_Ovf_Un">
          <source>The result is pushed onto the stack.</source>
          <target state="translated">O resultado é inserido na pilha.</target>       </trans-unit>
        <trans-unit id="4340" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Sub_Ovf_Un">
          <source><ph id="ph1">&lt;xref:System.OverflowException&gt;</ph> is thrown if the result can not be represented in the result type.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.OverflowException&gt;</ph> é gerada se o resultado não pode ser representado no tipo de resultado.</target>       </trans-unit>
        <trans-unit id="4341" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Sub_Ovf_Un">
          <source>This operation is performed on signed integers; for floating-point values, use <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Sub&gt;</ph>.</source>
          <target state="translated">Esta operação é executada em inteiros com sinal; para valores de ponto flutuantes, use <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Sub&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="4342" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Sub_Ovf_Un">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`sub.ovf.un`</ph> opcode:</source>
          <target state="translated">O seguinte <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> sobrecarga de método pode usar o <ph id="ph2">`sub.ovf.un`</ph> opcode:</target>       </trans-unit>
        <trans-unit id="4343" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Sub_Ovf_Un">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="4344" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Switch">
          <source>Implements a jump table.</source>
          <target state="translated">Implementa uma tabela de atalhos.</target>       </trans-unit>
        <trans-unit id="4345" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Switch">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">A tabela a seguir lista as instruções hexadecimal e formato de assembly do Microsoft Intermediate Language (MSIL), junto com um resumo breve de referência:</target>       </trans-unit>
        <trans-unit id="4346" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Switch">
          <source>Format</source>
          <target state="translated">Formatar</target>       </trans-unit>
        <trans-unit id="4347" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Switch">
          <source>Assembly Format</source>
          <target state="translated">Formato de assembly</target>       </trans-unit>
        <trans-unit id="4348" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Switch">
          <source>Description</source>
          <target state="translated">Descrição</target>       </trans-unit>
        <trans-unit id="4349" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Switch">
          <source>45 &lt; <ph id="ph1">`unsigned int32`</ph> &gt; &lt; <ph id="ph2">`int32`</ph> &gt;... &lt; <ph id="ph3">`int32`</ph><ph id="ph4"> &gt;</ph></source>
          <target state="translated">45 &lt; <ph id="ph1">`unsigned int32`</ph> &gt; &lt; <ph id="ph2">`int32`</ph> &gt;... &lt; <ph id="ph3">`int32`</ph><ph id="ph4"> &gt;</ph></target>       </trans-unit>
        <trans-unit id="4350" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Switch">
          <source>switch (<ph id="ph1">`N`</ph>, <ph id="ph2">`t1`</ph>, <ph id="ph3">`t2`</ph>... <ph id="ph4">`tN`</ph>)</source>
          <target state="translated">switch (<ph id="ph1">`N`</ph>, <ph id="ph2">`t1`</ph>, <ph id="ph3">`t2`</ph>... <ph id="ph4">`tN`</ph>)</target>       </trans-unit>
        <trans-unit id="4351" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Switch">
          <source>Jumps to one of <ph id="ph1">`N`</ph> values.</source>
          <target state="translated">Vai para um dos <ph id="ph1">`N`</ph> valores.</target>       </trans-unit>
        <trans-unit id="4352" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Switch">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">O comportamento de transição de pilha, em ordem sequencial, é:</target>       </trans-unit>
        <trans-unit id="4353" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Switch">
          <source>A value is pushed onto the stack.</source>
          <target state="translated">Um valor é inserido na pilha.</target>       </trans-unit>
        <trans-unit id="4354" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Switch">
          <source>The value is popped off the stack and execution is transferred to the instruction at the offset indexed by the value, where the value is less than <ph id="ph1">`N`</ph>.</source>
          <target state="translated">O valor é retirado da pilha e a execução será transferida para a instrução no deslocamento indexado por valor, onde o valor é menor que <ph id="ph1">`N`</ph>.</target>       </trans-unit>
        <trans-unit id="4355" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Switch">
          <source>The <ph id="ph1">`switch`</ph> instruction implements a jump table.</source>
          <target state="translated">O <ph id="ph1">`switch`</ph> instrução implementa uma tabela de salto.</target>       </trans-unit>
        <trans-unit id="4356" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Switch">
          <source>The format of the instruction is an <ph id="ph1">`unsigned int32`</ph> representing the number of targets <ph id="ph2">`N`</ph>, followed by <ph id="ph3">`N`</ph> int32 values specifying jump targets.</source>
          <target state="translated">O formato da instrução é um <ph id="ph1">`unsigned int32`</ph> que representa o número de destinos <ph id="ph2">`N`</ph>, seguido por <ph id="ph3">`N`</ph> valores int32 especificando destinos de salto.</target>       </trans-unit>
        <trans-unit id="4357" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Switch">
          <source>These targets are represented as offsets (positive or negative) from the beginning of the instruction following this <ph id="ph1">`switch`</ph> instruction.</source>
          <target state="translated">Esses destinos são representados como deslocamentos (positivos ou negativos) desde o início da instrução a seguir isso <ph id="ph1">`switch`</ph> instrução.</target>       </trans-unit>
        <trans-unit id="4358" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Switch">
          <source>The <ph id="ph1">`switch`</ph> instruction pops a value off the stack and compares it, as an unsigned integer, to <ph id="ph2">`N`</ph>.</source>
          <target state="translated">O <ph id="ph1">`switch`</ph> instrução aparece um valor da pilha e o compara, como um inteiro sem sinal, como <ph id="ph2">`N`</ph>.</target>       </trans-unit>
        <trans-unit id="4359" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Switch">
          <source>If value is less than <ph id="ph1">`N`</ph>, execution is transferred to the target indexed by value, where targets are numbered from 0 (for example, a value of 0 takes the first target, a value of 1 takes the second target, and so on).</source>
          <target state="translated">Se o valor é menor que <ph id="ph1">`N`</ph>, a execução será transferida para o destino indexado por valor, em que os destinos são numerados de 0 (por exemplo, o primeiro destino entra em um valor de 0, um valor 1 faz o destino de segundo e assim por diante).</target>       </trans-unit>
        <trans-unit id="4360" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Switch">
          <source>If the value is greater than or equal to <ph id="ph1">`N`</ph>, execution continues at the next instruction (fall through).</source>
          <target state="translated">Se o valor for maior que ou igual a <ph id="ph1">`N`</ph>, a execução continua na próxima instrução (falha).</target>       </trans-unit>
        <trans-unit id="4361" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Switch">
          <source>If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</source>
          <target state="translated">Se a instrução de destino tem um ou mais códigos de prefixo, o controle só pode ser transferido para o primeiro desses prefixos.</target>       </trans-unit>
        <trans-unit id="4362" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Switch">
          <source>Control transfers into and out of <ph id="ph1">`try`</ph>, <ph id="ph2">`catch`</ph>, <ph id="ph3">`filter`</ph>, and <ph id="ph4">`finally`</ph> blocks cannot be performed by this instruction.</source>
          <target state="translated">O controle transfere dentro e fora do <ph id="ph1">`try`</ph>, <ph id="ph2">`catch`</ph>, <ph id="ph3">`filter`</ph>, e <ph id="ph4">`finally`</ph> blocos não podem ser executados por essa instrução.</target>       </trans-unit>
        <trans-unit id="4363" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Switch">
          <source>(Such transfers are severely restricted and must use the leave instruction instead).</source>
          <target state="translated">(Essas transferências são restritas severos em devem usar a instrução de licença em vez disso).</target>       </trans-unit>
        <trans-unit id="4364" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Switch">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`switch`</ph> opcode.</source>
          <target state="translated">O seguinte <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> sobrecarga de método pode usar o <ph id="ph2">`switch`</ph> opcode.</target>       </trans-unit>
        <trans-unit id="4365" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Switch">
          <source>The <ph id="ph1">`Label[]`</ph> argument is an array of Labels representing 32-bit offsets.</source>
          <target state="translated">O <ph id="ph1">`Label[]`</ph> argumento é uma matriz dos rótulos que representa os deslocamentos de 32 bits.</target>       </trans-unit>
        <trans-unit id="4366" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Switch">
          <source>ILGenerator.Emit(OpCode, Label[])</source>
          <target state="translated">ILGenerator.Emit(OpCode, Label[])</target>       </trans-unit>
        <trans-unit id="4367" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Switch">
          <source>The following code sample illustrates the use of the <ph id="ph1">`Switch`</ph> opcode to generate a jump table using an array of <ph id="ph2">&lt;xref:System.Reflection.Emit.Label&gt;</ph>.</source>
          <target state="translated">O exemplo de código a seguir ilustra o uso do <ph id="ph1">`Switch`</ph> opcode para gerar uma tabela de salto usando uma matriz de <ph id="ph2">&lt;xref:System.Reflection.Emit.Label&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="4368" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Tailcall">
          <source>Performs a postfixed method call instruction such that the current method's stack frame is removed before the actual call instruction is executed.</source>
          <target state="translated">Executa uma instrução de chamada de método pós-fixada, de modo que o registro de ativação do método atual é removido antes da execução da instrução de chamada real.</target>       </trans-unit>
        <trans-unit id="4369" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Tailcall">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">A tabela a seguir lista as instruções hexadecimal e formato de assembly do Microsoft Intermediate Language (MSIL), junto com um resumo breve de referência:</target>       </trans-unit>
        <trans-unit id="4370" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Tailcall">
          <source>Format</source>
          <target state="translated">Formatar</target>       </trans-unit>
        <trans-unit id="4371" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Tailcall">
          <source>Assembly Format</source>
          <target state="translated">Formato de assembly</target>       </trans-unit>
        <trans-unit id="4372" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Tailcall">
          <source>Description</source>
          <target state="translated">Descrição</target>       </trans-unit>
        <trans-unit id="4373" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Tailcall">
          <source>FE 14</source>
          <target state="translated">FE 14</target>       </trans-unit>
        <trans-unit id="4374" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Tailcall">
          <source>tail.</source>
          <target state="translated">final.</target>       </trans-unit>
        <trans-unit id="4375" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Tailcall">
          <source>Subsequent call terminates current methods</source>
          <target state="translated">Chamada subsequente encerra métodos atuais</target>       </trans-unit>
        <trans-unit id="4376" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Tailcall">
          <source>There is no stack transition behavior defined for this instruction.</source>
          <target state="translated">Há um comportamento de transição de pilha definido para essa instrução.</target>       </trans-unit>
        <trans-unit id="4377" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Tailcall">
          <source>The <ph id="ph1">`tail`</ph> prefix instruction must immediately precede a <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Call&gt;</ph>, <ph id="ph3">&lt;xref:System.Reflection.Emit.OpCodes.Calli&gt;</ph>, or <ph id="ph4">&lt;xref:System.Reflection.Emit.OpCodes.Callvirt&gt;</ph> instruction.</source>
          <target state="translated">O <ph id="ph1">`tail`</ph> instrução de prefixo deve preceder imediatamente um <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Call&gt;</ph>, <ph id="ph3">&lt;xref:System.Reflection.Emit.OpCodes.Calli&gt;</ph>, ou <ph id="ph4">&lt;xref:System.Reflection.Emit.OpCodes.Callvirt&gt;</ph> instrução.</target>       </trans-unit>
        <trans-unit id="4378" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Tailcall">
          <source>It indicates that the current method's stack frame should be removed before the call instruction is executed.</source>
          <target state="translated">Ele indica que o quadro de pilha do método atual deve ser removido antes que a instrução de chamada é executada.</target>       </trans-unit>
        <trans-unit id="4379" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Tailcall">
          <source>It also implies that the value returned from the following call is also the value returned by the current method, and the call can therefore be converted into a cross-method jump.</source>
          <target state="translated">Isso também significa que o valor retornado da chamada a seguir também é o valor retornado pelo método atual, e a chamada, portanto, pode ser convertida em um salto cruzado método.</target>       </trans-unit>
        <trans-unit id="4380" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Tailcall">
          <source>The stack must be empty except for the arguments being transferred by the following call.</source>
          <target state="translated">A pilha deve estar vazia, exceto os argumentos que estão sendo transferidos, a chamada a seguir.</target>       </trans-unit>
        <trans-unit id="4381" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Tailcall">
          <source>The instruction following the call instruction must be a ret. Thus the only valid code sequence is <ph id="ph1">`tail. call`</ph> (or <ph id="ph2">`calli`</ph> or <ph id="ph3">`callvirt`</ph>).</source>
          <target state="translated">A instrução após a instrução de chamada deve ser um ret. Assim, a sequência de código só é válida é <ph id="ph1">`tail. call`</ph> (ou <ph id="ph2">`calli`</ph> ou <ph id="ph3">`callvirt`</ph>).</target>       </trans-unit>
        <trans-unit id="4382" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Tailcall">
          <source>Correct Microsoft Intermediate Language (MSIL) instructions must not branch to the <ph id="ph1">`call`</ph> instruction, but they may branch to the subsequent <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Ret&gt;</ph>.</source>
          <target state="translated">Instruções Microsoft Intermediate Language (MSIL) corretas não devem fazer branch para o <ph id="ph1">`call`</ph> instrução, mas eles podem ramificar próximos <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Ret&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="4383" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Tailcall">
          <source>The current frame cannot be discarded when control is transferred from untrusted code to trusted code, since this would jeopardize code identity security.</source>
          <target state="translated">O quadro atual não pode ser descartado quando o controle é transferido de código não confiável para o código confiável, pois isso poderia comprometer a segurança de identidade do código.</target>       </trans-unit>
        <trans-unit id="4384" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Tailcall">
          <source>The .NET Framework security checks can therefore cause the <ph id="ph1">`tail`</ph> to be ignored, leaving a standard <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Call&gt;</ph> instruction.</source>
          <target state="translated">Verifica se a segurança do .NET Framework, portanto, pode fazer com que o <ph id="ph1">`tail`</ph> sejam ignorados, deixando um padrão <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Call&gt;</ph> instrução.</target>       </trans-unit>
        <trans-unit id="4385" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Tailcall">
          <source>Similarly, in order to allow the exit of a synchronized region to occur after the call returns, the <ph id="ph1">`tail`</ph> prefix is ignored when used to exit a method that is marked synchronized.</source>
          <target state="translated">Da mesma forma, em ordem para permitir que a saída de uma região sincronizada a ocorrer após a chamada retorna, o <ph id="ph1">`tail`</ph> prefixo é ignorado quando usado para sair de um método que está marcado como sincronizado.</target>       </trans-unit>
        <trans-unit id="4386" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Tailcall">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`tail`</ph> opcode:</source>
          <target state="translated">O seguinte <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> sobrecarga de método pode usar o <ph id="ph2">`tail`</ph> opcode:</target>       </trans-unit>
        <trans-unit id="4387" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Tailcall">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="4388" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.OpCodes.TakesSingleByteArgument(System.Reflection.Emit.OpCode)">
          <source>An instance of an Opcode object.</source>
          <target state="translated">Uma instância de um objeto Opcode.</target>       </trans-unit>
        <trans-unit id="4389" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.OpCodes.TakesSingleByteArgument(System.Reflection.Emit.OpCode)">
          <source>Returns true or false if the supplied opcode takes a single byte argument.</source>
          <target state="translated">Retornará true ou false se o código de operação fornecido tiver um argumento de byte único.</target>       </trans-unit>
        <trans-unit id="4390" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.OpCodes.TakesSingleByteArgument(System.Reflection.Emit.OpCode)">
          <source><ph id="ph1">&lt;see langword="True" /&gt;</ph> or <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="True" /&gt;</ph> ou <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="4391" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.OpCodes.TakesSingleByteArgument(System.Reflection.Emit.OpCode)">
          <source>This method can be used to find which MSIL opcodes are "short form", for use in optimized code.</source>
          <target state="translated">Esse método pode ser usado para descobrir quais opcodes MSIL são "forma abreviada," para uso em código otimizado.</target>       </trans-unit>
        <trans-unit id="4392" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.OpCodes.TakesSingleByteArgument(System.Reflection.Emit.OpCode)">
          <source><ph id="ph1">`TakesSingleByteArgument`</ph> returns <ph id="ph2">`true`</ph> if the <ph id="ph3">&lt;xref:System.Reflection.Emit.OpCode&gt;</ph> instance takes a single byte argument in the following cases:</source>
          <target state="translated"><ph id="ph1">`TakesSingleByteArgument`</ph> Retorna <ph id="ph2">`true`</ph> se o <ph id="ph3">&lt;xref:System.Reflection.Emit.OpCode&gt;</ph> instância usa um argumento de byte único nos seguintes casos:</target>       </trans-unit>
        <trans-unit id="4393" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.OpCodes.TakesSingleByteArgument(System.Reflection.Emit.OpCode)">
          <source>The opcode performs a branch instruction to a byte-sized address (for example, <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Br_S&gt;</ph> and <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Bgt_S&gt;</ph>).</source>
          <target state="translated">O opcode executa uma instrução de ramificação para um endereço de tamanho de byte (por exemplo, <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Br_S&gt;</ph> e <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Bgt_S&gt;</ph>).</target>       </trans-unit>
        <trans-unit id="4394" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.OpCodes.TakesSingleByteArgument(System.Reflection.Emit.OpCode)">
          <source>The opcode pushes a byte value onto the stack (for example, <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Ldc_I4_S&gt;</ph>).</source>
          <target state="translated">O código de operação envia um valor de byte para a pilha (por exemplo, <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Ldc_I4_S&gt;</ph>).</target>       </trans-unit>
        <trans-unit id="4395" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.OpCodes.TakesSingleByteArgument(System.Reflection.Emit.OpCode)">
          <source>The opcode references a variable or argument via the byte-sized "short form" (for example, <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Ldloc_S&gt;</ph> and <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Stloc_S&gt;</ph>).</source>
          <target state="translated">O código de operação faz referência a uma variável ou argumento via o tamanho em bytes "curtas" (por exemplo, <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Ldloc_S&gt;</ph> e <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Stloc_S&gt;</ph>).</target>       </trans-unit>
        <trans-unit id="4396" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.OpCodes.TakesSingleByteArgument(System.Reflection.Emit.OpCode)">
          <source>Otherwise, it returns <ph id="ph1">`false`</ph>.</source>
          <target state="translated">Caso contrário, retornará <ph id="ph1">`false`</ph>.</target>       </trans-unit>
        <trans-unit id="4397" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.OpCodes.TakesSingleByteArgument(System.Reflection.Emit.OpCode)">
          <source>The example below demonstrates the use of <ph id="ph1">`TakesSingleByteArgument`</ph> by reflecting on to the <ph id="ph2">`OpCodes`</ph> class and testing to see whether each <ph id="ph3">`OpCode`</ph> field takes a single-byte argument.</source>
          <target state="translated">O exemplo a seguir demonstra o uso de <ph id="ph1">`TakesSingleByteArgument`</ph> refletindo para o <ph id="ph2">`OpCodes`</ph> classe e teste para ver se cada <ph id="ph3">`OpCode`</ph> campo usa um argumento de byte único.</target>       </trans-unit>
        <trans-unit id="4398" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Throw">
          <source>Throws the exception object currently on the evaluation stack.</source>
          <target state="translated">Gera o objeto de exceção atualmente na pilha de avaliação.</target>       </trans-unit>
        <trans-unit id="4399" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Throw">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">A tabela a seguir lista as instruções hexadecimal e formato de assembly do Microsoft Intermediate Language (MSIL), junto com um resumo breve de referência:</target>       </trans-unit>
        <trans-unit id="4400" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Throw">
          <source>Format</source>
          <target state="translated">Formatar</target>       </trans-unit>
        <trans-unit id="4401" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Throw">
          <source>Assembly Format</source>
          <target state="translated">Formato de assembly</target>       </trans-unit>
        <trans-unit id="4402" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Throw">
          <source>Description</source>
          <target state="translated">Descrição</target>       </trans-unit>
        <trans-unit id="4403" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Throw">
          <source>7A</source>
          <target state="translated">7A</target>       </trans-unit>
        <trans-unit id="4404" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Throw">
          <source>throw</source>
          <target state="translated">throw</target>       </trans-unit>
        <trans-unit id="4405" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Throw">
          <source>Throws an exception.</source>
          <target state="translated">Gerencie uma exceção.</target>       </trans-unit>
        <trans-unit id="4406" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Throw">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">O comportamento de transição de pilha, em ordem sequencial, é:</target>       </trans-unit>
        <trans-unit id="4407" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Throw">
          <source>An object reference (to an exception) is pushed onto the stack.</source>
          <target state="translated">Uma referência de objeto (uma exceção) é inserida na pilha.</target>       </trans-unit>
        <trans-unit id="4408" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Throw">
          <source>The object reference is popped from the stack and the exception thrown.</source>
          <target state="translated">A referência de objeto é exibida na pilha e a exceção é gerada.</target>       </trans-unit>
        <trans-unit id="4409" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Throw">
          <source>The <ph id="ph1">`throw`</ph> instruction throws the exception object (type <ph id="ph2">`O`</ph>) currently on the stack.</source>
          <target state="translated">O <ph id="ph1">`throw`</ph> instrução gera o objeto de exceção (tipo <ph id="ph2">`O`</ph>) atualmente na pilha.</target>       </trans-unit>
        <trans-unit id="4410" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Throw">
          <source><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> is thrown if the object reference is a null reference.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> é gerada se a referência de objeto é uma referência nula.</target>       </trans-unit>
        <trans-unit id="4411" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Throw">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`throw`</ph> opcode:</source>
          <target state="translated">O seguinte <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> sobrecarga de método pode usar o <ph id="ph2">`throw`</ph> opcode:</target>       </trans-unit>
        <trans-unit id="4412" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Throw">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="4413" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Unaligned">
          <source>Indicates that an address currently atop the evaluation stack might not be aligned to the natural size of the immediately following <ph id="ph1">&lt;see langword="ldind" /&gt;</ph>, <ph id="ph2">&lt;see langword="stind" /&gt;</ph>, <ph id="ph3">&lt;see langword="ldfld" /&gt;</ph>, <ph id="ph4">&lt;see langword="stfld" /&gt;</ph>, <ph id="ph5">&lt;see langword="ldobj" /&gt;</ph>, <ph id="ph6">&lt;see langword="stobj" /&gt;</ph>, <ph id="ph7">&lt;see langword="initblk" /&gt;</ph>, or <ph id="ph8">&lt;see langword="cpblk" /&gt;</ph> instruction.</source>
          <target state="translated">Indica que um endereço atualmente sobre a pilha de avaliação pode não estar alinhado ao tamanho natural da instrução imediatamente após <ph id="ph1">&lt;see langword="ldind" /&gt;</ph>, <ph id="ph2">&lt;see langword="stind" /&gt;</ph>, <ph id="ph3">&lt;see langword="ldfld" /&gt;</ph>, <ph id="ph4">&lt;see langword="stfld" /&gt;</ph>, <ph id="ph5">&lt;see langword="ldobj" /&gt;</ph>, <ph id="ph6">&lt;see langword="stobj" /&gt;</ph>, <ph id="ph7">&lt;see langword="initblk" /&gt;</ph> ou <ph id="ph8">&lt;see langword="cpblk" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="4414" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Unaligned">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">A tabela a seguir lista as instruções hexadecimal e formato de assembly do Microsoft Intermediate Language (MSIL), junto com um resumo breve de referência:</target>       </trans-unit>
        <trans-unit id="4415" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Unaligned">
          <source>Format</source>
          <target state="translated">Formatar</target>       </trans-unit>
        <trans-unit id="4416" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Unaligned">
          <source>Assembly Format</source>
          <target state="translated">Formato de assembly</target>       </trans-unit>
        <trans-unit id="4417" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Unaligned">
          <source>Description</source>
          <target state="translated">Descrição</target>       </trans-unit>
        <trans-unit id="4418" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Unaligned">
          <source>FE 12 &lt; <ph id="ph1">`unsigned int8`</ph><ph id="ph2"> &gt;</ph></source>
          <target state="translated">FE 12 &lt; <ph id="ph1">`unsigned int8`</ph><ph id="ph2"> &gt;</ph></target>       </trans-unit>
        <trans-unit id="4419" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Unaligned">
          <source>unaligned.</source>
          <target state="translated">não alinhado.</target>       </trans-unit>
        <trans-unit id="4420" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Unaligned">
          <source>Indicates that the subsequent pointer instruction may be unaligned.</source>
          <target state="translated">Indica que a instrução de ponteiro subsequentes pode ser não alinhada.</target>       </trans-unit>
        <trans-unit id="4421" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Unaligned">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">O comportamento de transição de pilha, em ordem sequencial, é:</target>       </trans-unit>
        <trans-unit id="4422" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Unaligned">
          <source>An address is pushed onto the stack.</source>
          <target state="translated">Um endereço é inserido na pilha.</target>       </trans-unit>
        <trans-unit id="4423" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Unaligned">
          <source><ph id="ph1">`Unaligned`</ph> specifies that the address (an unmanaged pointer, <ph id="ph2">`native int`</ph>) on the stack might not be aligned to the natural size of the immediately following <ph id="ph3">`ldind`</ph>, <ph id="ph4">`stind`</ph>, <ph id="ph5">`ldfld`</ph>, <ph id="ph6">`stfld`</ph>, <ph id="ph7">`ldobj`</ph>, <ph id="ph8">`stobj`</ph>, <ph id="ph9">`initblk`</ph>, or <ph id="ph10">`cpblk`</ph> instruction.</source>
          <target state="translated"><ph id="ph1">`Unaligned`</ph> Especifica que o endereço (um ponteiro não gerenciado, <ph id="ph2">`native int`</ph>) na pilha pode não estar alinhado ao tamanho natural de imediatamente após <ph id="ph3">`ldind`</ph>, <ph id="ph4">`stind`</ph>, <ph id="ph5">`ldfld`</ph>, <ph id="ph6">`stfld`</ph>, <ph id="ph7">`ldobj`</ph>, <ph id="ph8">`stobj`</ph>, <ph id="ph9">`initblk`</ph>, ou <ph id="ph10">`cpblk`</ph> instrução.</target>       </trans-unit>
        <trans-unit id="4424" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Unaligned">
          <source>That is, for a <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Ldind_I4&gt;</ph> instruction the alignment of the address may not be to a 4-byte boundary.</source>
          <target state="translated">Ou seja, para um <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Ldind_I4&gt;</ph> instrução não pode ser o alinhamento do endereço de um limite de 4 bytes.</target>       </trans-unit>
        <trans-unit id="4425" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Unaligned">
          <source>For <ph id="ph1">`initblk`</ph> and <ph id="ph2">`cpblk`</ph> the default alignment is architecture dependent (4-byte on 32-bit CPUs, 8-byte on 64-bit CPUs).</source>
          <target state="translated">Para <ph id="ph1">`initblk`</ph> e <ph id="ph2">`cpblk`</ph> o alinhamento padrão é dependente de arquitetura (4 bytes em CPUs de 32 bits, 8 bytes em CPUs de 64 bits).</target>       </trans-unit>
        <trans-unit id="4426" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Unaligned">
          <source>Code generators that do not restrict their output to a 32-bit word size must use <ph id="ph1">`unaligned`</ph> if the alignment is not known at compile time to be 8-byte.</source>
          <target state="translated">Geradores de código que não restringem a saída para um tamanho de palavra de 32 bits devem usar <ph id="ph1">`unaligned`</ph> se o alinhamento não é conhecido em tempo de compilação para ser 8 bytes.</target>       </trans-unit>
        <trans-unit id="4427" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Unaligned">
          <source>The value of alignment must be 1, 2, or 4 and means that the generated code should assume that the address is byte, double-byte, or quad-byte aligned, respectively.</source>
          <target state="translated">O valor de alinhamento deve ser 1, 2 ou 4 e significa que o código gerado deve presumir que o endereço é byte, byte duplo, ou quad-bytes alinhados, respectivamente.</target>       </trans-unit>
        <trans-unit id="4428" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Unaligned">
          <source>Note that transient pointers (type <ph id="ph1">`*`</ph>) are always aligned.</source>
          <target state="translated">Observe que transitório ponteiros (tipo <ph id="ph1">`*`</ph>) sempre são alinhados.</target>       </trans-unit>
        <trans-unit id="4429" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Unaligned">
          <source>While the alignment for a <ph id="ph1">`cpblk`</ph> instruction would logically require two numbers (one for the source and one for the destination), there is no noticeable impact on performance if only the lower number is specified.</source>
          <target state="translated">Enquanto o alinhamento de um <ph id="ph1">`cpblk`</ph> instrução logicamente exigem dois números (um para a origem) e outro para o destino, não há nenhum impacto perceptível no desempenho se apenas o número mais baixo é especificado.</target>       </trans-unit>
        <trans-unit id="4430" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Unaligned">
          <source>The <ph id="ph1">`unaligned`</ph> and <ph id="ph2">`volatile`</ph> prefixes can be combined in either order.</source>
          <target state="translated">O <ph id="ph1">`unaligned`</ph> e <ph id="ph2">`volatile`</ph> prefixos podem ser combinados em qualquer ordem.</target>       </trans-unit>
        <trans-unit id="4431" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Unaligned">
          <source>They must immediately precede a <ph id="ph1">`ldind`</ph>, <ph id="ph2">`stind`</ph>, <ph id="ph3">`ldfld`</ph>, <ph id="ph4">`stfld`</ph>, <ph id="ph5">`ldobj`</ph>, <ph id="ph6">`stobj`</ph>, <ph id="ph7">`initblk`</ph>, or <ph id="ph8">`cpblk`</ph> instruction.</source>
          <target state="translated">Deve preceder imediatamente um <ph id="ph1">`ldind`</ph>, <ph id="ph2">`stind`</ph>, <ph id="ph3">`ldfld`</ph>, <ph id="ph4">`stfld`</ph>, <ph id="ph5">`ldobj`</ph>, <ph id="ph6">`stobj`</ph>, <ph id="ph7">`initblk`</ph>, ou <ph id="ph8">`cpblk`</ph> instrução.</target>       </trans-unit>
        <trans-unit id="4432" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Unaligned">
          <source>Only the <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Volatile&gt;</ph> prefix is allowed for the <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Ldsfld&gt;</ph> and <ph id="ph3">&lt;xref:System.Reflection.Emit.OpCodes.Stsfld&gt;</ph> instructions.</source>
          <target state="translated">Somente o <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Volatile&gt;</ph> é permitido um prefixo para o <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Ldsfld&gt;</ph> e <ph id="ph3">&lt;xref:System.Reflection.Emit.OpCodes.Stsfld&gt;</ph> instruções.</target>       </trans-unit>
        <trans-unit id="4433" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Unaligned">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overloads can use the <ph id="ph2">`unaligned`</ph> opcode:</source>
          <target state="translated">O seguinte <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> sobrecargas de método podem usar o <ph id="ph2">`unaligned`</ph> opcode:</target>       </trans-unit>
        <trans-unit id="4434" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Unaligned">
          <source>ILGenerator.Emit(OpCode, Label)</source>
          <target state="translated">ILGenerator.Emit(OpCode, Label)</target>       </trans-unit>
        <trans-unit id="4435" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Unaligned">
          <source>ILGenerator.Emit(Opcode, Byte)</source>
          <target state="translated">ILGenerator.Emit(Opcode, Byte)</target>       </trans-unit>
        <trans-unit id="4436" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Unbox">
          <source>Converts the boxed representation of a value type to its unboxed form.</source>
          <target state="translated">Converte a representação demarcada de um tipo de valor em sua forma não marcada.</target>       </trans-unit>
        <trans-unit id="4437" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Unbox">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">A tabela a seguir lista as instruções hexadecimal e formato de assembly do Microsoft Intermediate Language (MSIL), junto com um resumo breve de referência:</target>       </trans-unit>
        <trans-unit id="4438" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Unbox">
          <source>Format</source>
          <target state="translated">Formatar</target>       </trans-unit>
        <trans-unit id="4439" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Unbox">
          <source>Assembly Format</source>
          <target state="translated">Formato de assembly</target>       </trans-unit>
        <trans-unit id="4440" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Unbox">
          <source>Description</source>
          <target state="translated">Descrição</target>       </trans-unit>
        <trans-unit id="4441" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Unbox">
          <source>79 &lt; <ph id="ph1">`T`</ph><ph id="ph2"> &gt;</ph></source>
          <target state="translated">79 &lt; <ph id="ph1">`T`</ph><ph id="ph2"> &gt;</ph></target>       </trans-unit>
        <trans-unit id="4442" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Unbox">
          <source>unbox <ph id="ph1">`valType`</ph></source>
          <target state="translated">Converter <ph id="ph1">`valType`</ph></target>       </trans-unit>
        <trans-unit id="4443" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Unbox">
          <source>Extracts the value type data from <ph id="ph1">`obj`</ph>, its boxed representation.</source>
          <target state="translated">Extrai os dados de tipo de valor de <ph id="ph1">`obj`</ph>, sua representação de processador.</target>       </trans-unit>
        <trans-unit id="4444" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Unbox">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">O comportamento de transição de pilha, em ordem sequencial, é:</target>       </trans-unit>
        <trans-unit id="4445" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Unbox">
          <source>An object reference is pushed onto the stack.</source>
          <target state="translated">Uma referência de objeto é inserida na pilha.</target>       </trans-unit>
        <trans-unit id="4446" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Unbox">
          <source>The object reference is popped from the stack and unboxed to a value type pointer.</source>
          <target state="translated">A referência de objeto é exibida da pilha e desencaixotada para um ponteiro de tipo de valor.</target>       </trans-unit>
        <trans-unit id="4447" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Unbox">
          <source>The value type pointer is pushed onto the stack.</source>
          <target state="translated">O ponteiro de tipo de valor é inserido na pilha.</target>       </trans-unit>
        <trans-unit id="4448" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Unbox">
          <source>A value type has two separate representations within the Common Language Infrastructure (CLI):</source>
          <target state="translated">Um tipo de valor tem duas representações separadas no Common Language Infrastructure (CLI):</target>       </trans-unit>
        <trans-unit id="4449" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Unbox">
          <source>A 'raw' form used when a value type is embedded within another object.</source>
          <target state="translated">Uma forma 'bruta' usada quando um tipo de valor é inserido em outro objeto.</target>       </trans-unit>
        <trans-unit id="4450" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Unbox">
          <source>A 'boxed' form, where the data in the value type is wrapped (boxed) into an object so it can exist as an independent entity.</source>
          <target state="translated">Uma forma 'boxed', onde os dados no tipo de valor são encapsulados (boxed) em um objeto para que ele pode existir de modo independente.</target>       </trans-unit>
        <trans-unit id="4451" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Unbox">
          <source>The <ph id="ph1">`unbox`</ph> instruction converts the object reference (type <ph id="ph2">`O`</ph>), the boxed representation of a value type, to a value type pointer (a managed pointer, type <ph id="ph3">`&amp;`</ph>), its unboxed form.</source>
          <target state="translated">O <ph id="ph1">`unbox`</ph> instrução converte a referência de objeto (tipo <ph id="ph2">`O`</ph>), o box representação de um tipo de valor, para um ponteiro de tipo de valor (um ponteiro gerenciado, tipo <ph id="ph3">`&amp;`</ph>), sua desencaixotado formulário.</target>       </trans-unit>
        <trans-unit id="4452" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Unbox">
          <source>The supplied value type (<ph id="ph1">`valType`</ph>) is a metadata token indicating the type of value type contained within the boxed object.</source>
          <target state="translated">O tipo de valor fornecido (<ph id="ph1">`valType`</ph>) é um token de metadados que indica o tipo do tipo de valor contido no objeto Demarcado.</target>       </trans-unit>
        <trans-unit id="4453" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Unbox">
          <source>Unlike <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Box&gt;</ph>, which is required to make a copy of a value type for use in the object, <ph id="ph2">`unbox`</ph> is not required to copy the value type from the object.</source>
          <target state="translated">Ao contrário de <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Box&gt;</ph>, que é necessário para fazer uma cópia de um tipo de valor para uso no objeto, <ph id="ph2">`unbox`</ph> não é necessário para copiar o tipo de valor do objeto.</target>       </trans-unit>
        <trans-unit id="4454" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Unbox">
          <source>Typically it simply computes the address of the value type that is already present inside of the boxed object.</source>
          <target state="translated">Normalmente, ele simplesmente computa o endereço do tipo de valor que já está presente no objeto Demarcado.</target>       </trans-unit>
        <trans-unit id="4455" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Unbox">
          <source><ph id="ph1">&lt;xref:System.InvalidCastException&gt;</ph> is thrown if the object is not boxed as <ph id="ph2">`valType`</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.InvalidCastException&gt;</ph> será gerada se o objeto não é demarcado como <ph id="ph2">`valType`</ph>.</target>       </trans-unit>
        <trans-unit id="4456" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Unbox">
          <source><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> is thrown if the object reference is a null reference.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> é gerada se a referência de objeto é uma referência nula.</target>       </trans-unit>
        <trans-unit id="4457" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Unbox">
          <source><ph id="ph1">&lt;xref:System.TypeLoadException&gt;</ph> is thrown if the value type <ph id="ph2">`valType`</ph> cannot be found.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.TypeLoadException&gt;</ph> será gerada se o valor do tipo <ph id="ph2">`valType`</ph> não pode ser encontrado.</target>       </trans-unit>
        <trans-unit id="4458" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Unbox">
          <source>This is typically detected when Microsoft Intermediate Language (MSIL) instructions are converted to native code, rather than at runtime.</source>
          <target state="translated">Normalmente, isso é detectado quando instruções Microsoft Intermediate Language (MSIL) são convertidas em código nativo, em vez de em tempo de execução.</target>       </trans-unit>
        <trans-unit id="4459" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Unbox">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`unbox`</ph> opcode:</source>
          <target state="translated">O seguinte <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> sobrecarga de método pode usar o <ph id="ph2">`unbox`</ph> opcode:</target>       </trans-unit>
        <trans-unit id="4460" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Unbox">
          <source>ILGenerator.Emit(OpCode, Type)</source>
          <target state="translated">ILGenerator.Emit(OpCode, Type)</target>       </trans-unit>
        <trans-unit id="4461" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Unbox_Any">
          <source>Converts the boxed representation of a type specified in the instruction to its unboxed form.</source>
          <target state="translated">Converte a representação demarcada de um tipo especificado na instrução em sua forma não demarcada.</target>       </trans-unit>
        <trans-unit id="4462" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Unbox_Any">
          <source>The following table lists the instruction's hexadecimal and Microsoft intermediate language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">A tabela a seguir lista a instrução hexadecimal e formato de assembly Microsoft intermediate language (MSIL), junto com um resumo breve de referência:</target>       </trans-unit>
        <trans-unit id="4463" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Unbox_Any">
          <source>Format</source>
          <target state="translated">Formatar</target>       </trans-unit>
        <trans-unit id="4464" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Unbox_Any">
          <source>Assembly Format</source>
          <target state="translated">Formato de assembly</target>       </trans-unit>
        <trans-unit id="4465" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Unbox_Any">
          <source>Description</source>
          <target state="translated">Descrição</target>       </trans-unit>
        <trans-unit id="4466" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Unbox_Any">
          <source>A5 &lt; <ph id="ph1">`T`</ph><ph id="ph2"> &gt;</ph></source>
          <target state="translated">A5 &lt; <ph id="ph1">`T`</ph><ph id="ph2"> &gt;</ph></target>       </trans-unit>
        <trans-unit id="4467" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Unbox_Any">
          <source>unbox.any <ph id="ph1">`typeTok`</ph></source>
          <target state="translated">unbox.Any <ph id="ph1">`typeTok`</ph></target>       </trans-unit>
        <trans-unit id="4468" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Unbox_Any">
          <source>Extract the data from <ph id="ph1">`obj`</ph>, its boxed representation.</source>
          <target state="translated">Extrair os dados de <ph id="ph1">`obj`</ph>, sua representação de processador.</target>       </trans-unit>
        <trans-unit id="4469" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Unbox_Any">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">O comportamento de transição de pilha, em ordem sequencial, é:</target>       </trans-unit>
        <trans-unit id="4470" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Unbox_Any">
          <source>An object reference <ph id="ph1">`obj`</ph> is pushed onto the stack.</source>
          <target state="translated">Uma referência de objeto <ph id="ph1">`obj`</ph> é inserido na pilha.</target>       </trans-unit>
        <trans-unit id="4471" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Unbox_Any">
          <source>The object reference is popped from the stack and unboxed to the type specified in the instruction.</source>
          <target state="translated">A referência de objeto é exibida da pilha e desencaixotada para o tipo especificado na instrução.</target>       </trans-unit>
        <trans-unit id="4472" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Unbox_Any">
          <source>The resulting object reference or value type is pushed onto the stack.</source>
          <target state="translated">O tipo de valor ou referência de objeto resultante é inserido na pilha.</target>       </trans-unit>
        <trans-unit id="4473" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Unbox_Any">
          <source>When applied to the boxed form of a value type, the <ph id="ph1">`unbox.any`</ph> instruction extracts the value contained within <ph id="ph2">`obj`</ph> (of type <ph id="ph3">`O`</ph>), and is therefore equivalent to <ph id="ph4">`unbox`</ph> followed by <ph id="ph5">`ldobj`</ph>.</source>
          <target state="translated">Quando aplicado a forma boxed do tipo de valor, o <ph id="ph1">`unbox.any`</ph> instrução extrai o valor contido em <ph id="ph2">`obj`</ph> (do tipo <ph id="ph3">`O`</ph>) e, portanto, é equivalente a <ph id="ph4">`unbox`</ph> seguido por <ph id="ph5">`ldobj`</ph>.</target>       </trans-unit>
        <trans-unit id="4474" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Unbox_Any">
          <source>When applied to a reference type, the <ph id="ph1">`unbox.any`</ph> instruction has the same effect as <ph id="ph2">`castclass`</ph> <ph id="ph3">`typeTok`</ph>.</source>
          <target state="translated">Quando aplicado a um tipo de referência, o <ph id="ph1">`unbox.any`</ph> instrução tem o mesmo efeito que <ph id="ph2">`castclass`</ph> <ph id="ph3">`typeTok`</ph>.</target>       </trans-unit>
        <trans-unit id="4475" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Unbox_Any">
          <source>If the operand <ph id="ph1">`typeTok`</ph> is a generic type parameter, then the runtime behavior is determined by the type that is specified for that generic type parameter.</source>
          <target state="translated">Se o operando <ph id="ph1">`typeTok`</ph> é um parâmetro de tipo genérico, em seguida, o comportamento de tempo de execução é determinado pelo tipo que é especificado para esse parâmetro de tipo genérico.</target>       </trans-unit>
        <trans-unit id="4476" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Unbox_Any">
          <source><ph id="ph1">&lt;xref:System.InvalidCastException&gt;</ph> is thrown if <ph id="ph2">`obj`</ph> is not a boxed type.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.InvalidCastException&gt;</ph> será gerada se <ph id="ph2">`obj`</ph> não é um tipo Demarcado.</target>       </trans-unit>
        <trans-unit id="4477" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Unbox_Any">
          <source><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> is thrown if <ph id="ph2">`obj`</ph> is a null reference.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> será gerada se <ph id="ph2">`obj`</ph> é uma referência nula.</target>       </trans-unit>
        <trans-unit id="4478" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Unbox_Any">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`unbox.any`</ph> opcode:</source>
          <target state="translated">O seguinte <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> sobrecarga de método pode usar o <ph id="ph2">`unbox.any`</ph> opcode:</target>       </trans-unit>
        <trans-unit id="4479" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Unbox_Any">
          <source>ILGenerator.Emit(OpCode, Type)</source>
          <target state="translated">ILGenerator.Emit(OpCode, Type)</target>       </trans-unit>
        <trans-unit id="4480" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Volatile">
          <source>Specifies that an address currently atop the evaluation stack might be volatile, and the results of reading that location cannot be cached or that multiple stores to that location cannot be suppressed.</source>
          <target state="translated">Especifica que um endereço atualmente sobre a pilha de avaliação pode ser volátil e os resultados da leitura daquele local não podem ser armazenados em cache ou não é possível suprimir vários repositórios para esse local.</target>       </trans-unit>
        <trans-unit id="4481" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Volatile">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">A tabela a seguir lista as instruções hexadecimal e formato de assembly do Microsoft Intermediate Language (MSIL), junto com um resumo breve de referência:</target>       </trans-unit>
        <trans-unit id="4482" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Volatile">
          <source>Format</source>
          <target state="translated">Formatar</target>       </trans-unit>
        <trans-unit id="4483" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Volatile">
          <source>Assembly Format</source>
          <target state="translated">Formato de assembly</target>       </trans-unit>
        <trans-unit id="4484" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Volatile">
          <source>Description</source>
          <target state="translated">Descrição</target>       </trans-unit>
        <trans-unit id="4485" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Volatile">
          <source>FE 13</source>
          <target state="translated">FE 13</target>       </trans-unit>
        <trans-unit id="4486" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Volatile">
          <source>volatile.</source>
          <target state="translated">voláteis.</target>       </trans-unit>
        <trans-unit id="4487" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Volatile">
          <source>Indicates that the subsequent pointer reference is volatile.</source>
          <target state="translated">Indica que a referência de ponteiro subsequente é volátil.</target>       </trans-unit>
        <trans-unit id="4488" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Volatile">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">O comportamento de transição de pilha, em ordem sequencial, é:</target>       </trans-unit>
        <trans-unit id="4489" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Volatile">
          <source>An address is pushed onto the stack.</source>
          <target state="translated">Um endereço é inserido na pilha.</target>       </trans-unit>
        <trans-unit id="4490" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Volatile">
          <source><ph id="ph1">`volatile`</ph>.</source>
          <target state="translated"><ph id="ph1">`volatile`</ph>.</target>       </trans-unit>
        <trans-unit id="4491" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Volatile">
          <source>specifies that the address is a volatile address (that is, it can be referenced externally to the current thread of execution) and the results of reading that location cannot be cached or that multiple stores to that location cannot be suppressed.</source>
          <target state="translated">Especifica que o endereço é um endereço volátil (isto é, ele pode ser referenciado externamente para o segmento atual de execução) e os resultados de leitura que local não pode ser armazenado em cache ou que várias lojas para esse local não pode ser suprimidas.</target>       </trans-unit>
        <trans-unit id="4492" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Volatile">
          <source>Marking an access as <ph id="ph1">`volatile`</ph> affects only that single access; other accesses to the same location must be marked separately.</source>
          <target state="translated">Marcar um acesso como <ph id="ph1">`volatile`</ph> afeta somente essa único; outros acessa no mesmo local deve ser marcado separadamente.</target>       </trans-unit>
        <trans-unit id="4493" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Volatile">
          <source>Access to volatile locations need not be performed atomically.</source>
          <target state="translated">Acesso a locais volátil não precisa ser executado atomicamente.</target>       </trans-unit>
        <trans-unit id="4494" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Volatile">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Unaligned&gt;</ph> and <ph id="ph2">`volatile`</ph> prefixes can be combined in either order.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Unaligned&gt;</ph> e <ph id="ph2">`volatile`</ph> prefixos podem ser combinados em qualquer ordem.</target>       </trans-unit>
        <trans-unit id="4495" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Volatile">
          <source>They must immediately precede a <ph id="ph1">`ldind`</ph>, <ph id="ph2">`stind`</ph>, <ph id="ph3">`ldfld`</ph>, <ph id="ph4">`stfld`</ph>, <ph id="ph5">`ldobj`</ph>, <ph id="ph6">`stobj`</ph>, <ph id="ph7">`initblk`</ph>, or <ph id="ph8">`cpblk`</ph> instruction.</source>
          <target state="translated">Deve preceder imediatamente um <ph id="ph1">`ldind`</ph>, <ph id="ph2">`stind`</ph>, <ph id="ph3">`ldfld`</ph>, <ph id="ph4">`stfld`</ph>, <ph id="ph5">`ldobj`</ph>, <ph id="ph6">`stobj`</ph>, <ph id="ph7">`initblk`</ph>, ou <ph id="ph8">`cpblk`</ph> instrução.</target>       </trans-unit>
        <trans-unit id="4496" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Volatile">
          <source>Only the <ph id="ph1">`volatile`</ph> prefix is allowed for the <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Ldsfld&gt;</ph> and <ph id="ph3">&lt;xref:System.Reflection.Emit.OpCodes.Stsfld&gt;</ph> instructions.</source>
          <target state="translated">Somente o <ph id="ph1">`volatile`</ph> é permitido um prefixo para o <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Ldsfld&gt;</ph> e <ph id="ph3">&lt;xref:System.Reflection.Emit.OpCodes.Stsfld&gt;</ph> instruções.</target>       </trans-unit>
        <trans-unit id="4497" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Volatile">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`volatile`</ph> opcode:</source>
          <target state="translated">O seguinte <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> sobrecarga de método pode usar o <ph id="ph2">`volatile`</ph> opcode:</target>       </trans-unit>
        <trans-unit id="4498" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Volatile">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="4499" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Xor">
          <source>Computes the bitwise XOR of the top two values on the evaluation stack, pushing the result onto the evaluation stack.</source>
          <target state="translated">Calcula o XOR bit a bit dos dois valores superiores na pilha de avaliação, efetuando o push do resultado para a pilha de avaliação.</target>       </trans-unit>
        <trans-unit id="4500" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Xor">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">A tabela a seguir lista as instruções hexadecimal e formato de assembly do Microsoft Intermediate Language (MSIL), junto com um resumo breve de referência:</target>       </trans-unit>
        <trans-unit id="4501" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Xor">
          <source>Format</source>
          <target state="translated">Formatar</target>       </trans-unit>
        <trans-unit id="4502" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Xor">
          <source>Assembly Format</source>
          <target state="translated">Formato de assembly</target>       </trans-unit>
        <trans-unit id="4503" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Xor">
          <source>Description</source>
          <target state="translated">Descrição</target>       </trans-unit>
        <trans-unit id="4504" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Xor">
          <source>61</source>
          <target state="translated">61</target>       </trans-unit>
        <trans-unit id="4505" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Xor">
          <source>xor</source>
          <target state="translated">xor</target>       </trans-unit>
        <trans-unit id="4506" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Xor">
          <source>Computes the bitwise XOR of two integer values and returns an integer.</source>
          <target state="translated">Calcula o XOR bit a bit de dois valores inteiros e retorna um inteiro.</target>       </trans-unit>
        <trans-unit id="4507" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Xor">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">O comportamento de transição de pilha, em ordem sequencial, é:</target>       </trans-unit>
        <trans-unit id="4508" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Xor">
          <source><ph id="ph1">`value1`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value1`</ph> é inserido na pilha.</target>       </trans-unit>
        <trans-unit id="4509" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Xor">
          <source><ph id="ph1">`value2`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value2`</ph> é inserido na pilha.</target>       </trans-unit>
        <trans-unit id="4510" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Xor">
          <source><ph id="ph1">`value2`</ph> and <ph id="ph2">`value1`</ph> are popped from the stack and their bitwise XOR computed.</source>
          <target state="translated"><ph id="ph1">`value2`</ph> e <ph id="ph2">`value1`</ph> são disparados de pilha e o bit a bit XOR computada.</target>       </trans-unit>
        <trans-unit id="4511" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Xor">
          <source>The bitwise XOR of <ph id="ph1">`value2`</ph> and <ph id="ph2">`value1`</ph> is pushed onto the stack.</source>
          <target state="translated">O XOR bit a bit de <ph id="ph1">`value2`</ph> e <ph id="ph2">`value1`</ph> é inserido na pilha.</target>       </trans-unit>
        <trans-unit id="4512" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Xor">
          <source>The <ph id="ph1">`xor`</ph> instruction computes the bitwise XOR of the top two values on the stack and leaves the result on the stack.</source>
          <target state="translated">O <ph id="ph1">`xor`</ph> instrução calcula o XOR bit a bit dos dois principais valores na pilha e deixa o resultado na pilha.</target>       </trans-unit>
        <trans-unit id="4513" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Xor">
          <source><ph id="ph1">`Xor`</ph> is an integer-specific operation.</source>
          <target state="translated"><ph id="ph1">`Xor`</ph> é uma operação de inteiro específico.</target>       </trans-unit>
        <trans-unit id="4514" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Xor">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`xor`</ph> opcode:</source>
          <target state="translated">O seguinte <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> sobrecarga de método pode usar o <ph id="ph2">`xor`</ph> opcode:</target>       </trans-unit>
        <trans-unit id="4515" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Xor">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>