<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="ModuleBuilder.xml" source-language="en-US" target-language="pt-BR">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-15c36f0" tool-company="Microsoft" />
      <xliffext:skl_file_name xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">02cd5861-7ce2-4a82-b358-31f8435a0ac5cd62ca0fc3883c3b58b0d81ab5d8f47e85cb31d6.skl</xliffext:skl_file_name>
      <xliffext:version xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">1.2</xliffext:version>
      <xliffext:ms.openlocfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">cd62ca0fc3883c3b58b0d81ab5d8f47e85cb31d6</xliffext:ms.openlocfilehash>
      <xliffext:ms.sourcegitcommit xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b</xliffext:ms.sourcegitcommit>
      <xliffext:ms.lasthandoff xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">04/03/2018</xliffext:ms.lasthandoff>
      <xliffext:moniker_ids xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">netcore-1.0,netcore-1.1,netcore-2.0,netcore-2.1,netframework-4.5.1,netframework-4.5.2,netframework-4.5,netframework-4.6.1,netframework-4.6.2,netframework-4.6,netframework-4.7.1,netframework-4.7,xamarinandroid-7.1,xamarinios-10.8,xamarinmac-3.0</xliffext:moniker_ids>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve" uid="T:System.Reflection.Emit.ModuleBuilder">
          <source>Defines and represents a module in a dynamic assembly.</source>
          <target state="translated">Define e representa um módulo em um assembly dinâmico.</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.ModuleBuilder">
          <source>To get an instance of <ph id="ph1">&lt;xref:System.Reflection.Emit.ModuleBuilder&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Reflection.Emit.AssemblyBuilder.DefineDynamicModule%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Para obter uma instância de <ph id="ph1">&lt;xref:System.Reflection.Emit.ModuleBuilder&gt;</ph>, use o <ph id="ph2">&lt;xref:System.Reflection.Emit.AssemblyBuilder.DefineDynamicModule%2A?displayProperty=nameWithType&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.ModuleBuilder">
          <source>The following code sample demonstrates the use of <ph id="ph1">`ModuleBuilder`</ph> to create a dynamic module.</source>
          <target state="translated">O exemplo de código a seguir demonstra o uso de <ph id="ph1">`ModuleBuilder`</ph> para criar um módulo dinâmico.</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.ModuleBuilder">
          <source>Note that the ModuleBuilder is created by calling <ph id="ph1">&lt;xref:System.Reflection.Emit.AssemblyBuilder.DefineDynamicModule%2A&gt;</ph> in <ph id="ph2">&lt;xref:System.Reflection.Emit.AssemblyBuilder&gt;</ph>, rather than through a constructor.</source>
          <target state="translated">Observe que o ModuleBuilder é criado chamando <ph id="ph1">&lt;xref:System.Reflection.Emit.AssemblyBuilder.DefineDynamicModule%2A&gt;</ph> em <ph id="ph2">&lt;xref:System.Reflection.Emit.AssemblyBuilder&gt;</ph>, em vez de por meio de um construtor.</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve" uid="P:System.Reflection.Emit.ModuleBuilder.Assembly">
          <source>Gets the dynamic assembly that defined this instance of <ph id="ph1">&lt;see cref="T:System.Reflection.Emit.ModuleBuilder" /&gt;</ph>.</source>
          <target state="translated">Obtém o assembly dinâmico que definiu esta instância do <ph id="ph1">&lt;see cref="T:System.Reflection.Emit.ModuleBuilder" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.ModuleBuilder.Assembly">
          <source>The dynamic assembly that defined the current dynamic module.</source>
          <target state="translated">O assembly dinâmico que definiu o módulo dinâmico atual.</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.ModuleBuilder.Assembly">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.Assembly&gt;</ph> object that is returned is the <ph id="ph2">&lt;xref:System.Reflection.Emit.AssemblyBuilder&gt;</ph> that defined this instance of <ph id="ph3">&lt;xref:System.Reflection.Emit.ModuleBuilder&gt;</ph>.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Reflection.Assembly&gt;</ph> objeto que é retornado é o <ph id="ph2">&lt;xref:System.Reflection.Emit.AssemblyBuilder&gt;</ph> que definido nesta instância do <ph id="ph3">&lt;xref:System.Reflection.Emit.ModuleBuilder&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.CreateGlobalFunctions">
          <source>Completes the global function definitions and global data definitions for this dynamic module.</source>
          <target state="translated">Conclui a definições de função global e dados globais para esse módulo dinâmico.</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.CreateGlobalFunctions">
          <source>This method should be called when the user is done with defining all the global functions within this dynamic module.</source>
          <target state="translated">Esse método deve ser chamado quando o usuário é feito com a definição de todas as funções globais dentro deste módulo dinâmico.</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.CreateGlobalFunctions">
          <source>After calling this function, no more new global functions or new global data are allowed.</source>
          <target state="translated">Depois de chamar essa função, não há mais novas funções globais ou novos dados globais são permitidos.</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.CreateGlobalFunctions">
          <source>Starting with the <ph id="ph1">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</ph>, this member no longer requires <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> with the <ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType&gt;</ph> flag.</source>
          <target state="translated">Começando com o <ph id="ph1">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</ph>, esse membro não requer mais <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> com o <ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType&gt;</ph> sinalizador.</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.CreateGlobalFunctions">
          <source>(See <bpt id="p1">[</bpt>Security Issues in Reflection Emit<ept id="p1">](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)</ept>.) To use this functionality, your application should target the <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> or later.</source>
          <target state="translated">(Consulte <bpt id="p1">[</bpt>problemas de segurança em reflexão emitir<ept id="p1">](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)</ept>.) Para usar essa funcionalidade, seu aplicativo deve ser direcionado ao <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> ou posterior.</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.CreateGlobalFunctions">
          <source>The following sample illustrates the use of <ph id="ph1">`CreateGlobalFunctions`</ph> to create a static global method from a <ph id="ph2">&lt;xref:System.Reflection.Emit.MethodBuilder&gt;</ph> implemented with <ph id="ph3">&lt;xref:System.Reflection.Emit.ModuleBuilder.DefineGlobalMethod%2A&gt;</ph>.</source>
          <target state="translated">O exemplo a seguir ilustra o uso de <ph id="ph1">`CreateGlobalFunctions`</ph> para criar um método estático global de um <ph id="ph2">&lt;xref:System.Reflection.Emit.MethodBuilder&gt;</ph> implementado com <ph id="ph3">&lt;xref:System.Reflection.Emit.ModuleBuilder.DefineGlobalMethod%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.CreateGlobalFunctions">
          <source>This method was called previously.</source>
          <target state="translated">Esse método foi chamado anteriormente.</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineDocument(System.String,System.Guid,System.Guid,System.Guid)">
          <source>The URL for the document.</source>
          <target state="translated">A URL para o documento.</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineDocument(System.String,System.Guid,System.Guid,System.Guid)">
          <source>The GUID that identifies the document language.</source>
          <target state="translated">O GUID que identifica o idioma do documento.</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineDocument(System.String,System.Guid,System.Guid,System.Guid)">
          <source>This can be <ph id="ph1">&lt;see cref="F:System.Guid.Empty" /&gt;</ph>.</source>
          <target state="translated">Ele pode ser <ph id="ph1">&lt;see cref="F:System.Guid.Empty" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineDocument(System.String,System.Guid,System.Guid,System.Guid)">
          <source>The GUID that identifies the document language vendor.</source>
          <target state="translated">O GUID que identifica o fornecedor de idioma do documento.</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineDocument(System.String,System.Guid,System.Guid,System.Guid)">
          <source>This can be <ph id="ph1">&lt;see cref="F:System.Guid.Empty" /&gt;</ph>.</source>
          <target state="translated">Ele pode ser <ph id="ph1">&lt;see cref="F:System.Guid.Empty" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineDocument(System.String,System.Guid,System.Guid,System.Guid)">
          <source>The GUID that identifies the document type.</source>
          <target state="translated">O GUID que identifica o tipo de documento.</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineDocument(System.String,System.Guid,System.Guid,System.Guid)">
          <source>This can be <ph id="ph1">&lt;see cref="F:System.Guid.Empty" /&gt;</ph>.</source>
          <target state="translated">Ele pode ser <ph id="ph1">&lt;see cref="F:System.Guid.Empty" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineDocument(System.String,System.Guid,System.Guid,System.Guid)">
          <source>Defines a document for source.</source>
          <target state="translated">Define um documento de origem.</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineDocument(System.String,System.Guid,System.Guid,System.Guid)">
          <source>The defined document.</source>
          <target state="translated">O documento definido.</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.DefineDocument(System.String,System.Guid,System.Guid,System.Guid)">
          <source>Earlier versions of the .NET Framework throw <ph id="ph1">&lt;xref:System.ArgumentException&gt;</ph> instead of <ph id="ph2">&lt;xref:System.ArgumentNullException&gt;</ph> when <ph id="ph3">`url`</ph> is <ph id="ph4">`null`</ph>.</source>
          <target state="translated">Versões anteriores do .NET Framework lançam <ph id="ph1">&lt;xref:System.ArgumentException&gt;</ph> em vez de <ph id="ph2">&lt;xref:System.ArgumentNullException&gt;</ph> quando <ph id="ph3">`url`</ph> é <ph id="ph4">`null`</ph>.</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.DefineDocument(System.String,System.Guid,System.Guid,System.Guid)">
          <source>The following code sample illustrates the use of <ph id="ph1">`DefineDocument`</ph> to attach an external symbol document (in this case, a raw IL file) to a dynamic module.</source>
          <target state="translated">O exemplo de código a seguir ilustra o uso de <ph id="ph1">`DefineDocument`</ph> para anexar um documento de símbolo externo (no caso, um IL arquivo bruto) a um módulo dinâmico.</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineDocument(System.String,System.Guid,System.Guid,System.Guid)">
          <source><ph id="ph1">&lt;paramref name="url" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="url" /&gt;</ph> é <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineDocument(System.String,System.Guid,System.Guid,System.Guid)">
          <source>This is a change from earlier versions of the .NET Framework.</source>
          <target state="translated">Essa é uma alteração proveniente de versões anteriores do .NET Framework.</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineDocument(System.String,System.Guid,System.Guid,System.Guid)">
          <source>This method is called on a dynamic module that is not a debug module.</source>
          <target state="translated">Esse método é chamado em um módulo dinâmico não é um módulo de depuração.</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineEnum(System.String,System.Reflection.TypeAttributes,System.Type)">
          <source>The full path of the enumeration type.</source>
          <target state="translated">O caminho completo do tipo de enumeração.</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineEnum(System.String,System.Reflection.TypeAttributes,System.Type)">
          <source><bpt id="p1">&lt;c&gt;</bpt>name<ept id="p1">&lt;/c&gt;</ept> cannot contain embedded nulls.</source>
          <target state="translated"><bpt id="p1">&lt;c&gt;</bpt>name<ept id="p1">&lt;/c&gt;</ept> não pode conter nulos inseridos.</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineEnum(System.String,System.Reflection.TypeAttributes,System.Type)">
          <source>The type attributes for the enumeration.</source>
          <target state="translated">Os atributos de tipo para a enumeração.</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineEnum(System.String,System.Reflection.TypeAttributes,System.Type)">
          <source>The attributes are any bits defined by <ph id="ph1">&lt;see cref="F:System.Reflection.TypeAttributes.VisibilityMask" /&gt;</ph>.</source>
          <target state="translated">Os atributos são quaisquer bits definidos pelo <ph id="ph1">&lt;see cref="F:System.Reflection.TypeAttributes.VisibilityMask" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineEnum(System.String,System.Reflection.TypeAttributes,System.Type)">
          <source>The underlying type for the enumeration.</source>
          <target state="translated">O tipo subjacente para a enumeração.</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineEnum(System.String,System.Reflection.TypeAttributes,System.Type)">
          <source>This must be a built-in integer type.</source>
          <target state="translated">Isso deve ser um tipo inteiro interno.</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineEnum(System.String,System.Reflection.TypeAttributes,System.Type)">
          <source>Defines an enumeration type that is a value type with a single non-static field called <ph id="ph1">&lt;paramref name="value__" /&gt;</ph> of the specified type.</source>
          <target state="translated">Define um tipo de enumeração que é um tipo de valor com um único campo não estático chamado <ph id="ph1">&lt;paramref name="value__" /&gt;</ph> do tipo especificado.</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineEnum(System.String,System.Reflection.TypeAttributes,System.Type)">
          <source>The defined enumeration.</source>
          <target state="translated">A enumeração definida.</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.DefineEnum(System.String,System.Reflection.TypeAttributes,System.Type)">
          <source>The defined enum is a derived class of <ph id="ph1">&lt;xref:System.Enum&gt;</ph>.</source>
          <target state="translated">A enumeração definida é uma classe derivada de <ph id="ph1">&lt;xref:System.Enum&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.DefineEnum(System.String,System.Reflection.TypeAttributes,System.Type)">
          <source>The <ph id="ph1">`value__`</ph> field has <ph id="ph2">&lt;xref:System.Reflection.FieldAttributes.Private&gt;</ph> and <ph id="ph3">&lt;xref:System.Reflection.FieldAttributes.SpecialName&gt;</ph> attributes set.</source>
          <target state="translated">O <ph id="ph1">`value__`</ph> campo tem <ph id="ph2">&lt;xref:System.Reflection.FieldAttributes.Private&gt;</ph> e <ph id="ph3">&lt;xref:System.Reflection.FieldAttributes.SpecialName&gt;</ph> conjunto de atributos.</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.DefineEnum(System.String,System.Reflection.TypeAttributes,System.Type)">
          <source>For more information about the built-in integer types that can be specified as the underlying types of enumerations, see <bpt id="p1">[</bpt>Class Library Overview<ept id="p1">](~/docs/standard/class-library-overview.md)</ept>.</source>
          <target state="translated">Para obter mais informações sobre os tipos de inteiro interno que pode ser especificado como os tipos subjacentes de enumerações, consulte <bpt id="p1">[</bpt>visão geral da biblioteca de classe<ept id="p1">](~/docs/standard/class-library-overview.md)</ept>.</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.DefineEnum(System.String,System.Reflection.TypeAttributes,System.Type)">
          <source>In the .NET Framework versions 1.0 and 1.1, it is necessary to define enumerations using <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> because <ph id="ph2">&lt;xref:System.Reflection.Emit.EnumBuilder&gt;</ph> emits enumerations whose elements are of type <ph id="ph3">&lt;xref:System.Int32&gt;</ph> instead of the enumeration type.</source>
          <target state="translated">Em versões do .NET Framework 1.0 e 1.1, é necessário definir enumerações usando <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> porque <ph id="ph2">&lt;xref:System.Reflection.Emit.EnumBuilder&gt;</ph> emite enumerações cujos elementos são do tipo <ph id="ph3">&lt;xref:System.Int32&gt;</ph> em vez do tipo de enumeração.</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.DefineEnum(System.String,System.Reflection.TypeAttributes,System.Type)">
          <source>In the .NET Framework version 2.0, <ph id="ph1">&lt;xref:System.Reflection.Emit.EnumBuilder&gt;</ph> emits enumerations whose elements have the correct type.</source>
          <target state="translated">No .NET Framework versão 2.0, <ph id="ph1">&lt;xref:System.Reflection.Emit.EnumBuilder&gt;</ph> emite enumerações cujos elementos têm o tipo correto.</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.DefineEnum(System.String,System.Reflection.TypeAttributes,System.Type)">
          <source>Starting with the <ph id="ph1">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</ph>, this member no longer requires <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> with the <ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType&gt;</ph> flag.</source>
          <target state="translated">Começando com o <ph id="ph1">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</ph>, esse membro não requer mais <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> com o <ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType&gt;</ph> sinalizador.</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.DefineEnum(System.String,System.Reflection.TypeAttributes,System.Type)">
          <source>(See <bpt id="p1">[</bpt>Security Issues in Reflection Emit<ept id="p1">](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)</ept>.) To use this functionality, your application should target the <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> or later.</source>
          <target state="translated">(Consulte <bpt id="p1">[</bpt>problemas de segurança em reflexão emitir<ept id="p1">](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)</ept>.) Para usar essa funcionalidade, seu aplicativo deve ser direcionado ao <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> ou posterior.</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.DefineEnum(System.String,System.Reflection.TypeAttributes,System.Type)">
          <source>The following example illustrates the use of <ph id="ph1">`DefineEnum`</ph> to implement an enumeration class in a dynamic module.</source>
          <target state="translated">O exemplo a seguir ilustra o uso de <ph id="ph1">`DefineEnum`</ph> para implementar uma classe de enumeração em um módulo dinâmico.</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.DefineEnum(System.String,System.Reflection.TypeAttributes,System.Type)">
          <source>The example defines an enumeration named <ph id="ph1">`Elevation`</ph> that has an underlying type of <ph id="ph2">&lt;xref:System.Int32&gt;</ph>, and creates two elements: <ph id="ph3">`Low`</ph>, with a value of 0, and <ph id="ph4">`High`</ph>, with a value of 1.</source>
          <target state="translated">O exemplo define uma enumeração denominada <ph id="ph1">`Elevation`</ph> que tem um tipo subjacente de <ph id="ph2">&lt;xref:System.Int32&gt;</ph>e cria dois elementos: <ph id="ph3">`Low`</ph>, com um valor de 0, e <ph id="ph4">`High`</ph>, com um valor de 1.</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.DefineEnum(System.String,System.Reflection.TypeAttributes,System.Type)">
          <source>After the type has been created, the assembly is saved with the name <ph id="ph1">`TempAssembly.dll`</ph>.</source>
          <target state="translated">Depois que o tipo tiver sido criado, o assembly é salvo com o nome <ph id="ph1">`TempAssembly.dll`</ph>.</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.DefineEnum(System.String,System.Reflection.TypeAttributes,System.Type)">
          <source>You can use the <bpt id="p1">[</bpt>Ildasm.exe (IL Disassembler)<ept id="p1">](~/docs/framework/tools/ildasm-exe-il-disassembler.md)</ept> to examine the contents of this assembly.</source>
          <target state="translated">Você pode usar o <bpt id="p1">[</bpt>Ildasm.exe (IL Disassembler)<ept id="p1">](~/docs/framework/tools/ildasm-exe-il-disassembler.md)</ept> para examinar o conteúdo deste assembly.</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.DefineEnum(System.String,System.Reflection.TypeAttributes,System.Type)">
          <source>Prior to the .NET Framework version 2.0, this code example does not produce a correct enumeration.</source>
          <target state="translated">Antes do .NET Framework versão 2.0, este exemplo de código não produz uma enumeração correta.</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineEnum(System.String,System.Reflection.TypeAttributes,System.Type)">
          <source>Attributes other than visibility attributes are provided.</source>
          <target state="translated">Atributos que não sejam os atributos de visibilidade são fornecidos.</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineEnum(System.String,System.Reflection.TypeAttributes,System.Type)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineEnum(System.String,System.Reflection.TypeAttributes,System.Type)">
          <source>An enumeration with the given name exists in the parent assembly of this module.</source>
          <target state="translated">Uma enumeração com o nome especificado existe no assembly pai deste módulo.</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineEnum(System.String,System.Reflection.TypeAttributes,System.Type)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineEnum(System.String,System.Reflection.TypeAttributes,System.Type)">
          <source>The visibility attributes do not match the scope of the enumeration.</source>
          <target state="translated">Os atributos de visibilidade não coincidem com o escopo da enumeração.</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineEnum(System.String,System.Reflection.TypeAttributes,System.Type)">
          <source>For example, <ph id="ph1">&lt;see cref="F:System.Reflection.TypeAttributes.NestedPublic" /&gt;</ph> is specified for <ph id="ph2">&lt;paramref name="visibility" /&gt;</ph>, but the enumeration is not a nested type.</source>
          <target state="translated">Por exemplo, <ph id="ph1">&lt;see cref="F:System.Reflection.TypeAttributes.NestedPublic" /&gt;</ph> é especificado para <ph id="ph2">&lt;paramref name="visibility" /&gt;</ph>, mas a enumeração não é um tipo aninhado.</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineEnum(System.String,System.Reflection.TypeAttributes,System.Type)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> é <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve" uid="T:System.Reflection.Emit.ModuleBuilder">
          <source>Defines a global method.</source>
          <target state="translated">Define um método global.</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineGlobalMethod(System.String,System.Reflection.MethodAttributes,System.Type,System.Type[])">
          <source>The name of the method.</source>
          <target state="translated">O nome do método.</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineGlobalMethod(System.String,System.Reflection.MethodAttributes,System.Type,System.Type[])">
          <source><bpt id="p1">&lt;c&gt;</bpt>name<ept id="p1">&lt;/c&gt;</ept> cannot contain embedded nulls.</source>
          <target state="translated"><bpt id="p1">&lt;c&gt;</bpt>name<ept id="p1">&lt;/c&gt;</ept> não pode conter nulos inseridos.</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineGlobalMethod(System.String,System.Reflection.MethodAttributes,System.Type,System.Type[])">
          <source>The attributes of the method.</source>
          <target state="translated">Os atributos do método.</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineGlobalMethod(System.String,System.Reflection.MethodAttributes,System.Type,System.Type[])">
          <source><bpt id="p1">&lt;c&gt;</bpt>attributes<ept id="p1">&lt;/c&gt;</ept> must include <ph id="ph1">&lt;see cref="F:System.Reflection.MethodAttributes.Static" /&gt;</ph>.</source>
          <target state="translated"><bpt id="p1">&lt;c&gt;</bpt>atributos<ept id="p1">&lt;/c&gt;</ept> devem incluir <ph id="ph1">&lt;see cref="F:System.Reflection.MethodAttributes.Static" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineGlobalMethod(System.String,System.Reflection.MethodAttributes,System.Type,System.Type[])">
          <source>The return type of the method.</source>
          <target state="translated">O tipo de retorno do método.</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineGlobalMethod(System.String,System.Reflection.MethodAttributes,System.Type,System.Type[])">
          <source>The types of the method's parameters.</source>
          <target state="translated">Os tipos de parâmetros do método.</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineGlobalMethod(System.String,System.Reflection.MethodAttributes,System.Type,System.Type[])">
          <source>Defines a global method with the specified name, attributes, return type, and parameter types.</source>
          <target state="translated">Define um método global com o nome, os atributos, o tipo de retorno e os tipos de parâmetro especificados.</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineGlobalMethod(System.String,System.Reflection.MethodAttributes,System.Type,System.Type[])">
          <source>The defined global method.</source>
          <target state="translated">O método global definido.</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.DefineGlobalMethod(System.String,System.Reflection.MethodAttributes,System.Type,System.Type[])">
          <source>The global method that this method defines is not usable until you call <ph id="ph1">&lt;xref:System.Reflection.Emit.ModuleBuilder.CreateGlobalFunctions%2A&gt;</ph>.</source>
          <target state="translated">O método global que define este método não é utilizável até que você chame <ph id="ph1">&lt;xref:System.Reflection.Emit.ModuleBuilder.CreateGlobalFunctions%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.DefineGlobalMethod(System.String,System.Reflection.MethodAttributes,System.Type,System.Type[])">
          <source>Starting with the <ph id="ph1">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</ph>, this member no longer requires <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> with the <ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType&gt;</ph> flag.</source>
          <target state="translated">Começando com o <ph id="ph1">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</ph>, esse membro não requer mais <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> com o <ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType&gt;</ph> sinalizador.</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.DefineGlobalMethod(System.String,System.Reflection.MethodAttributes,System.Type,System.Type[])">
          <source>(See <bpt id="p1">[</bpt>Security Issues in Reflection Emit<ept id="p1">](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)</ept>.) To use this functionality, your application should target the <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> or later.</source>
          <target state="translated">(Consulte <bpt id="p1">[</bpt>problemas de segurança em reflexão emitir<ept id="p1">](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)</ept>.) Para usar essa funcionalidade, seu aplicativo deve ser direcionado ao <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> ou posterior.</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.DefineGlobalMethod(System.String,System.Reflection.MethodAttributes,System.Type,System.Type[])">
          <source>The following example illustrates the use of <ph id="ph1">`DefineGlobalMethod`</ph> to create a type-independent method tied to the current <ph id="ph2">&lt;xref:System.Reflection.Emit.ModuleBuilder&gt;</ph>.</source>
          <target state="translated">O exemplo a seguir ilustra o uso de <ph id="ph1">`DefineGlobalMethod`</ph> para criar um método independente de tipo associado ao atual <ph id="ph2">&lt;xref:System.Reflection.Emit.ModuleBuilder&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.DefineGlobalMethod(System.String,System.Reflection.MethodAttributes,System.Type,System.Type[])">
          <source>After building the global method, <ph id="ph1">&lt;xref:System.Reflection.Emit.ModuleBuilder.CreateGlobalFunctions%2A&gt;</ph> must be called in order to complete it.</source>
          <target state="translated">Depois de criar o método global, <ph id="ph1">&lt;xref:System.Reflection.Emit.ModuleBuilder.CreateGlobalFunctions%2A&gt;</ph> deve ser chamado para concluí-la.</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineGlobalMethod(System.String,System.Reflection.MethodAttributes,System.Type,System.Type[])">
          <source>The method is not static.</source>
          <target state="translated">O método não é estático.</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineGlobalMethod(System.String,System.Reflection.MethodAttributes,System.Type,System.Type[])">
          <source>That is, <ph id="ph1">&lt;paramref name="attributes" /&gt;</ph> does not include <ph id="ph2">&lt;see cref="F:System.Reflection.MethodAttributes.Static" /&gt;</ph>.</source>
          <target state="translated">Ou seja, <ph id="ph1">&lt;paramref name="attributes" /&gt;</ph> não inclui <ph id="ph2">&lt;see cref="F:System.Reflection.MethodAttributes.Static" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineGlobalMethod(System.String,System.Reflection.MethodAttributes,System.Type,System.Type[])">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineGlobalMethod(System.String,System.Reflection.MethodAttributes,System.Type,System.Type[])">
          <source>The length of <ph id="ph1">&lt;paramref name="name" /&gt;</ph> is zero</source>
          <target state="translated">O comprimento de <ph id="ph1">&lt;paramref name="name" /&gt;</ph> é zero</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineGlobalMethod(System.String,System.Reflection.MethodAttributes,System.Type,System.Type[])">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineGlobalMethod(System.String,System.Reflection.MethodAttributes,System.Type,System.Type[])">
          <source>An element in the <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> array is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Um elemento na matriz <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> é <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineGlobalMethod(System.String,System.Reflection.MethodAttributes,System.Type,System.Type[])">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> é <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineGlobalMethod(System.String,System.Reflection.MethodAttributes,System.Type,System.Type[])">
          <source><ph id="ph1">&lt;see cref="M:System.Reflection.Emit.ModuleBuilder.CreateGlobalFunctions" /&gt;</ph> has been previously called.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="M:System.Reflection.Emit.ModuleBuilder.CreateGlobalFunctions" /&gt;</ph> foi chamado anteriormente.</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineGlobalMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[])">
          <source>The name of the method.</source>
          <target state="translated">O nome do método.</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineGlobalMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[])">
          <source><bpt id="p1">&lt;c&gt;</bpt>name<ept id="p1">&lt;/c&gt;</ept> cannot contain embedded nulls.</source>
          <target state="translated"><bpt id="p1">&lt;c&gt;</bpt>name<ept id="p1">&lt;/c&gt;</ept> não pode conter nulos inseridos.</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineGlobalMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[])">
          <source>The attributes of the method.</source>
          <target state="translated">Os atributos do método.</target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineGlobalMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[])">
          <source><bpt id="p1">&lt;c&gt;</bpt>attributes<ept id="p1">&lt;/c&gt;</ept> must include <ph id="ph1">&lt;see cref="F:System.Reflection.MethodAttributes.Static" /&gt;</ph>.</source>
          <target state="translated"><bpt id="p1">&lt;c&gt;</bpt>atributos<ept id="p1">&lt;/c&gt;</ept> devem incluir <ph id="ph1">&lt;see cref="F:System.Reflection.MethodAttributes.Static" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineGlobalMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[])">
          <source>The calling convention for the method.</source>
          <target state="translated">A convenção de chamada para o método.</target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineGlobalMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[])">
          <source>The return type of the method.</source>
          <target state="translated">O tipo de retorno do método.</target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineGlobalMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[])">
          <source>The types of the method's parameters.</source>
          <target state="translated">Os tipos de parâmetros do método.</target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineGlobalMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[])">
          <source>Defines a global method with the specified name, attributes, calling convention, return type, and parameter types.</source>
          <target state="translated">Define um método global com o nome, os atributos, a convenção de chamada, o tipo de retorno e os tipos de parâmetro especificados.</target>       </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineGlobalMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[])">
          <source>The defined global method.</source>
          <target state="translated">O método global definido.</target>       </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.DefineGlobalMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[])">
          <source>You cannot use the global method that this method defines until you call <ph id="ph1">&lt;xref:System.Reflection.Emit.ModuleBuilder.CreateGlobalFunctions%2A&gt;</ph>.</source>
          <target state="translated">Você não pode usar o método global que este método define até que você chame <ph id="ph1">&lt;xref:System.Reflection.Emit.ModuleBuilder.CreateGlobalFunctions%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.DefineGlobalMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[])">
          <source>Starting with the <ph id="ph1">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</ph>, this member no longer requires <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> with the <ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType&gt;</ph> flag.</source>
          <target state="translated">Começando com o <ph id="ph1">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</ph>, esse membro não requer mais <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> com o <ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType&gt;</ph> sinalizador.</target>       </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.DefineGlobalMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[])">
          <source>(See <bpt id="p1">[</bpt>Security Issues in Reflection Emit<ept id="p1">](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)</ept>.) To use this functionality, your application should target the <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> or later.</source>
          <target state="translated">(Consulte <bpt id="p1">[</bpt>problemas de segurança em reflexão emitir<ept id="p1">](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)</ept>.) Para usar essa funcionalidade, seu aplicativo deve ser direcionado ao <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> ou posterior.</target>       </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.DefineGlobalMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[])">
          <source>The following code sample illustrates the use of <ph id="ph1">`DefineGlobalMethod`</ph> to create a type-independent method tied to the current <ph id="ph2">&lt;xref:System.Reflection.Emit.ModuleBuilder&gt;</ph>.</source>
          <target state="translated">O exemplo de código a seguir ilustra o uso de <ph id="ph1">`DefineGlobalMethod`</ph> para criar um método independente de tipo associado ao atual <ph id="ph2">&lt;xref:System.Reflection.Emit.ModuleBuilder&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.DefineGlobalMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[])">
          <source>After building the global method, <ph id="ph1">&lt;xref:System.Reflection.Emit.ModuleBuilder.CreateGlobalFunctions%2A&gt;</ph> must be called in order to complete it.</source>
          <target state="translated">Depois de criar o método global, <ph id="ph1">&lt;xref:System.Reflection.Emit.ModuleBuilder.CreateGlobalFunctions%2A&gt;</ph> deve ser chamado para concluí-la.</target>       </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineGlobalMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[])">
          <source>The method is not static.</source>
          <target state="translated">O método não é estático.</target>       </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineGlobalMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[])">
          <source>That is, <ph id="ph1">&lt;paramref name="attributes" /&gt;</ph> does not include <ph id="ph2">&lt;see cref="F:System.Reflection.MethodAttributes.Static" /&gt;</ph>.</source>
          <target state="translated">Ou seja, <ph id="ph1">&lt;paramref name="attributes" /&gt;</ph> não inclui <ph id="ph2">&lt;see cref="F:System.Reflection.MethodAttributes.Static" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineGlobalMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[])">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineGlobalMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[])">
          <source>An element in the <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> array is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Um elemento na matriz <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> é <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineGlobalMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[])">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> é <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineGlobalMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[])">
          <source><ph id="ph1">&lt;see cref="M:System.Reflection.Emit.ModuleBuilder.CreateGlobalFunctions" /&gt;</ph> has been previously called.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="M:System.Reflection.Emit.ModuleBuilder.CreateGlobalFunctions" /&gt;</ph> foi chamado anteriormente.</target>       </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineGlobalMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>The name of the method.</source>
          <target state="translated">O nome do método.</target>       </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineGlobalMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source><bpt id="p1">&lt;c&gt;</bpt>name<ept id="p1">&lt;/c&gt;</ept> cannot contain embedded null characters.</source>
          <target state="translated"><bpt id="p1">&lt;c&gt;</bpt>nome<ept id="p1">&lt;/c&gt;</ept> não pode conter caracteres nulos inseridos.</target>       </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineGlobalMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>The attributes of the method.</source>
          <target state="translated">Os atributos do método.</target>       </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineGlobalMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source><bpt id="p1">&lt;c&gt;</bpt>attributes<ept id="p1">&lt;/c&gt;</ept> must include <ph id="ph1">&lt;see cref="F:System.Reflection.MethodAttributes.Static" /&gt;</ph>.</source>
          <target state="translated"><bpt id="p1">&lt;c&gt;</bpt>atributos<ept id="p1">&lt;/c&gt;</ept> devem incluir <ph id="ph1">&lt;see cref="F:System.Reflection.MethodAttributes.Static" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineGlobalMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>The calling convention for the method.</source>
          <target state="translated">A convenção de chamada para o método.</target>       </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineGlobalMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>The return type of the method.</source>
          <target state="translated">O tipo de retorno do método.</target>       </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineGlobalMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>An array of types representing the required custom modifiers for the return type, such as <ph id="ph1">&lt;see cref="T:System.Runtime.CompilerServices.IsConst" /&gt;</ph> or <ph id="ph2">&lt;see cref="T:System.Runtime.CompilerServices.IsBoxed" /&gt;</ph>.</source>
          <target state="translated">Uma matriz de tipos que representa os modificadores personalizados obrigatórios para o tipo de retorno, como <ph id="ph1">&lt;see cref="T:System.Runtime.CompilerServices.IsConst" /&gt;</ph> ou <ph id="ph2">&lt;see cref="T:System.Runtime.CompilerServices.IsBoxed" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineGlobalMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>If the return type has no required custom modifiers, specify <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Se o tipo de retorno não tiver modificadores personalizados obrigatórios, especifique <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineGlobalMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>An array of types representing the optional custom modifiers for the return type, such as <ph id="ph1">&lt;see cref="T:System.Runtime.CompilerServices.IsConst" /&gt;</ph> or <ph id="ph2">&lt;see cref="T:System.Runtime.CompilerServices.IsBoxed" /&gt;</ph>.</source>
          <target state="translated">Uma matriz de tipos que representa os modificadores personalizados opcionais para o tipo de retorno, como <ph id="ph1">&lt;see cref="T:System.Runtime.CompilerServices.IsConst" /&gt;</ph> ou <ph id="ph2">&lt;see cref="T:System.Runtime.CompilerServices.IsBoxed" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineGlobalMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>If the return type has no optional custom modifiers, specify <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Se o tipo de retorno não tiver modificadores personalizados opcionais, especifique <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineGlobalMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>The types of the method's parameters.</source>
          <target state="translated">Os tipos de parâmetros do método.</target>       </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineGlobalMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>An array of arrays of types.</source>
          <target state="translated">Uma matriz de matrizes de tipos.</target>       </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineGlobalMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>Each array of types represents the required custom modifiers for the corresponding parameter of the global method.</source>
          <target state="translated">Cada matriz de tipos representa os modificadores personalizados necessários para o parâmetro correspondente do método global.</target>       </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineGlobalMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>If a particular argument has no required custom modifiers, specify <ph id="ph1">&lt;see langword="null" /&gt;</ph> instead of an array of types.</source>
          <target state="translated">Se um argumento específico não tiver nenhum modificador personalizado obrigatório, especifique <ph id="ph1">&lt;see langword="null" /&gt;</ph>, em vez de uma matriz de tipos.</target>       </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineGlobalMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>If the global method has no arguments, or if none of the arguments have required custom modifiers, specify <ph id="ph1">&lt;see langword="null" /&gt;</ph> instead of an array of arrays.</source>
          <target state="translated">Se o método global não tiver nenhum argumento ou se nenhum argumento tiver modificadores personalizados obrigatórios, especifique <ph id="ph1">&lt;see langword="null" /&gt;</ph>, em vez de uma matriz de matrizes.</target>       </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineGlobalMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>An array of arrays of types.</source>
          <target state="translated">Uma matriz de matrizes de tipos.</target>       </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineGlobalMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>Each array of types represents the optional custom modifiers for the corresponding parameter.</source>
          <target state="translated">Cada matriz de tipos representa os modificadores personalizados opcionais para o parâmetro correspondente.</target>       </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineGlobalMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>If a particular argument has no optional custom modifiers, specify <ph id="ph1">&lt;see langword="null" /&gt;</ph> instead of an array of types.</source>
          <target state="translated">Se um argumento específico não tiver nenhum modificador personalizado opcional, especifique <ph id="ph1">&lt;see langword="null" /&gt;</ph>, em vez de uma matriz de tipos.</target>       </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineGlobalMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>If the global method has no arguments, or if none of the arguments have optional custom modifiers, specify <ph id="ph1">&lt;see langword="null" /&gt;</ph> instead of an array of arrays.</source>
          <target state="translated">Se o método global não tiver nenhum argumento ou se nenhum argumento tiver modificadores personalizados opcionais, especifique <ph id="ph1">&lt;see langword="null" /&gt;</ph>, em vez de uma matriz de matrizes.</target>       </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineGlobalMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>Defines a global method with the specified name, attributes, calling convention, return type, custom modifiers for the return type, parameter types, and custom modifiers for the parameter types.</source>
          <target state="translated">Define um método global com os valores especificado de nome, atributos, convenção de chamada, tipo de retorno, modificadores personalizados para o tipo de retorno, tipos de parâmetro e modificadores personalizados para os tipos de parâmetro.</target>       </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineGlobalMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>The defined global method.</source>
          <target state="translated">O método global definido.</target>       </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.DefineGlobalMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>This overload is provided for designers of managed compilers.</source>
          <target state="translated">Essa sobrecarga é fornecida para os designers de compiladores gerenciados.</target>       </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.DefineGlobalMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>You cannot use the global method that this method defines until you call <ph id="ph1">&lt;xref:System.Reflection.Emit.ModuleBuilder.CreateGlobalFunctions%2A&gt;</ph>.</source>
          <target state="translated">Você não pode usar o método global que este método define até que você chame <ph id="ph1">&lt;xref:System.Reflection.Emit.ModuleBuilder.CreateGlobalFunctions%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.DefineGlobalMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>Starting with the <ph id="ph1">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</ph>, this member no longer requires <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> with the <ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType&gt;</ph> flag.</source>
          <target state="translated">Começando com o <ph id="ph1">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</ph>, esse membro não requer mais <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> com o <ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType&gt;</ph> sinalizador.</target>       </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.DefineGlobalMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>(See <bpt id="p1">[</bpt>Security Issues in Reflection Emit<ept id="p1">](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)</ept>.) To use this functionality, your application should target the <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> or later.</source>
          <target state="translated">(Consulte <bpt id="p1">[</bpt>problemas de segurança em reflexão emitir<ept id="p1">](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)</ept>.) Para usar essa funcionalidade, seu aplicativo deve ser direcionado ao <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> ou posterior.</target>       </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineGlobalMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>The method is not static.</source>
          <target state="translated">O método não é estático.</target>       </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineGlobalMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>That is, <ph id="ph1">&lt;paramref name="attributes" /&gt;</ph> does not include <ph id="ph2">&lt;see cref="F:System.Reflection.MethodAttributes.Static" /&gt;</ph>.</source>
          <target state="translated">Ou seja, <ph id="ph1">&lt;paramref name="attributes" /&gt;</ph> não inclui <ph id="ph2">&lt;see cref="F:System.Reflection.MethodAttributes.Static" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineGlobalMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineGlobalMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>An element in the <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> array is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Um elemento na matriz <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> é <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineGlobalMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> é <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineGlobalMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>The <ph id="ph1">&lt;see cref="M:System.Reflection.Emit.ModuleBuilder.CreateGlobalFunctions" /&gt;</ph> method has been previously called.</source>
          <target state="translated">O método <ph id="ph1">&lt;see cref="M:System.Reflection.Emit.ModuleBuilder.CreateGlobalFunctions" /&gt;</ph> foi chamado anteriormente.</target>       </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineInitializedData(System.String,System.Byte[],System.Reflection.FieldAttributes)">
          <source>The name used to refer to the data.</source>
          <target state="translated">O nome usado para fazer referência aos dados.</target>       </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineInitializedData(System.String,System.Byte[],System.Reflection.FieldAttributes)">
          <source><bpt id="p1">&lt;c&gt;</bpt>name<ept id="p1">&lt;/c&gt;</ept> cannot contain embedded nulls.</source>
          <target state="translated"><bpt id="p1">&lt;c&gt;</bpt>name<ept id="p1">&lt;/c&gt;</ept> não pode conter nulos inseridos.</target>       </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineInitializedData(System.String,System.Byte[],System.Reflection.FieldAttributes)">
          <source>The binary large object (BLOB) of data.</source>
          <target state="translated">O BLOB (objeto binário grande) de dados.</target>       </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineInitializedData(System.String,System.Byte[],System.Reflection.FieldAttributes)">
          <source>The attributes for the field.</source>
          <target state="translated">Os atributos do campo.</target>       </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineInitializedData(System.String,System.Byte[],System.Reflection.FieldAttributes)">
          <source>The default is <ph id="ph1">&lt;see langword="Static" /&gt;</ph>.</source>
          <target state="translated">O padrão é <ph id="ph1">&lt;see langword="Static" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineInitializedData(System.String,System.Byte[],System.Reflection.FieldAttributes)">
          <source>Defines an initialized data field in the .sdata section of the portable executable (PE) file.</source>
          <target state="translated">Define o campo de dados inicializado na seção .sdata do arquivo PE (executável portátil).</target>       </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineInitializedData(System.String,System.Byte[],System.Reflection.FieldAttributes)">
          <source>A field to reference the data.</source>
          <target state="translated">Um campo para fazer referência aos dados.</target>       </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.DefineInitializedData(System.String,System.Byte[],System.Reflection.FieldAttributes)">
          <source><ph id="ph1">&lt;xref:System.Reflection.FieldAttributes.Static&gt;</ph> is automatically included in <ph id="ph2">`attributes`</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Reflection.FieldAttributes.Static&gt;</ph> é incluído automaticamente no <ph id="ph2">`attributes`</ph>.</target>       </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.DefineInitializedData(System.String,System.Byte[],System.Reflection.FieldAttributes)">
          <source>The data defined by this method is not created until the <ph id="ph1">&lt;xref:System.Reflection.Emit.ModuleBuilder.CreateGlobalFunctions%2A&gt;</ph> method is called.</source>
          <target state="translated">Os dados definidos por este método não são criados até que o <ph id="ph1">&lt;xref:System.Reflection.Emit.ModuleBuilder.CreateGlobalFunctions%2A&gt;</ph> método é chamado.</target>       </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.DefineInitializedData(System.String,System.Byte[],System.Reflection.FieldAttributes)">
          <source>Starting with the <ph id="ph1">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</ph>, this member no longer requires <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> with the <ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType&gt;</ph> flag.</source>
          <target state="translated">Começando com o <ph id="ph1">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</ph>, esse membro não requer mais <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> com o <ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType&gt;</ph> sinalizador.</target>       </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.DefineInitializedData(System.String,System.Byte[],System.Reflection.FieldAttributes)">
          <source>(See <bpt id="p1">[</bpt>Security Issues in Reflection Emit<ept id="p1">](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)</ept>.) To use this functionality, your application should target the <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> or later.</source>
          <target state="translated">(Consulte <bpt id="p1">[</bpt>problemas de segurança em reflexão emitir<ept id="p1">](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)</ept>.) Para usar essa funcionalidade, seu aplicativo deve ser direcionado ao <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> ou posterior.</target>       </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.DefineInitializedData(System.String,System.Byte[],System.Reflection.FieldAttributes)">
          <source>The following example uses the <ph id="ph1">&lt;xref:System.Reflection.Emit.ModuleBuilder.DefineInitializedData%2A&gt;</ph> method to define an initialized data field in the <ph id="ph2">`.sdata`</ph> section of the portable executable (PE) file.</source>
          <target state="translated">O exemplo a seguir usa o <ph id="ph1">&lt;xref:System.Reflection.Emit.ModuleBuilder.DefineInitializedData%2A&gt;</ph> método para definir um campo de dados inicializado no <ph id="ph2">`.sdata`</ph> seção do arquivo PE (executável portátil).</target>       </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineInitializedData(System.String,System.Byte[],System.Reflection.FieldAttributes)">
          <source>The length of <ph id="ph1">&lt;paramref name="name" /&gt;</ph> is zero.</source>
          <target state="translated">O comprimento de <ph id="ph1">&lt;paramref name="name" /&gt;</ph> é zero.</target>       </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineInitializedData(System.String,System.Byte[],System.Reflection.FieldAttributes)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineInitializedData(System.String,System.Byte[],System.Reflection.FieldAttributes)">
          <source>The size of <ph id="ph1">&lt;paramref name="data" /&gt;</ph> is less than or equal to zero or greater than or equal to 0x3f0000.</source>
          <target state="translated">O tamanho de <ph id="ph1">&lt;paramref name="data" /&gt;</ph> é menor ou igual a zero, ou maior ou igual a 0x3f0000.</target>       </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineInitializedData(System.String,System.Byte[],System.Reflection.FieldAttributes)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> or <ph id="ph2">&lt;paramref name="data" /&gt;</ph> is <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> ou <ph id="ph2">&lt;paramref name="data" /&gt;</ph> é <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineInitializedData(System.String,System.Byte[],System.Reflection.FieldAttributes)">
          <source><ph id="ph1">&lt;see cref="M:System.Reflection.Emit.ModuleBuilder.CreateGlobalFunctions" /&gt;</ph> has been previously called.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="M:System.Reflection.Emit.ModuleBuilder.CreateGlobalFunctions" /&gt;</ph> foi chamado anteriormente.</target>       </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineManifestResource(System.String,System.IO.Stream,System.Reflection.ResourceAttributes)">
          <source>The case-sensitive name for the resource.</source>
          <target state="translated">O nome que diferencia maiúsculas de minúsculas para o recurso.</target>       </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineManifestResource(System.String,System.IO.Stream,System.Reflection.ResourceAttributes)">
          <source>A stream that contains the bytes for the resource.</source>
          <target state="translated">Um fluxo que contém os bytes para o recurso.</target>       </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineManifestResource(System.String,System.IO.Stream,System.Reflection.ResourceAttributes)">
          <source>An enumeration value that specifies whether the resource is public or private.</source>
          <target state="translated">Um valor de enumeração que especifica se o recurso é público ou privado.</target>       </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineManifestResource(System.String,System.IO.Stream,System.Reflection.ResourceAttributes)">
          <source>Defines a binary large object (BLOB) that represents a manifest resource to be embedded in the dynamic assembly.</source>
          <target state="translated">Define um BLOB (objeto binário grande) que representa um recurso de manifesto a ser inserido no assembly dinâmico.</target>       </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.DefineManifestResource(System.String,System.IO.Stream,System.Reflection.ResourceAttributes)">
          <source>Resources that are recorded in the assembly manifest can be managed resources or manifest resource BLOBs, and each of these can be included in the assembly either by linking or by embedding.</source>
          <target state="translated">Recursos que são registrados no manifesto do assembly podem ser recursos gerenciados ou BLOBs do recurso de manifesto, e cada um deles pode ser incluída no assembly, vinculando ou incorporando.</target>       </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.DefineManifestResource(System.String,System.IO.Stream,System.Reflection.ResourceAttributes)">
          <source>All four scenarios are supported for dynamic assemblies.</source>
          <target state="translated">Todos os quatro cenários há suporte para assemblies dinâmicos.</target>       </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.DefineManifestResource(System.String,System.IO.Stream,System.Reflection.ResourceAttributes)">
          <source>This method allows you to embed a manifest resource BLOB into a dynamic assembly.</source>
          <target state="translated">Esse método permite que você insira um recurso de manifesto BLOB em um assembly dinâmico.</target>       </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.DefineManifestResource(System.String,System.IO.Stream,System.Reflection.ResourceAttributes)">
          <source>To embed a managed resource into the manifest module of a dynamic assembly or into a satellite module, use the <ph id="ph1">&lt;xref:System.Reflection.Emit.ModuleBuilder.DefineResource%2A?displayProperty=nameWithType&gt;</ph> method to get a resource writer, and use the <ph id="ph2">&lt;xref:System.Resources.ResourceWriter.AddResource%2A?displayProperty=nameWithType&gt;</ph> method to add the resource.</source>
          <target state="translated">Para inserir um recurso gerenciado em um módulo de manifesto de um assembly dinâmico ou um módulo de satélite, use o <ph id="ph1">&lt;xref:System.Reflection.Emit.ModuleBuilder.DefineResource%2A?displayProperty=nameWithType&gt;</ph> método para obter um gravador de recurso e usar o <ph id="ph2">&lt;xref:System.Resources.ResourceWriter.AddResource%2A?displayProperty=nameWithType&gt;</ph> para adicionar o recurso.</target>       </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.DefineManifestResource(System.String,System.IO.Stream,System.Reflection.ResourceAttributes)">
          <source>To link a managed resource into a dynamic assembly, use the <ph id="ph1">&lt;xref:System.Reflection.Emit.AssemblyBuilder.DefineResource%2A?displayProperty=nameWithType&gt;</ph> method to get a resource writer, and use the <ph id="ph2">&lt;xref:System.Resources.ResourceWriter.AddResource%2A?displayProperty=nameWithType&gt;</ph> method to add the linked resource.</source>
          <target state="translated">Para vincular um recurso gerenciado em um assembly dinâmico, use o <ph id="ph1">&lt;xref:System.Reflection.Emit.AssemblyBuilder.DefineResource%2A?displayProperty=nameWithType&gt;</ph> método para obter um gravador de recurso e usar o <ph id="ph2">&lt;xref:System.Resources.ResourceWriter.AddResource%2A?displayProperty=nameWithType&gt;</ph> para adicionar o recurso vinculado.</target>       </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.DefineManifestResource(System.String,System.IO.Stream,System.Reflection.ResourceAttributes)">
          <source>To link a manifest resource BLOB into a dynamic assembly, use the <ph id="ph1">&lt;xref:System.Reflection.Emit.AssemblyBuilder.AddResourceFile%2A?displayProperty=nameWithType&gt;</ph> method to add the linked resource.</source>
          <target state="translated">Para vincular um recurso de manifesto BLOB em um assembly dinâmico, use o <ph id="ph1">&lt;xref:System.Reflection.Emit.AssemblyBuilder.AddResourceFile%2A?displayProperty=nameWithType&gt;</ph> método para adicionar o recurso vinculado.</target>       </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.DefineManifestResource(System.String,System.IO.Stream,System.Reflection.ResourceAttributes)">
          <source>In addition, a single Win32 resource can be attached to an assembly by using the <ph id="ph1">&lt;xref:System.Reflection.Emit.AssemblyBuilder.DefineUnmanagedResource%2A?displayProperty=nameWithType&gt;</ph> method or the <ph id="ph2">&lt;xref:System.Reflection.Emit.ModuleBuilder.DefineUnmanagedResource%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Além disso, um único recurso do Win32 pode ser anexado a um assembly usando o <ph id="ph1">&lt;xref:System.Reflection.Emit.AssemblyBuilder.DefineUnmanagedResource%2A?displayProperty=nameWithType&gt;</ph> método ou o <ph id="ph2">&lt;xref:System.Reflection.Emit.ModuleBuilder.DefineUnmanagedResource%2A?displayProperty=nameWithType&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.DefineManifestResource(System.String,System.IO.Stream,System.Reflection.ResourceAttributes)">
          <source>This resource does not appear in the assembly manifest.</source>
          <target state="translated">Este recurso não aparecem no manifesto do assembly.</target>       </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.DefineManifestResource(System.String,System.IO.Stream,System.Reflection.ResourceAttributes)">
          <source>The following example generates and saves a dynamic assembly named <ph id="ph1">`EmittedManifestResourceAssembly.exe`</ph>, which contains an embedded unmanaged resource.</source>
          <target state="translated">O exemplo a seguir gera e salva um assembly dinâmico chamado <ph id="ph1">`EmittedManifestResourceAssembly.exe`</ph>, que contém um embedded recurso não gerenciado.</target>       </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.DefineManifestResource(System.String,System.IO.Stream,System.Reflection.ResourceAttributes)">
          <source>The example creates the assembly, which consists of one module, and opens a memory stream to contain the unmanaged resource.</source>
          <target state="translated">O exemplo cria o assembly, que consiste em um módulo e abre um fluxo de memória para conter o recurso não gerenciado.</target>       </trans-unit>
        <trans-unit id="260" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.DefineManifestResource(System.String,System.IO.Stream,System.Reflection.ResourceAttributes)">
          <source>The code then calls the <ph id="ph1">&lt;xref:System.Reflection.Emit.ModuleBuilder.DefineManifestResource%2A&gt;</ph> method to define the resource.</source>
          <target state="translated">O código, em seguida, chama o <ph id="ph1">&lt;xref:System.Reflection.Emit.ModuleBuilder.DefineManifestResource%2A&gt;</ph> método para definir o recurso.</target>       </trans-unit>
        <trans-unit id="261" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.DefineManifestResource(System.String,System.IO.Stream,System.Reflection.ResourceAttributes)">
          <source>You can use any kind of stream for your resource; for example, you can read the unmanaged binary data from a file.</source>
          <target state="translated">Você pode usar qualquer tipo de fluxo para o recurso; Por exemplo, você pode ler os dados binários não gerenciados de um arquivo.</target>       </trans-unit>
        <trans-unit id="262" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.DefineManifestResource(System.String,System.IO.Stream,System.Reflection.ResourceAttributes)">
          <source>The example defines a type in the dynamic module with a <ph id="ph1">`Main`</ph> method, and generates MSIL for the method body.</source>
          <target state="translated">O exemplo define um tipo no módulo dinâmico com um <ph id="ph1">`Main`</ph> método e gera o MSIL para o corpo do método.</target>       </trans-unit>
        <trans-unit id="263" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.DefineManifestResource(System.String,System.IO.Stream,System.Reflection.ResourceAttributes)">
          <source>After the body for the <ph id="ph1">`Main`</ph> method has been generated and the type has been created, the code example writes five bytes to the stream associated with the manifest resource.</source>
          <target state="translated">Após o corpo para o <ph id="ph1">`Main`</ph> método foi gerado e o tipo tenha sido criado, o exemplo de código grava cinco bytes no fluxo associado com o recurso de manifesto.</target>       </trans-unit>
        <trans-unit id="264" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.DefineManifestResource(System.String,System.IO.Stream,System.Reflection.ResourceAttributes)">
          <source>When the assembly is saved, the resource is appended to it.</source>
          <target state="translated">Quando o assembly for salvo, o recurso é anexado a ele.</target>       </trans-unit>
        <trans-unit id="265" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.DefineManifestResource(System.String,System.IO.Stream,System.Reflection.ResourceAttributes)">
          <source>After running the example, you can run the emitted assembly.</source>
          <target state="translated">Depois de executar o exemplo, você pode executar o assembly emitido.</target>       </trans-unit>
        <trans-unit id="266" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.DefineManifestResource(System.String,System.IO.Stream,System.Reflection.ResourceAttributes)">
          <source>The code in the emitted assembly's <ph id="ph1">`Main`</ph> method reads the embedded manifest resource and prints the byte values to the console.</source>
          <target state="translated">O código do assembly emitido <ph id="ph1">`Main`</ph> método lê o recurso de manifesto inserido e imprime os valores de byte para o console.</target>       </trans-unit>
        <trans-unit id="267" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.DefineManifestResource(System.String,System.IO.Stream,System.Reflection.ResourceAttributes)">
          <source>You can use the <bpt id="p1">[</bpt>Ildasm.exe (IL Disassembler)<ept id="p1">](~/docs/framework/tools/ildasm-exe-il-disassembler.md)</ept> to view the information in the assembly manifest.</source>
          <target state="translated">Você pode usar o <bpt id="p1">[</bpt>Ildasm.exe (IL Disassembler)<ept id="p1">](~/docs/framework/tools/ildasm-exe-il-disassembler.md)</ept> para exibir as informações no manifesto do assembly.</target>       </trans-unit>
        <trans-unit id="268" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineManifestResource(System.String,System.IO.Stream,System.Reflection.ResourceAttributes)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> é <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="269" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineManifestResource(System.String,System.IO.Stream,System.Reflection.ResourceAttributes)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="270" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineManifestResource(System.String,System.IO.Stream,System.Reflection.ResourceAttributes)">
          <source><ph id="ph1">&lt;paramref name="stream" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="stream" /&gt;</ph> é <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="271" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineManifestResource(System.String,System.IO.Stream,System.Reflection.ResourceAttributes)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is a zero-length string.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> é uma cadeia de comprimento zero.</target>       </trans-unit>
        <trans-unit id="272" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineManifestResource(System.String,System.IO.Stream,System.Reflection.ResourceAttributes)">
          <source>The dynamic assembly that contains the current module is transient; that is, no file name was specified when <ph id="ph1">&lt;see cref="M:System.Reflection.Emit.AssemblyBuilder.DefineDynamicModule(System.String,System.String)" /&gt;</ph> was called.</source>
          <target state="translated">O assembly dinâmico que contém o módulo atual é transitório; ou seja, nenhum nome de arquivo foi especificado quando <ph id="ph1">&lt;see cref="M:System.Reflection.Emit.AssemblyBuilder.DefineDynamicModule(System.String,System.String)" /&gt;</ph> foi chamado.</target>       </trans-unit>
        <trans-unit id="273" translate="yes" xml:space="preserve" uid="T:System.Reflection.Emit.ModuleBuilder">
          <source>Defines a <ph id="ph1">&lt;see langword="PInvoke" /&gt;</ph> method.</source>
          <target state="translated">Define um método <ph id="ph1">&lt;see langword="PInvoke" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="274" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefinePInvokeMethod(System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>The name of the <ph id="ph1">&lt;see langword="PInvoke" /&gt;</ph> method.</source>
          <target state="translated">O nome do método <ph id="ph1">&lt;see langword="PInvoke" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="275" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefinePInvokeMethod(System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source><bpt id="p1">&lt;c&gt;</bpt>name<ept id="p1">&lt;/c&gt;</ept> cannot contain embedded nulls.</source>
          <target state="translated"><bpt id="p1">&lt;c&gt;</bpt>name<ept id="p1">&lt;/c&gt;</ept> não pode conter nulos inseridos.</target>       </trans-unit>
        <trans-unit id="276" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefinePInvokeMethod(System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>The name of the DLL in which the <ph id="ph1">&lt;see langword="PInvoke" /&gt;</ph> method is defined.</source>
          <target state="translated">O nome da DLL na qual o método <ph id="ph1">&lt;see langword="PInvoke" /&gt;</ph> é definido.</target>       </trans-unit>
        <trans-unit id="277" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefinePInvokeMethod(System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>The attributes of the method.</source>
          <target state="translated">Os atributos do método.</target>       </trans-unit>
        <trans-unit id="278" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefinePInvokeMethod(System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>The method's calling convention.</source>
          <target state="translated">A convenção de chamada do método.</target>       </trans-unit>
        <trans-unit id="279" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefinePInvokeMethod(System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>The method's return type.</source>
          <target state="translated">O tipo de retorno do método.</target>       </trans-unit>
        <trans-unit id="280" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefinePInvokeMethod(System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>The types of the method's parameters.</source>
          <target state="translated">Os tipos de parâmetros do método.</target>       </trans-unit>
        <trans-unit id="281" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefinePInvokeMethod(System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>The native calling convention.</source>
          <target state="translated">A convenção de chamada nativa.</target>       </trans-unit>
        <trans-unit id="282" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefinePInvokeMethod(System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>The method's native character set.</source>
          <target state="translated">O conjunto de caracteres nativos do método.</target>       </trans-unit>
        <trans-unit id="283" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefinePInvokeMethod(System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>Defines a <ph id="ph1">&lt;see langword="PInvoke" /&gt;</ph> method with the specified name, the name of the DLL in which the method is defined, the attributes of the method, the calling convention of the method, the return type of the method, the types of the parameters of the method, and the <ph id="ph2">&lt;see langword="PInvoke" /&gt;</ph> flags.</source>
          <target state="translated">Define um método <ph id="ph1">&lt;see langword="PInvoke" /&gt;</ph> com o nome especificado, o nome da DLL em que o método é definido, os atributos do método, a convenção de chamada do método, o tipo de retorno do método, os tipos dos parâmetros do método e os sinalizadores <ph id="ph2">&lt;see langword="PInvoke" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="284" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefinePInvokeMethod(System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>The defined <ph id="ph1">&lt;see langword="PInvoke" /&gt;</ph> method.</source>
          <target state="translated">O método <ph id="ph1">&lt;see langword="PInvoke" /&gt;</ph> definido.</target>       </trans-unit>
        <trans-unit id="285" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.DefinePInvokeMethod(System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>Some DLL import attributes (see the description of System.Runtime.InteropServices.DllImportAttribute) cannot be specified as arguments to this method.</source>
          <target state="translated">Alguns atributos de importação DLL (consulte a descrição do DllImportAttribute) não podem ser especificados como argumentos para esse método.</target>       </trans-unit>
        <trans-unit id="286" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.DefinePInvokeMethod(System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>Such attributes should be set by emitting a custom attribute for the method.</source>
          <target state="translated">Esses atributos devem ser definidos pelo emissor de um atributo personalizado para o método.</target>       </trans-unit>
        <trans-unit id="287" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.DefinePInvokeMethod(System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>For example, the DLL import attribute <ph id="ph1">`PreserveSig`</ph> is set by emitting a custom attribute.</source>
          <target state="translated">Por exemplo, o atributo de importação de DLL <ph id="ph1">`PreserveSig`</ph> é definido pelo emissor de um atributo personalizado.</target>       </trans-unit>
        <trans-unit id="288" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.DefinePInvokeMethod(System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>Starting with the <ph id="ph1">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</ph>, this member no longer requires <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> with the <ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType&gt;</ph> flag.</source>
          <target state="translated">Começando com o <ph id="ph1">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</ph>, esse membro não requer mais <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> com o <ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType&gt;</ph> sinalizador.</target>       </trans-unit>
        <trans-unit id="289" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.DefinePInvokeMethod(System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>(See <bpt id="p1">[</bpt>Security Issues in Reflection Emit<ept id="p1">](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)</ept>.) To use this functionality, your application should target the <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> or later.</source>
          <target state="translated">(Consulte <bpt id="p1">[</bpt>problemas de segurança em reflexão emitir<ept id="p1">](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)</ept>.) Para usar essa funcionalidade, seu aplicativo deve ser direcionado ao <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> ou posterior.</target>       </trans-unit>
        <trans-unit id="290" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.DefinePInvokeMethod(System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>The following example illustrates the use of the <ph id="ph1">`DefinePInvokeMethod`</ph> method to create a <ph id="ph2">&lt;xref:System.Reflection.Emit.MethodBuilder&gt;</ph> for an external unmanaged method, <ph id="ph3">`MessageBoxA`</ph>, in the Win32 API.</source>
          <target state="translated">O exemplo a seguir ilustra o uso do <ph id="ph1">`DefinePInvokeMethod`</ph> método para criar um <ph id="ph2">&lt;xref:System.Reflection.Emit.MethodBuilder&gt;</ph> para um método externo não gerenciado, <ph id="ph3">`MessageBoxA`</ph>, na API do Win32.</target>       </trans-unit>
        <trans-unit id="291" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.DefinePInvokeMethod(System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>The example displays a message box with <bpt id="p1">**</bpt>Retry<ept id="p1">**</ept> and <bpt id="p2">**</bpt>Cancel<ept id="p2">**</ept> buttons, and displays the return value from the message box.</source>
          <target state="translated">O exemplo exibe uma caixa de mensagem com <bpt id="p1">**</bpt>novamente<ept id="p1">**</ept> e <bpt id="p2">**</bpt>Cancelar<ept id="p2">**</ept> botões e exibe o valor de retorno da caixa de mensagem.</target>       </trans-unit>
        <trans-unit id="292" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.DefinePInvokeMethod(System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>To get a non-zero return value, you must add <ph id="ph1">&lt;xref:System.Reflection.MethodImplAttributes.PreserveSig?displayProperty=nameWithType&gt;</ph> to the method implementation flags after you create the <ph id="ph2">&lt;xref:System.Reflection.Emit.MethodBuilder&gt;</ph>, by using the <ph id="ph3">&lt;xref:System.Reflection.Emit.MethodBuilder.GetMethodImplementationFlags%2A?displayProperty=nameWithType&gt;</ph> and <ph id="ph4">&lt;xref:System.Reflection.Emit.MethodBuilder.SetImplementationFlags%2A?displayProperty=nameWithType&gt;</ph> methods.</source>
          <target state="translated">Para obter um valor de retorno diferente de zero, você deve adicionar <ph id="ph1">&lt;xref:System.Reflection.MethodImplAttributes.PreserveSig?displayProperty=nameWithType&gt;</ph> para os sinalizadores de implementação de método depois de criar o <ph id="ph2">&lt;xref:System.Reflection.Emit.MethodBuilder&gt;</ph>, usando o <ph id="ph3">&lt;xref:System.Reflection.Emit.MethodBuilder.GetMethodImplementationFlags%2A?displayProperty=nameWithType&gt;</ph> e <ph id="ph4">&lt;xref:System.Reflection.Emit.MethodBuilder.SetImplementationFlags%2A?displayProperty=nameWithType&gt;</ph> métodos.</target>       </trans-unit>
        <trans-unit id="293" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefinePInvokeMethod(System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>The method is not static or if the containing type is an interface.</source>
          <target state="translated">O método não é estático ou o tipo de conteúdo é uma interface.</target>       </trans-unit>
        <trans-unit id="294" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefinePInvokeMethod(System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="295" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefinePInvokeMethod(System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>The method is abstract.</source>
          <target state="translated">O método é abstrato.</target>       </trans-unit>
        <trans-unit id="296" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefinePInvokeMethod(System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="297" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefinePInvokeMethod(System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>The method was previously defined.</source>
          <target state="translated">O método foi definido anteriormente.</target>       </trans-unit>
        <trans-unit id="298" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefinePInvokeMethod(System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> or <ph id="ph2">&lt;paramref name="dllName" /&gt;</ph> is <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> ou <ph id="ph2">&lt;paramref name="dllName" /&gt;</ph> é <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="299" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefinePInvokeMethod(System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>The containing type has been previously created using <ph id="ph1">&lt;see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /&gt;</ph></source>
          <target state="translated">O tipo recipiente foi criado anteriormente usando <ph id="ph1">&lt;see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="300" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>The name of the <ph id="ph1">&lt;see langword="PInvoke" /&gt;</ph> method.</source>
          <target state="translated">O nome do método <ph id="ph1">&lt;see langword="PInvoke" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="301" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source><bpt id="p1">&lt;c&gt;</bpt>name<ept id="p1">&lt;/c&gt;</ept> cannot contain embedded nulls.</source>
          <target state="translated"><bpt id="p1">&lt;c&gt;</bpt>name<ept id="p1">&lt;/c&gt;</ept> não pode conter nulos inseridos.</target>       </trans-unit>
        <trans-unit id="302" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>The name of the DLL in which the <ph id="ph1">&lt;see langword="PInvoke" /&gt;</ph> method is defined.</source>
          <target state="translated">O nome da DLL na qual o método <ph id="ph1">&lt;see langword="PInvoke" /&gt;</ph> é definido.</target>       </trans-unit>
        <trans-unit id="303" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>The name of the entry point in the DLL.</source>
          <target state="translated">O nome do ponto de entrada na DLL.</target>       </trans-unit>
        <trans-unit id="304" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>The attributes of the method.</source>
          <target state="translated">Os atributos do método.</target>       </trans-unit>
        <trans-unit id="305" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>The method's calling convention.</source>
          <target state="translated">A convenção de chamada do método.</target>       </trans-unit>
        <trans-unit id="306" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>The method's return type.</source>
          <target state="translated">O tipo de retorno do método.</target>       </trans-unit>
        <trans-unit id="307" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>The types of the method's parameters.</source>
          <target state="translated">Os tipos de parâmetros do método.</target>       </trans-unit>
        <trans-unit id="308" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>The native calling convention.</source>
          <target state="translated">A convenção de chamada nativa.</target>       </trans-unit>
        <trans-unit id="309" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>The method's native character set.</source>
          <target state="translated">O conjunto de caracteres nativos do método.</target>       </trans-unit>
        <trans-unit id="310" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>Defines a <ph id="ph1">&lt;see langword="PInvoke" /&gt;</ph> method with the specified name, the name of the DLL in which the method is defined, the attributes of the method, the calling convention of the method, the return type of the method, the types of the parameters of the method, and the <ph id="ph2">&lt;see langword="PInvoke" /&gt;</ph> flags.</source>
          <target state="translated">Define um método <ph id="ph1">&lt;see langword="PInvoke" /&gt;</ph> com o nome especificado, o nome da DLL em que o método é definido, os atributos do método, a convenção de chamada do método, o tipo de retorno do método, os tipos dos parâmetros do método e os sinalizadores <ph id="ph2">&lt;see langword="PInvoke" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="311" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>The defined <ph id="ph1">&lt;see langword="PInvoke" /&gt;</ph> method.</source>
          <target state="translated">O método <ph id="ph1">&lt;see langword="PInvoke" /&gt;</ph> definido.</target>       </trans-unit>
        <trans-unit id="312" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>Some DLL import attributes (see the description of <ph id="ph1">&lt;xref:System.Runtime.InteropServices.DllImportAttribute&gt;</ph>) cannot be specified as arguments to this method.</source>
          <target state="translated">Alguns DLL importar atributos (consulte a descrição da <ph id="ph1">&lt;xref:System.Runtime.InteropServices.DllImportAttribute&gt;</ph>) não podem ser especificados como argumentos para esse método.</target>       </trans-unit>
        <trans-unit id="313" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>Such attributes should be set by emitting a custom attribute for the method.</source>
          <target state="translated">Esses atributos devem ser definidos pelo emissor de um atributo personalizado para o método.</target>       </trans-unit>
        <trans-unit id="314" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>For example, the DLL import attribute <ph id="ph1">`PreserveSig`</ph> is set by emitting a custom attribute.</source>
          <target state="translated">Por exemplo, o atributo de importação de DLL <ph id="ph1">`PreserveSig`</ph> é definido pelo emissor de um atributo personalizado.</target>       </trans-unit>
        <trans-unit id="315" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>Starting with the <ph id="ph1">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</ph>, this member no longer requires <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> with the <ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType&gt;</ph> flag.</source>
          <target state="translated">Começando com o <ph id="ph1">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</ph>, esse membro não requer mais <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> com o <ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType&gt;</ph> sinalizador.</target>       </trans-unit>
        <trans-unit id="316" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>(See <bpt id="p1">[</bpt>Security Issues in Reflection Emit<ept id="p1">](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)</ept>.) To use this functionality, your application should target the <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> or later.</source>
          <target state="translated">(Consulte <bpt id="p1">[</bpt>problemas de segurança em reflexão emitir<ept id="p1">](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)</ept>.) Para usar essa funcionalidade, seu aplicativo deve ser direcionado ao <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> ou posterior.</target>       </trans-unit>
        <trans-unit id="317" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>The following example illustrates the use of the <ph id="ph1">`DefinePInvokeMethod`</ph> method to create a <ph id="ph2">&lt;xref:System.Reflection.Emit.MethodBuilder&gt;</ph> for an external unmanaged method, <ph id="ph3">`MessageBoxA`</ph>, in the Win32 API.</source>
          <target state="translated">O exemplo a seguir ilustra o uso do <ph id="ph1">`DefinePInvokeMethod`</ph> método para criar um <ph id="ph2">&lt;xref:System.Reflection.Emit.MethodBuilder&gt;</ph> para um método externo não gerenciado, <ph id="ph3">`MessageBoxA`</ph>, na API do Win32.</target>       </trans-unit>
        <trans-unit id="318" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>The example displays a message box with <bpt id="p1">**</bpt>Retry<ept id="p1">**</ept> and <bpt id="p2">**</bpt>Cancel<ept id="p2">**</ept> buttons, and displays the return value from the message box.</source>
          <target state="translated">O exemplo exibe uma caixa de mensagem com <bpt id="p1">**</bpt>novamente<ept id="p1">**</ept> e <bpt id="p2">**</bpt>Cancelar<ept id="p2">**</ept> botões e exibe o valor de retorno da caixa de mensagem.</target>       </trans-unit>
        <trans-unit id="319" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>To get a non-zero return value, you must add <ph id="ph1">&lt;xref:System.Reflection.MethodImplAttributes.PreserveSig?displayProperty=nameWithType&gt;</ph> to the method implementation flags after you create the <ph id="ph2">&lt;xref:System.Reflection.Emit.MethodBuilder&gt;</ph>, by using the <ph id="ph3">&lt;xref:System.Reflection.Emit.MethodBuilder.GetMethodImplementationFlags%2A?displayProperty=nameWithType&gt;</ph> and <ph id="ph4">&lt;xref:System.Reflection.Emit.MethodBuilder.SetImplementationFlags%2A?displayProperty=nameWithType&gt;</ph> methods.</source>
          <target state="translated">Para obter um valor de retorno diferente de zero, você deve adicionar <ph id="ph1">&lt;xref:System.Reflection.MethodImplAttributes.PreserveSig?displayProperty=nameWithType&gt;</ph> para os sinalizadores de implementação de método depois de criar o <ph id="ph2">&lt;xref:System.Reflection.Emit.MethodBuilder&gt;</ph>, usando o <ph id="ph3">&lt;xref:System.Reflection.Emit.MethodBuilder.GetMethodImplementationFlags%2A?displayProperty=nameWithType&gt;</ph> e <ph id="ph4">&lt;xref:System.Reflection.Emit.MethodBuilder.SetImplementationFlags%2A?displayProperty=nameWithType&gt;</ph> métodos.</target>       </trans-unit>
        <trans-unit id="320" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>This example uses a different overload of the <ph id="ph1">&lt;xref:System.Reflection.Emit.ModuleBuilder.DefinePInvokeMethod%2A&gt;</ph> method, but the technique is the same.</source>
          <target state="translated">Este exemplo usa uma sobrecarga diferente de <ph id="ph1">&lt;xref:System.Reflection.Emit.ModuleBuilder.DefinePInvokeMethod%2A&gt;</ph> método, mas a técnica é o mesmo.</target>       </trans-unit>
        <trans-unit id="321" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>The method is not static or if the containing type is an interface or if the method is abstract of if the method was previously defined.</source>
          <target state="translated">O método não é estático ou se o tipo de conteúdo é uma interface ou se o método é abstract se o método foi definido anteriormente.</target>       </trans-unit>
        <trans-unit id="322" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> or <ph id="ph2">&lt;paramref name="dllName" /&gt;</ph> is <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> ou <ph id="ph2">&lt;paramref name="dllName" /&gt;</ph> é <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="323" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>The containing type has been previously created using <ph id="ph1">&lt;see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /&gt;</ph></source>
          <target state="translated">O tipo recipiente foi criado anteriormente usando <ph id="ph1">&lt;see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="324" translate="yes" xml:space="preserve" uid="T:System.Reflection.Emit.ModuleBuilder">
          <source>Defines a managed embedded resource to be stored in this module.</source>
          <target state="translated">Define um recurso inserido gerenciado a ser armazenado neste módulo.</target>       </trans-unit>
        <trans-unit id="325" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineResource(System.String,System.String)">
          <source>The name of the resource.</source>
          <target state="translated">O nome do recurso.</target>       </trans-unit>
        <trans-unit id="326" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineResource(System.String,System.String)">
          <source><bpt id="p1">&lt;c&gt;</bpt>name<ept id="p1">&lt;/c&gt;</ept> cannot contain embedded nulls.</source>
          <target state="translated"><bpt id="p1">&lt;c&gt;</bpt>name<ept id="p1">&lt;/c&gt;</ept> não pode conter nulos inseridos.</target>       </trans-unit>
        <trans-unit id="327" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineResource(System.String,System.String)">
          <source>The description of the resource.</source>
          <target state="translated">A descrição do recurso.</target>       </trans-unit>
        <trans-unit id="328" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineResource(System.String,System.String)">
          <source>Defines the named managed embedded resource to be stored in this module.</source>
          <target state="translated">Define um recurso inserido gerenciado nomeado a ser armazenado neste módulo.</target>       </trans-unit>
        <trans-unit id="329" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineResource(System.String,System.String)">
          <source>A resource writer for the defined resource.</source>
          <target state="translated">Um gravador de recurso para o recurso definido.</target>       </trans-unit>
        <trans-unit id="330" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.DefineResource(System.String,System.String)">
          <source>The caller must not call the <ph id="ph1">`ResourceWriter.Generate()`</ph> and <ph id="ph2">`ResourceWriter.Close()`</ph> methods, because these methods are called by <ph id="ph3">`ModuleBuilder.Save`</ph> when the dynamic assembly is written to disk.</source>
          <target state="translated">O chamador não deve chamar o <ph id="ph1">`ResourceWriter.Generate()`</ph> e <ph id="ph2">`ResourceWriter.Close()`</ph> métodos, porque esses métodos são chamados pelo <ph id="ph3">`ModuleBuilder.Save`</ph> quando o assembly dinâmico é gravado no disco.</target>       </trans-unit>
        <trans-unit id="331" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.DefineResource(System.String,System.String)">
          <source>Use this method to embed a managed resource.</source>
          <target state="translated">Use esse método para inserir um recurso gerenciado.</target>       </trans-unit>
        <trans-unit id="332" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.DefineResource(System.String,System.String)">
          <source>To embed a manifest resource blob, use the <ph id="ph1">&lt;xref:System.Reflection.Emit.ModuleBuilder.DefineManifestResource%2A&gt;</ph> method.</source>
          <target state="translated">Para incorporar um blob de recurso de manifesto, use o <ph id="ph1">&lt;xref:System.Reflection.Emit.ModuleBuilder.DefineManifestResource%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="333" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.DefineResource(System.String,System.String)">
          <source>For a summary of embedding and linking managed resources and manifest resource blobs, see the <ph id="ph1">&lt;xref:System.Reflection.Emit.ModuleBuilder.DefineManifestResource%2A&gt;</ph> method.</source>
          <target state="translated">Para obter um resumo de incorporação e a vinculação de recursos gerenciados e blobs de recurso de manifesto, consulte o <ph id="ph1">&lt;xref:System.Reflection.Emit.ModuleBuilder.DefineManifestResource%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="334" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.DefineResource(System.String,System.String)">
          <source>Starting with the <ph id="ph1">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</ph>, this member no longer requires <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> with the <ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType&gt;</ph> flag.</source>
          <target state="translated">Começando com o <ph id="ph1">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</ph>, esse membro não requer mais <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> com o <ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType&gt;</ph> sinalizador.</target>       </trans-unit>
        <trans-unit id="335" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.DefineResource(System.String,System.String)">
          <source>(See <bpt id="p1">[</bpt>Security Issues in Reflection Emit<ept id="p1">](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)</ept>.) To use this functionality, your application should target the <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> or later.</source>
          <target state="translated">(Consulte <bpt id="p1">[</bpt>problemas de segurança em reflexão emitir<ept id="p1">](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)</ept>.) Para usar essa funcionalidade, seu aplicativo deve ser direcionado ao <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> ou posterior.</target>       </trans-unit>
        <trans-unit id="336" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.DefineResource(System.String,System.String)">
          <source>The following example illustrates the use of <ph id="ph1">`DefineResource`</ph> to add an external resource to the current <ph id="ph2">&lt;xref:System.Reflection.Emit.ModuleBuilder&gt;</ph>.</source>
          <target state="translated">O exemplo a seguir ilustra o uso de <ph id="ph1">`DefineResource`</ph> para adicionar um recurso externo ao atual <ph id="ph2">&lt;xref:System.Reflection.Emit.ModuleBuilder&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="337" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineResource(System.String,System.String)">
          <source>Length of <ph id="ph1">&lt;paramref name="name" /&gt;</ph> is zero.</source>
          <target state="translated">O tamanho de <ph id="ph1">&lt;paramref name="name" /&gt;</ph> é zero.</target>       </trans-unit>
        <trans-unit id="338" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineResource(System.String,System.String)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is null.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> é nulo.</target>       </trans-unit>
        <trans-unit id="339" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineResource(System.String,System.String)">
          <source>This module is transient.</source>
          <target state="translated">Esse módulo é transitório.</target>       </trans-unit>
        <trans-unit id="340" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineResource(System.String,System.String)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="341" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineResource(System.String,System.String)">
          <source>The containing assembly is not persistable.</source>
          <target state="translated">O assembly recipiente não é persistente.</target>       </trans-unit>
        <trans-unit id="342" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineResource(System.String,System.String,System.Reflection.ResourceAttributes)">
          <source>The name of the resource.</source>
          <target state="translated">O nome do recurso.</target>       </trans-unit>
        <trans-unit id="343" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineResource(System.String,System.String,System.Reflection.ResourceAttributes)">
          <source><bpt id="p1">&lt;c&gt;</bpt>name<ept id="p1">&lt;/c&gt;</ept> cannot contain embedded nulls.</source>
          <target state="translated"><bpt id="p1">&lt;c&gt;</bpt>name<ept id="p1">&lt;/c&gt;</ept> não pode conter nulos inseridos.</target>       </trans-unit>
        <trans-unit id="344" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineResource(System.String,System.String,System.Reflection.ResourceAttributes)">
          <source>The description of the resource.</source>
          <target state="translated">A descrição do recurso.</target>       </trans-unit>
        <trans-unit id="345" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineResource(System.String,System.String,System.Reflection.ResourceAttributes)">
          <source>The resource attributes.</source>
          <target state="translated">Os atributos de recursos.</target>       </trans-unit>
        <trans-unit id="346" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineResource(System.String,System.String,System.Reflection.ResourceAttributes)">
          <source>Defines the named managed embedded resource with the given attributes that is to be stored in this module.</source>
          <target state="translated">Define o recurso inserido gerenciado nomeado com os atributos informados que deve ser armazenado neste módulo.</target>       </trans-unit>
        <trans-unit id="347" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineResource(System.String,System.String,System.Reflection.ResourceAttributes)">
          <source>A resource writer for the defined resource.</source>
          <target state="translated">Um gravador de recurso para o recurso definido.</target>       </trans-unit>
        <trans-unit id="348" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.DefineResource(System.String,System.String,System.Reflection.ResourceAttributes)">
          <source>The caller must not call the <ph id="ph1">`ResourceWriter.Generate()`</ph> and <ph id="ph2">`ResourceWriter.Close()`</ph> methods, because these methods are called by <ph id="ph3">`ModuleBuilder.Save`</ph> when the dynamic assembly is written to disk.</source>
          <target state="translated">O chamador não deve chamar o <ph id="ph1">`ResourceWriter.Generate()`</ph> e <ph id="ph2">`ResourceWriter.Close()`</ph> métodos, porque esses métodos são chamados pelo <ph id="ph3">`ModuleBuilder.Save`</ph> quando o assembly dinâmico é gravado no disco.</target>       </trans-unit>
        <trans-unit id="349" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.DefineResource(System.String,System.String,System.Reflection.ResourceAttributes)">
          <source>Use this method to embed a managed resource.</source>
          <target state="translated">Use esse método para inserir um recurso gerenciado.</target>       </trans-unit>
        <trans-unit id="350" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.DefineResource(System.String,System.String,System.Reflection.ResourceAttributes)">
          <source>To embed a manifest resource blob, use the <ph id="ph1">&lt;xref:System.Reflection.Emit.ModuleBuilder.DefineManifestResource%2A&gt;</ph> method.</source>
          <target state="translated">Para incorporar um blob de recurso de manifesto, use o <ph id="ph1">&lt;xref:System.Reflection.Emit.ModuleBuilder.DefineManifestResource%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="351" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.DefineResource(System.String,System.String,System.Reflection.ResourceAttributes)">
          <source>For a summary of embedding and linking managed resources and manifest resource blobs, see the <ph id="ph1">&lt;xref:System.Reflection.Emit.ModuleBuilder.DefineManifestResource%2A&gt;</ph> method.</source>
          <target state="translated">Para obter um resumo de incorporação e a vinculação de recursos gerenciados e blobs de recurso de manifesto, consulte o <ph id="ph1">&lt;xref:System.Reflection.Emit.ModuleBuilder.DefineManifestResource%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="352" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.DefineResource(System.String,System.String,System.Reflection.ResourceAttributes)">
          <source>Starting with the <ph id="ph1">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</ph>, this member no longer requires <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> with the <ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType&gt;</ph> flag.</source>
          <target state="translated">Começando com o <ph id="ph1">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</ph>, esse membro não requer mais <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> com o <ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType&gt;</ph> sinalizador.</target>       </trans-unit>
        <trans-unit id="353" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.DefineResource(System.String,System.String,System.Reflection.ResourceAttributes)">
          <source>(See <bpt id="p1">[</bpt>Security Issues in Reflection Emit<ept id="p1">](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)</ept>.) To use this functionality, your application should target the <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> or later.</source>
          <target state="translated">(Consulte <bpt id="p1">[</bpt>problemas de segurança em reflexão emitir<ept id="p1">](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)</ept>.) Para usar essa funcionalidade, seu aplicativo deve ser direcionado ao <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> ou posterior.</target>       </trans-unit>
        <trans-unit id="354" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.DefineResource(System.String,System.String,System.Reflection.ResourceAttributes)">
          <source>The following example illustrates the use of DefineResource to add an external resource to the current <ph id="ph1">&lt;xref:System.Reflection.Emit.ModuleBuilder&gt;</ph>.</source>
          <target state="translated">O exemplo a seguir ilustra o uso de DefineResource para adicionar um recurso externo ao atual <ph id="ph1">&lt;xref:System.Reflection.Emit.ModuleBuilder&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="355" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineResource(System.String,System.String,System.Reflection.ResourceAttributes)">
          <source>Length of <ph id="ph1">&lt;paramref name="name" /&gt;</ph> is zero.</source>
          <target state="translated">O tamanho de <ph id="ph1">&lt;paramref name="name" /&gt;</ph> é zero.</target>       </trans-unit>
        <trans-unit id="356" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineResource(System.String,System.String,System.Reflection.ResourceAttributes)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is null.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> é nulo.</target>       </trans-unit>
        <trans-unit id="357" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineResource(System.String,System.String,System.Reflection.ResourceAttributes)">
          <source>This module is transient.</source>
          <target state="translated">Esse módulo é transitório.</target>       </trans-unit>
        <trans-unit id="358" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineResource(System.String,System.String,System.Reflection.ResourceAttributes)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="359" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineResource(System.String,System.String,System.Reflection.ResourceAttributes)">
          <source>The containing assembly is not persistable.</source>
          <target state="translated">O assembly recipiente não é persistente.</target>       </trans-unit>
        <trans-unit id="360" translate="yes" xml:space="preserve" uid="T:System.Reflection.Emit.ModuleBuilder">
          <source>Constructs a <ph id="ph1">&lt;see langword="TypeBuilder" /&gt;</ph>.</source>
          <target state="translated">Constrói um <ph id="ph1">&lt;see langword="TypeBuilder" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="361" translate="yes" xml:space="preserve" uid="T:System.Reflection.Emit.ModuleBuilder">
          <source>To define a value type, define a type that derives from <ph id="ph1">&lt;see cref="T:System.ValueType" /&gt;</ph>.</source>
          <target state="translated">Para definir um tipo de valor, defina um tipo que derive de <ph id="ph1">&lt;see cref="T:System.ValueType" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="362" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineType(System.String)">
          <source>The full path of the type, including the namespace.</source>
          <target state="translated">O caminho completo do tipo, incluindo o namespace.</target>       </trans-unit>
        <trans-unit id="363" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineType(System.String)">
          <source><bpt id="p1">&lt;c&gt;</bpt>name<ept id="p1">&lt;/c&gt;</ept> cannot contain embedded nulls.</source>
          <target state="translated"><bpt id="p1">&lt;c&gt;</bpt>name<ept id="p1">&lt;/c&gt;</ept> não pode conter nulos inseridos.</target>       </trans-unit>
        <trans-unit id="364" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineType(System.String)">
          <source>Constructs a <ph id="ph1">&lt;see langword="TypeBuilder" /&gt;</ph> for a private type with the specified name in this module.</source>
          <target state="translated">Constrói um <ph id="ph1">&lt;see langword="TypeBuilder" /&gt;</ph> para um tipo particular com o nome especificado neste módulo.</target>       </trans-unit>
        <trans-unit id="365" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineType(System.String)">
          <source>A private type with the specified name.</source>
          <target state="translated">Um tipo particular com o nome especificado.</target>       </trans-unit>
        <trans-unit id="366" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.DefineType(System.String)">
          <source>Type names must be unique within an assembly.</source>
          <target state="translated">Nomes de tipo devem ser exclusivos dentro de um assembly.</target>       </trans-unit>
        <trans-unit id="367" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.DefineType(System.String)">
          <source>You cannot have two types with the same name in two different modules of an assembly.</source>
          <target state="translated">Você não pode ter dois tipos com o mesmo nome em dois módulos diferentes de um assembly.</target>       </trans-unit>
        <trans-unit id="368" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.DefineType(System.String)">
          <source>Starting with the <ph id="ph1">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</ph>, this member no longer requires <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> with the <ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType&gt;</ph> flag.</source>
          <target state="translated">Começando com o <ph id="ph1">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</ph>, esse membro não requer mais <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> com o <ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType&gt;</ph> sinalizador.</target>       </trans-unit>
        <trans-unit id="369" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.DefineType(System.String)">
          <source>(See <bpt id="p1">[</bpt>Security Issues in Reflection Emit<ept id="p1">](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)</ept>.) To use this functionality, your application should target the <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> or later.</source>
          <target state="translated">(Consulte <bpt id="p1">[</bpt>problemas de segurança em reflexão emitir<ept id="p1">](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)</ept>.) Para usar essa funcionalidade, seu aplicativo deve ser direcionado ao <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> ou posterior.</target>       </trans-unit>
        <trans-unit id="370" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.DefineType(System.String)">
          <source>The following example creates a <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> in the current dynamic module using <ph id="ph2">`CreateType`</ph>, builds and completes the type, and saves the assembly.</source>
          <target state="translated">O exemplo a seguir cria um <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> no módulo dinâmico atual usando <ph id="ph2">`CreateType`</ph>, compilações e conclui o tipo e salva o assembly.</target>       </trans-unit>
        <trans-unit id="371" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineType(System.String)">
          <source>A type with the given name exists in the parent assembly of this module.</source>
          <target state="translated">Existe um tipo com o nome especificado no assembly pai deste módulo.</target>       </trans-unit>
        <trans-unit id="372" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineType(System.String)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="373" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineType(System.String)">
          <source>Nested type attributes are set on a type that is not nested.</source>
          <target state="translated">Atributos de tipo aninhado são definidos em um tipo que não está aninhado.</target>       </trans-unit>
        <trans-unit id="374" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineType(System.String)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> é <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="375" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineType(System.String,System.Reflection.TypeAttributes)">
          <source>The full path of the type.</source>
          <target state="translated">O caminho completo do tipo.</target>       </trans-unit>
        <trans-unit id="376" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineType(System.String,System.Reflection.TypeAttributes)">
          <source><bpt id="p1">&lt;c&gt;</bpt>name<ept id="p1">&lt;/c&gt;</ept> cannot contain embedded nulls.</source>
          <target state="translated"><bpt id="p1">&lt;c&gt;</bpt>name<ept id="p1">&lt;/c&gt;</ept> não pode conter nulos inseridos.</target>       </trans-unit>
        <trans-unit id="377" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineType(System.String,System.Reflection.TypeAttributes)">
          <source>The attributes of the defined type.</source>
          <target state="translated">Os atributos do tipo definido.</target>       </trans-unit>
        <trans-unit id="378" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineType(System.String,System.Reflection.TypeAttributes)">
          <source>Constructs a <ph id="ph1">&lt;see langword="TypeBuilder" /&gt;</ph> given the type name and the type attributes.</source>
          <target state="translated">Constrói um <ph id="ph1">&lt;see langword="TypeBuilder" /&gt;</ph> considerando o nome do tipo e os atributos de tipo.</target>       </trans-unit>
        <trans-unit id="379" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineType(System.String,System.Reflection.TypeAttributes)">
          <source>A <ph id="ph1">&lt;see langword="TypeBuilder" /&gt;</ph> created with all of the requested attributes.</source>
          <target state="translated">Um <ph id="ph1">&lt;see langword="TypeBuilder" /&gt;</ph> criado com todos os atributos solicitados.</target>       </trans-unit>
        <trans-unit id="380" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.DefineType(System.String,System.Reflection.TypeAttributes)">
          <source>Type names must be unique within an assembly.</source>
          <target state="translated">Nomes de tipo devem ser exclusivos dentro de um assembly.</target>       </trans-unit>
        <trans-unit id="381" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.DefineType(System.String,System.Reflection.TypeAttributes)">
          <source>You cannot have two types with the same name in two different modules of an assembly.</source>
          <target state="translated">Você não pode ter dois tipos com o mesmo nome em dois módulos diferentes de um assembly.</target>       </trans-unit>
        <trans-unit id="382" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.DefineType(System.String,System.Reflection.TypeAttributes)">
          <source>Starting with the <ph id="ph1">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</ph>, this member no longer requires <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> with the <ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType&gt;</ph> flag.</source>
          <target state="translated">Começando com o <ph id="ph1">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</ph>, esse membro não requer mais <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> com o <ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType&gt;</ph> sinalizador.</target>       </trans-unit>
        <trans-unit id="383" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.DefineType(System.String,System.Reflection.TypeAttributes)">
          <source>(See <bpt id="p1">[</bpt>Security Issues in Reflection Emit<ept id="p1">](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)</ept>.) To use this functionality, your application should target the <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> or later.</source>
          <target state="translated">(Consulte <bpt id="p1">[</bpt>problemas de segurança em reflexão emitir<ept id="p1">](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)</ept>.) Para usar essa funcionalidade, seu aplicativo deve ser direcionado ao <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> ou posterior.</target>       </trans-unit>
        <trans-unit id="384" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.DefineType(System.String,System.Reflection.TypeAttributes)">
          <source>The following example creates a <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> in the current dynamic module using <ph id="ph2">`CreateType`</ph>, builds and completes the type, and saves the assembly.</source>
          <target state="translated">O exemplo a seguir cria um <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> no módulo dinâmico atual usando <ph id="ph2">`CreateType`</ph>, compilações e conclui o tipo e salva o assembly.</target>       </trans-unit>
        <trans-unit id="385" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineType(System.String,System.Reflection.TypeAttributes)">
          <source>A type with the given name exists in the parent assembly of this module.</source>
          <target state="translated">Existe um tipo com o nome especificado no assembly pai deste módulo.</target>       </trans-unit>
        <trans-unit id="386" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineType(System.String,System.Reflection.TypeAttributes)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="387" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineType(System.String,System.Reflection.TypeAttributes)">
          <source>Nested type attributes are set on a type that is not nested.</source>
          <target state="translated">Atributos de tipo aninhado são definidos em um tipo que não está aninhado.</target>       </trans-unit>
        <trans-unit id="388" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineType(System.String,System.Reflection.TypeAttributes)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> é <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="389" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineType(System.String,System.Reflection.TypeAttributes,System.Type)">
          <source>The full path of the type.</source>
          <target state="translated">O caminho completo do tipo.</target>       </trans-unit>
        <trans-unit id="390" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineType(System.String,System.Reflection.TypeAttributes,System.Type)">
          <source><bpt id="p1">&lt;c&gt;</bpt>name<ept id="p1">&lt;/c&gt;</ept> cannot contain embedded nulls.</source>
          <target state="translated"><bpt id="p1">&lt;c&gt;</bpt>name<ept id="p1">&lt;/c&gt;</ept> não pode conter nulos inseridos.</target>       </trans-unit>
        <trans-unit id="391" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineType(System.String,System.Reflection.TypeAttributes,System.Type)">
          <source>The attribute to be associated with the type.</source>
          <target state="translated">O atributo a ser associado ao tipo.</target>       </trans-unit>
        <trans-unit id="392" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineType(System.String,System.Reflection.TypeAttributes,System.Type)">
          <source>The type that the defined type extends.</source>
          <target state="translated">O tipo que o tipo definido estende.</target>       </trans-unit>
        <trans-unit id="393" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineType(System.String,System.Reflection.TypeAttributes,System.Type)">
          <source>Constructs a <ph id="ph1">&lt;see langword="TypeBuilder" /&gt;</ph> given type name, its attributes, and the type that the defined type extends.</source>
          <target state="translated">Constrói um <ph id="ph1">&lt;see langword="TypeBuilder" /&gt;</ph> dado o nome do tipo, seus atributos e o tipo que o tipo definido estende.</target>       </trans-unit>
        <trans-unit id="394" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineType(System.String,System.Reflection.TypeAttributes,System.Type)">
          <source>A <ph id="ph1">&lt;see langword="TypeBuilder" /&gt;</ph> created with all of the requested attributes.</source>
          <target state="translated">Um <ph id="ph1">&lt;see langword="TypeBuilder" /&gt;</ph> criado com todos os atributos solicitados.</target>       </trans-unit>
        <trans-unit id="395" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.DefineType(System.String,System.Reflection.TypeAttributes,System.Type)">
          <source>Type names must be unique within an assembly.</source>
          <target state="translated">Nomes de tipo devem ser exclusivos dentro de um assembly.</target>       </trans-unit>
        <trans-unit id="396" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.DefineType(System.String,System.Reflection.TypeAttributes,System.Type)">
          <source>You cannot have two types with the same name in two different modules of an assembly.</source>
          <target state="translated">Você não pode ter dois tipos com o mesmo nome em dois módulos diferentes de um assembly.</target>       </trans-unit>
        <trans-unit id="397" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.DefineType(System.String,System.Reflection.TypeAttributes,System.Type)">
          <source>Starting with the <ph id="ph1">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</ph>, this member no longer requires <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> with the <ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType&gt;</ph> flag.</source>
          <target state="translated">Começando com o <ph id="ph1">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</ph>, esse membro não requer mais <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> com o <ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType&gt;</ph> sinalizador.</target>       </trans-unit>
        <trans-unit id="398" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.DefineType(System.String,System.Reflection.TypeAttributes,System.Type)">
          <source>(See <bpt id="p1">[</bpt>Security Issues in Reflection Emit<ept id="p1">](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)</ept>.) To use this functionality, your application should target the <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> or later.</source>
          <target state="translated">(Consulte <bpt id="p1">[</bpt>problemas de segurança em reflexão emitir<ept id="p1">](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)</ept>.) Para usar essa funcionalidade, seu aplicativo deve ser direcionado ao <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> ou posterior.</target>       </trans-unit>
        <trans-unit id="399" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.DefineType(System.String,System.Reflection.TypeAttributes,System.Type)">
          <source>The following example creates a <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> in the current dynamic module using <ph id="ph2">`CreateType`</ph>, builds and completes the type, and saves the assembly.</source>
          <target state="translated">O exemplo a seguir cria um <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> no módulo dinâmico atual usando <ph id="ph2">`CreateType`</ph>, compilações e conclui o tipo e salva o assembly.</target>       </trans-unit>
        <trans-unit id="400" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineType(System.String,System.Reflection.TypeAttributes,System.Type)">
          <source>A type with the given name exists in the parent assembly of this module.</source>
          <target state="translated">Existe um tipo com o nome especificado no assembly pai deste módulo.</target>       </trans-unit>
        <trans-unit id="401" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineType(System.String,System.Reflection.TypeAttributes,System.Type)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="402" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineType(System.String,System.Reflection.TypeAttributes,System.Type)">
          <source>Nested type attributes are set on a type that is not nested.</source>
          <target state="translated">Atributos de tipo aninhado são definidos em um tipo que não está aninhado.</target>       </trans-unit>
        <trans-unit id="403" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineType(System.String,System.Reflection.TypeAttributes,System.Type)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> é <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="404" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineType(System.String,System.Reflection.TypeAttributes,System.Type,System.Int32)">
          <source>The full path of the type.</source>
          <target state="translated">O caminho completo do tipo.</target>       </trans-unit>
        <trans-unit id="405" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineType(System.String,System.Reflection.TypeAttributes,System.Type,System.Int32)">
          <source><bpt id="p1">&lt;c&gt;</bpt>name<ept id="p1">&lt;/c&gt;</ept> cannot contain embedded nulls.</source>
          <target state="translated"><bpt id="p1">&lt;c&gt;</bpt>name<ept id="p1">&lt;/c&gt;</ept> não pode conter nulos inseridos.</target>       </trans-unit>
        <trans-unit id="406" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineType(System.String,System.Reflection.TypeAttributes,System.Type,System.Int32)">
          <source>The attributes of the defined type.</source>
          <target state="translated">Os atributos do tipo definido.</target>       </trans-unit>
        <trans-unit id="407" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineType(System.String,System.Reflection.TypeAttributes,System.Type,System.Int32)">
          <source>The type that the defined type extends.</source>
          <target state="translated">O tipo que o tipo definido estende.</target>       </trans-unit>
        <trans-unit id="408" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineType(System.String,System.Reflection.TypeAttributes,System.Type,System.Int32)">
          <source>The total size of the type.</source>
          <target state="translated">O tamanho total do tipo.</target>       </trans-unit>
        <trans-unit id="409" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineType(System.String,System.Reflection.TypeAttributes,System.Type,System.Int32)">
          <source>Constructs a <ph id="ph1">&lt;see langword="TypeBuilder" /&gt;</ph> given the type name, the attributes, the type that the defined type extends, and the total size of the type.</source>
          <target state="translated">Constrói um <ph id="ph1">&lt;see langword="TypeBuilder" /&gt;</ph> dado o nome do tipo, os atributos, o tipo que o tipo definido estende e o tamanho total do tipo.</target>       </trans-unit>
        <trans-unit id="410" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineType(System.String,System.Reflection.TypeAttributes,System.Type,System.Int32)">
          <source>A <ph id="ph1">&lt;see langword="TypeBuilder" /&gt;</ph> object.</source>
          <target state="translated">Um objeto <ph id="ph1">&lt;see langword="TypeBuilder" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="411" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.DefineType(System.String,System.Reflection.TypeAttributes,System.Type,System.Int32)">
          <source>Type names must be unique within an assembly.</source>
          <target state="translated">Nomes de tipo devem ser exclusivos dentro de um assembly.</target>       </trans-unit>
        <trans-unit id="412" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.DefineType(System.String,System.Reflection.TypeAttributes,System.Type,System.Int32)">
          <source>It is forbidden to have two types with the same name in two different modules of an assembly.</source>
          <target state="translated">É proibido têm dois tipos com o mesmo nome em dois módulos diferentes de um assembly.</target>       </trans-unit>
        <trans-unit id="413" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.DefineType(System.String,System.Reflection.TypeAttributes,System.Type,System.Int32)">
          <source>Starting with the <ph id="ph1">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</ph>, this member no longer requires <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> with the <ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType&gt;</ph> flag.</source>
          <target state="translated">Começando com o <ph id="ph1">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</ph>, esse membro não requer mais <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> com o <ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType&gt;</ph> sinalizador.</target>       </trans-unit>
        <trans-unit id="414" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.DefineType(System.String,System.Reflection.TypeAttributes,System.Type,System.Int32)">
          <source>(See <bpt id="p1">[</bpt>Security Issues in Reflection Emit<ept id="p1">](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)</ept>.) To use this functionality, your application should target the <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> or later.</source>
          <target state="translated">(Consulte <bpt id="p1">[</bpt>problemas de segurança em reflexão emitir<ept id="p1">](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)</ept>.) Para usar essa funcionalidade, seu aplicativo deve ser direcionado ao <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> ou posterior.</target>       </trans-unit>
        <trans-unit id="415" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.DefineType(System.String,System.Reflection.TypeAttributes,System.Type,System.Int32)">
          <source>The following example creates a <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> in the current dynamic module using <ph id="ph2">`CreateType`</ph>, builds and completes the type, and saves the assembly.</source>
          <target state="translated">O exemplo a seguir cria um <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> no módulo dinâmico atual usando <ph id="ph2">`CreateType`</ph>, compilações e conclui o tipo e salva o assembly.</target>       </trans-unit>
        <trans-unit id="416" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineType(System.String,System.Reflection.TypeAttributes,System.Type,System.Int32)">
          <source>A type with the given name exists in the parent assembly of this module.</source>
          <target state="translated">Existe um tipo com o nome especificado no assembly pai deste módulo.</target>       </trans-unit>
        <trans-unit id="417" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineType(System.String,System.Reflection.TypeAttributes,System.Type,System.Int32)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="418" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineType(System.String,System.Reflection.TypeAttributes,System.Type,System.Int32)">
          <source>Nested type attributes are set on a type that is not nested.</source>
          <target state="translated">Atributos de tipo aninhado são definidos em um tipo que não está aninhado.</target>       </trans-unit>
        <trans-unit id="419" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineType(System.String,System.Reflection.TypeAttributes,System.Type,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> é <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="420" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineType(System.String,System.Reflection.TypeAttributes,System.Type,System.Reflection.Emit.PackingSize)">
          <source>The full path of the type.</source>
          <target state="translated">O caminho completo do tipo.</target>       </trans-unit>
        <trans-unit id="421" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineType(System.String,System.Reflection.TypeAttributes,System.Type,System.Reflection.Emit.PackingSize)">
          <source><bpt id="p1">&lt;c&gt;</bpt>name<ept id="p1">&lt;/c&gt;</ept> cannot contain embedded nulls.</source>
          <target state="translated"><bpt id="p1">&lt;c&gt;</bpt>name<ept id="p1">&lt;/c&gt;</ept> não pode conter nulos inseridos.</target>       </trans-unit>
        <trans-unit id="422" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineType(System.String,System.Reflection.TypeAttributes,System.Type,System.Reflection.Emit.PackingSize)">
          <source>The attributes of the defined type.</source>
          <target state="translated">Os atributos do tipo definido.</target>       </trans-unit>
        <trans-unit id="423" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineType(System.String,System.Reflection.TypeAttributes,System.Type,System.Reflection.Emit.PackingSize)">
          <source>The type that the defined type extends.</source>
          <target state="translated">O tipo que o tipo definido estende.</target>       </trans-unit>
        <trans-unit id="424" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineType(System.String,System.Reflection.TypeAttributes,System.Type,System.Reflection.Emit.PackingSize)">
          <source>The packing size of the type.</source>
          <target state="translated">O tamanho de empacotamento do tipo.</target>       </trans-unit>
        <trans-unit id="425" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineType(System.String,System.Reflection.TypeAttributes,System.Type,System.Reflection.Emit.PackingSize)">
          <source>Constructs a <ph id="ph1">&lt;see langword="TypeBuilder" /&gt;</ph> given the type name, the attributes, the type that the defined type extends, and the packing size of the type.</source>
          <target state="translated">Constrói um <ph id="ph1">&lt;see langword="TypeBuilder" /&gt;</ph> dado o nome do tipo, os atributos, o tipo que o tipo definido estende e o tamanho de empacotamento do tipo.</target>       </trans-unit>
        <trans-unit id="426" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineType(System.String,System.Reflection.TypeAttributes,System.Type,System.Reflection.Emit.PackingSize)">
          <source>A <ph id="ph1">&lt;see langword="TypeBuilder" /&gt;</ph> object.</source>
          <target state="translated">Um objeto <ph id="ph1">&lt;see langword="TypeBuilder" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="427" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.DefineType(System.String,System.Reflection.TypeAttributes,System.Type,System.Reflection.Emit.PackingSize)">
          <source>Type names must be unique within an assembly.</source>
          <target state="translated">Nomes de tipo devem ser exclusivos dentro de um assembly.</target>       </trans-unit>
        <trans-unit id="428" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.DefineType(System.String,System.Reflection.TypeAttributes,System.Type,System.Reflection.Emit.PackingSize)">
          <source>You cannot have two types with the same name in two different modules of an assembly.</source>
          <target state="translated">Você não pode ter dois tipos com o mesmo nome em dois módulos diferentes de um assembly.</target>       </trans-unit>
        <trans-unit id="429" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.DefineType(System.String,System.Reflection.TypeAttributes,System.Type,System.Reflection.Emit.PackingSize)">
          <source>Starting with the <ph id="ph1">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</ph>, this member no longer requires <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> with the <ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType&gt;</ph> flag.</source>
          <target state="translated">Começando com o <ph id="ph1">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</ph>, esse membro não requer mais <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> com o <ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType&gt;</ph> sinalizador.</target>       </trans-unit>
        <trans-unit id="430" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.DefineType(System.String,System.Reflection.TypeAttributes,System.Type,System.Reflection.Emit.PackingSize)">
          <source>(See <bpt id="p1">[</bpt>Security Issues in Reflection Emit<ept id="p1">](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)</ept>.) To use this functionality, your application should target the <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> or later.</source>
          <target state="translated">(Consulte <bpt id="p1">[</bpt>problemas de segurança em reflexão emitir<ept id="p1">](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)</ept>.) Para usar essa funcionalidade, seu aplicativo deve ser direcionado ao <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> ou posterior.</target>       </trans-unit>
        <trans-unit id="431" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.DefineType(System.String,System.Reflection.TypeAttributes,System.Type,System.Reflection.Emit.PackingSize)">
          <source>The following example creates a <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> in the current dynamic module using <ph id="ph2">`CreateType`</ph>, builds and completes the type, and saves the assembly.</source>
          <target state="translated">O exemplo a seguir cria um <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> no módulo dinâmico atual usando <ph id="ph2">`CreateType`</ph>, compilações e conclui o tipo e salva o assembly.</target>       </trans-unit>
        <trans-unit id="432" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineType(System.String,System.Reflection.TypeAttributes,System.Type,System.Reflection.Emit.PackingSize)">
          <source>A type with the given name exists in the parent assembly of this module.</source>
          <target state="translated">Existe um tipo com o nome especificado no assembly pai deste módulo.</target>       </trans-unit>
        <trans-unit id="433" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineType(System.String,System.Reflection.TypeAttributes,System.Type,System.Reflection.Emit.PackingSize)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="434" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineType(System.String,System.Reflection.TypeAttributes,System.Type,System.Reflection.Emit.PackingSize)">
          <source>Nested type attributes are set on a type that is not nested.</source>
          <target state="translated">Atributos de tipo aninhado são definidos em um tipo que não está aninhado.</target>       </trans-unit>
        <trans-unit id="435" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineType(System.String,System.Reflection.TypeAttributes,System.Type,System.Reflection.Emit.PackingSize)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> é <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="436" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineType(System.String,System.Reflection.TypeAttributes,System.Type,System.Type[])">
          <source>The full path of the type.</source>
          <target state="translated">O caminho completo do tipo.</target>       </trans-unit>
        <trans-unit id="437" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineType(System.String,System.Reflection.TypeAttributes,System.Type,System.Type[])">
          <source><bpt id="p1">&lt;c&gt;</bpt>name<ept id="p1">&lt;/c&gt;</ept> cannot contain embedded nulls.</source>
          <target state="translated"><bpt id="p1">&lt;c&gt;</bpt>name<ept id="p1">&lt;/c&gt;</ept> não pode conter nulos inseridos.</target>       </trans-unit>
        <trans-unit id="438" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineType(System.String,System.Reflection.TypeAttributes,System.Type,System.Type[])">
          <source>The attributes to be associated with the type.</source>
          <target state="translated">Os atributos a serem associado ao tipo.</target>       </trans-unit>
        <trans-unit id="439" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineType(System.String,System.Reflection.TypeAttributes,System.Type,System.Type[])">
          <source>The type that the defined type extends.</source>
          <target state="translated">O tipo que o tipo definido estende.</target>       </trans-unit>
        <trans-unit id="440" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineType(System.String,System.Reflection.TypeAttributes,System.Type,System.Type[])">
          <source>The list of interfaces that the type implements.</source>
          <target state="translated">A lista de interfaces que o tipo implementa.</target>       </trans-unit>
        <trans-unit id="441" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineType(System.String,System.Reflection.TypeAttributes,System.Type,System.Type[])">
          <source>Constructs a <ph id="ph1">&lt;see langword="TypeBuilder" /&gt;</ph> given the type name, attributes, the type that the defined type extends, and the interfaces that the defined type implements.</source>
          <target state="translated">Constrói um <ph id="ph1">&lt;see langword="TypeBuilder" /&gt;</ph> dado o nome do tipo, os atributos, o tipo que o tipo definido estende e as interfaces que o tipo definido implementa.</target>       </trans-unit>
        <trans-unit id="442" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineType(System.String,System.Reflection.TypeAttributes,System.Type,System.Type[])">
          <source>A <ph id="ph1">&lt;see langword="TypeBuilder" /&gt;</ph> created with all of the requested attributes.</source>
          <target state="translated">Um <ph id="ph1">&lt;see langword="TypeBuilder" /&gt;</ph> criado com todos os atributos solicitados.</target>       </trans-unit>
        <trans-unit id="443" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.DefineType(System.String,System.Reflection.TypeAttributes,System.Type,System.Type[])">
          <source>Type names must be unique within an assembly.</source>
          <target state="translated">Nomes de tipo devem ser exclusivos dentro de um assembly.</target>       </trans-unit>
        <trans-unit id="444" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.DefineType(System.String,System.Reflection.TypeAttributes,System.Type,System.Type[])">
          <source>You cannot have two types with the same name in two different modules of an assembly.</source>
          <target state="translated">Você não pode ter dois tipos com o mesmo nome em dois módulos diferentes de um assembly.</target>       </trans-unit>
        <trans-unit id="445" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.DefineType(System.String,System.Reflection.TypeAttributes,System.Type,System.Type[])">
          <source>Starting with the <ph id="ph1">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</ph>, this member no longer requires <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> with the <ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType&gt;</ph> flag.</source>
          <target state="translated">Começando com o <ph id="ph1">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</ph>, esse membro não requer mais <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> com o <ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType&gt;</ph> sinalizador.</target>       </trans-unit>
        <trans-unit id="446" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.DefineType(System.String,System.Reflection.TypeAttributes,System.Type,System.Type[])">
          <source>(See <bpt id="p1">[</bpt>Security Issues in Reflection Emit<ept id="p1">](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)</ept>.) To use this functionality, your application should target the <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> or later.</source>
          <target state="translated">(Consulte <bpt id="p1">[</bpt>problemas de segurança em reflexão emitir<ept id="p1">](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)</ept>.) Para usar essa funcionalidade, seu aplicativo deve ser direcionado ao <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> ou posterior.</target>       </trans-unit>
        <trans-unit id="447" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.DefineType(System.String,System.Reflection.TypeAttributes,System.Type,System.Type[])">
          <source>The following example creates a <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> in the current dynamic module using <ph id="ph2">`CreateType`</ph>, builds and completes the type, and saves the assembly.</source>
          <target state="translated">O exemplo a seguir cria um <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> no módulo dinâmico atual usando <ph id="ph2">`CreateType`</ph>, compilações e conclui o tipo e salva o assembly.</target>       </trans-unit>
        <trans-unit id="448" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineType(System.String,System.Reflection.TypeAttributes,System.Type,System.Type[])">
          <source>A type with the given name exists in the parent assembly of this module.</source>
          <target state="translated">Existe um tipo com o nome especificado no assembly pai deste módulo.</target>       </trans-unit>
        <trans-unit id="449" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineType(System.String,System.Reflection.TypeAttributes,System.Type,System.Type[])">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="450" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineType(System.String,System.Reflection.TypeAttributes,System.Type,System.Type[])">
          <source>Nested type attributes are set on a type that is not nested.</source>
          <target state="translated">Atributos de tipo aninhado são definidos em um tipo que não está aninhado.</target>       </trans-unit>
        <trans-unit id="451" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineType(System.String,System.Reflection.TypeAttributes,System.Type,System.Type[])">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> é <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="452" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineType(System.String,System.Reflection.TypeAttributes,System.Type,System.Reflection.Emit.PackingSize,System.Int32)">
          <source>The full path of the type.</source>
          <target state="translated">O caminho completo do tipo.</target>       </trans-unit>
        <trans-unit id="453" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineType(System.String,System.Reflection.TypeAttributes,System.Type,System.Reflection.Emit.PackingSize,System.Int32)">
          <source><bpt id="p1">&lt;c&gt;</bpt>name<ept id="p1">&lt;/c&gt;</ept> cannot contain embedded nulls.</source>
          <target state="translated"><bpt id="p1">&lt;c&gt;</bpt>name<ept id="p1">&lt;/c&gt;</ept> não pode conter nulos inseridos.</target>       </trans-unit>
        <trans-unit id="454" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineType(System.String,System.Reflection.TypeAttributes,System.Type,System.Reflection.Emit.PackingSize,System.Int32)">
          <source>The attributes of the defined type.</source>
          <target state="translated">Os atributos do tipo definido.</target>       </trans-unit>
        <trans-unit id="455" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineType(System.String,System.Reflection.TypeAttributes,System.Type,System.Reflection.Emit.PackingSize,System.Int32)">
          <source>The type that the defined type extends.</source>
          <target state="translated">O tipo que o tipo definido estende.</target>       </trans-unit>
        <trans-unit id="456" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineType(System.String,System.Reflection.TypeAttributes,System.Type,System.Reflection.Emit.PackingSize,System.Int32)">
          <source>The packing size of the type.</source>
          <target state="translated">O tamanho de empacotamento do tipo.</target>       </trans-unit>
        <trans-unit id="457" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineType(System.String,System.Reflection.TypeAttributes,System.Type,System.Reflection.Emit.PackingSize,System.Int32)">
          <source>The total size of the type.</source>
          <target state="translated">O tamanho total do tipo.</target>       </trans-unit>
        <trans-unit id="458" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineType(System.String,System.Reflection.TypeAttributes,System.Type,System.Reflection.Emit.PackingSize,System.Int32)">
          <source>Constructs a <ph id="ph1">&lt;see langword="TypeBuilder" /&gt;</ph> given the type name, attributes, the type that the defined type extends, the packing size of the defined type, and the total size of the defined type.</source>
          <target state="translated">Constrói um <ph id="ph1">&lt;see langword="TypeBuilder" /&gt;</ph> dado o nome do tipo, os atributos, o tipo que o tipo definido estende, o tamanho de empacotamento do tipo definido e o tamanho total do tipo definido.</target>       </trans-unit>
        <trans-unit id="459" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineType(System.String,System.Reflection.TypeAttributes,System.Type,System.Reflection.Emit.PackingSize,System.Int32)">
          <source>A <ph id="ph1">&lt;see langword="TypeBuilder" /&gt;</ph> created with all of the requested attributes.</source>
          <target state="translated">Um <ph id="ph1">&lt;see langword="TypeBuilder" /&gt;</ph> criado com todos os atributos solicitados.</target>       </trans-unit>
        <trans-unit id="460" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.DefineType(System.String,System.Reflection.TypeAttributes,System.Type,System.Reflection.Emit.PackingSize,System.Int32)">
          <source>Type names must be unique within an assembly.</source>
          <target state="translated">Nomes de tipo devem ser exclusivos dentro de um assembly.</target>       </trans-unit>
        <trans-unit id="461" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.DefineType(System.String,System.Reflection.TypeAttributes,System.Type,System.Reflection.Emit.PackingSize,System.Int32)">
          <source>You cannot have two types with the same name in two different modules of an assembly.</source>
          <target state="translated">Você não pode ter dois tipos com o mesmo nome em dois módulos diferentes de um assembly.</target>       </trans-unit>
        <trans-unit id="462" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.DefineType(System.String,System.Reflection.TypeAttributes,System.Type,System.Reflection.Emit.PackingSize,System.Int32)">
          <source>Starting with the <ph id="ph1">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</ph>, this member no longer requires <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> with the <ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType&gt;</ph> flag.</source>
          <target state="translated">Começando com o <ph id="ph1">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</ph>, esse membro não requer mais <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> com o <ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType&gt;</ph> sinalizador.</target>       </trans-unit>
        <trans-unit id="463" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.DefineType(System.String,System.Reflection.TypeAttributes,System.Type,System.Reflection.Emit.PackingSize,System.Int32)">
          <source>(See <bpt id="p1">[</bpt>Security Issues in Reflection Emit<ept id="p1">](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)</ept>.) To use this functionality, your application should target the <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> or later.</source>
          <target state="translated">(Consulte <bpt id="p1">[</bpt>problemas de segurança em reflexão emitir<ept id="p1">](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)</ept>.) Para usar essa funcionalidade, seu aplicativo deve ser direcionado ao <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> ou posterior.</target>       </trans-unit>
        <trans-unit id="464" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.DefineType(System.String,System.Reflection.TypeAttributes,System.Type,System.Reflection.Emit.PackingSize,System.Int32)">
          <source>The following example creates a <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> in the current dynamic module using <ph id="ph2">`CreateType`</ph>, builds and completes the type, and saves the assembly.</source>
          <target state="translated">O exemplo a seguir cria um <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> no módulo dinâmico atual usando <ph id="ph2">`CreateType`</ph>, compilações e conclui o tipo e salva o assembly.</target>       </trans-unit>
        <trans-unit id="465" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineType(System.String,System.Reflection.TypeAttributes,System.Type,System.Reflection.Emit.PackingSize,System.Int32)">
          <source>A type with the given name exists in the parent assembly of this module.</source>
          <target state="translated">Existe um tipo com o nome especificado no assembly pai deste módulo.</target>       </trans-unit>
        <trans-unit id="466" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineType(System.String,System.Reflection.TypeAttributes,System.Type,System.Reflection.Emit.PackingSize,System.Int32)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="467" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineType(System.String,System.Reflection.TypeAttributes,System.Type,System.Reflection.Emit.PackingSize,System.Int32)">
          <source>Nested type attributes are set on a type that is not nested.</source>
          <target state="translated">Atributos de tipo aninhado são definidos em um tipo que não está aninhado.</target>       </trans-unit>
        <trans-unit id="468" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineType(System.String,System.Reflection.TypeAttributes,System.Type,System.Reflection.Emit.PackingSize,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> é <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="469" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineUninitializedData(System.String,System.Int32,System.Reflection.FieldAttributes)">
          <source>The name used to refer to the data.</source>
          <target state="translated">O nome usado para fazer referência aos dados.</target>       </trans-unit>
        <trans-unit id="470" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineUninitializedData(System.String,System.Int32,System.Reflection.FieldAttributes)">
          <source><bpt id="p1">&lt;c&gt;</bpt>name<ept id="p1">&lt;/c&gt;</ept> cannot contain embedded nulls.</source>
          <target state="translated"><bpt id="p1">&lt;c&gt;</bpt>name<ept id="p1">&lt;/c&gt;</ept> não pode conter nulos inseridos.</target>       </trans-unit>
        <trans-unit id="471" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineUninitializedData(System.String,System.Int32,System.Reflection.FieldAttributes)">
          <source>The size of the data field.</source>
          <target state="translated">O tamanho do campo de dados.</target>       </trans-unit>
        <trans-unit id="472" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineUninitializedData(System.String,System.Int32,System.Reflection.FieldAttributes)">
          <source>The attributes for the field.</source>
          <target state="translated">Os atributos do campo.</target>       </trans-unit>
        <trans-unit id="473" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineUninitializedData(System.String,System.Int32,System.Reflection.FieldAttributes)">
          <source>Defines an uninitialized data field in the .sdata section of the portable executable (PE) file.</source>
          <target state="translated">Define o campo de dados não inicializado na seção .sdata do arquivo PE (executável portátil).</target>       </trans-unit>
        <trans-unit id="474" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineUninitializedData(System.String,System.Int32,System.Reflection.FieldAttributes)">
          <source>A field to reference the data.</source>
          <target state="translated">Um campo para fazer referência aos dados.</target>       </trans-unit>
        <trans-unit id="475" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.DefineUninitializedData(System.String,System.Int32,System.Reflection.FieldAttributes)">
          <source><ph id="ph1">&lt;xref:System.Reflection.FieldAttributes.Static&gt;</ph> is automatically included in <ph id="ph2">`attributes`</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Reflection.FieldAttributes.Static&gt;</ph> é incluído automaticamente no <ph id="ph2">`attributes`</ph>.</target>       </trans-unit>
        <trans-unit id="476" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.DefineUninitializedData(System.String,System.Int32,System.Reflection.FieldAttributes)">
          <source>The data defined by this method is not created until the <ph id="ph1">&lt;xref:System.Reflection.Emit.ModuleBuilder.CreateGlobalFunctions%2A&gt;</ph> method is called.</source>
          <target state="translated">Os dados definidos por este método não são criados até que o <ph id="ph1">&lt;xref:System.Reflection.Emit.ModuleBuilder.CreateGlobalFunctions%2A&gt;</ph> método é chamado.</target>       </trans-unit>
        <trans-unit id="477" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.DefineUninitializedData(System.String,System.Int32,System.Reflection.FieldAttributes)">
          <source>Starting with the <ph id="ph1">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</ph>, this member no longer requires <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> with the <ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType&gt;</ph> flag.</source>
          <target state="translated">Começando com o <ph id="ph1">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</ph>, esse membro não requer mais <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> com o <ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType&gt;</ph> sinalizador.</target>       </trans-unit>
        <trans-unit id="478" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.DefineUninitializedData(System.String,System.Int32,System.Reflection.FieldAttributes)">
          <source>(See <bpt id="p1">[</bpt>Security Issues in Reflection Emit<ept id="p1">](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)</ept>.) To use this functionality, your application should target the <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> or later.</source>
          <target state="translated">(Consulte <bpt id="p1">[</bpt>problemas de segurança em reflexão emitir<ept id="p1">](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)</ept>.) Para usar essa funcionalidade, seu aplicativo deve ser direcionado ao <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> ou posterior.</target>       </trans-unit>
        <trans-unit id="479" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineUninitializedData(System.String,System.Int32,System.Reflection.FieldAttributes)">
          <source>The length of <ph id="ph1">&lt;paramref name="name" /&gt;</ph> is zero.</source>
          <target state="translated">O comprimento de <ph id="ph1">&lt;paramref name="name" /&gt;</ph> é zero.</target>       </trans-unit>
        <trans-unit id="480" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineUninitializedData(System.String,System.Int32,System.Reflection.FieldAttributes)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="481" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineUninitializedData(System.String,System.Int32,System.Reflection.FieldAttributes)">
          <source><ph id="ph1">&lt;paramref name="size" /&gt;</ph> is less than or equal to zero, or greater than or equal to 0x003f0000.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="size" /&gt;</ph> é menor que ou igual a zero, ou maior que ou igual a 0x003f0000.</target>       </trans-unit>
        <trans-unit id="482" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineUninitializedData(System.String,System.Int32,System.Reflection.FieldAttributes)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> é <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="483" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineUninitializedData(System.String,System.Int32,System.Reflection.FieldAttributes)">
          <source><ph id="ph1">&lt;see cref="M:System.Reflection.Emit.ModuleBuilder.CreateGlobalFunctions" /&gt;</ph> has been previously called.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="M:System.Reflection.Emit.ModuleBuilder.CreateGlobalFunctions" /&gt;</ph> foi chamado anteriormente.</target>       </trans-unit>
        <trans-unit id="484" translate="yes" xml:space="preserve" uid="T:System.Reflection.Emit.ModuleBuilder">
          <source>Defines an unmanaged resource in this module.</source>
          <target state="translated">Define um recurso não gerenciado neste módulo.</target>       </trans-unit>
        <trans-unit id="485" translate="yes" xml:space="preserve" uid="T:System.Reflection.Emit.ModuleBuilder">
          <source>The binary large object (BLOB) must have the right format for a Win32 resource.</source>
          <target state="translated">O BLOB (objeto binário grande) deve ter o formato correto para um recurso do Win32.</target>       </trans-unit>
        <trans-unit id="486" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineUnmanagedResource(System.Byte[])">
          <source>An opaque BLOB that represents an unmanaged resource</source>
          <target state="translated">Um BLOB opaco que representa um recurso não gerenciado</target>       </trans-unit>
        <trans-unit id="487" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineUnmanagedResource(System.Byte[])">
          <source>Defines an unmanaged embedded resource given an opaque binary large object (BLOB) of bytes.</source>
          <target state="translated">Define um recurso inserido não gerenciado recebe um BLOB (objeto binário grande) opaco de bytes.</target>       </trans-unit>
        <trans-unit id="488" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.DefineUnmanagedResource(System.Byte[])">
          <source>An assembly can be associated with only one unmanaged resource.</source>
          <target state="translated">Um assembly pode ser associado a apenas um recurso não gerenciado.</target>       </trans-unit>
        <trans-unit id="489" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.DefineUnmanagedResource(System.Byte[])">
          <source>This means that calling <ph id="ph1">`DefineVersionInfoResource`</ph> or <ph id="ph2">`DefineUnmanagedResource`</ph> after either one of the methods was called previously throws <ph id="ph3">&lt;xref:System.ArgumentException&gt;</ph>.</source>
          <target state="translated">Isso significa que a chamada <ph id="ph1">`DefineVersionInfoResource`</ph> ou <ph id="ph2">`DefineUnmanagedResource`</ph> após um um dos métodos foi chamado anteriormente gera <ph id="ph3">&lt;xref:System.ArgumentException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="490" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.DefineUnmanagedResource(System.Byte[])">
          <source>Multiple unmanaged resources need to be merged with a tool such as the Microsoft ResMerge utility (not supplied with the common language runtime).</source>
          <target state="translated">Vários recursos não gerenciados precisam ser mesclada com uma ferramenta como o utilitário Microsoft ResMerge (não é fornecido com o common language runtime).</target>       </trans-unit>
        <trans-unit id="491" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.DefineUnmanagedResource(System.Byte[])">
          <source>Starting with the <ph id="ph1">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</ph>, this member no longer requires <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> with the <ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType&gt;</ph> flag.</source>
          <target state="translated">Começando com o <ph id="ph1">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</ph>, esse membro não requer mais <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> com o <ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType&gt;</ph> sinalizador.</target>       </trans-unit>
        <trans-unit id="492" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.DefineUnmanagedResource(System.Byte[])">
          <source>(See <bpt id="p1">[</bpt>Security Issues in Reflection Emit<ept id="p1">](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)</ept>.) To use this functionality, your application should target the <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> or later.</source>
          <target state="translated">(Consulte <bpt id="p1">[</bpt>problemas de segurança em reflexão emitir<ept id="p1">](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)</ept>.) Para usar essa funcionalidade, seu aplicativo deve ser direcionado ao <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> ou posterior.</target>       </trans-unit>
        <trans-unit id="493" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineUnmanagedResource(System.Byte[])">
          <source>An unmanaged resource has already been defined in the module's assembly.</source>
          <target state="translated">Um recurso não gerenciado já foi definido no assembly do módulo.</target>       </trans-unit>
        <trans-unit id="494" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineUnmanagedResource(System.Byte[])">
          <source><ph id="ph1">&lt;paramref name="resource" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="resource" /&gt;</ph> é <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="495" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineUnmanagedResource(System.String)">
          <source>The name of the unmanaged resource file.</source>
          <target state="translated">O nome do arquivo de recurso não gerenciado.</target>       </trans-unit>
        <trans-unit id="496" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineUnmanagedResource(System.String)">
          <source>Defines an unmanaged resource given the name of Win32 resource file.</source>
          <target state="translated">Define um recurso não gerenciado dado o nome do arquivo de recurso Win32.</target>       </trans-unit>
        <trans-unit id="497" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.DefineUnmanagedResource(System.String)">
          <source>An assembly can be associated with only one unmanaged resource.</source>
          <target state="translated">Um assembly pode ser associado a apenas um recurso não gerenciado.</target>       </trans-unit>
        <trans-unit id="498" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.DefineUnmanagedResource(System.String)">
          <source>This means that calling <ph id="ph1">`DefineVersionInfoResource`</ph> or <ph id="ph2">`DefineUnmanagedResource`</ph> after either one of the methods was called previously throws <ph id="ph3">&lt;xref:System.ArgumentException&gt;</ph>.</source>
          <target state="translated">Isso significa que a chamada <ph id="ph1">`DefineVersionInfoResource`</ph> ou <ph id="ph2">`DefineUnmanagedResource`</ph> após um um dos métodos foi chamado anteriormente gera <ph id="ph3">&lt;xref:System.ArgumentException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="499" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.DefineUnmanagedResource(System.String)">
          <source>Multiple unmanaged resources need to be merged with a tool such as the Microsoft ResMerge utility (not supplied with the common language runtime).</source>
          <target state="translated">Vários recursos não gerenciados precisam ser mesclada com uma ferramenta como o utilitário Microsoft ResMerge (não é fornecido com o common language runtime).</target>       </trans-unit>
        <trans-unit id="500" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.DefineUnmanagedResource(System.String)">
          <source>Starting with the <ph id="ph1">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</ph>, this member no longer requires <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> with the <ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType&gt;</ph> flag.</source>
          <target state="translated">Começando com o <ph id="ph1">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</ph>, esse membro não requer mais <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> com o <ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType&gt;</ph> sinalizador.</target>       </trans-unit>
        <trans-unit id="501" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.DefineUnmanagedResource(System.String)">
          <source>(See <bpt id="p1">[</bpt>Security Issues in Reflection Emit<ept id="p1">](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)</ept>.) To use this functionality, your application should target the <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> or later.</source>
          <target state="translated">(Consulte <bpt id="p1">[</bpt>problemas de segurança em reflexão emitir<ept id="p1">](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)</ept>.) Para usar essa funcionalidade, seu aplicativo deve ser direcionado ao <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> ou posterior.</target>       </trans-unit>
        <trans-unit id="502" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineUnmanagedResource(System.String)">
          <source>An unmanaged resource has already been defined in the module's assembly.</source>
          <target state="translated">Um recurso não gerenciado já foi definido no assembly do módulo.</target>       </trans-unit>
        <trans-unit id="503" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineUnmanagedResource(System.String)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="504" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineUnmanagedResource(System.String)">
          <source><ph id="ph1">&lt;paramref name="resourceFileName" /&gt;</ph> is the empty string ("").</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="resourceFileName" /&gt;</ph> é a cadeia de caracteres vazia ("").</target>       </trans-unit>
        <trans-unit id="505" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineUnmanagedResource(System.String)">
          <source><ph id="ph1">&lt;paramref name="resourceFileName" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="resourceFileName" /&gt;</ph> é <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="506" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineUnmanagedResource(System.String)">
          <source><ph id="ph1">&lt;paramref name="resourceFileName" /&gt;</ph> is not found.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="resourceFileName" /&gt;</ph> não foi encontrado.</target>       </trans-unit>
        <trans-unit id="507" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineUnmanagedResource(System.String)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="508" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineUnmanagedResource(System.String)">
          <source><ph id="ph1">&lt;paramref name="resourceFileName" /&gt;</ph> is a directory.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="resourceFileName" /&gt;</ph> é um diretório.</target>       </trans-unit>
        <trans-unit id="509" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.Equals(System.Object)">
          <source>An object to compare with this instance, or <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Um objeto a ser comparado com essa instância ou <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="510" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.Equals(System.Object)">
          <source>Returns a value that indicates whether this instance is equal to the specified object.</source>
          <target state="translated">Retorna um valor que indica se essa instância é igual ao objeto especificado.</target>       </trans-unit>
        <trans-unit id="511" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.Equals(System.Object)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if <ph id="ph2">&lt;paramref name="obj" /&gt;</ph> equals the type and value of this instance; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> se <ph id="ph2">&lt;paramref name="obj" /&gt;</ph> for igual ao tipo e ao valor dessa instância, caso contrário, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="512" translate="yes" xml:space="preserve" uid="P:System.Reflection.Emit.ModuleBuilder.FullyQualifiedName">
          <source>Gets a <ph id="ph1">&lt;see langword="String" /&gt;</ph> representing the fully qualified name and path to this module.</source>
          <target state="translated">Obtém uma <ph id="ph1">&lt;see langword="String" /&gt;</ph> que representa o nome totalmente qualificado e o caminho para esse módulo.</target>       </trans-unit>
        <trans-unit id="513" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.ModuleBuilder.FullyQualifiedName">
          <source>The fully qualified module name.</source>
          <target state="translated">O nome do módulo totalmente qualificado.</target>       </trans-unit>
        <trans-unit id="514" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.ModuleBuilder.FullyQualifiedName">
          <source>To get the name without the path, use <ph id="ph1">`Name`</ph>.</source>
          <target state="translated">Para obter o nome sem o caminho, use <ph id="ph1">`Name`</ph>.</target>       </trans-unit>
        <trans-unit id="515" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.ModuleBuilder.FullyQualifiedName">
          <source>The case of a module name is platform dependent.</source>
          <target state="translated">No caso de um nome de módulo é dependente de plataforma.</target>       </trans-unit>
        <trans-unit id="516" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.ModuleBuilder.FullyQualifiedName">
          <source>Accesses information in the path.</source>
          <target state="translated">Acessa informações no caminho.</target>       </trans-unit>
        <trans-unit id="517" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.ModuleBuilder.FullyQualifiedName">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /&gt;</ph>.</source>
          <target state="translated">Enumeração associada: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="518" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetArrayMethod(System.Type,System.String,System.Reflection.CallingConventions,System.Type,System.Type[])">
          <source>An array class.</source>
          <target state="translated">Uma classe de matriz.</target>       </trans-unit>
        <trans-unit id="519" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetArrayMethod(System.Type,System.String,System.Reflection.CallingConventions,System.Type,System.Type[])">
          <source>The name of a method on the array class.</source>
          <target state="translated">O nome de um método na classe de matriz.</target>       </trans-unit>
        <trans-unit id="520" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetArrayMethod(System.Type,System.String,System.Reflection.CallingConventions,System.Type,System.Type[])">
          <source>The method's calling convention.</source>
          <target state="translated">A convenção de chamada do método.</target>       </trans-unit>
        <trans-unit id="521" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetArrayMethod(System.Type,System.String,System.Reflection.CallingConventions,System.Type,System.Type[])">
          <source>The return type of the method.</source>
          <target state="translated">O tipo de retorno do método.</target>       </trans-unit>
        <trans-unit id="522" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetArrayMethod(System.Type,System.String,System.Reflection.CallingConventions,System.Type,System.Type[])">
          <source>The types of the method's parameters.</source>
          <target state="translated">Os tipos de parâmetros do método.</target>       </trans-unit>
        <trans-unit id="523" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetArrayMethod(System.Type,System.String,System.Reflection.CallingConventions,System.Type,System.Type[])">
          <source>Returns the named method on an array class.</source>
          <target state="translated">Retorna o método nomeado em uma classe de matriz.</target>       </trans-unit>
        <trans-unit id="524" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetArrayMethod(System.Type,System.String,System.Reflection.CallingConventions,System.Type,System.Type[])">
          <source>The named method on an array class.</source>
          <target state="translated">O método nomeado em uma classe de matriz.</target>       </trans-unit>
        <trans-unit id="525" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.GetArrayMethod(System.Type,System.String,System.Reflection.CallingConventions,System.Type,System.Type[])">
          <source><ph id="ph1">`GetArrayMethod`</ph> is useful when you have an array of a type whose definition has not been completed and you want to access methods defined on <ph id="ph2">&lt;xref:System.Array&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">`GetArrayMethod`</ph> é útil quando você tem uma matriz de um tipo cuja definição não foi concluída e você deseja acessar métodos definidos no <ph id="ph2">&lt;xref:System.Array&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="526" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.GetArrayMethod(System.Type,System.String,System.Reflection.CallingConventions,System.Type,System.Type[])">
          <source>For example, you might define a type and want to define a method that takes an array of the type as a parameter.</source>
          <target state="translated">Por exemplo, você pode definir um tipo e deseja definir um método que usa uma matriz do tipo como um parâmetro.</target>       </trans-unit>
        <trans-unit id="527" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.GetArrayMethod(System.Type,System.String,System.Reflection.CallingConventions,System.Type,System.Type[])">
          <source>In order to access the elements of the array, you will need to call methods of the <ph id="ph1">&lt;xref:System.Array&gt;</ph> class.</source>
          <target state="translated">Para acessar os elementos da matriz, você precisará chamar métodos do <ph id="ph1">&lt;xref:System.Array&gt;</ph> classe.</target>       </trans-unit>
        <trans-unit id="528" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.GetArrayMethod(System.Type,System.String,System.Reflection.CallingConventions,System.Type,System.Type[])">
          <source>The following example demonstrates how to use <ph id="ph1">&lt;xref:System.Reflection.Emit.ModuleBuilder.GetArrayMethod%2A&gt;</ph> to obtain the <ph id="ph2">&lt;xref:System.Reflection.MethodInfo&gt;</ph> corresponding to a method that returns an array value.</source>
          <target state="translated">O exemplo a seguir demonstra como usar <ph id="ph1">&lt;xref:System.Reflection.Emit.ModuleBuilder.GetArrayMethod%2A&gt;</ph> para obter o <ph id="ph2">&lt;xref:System.Reflection.MethodInfo&gt;</ph> correspondente a um método que retorna um valor de matriz.</target>       </trans-unit>
        <trans-unit id="529" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetArrayMethod(System.Type,System.String,System.Reflection.CallingConventions,System.Type,System.Type[])">
          <source><ph id="ph1">&lt;paramref name="arrayClass" /&gt;</ph> is not an array.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="arrayClass" /&gt;</ph> não é uma matriz.</target>       </trans-unit>
        <trans-unit id="530" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetArrayMethod(System.Type,System.String,System.Reflection.CallingConventions,System.Type,System.Type[])">
          <source><ph id="ph1">&lt;paramref name="arrayClass" /&gt;</ph> or <ph id="ph2">&lt;paramref name="methodName" /&gt;</ph> is <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="arrayClass" /&gt;</ph> ou <ph id="ph2">&lt;paramref name="methodName" /&gt;</ph> é <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="531" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetArrayMethodToken(System.Type,System.String,System.Reflection.CallingConventions,System.Type,System.Type[])">
          <source>The object for the array.</source>
          <target state="translated">O objeto para a matriz.</target>       </trans-unit>
        <trans-unit id="532" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetArrayMethodToken(System.Type,System.String,System.Reflection.CallingConventions,System.Type,System.Type[])">
          <source>A string that contains the name of the method.</source>
          <target state="translated">Uma cadeia de caracteres que contém o nome do método.</target>       </trans-unit>
        <trans-unit id="533" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetArrayMethodToken(System.Type,System.String,System.Reflection.CallingConventions,System.Type,System.Type[])">
          <source>The calling convention for the method.</source>
          <target state="translated">A convenção de chamada para o método.</target>       </trans-unit>
        <trans-unit id="534" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetArrayMethodToken(System.Type,System.String,System.Reflection.CallingConventions,System.Type,System.Type[])">
          <source>The return type of the method.</source>
          <target state="translated">O tipo de retorno do método.</target>       </trans-unit>
        <trans-unit id="535" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetArrayMethodToken(System.Type,System.String,System.Reflection.CallingConventions,System.Type,System.Type[])">
          <source>The types of the parameters of the method.</source>
          <target state="translated">Os tipos dos parâmetros do método.</target>       </trans-unit>
        <trans-unit id="536" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetArrayMethodToken(System.Type,System.String,System.Reflection.CallingConventions,System.Type,System.Type[])">
          <source>Returns the token for the named method on an array class.</source>
          <target state="translated">Retorna o token para o método chamado em uma classe de matriz.</target>       </trans-unit>
        <trans-unit id="537" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetArrayMethodToken(System.Type,System.String,System.Reflection.CallingConventions,System.Type,System.Type[])">
          <source>The token for the named method on an array class.</source>
          <target state="translated">O token para o método nomeado em uma classe de matriz.</target>       </trans-unit>
        <trans-unit id="538" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.GetArrayMethodToken(System.Type,System.String,System.Reflection.CallingConventions,System.Type,System.Type[])">
          <source>This method is similar to <ph id="ph1">&lt;xref:System.Reflection.Emit.ModuleBuilder.GetArrayMethod%2A&gt;</ph>, except that it returns the token of the array method instead of the method itself.</source>
          <target state="translated">Esse método é semelhante ao <ph id="ph1">&lt;xref:System.Reflection.Emit.ModuleBuilder.GetArrayMethod%2A&gt;</ph>, exceto que ele retorna o token do método de matriz em vez do método em si.</target>       </trans-unit>
        <trans-unit id="539" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.GetArrayMethodToken(System.Type,System.String,System.Reflection.CallingConventions,System.Type,System.Type[])">
          <source>The following example demonstrates how to use <ph id="ph1">&lt;xref:System.Reflection.Emit.ModuleBuilder.GetArrayMethod%2A&gt;</ph> to obtain the <ph id="ph2">&lt;xref:System.Reflection.Emit.MethodToken&gt;</ph> corresponding to a method that returns an array value.</source>
          <target state="translated">O exemplo a seguir demonstra como usar <ph id="ph1">&lt;xref:System.Reflection.Emit.ModuleBuilder.GetArrayMethod%2A&gt;</ph> para obter o <ph id="ph2">&lt;xref:System.Reflection.Emit.MethodToken&gt;</ph> correspondente a um método que retorna um valor de matriz.</target>       </trans-unit>
        <trans-unit id="540" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetArrayMethodToken(System.Type,System.String,System.Reflection.CallingConventions,System.Type,System.Type[])">
          <source><ph id="ph1">&lt;paramref name="arrayClass" /&gt;</ph> is not an array.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="arrayClass" /&gt;</ph> não é uma matriz.</target>       </trans-unit>
        <trans-unit id="541" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetArrayMethodToken(System.Type,System.String,System.Reflection.CallingConventions,System.Type,System.Type[])">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="542" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetArrayMethodToken(System.Type,System.String,System.Reflection.CallingConventions,System.Type,System.Type[])">
          <source>The length of <ph id="ph1">&lt;paramref name="methodName" /&gt;</ph> is zero.</source>
          <target state="translated">O comprimento de <ph id="ph1">&lt;paramref name="methodName" /&gt;</ph> é zero.</target>       </trans-unit>
        <trans-unit id="543" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetArrayMethodToken(System.Type,System.String,System.Reflection.CallingConventions,System.Type,System.Type[])">
          <source><ph id="ph1">&lt;paramref name="arrayClass" /&gt;</ph> or <ph id="ph2">&lt;paramref name="methodName" /&gt;</ph> is <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="arrayClass" /&gt;</ph> ou <ph id="ph2">&lt;paramref name="methodName" /&gt;</ph> é <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="544" translate="yes" xml:space="preserve" uid="T:System.Reflection.Emit.ModuleBuilder">
          <source>Returns the token used to identify the specified constructor within this module.</source>
          <target state="translated">Retorna o token usado para identificar o construtor especificado neste módulo.</target>       </trans-unit>
        <trans-unit id="545" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetConstructorToken(System.Reflection.ConstructorInfo)">
          <source>The constructor to get a token for.</source>
          <target state="translated">O construtor para o qual obter um token.</target>       </trans-unit>
        <trans-unit id="546" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetConstructorToken(System.Reflection.ConstructorInfo)">
          <source>Returns the token used to identify the specified constructor within this module.</source>
          <target state="translated">Retorna o token usado para identificar o construtor especificado neste módulo.</target>       </trans-unit>
        <trans-unit id="547" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetConstructorToken(System.Reflection.ConstructorInfo)">
          <source>The token used to identify the specified constructor within this module.</source>
          <target state="translated">O token usado para identificar o construtor especificado neste módulo.</target>       </trans-unit>
        <trans-unit id="548" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetConstructorToken(System.Reflection.ConstructorInfo)">
          <source><ph id="ph1">&lt;paramref name="con" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="con" /&gt;</ph> é <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="549" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetConstructorToken(System.Reflection.ConstructorInfo,System.Collections.Generic.IEnumerable{System.Type})">
          <source>The constructor to get a token for.</source>
          <target state="translated">O construtor para o qual obter um token.</target>       </trans-unit>
        <trans-unit id="550" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetConstructorToken(System.Reflection.ConstructorInfo,System.Collections.Generic.IEnumerable{System.Type})">
          <source>A collection of the types of the optional parameters to the constructor.</source>
          <target state="translated">Uma coleção de tipos dos parâmetros opcionais para o construtor.</target>       </trans-unit>
        <trans-unit id="551" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetConstructorToken(System.Reflection.ConstructorInfo,System.Collections.Generic.IEnumerable{System.Type})">
          <source>Returns the token used to identify the constructor that has the specified attributes and parameter types within this module.</source>
          <target state="translated">Retorna o token usado para identificar o construtor que tem os atributos e tipos de parâmetro especificados neste módulo.</target>       </trans-unit>
        <trans-unit id="552" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetConstructorToken(System.Reflection.ConstructorInfo,System.Collections.Generic.IEnumerable{System.Type})">
          <source>The token used to identify the specified constructor within this module.</source>
          <target state="translated">O token usado para identificar o construtor especificado neste módulo.</target>       </trans-unit>
        <trans-unit id="553" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetConstructorToken(System.Reflection.ConstructorInfo,System.Collections.Generic.IEnumerable{System.Type})">
          <source><ph id="ph1">&lt;paramref name="constructor" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="constructor" /&gt;</ph> é <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="554" translate="yes" xml:space="preserve" uid="T:System.Reflection.Emit.ModuleBuilder">
          <source>Returns the custom attributes that are applied to the current <ph id="ph1">&lt;see cref="T:System.Reflection.Emit.ModuleBuilder" /&gt;</ph>.</source>
          <target state="translated">Retorna os atributos personalizados que são aplicados ao <ph id="ph1">&lt;see cref="T:System.Reflection.Emit.ModuleBuilder" /&gt;</ph> atual.</target>       </trans-unit>
        <trans-unit id="555" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetCustomAttributes(System.Boolean)">
          <source>This argument is ignored for objects of this type.</source>
          <target state="translated">Este argumento é ignorado para objetos deste tipo.</target>       </trans-unit>
        <trans-unit id="556" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetCustomAttributes(System.Boolean)">
          <source>Returns all the custom attributes that have been applied to the current <ph id="ph1">&lt;see cref="T:System.Reflection.Emit.ModuleBuilder" /&gt;</ph>.</source>
          <target state="translated">Retorna todos os atributos personalizados que foram aplicados ao <ph id="ph1">&lt;see cref="T:System.Reflection.Emit.ModuleBuilder" /&gt;</ph> atual.</target>       </trans-unit>
        <trans-unit id="557" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetCustomAttributes(System.Boolean)">
          <source>An array that contains the custom attributes; the array is empty if there are no attributes.</source>
          <target state="translated">Uma matriz que contém os atributos personalizados; a matriz será vazia se não houver nenhum atributo.</target>       </trans-unit>
        <trans-unit id="558" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetCustomAttributes(System.Type,System.Boolean)">
          <source>The base type from which attributes derive.</source>
          <target state="translated">O tipo base do qual derivam os atributos.</target>       </trans-unit>
        <trans-unit id="559" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetCustomAttributes(System.Type,System.Boolean)">
          <source>This argument is ignored for objects of this type.</source>
          <target state="translated">Este argumento é ignorado para objetos deste tipo.</target>       </trans-unit>
        <trans-unit id="560" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetCustomAttributes(System.Type,System.Boolean)">
          <source>Returns all the custom attributes that have been applied to the current <ph id="ph1">&lt;see cref="T:System.Reflection.Emit.ModuleBuilder" /&gt;</ph>, and that derive from a specified attribute type.</source>
          <target state="translated">Retorna todos os atributos personalizados que foram aplicados ao <ph id="ph1">&lt;see cref="T:System.Reflection.Emit.ModuleBuilder" /&gt;</ph> atual e que derivam de um tipo de atributo especificado.</target>       </trans-unit>
        <trans-unit id="561" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetCustomAttributes(System.Type,System.Boolean)">
          <source>An array that contains the custom attributes that are derived, at any level, from <ph id="ph1">&lt;paramref name="attributeType" /&gt;</ph>; the array is empty if there are no such attributes.</source>
          <target state="translated">Uma matriz que contém os atributos personalizados que são derivados em qualquer nível de <ph id="ph1">&lt;paramref name="attributeType" /&gt;</ph>; a matriz será vazia se não houver nenhum desses atributos.</target>       </trans-unit>
        <trans-unit id="562" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetCustomAttributes(System.Type,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="attributeType" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="attributeType" /&gt;</ph> é <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="563" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetCustomAttributes(System.Type,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="attributeType" /&gt;</ph> is not a <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> object supplied by the runtime.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="attributeType" /&gt;</ph> não é um objeto <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> fornecido pelo tempo de execução.</target>       </trans-unit>
        <trans-unit id="564" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetCustomAttributes(System.Type,System.Boolean)">
          <source>For example, <ph id="ph1">&lt;paramref name="attributeType" /&gt;</ph> is a <ph id="ph2">&lt;see cref="T:System.Reflection.Emit.TypeBuilder" /&gt;</ph> object.</source>
          <target state="translated">Por exemplo, <ph id="ph1">&lt;paramref name="attributeType" /&gt;</ph> é um objeto <ph id="ph2">&lt;see cref="T:System.Reflection.Emit.TypeBuilder" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="565" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetCustomAttributesData">
          <source>Returns information about the attributes that have been applied to the current <ph id="ph1">&lt;see cref="T:System.Reflection.Emit.ModuleBuilder" /&gt;</ph>, expressed as <ph id="ph2">&lt;see cref="T:System.Reflection.CustomAttributeData" /&gt;</ph> objects.</source>
          <target state="translated">Retorna informações sobre os atributos que foram aplicados ao <ph id="ph1">&lt;see cref="T:System.Reflection.Emit.ModuleBuilder" /&gt;</ph> atual, expressos como objetos <ph id="ph2">&lt;see cref="T:System.Reflection.CustomAttributeData" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="566" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetCustomAttributesData">
          <source>A generic list of <ph id="ph1">&lt;see cref="T:System.Reflection.CustomAttributeData" /&gt;</ph> objects representing data about the attributes that have been applied to the current module.</source>
          <target state="translated">Uma lista genérica de objetos <ph id="ph1">&lt;see cref="T:System.Reflection.CustomAttributeData" /&gt;</ph> que representam dados sobre os atributos que foram aplicados ao módulo atual.</target>       </trans-unit>
        <trans-unit id="567" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.GetCustomAttributesData">
          <source>Use this method to examine the custom attributes of code in the reflection-only context, in cases where the custom attributes themselves are defined in code that is loaded into the reflection-only context.</source>
          <target state="translated">Use esse método para examinar os atributos personalizados de código no contexto exclusivo de reflexão, em casos onde os atributos personalizados próprios são definidos no código que é carregado no contexto exclusivo de reflexão.</target>       </trans-unit>
        <trans-unit id="568" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.GetCustomAttributesData">
          <source>Methods like <ph id="ph1">&lt;xref:System.Attribute.GetCustomAttributes%2A?displayProperty=nameWithType&gt;</ph> and <ph id="ph2">&lt;xref:System.Reflection.Assembly.GetCustomAttributes%2A?displayProperty=nameWithType&gt;</ph> cannot be used in such cases, because they create instances of the attributes.</source>
          <target state="translated">Métodos como <ph id="ph1">&lt;xref:System.Attribute.GetCustomAttributes%2A?displayProperty=nameWithType&gt;</ph> e <ph id="ph2">&lt;xref:System.Reflection.Assembly.GetCustomAttributes%2A?displayProperty=nameWithType&gt;</ph> não pode ser usado em tais casos, porque eles criar instâncias dos atributos.</target>       </trans-unit>
        <trans-unit id="569" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.GetCustomAttributesData">
          <source>Code in the reflection-only context cannot be executed.</source>
          <target state="translated">O código no contexto exclusivo de reflexão não pode ser executado.</target>       </trans-unit>
        <trans-unit id="570" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.GetCustomAttributesData">
          <source>For more information and for example code, see the <ph id="ph1">&lt;xref:System.Reflection.CustomAttributeData&gt;</ph> class.</source>
          <target state="translated">Para obter mais informações e como código, consulte o <ph id="ph1">&lt;xref:System.Reflection.CustomAttributeData&gt;</ph> classe.</target>       </trans-unit>
        <trans-unit id="571" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetField(System.String,System.Reflection.BindingFlags)">
          <source>The field name.</source>
          <target state="translated">O nome do campo.</target>       </trans-unit>
        <trans-unit id="572" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetField(System.String,System.Reflection.BindingFlags)">
          <source>A combination of the <ph id="ph1">&lt;see langword="BindingFlags" /&gt;</ph> bit flags used to control the search.</source>
          <target state="translated">Uma combinação dos sinalizadores de bit <ph id="ph1">&lt;see langword="BindingFlags" /&gt;</ph> usados para controlar a pesquisa.</target>       </trans-unit>
        <trans-unit id="573" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetField(System.String,System.Reflection.BindingFlags)">
          <source>Returns a module-level field, defined in the .sdata region of the portable executable (PE) file, that has the specified name and binding attributes.</source>
          <target state="translated">Retorna um campo no nível de módulo, definido na região de .sdata o arquivo PE (executável portátil), que tem o nome e os atributos de associação especificados.</target>       </trans-unit>
        <trans-unit id="574" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetField(System.String,System.Reflection.BindingFlags)">
          <source>A field that has the specified name and binding attributes, or <ph id="ph1">&lt;see langword="null" /&gt;</ph> if the field does not exist.</source>
          <target state="translated">Um campo que tem o nome e os atributos de associação especificados ou <ph id="ph1">&lt;see langword="null" /&gt;</ph>, se o campo não existir.</target>       </trans-unit>
        <trans-unit id="575" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.GetField(System.String,System.Reflection.BindingFlags)">
          <source>When you emit dynamic assemblies, fields in the .sdata region of the portable executable (PE) file are defined by using the <ph id="ph1">&lt;xref:System.Reflection.Emit.ModuleBuilder.DefineInitializedData%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.Reflection.Emit.ModuleBuilder.DefineUninitializedData%2A&gt;</ph> methods.</source>
          <target state="translated">Quando você emite assemblies dinâmicos, os campos na região .sdata do arquivo PE (executável portátil) são definidos usando o <ph id="ph1">&lt;xref:System.Reflection.Emit.ModuleBuilder.DefineInitializedData%2A&gt;</ph> ou <ph id="ph2">&lt;xref:System.Reflection.Emit.ModuleBuilder.DefineUninitializedData%2A&gt;</ph> métodos.</target>       </trans-unit>
        <trans-unit id="576" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.GetField(System.String,System.Reflection.BindingFlags)">
          <source>Module-level fields cannot be retrieved until after the <ph id="ph1">&lt;xref:System.Reflection.Emit.ModuleBuilder.CreateGlobalFunctions%2A&gt;</ph> method has been called for the module.</source>
          <target state="translated">Campos de nível de módulo não podem ser recuperados até depois que o <ph id="ph1">&lt;xref:System.Reflection.Emit.ModuleBuilder.CreateGlobalFunctions%2A&gt;</ph> método foi chamado para o módulo.</target>       </trans-unit>
        <trans-unit id="577" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetField(System.String,System.Reflection.BindingFlags)">
          <source>The <ph id="ph1">&lt;paramref name="name" /&gt;</ph> parameter is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">O parâmetro <ph id="ph1">&lt;paramref name="name" /&gt;</ph> é <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="578" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetFields(System.Reflection.BindingFlags)">
          <source>A combination of the <ph id="ph1">&lt;see langword="BindingFlags" /&gt;</ph> bit flags used to control the search.</source>
          <target state="translated">Uma combinação dos sinalizadores de bit <ph id="ph1">&lt;see langword="BindingFlags" /&gt;</ph> usados para controlar a pesquisa.</target>       </trans-unit>
        <trans-unit id="579" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetFields(System.Reflection.BindingFlags)">
          <source>Returns all fields defined in the .sdata region of the portable executable (PE) file that match the specified binding flags.</source>
          <target state="translated">Retorna todos os campos definidos na região .sdata do arquivo PE (executável portátil) que correspondem aos sinalizadores de associação especificados.</target>       </trans-unit>
        <trans-unit id="580" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetFields(System.Reflection.BindingFlags)">
          <source>An array of fields that match the specified flags; the array is empty if no such fields exist.</source>
          <target state="translated">Uma matriz de campos que coincidem com os sinalizadores especificados; a matriz estará vazia se não existirem esses campos.</target>       </trans-unit>
        <trans-unit id="581" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.GetFields(System.Reflection.BindingFlags)">
          <source>When you emit dynamic assemblies, fields in the .sdata region of the portable executable (PE) file are defined by using the <ph id="ph1">&lt;xref:System.Reflection.Emit.ModuleBuilder.DefineInitializedData%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.Reflection.Emit.ModuleBuilder.DefineUninitializedData%2A&gt;</ph> methods.</source>
          <target state="translated">Quando você emite assemblies dinâmicos, os campos na região .sdata do arquivo PE (executável portátil) são definidos usando o <ph id="ph1">&lt;xref:System.Reflection.Emit.ModuleBuilder.DefineInitializedData%2A&gt;</ph> ou <ph id="ph2">&lt;xref:System.Reflection.Emit.ModuleBuilder.DefineUninitializedData%2A&gt;</ph> métodos.</target>       </trans-unit>
        <trans-unit id="582" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.GetFields(System.Reflection.BindingFlags)">
          <source>Module-level fields cannot be retrieved until after the <ph id="ph1">&lt;xref:System.Reflection.Emit.ModuleBuilder.CreateGlobalFunctions%2A&gt;</ph> method has been called for the module.</source>
          <target state="translated">Campos de nível de módulo não podem ser recuperados até depois que o <ph id="ph1">&lt;xref:System.Reflection.Emit.ModuleBuilder.CreateGlobalFunctions%2A&gt;</ph> método foi chamado para o módulo.</target>       </trans-unit>
        <trans-unit id="583" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetFields(System.Reflection.BindingFlags)">
          <source>The <ph id="ph1">&lt;paramref name="name" /&gt;</ph> parameter is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">O parâmetro <ph id="ph1">&lt;paramref name="name" /&gt;</ph> é <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="584" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetFieldToken(System.Reflection.FieldInfo)">
          <source>The field to get a token for.</source>
          <target state="translated">O campo para o qual obter um token.</target>       </trans-unit>
        <trans-unit id="585" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetFieldToken(System.Reflection.FieldInfo)">
          <source>Returns the token used to identify the specified field within this module.</source>
          <target state="translated">Retorna o token usado para identificar o campo especificado neste módulo.</target>       </trans-unit>
        <trans-unit id="586" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetFieldToken(System.Reflection.FieldInfo)">
          <source>The token used to identify the specified field within this module.</source>
          <target state="translated">O token usado para identificar o campo especificado neste módulo.</target>       </trans-unit>
        <trans-unit id="587" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetFieldToken(System.Reflection.FieldInfo)">
          <source><ph id="ph1">&lt;paramref name="field" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="field" /&gt;</ph> é <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="588" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetHashCode">
          <source>Returns the hash code for this instance.</source>
          <target state="translated">Retorna o código hash para essa instância.</target>       </trans-unit>
        <trans-unit id="589" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetHashCode">
          <source>A 32-bit signed integer hash code.</source>
          <target state="translated">Um código de hash do inteiro assinado de 32 bits.</target>       </trans-unit>
        <trans-unit id="590" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>The method name.</source>
          <target state="translated">O nome do método.</target>       </trans-unit>
        <trans-unit id="591" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>A combination of <ph id="ph1">&lt;see langword="BindingFlags" /&gt;</ph> bit flags used to control the search.</source>
          <target state="translated">Uma combinação de sinalizadores de bit <ph id="ph1">&lt;see langword="BindingFlags" /&gt;</ph> usados para controlar a pesquisa.</target>       </trans-unit>
        <trans-unit id="592" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>An object that implements <ph id="ph1">&lt;see langword="Binder" /&gt;</ph>, containing properties related to this method.</source>
          <target state="translated">Um objeto que implementa <ph id="ph1">&lt;see langword="Binder" /&gt;</ph>, contendo as propriedades relacionadas a este método.</target>       </trans-unit>
        <trans-unit id="593" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>The calling convention for the method.</source>
          <target state="translated">A convenção de chamada para o método.</target>       </trans-unit>
        <trans-unit id="594" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>The parameter types of the method.</source>
          <target state="translated">Os tipos de parâmetro do método.</target>       </trans-unit>
        <trans-unit id="595" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>An array of parameter modifiers used to make binding work with parameter signatures in which the types have been modified.</source>
          <target state="translated">Uma matriz de modificadores de parâmetro usados para fazer a associação funcionar com assinaturas de parâmetro nos quais os tipos foram modificados.</target>       </trans-unit>
        <trans-unit id="596" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Returns the module-level method that matches the specified criteria.</source>
          <target state="translated">Retorna o método no nível de módulo que corresponde aos critérios especificados.</target>       </trans-unit>
        <trans-unit id="597" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>A method that is defined at the module level, and matches the specified criteria; or <ph id="ph1">&lt;see langword="null" /&gt;</ph> if such a method does not exist.</source>
          <target state="translated">Um método definido no nível de módulo e corresponde aos critérios especificados; ou <ph id="ph1">&lt;see langword="null" /&gt;</ph>, se tal método não existir.</target>       </trans-unit>
        <trans-unit id="598" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>This method provides the implementation for all overloads of the inherited <ph id="ph1">&lt;xref:System.Reflection.Module.GetMethod%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Esse método fornece a implementação para todas as sobrecargas do herdadas <ph id="ph1">&lt;xref:System.Reflection.Module.GetMethod%2A?displayProperty=nameWithType&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="599" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Use the inherited <ph id="ph1">&lt;xref:System.Reflection.Module.GetMethod%2A?displayProperty=nameWithType&gt;</ph> method to get methods that have been declared at the module level.</source>
          <target state="translated">Use o herdadas <ph id="ph1">&lt;xref:System.Reflection.Module.GetMethod%2A?displayProperty=nameWithType&gt;</ph> método para obter os métodos que foram declarados no nível de módulo.</target>       </trans-unit>
        <trans-unit id="600" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Module-level methods are defined in emitted code by using the <ph id="ph1">&lt;xref:System.Reflection.Emit.ModuleBuilder.DefineGlobalMethod%2A&gt;</ph> method.</source>
          <target state="translated">Métodos de nível de módulo são definidos no código emitido por meio de <ph id="ph1">&lt;xref:System.Reflection.Emit.ModuleBuilder.DefineGlobalMethod%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="601" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Module-level methods cannot be retrieved until after the <ph id="ph1">&lt;xref:System.Reflection.Emit.ModuleBuilder.CreateGlobalFunctions%2A&gt;</ph> method has been called for the module.</source>
          <target state="translated">Métodos de nível de módulo não podem ser recuperados até depois que o <ph id="ph1">&lt;xref:System.Reflection.Emit.ModuleBuilder.CreateGlobalFunctions%2A&gt;</ph> método foi chamado para o módulo.</target>       </trans-unit>
        <trans-unit id="602" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>, <ph id="ph3">&lt;paramref name="types" /&gt;</ph> is <ph id="ph4">&lt;see langword="null" /&gt;</ph>, or an element of <ph id="ph5">&lt;paramref name="types" /&gt;</ph> is <ph id="ph6">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> é <ph id="ph2">&lt;see langword="null" /&gt;</ph>, <ph id="ph3">&lt;paramref name="types" /&gt;</ph> é <ph id="ph4">&lt;see langword="null" /&gt;</ph> ou um elemento de <ph id="ph5">&lt;paramref name="types" /&gt;</ph> é <ph id="ph6">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="603" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetMethods(System.Reflection.BindingFlags)">
          <source>A combination of <ph id="ph1">&lt;see langword="BindingFlags" /&gt;</ph> bit flags used to control the search.</source>
          <target state="translated">Uma combinação de sinalizadores de bit <ph id="ph1">&lt;see langword="BindingFlags" /&gt;</ph> usados para controlar a pesquisa.</target>       </trans-unit>
        <trans-unit id="604" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetMethods(System.Reflection.BindingFlags)">
          <source>Returns all the methods that have been defined at the module level for the current <ph id="ph1">&lt;see cref="T:System.Reflection.Emit.ModuleBuilder" /&gt;</ph>, and that match the specified binding flags.</source>
          <target state="translated">Retorna todos os métodos que foram definidos no nível de módulo para o <ph id="ph1">&lt;see cref="T:System.Reflection.Emit.ModuleBuilder" /&gt;</ph> atual e que corresponde aos sinalizadores de associação especificados.</target>       </trans-unit>
        <trans-unit id="605" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetMethods(System.Reflection.BindingFlags)">
          <source>An array that contains all the module-level methods that match <ph id="ph1">&lt;paramref name="bindingFlags" /&gt;</ph>.</source>
          <target state="translated">Uma matriz que contém todos os métodos de nível de módulo que correspondem a <ph id="ph1">&lt;paramref name="bindingFlags" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="606" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.GetMethods(System.Reflection.BindingFlags)">
          <source>Module-level methods are defined in emitted code by using the <ph id="ph1">&lt;xref:System.Reflection.Emit.ModuleBuilder.DefineGlobalMethod%2A&gt;</ph> method.</source>
          <target state="translated">Métodos de nível de módulo são definidos no código emitido por meio de <ph id="ph1">&lt;xref:System.Reflection.Emit.ModuleBuilder.DefineGlobalMethod%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="607" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.GetMethods(System.Reflection.BindingFlags)">
          <source>Module-level methods cannot be retrieved until after the <ph id="ph1">&lt;xref:System.Reflection.Emit.ModuleBuilder.CreateGlobalFunctions%2A&gt;</ph> method has been called for the module.</source>
          <target state="translated">Métodos de nível de módulo não podem ser recuperados até depois que o <ph id="ph1">&lt;xref:System.Reflection.Emit.ModuleBuilder.CreateGlobalFunctions%2A&gt;</ph> método foi chamado para o módulo.</target>       </trans-unit>
        <trans-unit id="608" translate="yes" xml:space="preserve" uid="T:System.Reflection.Emit.ModuleBuilder">
          <source>Returns the token used to identify the specified method within this module.</source>
          <target state="translated">Retorna o token usado para identificar o método especificado neste módulo.</target>       </trans-unit>
        <trans-unit id="609" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetMethodToken(System.Reflection.MethodInfo)">
          <source>The method to get a token for.</source>
          <target state="translated">O método para o qual obter um token.</target>       </trans-unit>
        <trans-unit id="610" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetMethodToken(System.Reflection.MethodInfo)">
          <source>Returns the token used to identify the specified method within this module.</source>
          <target state="translated">Retorna o token usado para identificar o método especificado neste módulo.</target>       </trans-unit>
        <trans-unit id="611" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetMethodToken(System.Reflection.MethodInfo)">
          <source>The token used to identify the specified method within this module.</source>
          <target state="translated">O token usado para identificar o método especificado neste módulo.</target>       </trans-unit>
        <trans-unit id="612" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetMethodToken(System.Reflection.MethodInfo)">
          <source><ph id="ph1">&lt;paramref name="method" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="method" /&gt;</ph> é <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="613" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetMethodToken(System.Reflection.MethodInfo)">
          <source>The declaring type for the method is not in this module.</source>
          <target state="translated">O tipo declarativo para o método não está neste módulo.</target>       </trans-unit>
        <trans-unit id="614" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetMethodToken(System.Reflection.MethodInfo,System.Collections.Generic.IEnumerable{System.Type})">
          <source>The method to get a token for.</source>
          <target state="translated">O método para o qual obter um token.</target>       </trans-unit>
        <trans-unit id="615" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetMethodToken(System.Reflection.MethodInfo,System.Collections.Generic.IEnumerable{System.Type})">
          <source>A collection of the types of the optional parameters to the method.</source>
          <target state="translated">Uma coleção dos tipos de parâmetros opcionais para o método.</target>       </trans-unit>
        <trans-unit id="616" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetMethodToken(System.Reflection.MethodInfo,System.Collections.Generic.IEnumerable{System.Type})">
          <source>Returns the token used to identify the method that has the specified attributes and parameter types within this module.</source>
          <target state="translated">Retorna o token usado para identificar o método que tem os atributos e tipos de parâmetro especificados neste módulo.</target>       </trans-unit>
        <trans-unit id="617" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetMethodToken(System.Reflection.MethodInfo,System.Collections.Generic.IEnumerable{System.Type})">
          <source>The token used to identify the specified method within this module.</source>
          <target state="translated">O token usado para identificar o método especificado neste módulo.</target>       </trans-unit>
        <trans-unit id="618" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetMethodToken(System.Reflection.MethodInfo,System.Collections.Generic.IEnumerable{System.Type})">
          <source><ph id="ph1">&lt;paramref name="method" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="method" /&gt;</ph> é <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="619" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetMethodToken(System.Reflection.MethodInfo,System.Collections.Generic.IEnumerable{System.Type})">
          <source>The declaring type for the method is not in this module.</source>
          <target state="translated">O tipo declarativo para o método não está neste módulo.</target>       </trans-unit>
        <trans-unit id="620" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetPEKind(System.Reflection.PortableExecutableKinds@,System.Reflection.ImageFileMachine@)">
          <source>When this method returns, a combination of the <ph id="ph1">&lt;see cref="T:System.Reflection.PortableExecutableKinds" /&gt;</ph> values indicating the nature of the code in the module.</source>
          <target state="translated">Quando este método retorna, uma combinação dos valores <ph id="ph1">&lt;see cref="T:System.Reflection.PortableExecutableKinds" /&gt;</ph> indicando a natureza do código no módulo.</target>       </trans-unit>
        <trans-unit id="621" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetPEKind(System.Reflection.PortableExecutableKinds@,System.Reflection.ImageFileMachine@)">
          <source>When this method returns, one of the <ph id="ph1">&lt;see cref="T:System.Reflection.ImageFileMachine" /&gt;</ph> values indicating the platform targeted by the module.</source>
          <target state="translated">Quando este método retorna, um dos valores <ph id="ph1">&lt;see cref="T:System.Reflection.ImageFileMachine" /&gt;</ph> indicando a plataforma de destino no módulo.</target>       </trans-unit>
        <trans-unit id="622" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetPEKind(System.Reflection.PortableExecutableKinds@,System.Reflection.ImageFileMachine@)">
          <source>Gets a pair of values indicating the nature of the code in a module and the platform targeted by the module.</source>
          <target state="translated">Obtém um par de valores que indica a natureza do código em um módulo e a plataforma de destino do módulo.</target>       </trans-unit>
        <trans-unit id="623" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.GetPEKind(System.Reflection.PortableExecutableKinds@,System.Reflection.ImageFileMachine@)">
          <source>For dynamic modules, <ph id="ph1">`peKind`</ph> is always <ph id="ph2">&lt;xref:System.Reflection.PortableExecutableKinds.NotAPortableExecutableImage?displayProperty=nameWithType&gt;</ph> and <ph id="ph3">`machine`</ph> is always 0 (zero).</source>
          <target state="translated">Para módulos dinâmicos, <ph id="ph1">`peKind`</ph> é sempre <ph id="ph2">&lt;xref:System.Reflection.PortableExecutableKinds.NotAPortableExecutableImage?displayProperty=nameWithType&gt;</ph> e <ph id="ph3">`machine`</ph> é sempre 0 (zero).</target>       </trans-unit>
        <trans-unit id="624" translate="yes" xml:space="preserve" uid="T:System.Reflection.Emit.ModuleBuilder">
          <source>Defines a signature token.</source>
          <target state="translated">Define um token de assinatura.</target>       </trans-unit>
        <trans-unit id="625" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetSignatureToken(System.Reflection.Emit.SignatureHelper)">
          <source>The signature.</source>
          <target state="translated">A assinatura.</target>       </trans-unit>
        <trans-unit id="626" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetSignatureToken(System.Reflection.Emit.SignatureHelper)">
          <source>Defines a token for the signature that is defined by the specified <ph id="ph1">&lt;see cref="T:System.Reflection.Emit.SignatureHelper" /&gt;</ph>.</source>
          <target state="translated">Define um token para a assinatura que é definida pelo <ph id="ph1">&lt;see cref="T:System.Reflection.Emit.SignatureHelper" /&gt;</ph> especificado.</target>       </trans-unit>
        <trans-unit id="627" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetSignatureToken(System.Reflection.Emit.SignatureHelper)">
          <source>A token for the defined signature.</source>
          <target state="translated">Um token para a assinatura definida.</target>       </trans-unit>
        <trans-unit id="628" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.GetSignatureToken(System.Reflection.Emit.SignatureHelper)">
          <source>This method defines a metadata token for the signature described by <ph id="ph1">`sigHelper`</ph>.</source>
          <target state="translated">Este método define um token de metadados para a assinatura descrito pelo <ph id="ph1">`sigHelper`</ph>.</target>       </trans-unit>
        <trans-unit id="629" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetSignatureToken(System.Reflection.Emit.SignatureHelper)">
          <source><ph id="ph1">&lt;paramref name="sigHelper" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="sigHelper" /&gt;</ph> é <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="630" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetSignatureToken(System.Byte[],System.Int32)">
          <source>The signature binary large object (BLOB).</source>
          <target state="translated">O BLOB (objeto binário grande) da assinatura.</target>       </trans-unit>
        <trans-unit id="631" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetSignatureToken(System.Byte[],System.Int32)">
          <source>The length of the signature BLOB.</source>
          <target state="translated">O comprimento do BLOB de assinatura.</target>       </trans-unit>
        <trans-unit id="632" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetSignatureToken(System.Byte[],System.Int32)">
          <source>Defines a token for the signature that has the specified character array and signature length.</source>
          <target state="translated">Define um token para a assinatura que tem o comprimento de assinatura e matriz de caracteres especificado.</target>       </trans-unit>
        <trans-unit id="633" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetSignatureToken(System.Byte[],System.Int32)">
          <source>A token for the specified signature.</source>
          <target state="translated">Um token para a assinatura especificada.</target>       </trans-unit>
        <trans-unit id="634" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetSignatureToken(System.Byte[],System.Int32)">
          <source><ph id="ph1">&lt;paramref name="sigBytes" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="sigBytes" /&gt;</ph> é <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="635" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetSignerCertificate">
          <source>Returns an <ph id="ph1">&lt;see cref="T:System.Security.Cryptography.X509Certificates.X509Certificate" /&gt;</ph> object corresponding to the certificate included in the Authenticode signature of the assembly which this module belongs to.</source>
          <target state="translated">Retorna um objeto <ph id="ph1">&lt;see cref="T:System.Security.Cryptography.X509Certificates.X509Certificate" /&gt;</ph> correspondente ao certificado incluído na assinatura Authenticode do assembly ao qual este módulo pertence.</target>       </trans-unit>
        <trans-unit id="636" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetSignerCertificate">
          <source>If the assembly has not been Authenticode signed, <ph id="ph1">&lt;see langword="null" /&gt;</ph> is returned.</source>
          <target state="translated">Se o assembly não tiver sido assinado por Authenticode, <ph id="ph1">&lt;see langword="null" /&gt;</ph> será retornado.</target>       </trans-unit>
        <trans-unit id="637" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetSignerCertificate">
          <source>A certificate, or <ph id="ph1">&lt;see langword="null" /&gt;</ph> if the assembly to which this module belongs has not been Authenticode signed.</source>
          <target state="translated">Um certificado ou <ph id="ph1">&lt;see langword="null" /&gt;</ph>, se o assembly ao qual este módulo pertence não tiver sido assinado por Authenticode.</target>       </trans-unit>
        <trans-unit id="638" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetStringConstant(System.String)">
          <source>The string to add to the module's constant pool.</source>
          <target state="translated">A cadeia de caracteres a ser adicionada ao pool de constante do módulo.</target>       </trans-unit>
        <trans-unit id="639" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetStringConstant(System.String)">
          <source>Returns the token of the given string in the module’s constant pool.</source>
          <target state="translated">Retorna o token de cadeia de caracteres especificada no pool de constante do módulo.</target>       </trans-unit>
        <trans-unit id="640" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetStringConstant(System.String)">
          <source>The token of the string in the constant pool.</source>
          <target state="translated">O token da cadeia de caracteres no pool de constante.</target>       </trans-unit>
        <trans-unit id="641" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.GetStringConstant(System.String)">
          <source>If <ph id="ph1">`str`</ph> has already been defined, the existing token will be returned.</source>
          <target state="translated">Se <ph id="ph1">`str`</ph> já foi definido, o token existente será retornado.</target>       </trans-unit>
        <trans-unit id="642" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetStringConstant(System.String)">
          <source><ph id="ph1">&lt;paramref name="str" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="str" /&gt;</ph> é <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="643" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetSymWriter">
          <source>Returns the symbol writer associated with this dynamic module.</source>
          <target state="translated">Retorna o gravador de símbolo associado a esse módulo dinâmico.</target>       </trans-unit>
        <trans-unit id="644" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetSymWriter">
          <source>The symbol writer associated with this dynamic module.</source>
          <target state="translated">O gravador de símbolo associado a esse módulo dinâmico.</target>       </trans-unit>
        <trans-unit id="645" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.GetSymWriter">
          <source>Starting with the <ph id="ph1">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</ph>, this member no longer requires <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> with the <ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType&gt;</ph> flag.</source>
          <target state="translated">Começando com o <ph id="ph1">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</ph>, esse membro não requer mais <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> com o <ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType&gt;</ph> sinalizador.</target>       </trans-unit>
        <trans-unit id="646" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.GetSymWriter">
          <source>(See <bpt id="p1">[</bpt>Security Issues in Reflection Emit<ept id="p1">](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)</ept>.) To use this functionality, your application should target the <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> or later.</source>
          <target state="translated">(Consulte <bpt id="p1">[</bpt>problemas de segurança em reflexão emitir<ept id="p1">](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)</ept>.) Para usar essa funcionalidade, seu aplicativo deve ser direcionado ao <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> ou posterior.</target>       </trans-unit>
        <trans-unit id="647" translate="yes" xml:space="preserve" uid="T:System.Reflection.Emit.ModuleBuilder">
          <source>Gets the named type defined in the module.</source>
          <target state="translated">Obtém o tipo nomeado definido no módulo.</target>       </trans-unit>
        <trans-unit id="648" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetType(System.String)">
          <source>The name of the <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> to get.</source>
          <target state="translated">O nome do <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> a obter.</target>       </trans-unit>
        <trans-unit id="649" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetType(System.String)">
          <source>Gets the named type defined in the module.</source>
          <target state="translated">Obtém o tipo nomeado definido no módulo.</target>       </trans-unit>
        <trans-unit id="650" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetType(System.String)">
          <source>The requested type, if the type is defined in this module; otherwise, <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">O tipo solicitado, se o tipo estiver definido neste módulo; caso contrário, <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="651" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.GetType(System.String)">
          <source>Do not use this method to generate array types, pointer types, or byref types.</source>
          <target state="translated">Não use esse método para gerar tipos de matriz, tipos de ponteiro ou tipos byref.</target>       </trans-unit>
        <trans-unit id="652" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.GetType(System.String)">
          <source>Use the <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.MakeArrayType%2A?displayProperty=nameWithType&gt;</ph>, <ph id="ph2">&lt;xref:System.Reflection.Emit.TypeBuilder.MakePointerType%2A?displayProperty=nameWithType&gt;</ph>, and <ph id="ph3">&lt;xref:System.Reflection.Emit.TypeBuilder.MakeByRefType%2A?displayProperty=nameWithType&gt;</ph> methods instead.</source>
          <target state="translated">Use o <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.MakeArrayType%2A?displayProperty=nameWithType&gt;</ph>, <ph id="ph2">&lt;xref:System.Reflection.Emit.TypeBuilder.MakePointerType%2A?displayProperty=nameWithType&gt;</ph>, e <ph id="ph3">&lt;xref:System.Reflection.Emit.TypeBuilder.MakeByRefType%2A?displayProperty=nameWithType&gt;</ph> métodos em vez disso.</target>       </trans-unit>
        <trans-unit id="653" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.GetType(System.String)">
          <source>Starting with the <ph id="ph1">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</ph>, this member no longer requires <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> with the <ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType&gt;</ph> flag.</source>
          <target state="translated">Começando com o <ph id="ph1">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</ph>, esse membro não requer mais <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> com o <ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType&gt;</ph> sinalizador.</target>       </trans-unit>
        <trans-unit id="654" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.GetType(System.String)">
          <source>(See <bpt id="p1">[</bpt>Security Issues in Reflection Emit<ept id="p1">](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)</ept>.) To use this functionality, your application should target the <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> or later.</source>
          <target state="translated">(Consulte <bpt id="p1">[</bpt>problemas de segurança em reflexão emitir<ept id="p1">](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)</ept>.) Para usar essa funcionalidade, seu aplicativo deve ser direcionado ao <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> ou posterior.</target>       </trans-unit>
        <trans-unit id="655" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetType(System.String)">
          <source>Length of <ph id="ph1">&lt;paramref name="className" /&gt;</ph> is zero or is greater than 1023.</source>
          <target state="translated">O comprimento de <ph id="ph1">&lt;paramref name="className" /&gt;</ph> é igual a zero ou maior que 1023.</target>       </trans-unit>
        <trans-unit id="656" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetType(System.String)">
          <source><ph id="ph1">&lt;paramref name="className" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="className" /&gt;</ph> é <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="657" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetType(System.String)">
          <source>The requested <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> is non-public and the caller does not have <ph id="ph2">&lt;see cref="T:System.Security.Permissions.ReflectionPermission" /&gt;</ph> to reflect non-public objects outside the current assembly.</source>
          <target state="translated">O <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> solicitado é não público e o chamador não tem <ph id="ph2">&lt;see cref="T:System.Security.Permissions.ReflectionPermission" /&gt;</ph> para refletir objetos não públicos fora do assembly atual.</target>       </trans-unit>
        <trans-unit id="658" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetType(System.String)">
          <source>A class initializer is invoked and throws an exception.</source>
          <target state="translated">Um inicializador de classe é invocado e lança uma exceção.</target>       </trans-unit>
        <trans-unit id="659" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetType(System.String)">
          <source>An error is encountered while loading the <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>.</source>
          <target state="translated">Um erro é encontrado ao carregar o <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="660" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetType(System.String,System.Boolean)">
          <source>The name of the <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> to get.</source>
          <target state="translated">O nome do <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> a obter.</target>       </trans-unit>
        <trans-unit id="661" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetType(System.String,System.Boolean)">
          <source>If <ph id="ph1">&lt;see langword="true" /&gt;</ph>, the search is case-insensitive.</source>
          <target state="translated">Se <ph id="ph1">&lt;see langword="true" /&gt;</ph>, a pesquisa não diferenciará maiúsculas de minúsculas.</target>       </trans-unit>
        <trans-unit id="662" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetType(System.String,System.Boolean)">
          <source>If <ph id="ph1">&lt;see langword="false" /&gt;</ph>, the search is case-sensitive.</source>
          <target state="translated">Se <ph id="ph1">&lt;see langword="false" /&gt;</ph>, a pesquisa diferenciará maiúsculas de minúsculas.</target>       </trans-unit>
        <trans-unit id="663" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetType(System.String,System.Boolean)">
          <source>Gets the named type defined in the module, optionally ignoring the case of the type name.</source>
          <target state="translated">Obtém o tipo nomeado definido no módulo, opcionalmente ignorando maiúsculas e minúsculas do nome do tipo.</target>       </trans-unit>
        <trans-unit id="664" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetType(System.String,System.Boolean)">
          <source>The requested type, if the type is defined in this module; otherwise, <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">O tipo solicitado, se o tipo estiver definido neste módulo; caso contrário, <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="665" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.GetType(System.String,System.Boolean)">
          <source>Do not use this method to generate array types, pointer types, or byref types.</source>
          <target state="translated">Não use esse método para gerar tipos de matriz, tipos de ponteiro ou tipos byref.</target>       </trans-unit>
        <trans-unit id="666" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.GetType(System.String,System.Boolean)">
          <source>Use the <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.MakeArrayType%2A?displayProperty=nameWithType&gt;</ph>, <ph id="ph2">&lt;xref:System.Reflection.Emit.TypeBuilder.MakePointerType%2A?displayProperty=nameWithType&gt;</ph>, and <ph id="ph3">&lt;xref:System.Reflection.Emit.TypeBuilder.MakeByRefType%2A?displayProperty=nameWithType&gt;</ph> methods instead.</source>
          <target state="translated">Use o <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.MakeArrayType%2A?displayProperty=nameWithType&gt;</ph>, <ph id="ph2">&lt;xref:System.Reflection.Emit.TypeBuilder.MakePointerType%2A?displayProperty=nameWithType&gt;</ph>, e <ph id="ph3">&lt;xref:System.Reflection.Emit.TypeBuilder.MakeByRefType%2A?displayProperty=nameWithType&gt;</ph> métodos em vez disso.</target>       </trans-unit>
        <trans-unit id="667" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.GetType(System.String,System.Boolean)">
          <source>Starting with the <ph id="ph1">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</ph>, this member no longer requires <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> with the <ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType&gt;</ph> flag.</source>
          <target state="translated">Começando com o <ph id="ph1">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</ph>, esse membro não requer mais <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> com o <ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType&gt;</ph> sinalizador.</target>       </trans-unit>
        <trans-unit id="668" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.GetType(System.String,System.Boolean)">
          <source>(See <bpt id="p1">[</bpt>Security Issues in Reflection Emit<ept id="p1">](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)</ept>.) To use this functionality, your application should target the <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> or later.</source>
          <target state="translated">(Consulte <bpt id="p1">[</bpt>problemas de segurança em reflexão emitir<ept id="p1">](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)</ept>.) Para usar essa funcionalidade, seu aplicativo deve ser direcionado ao <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> ou posterior.</target>       </trans-unit>
        <trans-unit id="669" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetType(System.String,System.Boolean)">
          <source>Length of <ph id="ph1">&lt;paramref name="className" /&gt;</ph> is zero or is greater than 1023.</source>
          <target state="translated">O comprimento de <ph id="ph1">&lt;paramref name="className" /&gt;</ph> é igual a zero ou maior que 1023.</target>       </trans-unit>
        <trans-unit id="670" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetType(System.String,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="className" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="className" /&gt;</ph> é <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="671" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetType(System.String,System.Boolean)">
          <source>The requested <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> is non-public and the caller does not have <ph id="ph2">&lt;see cref="T:System.Security.Permissions.ReflectionPermission" /&gt;</ph> to reflect non-public objects outside the current assembly.</source>
          <target state="translated">O <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> solicitado é não público e o chamador não tem <ph id="ph2">&lt;see cref="T:System.Security.Permissions.ReflectionPermission" /&gt;</ph> para refletir objetos não públicos fora do assembly atual.</target>       </trans-unit>
        <trans-unit id="672" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetType(System.String,System.Boolean)">
          <source>A class initializer is invoked and throws an exception.</source>
          <target state="translated">Um inicializador de classe é invocado e lança uma exceção.</target>       </trans-unit>
        <trans-unit id="673" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetType(System.String,System.Boolean,System.Boolean)">
          <source>The name of the <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> to get.</source>
          <target state="translated">O nome do <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> a obter.</target>       </trans-unit>
        <trans-unit id="674" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetType(System.String,System.Boolean,System.Boolean)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> to throw an exception if the type cannot be found; <ph id="ph2">&lt;see langword="false" /&gt;</ph> to return <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> para gerar uma exceção se não for possível encontrar o tipo; <ph id="ph2">&lt;see langword="false" /&gt;</ph> para retornar <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="675" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetType(System.String,System.Boolean,System.Boolean)">
          <source>If <ph id="ph1">&lt;see langword="true" /&gt;</ph>, the search is case-insensitive.</source>
          <target state="translated">Se <ph id="ph1">&lt;see langword="true" /&gt;</ph>, a pesquisa não diferenciará maiúsculas de minúsculas.</target>       </trans-unit>
        <trans-unit id="676" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetType(System.String,System.Boolean,System.Boolean)">
          <source>If <ph id="ph1">&lt;see langword="false" /&gt;</ph>, the search is case-sensitive.</source>
          <target state="translated">Se <ph id="ph1">&lt;see langword="false" /&gt;</ph>, a pesquisa diferenciará maiúsculas de minúsculas.</target>       </trans-unit>
        <trans-unit id="677" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetType(System.String,System.Boolean,System.Boolean)">
          <source>Gets the named type defined in the module, optionally ignoring the case of the type name.</source>
          <target state="translated">Obtém o tipo nomeado definido no módulo, opcionalmente ignorando maiúsculas e minúsculas do nome do tipo.</target>       </trans-unit>
        <trans-unit id="678" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetType(System.String,System.Boolean,System.Boolean)">
          <source>Optionally throws an exception if the type is not found.</source>
          <target state="translated">Opcionalmente, gerará uma exceção se o tipo não for encontrado.</target>       </trans-unit>
        <trans-unit id="679" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetType(System.String,System.Boolean,System.Boolean)">
          <source>The specified type, if the type is declared in this module; otherwise, <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">O tipo especificado, se o tipo for declarado neste módulo; caso contrário, <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="680" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.GetType(System.String,System.Boolean,System.Boolean)">
          <source>The <ph id="ph1">`throwOnError`</ph> parameter only affects what happens when the type is not found.</source>
          <target state="translated">O <ph id="ph1">`throwOnError`</ph> parâmetro afeta somente o que acontece quando o tipo não foi encontrado.</target>       </trans-unit>
        <trans-unit id="681" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.GetType(System.String,System.Boolean,System.Boolean)">
          <source>It does not affect any other exceptions that might be thrown.</source>
          <target state="translated">Ele não afeta todas as exceções que podem ser geradas.</target>       </trans-unit>
        <trans-unit id="682" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.GetType(System.String,System.Boolean,System.Boolean)">
          <source>In particular, if the type is found but cannot be loaded, <ph id="ph1">&lt;xref:System.TypeLoadException&gt;</ph> can be thrown even if <ph id="ph2">`throwOnError`</ph> is <ph id="ph3">`false`</ph>.</source>
          <target state="translated">Em particular, se o tipo é encontrado, mas não pode ser carregado, <ph id="ph1">&lt;xref:System.TypeLoadException&gt;</ph> pode ser acionada mesmo se <ph id="ph2">`throwOnError`</ph> é <ph id="ph3">`false`</ph>.</target>       </trans-unit>
        <trans-unit id="683" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.GetType(System.String,System.Boolean,System.Boolean)">
          <source>Do not use this method to generate array types, pointer types, or byref types.</source>
          <target state="translated">Não use esse método para gerar tipos de matriz, tipos de ponteiro ou tipos byref.</target>       </trans-unit>
        <trans-unit id="684" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.GetType(System.String,System.Boolean,System.Boolean)">
          <source>Use the <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.MakeArrayType%2A?displayProperty=nameWithType&gt;</ph>, <ph id="ph2">&lt;xref:System.Reflection.Emit.TypeBuilder.MakePointerType%2A?displayProperty=nameWithType&gt;</ph>, and <ph id="ph3">&lt;xref:System.Reflection.Emit.TypeBuilder.MakeByRefType%2A?displayProperty=nameWithType&gt;</ph> methods instead.</source>
          <target state="translated">Use o <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.MakeArrayType%2A?displayProperty=nameWithType&gt;</ph>, <ph id="ph2">&lt;xref:System.Reflection.Emit.TypeBuilder.MakePointerType%2A?displayProperty=nameWithType&gt;</ph>, e <ph id="ph3">&lt;xref:System.Reflection.Emit.TypeBuilder.MakeByRefType%2A?displayProperty=nameWithType&gt;</ph> métodos em vez disso.</target>       </trans-unit>
        <trans-unit id="685" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.GetType(System.String,System.Boolean,System.Boolean)">
          <source>Starting with the <ph id="ph1">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</ph>, this member no longer requires <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> with the <ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType&gt;</ph> flag.</source>
          <target state="translated">Começando com o <ph id="ph1">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</ph>, esse membro não requer mais <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> com o <ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType&gt;</ph> sinalizador.</target>       </trans-unit>
        <trans-unit id="686" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.GetType(System.String,System.Boolean,System.Boolean)">
          <source>(See <bpt id="p1">[</bpt>Security Issues in Reflection Emit<ept id="p1">](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)</ept>.) To use this functionality, your application should target the <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> or later.</source>
          <target state="translated">(Consulte <bpt id="p1">[</bpt>problemas de segurança em reflexão emitir<ept id="p1">](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)</ept>.) Para usar essa funcionalidade, seu aplicativo deve ser direcionado ao <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> ou posterior.</target>       </trans-unit>
        <trans-unit id="687" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetType(System.String,System.Boolean,System.Boolean)">
          <source>Length of <ph id="ph1">&lt;paramref name="className" /&gt;</ph> is zero or is greater than 1023.</source>
          <target state="translated">O comprimento de <ph id="ph1">&lt;paramref name="className" /&gt;</ph> é igual a zero ou maior que 1023.</target>       </trans-unit>
        <trans-unit id="688" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetType(System.String,System.Boolean,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="className" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="className" /&gt;</ph> é <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="689" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetType(System.String,System.Boolean,System.Boolean)">
          <source>The requested <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> is non-public and the caller does not have <ph id="ph2">&lt;see cref="T:System.Security.Permissions.ReflectionPermission" /&gt;</ph> to reflect non-public objects outside the current assembly.</source>
          <target state="translated">O <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> solicitado é não público e o chamador não tem <ph id="ph2">&lt;see cref="T:System.Security.Permissions.ReflectionPermission" /&gt;</ph> para refletir objetos não públicos fora do assembly atual.</target>       </trans-unit>
        <trans-unit id="690" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetType(System.String,System.Boolean,System.Boolean)">
          <source>A class initializer is invoked and throws an exception.</source>
          <target state="translated">Um inicializador de classe é invocado e lança uma exceção.</target>       </trans-unit>
        <trans-unit id="691" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetType(System.String,System.Boolean,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="throwOnError" /&gt;</ph> is <ph id="ph2">&lt;see langword="true" /&gt;</ph> and the specified type is not found.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="throwOnError" /&gt;</ph> é <ph id="ph2">&lt;see langword="true" /&gt;</ph> e o tipo especificado não foi encontrado.</target>       </trans-unit>
        <trans-unit id="692" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetTypes">
          <source>Returns all the classes defined within this module.</source>
          <target state="translated">Retorna todas as classes definidas neste módulo.</target>       </trans-unit>
        <trans-unit id="693" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetTypes">
          <source>An array that contains the types defined within the module that is reflected by this instance.</source>
          <target state="translated">Uma matriz que contém os tipos definidos dentro do módulo que é refletido por esta instância.</target>       </trans-unit>
        <trans-unit id="694" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.GetTypes">
          <source><ph id="ph1">`ReflectionTypeLoadException`</ph> is a special class load exception.</source>
          <target state="translated"><ph id="ph1">`ReflectionTypeLoadException`</ph> é uma exceção de carregamento de classe especial.</target>       </trans-unit>
        <trans-unit id="695" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.GetTypes">
          <source>The <ph id="ph1">`ReflectionTypeLoadException.Types`</ph> property contains the array of classes that were defined in the module and loaded.</source>
          <target state="translated">O <ph id="ph1">`ReflectionTypeLoadException.Types`</ph> propriedade contém a matriz de classes que foram definidos no módulo e carregados.</target>       </trans-unit>
        <trans-unit id="696" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.GetTypes">
          <source>This array can contain some null values.</source>
          <target state="translated">Esta matriz pode conter alguns valores nulos.</target>       </trans-unit>
        <trans-unit id="697" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.GetTypes">
          <source>The <ph id="ph1">`ReflectionTypeLoadException.LoaderExceptions`</ph> property is an array of exceptions that represent the exceptions that were thrown by the class loader.</source>
          <target state="translated">O <ph id="ph1">`ReflectionTypeLoadException.LoaderExceptions`</ph> propriedade é uma matriz de exceções que representam as exceções que foram lançadas pelo carregador de classes.</target>       </trans-unit>
        <trans-unit id="698" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.GetTypes">
          <source>The holes in the class array line up with the exceptions.</source>
          <target state="translated">Falhas na matriz de classe alinharem com as exceções.</target>       </trans-unit>
        <trans-unit id="699" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.GetTypes">
          <source>For example, if the class initializers of one of the classes throws an exception while it is being loaded, a <ph id="ph1">`TargetInvocationException`</ph> is stored in the corresponding element of the <ph id="ph2">`LoaderExceptions`</ph> array.</source>
          <target state="translated">Por exemplo, se os inicializadores de classe de uma das classes de lançar uma exceção enquanto ele está sendo carregado, um <ph id="ph1">`TargetInvocationException`</ph> é armazenado no elemento correspondente a <ph id="ph2">`LoaderExceptions`</ph> matriz.</target>       </trans-unit>
        <trans-unit id="700" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.GetTypes">
          <source>Starting with the <ph id="ph1">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</ph>, this member no longer requires <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> with the <ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType&gt;</ph> flag.</source>
          <target state="translated">Começando com o <ph id="ph1">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</ph>, esse membro não requer mais <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> com o <ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType&gt;</ph> sinalizador.</target>       </trans-unit>
        <trans-unit id="701" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.GetTypes">
          <source>(See <bpt id="p1">[</bpt>Security Issues in Reflection Emit<ept id="p1">](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)</ept>.) To use this functionality, your application should target the <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> or later.</source>
          <target state="translated">(Consulte <bpt id="p1">[</bpt>problemas de segurança em reflexão emitir<ept id="p1">](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)</ept>.) Para usar essa funcionalidade, seu aplicativo deve ser direcionado ao <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> ou posterior.</target>       </trans-unit>
        <trans-unit id="702" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetTypes">
          <source>One or more classes in a module could not be loaded.</source>
          <target state="translated">Uma ou mais classes em um módulo não puderam ser carregadas.</target>       </trans-unit>
        <trans-unit id="703" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetTypes">
          <source>The caller does not have the required permission.</source>
          <target state="translated">O chamador não tem a permissão necessária.</target>       </trans-unit>
        <trans-unit id="704" translate="yes" xml:space="preserve" uid="T:System.Reflection.Emit.ModuleBuilder">
          <source>Returns a type token.</source>
          <target state="translated">Retorna um token de tipo.</target>       </trans-unit>
        <trans-unit id="705" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetTypeToken(System.String)">
          <source>The name of the class, including the namespace.</source>
          <target state="translated">O nome da classe, incluindo o namespace.</target>       </trans-unit>
        <trans-unit id="706" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetTypeToken(System.String)">
          <source>Returns the token used to identify the type with the specified name.</source>
          <target state="translated">Retorna o token usado para identificar o tipo com o nome especificado.</target>       </trans-unit>
        <trans-unit id="707" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetTypeToken(System.String)">
          <source>The token used to identify the type with the specified name within this module.</source>
          <target state="translated">O token usado para identificar o tipo com o nome especificado neste módulo.</target>       </trans-unit>
        <trans-unit id="708" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.GetTypeToken(System.String)">
          <source>This method is useful for clients of the <ph id="ph1">&lt;xref:System.Reflection.Emit.MethodRental&gt;</ph> class who want to directly modify the body of a method.</source>
          <target state="translated">Esse método é útil para clientes de <ph id="ph1">&lt;xref:System.Reflection.Emit.MethodRental&gt;</ph> classe que deseja modificar diretamente o corpo de um método.</target>       </trans-unit>
        <trans-unit id="709" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetTypeToken(System.String)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is the empty string ("").</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> é a cadeia de caracteres vazia ("").</target>       </trans-unit>
        <trans-unit id="710" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetTypeToken(System.String)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="711" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetTypeToken(System.String)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> represents a <ph id="ph2">&lt;see langword="ByRef" /&gt;</ph> type.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> representa um tipo <ph id="ph2">&lt;see langword="ByRef" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="712" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetTypeToken(System.String)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> é <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="713" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetTypeToken(System.String)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="714" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetTypeToken(System.String)">
          <source>The type specified by <ph id="ph1">&lt;paramref name="name" /&gt;</ph> could not be found.</source>
          <target state="translated">O tipo especificado por <ph id="ph1">&lt;paramref name="name" /&gt;</ph> não pôde ser encontrado.</target>       </trans-unit>
        <trans-unit id="715" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetTypeToken(System.String)">
          <source>This is a non-transient module that references a transient module.</source>
          <target state="translated">Este é um módulo não temporário que faz referência a um módulo transitório.</target>       </trans-unit>
        <trans-unit id="716" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetTypeToken(System.Type)">
          <source>The type object that represents the class type.</source>
          <target state="translated">O objeto de tipo que representa o tipo de classe.</target>       </trans-unit>
        <trans-unit id="717" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetTypeToken(System.Type)">
          <source>Returns the token used to identify the specified type within this module.</source>
          <target state="translated">Retorna o token usado para identificar o tipo especificado neste módulo.</target>       </trans-unit>
        <trans-unit id="718" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetTypeToken(System.Type)">
          <source>The token used to identify the given type within this module.</source>
          <target state="translated">O token usado para identificar o tipo fornecido neste módulo.</target>       </trans-unit>
        <trans-unit id="719" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.GetTypeToken(System.Type)">
          <source>Tokens are used in Microsoft intermediate language (MSIL) instructions to identify objects.</source>
          <target state="translated">Tokens são usados nas instruções de linguagem intermediária (MSIL) da Microsoft para identificar objetos.</target>       </trans-unit>
        <trans-unit id="720" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.GetTypeToken(System.Type)">
          <source>Tokens are relative to the module in which they are contained.</source>
          <target state="translated">Tokens são relativas ao módulo no qual elas são contidas.</target>       </trans-unit>
        <trans-unit id="721" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.GetTypeToken(System.Type)">
          <source>For example, the token value for <ph id="ph1">`String`</ph> is likely to be different from module to module.</source>
          <target state="translated">Por exemplo, o valor do token para <ph id="ph1">`String`</ph> provavelmente será diferente para cada módulo.</target>       </trans-unit>
        <trans-unit id="722" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.GetTypeToken(System.Type)">
          <source>When <ph id="ph1">`GetTypeToken`</ph> is invoked, a reference is added to the module.</source>
          <target state="translated">Quando <ph id="ph1">`GetTypeToken`</ph> é invocado, uma referência é adicionada para o módulo.</target>       </trans-unit>
        <trans-unit id="723" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.GetTypeToken(System.Type)">
          <source>The reference becomes a permanent part of the module; multiple calls with the same argument have no additional effect.</source>
          <target state="translated">A referência se torna parte permanente do módulo; várias chamadas com o mesmo argumento não têm nenhum efeito adicional.</target>       </trans-unit>
        <trans-unit id="724" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetTypeToken(System.Type)">
          <source><ph id="ph1">&lt;paramref name="type" /&gt;</ph> is a <ph id="ph2">&lt;see langword="ByRef" /&gt;</ph> type.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="type" /&gt;</ph> é um tipo <ph id="ph2">&lt;see langword="ByRef" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="725" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetTypeToken(System.Type)">
          <source><ph id="ph1">&lt;paramref name="type" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="type" /&gt;</ph> é <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="726" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetTypeToken(System.Type)">
          <source>This is a non-transient module that references a transient module.</source>
          <target state="translated">Este é um módulo não temporário que faz referência a um módulo transitório.</target>       </trans-unit>
        <trans-unit id="727" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.IsDefined(System.Type,System.Boolean)">
          <source>The type of custom attribute to test for.</source>
          <target state="translated">O tipo de atributo personalizado para o qual testar.</target>       </trans-unit>
        <trans-unit id="728" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.IsDefined(System.Type,System.Boolean)">
          <source>This argument is ignored for objects of this type.</source>
          <target state="translated">Este argumento é ignorado para objetos deste tipo.</target>       </trans-unit>
        <trans-unit id="729" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.IsDefined(System.Type,System.Boolean)">
          <source>Returns a value that indicates whether the specified attribute type has been applied to this module.</source>
          <target state="translated">Retorna um valor que indica se o tipo de atributo especificado foi aplicado a este módulo.</target>       </trans-unit>
        <trans-unit id="730" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.IsDefined(System.Type,System.Boolean)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if one or more instances of <ph id="ph2">&lt;paramref name="attributeType" /&gt;</ph> have been applied to this module; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> se uma ou mais instâncias de <ph id="ph2">&lt;paramref name="attributeType" /&gt;</ph> tiver sido aplicada a este módulo; caso contrário, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="731" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.IsDefined(System.Type,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="attributeType" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="attributeType" /&gt;</ph> é <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="732" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.IsDefined(System.Type,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="attributeType" /&gt;</ph> is not a <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> object supplied by the runtime.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="attributeType" /&gt;</ph> não é um objeto <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> fornecido pelo tempo de execução.</target>       </trans-unit>
        <trans-unit id="733" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.IsDefined(System.Type,System.Boolean)">
          <source>For example, <ph id="ph1">&lt;paramref name="attributeType" /&gt;</ph> is a <ph id="ph2">&lt;see cref="T:System.Reflection.Emit.TypeBuilder" /&gt;</ph> object.</source>
          <target state="translated">Por exemplo, <ph id="ph1">&lt;paramref name="attributeType" /&gt;</ph> é um objeto <ph id="ph2">&lt;see cref="T:System.Reflection.Emit.TypeBuilder" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="734" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.IsResource">
          <source>Gets a value indicating whether the object is a resource.</source>
          <target state="translated">Obtém um valor que indica se o objeto é um recurso.</target>       </trans-unit>
        <trans-unit id="735" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.IsResource">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the object is a resource; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> se o objeto for um recurso; caso contrário, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="736" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.IsTransient">
          <source>Returns a value that indicates whether this dynamic module is transient.</source>
          <target state="translated">Retorna um valor que indica se este módulo dinâmico é transitório.</target>       </trans-unit>
        <trans-unit id="737" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.IsTransient">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if this dynamic module is transient; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> se esse módulo dinâmico for transitório; caso contrário, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="738" translate="yes" xml:space="preserve" uid="P:System.Reflection.Emit.ModuleBuilder.MDStreamVersion">
          <source>Gets the metadata stream version.</source>
          <target state="translated">Obtém a versão de fluxo de metadados.</target>       </trans-unit>
        <trans-unit id="739" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.ModuleBuilder.MDStreamVersion">
          <source>A 32-bit integer representing the metadata stream version.</source>
          <target state="translated">Um inteiro de 32 bits que representa a versão de fluxo de metadados.</target>       </trans-unit>
        <trans-unit id="740" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.ModuleBuilder.MDStreamVersion">
          <source>The high-order two bytes represent the major version number, and the low-order two bytes represent the minor version number.</source>
          <target state="translated">Os dois bytes de ordem superior representam o número de versão principal e as ordem inferior dois bytes representam o número de versão secundária.</target>       </trans-unit>
        <trans-unit id="741" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.ModuleBuilder.MDStreamVersion">
          <source>For more information on the metadata header, see "Partition II: Metadata Definition and Semantics" in the Common Language Infrastructure (CLI) documentation.</source>
          <target state="translated">Para obter mais informações sobre o cabeçalho de metadados, consulte "Partição II: metadados definição e semântica" na documentação do Common Language Infrastructure (CLI).</target>       </trans-unit>
        <trans-unit id="742" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.ModuleBuilder.MDStreamVersion">
          <source>The documentation is available online; see <bpt id="p1">[</bpt>ECMA C# and Common Language Infrastructure Standards<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=99212)</ept> on MSDN and <bpt id="p2">[</bpt>Standard ECMA-335 - Common Language Infrastructure (CLI)<ept id="p2">](http://go.microsoft.com/fwlink/?LinkID=65552)</ept> on the ECMA Web site.</source>
          <target state="translated">A documentação está disponível online; consulte <bpt id="p1">[</bpt>ECMA para c# e padrões de infra-estrutura de linguagem comum<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=99212)</ept> no MSDN e <bpt id="p2">[</bpt>padrão ECMA-335 - infraestrutura de linguagem comum (CLI)<ept id="p2">](http://go.microsoft.com/fwlink/?LinkID=65552)</ept> no site da Web de ECMA.</target>       </trans-unit>
        <trans-unit id="743" translate="yes" xml:space="preserve" uid="P:System.Reflection.Emit.ModuleBuilder.MetadataToken">
          <source>Gets a token that identifies the current dynamic module in metadata.</source>
          <target state="translated">Obtém um token que identifica o módulo dinâmico atual nos metadados.</target>       </trans-unit>
        <trans-unit id="744" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.ModuleBuilder.MetadataToken">
          <source>An integer token that identifies the current module in metadata.</source>
          <target state="translated">Um token de número inteiro que identifica o módulo atual nos metadados.</target>       </trans-unit>
        <trans-unit id="745" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.ModuleBuilder.MetadataToken">
          <source>The tokens obtained using this property can be passed to the unmanaged Reflection API.</source>
          <target state="translated">Os símbolos obtidos usando essa propriedade podem ser passados para a API não gerenciada de reflexão.</target>       </trans-unit>
        <trans-unit id="746" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.ModuleBuilder.MetadataToken">
          <source>For more information, see <bpt id="p1">[</bpt>Unmanaged Reflection API<ept id="p1">](http://msdn.microsoft.com/library/0c5bb9de-0cf6-438d-ba47-134e6c775fb8)</ept>.</source>
          <target state="translated">Para obter mais informações, consulte <bpt id="p1">[</bpt>API não gerenciada de reflexão<ept id="p1">](http://msdn.microsoft.com/library/0c5bb9de-0cf6-438d-ba47-134e6c775fb8)</ept>.</target>       </trans-unit>
        <trans-unit id="747" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.ModuleBuilder.MetadataToken">
          <source>Information about metadata tokens can be found in the Common Language Infrastructure (CLI) documentation, especially "Partition II: Metadata Definition and Semantics".</source>
          <target state="translated">Informações sobre tokens de metadados podem ser encontradas na documentação do Common Language Infrastructure (CLI), especialmente "partição II: metadados definição e semântica".</target>       </trans-unit>
        <trans-unit id="748" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.ModuleBuilder.MetadataToken">
          <source>The documentation is available online; see <bpt id="p1">[</bpt>ECMA C# and Common Language Infrastructure Standards<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=99212)</ept> on MSDN and <bpt id="p2">[</bpt>Standard ECMA-335 - Common Language Infrastructure (CLI)<ept id="p2">](http://go.microsoft.com/fwlink/?LinkID=65552)</ept> on the ECMA Web site.</source>
          <target state="translated">A documentação está disponível online; consulte <bpt id="p1">[</bpt>ECMA para c# e padrões de infra-estrutura de linguagem comum<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=99212)</ept> no MSDN e <bpt id="p2">[</bpt>padrão ECMA-335 - infraestrutura de linguagem comum (CLI)<ept id="p2">](http://go.microsoft.com/fwlink/?LinkID=65552)</ept> no site da Web de ECMA.</target>       </trans-unit>
        <trans-unit id="749" translate="yes" xml:space="preserve" uid="P:System.Reflection.Emit.ModuleBuilder.ModuleVersionId">
          <source>Gets a universally unique identifier (UUID) that can be used to distinguish between two versions of a module.</source>
          <target state="translated">Obtém um UUID (identificador universal exclusivo) que pode ser usado para distinguir entre duas versões de um módulo.</target>       </trans-unit>
        <trans-unit id="750" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.ModuleBuilder.ModuleVersionId">
          <source>A <ph id="ph1">&lt;see cref="T:System.Guid" /&gt;</ph> that can be used to distinguish between two versions of a module.</source>
          <target state="translated">Um <ph id="ph1">&lt;see cref="T:System.Guid" /&gt;</ph> que pode ser usado para distinguir entre duas versões de um módulo.</target>       </trans-unit>
        <trans-unit id="751" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.ModuleBuilder.ModuleVersionId">
          <source>In unmanaged metadata, the GUID returned by the <ph id="ph1">&lt;xref:System.Reflection.Module.ModuleVersionId%2A&gt;</ph> property is referred to as the <ph id="ph2">`mvid`</ph>, and is stored in the GUID heap.</source>
          <target state="translated">Em metadados não gerenciado, o GUID retornado pelo <ph id="ph1">&lt;xref:System.Reflection.Module.ModuleVersionId%2A&gt;</ph> propriedade é conhecida como o <ph id="ph2">`mvid`</ph>e é armazenado no heap de GUID.</target>       </trans-unit>
        <trans-unit id="752" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.ModuleBuilder.ModuleVersionId">
          <source>More information about metadata can be found in the Common Language Infrastructure (CLI) documentation, especially "Partition II: Metadata Definition and Semantics".</source>
          <target state="translated">Para obter mais informações sobre metadados podem ser encontradas na documentação do Common Language Infrastructure (CLI), especialmente "partição II: metadados definição e semântica".</target>       </trans-unit>
        <trans-unit id="753" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.ModuleBuilder.ModuleVersionId">
          <source>The documentation is available online; see <bpt id="p1">[</bpt>ECMA C# and Common Language Infrastructure Standards<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=99212)</ept> on MSDN and <bpt id="p2">[</bpt>Standard ECMA-335 - Common Language Infrastructure (CLI)<ept id="p2">](http://go.microsoft.com/fwlink/?LinkID=65552)</ept> on the ECMA Web site.</source>
          <target state="translated">A documentação está disponível online; consulte <bpt id="p1">[</bpt>ECMA para c# e padrões de infra-estrutura de linguagem comum<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=99212)</ept> no MSDN e <bpt id="p2">[</bpt>padrão ECMA-335 - infraestrutura de linguagem comum (CLI)<ept id="p2">](http://go.microsoft.com/fwlink/?LinkID=65552)</ept> no site da Web de ECMA.</target>       </trans-unit>
        <trans-unit id="754" translate="yes" xml:space="preserve" uid="P:System.Reflection.Emit.ModuleBuilder.Name">
          <source>A string that indicates that this is an in-memory module.</source>
          <target state="translated">Uma cadeia de caracteres que indica que este é um módulo na memória.</target>       </trans-unit>
        <trans-unit id="755" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.ModuleBuilder.Name">
          <source>Text that indicates that this is an in-memory module.</source>
          <target state="translated">Texto que indica que este é um módulo de memória.</target>       </trans-unit>
        <trans-unit id="756" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.ModuleBuilder.Name">
          <source>The name of a dynamic module cannot be obtained until the module has been saved and reloaded from disk.</source>
          <target state="translated">Não é possível obter o nome de um módulo dinâmico até que o módulo foi salvo e recarregado do disco.</target>       </trans-unit>
        <trans-unit id="757" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.ResolveField(System.Int32,System.Type[],System.Type[])">
          <source>A metadata token that identifies a field in the module.</source>
          <target state="translated">Um token de metadados que identifica um campo no módulo.</target>       </trans-unit>
        <trans-unit id="758" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.ResolveField(System.Int32,System.Type[],System.Type[])">
          <source>An array of <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> objects representing the generic type arguments of the type where the token is in scope, or <ph id="ph2">&lt;see langword="null" /&gt;</ph> if that type is not generic.</source>
          <target state="translated">Uma matriz de objetos <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> que representam os argumentos de tipo genérico do tipo em que o token está no escopo ou <ph id="ph2">&lt;see langword="null" /&gt;</ph> se esse tipo não for genérico.</target>       </trans-unit>
        <trans-unit id="759" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.ResolveField(System.Int32,System.Type[],System.Type[])">
          <source>An array of <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> objects representing the generic type arguments of the method where the token is in scope, or <ph id="ph2">&lt;see langword="null" /&gt;</ph> if that method is not generic.</source>
          <target state="translated">Uma matriz de objetos <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> que representam os argumentos de tipo genérico do método em que o token está no escopo ou <ph id="ph2">&lt;see langword="null" /&gt;</ph> se esse método não for genérico.</target>       </trans-unit>
        <trans-unit id="760" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.ResolveField(System.Int32,System.Type[],System.Type[])">
          <source>Returns the field identified by the specified metadata token, in the context defined by the specified generic type parameters.</source>
          <target state="translated">Retorna o campo identificado pelo token de metadados especificado, no contexto definido pelos parâmetros de tipo genérico especificados.</target>       </trans-unit>
        <trans-unit id="761" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.ResolveField(System.Int32,System.Type[],System.Type[])">
          <source>A <ph id="ph1">&lt;see cref="T:System.Reflection.FieldInfo" /&gt;</ph> object representing the field that is identified by the specified metadata token.</source>
          <target state="translated">Um objeto <ph id="ph1">&lt;see cref="T:System.Reflection.FieldInfo" /&gt;</ph> que representa o campo que é identificado pelo token de metadados especificado.</target>       </trans-unit>
        <trans-unit id="762" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.ResolveField(System.Int32,System.Type[],System.Type[])">
          <source>Use the <ph id="ph1">&lt;xref:System.Type.GetGenericArguments%2A?displayProperty=nameWithType&gt;</ph> method on the type where <ph id="ph2">`metadataToken`</ph> is in scope to obtain an array of generic type arguments for <ph id="ph3">`genericTypeArguments`</ph>.</source>
          <target state="translated">Use o <ph id="ph1">&lt;xref:System.Type.GetGenericArguments%2A?displayProperty=nameWithType&gt;</ph> método do tipo onde <ph id="ph2">`metadataToken`</ph> está no escopo para obter uma matriz de argumentos de tipo genérico para <ph id="ph3">`genericTypeArguments`</ph>.</target>       </trans-unit>
        <trans-unit id="763" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.ResolveField(System.Int32,System.Type[],System.Type[])">
          <source>Use the <ph id="ph1">&lt;xref:System.Reflection.MethodInfo.GetGenericArguments%2A?displayProperty=nameWithType&gt;</ph> method on the method where <ph id="ph2">`metadataToken`</ph> is in scope to obtain an array of generic type arguments for <ph id="ph3">`genericTypeArguments`</ph>.</source>
          <target state="translated">Use o <ph id="ph1">&lt;xref:System.Reflection.MethodInfo.GetGenericArguments%2A?displayProperty=nameWithType&gt;</ph> método no método onde <ph id="ph2">`metadataToken`</ph> está no escopo para obter uma matriz de argumentos de tipo genérico para <ph id="ph3">`genericTypeArguments`</ph>.</target>       </trans-unit>
        <trans-unit id="764" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.ResolveField(System.Int32,System.Type[],System.Type[])">
          <source>It is always safe to provide these arguments, even when they are not needed.</source>
          <target state="translated">É sempre seguro fornecer esses argumentos, mesmo quando eles não são necessários.</target>       </trans-unit>
        <trans-unit id="765" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.ResolveField(System.Int32,System.Type[],System.Type[])">
          <source>Information about metadata tokens can be found in the Common Language Infrastructure (CLI) documentation, especially "Partition II: Metadata Definition and Semantics".</source>
          <target state="translated">Informações sobre tokens de metadados podem ser encontradas na documentação do Common Language Infrastructure (CLI), especialmente "partição II: metadados definição e semântica".</target>       </trans-unit>
        <trans-unit id="766" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.ResolveField(System.Int32,System.Type[],System.Type[])">
          <source>The documentation is available online; see <bpt id="p1">[</bpt>ECMA C# and Common Language Infrastructure Standards<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=99212)</ept> on MSDN and <bpt id="p2">[</bpt>Standard ECMA-335 - Common Language Infrastructure (CLI)<ept id="p2">](http://go.microsoft.com/fwlink/?LinkID=65552)</ept> on the ECMA Web site.</source>
          <target state="translated">A documentação está disponível online; consulte <bpt id="p1">[</bpt>ECMA para c# e padrões de infra-estrutura de linguagem comum<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=99212)</ept> no MSDN e <bpt id="p2">[</bpt>padrão ECMA-335 - infraestrutura de linguagem comum (CLI)<ept id="p2">](http://go.microsoft.com/fwlink/?LinkID=65552)</ept> no site da Web de ECMA.</target>       </trans-unit>
        <trans-unit id="767" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.ResolveField(System.Int32,System.Type[],System.Type[])">
          <source>For code that demonstrates token resolution using the generic context (that is, the generic type parameters of the generic type and/or the generic method in which the token is embedded) see the <ph id="ph1">&lt;xref:System.Reflection.Module.ResolveMethod%28System.Int32%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%29?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Para o código que demonstra a resolução de token usando o contexto genérico (ou seja, os parâmetros de tipo genérico do tipo genérico e/ou o método genérico na qual o token é incorporado) consulte o <ph id="ph1">&lt;xref:System.Reflection.Module.ResolveMethod%28System.Int32%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%29?displayProperty=nameWithType&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="768" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.ResolveField(System.Int32,System.Type[],System.Type[])">
          <source><ph id="ph1">&lt;paramref name="metadataToken" /&gt;</ph> is not a token for a field in the scope of the current module.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="metadataToken" /&gt;</ph> não é um token para um campo no escopo do módulo atual.</target>       </trans-unit>
        <trans-unit id="769" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.ResolveField(System.Int32,System.Type[],System.Type[])">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="770" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.ResolveField(System.Int32,System.Type[],System.Type[])">
          <source><ph id="ph1">&lt;paramref name="metadataToken" /&gt;</ph> identifies a field whose parent <ph id="ph2">&lt;see langword="TypeSpec" /&gt;</ph> has a signature containing element type <ph id="ph3">&lt;see langword="var" /&gt;</ph> (a type parameter of a generic type) or <ph id="ph4">&lt;see langword="mvar" /&gt;</ph> (a type parameter of a generic method), and the necessary generic type arguments were not supplied for either or both of <ph id="ph5">&lt;paramref name="genericTypeArguments" /&gt;</ph> and <ph id="ph6">&lt;paramref name="genericMethodArguments" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="metadataToken" /&gt;</ph> identifica um campo cujo <ph id="ph2">&lt;see langword="TypeSpec" /&gt;</ph> pai tem uma assinatura que contém o tipo de elemento <ph id="ph3">&lt;see langword="var" /&gt;</ph> (um parâmetro de tipo de um tipo genérico) ou <ph id="ph4">&lt;see langword="mvar" /&gt;</ph> (um parâmetro de tipo de um método genérico) e os argumentos de tipo genérico necessários não foram fornecidos para <ph id="ph5">&lt;paramref name="genericTypeArguments" /&gt;</ph> ou <ph id="ph6">&lt;paramref name="genericMethodArguments" /&gt;</ph> ou ambos.</target>       </trans-unit>
        <trans-unit id="771" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.ResolveField(System.Int32,System.Type[],System.Type[])">
          <source><ph id="ph1">&lt;paramref name="metadataToken" /&gt;</ph> is not a valid token in the scope of the current module.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="metadataToken" /&gt;</ph> não é um token válido no escopo do módulo atual.</target>       </trans-unit>
        <trans-unit id="772" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.ResolveMember(System.Int32,System.Type[],System.Type[])">
          <source>A metadata token that identifies a type or member in the module.</source>
          <target state="translated">Um token de metadados que identifica um tipo ou membro no módulo.</target>       </trans-unit>
        <trans-unit id="773" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.ResolveMember(System.Int32,System.Type[],System.Type[])">
          <source>An array of <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> objects representing the generic type arguments of the type where the token is in scope, or <ph id="ph2">&lt;see langword="null" /&gt;</ph> if that type is not generic.</source>
          <target state="translated">Uma matriz de objetos <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> que representam os argumentos de tipo genérico do tipo em que o token está no escopo ou <ph id="ph2">&lt;see langword="null" /&gt;</ph> se esse tipo não for genérico.</target>       </trans-unit>
        <trans-unit id="774" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.ResolveMember(System.Int32,System.Type[],System.Type[])">
          <source>An array of <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> objects representing the generic type arguments of the method where the token is in scope, or <ph id="ph2">&lt;see langword="null" /&gt;</ph> if that method is not generic.</source>
          <target state="translated">Uma matriz de objetos <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> que representam os argumentos de tipo genérico do método em que o token está no escopo ou <ph id="ph2">&lt;see langword="null" /&gt;</ph> se esse método não for genérico.</target>       </trans-unit>
        <trans-unit id="775" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.ResolveMember(System.Int32,System.Type[],System.Type[])">
          <source>Returns the type or member identified by the specified metadata token, in the context defined by the specified generic type parameters.</source>
          <target state="translated">Retorna o tipo ou o membro identificado pelo token de metadados especificado, no contexto definido pelos parâmetros de tipo genérico especificados.</target>       </trans-unit>
        <trans-unit id="776" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.ResolveMember(System.Int32,System.Type[],System.Type[])">
          <source>A <ph id="ph1">&lt;see cref="T:System.Reflection.MemberInfo" /&gt;</ph> object representing the type or member that is identified by the specified metadata token.</source>
          <target state="translated">Um objeto <ph id="ph1">&lt;see cref="T:System.Reflection.MemberInfo" /&gt;</ph> que representa o tipo ou o membro que é identificado pelo token de metadados especificado.</target>       </trans-unit>
        <trans-unit id="777" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.ResolveMember(System.Int32,System.Type[],System.Type[])">
          <source>Use the <ph id="ph1">&lt;xref:System.Type.GetGenericArguments%2A?displayProperty=nameWithType&gt;</ph> method on the type where <ph id="ph2">`metadataToken`</ph> is in scope to obtain an array of generic type arguments for <ph id="ph3">`genericTypeArguments`</ph>.</source>
          <target state="translated">Use o <ph id="ph1">&lt;xref:System.Type.GetGenericArguments%2A?displayProperty=nameWithType&gt;</ph> método do tipo onde <ph id="ph2">`metadataToken`</ph> está no escopo para obter uma matriz de argumentos de tipo genérico para <ph id="ph3">`genericTypeArguments`</ph>.</target>       </trans-unit>
        <trans-unit id="778" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.ResolveMember(System.Int32,System.Type[],System.Type[])">
          <source>Use the <ph id="ph1">&lt;xref:System.Reflection.MethodInfo.GetGenericArguments%2A?displayProperty=nameWithType&gt;</ph> method on the method where <ph id="ph2">`metadataToken`</ph> is in scope to obtain an array of generic type arguments for <ph id="ph3">`genericTypeArguments`</ph>.</source>
          <target state="translated">Use o <ph id="ph1">&lt;xref:System.Reflection.MethodInfo.GetGenericArguments%2A?displayProperty=nameWithType&gt;</ph> método no método onde <ph id="ph2">`metadataToken`</ph> está no escopo para obter uma matriz de argumentos de tipo genérico para <ph id="ph3">`genericTypeArguments`</ph>.</target>       </trans-unit>
        <trans-unit id="779" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.ResolveMember(System.Int32,System.Type[],System.Type[])">
          <source>It is always safe to provide these arguments, even when they are not needed.</source>
          <target state="translated">É sempre seguro fornecer esses argumentos, mesmo quando eles não são necessários.</target>       </trans-unit>
        <trans-unit id="780" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.ResolveMember(System.Int32,System.Type[],System.Type[])">
          <source>Information about metadata tokens can be found in the Common Language Infrastructure (CLI) documentation, especially "Partition II: Metadata Definition and Semantics".</source>
          <target state="translated">Informações sobre tokens de metadados podem ser encontradas na documentação do Common Language Infrastructure (CLI), especialmente "partição II: metadados definição e semântica".</target>       </trans-unit>
        <trans-unit id="781" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.ResolveMember(System.Int32,System.Type[],System.Type[])">
          <source>The documentation is available online; see <bpt id="p1">[</bpt>ECMA C# and Common Language Infrastructure Standards<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=99212)</ept> on MSDN and <bpt id="p2">[</bpt>Standard ECMA-335 - Common Language Infrastructure (CLI)<ept id="p2">](http://go.microsoft.com/fwlink/?LinkID=65552)</ept> on the ECMA Web site.</source>
          <target state="translated">A documentação está disponível online; consulte <bpt id="p1">[</bpt>ECMA para c# e padrões de infra-estrutura de linguagem comum<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=99212)</ept> no MSDN e <bpt id="p2">[</bpt>padrão ECMA-335 - infraestrutura de linguagem comum (CLI)<ept id="p2">](http://go.microsoft.com/fwlink/?LinkID=65552)</ept> no site da Web de ECMA.</target>       </trans-unit>
        <trans-unit id="782" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.ResolveMember(System.Int32,System.Type[],System.Type[])">
          <source>For code that demonstrates token resolution using the generic context (that is, the generic type parameters of the generic type and/or the generic method in which the token is embedded) see the <ph id="ph1">&lt;xref:System.Reflection.Module.ResolveMethod%28System.Int32%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%29?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Para o código que demonstra a resolução de token usando o contexto genérico (ou seja, os parâmetros de tipo genérico do tipo genérico e/ou o método genérico na qual o token é incorporado) consulte o <ph id="ph1">&lt;xref:System.Reflection.Module.ResolveMethod%28System.Int32%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%29?displayProperty=nameWithType&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="783" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.ResolveMember(System.Int32,System.Type[],System.Type[])">
          <source><ph id="ph1">&lt;paramref name="metadataToken" /&gt;</ph> is not a token for a type or member in the scope of the current module.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="metadataToken" /&gt;</ph> não é um token para um tipo ou membro no escopo do módulo atual.</target>       </trans-unit>
        <trans-unit id="784" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.ResolveMember(System.Int32,System.Type[],System.Type[])">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="785" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.ResolveMember(System.Int32,System.Type[],System.Type[])">
          <source><ph id="ph1">&lt;paramref name="metadataToken" /&gt;</ph> is a <ph id="ph2">&lt;see langword="MethodSpec" /&gt;</ph> or <ph id="ph3">&lt;see langword="TypeSpec" /&gt;</ph> whose signature contains element type <ph id="ph4">&lt;see langword="var" /&gt;</ph> (a type parameter of a generic type) or <ph id="ph5">&lt;see langword="mvar" /&gt;</ph> (a type parameter of a generic method), and the necessary generic type arguments were not supplied for either or both of <ph id="ph6">&lt;paramref name="genericTypeArguments" /&gt;</ph> and <ph id="ph7">&lt;paramref name="genericMethodArguments" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="metadataToken" /&gt;</ph> é um <ph id="ph2">&lt;see langword="MethodSpec" /&gt;</ph> ou <ph id="ph3">&lt;see langword="TypeSpec" /&gt;</ph> cuja assinatura contém o tipo de elemento <ph id="ph4">&lt;see langword="var" /&gt;</ph> (um parâmetro de tipo de um tipo genérico) ou <ph id="ph5">&lt;see langword="mvar" /&gt;</ph> (um parâmetro de tipo de um método genérico) e os argumentos de tipo genérico necessários não foram fornecidos para <ph id="ph6">&lt;paramref name="genericTypeArguments" /&gt;</ph> ou <ph id="ph7">&lt;paramref name="genericMethodArguments" /&gt;</ph> ou ambos.</target>       </trans-unit>
        <trans-unit id="786" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.ResolveMember(System.Int32,System.Type[],System.Type[])">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="787" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.ResolveMember(System.Int32,System.Type[],System.Type[])">
          <source><ph id="ph1">&lt;paramref name="metadataToken" /&gt;</ph> identifies a property or event.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="metadataToken" /&gt;</ph> identifica uma propriedade ou evento.</target>       </trans-unit>
        <trans-unit id="788" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.ResolveMember(System.Int32,System.Type[],System.Type[])">
          <source><ph id="ph1">&lt;paramref name="metadataToken" /&gt;</ph> is not a valid token in the scope of the current module.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="metadataToken" /&gt;</ph> não é um token válido no escopo do módulo atual.</target>       </trans-unit>
        <trans-unit id="789" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.ResolveMethod(System.Int32,System.Type[],System.Type[])">
          <source>A metadata token that identifies a method or constructor in the module.</source>
          <target state="translated">Um token de metadados que identifica um método ou um construtor no módulo.</target>       </trans-unit>
        <trans-unit id="790" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.ResolveMethod(System.Int32,System.Type[],System.Type[])">
          <source>An array of <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> objects representing the generic type arguments of the type where the token is in scope, or <ph id="ph2">&lt;see langword="null" /&gt;</ph> if that type is not generic.</source>
          <target state="translated">Uma matriz de objetos <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> que representam os argumentos de tipo genérico do tipo em que o token está no escopo ou <ph id="ph2">&lt;see langword="null" /&gt;</ph> se esse tipo não for genérico.</target>       </trans-unit>
        <trans-unit id="791" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.ResolveMethod(System.Int32,System.Type[],System.Type[])">
          <source>An array of <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> objects representing the generic type arguments of the method where the token is in scope, or <ph id="ph2">&lt;see langword="null" /&gt;</ph> if that method is not generic.</source>
          <target state="translated">Uma matriz de objetos <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> que representam os argumentos de tipo genérico do método em que o token está no escopo ou <ph id="ph2">&lt;see langword="null" /&gt;</ph> se esse método não for genérico.</target>       </trans-unit>
        <trans-unit id="792" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.ResolveMethod(System.Int32,System.Type[],System.Type[])">
          <source>Returns the method or constructor identified by the specified metadata token, in the context defined by the specified generic type parameters.</source>
          <target state="translated">Retorna o método ou o construtor identificado pelo token de metadados especificado, no contexto definido pelos parâmetros de tipo genérico especificados.</target>       </trans-unit>
        <trans-unit id="793" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.ResolveMethod(System.Int32,System.Type[],System.Type[])">
          <source>A <ph id="ph1">&lt;see cref="T:System.Reflection.MethodBase" /&gt;</ph> object representing the method that is identified by the specified metadata token.</source>
          <target state="translated">Um objeto <ph id="ph1">&lt;see cref="T:System.Reflection.MethodBase" /&gt;</ph> que representa o método que é identificado pelo token de metadados especificado.</target>       </trans-unit>
        <trans-unit id="794" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.ResolveMethod(System.Int32,System.Type[],System.Type[])">
          <source>Use the <ph id="ph1">&lt;xref:System.Type.GetGenericArguments%2A?displayProperty=nameWithType&gt;</ph> method on the type where <ph id="ph2">`metadataToken`</ph> is in scope to obtain an array of generic type arguments for <ph id="ph3">`genericTypeArguments`</ph>.</source>
          <target state="translated">Use o <ph id="ph1">&lt;xref:System.Type.GetGenericArguments%2A?displayProperty=nameWithType&gt;</ph> método do tipo onde <ph id="ph2">`metadataToken`</ph> está no escopo para obter uma matriz de argumentos de tipo genérico para <ph id="ph3">`genericTypeArguments`</ph>.</target>       </trans-unit>
        <trans-unit id="795" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.ResolveMethod(System.Int32,System.Type[],System.Type[])">
          <source>Use the <ph id="ph1">&lt;xref:System.Reflection.MethodInfo.GetGenericArguments%2A?displayProperty=nameWithType&gt;</ph> method on the method where <ph id="ph2">`metadataToken`</ph> is in scope to obtain an array of generic type arguments for <ph id="ph3">`genericMethodArguments`</ph>.</source>
          <target state="translated">Use o <ph id="ph1">&lt;xref:System.Reflection.MethodInfo.GetGenericArguments%2A?displayProperty=nameWithType&gt;</ph> método no método onde <ph id="ph2">`metadataToken`</ph> está no escopo para obter uma matriz de argumentos de tipo genérico para <ph id="ph3">`genericMethodArguments`</ph>.</target>       </trans-unit>
        <trans-unit id="796" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.ResolveMethod(System.Int32,System.Type[],System.Type[])">
          <source>It is always safe to provide these arguments, even when they are not needed.</source>
          <target state="translated">É sempre seguro fornecer esses argumentos, mesmo quando eles não são necessários.</target>       </trans-unit>
        <trans-unit id="797" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.ResolveMethod(System.Int32,System.Type[],System.Type[])">
          <source>Information about metadata tokens can be found in the Common Language Infrastructure (CLI) documentation, especially "Partition II: Metadata Definition and Semantics".</source>
          <target state="translated">Informações sobre tokens de metadados podem ser encontradas na documentação do Common Language Infrastructure (CLI), especialmente "partição II: metadados definição e semântica".</target>       </trans-unit>
        <trans-unit id="798" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.ResolveMethod(System.Int32,System.Type[],System.Type[])">
          <source>The documentation is available online; see <bpt id="p1">[</bpt>ECMA C# and Common Language Infrastructure Standards<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=99212)</ept> on MSDN and <bpt id="p2">[</bpt>Standard ECMA-335 - Common Language Infrastructure (CLI)<ept id="p2">](http://go.microsoft.com/fwlink/?LinkID=65552)</ept> on the ECMA Web site.</source>
          <target state="translated">A documentação está disponível online; consulte <bpt id="p1">[</bpt>ECMA para c# e padrões de infra-estrutura de linguagem comum<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=99212)</ept> no MSDN e <bpt id="p2">[</bpt>padrão ECMA-335 - infraestrutura de linguagem comum (CLI)<ept id="p2">](http://go.microsoft.com/fwlink/?LinkID=65552)</ept> no site da Web de ECMA.</target>       </trans-unit>
        <trans-unit id="799" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.ResolveMethod(System.Int32,System.Type[],System.Type[])">
          <source>For code that demonstrates token resolution using the generic context (that is, the generic type parameters of the generic type and/or the generic method in which the token is embedded) see the <ph id="ph1">&lt;xref:System.Reflection.Module.ResolveMethod%28System.Int32%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%29?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Para o código que demonstra a resolução de token usando o contexto genérico (ou seja, os parâmetros de tipo genérico do tipo genérico e/ou o método genérico na qual o token é incorporado) consulte o <ph id="ph1">&lt;xref:System.Reflection.Module.ResolveMethod%28System.Int32%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%29?displayProperty=nameWithType&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="800" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.ResolveMethod(System.Int32,System.Type[],System.Type[])">
          <source><ph id="ph1">&lt;paramref name="metadataToken" /&gt;</ph> is not a token for a method or constructor in the scope of the current module.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="metadataToken" /&gt;</ph> não é um token de um método ou construtor no escopo do módulo atual.</target>       </trans-unit>
        <trans-unit id="801" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.ResolveMethod(System.Int32,System.Type[],System.Type[])">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="802" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.ResolveMethod(System.Int32,System.Type[],System.Type[])">
          <source><ph id="ph1">&lt;paramref name="metadataToken" /&gt;</ph> is a <ph id="ph2">&lt;see langword="MethodSpec" /&gt;</ph> whose signature contains element type <ph id="ph3">&lt;see langword="var" /&gt;</ph> (a type parameter of a generic type) or <ph id="ph4">&lt;see langword="mvar" /&gt;</ph> (a type parameter of a generic method), and the necessary generic type arguments were not supplied for either or both of <ph id="ph5">&lt;paramref name="genericTypeArguments" /&gt;</ph> and <ph id="ph6">&lt;paramref name="genericMethodArguments" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="metadataToken" /&gt;</ph> é um <ph id="ph2">&lt;see langword="MethodSpec" /&gt;</ph> cuja assinatura contém o tipo de elemento <ph id="ph3">&lt;see langword="var" /&gt;</ph> (um parâmetro de tipo de um tipo genérico) ou <ph id="ph4">&lt;see langword="mvar" /&gt;</ph> (um parâmetro de tipo de um método genérico) e os argumentos de tipo genérico necessários não foram fornecidos para <ph id="ph5">&lt;paramref name="genericTypeArguments" /&gt;</ph> ou <ph id="ph6">&lt;paramref name="genericMethodArguments" /&gt;</ph>, ou para ambos.</target>       </trans-unit>
        <trans-unit id="803" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.ResolveMethod(System.Int32,System.Type[],System.Type[])">
          <source><ph id="ph1">&lt;paramref name="metadataToken" /&gt;</ph> is not a valid token in the scope of the current module.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="metadataToken" /&gt;</ph> não é um token válido no escopo do módulo atual.</target>       </trans-unit>
        <trans-unit id="804" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.ResolveSignature(System.Int32)">
          <source>A metadata token that identifies a signature in the module.</source>
          <target state="translated">Um token de metadados que identifica uma assinatura no módulo.</target>       </trans-unit>
        <trans-unit id="805" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.ResolveSignature(System.Int32)">
          <source>Returns the signature blob identified by a metadata token.</source>
          <target state="translated">Retorna o blob de assinatura identificado por um token de metadados.</target>       </trans-unit>
        <trans-unit id="806" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.ResolveSignature(System.Int32)">
          <source>An array of bytes representing the signature blob.</source>
          <target state="translated">Uma matriz de bytes que representa o blob de assinatura.</target>       </trans-unit>
        <trans-unit id="807" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.ResolveSignature(System.Int32)">
          <source>Information about metadata tokens and signatures can be found in the Common Language Infrastructure (CLI) documentation, especially "Partition II: Metadata Definition and Semantics".</source>
          <target state="translated">Informações sobre assinaturas e tokens de metadados podem ser encontradas na documentação do Common Language Infrastructure (CLI), especialmente "partição II: metadados definição e semântica".</target>       </trans-unit>
        <trans-unit id="808" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.ResolveSignature(System.Int32)">
          <source>The documentation is available online; see <bpt id="p1">[</bpt>ECMA C# and Common Language Infrastructure Standards<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=99212)</ept> on MSDN and <bpt id="p2">[</bpt>Standard ECMA-335 - Common Language Infrastructure (CLI)<ept id="p2">](http://go.microsoft.com/fwlink/?LinkID=65552)</ept> on the ECMA Web site.</source>
          <target state="translated">A documentação está disponível online; consulte <bpt id="p1">[</bpt>ECMA para c# e padrões de infra-estrutura de linguagem comum<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=99212)</ept> no MSDN e <bpt id="p2">[</bpt>padrão ECMA-335 - infraestrutura de linguagem comum (CLI)<ept id="p2">](http://go.microsoft.com/fwlink/?LinkID=65552)</ept> no site da Web de ECMA.</target>       </trans-unit>
        <trans-unit id="809" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.ResolveSignature(System.Int32)">
          <source><ph id="ph1">&lt;paramref name="metadataToken" /&gt;</ph> is not a valid <ph id="ph2">&lt;see langword="MemberRef" /&gt;</ph>, <ph id="ph3">&lt;see langword="MethodDef" /&gt;</ph>, <ph id="ph4">&lt;see langword="TypeSpec" /&gt;</ph>, signature, or <ph id="ph5">&lt;see langword="FieldDef" /&gt;</ph> token in the scope of the current module.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="metadataToken" /&gt;</ph> não é um <ph id="ph2">&lt;see langword="MemberRef" /&gt;</ph>, <ph id="ph3">&lt;see langword="MethodDef" /&gt;</ph>, <ph id="ph4">&lt;see langword="TypeSpec" /&gt;</ph>, assinatura ou token <ph id="ph5">&lt;see langword="FieldDef" /&gt;</ph> válido no escopo do módulo atual.</target>       </trans-unit>
        <trans-unit id="810" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.ResolveSignature(System.Int32)">
          <source><ph id="ph1">&lt;paramref name="metadataToken" /&gt;</ph> is not a valid token in the scope of the current module.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="metadataToken" /&gt;</ph> não é um token válido no escopo do módulo atual.</target>       </trans-unit>
        <trans-unit id="811" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.ResolveString(System.Int32)">
          <source>A metadata token that identifies a string in the string heap of the module.</source>
          <target state="translated">Um token de metadados que identifica uma cadeia de caracteres no heap de cadeia de caracteres do módulo.</target>       </trans-unit>
        <trans-unit id="812" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.ResolveString(System.Int32)">
          <source>Returns the string identified by the specified metadata token.</source>
          <target state="translated">Retorna a cadeia de caracteres identificada pelo token de metadados especificado.</target>       </trans-unit>
        <trans-unit id="813" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.ResolveString(System.Int32)">
          <source>A <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> containing a string value from the metadata string heap.</source>
          <target state="translated">Um <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> que contém um valor de cadeia de caracteres do heap de cadeia de caracteres de metadados.</target>       </trans-unit>
        <trans-unit id="814" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.ResolveString(System.Int32)">
          <source>Information about metadata tokens can be found in the Common Language Infrastructure (CLI) documentation, especially "Partition II: Metadata Definition and Semantics".</source>
          <target state="translated">Informações sobre tokens de metadados podem ser encontradas na documentação do Common Language Infrastructure (CLI), especialmente "partição II: metadados definição e semântica".</target>       </trans-unit>
        <trans-unit id="815" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.ResolveString(System.Int32)">
          <source>The documentation is available online; see <bpt id="p1">[</bpt>ECMA C# and Common Language Infrastructure Standards<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=99212)</ept> on MSDN and <bpt id="p2">[</bpt>Standard ECMA-335 - Common Language Infrastructure (CLI)<ept id="p2">](http://go.microsoft.com/fwlink/?LinkID=65552)</ept> on the ECMA Web site.</source>
          <target state="translated">A documentação está disponível online; consulte <bpt id="p1">[</bpt>ECMA para c# e padrões de infra-estrutura de linguagem comum<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=99212)</ept> no MSDN e <bpt id="p2">[</bpt>padrão ECMA-335 - infraestrutura de linguagem comum (CLI)<ept id="p2">](http://go.microsoft.com/fwlink/?LinkID=65552)</ept> no site da Web de ECMA.</target>       </trans-unit>
        <trans-unit id="816" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.ResolveString(System.Int32)">
          <source><ph id="ph1">&lt;paramref name="metadataToken" /&gt;</ph> is not a token for a string in the scope of the current module.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="metadataToken" /&gt;</ph> não é um token para uma cadeia de caracteres no escopo do módulo atual.</target>       </trans-unit>
        <trans-unit id="817" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.ResolveString(System.Int32)">
          <source><ph id="ph1">&lt;paramref name="metadataToken" /&gt;</ph> is not a valid token in the scope of the current module.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="metadataToken" /&gt;</ph> não é um token válido no escopo do módulo atual.</target>       </trans-unit>
        <trans-unit id="818" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.ResolveType(System.Int32,System.Type[],System.Type[])">
          <source>A metadata token that identifies a type in the module.</source>
          <target state="translated">Um token de metadados que identifica um tipo no módulo.</target>       </trans-unit>
        <trans-unit id="819" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.ResolveType(System.Int32,System.Type[],System.Type[])">
          <source>An array of <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> objects representing the generic type arguments of the type where the token is in scope, or <ph id="ph2">&lt;see langword="null" /&gt;</ph> if that type is not generic.</source>
          <target state="translated">Uma matriz de objetos <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> que representam os argumentos de tipo genérico do tipo em que o token está no escopo ou <ph id="ph2">&lt;see langword="null" /&gt;</ph> se esse tipo não for genérico.</target>       </trans-unit>
        <trans-unit id="820" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.ResolveType(System.Int32,System.Type[],System.Type[])">
          <source>An array of <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> objects representing the generic type arguments of the method where the token is in scope, or <ph id="ph2">&lt;see langword="null" /&gt;</ph> if that method is not generic.</source>
          <target state="translated">Uma matriz de objetos <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> que representam os argumentos de tipo genérico do método em que o token está no escopo ou <ph id="ph2">&lt;see langword="null" /&gt;</ph> se esse método não for genérico.</target>       </trans-unit>
        <trans-unit id="821" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.ResolveType(System.Int32,System.Type[],System.Type[])">
          <source>Returns the type identified by the specified metadata token, in the context defined by the specified generic type parameters.</source>
          <target state="translated">Retorna o tipo identificado pelo token de metadados especificado no contexto definido pelos parâmetros de tipo genérico especificados.</target>       </trans-unit>
        <trans-unit id="822" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.ResolveType(System.Int32,System.Type[],System.Type[])">
          <source>A <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> object representing the type that is identified by the specified metadata token.</source>
          <target state="translated">Um objeto <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> que representa o tipo que é identificado pelo token de metadados especificado.</target>       </trans-unit>
        <trans-unit id="823" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.ResolveType(System.Int32,System.Type[],System.Type[])">
          <source>Use the <ph id="ph1">&lt;xref:System.Type.GetGenericArguments%2A?displayProperty=nameWithType&gt;</ph> method on the type where <ph id="ph2">`metadataToken`</ph> is in scope to obtain an array of generic type arguments for <ph id="ph3">`genericTypeArguments`</ph>.</source>
          <target state="translated">Use o <ph id="ph1">&lt;xref:System.Type.GetGenericArguments%2A?displayProperty=nameWithType&gt;</ph> método do tipo onde <ph id="ph2">`metadataToken`</ph> está no escopo para obter uma matriz de argumentos de tipo genérico para <ph id="ph3">`genericTypeArguments`</ph>.</target>       </trans-unit>
        <trans-unit id="824" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.ResolveType(System.Int32,System.Type[],System.Type[])">
          <source>Use the <ph id="ph1">&lt;xref:System.Reflection.MethodInfo.GetGenericArguments%2A?displayProperty=nameWithType&gt;</ph> method on the method where <ph id="ph2">`metadataToken`</ph> is in scope to obtain an array of generic type arguments for <ph id="ph3">`genericTypeArguments`</ph>.</source>
          <target state="translated">Use o <ph id="ph1">&lt;xref:System.Reflection.MethodInfo.GetGenericArguments%2A?displayProperty=nameWithType&gt;</ph> método no método onde <ph id="ph2">`metadataToken`</ph> está no escopo para obter uma matriz de argumentos de tipo genérico para <ph id="ph3">`genericTypeArguments`</ph>.</target>       </trans-unit>
        <trans-unit id="825" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.ResolveType(System.Int32,System.Type[],System.Type[])">
          <source>It is always safe to provide these arguments, even when they are not needed.</source>
          <target state="translated">É sempre seguro fornecer esses argumentos, mesmo quando eles não são necessários.</target>       </trans-unit>
        <trans-unit id="826" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.ResolveType(System.Int32,System.Type[],System.Type[])">
          <source>Information about metadata tokens can be found in the Common Language Infrastructure (CLI) documentation, especially "Partition II: Metadata Definition and Semantics".</source>
          <target state="translated">Informações sobre tokens de metadados podem ser encontradas na documentação do Common Language Infrastructure (CLI), especialmente "partição II: metadados definição e semântica".</target>       </trans-unit>
        <trans-unit id="827" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.ResolveType(System.Int32,System.Type[],System.Type[])">
          <source>The documentation is available online; see <bpt id="p1">[</bpt>ECMA C# and Common Language Infrastructure Standards<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=99212)</ept> on MSDN and <bpt id="p2">[</bpt>Standard ECMA-335 - Common Language Infrastructure (CLI)<ept id="p2">](http://go.microsoft.com/fwlink/?LinkID=65552)</ept> on the ECMA Web site.</source>
          <target state="translated">A documentação está disponível online; consulte <bpt id="p1">[</bpt>ECMA para c# e padrões de infra-estrutura de linguagem comum<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=99212)</ept> no MSDN e <bpt id="p2">[</bpt>padrão ECMA-335 - infraestrutura de linguagem comum (CLI)<ept id="p2">](http://go.microsoft.com/fwlink/?LinkID=65552)</ept> no site da Web de ECMA.</target>       </trans-unit>
        <trans-unit id="828" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.ResolveType(System.Int32,System.Type[],System.Type[])">
          <source>For code that demonstrates token resolution using the generic context (that is, the generic type parameters of the generic type and/or the generic method in which the token is embedded) see the <ph id="ph1">&lt;xref:System.Reflection.Module.ResolveMethod%28System.Int32%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%29?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Para o código que demonstra a resolução de token usando o contexto genérico (ou seja, os parâmetros de tipo genérico do tipo genérico e/ou o método genérico na qual o token é incorporado) consulte o <ph id="ph1">&lt;xref:System.Reflection.Module.ResolveMethod%28System.Int32%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%29?displayProperty=nameWithType&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="829" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.ResolveType(System.Int32,System.Type[],System.Type[])">
          <source><ph id="ph1">&lt;paramref name="metadataToken" /&gt;</ph> is not a token for a type in the scope of the current module.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="metadataToken" /&gt;</ph> não é um token para um tipo no escopo do módulo atual.</target>       </trans-unit>
        <trans-unit id="830" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.ResolveType(System.Int32,System.Type[],System.Type[])">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="831" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.ResolveType(System.Int32,System.Type[],System.Type[])">
          <source><ph id="ph1">&lt;paramref name="metadataToken" /&gt;</ph> is a <ph id="ph2">&lt;see langword="TypeSpec" /&gt;</ph> whose signature contains element type <ph id="ph3">&lt;see langword="var" /&gt;</ph> (a type parameter of a generic type) or <ph id="ph4">&lt;see langword="mvar" /&gt;</ph> (a type parameter of a generic method), and the necessary generic type arguments were not supplied for either or both of <ph id="ph5">&lt;paramref name="genericTypeArguments" /&gt;</ph> and <ph id="ph6">&lt;paramref name="genericMethodArguments" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="metadataToken" /&gt;</ph> é um <ph id="ph2">&lt;see langword="TypeSpec" /&gt;</ph> cuja assinatura contém o tipo de elemento <ph id="ph3">&lt;see langword="var" /&gt;</ph> (um parâmetro de tipo de um tipo genérico) ou <ph id="ph4">&lt;see langword="mvar" /&gt;</ph> (um parâmetro de tipo de um método genérico) e os argumentos de tipo genérico necessários não foram fornecidos para <ph id="ph5">&lt;paramref name="genericTypeArguments" /&gt;</ph> ou <ph id="ph6">&lt;paramref name="genericMethodArguments" /&gt;</ph>, ou para ambos.</target>       </trans-unit>
        <trans-unit id="832" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.ResolveType(System.Int32,System.Type[],System.Type[])">
          <source><ph id="ph1">&lt;paramref name="metadataToken" /&gt;</ph> is not a valid token in the scope of the current module.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="metadataToken" /&gt;</ph> não é um token válido no escopo do módulo atual.</target>       </trans-unit>
        <trans-unit id="833" translate="yes" xml:space="preserve" uid="P:System.Reflection.Emit.ModuleBuilder.ScopeName">
          <source>Gets a string that represents the name of the dynamic module.</source>
          <target state="translated">Obtém uma cadeia de caracteres que representa o nome do módulo dinâmico.</target>       </trans-unit>
        <trans-unit id="834" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.ModuleBuilder.ScopeName">
          <source>The name of the dynamic module.</source>
          <target state="translated">O nome do módulo dinâmico.</target>       </trans-unit>
        <trans-unit id="835" translate="yes" xml:space="preserve" uid="T:System.Reflection.Emit.ModuleBuilder">
          <source>Applies a custom attribute to this module.</source>
          <target state="translated">Aplica um atributo personalizado a esse módulo.</target>       </trans-unit>
        <trans-unit id="836" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.SetCustomAttribute(System.Reflection.Emit.CustomAttributeBuilder)">
          <source>An instance of a helper class that specifies the custom attribute to apply.</source>
          <target state="translated">Uma instância de uma classe auxiliar que especifica o atributo personalizado a aplicar.</target>       </trans-unit>
        <trans-unit id="837" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.SetCustomAttribute(System.Reflection.Emit.CustomAttributeBuilder)">
          <source>Applies a custom attribute to this module by using a custom attribute builder.</source>
          <target state="translated">Aplica um atributo personalizado a esse módulo usando um construtor de atributo personalizado.</target>       </trans-unit>
        <trans-unit id="838" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.SetCustomAttribute(System.Reflection.Emit.CustomAttributeBuilder)">
          <source>Starting with the <ph id="ph1">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</ph>, this member no longer requires <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> with the <ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType&gt;</ph> flag.</source>
          <target state="translated">Começando com o <ph id="ph1">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</ph>, esse membro não requer mais <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> com o <ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType&gt;</ph> sinalizador.</target>       </trans-unit>
        <trans-unit id="839" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.SetCustomAttribute(System.Reflection.Emit.CustomAttributeBuilder)">
          <source>(See <bpt id="p1">[</bpt>Security Issues in Reflection Emit<ept id="p1">](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)</ept>.) To use this functionality, your application should target the <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> or later.</source>
          <target state="translated">(Consulte <bpt id="p1">[</bpt>problemas de segurança em reflexão emitir<ept id="p1">](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)</ept>.) Para usar essa funcionalidade, seu aplicativo deve ser direcionado ao <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> ou posterior.</target>       </trans-unit>
        <trans-unit id="840" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.SetCustomAttribute(System.Reflection.Emit.CustomAttributeBuilder)">
          <source><ph id="ph1">&lt;paramref name="customBuilder" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="customBuilder" /&gt;</ph> é <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="841" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.SetCustomAttribute(System.Reflection.ConstructorInfo,System.Byte[])">
          <source>The constructor for the custom attribute.</source>
          <target state="translated">O construtor do atributo personalizado.</target>       </trans-unit>
        <trans-unit id="842" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.SetCustomAttribute(System.Reflection.ConstructorInfo,System.Byte[])">
          <source>A byte BLOB representing the attribute.</source>
          <target state="translated">Um BLOB de Byte que representa o atributo.</target>       </trans-unit>
        <trans-unit id="843" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.SetCustomAttribute(System.Reflection.ConstructorInfo,System.Byte[])">
          <source>Applies a custom attribute to this module by using a specified binary large object (BLOB) that represents the attribute.</source>
          <target state="translated">Aplica um atributo personalizado a esse módulo usando um BLOB (objeto binário grande) especificado que representa o atributo.</target>       </trans-unit>
        <trans-unit id="844" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.SetCustomAttribute(System.Reflection.ConstructorInfo,System.Byte[])">
          <source>For more information about how to format <ph id="ph1">`binaryAttribute`</ph>, see the Common Language Infrastructure (CLI) documentation, especially "Partition II: Metadata Definition and Semantics".</source>
          <target state="translated">Para obter mais informações sobre como formatar <ph id="ph1">`binaryAttribute`</ph>, consulte a documentação de infra-estrutura de linguagem comum (CLI), especialmente "partição II: metadados definição e semântica".</target>       </trans-unit>
        <trans-unit id="845" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.SetCustomAttribute(System.Reflection.ConstructorInfo,System.Byte[])">
          <source>The documentation is available online; see <bpt id="p1">[</bpt>ECMA C# and Common Language Infrastructure Standards<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=99212)</ept> on MSDN and <bpt id="p2">[</bpt>Standard ECMA-335 - Common Language Infrastructure (CLI)<ept id="p2">](http://go.microsoft.com/fwlink/?LinkID=65552)</ept> on the Ecma International Web site.</source>
          <target state="translated">A documentação está disponível online; confira <bpt id="p1">[</bpt>ECMA C# and Common Language Infrastructure Standards<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=99212)</ept>, no MSDN, e <bpt id="p2">[</bpt>Standard ECMA-335 - Common Language Infrastructure (CLI)<ept id="p2">](http://go.microsoft.com/fwlink/?LinkID=65552)</ept>, no site internacional da Ecma.</target>       </trans-unit>
        <trans-unit id="846" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.SetCustomAttribute(System.Reflection.ConstructorInfo,System.Byte[])">
          <source>Starting with the <ph id="ph1">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</ph>, this member no longer requires <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> with the <ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType&gt;</ph> flag.</source>
          <target state="translated">Começando com o <ph id="ph1">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</ph>, esse membro não requer mais <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> com o <ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType&gt;</ph> sinalizador.</target>       </trans-unit>
        <trans-unit id="847" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.SetCustomAttribute(System.Reflection.ConstructorInfo,System.Byte[])">
          <source>(See <bpt id="p1">[</bpt>Security Issues in Reflection Emit<ept id="p1">](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)</ept>.) To use this functionality, your application should target the <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> or later.</source>
          <target state="translated">(Consulte <bpt id="p1">[</bpt>problemas de segurança em reflexão emitir<ept id="p1">](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)</ept>.) Para usar essa funcionalidade, seu aplicativo deve ser direcionado ao <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> ou posterior.</target>       </trans-unit>
        <trans-unit id="848" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.SetCustomAttribute(System.Reflection.ConstructorInfo,System.Byte[])">
          <source><ph id="ph1">&lt;paramref name="con" /&gt;</ph> or <ph id="ph2">&lt;paramref name="binaryAttribute" /&gt;</ph> is <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="con" /&gt;</ph> ou <ph id="ph2">&lt;paramref name="binaryAttribute" /&gt;</ph> é <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="849" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.SetSymCustomAttribute(System.String,System.Byte[])">
          <source>The name of the custom attribute</source>
          <target state="translated">O nome do atributo personalizado</target>       </trans-unit>
        <trans-unit id="850" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.SetSymCustomAttribute(System.String,System.Byte[])">
          <source>An opaque binary large object (BLOB) of bytes that represents the value of the custom attribute.</source>
          <target state="translated">Um BLOB (objeto binário grande) opaco de bytes que representa o valor do atributo personalizado.</target>       </trans-unit>
        <trans-unit id="851" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.SetSymCustomAttribute(System.String,System.Byte[])">
          <source>This method does nothing.</source>
          <target state="translated">Esse método não faz nada.</target>       </trans-unit>
        <trans-unit id="852" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.SetSymCustomAttribute(System.String,System.Byte[])">
          <source>This method does nothing.</source>
          <target state="translated">Esse método não faz nada.</target>       </trans-unit>
        <trans-unit id="853" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.SetSymCustomAttribute(System.String,System.Byte[])">
          <source>Starting with the <ph id="ph1">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</ph>, this member no longer requires <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> with the <ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType&gt;</ph> flag.</source>
          <target state="translated">Começando com o <ph id="ph1">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</ph>, esse membro não requer mais <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> com o <ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType&gt;</ph> sinalizador.</target>       </trans-unit>
        <trans-unit id="854" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.SetSymCustomAttribute(System.String,System.Byte[])">
          <source>(See <bpt id="p1">[</bpt>Security Issues in Reflection Emit<ept id="p1">](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)</ept>.) To use this functionality, your application should target the <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> or later.</source>
          <target state="translated">(Consulte <bpt id="p1">[</bpt>problemas de segurança em reflexão emitir<ept id="p1">](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)</ept>.) Para usar essa funcionalidade, seu aplicativo deve ser direcionado ao <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> ou posterior.</target>       </trans-unit>
        <trans-unit id="855" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.SetSymCustomAttribute(System.String,System.Byte[])">
          <source><ph id="ph1">&lt;paramref name="url" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="url" /&gt;</ph> é <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="856" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.SetUserEntryPoint(System.Reflection.MethodInfo)">
          <source>The user entry point.</source>
          <target state="translated">O ponto de entrada do usuário.</target>       </trans-unit>
        <trans-unit id="857" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.SetUserEntryPoint(System.Reflection.MethodInfo)">
          <source>Sets the user entry point.</source>
          <target state="translated">Define o ponto de entrada do usuário.</target>       </trans-unit>
        <trans-unit id="858" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.SetUserEntryPoint(System.Reflection.MethodInfo)">
          <source>The compiler might generate a startup stub before calling user main.</source>
          <target state="translated">O compilador pode gerar um stub de inicialização antes de chamar o usuário principal.</target>       </trans-unit>
        <trans-unit id="859" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.SetUserEntryPoint(System.Reflection.MethodInfo)">
          <source>The startup stub will be the entry point.</source>
          <target state="translated">O stub de inicialização será o ponto de entrada.</target>       </trans-unit>
        <trans-unit id="860" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.SetUserEntryPoint(System.Reflection.MethodInfo)">
          <source>While the user main will be the user entry point so that debugger will not step into the compiler entry point.</source>
          <target state="translated">Enquanto o usuário principal será o ponto de entrada do usuário para que o depurador não irá passar para o ponto de entrada do compilador.</target>       </trans-unit>
        <trans-unit id="861" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.SetUserEntryPoint(System.Reflection.MethodInfo)">
          <source>Starting with the <ph id="ph1">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</ph>, this member no longer requires <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> with the <ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType&gt;</ph> flag.</source>
          <target state="translated">Começando com o <ph id="ph1">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</ph>, esse membro não requer mais <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> com o <ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType&gt;</ph> sinalizador.</target>       </trans-unit>
        <trans-unit id="862" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.SetUserEntryPoint(System.Reflection.MethodInfo)">
          <source>(See <bpt id="p1">[</bpt>Security Issues in Reflection Emit<ept id="p1">](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)</ept>.) To use this functionality, your application should target the <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> or later.</source>
          <target state="translated">(Consulte <bpt id="p1">[</bpt>problemas de segurança em reflexão emitir<ept id="p1">](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)</ept>.) Para usar essa funcionalidade, seu aplicativo deve ser direcionado ao <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> ou posterior.</target>       </trans-unit>
        <trans-unit id="863" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.SetUserEntryPoint(System.Reflection.MethodInfo)">
          <source><ph id="ph1">&lt;paramref name="entryPoint" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="entryPoint" /&gt;</ph> é <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="864" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.SetUserEntryPoint(System.Reflection.MethodInfo)">
          <source>This method is called on a dynamic module that is not a debug module.</source>
          <target state="translated">Esse método é chamado em um módulo dinâmico não é um módulo de depuração.</target>       </trans-unit>
        <trans-unit id="865" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.SetUserEntryPoint(System.Reflection.MethodInfo)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="866" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.SetUserEntryPoint(System.Reflection.MethodInfo)">
          <source><ph id="ph1">&lt;paramref name="entryPoint" /&gt;</ph> is not contained in this dynamic module.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="entryPoint" /&gt;</ph> não está contido neste módulo dinâmico.</target>       </trans-unit>
        <trans-unit id="867" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.System#Runtime#InteropServices#_ModuleBuilder#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)">
          <source>Reserved for future use.</source>
          <target state="translated">Reservado para uso futuro.</target>       </trans-unit>
        <trans-unit id="868" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.System#Runtime#InteropServices#_ModuleBuilder#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)">
          <source>Must be IID_NULL.</source>
          <target state="translated">Deve ser IID_NULL.</target>       </trans-unit>
        <trans-unit id="869" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.System#Runtime#InteropServices#_ModuleBuilder#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)">
          <source>Passed-in array of names to be mapped.</source>
          <target state="translated">Matriz passada de nomes a serem mapeados.</target>       </trans-unit>
        <trans-unit id="870" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.System#Runtime#InteropServices#_ModuleBuilder#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)">
          <source>Count of the names to be mapped.</source>
          <target state="translated">Contagem dos nomes a serem mapeados.</target>       </trans-unit>
        <trans-unit id="871" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.System#Runtime#InteropServices#_ModuleBuilder#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)">
          <source>The locale context in which to interpret the names.</source>
          <target state="translated">O contexto de localidade no qual interpretar os nomes.</target>       </trans-unit>
        <trans-unit id="872" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.System#Runtime#InteropServices#_ModuleBuilder#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)">
          <source>Caller-allocated array which receives the IDs corresponding to the names.</source>
          <target state="translated">Matriz alocada pelo chamador que recebe os IDs correspondentes aos nomes.</target>       </trans-unit>
        <trans-unit id="873" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.System#Runtime#InteropServices#_ModuleBuilder#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)">
          <source>For a description of this member, see <ph id="ph1">&lt;see cref="M:System.Runtime.InteropServices._ModuleBuilder.GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)" /&gt;</ph>.</source>
          <target state="translated">Para obter uma descrição desse membro, consulte <ph id="ph1">&lt;see cref="M:System.Runtime.InteropServices._ModuleBuilder.GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="874" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.System#Runtime#InteropServices#_ModuleBuilder#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)">
          <source>This method is for access to managed classes from unmanaged code, and should not be called from managed code.</source>
          <target state="translated">Este método é para acesso a classes gerenciadas de código não gerenciado e não deve ser chamado em código gerenciado.</target>       </trans-unit>
        <trans-unit id="875" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.System#Runtime#InteropServices#_ModuleBuilder#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)">
          <source>For more information about <ph id="ph1">`IDispatch::GetIDsOfNames`</ph>, see the MSDN Library.</source>
          <target state="translated">Para obter mais informações sobre <ph id="ph1">`IDispatch::GetIDsOfNames`</ph>, consulte a Biblioteca MSDN.</target>       </trans-unit>
        <trans-unit id="876" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.System#Runtime#InteropServices#_ModuleBuilder#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)">
          <source>This member is an explicit interface member implementation.</source>
          <target state="translated">Este membro é uma implementação do membro de interface explícita.</target>       </trans-unit>
        <trans-unit id="877" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.System#Runtime#InteropServices#_ModuleBuilder#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)">
          <source>It can be used only when the <ph id="ph1">&lt;xref:System.Reflection.Emit.ModuleBuilder&gt;</ph> instance is cast to an <ph id="ph2">&lt;xref:System.Runtime.InteropServices._ModuleBuilder&gt;</ph> interface.</source>
          <target state="translated">Ele só pode ser usado quando a instância de <ph id="ph1">&lt;xref:System.Reflection.Emit.ModuleBuilder&gt;</ph> é convertida em uma interface de <ph id="ph2">&lt;xref:System.Runtime.InteropServices._ModuleBuilder&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="878" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.System#Runtime#InteropServices#_ModuleBuilder#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)">
          <source>The method is called late-bound using the COM <bpt id="p1">&lt;c&gt;</bpt>IDispatch<ept id="p1">&lt;/c&gt;</ept> interface.</source>
          <target state="translated">O método é chamado de associação tardia usando a interface <bpt id="p1">&lt;c&gt;</bpt>IDispatch<ept id="p1">&lt;/c&gt;</ept> do COM.</target>       </trans-unit>
        <trans-unit id="879" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.System#Runtime#InteropServices#_ModuleBuilder#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)">
          <source>The type information to return.</source>
          <target state="translated">As informações de tipo a serem retornadas.</target>       </trans-unit>
        <trans-unit id="880" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.System#Runtime#InteropServices#_ModuleBuilder#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)">
          <source>The locale identifier for the type information.</source>
          <target state="translated">O identificador de localidade das informações do tipo.</target>       </trans-unit>
        <trans-unit id="881" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.System#Runtime#InteropServices#_ModuleBuilder#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)">
          <source>A pointer to the requested type information object.</source>
          <target state="translated">Um ponteiro para o objeto de informações de tipo solicitado.</target>       </trans-unit>
        <trans-unit id="882" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.System#Runtime#InteropServices#_ModuleBuilder#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)">
          <source>For a description of this member, see <ph id="ph1">&lt;see cref="M:System.Runtime.InteropServices._ModuleBuilder.GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)" /&gt;</ph>.</source>
          <target state="translated">Para obter uma descrição desse membro, consulte <ph id="ph1">&lt;see cref="M:System.Runtime.InteropServices._ModuleBuilder.GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="883" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.System#Runtime#InteropServices#_ModuleBuilder#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)">
          <source>This method is for access to managed classes from unmanaged code, and should not be called from managed code.</source>
          <target state="translated">Este método é para acesso a classes gerenciadas de código não gerenciado e não deve ser chamado em código gerenciado.</target>       </trans-unit>
        <trans-unit id="884" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.System#Runtime#InteropServices#_ModuleBuilder#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)">
          <source>For more information about <ph id="ph1">`IDispatch::GetTypeInfo`</ph>, see the MSDN Library.</source>
          <target state="translated">Para obter mais informações sobre <ph id="ph1">`IDispatch::GetTypeInfo`</ph>, consulte a Biblioteca MSDN.</target>       </trans-unit>
        <trans-unit id="885" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.System#Runtime#InteropServices#_ModuleBuilder#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)">
          <source>This member is an explicit interface member implementation.</source>
          <target state="translated">Este membro é uma implementação do membro de interface explícita.</target>       </trans-unit>
        <trans-unit id="886" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.System#Runtime#InteropServices#_ModuleBuilder#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)">
          <source>It can be used only when the <ph id="ph1">&lt;xref:System.Reflection.Emit.ModuleBuilder&gt;</ph> instance is cast to an <ph id="ph2">&lt;xref:System.Runtime.InteropServices._ModuleBuilder&gt;</ph> interface.</source>
          <target state="translated">Ele só pode ser usado quando a instância de <ph id="ph1">&lt;xref:System.Reflection.Emit.ModuleBuilder&gt;</ph> é convertida em uma interface de <ph id="ph2">&lt;xref:System.Runtime.InteropServices._ModuleBuilder&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="887" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.System#Runtime#InteropServices#_ModuleBuilder#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)">
          <source>The method is called late-bound using the COM <bpt id="p1">&lt;c&gt;</bpt>IDispatch<ept id="p1">&lt;/c&gt;</ept> interface.</source>
          <target state="translated">O método é chamado de associação tardia usando a interface <bpt id="p1">&lt;c&gt;</bpt>IDispatch<ept id="p1">&lt;/c&gt;</ept> do COM.</target>       </trans-unit>
        <trans-unit id="888" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.System#Runtime#InteropServices#_ModuleBuilder#GetTypeInfoCount(System.UInt32@)">
          <source>The location that receives the number of type information interfaces provided by the object.</source>
          <target state="translated">O local que recebe o número de interfaces de informações de tipo fornecidas pelo objeto.</target>       </trans-unit>
        <trans-unit id="889" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.System#Runtime#InteropServices#_ModuleBuilder#GetTypeInfoCount(System.UInt32@)">
          <source>For a description of this member, see <ph id="ph1">&lt;see cref="M:System.Runtime.InteropServices._ModuleBuilder.GetTypeInfoCount(System.UInt32@)" /&gt;</ph>.</source>
          <target state="translated">Para obter uma descrição desse membro, consulte <ph id="ph1">&lt;see cref="M:System.Runtime.InteropServices._ModuleBuilder.GetTypeInfoCount(System.UInt32@)" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="890" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.System#Runtime#InteropServices#_ModuleBuilder#GetTypeInfoCount(System.UInt32@)">
          <source>This method is for access to managed classes from unmanaged code, and should not be called from managed code.</source>
          <target state="translated">Este método é para acesso a classes gerenciadas de código não gerenciado e não deve ser chamado em código gerenciado.</target>       </trans-unit>
        <trans-unit id="891" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.System#Runtime#InteropServices#_ModuleBuilder#GetTypeInfoCount(System.UInt32@)">
          <source>For more information about <ph id="ph1">`IDispatch::GetTypeInfoCount`</ph>, see the MSDN Library.</source>
          <target state="translated">Para obter mais informações sobre <ph id="ph1">`IDispatch::GetTypeInfoCount`</ph>, consulte a Biblioteca MSDN.</target>       </trans-unit>
        <trans-unit id="892" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.System#Runtime#InteropServices#_ModuleBuilder#GetTypeInfoCount(System.UInt32@)">
          <source>This member is an explicit interface member implementation.</source>
          <target state="translated">Este membro é uma implementação do membro de interface explícita.</target>       </trans-unit>
        <trans-unit id="893" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.System#Runtime#InteropServices#_ModuleBuilder#GetTypeInfoCount(System.UInt32@)">
          <source>It can be used only when the <ph id="ph1">&lt;xref:System.Reflection.Emit.ModuleBuilder&gt;</ph> instance is cast to an <ph id="ph2">&lt;xref:System.Runtime.InteropServices._ModuleBuilder&gt;</ph> interface.</source>
          <target state="translated">Ele só pode ser usado quando a instância de <ph id="ph1">&lt;xref:System.Reflection.Emit.ModuleBuilder&gt;</ph> é convertida em uma interface de <ph id="ph2">&lt;xref:System.Runtime.InteropServices._ModuleBuilder&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="894" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.System#Runtime#InteropServices#_ModuleBuilder#GetTypeInfoCount(System.UInt32@)">
          <source>The method is called late-bound using the COM <bpt id="p1">&lt;c&gt;</bpt>IDispatch<ept id="p1">&lt;/c&gt;</ept> interface.</source>
          <target state="translated">O método é chamado de associação tardia usando a interface <bpt id="p1">&lt;c&gt;</bpt>IDispatch<ept id="p1">&lt;/c&gt;</ept> do COM.</target>       </trans-unit>
        <trans-unit id="895" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.System#Runtime#InteropServices#_ModuleBuilder#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>The member ID.</source>
          <target state="translated">A ID do membro.</target>       </trans-unit>
        <trans-unit id="896" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.System#Runtime#InteropServices#_ModuleBuilder#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>Reserved for future use.</source>
          <target state="translated">Reservado para uso futuro.</target>       </trans-unit>
        <trans-unit id="897" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.System#Runtime#InteropServices#_ModuleBuilder#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>Must be IID_NULL.</source>
          <target state="translated">Deve ser IID_NULL.</target>       </trans-unit>
        <trans-unit id="898" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.System#Runtime#InteropServices#_ModuleBuilder#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>The locale context in which to interpret arguments.</source>
          <target state="translated">O contexto de localidade no qual interpretar argumentos.</target>       </trans-unit>
        <trans-unit id="899" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.System#Runtime#InteropServices#_ModuleBuilder#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>Flags describing the context of the call.</source>
          <target state="translated">Sinalizadores que descrevem o contexto da chamada.</target>       </trans-unit>
        <trans-unit id="900" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.System#Runtime#InteropServices#_ModuleBuilder#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>Pointer to a structure containing an array of arguments, an array of argument DISPIDs for named arguments, and counts for the number of elements in the arrays.</source>
          <target state="translated">Ponteiro para uma estrutura contendo uma matriz de argumentos, uma matriz de DISPIDs de argumento para argumentos nomeados e contagens para o número de elementos nas matrizes.</target>       </trans-unit>
        <trans-unit id="901" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.System#Runtime#InteropServices#_ModuleBuilder#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>Pointer to the location where the result is to be stored.</source>
          <target state="translated">Ponteiro para o local onde o resultado deve ser armazenado.</target>       </trans-unit>
        <trans-unit id="902" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.System#Runtime#InteropServices#_ModuleBuilder#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>Pointer to a structure that contains exception information.</source>
          <target state="translated">Ponteiro para uma estrutura que contém informações de exceção.</target>       </trans-unit>
        <trans-unit id="903" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.System#Runtime#InteropServices#_ModuleBuilder#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>The index of the first argument that has an error.</source>
          <target state="translated">O índice do primeiro argumento que tem um erro.</target>       </trans-unit>
        <trans-unit id="904" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.System#Runtime#InteropServices#_ModuleBuilder#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>For a description of this member, see <ph id="ph1">&lt;see cref="M:System.Runtime.InteropServices._ModuleBuilder.Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)" /&gt;</ph>.</source>
          <target state="translated">Para obter uma descrição desse membro, consulte <ph id="ph1">&lt;see cref="M:System.Runtime.InteropServices._ModuleBuilder.Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="905" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.System#Runtime#InteropServices#_ModuleBuilder#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>This method is for access to managed classes from unmanaged code, and should not be called from managed code.</source>
          <target state="translated">Este método é para acesso a classes gerenciadas de código não gerenciado e não deve ser chamado em código gerenciado.</target>       </trans-unit>
        <trans-unit id="906" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.System#Runtime#InteropServices#_ModuleBuilder#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>For more information about <ph id="ph1">`IDispatch::Invoke`</ph>, see the MSDN Library.</source>
          <target state="translated">Para obter mais informações sobre <ph id="ph1">`IDispatch::Invoke`</ph>, consulte a Biblioteca MSDN.</target>       </trans-unit>
        <trans-unit id="907" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.System#Runtime#InteropServices#_ModuleBuilder#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>This member is an explicit interface member implementation.</source>
          <target state="translated">Este membro é uma implementação do membro de interface explícita.</target>       </trans-unit>
        <trans-unit id="908" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.System#Runtime#InteropServices#_ModuleBuilder#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>It can be used only when the <ph id="ph1">&lt;xref:System.Reflection.Emit.ModuleBuilder&gt;</ph> instance is cast to an <ph id="ph2">&lt;xref:System.Runtime.InteropServices._ModuleBuilder&gt;</ph> interface.</source>
          <target state="translated">Ele só pode ser usado quando a instância de <ph id="ph1">&lt;xref:System.Reflection.Emit.ModuleBuilder&gt;</ph> é convertida em uma interface de <ph id="ph2">&lt;xref:System.Runtime.InteropServices._ModuleBuilder&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="909" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.System#Runtime#InteropServices#_ModuleBuilder#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>The method is called late-bound using the COM <bpt id="p1">&lt;c&gt;</bpt>IDispatch<ept id="p1">&lt;/c&gt;</ept> interface.</source>
          <target state="translated">O método é chamado de associação tardia usando a interface <bpt id="p1">&lt;c&gt;</bpt>IDispatch<ept id="p1">&lt;/c&gt;</ept> do COM.</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>