<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="AssemblyBuilder.xml" source-language="en-US" target-language="pt-BR">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-15c36f0" tool-company="Microsoft" />
      <xliffext:skl_file_name xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">02cd5861-7ce2-4a82-b358-31f8435a0ac58042d4d2a7c7a54f8532813c480f8abdd84ee332.skl</xliffext:skl_file_name>
      <xliffext:version xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">1.2</xliffext:version>
      <xliffext:ms.openlocfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">8042d4d2a7c7a54f8532813c480f8abdd84ee332</xliffext:ms.openlocfilehash>
      <xliffext:ms.sourcegitcommit xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b</xliffext:ms.sourcegitcommit>
      <xliffext:ms.lasthandoff xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">04/03/2018</xliffext:ms.lasthandoff>
      <xliffext:moniker_ids xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">netcore-1.0,netcore-1.1,netcore-2.0,netcore-2.1,netframework-4.5.1,netframework-4.5.2,netframework-4.5,netframework-4.6.1,netframework-4.6.2,netframework-4.6,netframework-4.7.1,netframework-4.7,xamarinandroid-7.1,xamarinios-10.8,xamarinmac-3.0</xliffext:moniker_ids>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve" uid="T:System.Reflection.Emit.AssemblyBuilder">
          <source>Defines and represents a dynamic assembly.</source>
          <target state="translated">Define e representa um assembly dinâmico.</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.AssemblyBuilder">
          <source>A dynamic assembly is an assembly that is created using the Reflection Emit APIs.</source>
          <target state="translated">Um assembly dinâmico é um assembly que é criado usando as APIs de emissão de reflexão.</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.AssemblyBuilder">
          <source>The dynamic modules in the assembly are saved when the dynamic assembly is saved using the <ph id="ph1">&lt;xref:System.Reflection.Emit.AssemblyBuilder.Save%2A&gt;</ph> method.</source>
          <target state="translated">Os módulos dinâmicos no assembly são salvas quando o assembly dinâmico é salvo usando o <ph id="ph1">&lt;xref:System.Reflection.Emit.AssemblyBuilder.Save%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.AssemblyBuilder">
          <source>To generate an executable, the <ph id="ph1">&lt;xref:System.Reflection.Emit.AssemblyBuilder.SetEntryPoint%2A&gt;</ph> method must be called to identify the method that is the entry point to the assembly.</source>
          <target state="translated">Para gerar um executável, o <ph id="ph1">&lt;xref:System.Reflection.Emit.AssemblyBuilder.SetEntryPoint%2A&gt;</ph> método deve ser chamado para identificar o método que é o ponto de entrada para o assembly.</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.AssemblyBuilder">
          <source>Assemblies are saved as DLLs by default, unless the <ph id="ph1">&lt;xref:System.Reflection.Emit.AssemblyBuilder.SetEntryPoint%2A&gt;</ph> method requests the generation of a console application or a Windows-based application.</source>
          <target state="translated">Assemblies são salvos como DLLs por padrão, a menos que o <ph id="ph1">&lt;xref:System.Reflection.Emit.AssemblyBuilder.SetEntryPoint%2A&gt;</ph> método solicita a geração de um aplicativo de console ou um aplicativo baseado em Windows.</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.AssemblyBuilder">
          <source>If a dynamic assembly contains more than one dynamic module, the assembly's manifest file name should match the module's name that is specified as the first argument to the <ph id="ph1">&lt;xref:System.Reflection.Emit.AssemblyBuilder.DefineDynamicModule%2A&gt;</ph> method.</source>
          <target state="translated">Se um assembly dinâmico contém mais de um módulo dinâmico, nome de arquivo de manifesto do assembly deve corresponder o nome do módulo que é especificado como o primeiro argumento para o <ph id="ph1">&lt;xref:System.Reflection.Emit.AssemblyBuilder.DefineDynamicModule%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.AssemblyBuilder">
          <source>Some methods on the base <ph id="ph1">&lt;xref:System.Reflection.Assembly&gt;</ph> class, such as <ph id="ph2">`GetModules`</ph> and <ph id="ph3">`GetLoadedModules`</ph>, will not work correctly when called from <ph id="ph4">&lt;xref:System.Reflection.Emit.AssemblyBuilder&gt;</ph> objects.</source>
          <target state="translated">Alguns métodos na base de <ph id="ph1">&lt;xref:System.Reflection.Assembly&gt;</ph> classe, como <ph id="ph2">`GetModules`</ph> e <ph id="ph3">`GetLoadedModules`</ph>, não funcionará corretamente quando chamado de <ph id="ph4">&lt;xref:System.Reflection.Emit.AssemblyBuilder&gt;</ph> objetos.</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.AssemblyBuilder">
          <source>You can load the defined dynamic assembly and call the methods on the loaded assembly.</source>
          <target state="translated">Você pode carregar o assembly dinâmico definido e chamar os métodos no assembly carregado.</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.AssemblyBuilder">
          <source>For example, to ensure that resource modules are included in the returned module list, call <ph id="ph1">`GetModules`</ph> on the loaded <ph id="ph2">&lt;xref:System.Reflection.Assembly&gt;</ph> object.</source>
          <target state="translated">Por exemplo, para garantir que os módulos de recursos estão incluídos na lista de módulos retornado, chame <ph id="ph1">`GetModules`</ph> no carregador <ph id="ph2">&lt;xref:System.Reflection.Assembly&gt;</ph> objeto.</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.AssemblyBuilder">
          <source>The signing of a dynamic assembly using <ph id="ph1">&lt;xref:System.Reflection.AssemblyName.KeyPair%2A&gt;</ph> is not effective until the assembly is saved to disk.</source>
          <target state="translated">A assinatura de um assembly dinâmico usando <ph id="ph1">&lt;xref:System.Reflection.AssemblyName.KeyPair%2A&gt;</ph> não é eficaz até que o assembly seja salvo no disco.</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.AssemblyBuilder">
          <source>So, strong names will not work with transient dynamic assemblies.</source>
          <target state="translated">Portanto, nomes fortes não funcionará com assemblies dinâmicos transitórios.</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.AssemblyBuilder">
          <source>To get an <ph id="ph1">&lt;xref:System.Reflection.Emit.AssemblyBuilder&gt;</ph> object, use the <ph id="ph2">&lt;xref:System.AppDomain.DefineDynamicAssembly%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Para obter um <ph id="ph1">&lt;xref:System.Reflection.Emit.AssemblyBuilder&gt;</ph> de objeto, use o <ph id="ph2">&lt;xref:System.AppDomain.DefineDynamicAssembly%2A?displayProperty=nameWithType&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.AssemblyBuilder">
          <source>Reflection emit dynamic assembly scenarios</source>
          <target state="translated">Cenários de assembly dinâmico de emissão de reflexão</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.AssemblyBuilder">
          <source>The following are some things to consider when using the <ph id="ph1">&lt;xref:System.Reflection.Emit.AssemblyBuilder&gt;</ph> class to create dynamic assemblies.</source>
          <target state="translated">Estes são alguns pontos a considerar ao usar o <ph id="ph1">&lt;xref:System.Reflection.Emit.AssemblyBuilder&gt;</ph> classe para criar assemblies dinâmicos.</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.AssemblyBuilder">
          <source>Dynamic modules</source>
          <target state="translated">Módulos dinâmicos</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.AssemblyBuilder">
          <source>Reflection emit supports the creation of dynamic modules defined in dynamic assemblies.</source>
          <target state="translated">Oferece suporte à emissão de reflexão a criação de módulos dinâmicos definidos em assemblies dinâmicos.</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.AssemblyBuilder">
          <source>A dynamic module created in a dynamic assembly can be transient or persistable.</source>
          <target state="translated">Um módulo dinâmico criado em um assembly dinâmico pode ser transiente ou persistente.</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.AssemblyBuilder">
          <source>Restrictions on type references</source>
          <target state="translated">Restrições em referências de tipo</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.AssemblyBuilder">
          <source>Assemblies can reference types defined in another assembly.</source>
          <target state="translated">Módulos (assemblies) pode fazer referência a tipos definidos em outro assembly.</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.AssemblyBuilder">
          <source>A transient dynamic assembly can safely reference types defined in another transient dynamic assembly, a persistable dynamic assembly, or a static assembly.</source>
          <target state="translated">Um assembly dinâmico transitório com segurança pode fazer referência a tipos definidos em outro assembly dinâmico transitório, um assembly dinâmico persistente ou um conjunto estático.</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.AssemblyBuilder">
          <source>However, the common language runtime does not allow a persistable dynamic module to reference a type defined in a transient dynamic module.</source>
          <target state="translated">No entanto, o common language runtime não permite que um módulo dinâmico persistente fazer referência a um tipo definido em um módulo dinâmico transitório.</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.AssemblyBuilder">
          <source>This is because when the persisted dynamic module is loaded after being saved to disk, the runtime cannot resolve the references to types defined in the transient dynamic module.</source>
          <target state="translated">Isso ocorre porque quando o módulo dinâmico persistente é carregado após ser salvo em disco, o tempo de execução não é possível resolver as referências aos tipos definidos no módulo dinâmico transitório.</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.AssemblyBuilder">
          <source>Restrictions on emitting to remote application domains</source>
          <target state="translated">Restrições em emitindo a domínios de aplicativo remoto</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.AssemblyBuilder">
          <source>Some scenarios require a dynamic assembly to be created and executed in a remote application domain.</source>
          <target state="translated">Alguns cenários exigem um assembly dinâmico seja criado e executado em um domínio de aplicativo remoto.</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.AssemblyBuilder">
          <source>Reflection emit does not allow a dynamic assembly to be emitted directly to a remote application domain.</source>
          <target state="translated">Emissão de reflexão não permite que um assembly dinâmico ser emitida diretamente a um domínio de aplicativo remoto.</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.AssemblyBuilder">
          <source>The solution is to emit the dynamic assembly in the current application domain, save the emitted dynamic assembly to disk, and then load the dynamic assembly into the remote application domain.</source>
          <target state="translated">A solução é emitir o assembly dinâmico no domínio do aplicativo atual, salve o assembly dinâmico emitido em disco e, em seguida, carregar o assembly dinâmico no domínio de aplicativo remoto.</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.AssemblyBuilder">
          <source>Dynamic assembly access modes</source>
          <target state="translated">Modos de acesso de assembly dinâmico</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.AssemblyBuilder">
          <source>Dynamic assemblies can be created using one of the following access modes:</source>
          <target state="translated">Assemblies dinâmicos podem ser criados usando um dos seguintes modos:</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.AssemblyBuilder">
          <source>The dynamic assembly represented by an <ph id="ph1">&lt;xref:System.Reflection.Emit.AssemblyBuilder&gt;</ph> object is transient.</source>
          <target state="translated">O assembly dinâmico representado por um <ph id="ph1">&lt;xref:System.Reflection.Emit.AssemblyBuilder&gt;</ph> objeto é transitório.</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.AssemblyBuilder">
          <source>The dynamic assembly can only be used to execute the emitted code.</source>
          <target state="translated">O assembly dinâmico só pode ser usado para executar o código emitido.</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.AssemblyBuilder">
          <source>The dynamic assembly represented by an <ph id="ph1">&lt;xref:System.Reflection.Emit.AssemblyBuilder&gt;</ph> object is persistable but cannot be executed until the saved portable executable (PE) file has been loaded from disk.</source>
          <target state="translated">O assembly dinâmico representado por um <ph id="ph1">&lt;xref:System.Reflection.Emit.AssemblyBuilder&gt;</ph> objeto é persistente, mas não pode ser executado até que o arquivo salvo PE (executável portátil) foi carregado do disco.</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.AssemblyBuilder">
          <source>The dynamic assembly represented by an <ph id="ph1">&lt;xref:System.Reflection.Emit.AssemblyBuilder&gt;</ph> object is persistable, but can also be executed before and/or after the assembly is saved to disk.</source>
          <target state="translated">O assembly dinâmico representado por um <ph id="ph1">&lt;xref:System.Reflection.Emit.AssemblyBuilder&gt;</ph> é persistente do objeto, mas também podem ser executados antes e/ou depois que o assembly é salvo em disco.</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.AssemblyBuilder">
          <source>The access mode must be specified by providing the appropriate <ph id="ph1">&lt;xref:System.Reflection.Emit.AssemblyBuilderAccess&gt;</ph> value in the call to the <ph id="ph2">&lt;xref:System.Reflection.Emit.AssemblyBuilder.DefineDynamicAssembly%2A?displayProperty=nameWithType&gt;</ph> method when the dynamic assembly is defined and cannot be changed later.</source>
          <target state="translated">O modo de acesso deve ser especificado, fornecendo apropriada <ph id="ph1">&lt;xref:System.Reflection.Emit.AssemblyBuilderAccess&gt;</ph> valor na chamada para o <ph id="ph2">&lt;xref:System.Reflection.Emit.AssemblyBuilder.DefineDynamicAssembly%2A?displayProperty=nameWithType&gt;</ph> método quando o assembly dinâmico é definido e não pode ser alterado posteriormente.</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.AssemblyBuilder">
          <source>The runtime uses the access mode of a dynamic assembly to optimize the assembly's internal representation.</source>
          <target state="translated">O tempo de execução usa o modo de acesso de um assembly dinâmico para otimizar a representação interna do assembly.</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.AssemblyBuilder">
          <source>The following code example shows how to define a dynamic assembly with one module.</source>
          <target state="translated">O exemplo de código a seguir mostra como definir um assembly dinâmico com um módulo.</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.AssemblyBuilder">
          <source>The module in the example assembly contains one type, <ph id="ph1">`MyDynamicType`</ph>, which has a private field, a property that gets and sets the private field, constructors that initialize the private field, and a method that multiplies a user-supplied number by the private field value and returns the result.</source>
          <target state="translated">O módulo no assembly de exemplo contém um tipo, <ph id="ph1">`MyDynamicType`</ph>, que tem um campo particular, uma propriedade que obtém e define o campo privado, construtores que inicializar o campo privado e um método que multiplica um número fornecido pelo usuário pelo campo particular valor e retorna o resultado.</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.AssemblyBuilder">
          <source><ph id="ph1">&lt;xref:System.Reflection.Emit.AssemblyBuilderAccess.RunAndSave?displayProperty=nameWithType&gt;</ph> is specified when the assembly is created.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Reflection.Emit.AssemblyBuilderAccess.RunAndSave?displayProperty=nameWithType&gt;</ph> é especificado quando o assembly é criado.</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.AssemblyBuilder">
          <source>The assembly code is used immediately, and the assembly is also saved to disk so that it can be examined with <bpt id="p1">[</bpt>Ildasm.exe (IL Disassembler)<ept id="p1">](~/docs/framework/tools/ildasm-exe-il-disassembler.md)</ept> or used in another program.</source>
          <target state="translated">O código do assembly é usado imediatamente, e o assembly também é salvas em disco para que ele pode ser examinado com <bpt id="p1">[</bpt>Ildasm.exe (IL Disassembler)<ept id="p1">](~/docs/framework/tools/ildasm-exe-il-disassembler.md)</ept> ou usado em outro programa.</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.AssemblyBuilder">
          <source>when invoked late-bound through mechanisms such as <ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>.</source>
          <target state="translated">quando invocado com associação tardia por meio de mecanismos como <ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.AssemblyBuilder">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph>.</source>
          <target state="translated">Enumeração associada: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve" uid="T:System.Reflection.Emit.AssemblyBuilder">
          <source>Adds an existing resource file to this assembly.</source>
          <target state="translated">Adiciona um arquivo de recurso existente a esse assembly.</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.AssemblyBuilder.AddResourceFile(System.String,System.String)">
          <source>The logical name of the resource.</source>
          <target state="translated">O nome lógico do recurso.</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.AssemblyBuilder.AddResourceFile(System.String,System.String)">
          <source>The physical file name (.resources file) to which the logical name is mapped.</source>
          <target state="translated">O nome do arquivo físico (arquivo .resources) para o qual o nome lógico é mapeado.</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.AssemblyBuilder.AddResourceFile(System.String,System.String)">
          <source>This should not include a path; the file must be in the same directory as the assembly to which it is added.</source>
          <target state="translated">Não se deve incluir um caminho; o arquivo deve estar no mesmo diretório que o assembly ao qual ele é adicionado.</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.AssemblyBuilder.AddResourceFile(System.String,System.String)">
          <source>Adds an existing resource file to this assembly.</source>
          <target state="translated">Adiciona um arquivo de recurso existente a esse assembly.</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.AssemblyBuilder.AddResourceFile(System.String,System.String)">
          <source><ph id="ph1">`fileName`</ph> should not be the same as that of any other persistable module, standalone managed resource, or the standalone manifest file.</source>
          <target state="translated"><ph id="ph1">`fileName`</ph> não deve ser o mesmo de outro módulo persistente, recurso autônomo gerenciado ou o arquivo de manifesto autônomo.</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.AssemblyBuilder.AddResourceFile(System.String,System.String)">
          <source>The managed resources in the file are assumed to be public.</source>
          <target state="translated">Os recursos gerenciados no arquivo devem para ser públicos.</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.AssemblyBuilder.AddResourceFile(System.String,System.String)">
          <source>The specified resource file must be in the directory where the assembly will be saved.</source>
          <target state="translated">O arquivo de recurso especificado deve estar no diretório onde o assembly será salvo.</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.AssemblyBuilder.AddResourceFile(System.String,System.String)">
          <source>Starting with the <ph id="ph1">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</ph>, this member no longer requires <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> with the <ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType&gt;</ph> flag.</source>
          <target state="translated">Começando com o <ph id="ph1">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</ph>, esse membro não requer mais <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> com o <ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType&gt;</ph> sinalizador.</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.AssemblyBuilder.AddResourceFile(System.String,System.String)">
          <source>(See <bpt id="p1">[</bpt>Security Issues in Reflection Emit<ept id="p1">](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)</ept>.) To use this functionality, your application should target the <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> or later.</source>
          <target state="translated">(Consulte <bpt id="p1">[</bpt>problemas de segurança em reflexão emitir<ept id="p1">](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)</ept>.) Para usar essa funcionalidade, seu aplicativo deve ser direcionado ao <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> ou posterior.</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.AssemblyBuilder.AddResourceFile(System.String,System.String)">
          <source>The following code sample demonstrates how to attach a resource file to a dynamically created assembly, using <ph id="ph1">`AddResourceFile`</ph>.</source>
          <target state="translated">O exemplo de código a seguir demonstra como anexar um arquivo de recurso a um assembly criado dinamicamente, usando <ph id="ph1">`AddResourceFile`</ph>.</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.AssemblyBuilder.AddResourceFile(System.String,System.String)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> has been previously defined.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> foi definido anteriormente.</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.AssemblyBuilder.AddResourceFile(System.String,System.String)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.AssemblyBuilder.AddResourceFile(System.String,System.String)">
          <source>There is another file in the assembly named <ph id="ph1">&lt;paramref name="fileName" /&gt;</ph>.</source>
          <target state="translated">Há outro arquivo no assembly chamado <ph id="ph1">&lt;paramref name="fileName" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.AssemblyBuilder.AddResourceFile(System.String,System.String)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.AssemblyBuilder.AddResourceFile(System.String,System.String)">
          <source>The length of <ph id="ph1">&lt;paramref name="name" /&gt;</ph> is zero.</source>
          <target state="translated">O comprimento de <ph id="ph1">&lt;paramref name="name" /&gt;</ph> é zero.</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.AssemblyBuilder.AddResourceFile(System.String,System.String)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.AssemblyBuilder.AddResourceFile(System.String,System.String)">
          <source>The length of <ph id="ph1">&lt;paramref name="fileName" /&gt;</ph> is zero, or if <ph id="ph2">&lt;paramref name="fileName" /&gt;</ph> includes a path.</source>
          <target state="translated">O comprimento de <ph id="ph1">&lt;paramref name="fileName" /&gt;</ph> é zero ou, se <ph id="ph2">&lt;paramref name="fileName" /&gt;</ph> inclui um caminho.</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.AssemblyBuilder.AddResourceFile(System.String,System.String)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> or <ph id="ph2">&lt;paramref name="fileName" /&gt;</ph> is <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> ou <ph id="ph2">&lt;paramref name="fileName" /&gt;</ph> é <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.AssemblyBuilder.AddResourceFile(System.String,System.String)">
          <source>The file <ph id="ph1">&lt;paramref name="fileName" /&gt;</ph> is not found.</source>
          <target state="translated">O arquivo <ph id="ph1">&lt;paramref name="fileName" /&gt;</ph> não foi encontrado.</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.AssemblyBuilder.AddResourceFile(System.String,System.String)">
          <source>The caller does not have the required permission.</source>
          <target state="translated">O chamador não tem a permissão necessária.</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.AssemblyBuilder.AddResourceFile(System.String,System.String)">
          <source>when invoked late-bound through mechanisms such as <ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>.</source>
          <target state="translated">quando invocado com associação tardia por meio de mecanismos como <ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.AssemblyBuilder.AddResourceFile(System.String,System.String)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph>.</source>
          <target state="translated">Enumeração associada: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.AssemblyBuilder.AddResourceFile(System.String,System.String)">
          <source>The FileIOPermissionAccess.Read permission is needed to access the resource file <ph id="ph1">&lt;paramref name="resourceFileName" /&gt;</ph>.</source>
          <target state="translated">A permissão de FileIOPermissionAccess.Read é necessária para acessar o arquivo de recurso <ph id="ph1">&lt;paramref name="resourceFileName" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.AssemblyBuilder.AddResourceFile(System.String,System.String,System.Reflection.ResourceAttributes)">
          <source>The logical name of the resource.</source>
          <target state="translated">O nome lógico do recurso.</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.AssemblyBuilder.AddResourceFile(System.String,System.String,System.Reflection.ResourceAttributes)">
          <source>The physical file name (.resources file) to which the logical name is mapped.</source>
          <target state="translated">O nome do arquivo físico (arquivo .resources) para o qual o nome lógico é mapeado.</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.AssemblyBuilder.AddResourceFile(System.String,System.String,System.Reflection.ResourceAttributes)">
          <source>This should not include a path; the file must be in the same directory as the assembly to which it is added.</source>
          <target state="translated">Não se deve incluir um caminho; o arquivo deve estar no mesmo diretório que o assembly ao qual ele é adicionado.</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.AssemblyBuilder.AddResourceFile(System.String,System.String,System.Reflection.ResourceAttributes)">
          <source>The resource attributes.</source>
          <target state="translated">Os atributos de recursos.</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.AssemblyBuilder.AddResourceFile(System.String,System.String,System.Reflection.ResourceAttributes)">
          <source>Adds an existing resource file to this assembly.</source>
          <target state="translated">Adiciona um arquivo de recurso existente a esse assembly.</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.AssemblyBuilder.AddResourceFile(System.String,System.String,System.Reflection.ResourceAttributes)">
          <source><ph id="ph1">`fileName`</ph> should not be the same as that of any other persistable module, standalone managed resource, or the standalone manifest file.</source>
          <target state="translated"><ph id="ph1">`fileName`</ph> não deve ser o mesmo de outro módulo persistente, recurso autônomo gerenciado ou o arquivo de manifesto autônomo.</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.AssemblyBuilder.AddResourceFile(System.String,System.String,System.Reflection.ResourceAttributes)">
          <source>Attributes can be specified for the managed resource.</source>
          <target state="translated">Atributos podem ser especificados para o recurso gerenciado.</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.AssemblyBuilder.AddResourceFile(System.String,System.String,System.Reflection.ResourceAttributes)">
          <source>The specified resource file must be in the directory where the assembly will be saved.</source>
          <target state="translated">O arquivo de recurso especificado deve estar no diretório onde o assembly será salvo.</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.AssemblyBuilder.AddResourceFile(System.String,System.String,System.Reflection.ResourceAttributes)">
          <source>Starting with the <ph id="ph1">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</ph>, this member no longer requires <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> with the <ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType&gt;</ph> flag.</source>
          <target state="translated">Começando com o <ph id="ph1">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</ph>, esse membro não requer mais <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> com o <ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType&gt;</ph> sinalizador.</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.AssemblyBuilder.AddResourceFile(System.String,System.String,System.Reflection.ResourceAttributes)">
          <source>(See <bpt id="p1">[</bpt>Security Issues in Reflection Emit<ept id="p1">](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)</ept>.) To use this functionality, your application should target the <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> or later.</source>
          <target state="translated">(Consulte <bpt id="p1">[</bpt>problemas de segurança em reflexão emitir<ept id="p1">](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)</ept>.) Para usar essa funcionalidade, seu aplicativo deve ser direcionado ao <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> ou posterior.</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.AssemblyBuilder.AddResourceFile(System.String,System.String,System.Reflection.ResourceAttributes)">
          <source>The following code sample demonstrates how to attach a resource file to a dynamically created assembly, using <ph id="ph1">`AddResourceFile`</ph>.</source>
          <target state="translated">O exemplo de código a seguir demonstra como anexar um arquivo de recurso a um assembly criado dinamicamente, usando <ph id="ph1">`AddResourceFile`</ph>.</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.AssemblyBuilder.AddResourceFile(System.String,System.String,System.Reflection.ResourceAttributes)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> has been previously defined.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> foi definido anteriormente.</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.AssemblyBuilder.AddResourceFile(System.String,System.String,System.Reflection.ResourceAttributes)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.AssemblyBuilder.AddResourceFile(System.String,System.String,System.Reflection.ResourceAttributes)">
          <source>There is another file in the assembly named <ph id="ph1">&lt;paramref name="fileName" /&gt;</ph>.</source>
          <target state="translated">Há outro arquivo no assembly chamado <ph id="ph1">&lt;paramref name="fileName" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.AssemblyBuilder.AddResourceFile(System.String,System.String,System.Reflection.ResourceAttributes)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.AssemblyBuilder.AddResourceFile(System.String,System.String,System.Reflection.ResourceAttributes)">
          <source>The length of <ph id="ph1">&lt;paramref name="name" /&gt;</ph> is zero or if the length of <ph id="ph2">&lt;paramref name="fileName" /&gt;</ph> is zero.</source>
          <target state="translated">O comprimento de <ph id="ph1">&lt;paramref name="name" /&gt;</ph> é zero ou se o comprimento de <ph id="ph2">&lt;paramref name="fileName" /&gt;</ph> for zero.</target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.AssemblyBuilder.AddResourceFile(System.String,System.String,System.Reflection.ResourceAttributes)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.AssemblyBuilder.AddResourceFile(System.String,System.String,System.Reflection.ResourceAttributes)">
          <source><ph id="ph1">&lt;paramref name="fileName" /&gt;</ph> includes a path.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="fileName" /&gt;</ph> inclui um caminho.</target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.AssemblyBuilder.AddResourceFile(System.String,System.String,System.Reflection.ResourceAttributes)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> or <ph id="ph2">&lt;paramref name="fileName" /&gt;</ph> is <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> ou <ph id="ph2">&lt;paramref name="fileName" /&gt;</ph> é <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.AssemblyBuilder.AddResourceFile(System.String,System.String,System.Reflection.ResourceAttributes)">
          <source>If the file <ph id="ph1">&lt;paramref name="fileName" /&gt;</ph> is not found.</source>
          <target state="translated">Se o arquivo <ph id="ph1">&lt;paramref name="fileName" /&gt;</ph> não foi encontrado.</target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.AssemblyBuilder.AddResourceFile(System.String,System.String,System.Reflection.ResourceAttributes)">
          <source>The caller does not have the required permission.</source>
          <target state="translated">O chamador não tem a permissão necessária.</target>       </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.AssemblyBuilder.AddResourceFile(System.String,System.String,System.Reflection.ResourceAttributes)">
          <source>when invoked late-bound through mechanisms such as <ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>.</source>
          <target state="translated">quando invocado com associação tardia por meio de mecanismos como <ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.AssemblyBuilder.AddResourceFile(System.String,System.String,System.Reflection.ResourceAttributes)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph>.</source>
          <target state="translated">Enumeração associada: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.AssemblyBuilder.AddResourceFile(System.String,System.String,System.Reflection.ResourceAttributes)">
          <source>The FileIOPermissionAccess.Read permission is needed to access the resource file <ph id="ph1">&lt;paramref name="resourceFileName" /&gt;</ph>.</source>
          <target state="translated">A permissão de FileIOPermissionAccess.Read é necessária para acessar o arquivo de recurso <ph id="ph1">&lt;paramref name="resourceFileName" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve" uid="P:System.Reflection.Emit.AssemblyBuilder.CodeBase">
          <source>Gets the location of the assembly, as specified originally (such as in an <ph id="ph1">&lt;see cref="T:System.Reflection.AssemblyName" /&gt;</ph> object).</source>
          <target state="translated">Obtém o local do assembly como especificado originalmente (como em um objeto <ph id="ph1">&lt;see cref="T:System.Reflection.AssemblyName" /&gt;</ph>).</target>       </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.AssemblyBuilder.CodeBase">
          <source>The location of the assembly, as specified originally.</source>
          <target state="translated">O local do assembly, conforme especificado originalmente.</target>       </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.AssemblyBuilder.CodeBase">
          <source>To get the absolute path to the loaded manifest-containing file, use the <ph id="ph1">&lt;xref:System.Reflection.Assembly.Location%2A?displayProperty=nameWithType&gt;</ph> property.</source>
          <target state="translated">Para obter o caminho absoluto para o arquivo de manifesto-contendo carregado, use o <ph id="ph1">&lt;xref:System.Reflection.Assembly.Location%2A?displayProperty=nameWithType&gt;</ph> propriedade.</target>       </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve" uid="P:System.Reflection.Emit.AssemblyBuilder.CodeBase">
          <source>This method is not currently supported.</source>
          <target state="translated">Não há suporte para este método atualmente.</target>       </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve" uid="P:System.Reflection.Emit.AssemblyBuilder.CodeBase">
          <source>The caller does not have the required permission.</source>
          <target state="translated">O chamador não tem a permissão necessária.</target>       </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.AssemblyBuilder.CodeBase">
          <source>when invoked late-bound through mechanisms such as <ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>.</source>
          <target state="translated">quando invocado com associação tardia por meio de mecanismos como <ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.AssemblyBuilder.CodeBase">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph>.</source>
          <target state="translated">Enumeração associada: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve" uid="T:System.Reflection.Emit.AssemblyBuilder">
          <source>Defines a dynamic assembly.</source>
          <target state="translated">Define um assembly dinâmico.</target>       </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.AssemblyBuilder.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess)">
          <source>The name of the assembly.</source>
          <target state="translated">O nome do assembly.</target>       </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.AssemblyBuilder.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess)">
          <source>The access rights of the assembly.</source>
          <target state="translated">Os direitos de acesso do assembly.</target>       </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.AssemblyBuilder.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess)">
          <source>Defines a dynamic assembly that has the specified name and access rights.</source>
          <target state="translated">Define um assembly dinâmico que tem o nome e os direitos de acesso especificados.</target>       </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.AssemblyBuilder.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess)">
          <source>An object that represents the new assembly.</source>
          <target state="translated">Um objeto que representa o novo assembly.</target>       </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.AssemblyBuilder.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder})">
          <source>The name of the assembly.</source>
          <target state="translated">O nome do assembly.</target>       </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.AssemblyBuilder.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder})">
          <source>The access rights of the assembly.</source>
          <target state="translated">Os direitos de acesso do assembly.</target>       </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.AssemblyBuilder.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder})">
          <source>A collection that contains the attributes of the assembly.</source>
          <target state="translated">Uma coleção que contém os atributos do assembly.</target>       </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.AssemblyBuilder.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder})">
          <source>Defines a new assembly that has the specified name, access rights, and attributes.</source>
          <target state="translated">Define um novo assembly que tem o nome, os direitos de acesso e os atributos especificados.</target>       </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.AssemblyBuilder.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder})">
          <source>An object that represents the new assembly.</source>
          <target state="translated">Um objeto que representa o novo assembly.</target>       </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve" uid="T:System.Reflection.Emit.AssemblyBuilder">
          <source>Defines a dynamic module in this assembly.</source>
          <target state="translated">Define um módulo dinâmico neste assembly.</target>       </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.AssemblyBuilder.DefineDynamicModule(System.String)">
          <source>The name of the dynamic module.</source>
          <target state="translated">O nome do módulo dinâmico.</target>       </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.AssemblyBuilder.DefineDynamicModule(System.String)">
          <source>Must be less than 260 characters in length.</source>
          <target state="translated">Deve ter menos que 260 caracteres.</target>       </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.AssemblyBuilder.DefineDynamicModule(System.String)">
          <source>Defines a named transient dynamic module in this assembly.</source>
          <target state="translated">Define um módulo dinâmico transitório nomeado nesse assembly.</target>       </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.AssemblyBuilder.DefineDynamicModule(System.String)">
          <source>A <ph id="ph1">&lt;see cref="T:System.Reflection.Emit.ModuleBuilder" /&gt;</ph> representing the defined dynamic module.</source>
          <target state="translated">Um <ph id="ph1">&lt;see cref="T:System.Reflection.Emit.ModuleBuilder" /&gt;</ph> que representa o módulo dinâmico definido.</target>       </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.AssemblyBuilder.DefineDynamicModule(System.String)">
          <source>It is an error to define multiple dynamic modules with the same name in an assembly.</source>
          <target state="translated">É um erro ao definir vários módulos dinâmicos com o mesmo nome em um assembly.</target>       </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.AssemblyBuilder.DefineDynamicModule(System.String)">
          <source>The defined dynamic module is transient.</source>
          <target state="translated">O módulo dinâmico definido é transitório.</target>       </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.AssemblyBuilder.DefineDynamicModule(System.String)">
          <source>The dynamic module is not saved, even if the parent dynamic assembly was created with <ph id="ph1">&lt;xref:System.Reflection.Emit.AssemblyBuilderAccess.RunAndSave&gt;</ph>.</source>
          <target state="translated">O módulo dinâmico não for salva, mesmo se o assembly dinâmico pai foi criado com <ph id="ph1">&lt;xref:System.Reflection.Emit.AssemblyBuilderAccess.RunAndSave&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.AssemblyBuilder.DefineDynamicModule(System.String)">
          <source>To suppress optimizations when debugging dynamic modules, apply the <ph id="ph1">&lt;xref:System.Diagnostics.DebuggableAttribute&gt;</ph> attribute to the dynamic assembly before calling <ph id="ph2">&lt;xref:System.Reflection.Emit.AssemblyBuilder.DefineDynamicModule%2A&gt;</ph>.</source>
          <target state="translated">Para suprimir otimizações durante a depuração de módulos dinâmicos, aplicar o <ph id="ph1">&lt;xref:System.Diagnostics.DebuggableAttribute&gt;</ph> de atributo para o assembly dinâmico antes de chamar <ph id="ph2">&lt;xref:System.Reflection.Emit.AssemblyBuilder.DefineDynamicModule%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.AssemblyBuilder.DefineDynamicModule(System.String)">
          <source>Create an instance of <ph id="ph1">&lt;xref:System.Diagnostics.DebuggableAttribute&gt;</ph> with the <ph id="ph2">&lt;xref:System.Diagnostics.DebuggableAttribute.DebuggingModes.DisableOptimizations&gt;</ph> flag and apply it using the <ph id="ph3">&lt;xref:System.Reflection.Emit.AssemblyBuilder.SetCustomAttribute%2A&gt;</ph> method.</source>
          <target state="translated">Criar uma instância de <ph id="ph1">&lt;xref:System.Diagnostics.DebuggableAttribute&gt;</ph> com o <ph id="ph2">&lt;xref:System.Diagnostics.DebuggableAttribute.DebuggingModes.DisableOptimizations&gt;</ph> sinalizador e aplicá-lo usando o <ph id="ph3">&lt;xref:System.Reflection.Emit.AssemblyBuilder.SetCustomAttribute%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.AssemblyBuilder.DefineDynamicModule(System.String)">
          <source>The attribute must be applied to the dynamic assembly.</source>
          <target state="translated">O atributo deve ser aplicado ao assembly dinâmico.</target>       </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.AssemblyBuilder.DefineDynamicModule(System.String)">
          <source>It has no effect if applied to the module.</source>
          <target state="translated">Não tem nenhum efeito se aplicada para o módulo.</target>       </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.AssemblyBuilder.DefineDynamicModule(System.String)">
          <source>Starting with the <ph id="ph1">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</ph>, this member no longer requires <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> with the <ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType&gt;</ph> flag.</source>
          <target state="translated">Começando com o <ph id="ph1">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</ph>, esse membro não requer mais <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> com o <ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType&gt;</ph> sinalizador.</target>       </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.AssemblyBuilder.DefineDynamicModule(System.String)">
          <source>(See <bpt id="p1">[</bpt>Security Issues in Reflection Emit<ept id="p1">](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)</ept>.) To use this functionality, your application should target the <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> or later.</source>
          <target state="translated">(Consulte <bpt id="p1">[</bpt>problemas de segurança em reflexão emitir<ept id="p1">](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)</ept>.) Para usar essa funcionalidade, seu aplicativo deve ser direcionado ao <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> ou posterior.</target>       </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.AssemblyBuilder.DefineDynamicModule(System.String)">
          <source>[Visual Basic, C#]</source>
          <target state="translated">[Visual Basic, C#]</target>       </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.AssemblyBuilder.DefineDynamicModule(System.String)">
          <source>The code example below demonstrates how to create a transient dynamic module using <ph id="ph1">`DefineDynamicModule`</ph>.</source>
          <target state="translated">O exemplo de código a seguir demonstra como criar um módulo dinâmico temporário usando <ph id="ph1">`DefineDynamicModule`</ph>.</target>       </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.AssemblyBuilder.DefineDynamicModule(System.String)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> begins with white space.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> começa com um espaço em branco.</target>       </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.AssemblyBuilder.DefineDynamicModule(System.String)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.AssemblyBuilder.DefineDynamicModule(System.String)">
          <source>The length of <ph id="ph1">&lt;paramref name="name" /&gt;</ph> is zero.</source>
          <target state="translated">O comprimento de <ph id="ph1">&lt;paramref name="name" /&gt;</ph> é zero.</target>       </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.AssemblyBuilder.DefineDynamicModule(System.String)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.AssemblyBuilder.DefineDynamicModule(System.String)">
          <source>The length of <ph id="ph1">&lt;paramref name="name" /&gt;</ph> is greater than or equal to 260.</source>
          <target state="translated">O comprimento de <ph id="ph1">&lt;paramref name="name" /&gt;</ph> é maior ou igual a 260.</target>       </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.AssemblyBuilder.DefineDynamicModule(System.String)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> é <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.AssemblyBuilder.DefineDynamicModule(System.String)">
          <source>The caller does not have the required permission.</source>
          <target state="translated">O chamador não tem a permissão necessária.</target>       </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.AssemblyBuilder.DefineDynamicModule(System.String)">
          <source>The assembly for default symbol writer cannot be loaded.</source>
          <target state="translated">Não é possível carregar o assembly para o gravador de símbolo padrão.</target>       </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.AssemblyBuilder.DefineDynamicModule(System.String)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.AssemblyBuilder.DefineDynamicModule(System.String)">
          <source>The type that implements the default symbol writer interface cannot be found.</source>
          <target state="translated">Não foi possível encontrar o tipo que implementa a interface do gravador de símbolo padrão.</target>       </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.AssemblyBuilder.DefineDynamicModule(System.String)">
          <source>when invoked late-bound through mechanisms such as <ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>.</source>
          <target state="translated">quando invocado com associação tardia por meio de mecanismos como <ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.AssemblyBuilder.DefineDynamicModule(System.String)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph>.</source>
          <target state="translated">Enumeração associada: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.AssemblyBuilder.DefineDynamicModule(System.String,System.Boolean)">
          <source>The name of the dynamic module.</source>
          <target state="translated">O nome do módulo dinâmico.</target>       </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.AssemblyBuilder.DefineDynamicModule(System.String,System.Boolean)">
          <source>Must be less than 260 characters in length.</source>
          <target state="translated">Deve ter menos que 260 caracteres.</target>       </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.AssemblyBuilder.DefineDynamicModule(System.String,System.Boolean)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if symbol information is to be emitted; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> se as informações de símbolo devem ser emitidas; caso contrário, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.AssemblyBuilder.DefineDynamicModule(System.String,System.Boolean)">
          <source>Defines a named transient dynamic module in this assembly and specifies whether symbol information should be emitted.</source>
          <target state="translated">Define o módulo dinâmico transitório nomeado neste assembly e especifica se as informações de símbolo devem ser emitidas.</target>       </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.AssemblyBuilder.DefineDynamicModule(System.String,System.Boolean)">
          <source>A <ph id="ph1">&lt;see cref="T:System.Reflection.Emit.ModuleBuilder" /&gt;</ph> representing the defined dynamic module.</source>
          <target state="translated">Um <ph id="ph1">&lt;see cref="T:System.Reflection.Emit.ModuleBuilder" /&gt;</ph> que representa o módulo dinâmico definido.</target>       </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.AssemblyBuilder.DefineDynamicModule(System.String,System.Boolean)">
          <source>It is an error to define multiple dynamic modules with the same name in an assembly.</source>
          <target state="translated">É um erro ao definir vários módulos dinâmicos com o mesmo nome em um assembly.</target>       </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.AssemblyBuilder.DefineDynamicModule(System.String,System.Boolean)">
          <source>The dynamic module is not saved, even if the parent dynamic assembly was created with <ph id="ph1">&lt;xref:System.Reflection.Emit.AssemblyBuilderAccess.RunAndSave&gt;</ph>.</source>
          <target state="translated">O módulo dinâmico não for salva, mesmo se o assembly dinâmico pai foi criado com <ph id="ph1">&lt;xref:System.Reflection.Emit.AssemblyBuilderAccess.RunAndSave&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.AssemblyBuilder.DefineDynamicModule(System.String,System.Boolean)">
          <source>To suppress optimizations when debugging dynamic modules, apply the <ph id="ph1">&lt;xref:System.Diagnostics.DebuggableAttribute&gt;</ph> attribute to the dynamic assembly before calling <ph id="ph2">&lt;xref:System.Reflection.Emit.AssemblyBuilder.DefineDynamicModule%2A&gt;</ph>.</source>
          <target state="translated">Para suprimir otimizações durante a depuração de módulos dinâmicos, aplicar o <ph id="ph1">&lt;xref:System.Diagnostics.DebuggableAttribute&gt;</ph> de atributo para o assembly dinâmico antes de chamar <ph id="ph2">&lt;xref:System.Reflection.Emit.AssemblyBuilder.DefineDynamicModule%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.AssemblyBuilder.DefineDynamicModule(System.String,System.Boolean)">
          <source>Create an instance of <ph id="ph1">&lt;xref:System.Diagnostics.DebuggableAttribute&gt;</ph> with the <ph id="ph2">&lt;xref:System.Diagnostics.DebuggableAttribute.DebuggingModes.DisableOptimizations&gt;</ph> flag and apply it using the <ph id="ph3">&lt;xref:System.Reflection.Emit.AssemblyBuilder.SetCustomAttribute%2A&gt;</ph> method.</source>
          <target state="translated">Criar uma instância de <ph id="ph1">&lt;xref:System.Diagnostics.DebuggableAttribute&gt;</ph> com o <ph id="ph2">&lt;xref:System.Diagnostics.DebuggableAttribute.DebuggingModes.DisableOptimizations&gt;</ph> sinalizador e aplicá-lo usando o <ph id="ph3">&lt;xref:System.Reflection.Emit.AssemblyBuilder.SetCustomAttribute%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.AssemblyBuilder.DefineDynamicModule(System.String,System.Boolean)">
          <source>The attribute must be applied to the dynamic assembly.</source>
          <target state="translated">O atributo deve ser aplicado ao assembly dinâmico.</target>       </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.AssemblyBuilder.DefineDynamicModule(System.String,System.Boolean)">
          <source>It has no effect if applied to the module.</source>
          <target state="translated">Não tem nenhum efeito se aplicada para o módulo.</target>       </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.AssemblyBuilder.DefineDynamicModule(System.String,System.Boolean)">
          <source>Starting with the <ph id="ph1">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</ph>, this member no longer requires <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> with the <ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType&gt;</ph> flag.</source>
          <target state="translated">Começando com o <ph id="ph1">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</ph>, esse membro não requer mais <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> com o <ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType&gt;</ph> sinalizador.</target>       </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.AssemblyBuilder.DefineDynamicModule(System.String,System.Boolean)">
          <source>(See <bpt id="p1">[</bpt>Security Issues in Reflection Emit<ept id="p1">](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)</ept>.) To use this functionality, your application should target the <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> or later.</source>
          <target state="translated">(Consulte <bpt id="p1">[</bpt>problemas de segurança em reflexão emitir<ept id="p1">](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)</ept>.) Para usar essa funcionalidade, seu aplicativo deve ser direcionado ao <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> ou posterior.</target>       </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.AssemblyBuilder.DefineDynamicModule(System.String,System.Boolean)">
          <source>[Visual Basic, C#]</source>
          <target state="translated">[Visual Basic, C#]</target>       </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.AssemblyBuilder.DefineDynamicModule(System.String,System.Boolean)">
          <source>The code example below demonstrates how to create a transient dynamic module using <ph id="ph1">`DefineDynamicModule`</ph>, suppressing symbol information.</source>
          <target state="translated">O exemplo de código a seguir demonstra como criar um módulo dinâmico temporário usando <ph id="ph1">`DefineDynamicModule`</ph>, suprimindo informações de símbolo.</target>       </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.AssemblyBuilder.DefineDynamicModule(System.String,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> begins with white space.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> começa com um espaço em branco.</target>       </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.AssemblyBuilder.DefineDynamicModule(System.String,System.Boolean)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.AssemblyBuilder.DefineDynamicModule(System.String,System.Boolean)">
          <source>The length of <ph id="ph1">&lt;paramref name="name" /&gt;</ph> is zero.</source>
          <target state="translated">O comprimento de <ph id="ph1">&lt;paramref name="name" /&gt;</ph> é zero.</target>       </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.AssemblyBuilder.DefineDynamicModule(System.String,System.Boolean)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.AssemblyBuilder.DefineDynamicModule(System.String,System.Boolean)">
          <source>The length of <ph id="ph1">&lt;paramref name="name" /&gt;</ph> is greater than or equal to 260.</source>
          <target state="translated">O comprimento de <ph id="ph1">&lt;paramref name="name" /&gt;</ph> é maior ou igual a 260.</target>       </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.AssemblyBuilder.DefineDynamicModule(System.String,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> é <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.AssemblyBuilder.DefineDynamicModule(System.String,System.Boolean)">
          <source>The assembly for default symbol writer cannot be loaded.</source>
          <target state="translated">Não é possível carregar o assembly para o gravador de símbolo padrão.</target>       </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.AssemblyBuilder.DefineDynamicModule(System.String,System.Boolean)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.AssemblyBuilder.DefineDynamicModule(System.String,System.Boolean)">
          <source>The type that implements the default symbol writer interface cannot be found.</source>
          <target state="translated">Não foi possível encontrar o tipo que implementa a interface do gravador de símbolo padrão.</target>       </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.AssemblyBuilder.DefineDynamicModule(System.String,System.Boolean)">
          <source>The caller does not have the required permission.</source>
          <target state="translated">O chamador não tem a permissão necessária.</target>       </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.AssemblyBuilder.DefineDynamicModule(System.String,System.Boolean)">
          <source>when invoked late-bound through mechanisms such as <ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>.</source>
          <target state="translated">quando invocado com associação tardia por meio de mecanismos como <ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="260" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.AssemblyBuilder.DefineDynamicModule(System.String,System.Boolean)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph>.</source>
          <target state="translated">Enumeração associada: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="261" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.AssemblyBuilder.DefineDynamicModule(System.String,System.String)">
          <source>The name of the dynamic module.</source>
          <target state="translated">O nome do módulo dinâmico.</target>       </trans-unit>
        <trans-unit id="262" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.AssemblyBuilder.DefineDynamicModule(System.String,System.String)">
          <source>Must be less than 260 characters in length.</source>
          <target state="translated">Deve ter menos que 260 caracteres.</target>       </trans-unit>
        <trans-unit id="263" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.AssemblyBuilder.DefineDynamicModule(System.String,System.String)">
          <source>The name of the file to which the dynamic module should be saved.</source>
          <target state="translated">O nome do arquivo no qual o módulo dinâmico deve ser salvo.</target>       </trans-unit>
        <trans-unit id="264" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.AssemblyBuilder.DefineDynamicModule(System.String,System.String)">
          <source>Defines a persistable dynamic module with the given name that will be saved to the specified file.</source>
          <target state="translated">Define um módulo dinâmico persistente com o nome fornecido que será salvo no arquivo especificado.</target>       </trans-unit>
        <trans-unit id="265" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.AssemblyBuilder.DefineDynamicModule(System.String,System.String)">
          <source>No symbol information is emitted.</source>
          <target state="translated">Nenhuma informação de símbolo é emitida.</target>       </trans-unit>
        <trans-unit id="266" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.AssemblyBuilder.DefineDynamicModule(System.String,System.String)">
          <source>A <ph id="ph1">&lt;see cref="T:System.Reflection.Emit.ModuleBuilder" /&gt;</ph> object representing the defined dynamic module.</source>
          <target state="translated">Um objeto <ph id="ph1">&lt;see cref="T:System.Reflection.Emit.ModuleBuilder" /&gt;</ph> que representa o módulo dinâmico definido.</target>       </trans-unit>
        <trans-unit id="267" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.AssemblyBuilder.DefineDynamicModule(System.String,System.String)">
          <source>To define a persistable dynamic module, this assembly needs to be created with the <ph id="ph1">&lt;xref:System.Reflection.Emit.AssemblyBuilderAccess.Save&gt;</ph> or the <ph id="ph2">&lt;xref:System.Reflection.Emit.AssemblyBuilderAccess.RunAndSave&gt;</ph> attribute.</source>
          <target state="translated">Para definir um módulo dinâmico persistente, esse assembly precisa ser criado com o <ph id="ph1">&lt;xref:System.Reflection.Emit.AssemblyBuilderAccess.Save&gt;</ph> ou <ph id="ph2">&lt;xref:System.Reflection.Emit.AssemblyBuilderAccess.RunAndSave&gt;</ph> atributo.</target>       </trans-unit>
        <trans-unit id="268" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.AssemblyBuilder.DefineDynamicModule(System.String,System.String)">
          <source>If you want the module to contain the assembly manifest, <ph id="ph1">`name`</ph> should be the same as the name of the assembly (that is, the <ph id="ph2">&lt;xref:System.Reflection.AssemblyName.Name%2A?displayProperty=nameWithType&gt;</ph> property of the <ph id="ph3">&lt;xref:System.Reflection.AssemblyName&gt;</ph> used to create the dynamic assembly) and <ph id="ph4">`fileName`</ph> should be the same as the filename you specify when you save the assembly.</source>
          <target state="translated">Se você quiser que o módulo contém o manifesto do assembly, <ph id="ph1">`name`</ph> deve ser igual ao nome do assembly (ou seja, o <ph id="ph2">&lt;xref:System.Reflection.AssemblyName.Name%2A?displayProperty=nameWithType&gt;</ph> propriedade o <ph id="ph3">&lt;xref:System.Reflection.AssemblyName&gt;</ph> usado para criar o assembly dinâmico) e <ph id="ph4">`fileName`</ph> deve ser o mesmo que o nome de arquivo especificado quando você salvar o assembly.</target>       </trans-unit>
        <trans-unit id="269" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.AssemblyBuilder.DefineDynamicModule(System.String,System.String)">
          <source>In an assembly with only one module, that module should contain the assembly manifest.</source>
          <target state="translated">Em um assembly com apenas um módulo, que o módulo deve conter o manifesto do assembly.</target>       </trans-unit>
        <trans-unit id="270" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.AssemblyBuilder.DefineDynamicModule(System.String,System.String)">
          <source>To suppress optimizations when debugging dynamic modules, apply the <ph id="ph1">&lt;xref:System.Diagnostics.DebuggableAttribute&gt;</ph> attribute to the dynamic assembly before calling <ph id="ph2">&lt;xref:System.Reflection.Emit.AssemblyBuilder.DefineDynamicModule%2A&gt;</ph>.</source>
          <target state="translated">Para suprimir otimizações durante a depuração de módulos dinâmicos, aplicar o <ph id="ph1">&lt;xref:System.Diagnostics.DebuggableAttribute&gt;</ph> de atributo para o assembly dinâmico antes de chamar <ph id="ph2">&lt;xref:System.Reflection.Emit.AssemblyBuilder.DefineDynamicModule%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="271" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.AssemblyBuilder.DefineDynamicModule(System.String,System.String)">
          <source>Create an instance of <ph id="ph1">&lt;xref:System.Diagnostics.DebuggableAttribute&gt;</ph> with the <ph id="ph2">&lt;xref:System.Diagnostics.DebuggableAttribute.DebuggingModes.DisableOptimizations&gt;</ph> flag and apply it using the <ph id="ph3">&lt;xref:System.Reflection.Emit.AssemblyBuilder.SetCustomAttribute%2A&gt;</ph> method.</source>
          <target state="translated">Criar uma instância de <ph id="ph1">&lt;xref:System.Diagnostics.DebuggableAttribute&gt;</ph> com o <ph id="ph2">&lt;xref:System.Diagnostics.DebuggableAttribute.DebuggingModes.DisableOptimizations&gt;</ph> sinalizador e aplicá-lo usando o <ph id="ph3">&lt;xref:System.Reflection.Emit.AssemblyBuilder.SetCustomAttribute%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="272" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.AssemblyBuilder.DefineDynamicModule(System.String,System.String)">
          <source>The attribute must be applied to the dynamic assembly.</source>
          <target state="translated">O atributo deve ser aplicado ao assembly dinâmico.</target>       </trans-unit>
        <trans-unit id="273" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.AssemblyBuilder.DefineDynamicModule(System.String,System.String)">
          <source>It has no effect if applied to the module.</source>
          <target state="translated">Não tem nenhum efeito se aplicada para o módulo.</target>       </trans-unit>
        <trans-unit id="274" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.AssemblyBuilder.DefineDynamicModule(System.String,System.String)">
          <source>Starting with the <ph id="ph1">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</ph>, this member no longer requires <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> with the <ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType&gt;</ph> flag.</source>
          <target state="translated">Começando com o <ph id="ph1">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</ph>, esse membro não requer mais <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> com o <ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType&gt;</ph> sinalizador.</target>       </trans-unit>
        <trans-unit id="275" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.AssemblyBuilder.DefineDynamicModule(System.String,System.String)">
          <source>(See <bpt id="p1">[</bpt>Security Issues in Reflection Emit<ept id="p1">](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)</ept>.) To use this functionality, your application should target the <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> or later.</source>
          <target state="translated">(Consulte <bpt id="p1">[</bpt>problemas de segurança em reflexão emitir<ept id="p1">](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)</ept>.) Para usar essa funcionalidade, seu aplicativo deve ser direcionado ao <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> ou posterior.</target>       </trans-unit>
        <trans-unit id="276" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.AssemblyBuilder.DefineDynamicModule(System.String,System.String)">
          <source>[Visual Basic, C#]</source>
          <target state="translated">[Visual Basic, C#]</target>       </trans-unit>
        <trans-unit id="277" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.AssemblyBuilder.DefineDynamicModule(System.String,System.String)">
          <source>The code example below demonstrates how to create a persistent dynamic module using <ph id="ph1">`DefineDynamicModule`</ph>.</source>
          <target state="translated">O exemplo de código a seguir demonstra como criar um módulo dinâmico persistente usando <ph id="ph1">`DefineDynamicModule`</ph>.</target>       </trans-unit>
        <trans-unit id="278" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.AssemblyBuilder.DefineDynamicModule(System.String,System.String)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> or <ph id="ph2">&lt;paramref name="fileName" /&gt;</ph> is <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> ou <ph id="ph2">&lt;paramref name="fileName" /&gt;</ph> é <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="279" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.AssemblyBuilder.DefineDynamicModule(System.String,System.String)">
          <source>The length of <ph id="ph1">&lt;paramref name="name" /&gt;</ph> or <ph id="ph2">&lt;paramref name="fileName" /&gt;</ph> is zero.</source>
          <target state="translated">O comprimento de <ph id="ph1">&lt;paramref name="name" /&gt;</ph> ou <ph id="ph2">&lt;paramref name="fileName" /&gt;</ph> é zero.</target>       </trans-unit>
        <trans-unit id="280" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.AssemblyBuilder.DefineDynamicModule(System.String,System.String)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="281" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.AssemblyBuilder.DefineDynamicModule(System.String,System.String)">
          <source>The length of <ph id="ph1">&lt;paramref name="name" /&gt;</ph> is greater than or equal to 260.</source>
          <target state="translated">O comprimento de <ph id="ph1">&lt;paramref name="name" /&gt;</ph> é maior ou igual a 260.</target>       </trans-unit>
        <trans-unit id="282" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.AssemblyBuilder.DefineDynamicModule(System.String,System.String)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="283" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.AssemblyBuilder.DefineDynamicModule(System.String,System.String)">
          <source><ph id="ph1">&lt;paramref name="fileName" /&gt;</ph> contains a path specification (a directory component, for example).</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="fileName" /&gt;</ph> contém uma especificação de caminho (um componente de diretório, por exemplo).</target>       </trans-unit>
        <trans-unit id="284" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.AssemblyBuilder.DefineDynamicModule(System.String,System.String)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="285" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.AssemblyBuilder.DefineDynamicModule(System.String,System.String)">
          <source>There is a conflict with the name of another file that belongs to this assembly.</source>
          <target state="translated">Há um conflito com o nome de outro arquivo que pertence a este assembly.</target>       </trans-unit>
        <trans-unit id="286" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.AssemblyBuilder.DefineDynamicModule(System.String,System.String)">
          <source>This assembly has been previously saved.</source>
          <target state="translated">Este assembly foi salvo anteriormente.</target>       </trans-unit>
        <trans-unit id="287" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.AssemblyBuilder.DefineDynamicModule(System.String,System.String)">
          <source>This assembly was called on a dynamic assembly with <ph id="ph1">&lt;see cref="F:System.Reflection.Emit.AssemblyBuilderAccess.Run" /&gt;</ph> attribute.</source>
          <target state="translated">Este assembly foi chamado em um assembly dinâmico com o atributo <ph id="ph1">&lt;see cref="F:System.Reflection.Emit.AssemblyBuilderAccess.Run" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="288" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.AssemblyBuilder.DefineDynamicModule(System.String,System.String)">
          <source>The caller does not have the required permission.</source>
          <target state="translated">O chamador não tem a permissão necessária.</target>       </trans-unit>
        <trans-unit id="289" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.AssemblyBuilder.DefineDynamicModule(System.String,System.String)">
          <source>The assembly for default symbol writer cannot be loaded.</source>
          <target state="translated">Não é possível carregar o assembly para o gravador de símbolo padrão.</target>       </trans-unit>
        <trans-unit id="290" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.AssemblyBuilder.DefineDynamicModule(System.String,System.String)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="291" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.AssemblyBuilder.DefineDynamicModule(System.String,System.String)">
          <source>The type that implements the default symbol writer interface cannot be found.</source>
          <target state="translated">Não foi possível encontrar o tipo que implementa a interface do gravador de símbolo padrão.</target>       </trans-unit>
        <trans-unit id="292" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.AssemblyBuilder.DefineDynamicModule(System.String,System.String)">
          <source>when invoked late-bound through mechanisms such as <ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>.</source>
          <target state="translated">quando invocado com associação tardia por meio de mecanismos como <ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="293" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.AssemblyBuilder.DefineDynamicModule(System.String,System.String)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph>.</source>
          <target state="translated">Enumeração associada: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="294" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.AssemblyBuilder.DefineDynamicModule(System.String,System.String)">
          <source>Write=true or Append=true is needed to save the module</source>
          <target state="translated">Gravar = true ou acrescentar = true é necessária para salvar o módulo</target>       </trans-unit>
        <trans-unit id="295" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.AssemblyBuilder.DefineDynamicModule(System.String,System.String,System.Boolean)">
          <source>The name of the dynamic module.</source>
          <target state="translated">O nome do módulo dinâmico.</target>       </trans-unit>
        <trans-unit id="296" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.AssemblyBuilder.DefineDynamicModule(System.String,System.String,System.Boolean)">
          <source>Must be less than 260 characters in length.</source>
          <target state="translated">Deve ter menos que 260 caracteres.</target>       </trans-unit>
        <trans-unit id="297" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.AssemblyBuilder.DefineDynamicModule(System.String,System.String,System.Boolean)">
          <source>The name of the file to which the dynamic module should be saved.</source>
          <target state="translated">O nome do arquivo no qual o módulo dinâmico deve ser salvo.</target>       </trans-unit>
        <trans-unit id="298" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.AssemblyBuilder.DefineDynamicModule(System.String,System.String,System.Boolean)">
          <source>If <ph id="ph1">&lt;see langword="true" /&gt;</ph>, symbolic information is written using the default symbol writer.</source>
          <target state="translated">Se <ph id="ph1">&lt;see langword="true" /&gt;</ph>, as informações simbólicas serão gravadas usando o gravador de símbolo padrão.</target>       </trans-unit>
        <trans-unit id="299" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.AssemblyBuilder.DefineDynamicModule(System.String,System.String,System.Boolean)">
          <source>Defines a persistable dynamic module, specifying the module name, the name of the file to which the module will be saved, and whether symbol information should be emitted using the default symbol writer.</source>
          <target state="translated">Define um módulo dinâmico persistente, especificando o nome do módulo, o nome do arquivo no qual o módulo será salvo e se as informações de símbolo deverão ser emitidas usando o gravador de símbolo padrão.</target>       </trans-unit>
        <trans-unit id="300" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.AssemblyBuilder.DefineDynamicModule(System.String,System.String,System.Boolean)">
          <source>A <ph id="ph1">&lt;see cref="T:System.Reflection.Emit.ModuleBuilder" /&gt;</ph> object representing the defined dynamic module.</source>
          <target state="translated">Um objeto <ph id="ph1">&lt;see cref="T:System.Reflection.Emit.ModuleBuilder" /&gt;</ph> que representa o módulo dinâmico definido.</target>       </trans-unit>
        <trans-unit id="301" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.AssemblyBuilder.DefineDynamicModule(System.String,System.String,System.Boolean)">
          <source>To define a persistable dynamic module, this assembly needs to be created with the <ph id="ph1">&lt;xref:System.Reflection.Emit.AssemblyBuilderAccess.Save&gt;</ph> or the <ph id="ph2">&lt;xref:System.Reflection.Emit.AssemblyBuilderAccess.RunAndSave&gt;</ph> attribute.</source>
          <target state="translated">Para definir um módulo dinâmico persistente, esse assembly precisa ser criado com o <ph id="ph1">&lt;xref:System.Reflection.Emit.AssemblyBuilderAccess.Save&gt;</ph> ou <ph id="ph2">&lt;xref:System.Reflection.Emit.AssemblyBuilderAccess.RunAndSave&gt;</ph> atributo.</target>       </trans-unit>
        <trans-unit id="302" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.AssemblyBuilder.DefineDynamicModule(System.String,System.String,System.Boolean)">
          <source>If you want the module to contain the assembly manifest, <ph id="ph1">`name`</ph> should be the same as the name of the assembly (that is, the <ph id="ph2">&lt;xref:System.Reflection.AssemblyName.Name%2A?displayProperty=nameWithType&gt;</ph> property of the <ph id="ph3">&lt;xref:System.Reflection.AssemblyName&gt;</ph> used to create the dynamic assembly) and <ph id="ph4">`fileName`</ph> should be the same as the filename you specify when you save the assembly.</source>
          <target state="translated">Se você quiser que o módulo contém o manifesto do assembly, <ph id="ph1">`name`</ph> deve ser igual ao nome do assembly (ou seja, o <ph id="ph2">&lt;xref:System.Reflection.AssemblyName.Name%2A?displayProperty=nameWithType&gt;</ph> propriedade o <ph id="ph3">&lt;xref:System.Reflection.AssemblyName&gt;</ph> usado para criar o assembly dinâmico) e <ph id="ph4">`fileName`</ph> deve ser o mesmo que o nome de arquivo especificado quando você salvar o assembly.</target>       </trans-unit>
        <trans-unit id="303" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.AssemblyBuilder.DefineDynamicModule(System.String,System.String,System.Boolean)">
          <source>In an assembly with only one module, that module should contain the assembly manifest.</source>
          <target state="translated">Em um assembly com apenas um módulo, que o módulo deve conter o manifesto do assembly.</target>       </trans-unit>
        <trans-unit id="304" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.AssemblyBuilder.DefineDynamicModule(System.String,System.String,System.Boolean)">
          <source>To suppress optimizations when debugging dynamic modules, apply the <ph id="ph1">&lt;xref:System.Diagnostics.DebuggableAttribute&gt;</ph> attribute to the dynamic assembly before calling <ph id="ph2">&lt;xref:System.Reflection.Emit.AssemblyBuilder.DefineDynamicModule%2A&gt;</ph>.</source>
          <target state="translated">Para suprimir otimizações durante a depuração de módulos dinâmicos, aplicar o <ph id="ph1">&lt;xref:System.Diagnostics.DebuggableAttribute&gt;</ph> de atributo para o assembly dinâmico antes de chamar <ph id="ph2">&lt;xref:System.Reflection.Emit.AssemblyBuilder.DefineDynamicModule%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="305" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.AssemblyBuilder.DefineDynamicModule(System.String,System.String,System.Boolean)">
          <source>Create an instance of <ph id="ph1">&lt;xref:System.Diagnostics.DebuggableAttribute&gt;</ph> with the <ph id="ph2">&lt;xref:System.Diagnostics.DebuggableAttribute.DebuggingModes.DisableOptimizations&gt;</ph> flag and apply it using the <ph id="ph3">&lt;xref:System.Reflection.Emit.AssemblyBuilder.SetCustomAttribute%2A&gt;</ph> method.</source>
          <target state="translated">Criar uma instância de <ph id="ph1">&lt;xref:System.Diagnostics.DebuggableAttribute&gt;</ph> com o <ph id="ph2">&lt;xref:System.Diagnostics.DebuggableAttribute.DebuggingModes.DisableOptimizations&gt;</ph> sinalizador e aplicá-lo usando o <ph id="ph3">&lt;xref:System.Reflection.Emit.AssemblyBuilder.SetCustomAttribute%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="306" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.AssemblyBuilder.DefineDynamicModule(System.String,System.String,System.Boolean)">
          <source>The attribute must be applied to the dynamic assembly.</source>
          <target state="translated">O atributo deve ser aplicado ao assembly dinâmico.</target>       </trans-unit>
        <trans-unit id="307" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.AssemblyBuilder.DefineDynamicModule(System.String,System.String,System.Boolean)">
          <source>It has no effect if applied to the module.</source>
          <target state="translated">Não tem nenhum efeito se aplicada para o módulo.</target>       </trans-unit>
        <trans-unit id="308" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.AssemblyBuilder.DefineDynamicModule(System.String,System.String,System.Boolean)">
          <source>Starting with the <ph id="ph1">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</ph>, this member no longer requires <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> with the <ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType&gt;</ph> flag.</source>
          <target state="translated">Começando com o <ph id="ph1">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</ph>, esse membro não requer mais <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> com o <ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType&gt;</ph> sinalizador.</target>       </trans-unit>
        <trans-unit id="309" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.AssemblyBuilder.DefineDynamicModule(System.String,System.String,System.Boolean)">
          <source>(See <bpt id="p1">[</bpt>Security Issues in Reflection Emit<ept id="p1">](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)</ept>.) To use this functionality, your application should target the <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> or later.</source>
          <target state="translated">(Consulte <bpt id="p1">[</bpt>problemas de segurança em reflexão emitir<ept id="p1">](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)</ept>.) Para usar essa funcionalidade, seu aplicativo deve ser direcionado ao <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> ou posterior.</target>       </trans-unit>
        <trans-unit id="310" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.AssemblyBuilder.DefineDynamicModule(System.String,System.String,System.Boolean)">
          <source>[Visual Basic, C#]</source>
          <target state="translated">[Visual Basic, C#]</target>       </trans-unit>
        <trans-unit id="311" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.AssemblyBuilder.DefineDynamicModule(System.String,System.String,System.Boolean)">
          <source>The code example below demonstrates how to create a persistent dynamic module with symbol emission using <ph id="ph1">`DefineDynamicModule`</ph>.</source>
          <target state="translated">O exemplo de código a seguir demonstra como criar um módulo dinâmico persistente com o uso de emissão de símbolo <ph id="ph1">`DefineDynamicModule`</ph>.</target>       </trans-unit>
        <trans-unit id="312" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.AssemblyBuilder.DefineDynamicModule(System.String,System.String,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> or <ph id="ph2">&lt;paramref name="fileName" /&gt;</ph> is <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> ou <ph id="ph2">&lt;paramref name="fileName" /&gt;</ph> é <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="313" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.AssemblyBuilder.DefineDynamicModule(System.String,System.String,System.Boolean)">
          <source>The length of <ph id="ph1">&lt;paramref name="name" /&gt;</ph> or <ph id="ph2">&lt;paramref name="fileName" /&gt;</ph> is zero.</source>
          <target state="translated">O comprimento de <ph id="ph1">&lt;paramref name="name" /&gt;</ph> ou <ph id="ph2">&lt;paramref name="fileName" /&gt;</ph> é zero.</target>       </trans-unit>
        <trans-unit id="314" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.AssemblyBuilder.DefineDynamicModule(System.String,System.String,System.Boolean)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="315" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.AssemblyBuilder.DefineDynamicModule(System.String,System.String,System.Boolean)">
          <source>The length of <ph id="ph1">&lt;paramref name="name" /&gt;</ph> is greater than or equal to 260.</source>
          <target state="translated">O comprimento de <ph id="ph1">&lt;paramref name="name" /&gt;</ph> é maior ou igual a 260.</target>       </trans-unit>
        <trans-unit id="316" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.AssemblyBuilder.DefineDynamicModule(System.String,System.String,System.Boolean)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="317" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.AssemblyBuilder.DefineDynamicModule(System.String,System.String,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="fileName" /&gt;</ph> contains a path specification (a directory component, for example).</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="fileName" /&gt;</ph> contém uma especificação de caminho (um componente de diretório, por exemplo).</target>       </trans-unit>
        <trans-unit id="318" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.AssemblyBuilder.DefineDynamicModule(System.String,System.String,System.Boolean)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="319" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.AssemblyBuilder.DefineDynamicModule(System.String,System.String,System.Boolean)">
          <source>There is a conflict with the name of another file that belongs to this assembly.</source>
          <target state="translated">Há um conflito com o nome de outro arquivo que pertence a este assembly.</target>       </trans-unit>
        <trans-unit id="320" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.AssemblyBuilder.DefineDynamicModule(System.String,System.String,System.Boolean)">
          <source>This assembly has been previously saved.</source>
          <target state="translated">Este assembly foi salvo anteriormente.</target>       </trans-unit>
        <trans-unit id="321" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.AssemblyBuilder.DefineDynamicModule(System.String,System.String,System.Boolean)">
          <source>This assembly was called on a dynamic assembly with the <ph id="ph1">&lt;see cref="F:System.Reflection.Emit.AssemblyBuilderAccess.Run" /&gt;</ph> attribute.</source>
          <target state="translated">Este assembly foi chamado em um assembly dinâmico com o atributo <ph id="ph1">&lt;see cref="F:System.Reflection.Emit.AssemblyBuilderAccess.Run" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="322" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.AssemblyBuilder.DefineDynamicModule(System.String,System.String,System.Boolean)">
          <source>The assembly for default symbol writer cannot be loaded.</source>
          <target state="translated">Não é possível carregar o assembly para o gravador de símbolo padrão.</target>       </trans-unit>
        <trans-unit id="323" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.AssemblyBuilder.DefineDynamicModule(System.String,System.String,System.Boolean)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="324" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.AssemblyBuilder.DefineDynamicModule(System.String,System.String,System.Boolean)">
          <source>The type that implements the default symbol writer interface cannot be found.</source>
          <target state="translated">Não foi possível encontrar o tipo que implementa a interface do gravador de símbolo padrão.</target>       </trans-unit>
        <trans-unit id="325" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.AssemblyBuilder.DefineDynamicModule(System.String,System.String,System.Boolean)">
          <source>The caller does not have the required permission.</source>
          <target state="translated">O chamador não tem a permissão necessária.</target>       </trans-unit>
        <trans-unit id="326" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.AssemblyBuilder.DefineDynamicModule(System.String,System.String,System.Boolean)">
          <source>when invoked late-bound through mechanisms such as <ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>.</source>
          <target state="translated">quando invocado com associação tardia por meio de mecanismos como <ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="327" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.AssemblyBuilder.DefineDynamicModule(System.String,System.String,System.Boolean)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph>.</source>
          <target state="translated">Enumeração associada: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="328" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.AssemblyBuilder.DefineDynamicModule(System.String,System.String,System.Boolean)">
          <source>Write=true or Append=true is needed to save this module</source>
          <target state="translated">Gravar = true ou acrescentar = true é necessária para salvar este módulo</target>       </trans-unit>
        <trans-unit id="329" translate="yes" xml:space="preserve" uid="T:System.Reflection.Emit.AssemblyBuilder">
          <source>Defines a standalone managed resource for this assembly.</source>
          <target state="translated">Define um recurso autônomo gerenciado para esse assembly.</target>       </trans-unit>
        <trans-unit id="330" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.AssemblyBuilder.DefineResource(System.String,System.String,System.String)">
          <source>The logical name of the resource.</source>
          <target state="translated">O nome lógico do recurso.</target>       </trans-unit>
        <trans-unit id="331" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.AssemblyBuilder.DefineResource(System.String,System.String,System.String)">
          <source>A textual description of the resource.</source>
          <target state="translated">Uma descrição textual do recurso.</target>       </trans-unit>
        <trans-unit id="332" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.AssemblyBuilder.DefineResource(System.String,System.String,System.String)">
          <source>The physical file name (.resources file) to which the logical name is mapped.</source>
          <target state="translated">O nome do arquivo físico (arquivo .resources) para o qual o nome lógico é mapeado.</target>       </trans-unit>
        <trans-unit id="333" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.AssemblyBuilder.DefineResource(System.String,System.String,System.String)">
          <source>This should not include a path.</source>
          <target state="translated">Não se deve incluir um caminho.</target>       </trans-unit>
        <trans-unit id="334" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.AssemblyBuilder.DefineResource(System.String,System.String,System.String)">
          <source>Defines a standalone managed resource for this assembly with the default public resource attribute.</source>
          <target state="translated">Define um recurso gerenciado autônomo para esse assembly com o atributo de recurso público padrão.</target>       </trans-unit>
        <trans-unit id="335" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.AssemblyBuilder.DefineResource(System.String,System.String,System.String)">
          <source>A <ph id="ph1">&lt;see cref="T:System.Resources.ResourceWriter" /&gt;</ph> object for the specified resource.</source>
          <target state="translated">Um objeto <ph id="ph1">&lt;see cref="T:System.Resources.ResourceWriter" /&gt;</ph> para o recurso especificado.</target>       </trans-unit>
        <trans-unit id="336" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.AssemblyBuilder.DefineResource(System.String,System.String,System.String)">
          <source>Fine grain resources can be added with the returned <ph id="ph1">&lt;xref:System.Resources.ResourceWriter&gt;</ph> by calling <ph id="ph2">&lt;xref:System.Resources.ResourceWriter.AddResource%2A&gt;</ph>.</source>
          <target state="translated">Recursos granulares podem ser adicionados com retornado <ph id="ph1">&lt;xref:System.Resources.ResourceWriter&gt;</ph> chamando <ph id="ph2">&lt;xref:System.Resources.ResourceWriter.AddResource%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="337" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.AssemblyBuilder.DefineResource(System.String,System.String,System.String)">
          <source><ph id="ph1">`fileName`</ph> should not be the same as that of any other persistable module, stand-alone managed resource, or the stand-alone manifest file.</source>
          <target state="translated"><ph id="ph1">`fileName`</ph> não deve ser o mesmo de outro módulo persistente, recurso gerenciado autônomo ou o arquivo de manifesto autônomo.</target>       </trans-unit>
        <trans-unit id="338" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.AssemblyBuilder.DefineResource(System.String,System.String,System.String)">
          <source>The runtime calls the <ph id="ph1">&lt;xref:System.Resources.ResourceWriter.Close%2A&gt;</ph> method when the dynamic assembly is saved.</source>
          <target state="translated">O tempo de execução chama o <ph id="ph1">&lt;xref:System.Resources.ResourceWriter.Close%2A&gt;</ph> método quando o assembly dinâmico é salvo.</target>       </trans-unit>
        <trans-unit id="339" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.AssemblyBuilder.DefineResource(System.String,System.String,System.String)">
          <source>Starting with the <ph id="ph1">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</ph>, this member no longer requires <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> with the <ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType&gt;</ph> flag.</source>
          <target state="translated">Começando com o <ph id="ph1">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</ph>, esse membro não requer mais <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> com o <ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType&gt;</ph> sinalizador.</target>       </trans-unit>
        <trans-unit id="340" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.AssemblyBuilder.DefineResource(System.String,System.String,System.String)">
          <source>(See <bpt id="p1">[</bpt>Security Issues in Reflection Emit<ept id="p1">](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)</ept>.) To use this functionality, your application should target the <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> or later.</source>
          <target state="translated">(Consulte <bpt id="p1">[</bpt>problemas de segurança em reflexão emitir<ept id="p1">](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)</ept>.) Para usar essa funcionalidade, seu aplicativo deve ser direcionado ao <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> ou posterior.</target>       </trans-unit>
        <trans-unit id="341" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.AssemblyBuilder.DefineResource(System.String,System.String,System.String)">
          <source>The following example uses the <ph id="ph1">&lt;xref:System.Reflection.Emit.AssemblyBuilder.DefineResource%2A&gt;</ph> method to get a resource writer.</source>
          <target state="translated">O exemplo a seguir usa o <ph id="ph1">&lt;xref:System.Reflection.Emit.AssemblyBuilder.DefineResource%2A&gt;</ph> método para obter um gravador de recurso.</target>       </trans-unit>
        <trans-unit id="342" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.AssemblyBuilder.DefineResource(System.String,System.String,System.String)">
          <source>The example uses the resource writer to add three resource strings.</source>
          <target state="translated">O exemplo usa o gravador de recurso para adicionar três cadeias de caracteres de recurso.</target>       </trans-unit>
        <trans-unit id="343" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.AssemblyBuilder.DefineResource(System.String,System.String,System.String)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> has been previously defined.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> foi definido anteriormente.</target>       </trans-unit>
        <trans-unit id="344" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.AssemblyBuilder.DefineResource(System.String,System.String,System.String)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="345" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.AssemblyBuilder.DefineResource(System.String,System.String,System.String)">
          <source>There is another file in the assembly named <ph id="ph1">&lt;paramref name="fileName" /&gt;</ph>.</source>
          <target state="translated">Há outro arquivo no assembly chamado <ph id="ph1">&lt;paramref name="fileName" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="346" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.AssemblyBuilder.DefineResource(System.String,System.String,System.String)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="347" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.AssemblyBuilder.DefineResource(System.String,System.String,System.String)">
          <source>The length of <ph id="ph1">&lt;paramref name="name" /&gt;</ph> is zero.</source>
          <target state="translated">O comprimento de <ph id="ph1">&lt;paramref name="name" /&gt;</ph> é zero.</target>       </trans-unit>
        <trans-unit id="348" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.AssemblyBuilder.DefineResource(System.String,System.String,System.String)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="349" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.AssemblyBuilder.DefineResource(System.String,System.String,System.String)">
          <source>The length of <ph id="ph1">&lt;paramref name="fileName" /&gt;</ph> is zero.</source>
          <target state="translated">O comprimento de <ph id="ph1">&lt;paramref name="fileName" /&gt;</ph> é zero.</target>       </trans-unit>
        <trans-unit id="350" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.AssemblyBuilder.DefineResource(System.String,System.String,System.String)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="351" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.AssemblyBuilder.DefineResource(System.String,System.String,System.String)">
          <source><ph id="ph1">&lt;paramref name="fileName" /&gt;</ph> includes a path.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="fileName" /&gt;</ph> inclui um caminho.</target>       </trans-unit>
        <trans-unit id="352" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.AssemblyBuilder.DefineResource(System.String,System.String,System.String)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> or <ph id="ph2">&lt;paramref name="fileName" /&gt;</ph> is <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> ou <ph id="ph2">&lt;paramref name="fileName" /&gt;</ph> é <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="353" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.AssemblyBuilder.DefineResource(System.String,System.String,System.String)">
          <source>The caller does not have the required permission.</source>
          <target state="translated">O chamador não tem a permissão necessária.</target>       </trans-unit>
        <trans-unit id="354" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.AssemblyBuilder.DefineResource(System.String,System.String,System.String)">
          <source>when invoked late-bound through mechanisms such as <ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>.</source>
          <target state="translated">quando invocado com associação tardia por meio de mecanismos como <ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="355" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.AssemblyBuilder.DefineResource(System.String,System.String,System.String)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph>.</source>
          <target state="translated">Enumeração associada: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="356" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.AssemblyBuilder.DefineResource(System.String,System.String,System.String)">
          <source>Write=true or Append=true</source>
          <target state="translated">Gravar = true ou acrescentar = true</target>       </trans-unit>
        <trans-unit id="357" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.AssemblyBuilder.DefineResource(System.String,System.String,System.String,System.Reflection.ResourceAttributes)">
          <source>The logical name of the resource.</source>
          <target state="translated">O nome lógico do recurso.</target>       </trans-unit>
        <trans-unit id="358" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.AssemblyBuilder.DefineResource(System.String,System.String,System.String,System.Reflection.ResourceAttributes)">
          <source>A textual description of the resource.</source>
          <target state="translated">Uma descrição textual do recurso.</target>       </trans-unit>
        <trans-unit id="359" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.AssemblyBuilder.DefineResource(System.String,System.String,System.String,System.Reflection.ResourceAttributes)">
          <source>The physical file name (.resources file) to which the logical name is mapped.</source>
          <target state="translated">O nome do arquivo físico (arquivo .resources) para o qual o nome lógico é mapeado.</target>       </trans-unit>
        <trans-unit id="360" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.AssemblyBuilder.DefineResource(System.String,System.String,System.String,System.Reflection.ResourceAttributes)">
          <source>This should not include a path.</source>
          <target state="translated">Não se deve incluir um caminho.</target>       </trans-unit>
        <trans-unit id="361" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.AssemblyBuilder.DefineResource(System.String,System.String,System.String,System.Reflection.ResourceAttributes)">
          <source>The resource attributes.</source>
          <target state="translated">Os atributos de recursos.</target>       </trans-unit>
        <trans-unit id="362" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.AssemblyBuilder.DefineResource(System.String,System.String,System.String,System.Reflection.ResourceAttributes)">
          <source>Defines a standalone managed resource for this assembly.</source>
          <target state="translated">Define um recurso autônomo gerenciado para esse assembly.</target>       </trans-unit>
        <trans-unit id="363" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.AssemblyBuilder.DefineResource(System.String,System.String,System.String,System.Reflection.ResourceAttributes)">
          <source>Attributes can be specified for the managed resource.</source>
          <target state="translated">Atributos podem ser especificados para o recurso gerenciado.</target>       </trans-unit>
        <trans-unit id="364" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.AssemblyBuilder.DefineResource(System.String,System.String,System.String,System.Reflection.ResourceAttributes)">
          <source>A <ph id="ph1">&lt;see cref="T:System.Resources.ResourceWriter" /&gt;</ph> object for the specified resource.</source>
          <target state="translated">Um objeto <ph id="ph1">&lt;see cref="T:System.Resources.ResourceWriter" /&gt;</ph> para o recurso especificado.</target>       </trans-unit>
        <trans-unit id="365" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.AssemblyBuilder.DefineResource(System.String,System.String,System.String,System.Reflection.ResourceAttributes)">
          <source>Fine-grain resources can be added with the returned <ph id="ph1">&lt;xref:System.Resources.ResourceWriter&gt;</ph> by calling <ph id="ph2">&lt;xref:System.Resources.ResourceWriter.AddResource%2A&gt;</ph>.</source>
          <target state="translated">Recursos de granularidade fina podem ser adicionados com retornado <ph id="ph1">&lt;xref:System.Resources.ResourceWriter&gt;</ph> chamando <ph id="ph2">&lt;xref:System.Resources.ResourceWriter.AddResource%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="366" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.AssemblyBuilder.DefineResource(System.String,System.String,System.String,System.Reflection.ResourceAttributes)">
          <source><ph id="ph1">`fileName`</ph> should not be the same as that of any other persistable module, standalone managed resource, or the standalone manifest file.</source>
          <target state="translated"><ph id="ph1">`fileName`</ph> não deve ser o mesmo de outro módulo persistente, recurso autônomo gerenciado ou o arquivo de manifesto autônomo.</target>       </trans-unit>
        <trans-unit id="367" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.AssemblyBuilder.DefineResource(System.String,System.String,System.String,System.Reflection.ResourceAttributes)">
          <source>The runtime calls the <ph id="ph1">&lt;xref:System.Resources.ResourceWriter.Close%2A&gt;</ph> method when the dynamic assembly is saved.</source>
          <target state="translated">O tempo de execução chama o <ph id="ph1">&lt;xref:System.Resources.ResourceWriter.Close%2A&gt;</ph> método quando o assembly dinâmico é salvo.</target>       </trans-unit>
        <trans-unit id="368" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.AssemblyBuilder.DefineResource(System.String,System.String,System.String,System.Reflection.ResourceAttributes)">
          <source>Starting with the <ph id="ph1">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</ph>, this member no longer requires <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> with the <ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType&gt;</ph> flag.</source>
          <target state="translated">Começando com o <ph id="ph1">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</ph>, esse membro não requer mais <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> com o <ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType&gt;</ph> sinalizador.</target>       </trans-unit>
        <trans-unit id="369" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.AssemblyBuilder.DefineResource(System.String,System.String,System.String,System.Reflection.ResourceAttributes)">
          <source>(See <bpt id="p1">[</bpt>Security Issues in Reflection Emit<ept id="p1">](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)</ept>.) To use this functionality, your application should target the <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> or later.</source>
          <target state="translated">(Consulte <bpt id="p1">[</bpt>problemas de segurança em reflexão emitir<ept id="p1">](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)</ept>.) Para usar essa funcionalidade, seu aplicativo deve ser direcionado ao <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> ou posterior.</target>       </trans-unit>
        <trans-unit id="370" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.AssemblyBuilder.DefineResource(System.String,System.String,System.String,System.Reflection.ResourceAttributes)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> has been previously defined or if there is another file in the assembly named <ph id="ph2">&lt;paramref name="fileName" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> foi definido anteriormente ou se há outro arquivo no assembly chamado <ph id="ph2">&lt;paramref name="fileName" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="371" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.AssemblyBuilder.DefineResource(System.String,System.String,System.String,System.Reflection.ResourceAttributes)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="372" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.AssemblyBuilder.DefineResource(System.String,System.String,System.String,System.Reflection.ResourceAttributes)">
          <source>The length of <ph id="ph1">&lt;paramref name="name" /&gt;</ph> is zero.</source>
          <target state="translated">O comprimento de <ph id="ph1">&lt;paramref name="name" /&gt;</ph> é zero.</target>       </trans-unit>
        <trans-unit id="373" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.AssemblyBuilder.DefineResource(System.String,System.String,System.String,System.Reflection.ResourceAttributes)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="374" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.AssemblyBuilder.DefineResource(System.String,System.String,System.String,System.Reflection.ResourceAttributes)">
          <source>The length of <ph id="ph1">&lt;paramref name="fileName" /&gt;</ph> is zero.</source>
          <target state="translated">O comprimento de <ph id="ph1">&lt;paramref name="fileName" /&gt;</ph> é zero.</target>       </trans-unit>
        <trans-unit id="375" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.AssemblyBuilder.DefineResource(System.String,System.String,System.String,System.Reflection.ResourceAttributes)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="376" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.AssemblyBuilder.DefineResource(System.String,System.String,System.String,System.Reflection.ResourceAttributes)">
          <source><ph id="ph1">&lt;paramref name="fileName" /&gt;</ph> includes a path.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="fileName" /&gt;</ph> inclui um caminho.</target>       </trans-unit>
        <trans-unit id="377" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.AssemblyBuilder.DefineResource(System.String,System.String,System.String,System.Reflection.ResourceAttributes)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> or <ph id="ph2">&lt;paramref name="fileName" /&gt;</ph> is <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> ou <ph id="ph2">&lt;paramref name="fileName" /&gt;</ph> é <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="378" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.AssemblyBuilder.DefineResource(System.String,System.String,System.String,System.Reflection.ResourceAttributes)">
          <source>The caller does not have the required permission.</source>
          <target state="translated">O chamador não tem a permissão necessária.</target>       </trans-unit>
        <trans-unit id="379" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.AssemblyBuilder.DefineResource(System.String,System.String,System.String,System.Reflection.ResourceAttributes)">
          <source>when invoked late-bound through mechanisms such as <ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>.</source>
          <target state="translated">quando invocado com associação tardia por meio de mecanismos como <ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="380" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.AssemblyBuilder.DefineResource(System.String,System.String,System.String,System.Reflection.ResourceAttributes)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph>.</source>
          <target state="translated">Enumeração associada: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="381" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.AssemblyBuilder.DefineResource(System.String,System.String,System.String,System.Reflection.ResourceAttributes)">
          <source>Write=true or Append=true</source>
          <target state="translated">Gravar = true ou acrescentar = true</target>       </trans-unit>
        <trans-unit id="382" translate="yes" xml:space="preserve" uid="T:System.Reflection.Emit.AssemblyBuilder">
          <source>Defines an unmanaged resource for this assembly.</source>
          <target state="translated">Define um recurso não gerenciado para este assembly.</target>       </trans-unit>
        <trans-unit id="383" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.AssemblyBuilder.DefineUnmanagedResource(System.Byte[])">
          <source>The opaque blob of bytes representing the unmanaged resource.</source>
          <target state="translated">O blob de bytes opaco que representa o recurso não gerenciado.</target>       </trans-unit>
        <trans-unit id="384" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.AssemblyBuilder.DefineUnmanagedResource(System.Byte[])">
          <source>Defines an unmanaged resource for this assembly as an opaque blob of bytes.</source>
          <target state="translated">Define um recurso não gerenciado para este assembly como um blob de bytes opaco.</target>       </trans-unit>
        <trans-unit id="385" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.AssemblyBuilder.DefineUnmanagedResource(System.Byte[])">
          <source>An assembly can be associated with only one unmanaged resource.</source>
          <target state="translated">Um assembly pode ser associado a apenas um recurso não gerenciado.</target>       </trans-unit>
        <trans-unit id="386" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.AssemblyBuilder.DefineUnmanagedResource(System.Byte[])">
          <source>This means that calling <ph id="ph1">&lt;xref:System.Reflection.Emit.AssemblyBuilder.DefineVersionInfoResource%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.Reflection.Emit.AssemblyBuilder.DefineUnmanagedResource%2A&gt;</ph> after either one of the methods was called previously will throw the System.ArgumentException being throw.</source>
          <target state="translated">Isso significa que a chamada <ph id="ph1">&lt;xref:System.Reflection.Emit.AssemblyBuilder.DefineVersionInfoResource%2A&gt;</ph> ou <ph id="ph2">&lt;xref:System.Reflection.Emit.AssemblyBuilder.DefineUnmanagedResource%2A&gt;</ph> após um um dos métodos foi chamado anteriormente lançará a System. ArgumentException sendo throw.</target>       </trans-unit>
        <trans-unit id="387" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.AssemblyBuilder.DefineUnmanagedResource(System.Byte[])">
          <source>Multiple unmanaged resources need to be merged with a tool such as the Microsoft ResMerge utility (not supplied with the common language runtime).</source>
          <target state="translated">Vários recursos não gerenciados precisam ser mesclada com uma ferramenta como o utilitário Microsoft ResMerge (não é fornecido com o common language runtime).</target>       </trans-unit>
        <trans-unit id="388" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.AssemblyBuilder.DefineUnmanagedResource(System.Byte[])">
          <source>The following code sample creates and attaches an array of bytes representing an unmanaged resource to a dynamic assembly, using <ph id="ph1">`DefineUnmanagedResource`</ph>.</source>
          <target state="translated">O exemplo de código a seguir cria e anexa uma matriz de bytes que representa um recurso não gerenciado para um assembly dinâmico, usando <ph id="ph1">`DefineUnmanagedResource`</ph>.</target>       </trans-unit>
        <trans-unit id="389" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.AssemblyBuilder.DefineUnmanagedResource(System.Byte[])">
          <source>An unmanaged resource was previously defined.</source>
          <target state="translated">Um recurso não gerenciado foi definido anteriormente.</target>       </trans-unit>
        <trans-unit id="390" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.AssemblyBuilder.DefineUnmanagedResource(System.Byte[])">
          <source><ph id="ph1">&lt;paramref name="resource" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="resource" /&gt;</ph> é <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="391" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.AssemblyBuilder.DefineUnmanagedResource(System.Byte[])">
          <source>The caller does not have the required permission.</source>
          <target state="translated">O chamador não tem a permissão necessária.</target>       </trans-unit>
        <trans-unit id="392" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.AssemblyBuilder.DefineUnmanagedResource(System.Byte[])">
          <source>when invoked late-bound through mechanisms such as <ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>.</source>
          <target state="translated">quando invocado com associação tardia por meio de mecanismos como <ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="393" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.AssemblyBuilder.DefineUnmanagedResource(System.Byte[])">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph>.</source>
          <target state="translated">Enumeração associada: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="394" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.AssemblyBuilder.DefineUnmanagedResource(System.String)">
          <source>The name of the resource file.</source>
          <target state="translated">O nome do arquivo de recurso.</target>       </trans-unit>
        <trans-unit id="395" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.AssemblyBuilder.DefineUnmanagedResource(System.String)">
          <source>Defines an unmanaged resource file for this assembly given the name of the resource file.</source>
          <target state="translated">Define um arquivo de recurso não gerenciado para este assembly, considerando o nome do arquivo de recurso.</target>       </trans-unit>
        <trans-unit id="396" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.AssemblyBuilder.DefineUnmanagedResource(System.String)">
          <source>An assembly can be associated with only one unmanaged resource.</source>
          <target state="translated">Um assembly pode ser associado a apenas um recurso não gerenciado.</target>       </trans-unit>
        <trans-unit id="397" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.AssemblyBuilder.DefineUnmanagedResource(System.String)">
          <source>This means that calling <ph id="ph1">&lt;xref:System.Reflection.Emit.AssemblyBuilder.DefineVersionInfoResource%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.Reflection.Emit.AssemblyBuilder.DefineUnmanagedResource%2A&gt;</ph> after either one of the methods was called previously will throw the System.ArgumentException.</source>
          <target state="translated">Isso significa que a chamada <ph id="ph1">&lt;xref:System.Reflection.Emit.AssemblyBuilder.DefineVersionInfoResource%2A&gt;</ph> ou <ph id="ph2">&lt;xref:System.Reflection.Emit.AssemblyBuilder.DefineUnmanagedResource%2A&gt;</ph> após um um dos métodos foi chamado anteriormente lançará a System. ArgumentException.</target>       </trans-unit>
        <trans-unit id="398" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.AssemblyBuilder.DefineUnmanagedResource(System.String)">
          <source>Multiple unmanaged resources need to be merged with a tool such as the Microsoft ResMerge utility (not supplied with the common language runtime).</source>
          <target state="translated">Vários recursos não gerenciados precisam ser mesclada com uma ferramenta como o utilitário Microsoft ResMerge (não é fornecido com o common language runtime).</target>       </trans-unit>
        <trans-unit id="399" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.AssemblyBuilder.DefineUnmanagedResource(System.String)">
          <source>Starting with the <ph id="ph1">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</ph>, this member no longer requires <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> with the <ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType&gt;</ph> flag.</source>
          <target state="translated">Começando com o <ph id="ph1">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</ph>, esse membro não requer mais <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> com o <ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType&gt;</ph> sinalizador.</target>       </trans-unit>
        <trans-unit id="400" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.AssemblyBuilder.DefineUnmanagedResource(System.String)">
          <source>(See <bpt id="p1">[</bpt>Security Issues in Reflection Emit<ept id="p1">](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)</ept>.) To use this functionality, your application should target the <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> or later.</source>
          <target state="translated">(Consulte <bpt id="p1">[</bpt>problemas de segurança em reflexão emitir<ept id="p1">](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)</ept>.) Para usar essa funcionalidade, seu aplicativo deve ser direcionado ao <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> ou posterior.</target>       </trans-unit>
        <trans-unit id="401" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.AssemblyBuilder.DefineUnmanagedResource(System.String)">
          <source>The example below demonstrates a call to <ph id="ph1">`DefineUnmanagedResource`</ph>, passing an external resource file.</source>
          <target state="translated">O exemplo a seguir demonstra uma chamada para <ph id="ph1">`DefineUnmanagedResource`</ph>, passando um arquivo de recursos externos.</target>       </trans-unit>
        <trans-unit id="402" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.AssemblyBuilder.DefineUnmanagedResource(System.String)">
          <source>An unmanaged resource was previously defined.</source>
          <target state="translated">Um recurso não gerenciado foi definido anteriormente.</target>       </trans-unit>
        <trans-unit id="403" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.AssemblyBuilder.DefineUnmanagedResource(System.String)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="404" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.AssemblyBuilder.DefineUnmanagedResource(System.String)">
          <source>The file <ph id="ph1">&lt;paramref name="resourceFileName" /&gt;</ph> is not readable.</source>
          <target state="translated">O arquivo <ph id="ph1">&lt;paramref name="resourceFileName" /&gt;</ph> não é legível.</target>       </trans-unit>
        <trans-unit id="405" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.AssemblyBuilder.DefineUnmanagedResource(System.String)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="406" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.AssemblyBuilder.DefineUnmanagedResource(System.String)">
          <source><ph id="ph1">&lt;paramref name="resourceFileName" /&gt;</ph> is the empty string ("").</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="resourceFileName" /&gt;</ph> é a cadeia de caracteres vazia ("").</target>       </trans-unit>
        <trans-unit id="407" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.AssemblyBuilder.DefineUnmanagedResource(System.String)">
          <source><ph id="ph1">&lt;paramref name="resourceFileName" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="resourceFileName" /&gt;</ph> é <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="408" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.AssemblyBuilder.DefineUnmanagedResource(System.String)">
          <source><ph id="ph1">&lt;paramref name="resourceFileName" /&gt;</ph> is not found.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="resourceFileName" /&gt;</ph> não foi encontrado.</target>       </trans-unit>
        <trans-unit id="409" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.AssemblyBuilder.DefineUnmanagedResource(System.String)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="410" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.AssemblyBuilder.DefineUnmanagedResource(System.String)">
          <source><ph id="ph1">&lt;paramref name="resourceFileName" /&gt;</ph> is a directory.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="resourceFileName" /&gt;</ph> é um diretório.</target>       </trans-unit>
        <trans-unit id="411" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.AssemblyBuilder.DefineUnmanagedResource(System.String)">
          <source>The caller does not have the required permission.</source>
          <target state="translated">O chamador não tem a permissão necessária.</target>       </trans-unit>
        <trans-unit id="412" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.AssemblyBuilder.DefineUnmanagedResource(System.String)">
          <source>when invoked late-bound through mechanisms such as <ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>.</source>
          <target state="translated">quando invocado com associação tardia por meio de mecanismos como <ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="413" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.AssemblyBuilder.DefineUnmanagedResource(System.String)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph>.</source>
          <target state="translated">Enumeração associada: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="414" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.AssemblyBuilder.DefineUnmanagedResource(System.String)">
          <source>The FileIOPermissionAccess.Read permission is needed to access the resource file <ph id="ph1">&lt;paramref name="resourceFileName" /&gt;</ph>.</source>
          <target state="translated">A permissão de FileIOPermissionAccess.Read é necessária para acessar o arquivo de recurso <ph id="ph1">&lt;paramref name="resourceFileName" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="415" translate="yes" xml:space="preserve" uid="T:System.Reflection.Emit.AssemblyBuilder">
          <source>Defines an unmanaged version information resource for this assembly.</source>
          <target state="translated">Define um recurso de informações de versão não gerenciada para este assembly.</target>       </trans-unit>
        <trans-unit id="416" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.AssemblyBuilder.DefineVersionInfoResource">
          <source>Defines an unmanaged version information resource using the information specified in the assembly's AssemblyName object and the assembly's custom attributes.</source>
          <target state="translated">Define um recurso de informações de versão não gerenciada usando as informações especificadas no objeto AssemblyName do assembly e nos atributos personalizados do assembly.</target>       </trans-unit>
        <trans-unit id="417" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.AssemblyBuilder.DefineVersionInfoResource">
          <source>An assembly can be associated with only one unmanaged resource.</source>
          <target state="translated">Um assembly pode ser associado a apenas um recurso não gerenciado.</target>       </trans-unit>
        <trans-unit id="418" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.AssemblyBuilder.DefineVersionInfoResource">
          <source>This means that calling <ph id="ph1">&lt;xref:System.Reflection.Emit.AssemblyBuilder.DefineVersionInfoResource%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.Reflection.Emit.AssemblyBuilder.DefineUnmanagedResource%2A&gt;</ph> after either one of the methods was called previously will throw the System.ArgumentException.</source>
          <target state="translated">Isso significa que a chamada <ph id="ph1">&lt;xref:System.Reflection.Emit.AssemblyBuilder.DefineVersionInfoResource%2A&gt;</ph> ou <ph id="ph2">&lt;xref:System.Reflection.Emit.AssemblyBuilder.DefineUnmanagedResource%2A&gt;</ph> após um um dos métodos foi chamado anteriormente lançará a System. ArgumentException.</target>       </trans-unit>
        <trans-unit id="419" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.AssemblyBuilder.DefineVersionInfoResource">
          <source>Multiple unmanaged resources need to be merged with a tool such as the Microsoft ResMerge utility (not supplied with the common language runtime SDK).</source>
          <target state="translated">Vários recursos não gerenciados precisam ser mesclada com uma ferramenta como o utilitário Microsoft ResMerge (não é fornecido com o SDK do common language runtime).</target>       </trans-unit>
        <trans-unit id="420" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.AssemblyBuilder.DefineVersionInfoResource">
          <source>Empty argument strings get written as a single space.</source>
          <target state="translated">Cadeias de caracteres de argumentos vazia ser gravadas como um único espaço.</target>       </trans-unit>
        <trans-unit id="421" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.AssemblyBuilder.DefineVersionInfoResource">
          <source>Spaces are substituted for null characters in the argument strings.</source>
          <target state="translated">Espaços são substituídos por caracteres nulos em cadeias de caracteres da argumento.</target>       </trans-unit>
        <trans-unit id="422" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.AssemblyBuilder.DefineVersionInfoResource">
          <source>The information is inferred from the <ph id="ph1">`AssemblyName`</ph> object used to define this dynamic assembly.</source>
          <target state="translated">As informações são inferidas a partir de <ph id="ph1">`AssemblyName`</ph> objeto usado para definir esse assembly dinâmico.</target>       </trans-unit>
        <trans-unit id="423" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.AssemblyBuilder.DefineVersionInfoResource">
          <source>This assembly's custom attributes override information specified in the <ph id="ph1">`AssemblyName`</ph> object.</source>
          <target state="translated">Atributos personalizados deste assembly substituam informações especificadas no <ph id="ph1">`AssemblyName`</ph> objeto.</target>       </trans-unit>
        <trans-unit id="424" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.AssemblyBuilder.DefineVersionInfoResource">
          <source>Starting with the <ph id="ph1">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</ph>, this member no longer requires <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> with the <ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType&gt;</ph> flag.</source>
          <target state="translated">Começando com o <ph id="ph1">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</ph>, esse membro não requer mais <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> com o <ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType&gt;</ph> sinalizador.</target>       </trans-unit>
        <trans-unit id="425" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.AssemblyBuilder.DefineVersionInfoResource">
          <source>(See <bpt id="p1">[</bpt>Security Issues in Reflection Emit<ept id="p1">](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)</ept>.) To use this functionality, your application should target the <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> or later.</source>
          <target state="translated">(Consulte <bpt id="p1">[</bpt>problemas de segurança em reflexão emitir<ept id="p1">](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)</ept>.) Para usar essa funcionalidade, seu aplicativo deve ser direcionado ao <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> ou posterior.</target>       </trans-unit>
        <trans-unit id="426" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.AssemblyBuilder.DefineVersionInfoResource">
          <source>The example below illustrates the usage of <ph id="ph1">`DefineVersionInfoResource`</ph>.</source>
          <target state="translated">O exemplo a seguir ilustra o uso de <ph id="ph1">`DefineVersionInfoResource`</ph>.</target>       </trans-unit>
        <trans-unit id="427" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.AssemblyBuilder.DefineVersionInfoResource">
          <source>An unmanaged version information resource was previously defined.</source>
          <target state="translated">Um recurso de informações de versão não gerenciada foi definido anteriormente.</target>       </trans-unit>
        <trans-unit id="428" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.AssemblyBuilder.DefineVersionInfoResource">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="429" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.AssemblyBuilder.DefineVersionInfoResource">
          <source>The unmanaged version information is too large to persist.</source>
          <target state="translated">As informações de versão não gerenciadas são muito grandes para serem persistidas.</target>       </trans-unit>
        <trans-unit id="430" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.AssemblyBuilder.DefineVersionInfoResource">
          <source>The caller does not have the required permission.</source>
          <target state="translated">O chamador não tem a permissão necessária.</target>       </trans-unit>
        <trans-unit id="431" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.AssemblyBuilder.DefineVersionInfoResource">
          <source>when invoked late-bound through mechanisms such as <ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>.</source>
          <target state="translated">quando invocado com associação tardia por meio de mecanismos como <ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="432" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.AssemblyBuilder.DefineVersionInfoResource">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph>.</source>
          <target state="translated">Enumeração associada: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="433" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.AssemblyBuilder.DefineVersionInfoResource(System.String,System.String,System.String,System.String,System.String)">
          <source>The name of the product with which this assembly is distributed.</source>
          <target state="translated">O nome do produto com o qual este assembly é distribuído.</target>       </trans-unit>
        <trans-unit id="434" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.AssemblyBuilder.DefineVersionInfoResource(System.String,System.String,System.String,System.String,System.String)">
          <source>The version of the product with which this assembly is distributed.</source>
          <target state="translated">A versão do produto com o qual este assembly é distribuído.</target>       </trans-unit>
        <trans-unit id="435" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.AssemblyBuilder.DefineVersionInfoResource(System.String,System.String,System.String,System.String,System.String)">
          <source>The name of the company that produced this assembly.</source>
          <target state="translated">O nome da empresa que produziu este assembly.</target>       </trans-unit>
        <trans-unit id="436" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.AssemblyBuilder.DefineVersionInfoResource(System.String,System.String,System.String,System.String,System.String)">
          <source>Describes all copyright notices, trademarks, and registered trademarks that apply to this assembly.</source>
          <target state="translated">Descreve todos os avisos de direitos autorais, marcas e marcas registradas que se aplicam a este assembly.</target>       </trans-unit>
        <trans-unit id="437" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.AssemblyBuilder.DefineVersionInfoResource(System.String,System.String,System.String,System.String,System.String)">
          <source>This should include the full text of all notices, legal symbols, copyright dates, trademark numbers, and so on.</source>
          <target state="translated">Isso deve incluir o texto completo de todos os avisos, símbolos legais, datas de direitos autorais, números de marca e assim por diante.</target>       </trans-unit>
        <trans-unit id="438" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.AssemblyBuilder.DefineVersionInfoResource(System.String,System.String,System.String,System.String,System.String)">
          <source>In English, this string should be in the format "Copyright Microsoft Corp. 1990-2001".</source>
          <target state="translated">Em inglês, essa cadeia de caracteres deve estar no formato "Copyright Microsoft Corp. 1990-2001".</target>       </trans-unit>
        <trans-unit id="439" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.AssemblyBuilder.DefineVersionInfoResource(System.String,System.String,System.String,System.String,System.String)">
          <source>Describes all trademarks and registered trademarks that apply to this assembly.</source>
          <target state="translated">Descreve todas as marcas e marcas registradas que se aplicam a este assembly.</target>       </trans-unit>
        <trans-unit id="440" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.AssemblyBuilder.DefineVersionInfoResource(System.String,System.String,System.String,System.String,System.String)">
          <source>This should include the full text of all notices, legal symbols, trademark numbers, and so on.</source>
          <target state="translated">Isso deve incluir o texto completo de todos os avisos, símbolos legais, números de marca e assim por diante.</target>       </trans-unit>
        <trans-unit id="441" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.AssemblyBuilder.DefineVersionInfoResource(System.String,System.String,System.String,System.String,System.String)">
          <source>In English, this string should be in the format "Windows is a trademark of Microsoft Corporation".</source>
          <target state="translated">Em inglês, essa cadeia de caracteres deve estar no formato "Windows is a trademark of Microsoft Corporation".</target>       </trans-unit>
        <trans-unit id="442" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.AssemblyBuilder.DefineVersionInfoResource(System.String,System.String,System.String,System.String,System.String)">
          <source>Defines an unmanaged version information resource for this assembly with the given specifications.</source>
          <target state="translated">Define um recurso de informações de versão não gerenciada para este assembly com as especificações determinadas.</target>       </trans-unit>
        <trans-unit id="443" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.AssemblyBuilder.DefineVersionInfoResource(System.String,System.String,System.String,System.String,System.String)">
          <source>An assembly can be associated with only one unmanaged resource.</source>
          <target state="translated">Um assembly pode ser associado a apenas um recurso não gerenciado.</target>       </trans-unit>
        <trans-unit id="444" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.AssemblyBuilder.DefineVersionInfoResource(System.String,System.String,System.String,System.String,System.String)">
          <source>This means that calling <ph id="ph1">&lt;xref:System.Reflection.Emit.AssemblyBuilder.DefineVersionInfoResource%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.Reflection.Emit.AssemblyBuilder.DefineUnmanagedResource%2A&gt;</ph> after either one of the methods was called previously will throw the System.ArgumentException.</source>
          <target state="translated">Isso significa que a chamada <ph id="ph1">&lt;xref:System.Reflection.Emit.AssemblyBuilder.DefineVersionInfoResource%2A&gt;</ph> ou <ph id="ph2">&lt;xref:System.Reflection.Emit.AssemblyBuilder.DefineUnmanagedResource%2A&gt;</ph> após um um dos métodos foi chamado anteriormente lançará a System. ArgumentException.</target>       </trans-unit>
        <trans-unit id="445" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.AssemblyBuilder.DefineVersionInfoResource(System.String,System.String,System.String,System.String,System.String)">
          <source>Multiple unmanaged resources need to be merged with a tool such as the Microsoft <ph id="ph1">`ResMerge`</ph> utility (not supplied with the common language runtime SDK).</source>
          <target state="translated">Vários recursos não gerenciados precisam ser mesclada com uma ferramenta como o Microsoft <ph id="ph1">`ResMerge`</ph> utilitário (não é fornecido com o SDK do common language runtime).</target>       </trans-unit>
        <trans-unit id="446" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.AssemblyBuilder.DefineVersionInfoResource(System.String,System.String,System.String,System.String,System.String)">
          <source>Empty argument strings get written as a single space.</source>
          <target state="translated">Cadeias de caracteres de argumentos vazia ser gravadas como um único espaço.</target>       </trans-unit>
        <trans-unit id="447" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.AssemblyBuilder.DefineVersionInfoResource(System.String,System.String,System.String,System.String,System.String)">
          <source>Spaces are substituted for null characters in the argument strings.</source>
          <target state="translated">Espaços são substituídos por caracteres nulos em cadeias de caracteres da argumento.</target>       </trans-unit>
        <trans-unit id="448" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.AssemblyBuilder.DefineVersionInfoResource(System.String,System.String,System.String,System.String,System.String)">
          <source>The structure of the version resource includes data that identifies the version, language, and distribution of the file.</source>
          <target state="translated">A estrutura do recurso de versão inclui dados que identifica a versão, o idioma e a distribuição do arquivo.</target>       </trans-unit>
        <trans-unit id="449" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.AssemblyBuilder.DefineVersionInfoResource(System.String,System.String,System.String,System.String,System.String)">
          <source>Installation programs use the functions in the file installation library (VER.DLL) to retrieve the version information resource from a file and to extract the version information blocks from the resource.</source>
          <target state="translated">Programas de instalação de usam as funções na biblioteca de instalação do arquivo (VER. DLL) para recuperar o recurso de informações de versão de um arquivo e para extrair os blocos de informações de versão do recurso.</target>       </trans-unit>
        <trans-unit id="450" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.AssemblyBuilder.DefineVersionInfoResource(System.String,System.String,System.String,System.String,System.String)">
          <source>Starting with the <ph id="ph1">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</ph>, this member no longer requires <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> with the <ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType&gt;</ph> flag.</source>
          <target state="translated">Começando com o <ph id="ph1">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</ph>, esse membro não requer mais <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> com o <ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType&gt;</ph> sinalizador.</target>       </trans-unit>
        <trans-unit id="451" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.AssemblyBuilder.DefineVersionInfoResource(System.String,System.String,System.String,System.String,System.String)">
          <source>(See <bpt id="p1">[</bpt>Security Issues in Reflection Emit<ept id="p1">](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)</ept>.) To use this functionality, your application should target the <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> or later.</source>
          <target state="translated">(Consulte <bpt id="p1">[</bpt>problemas de segurança em reflexão emitir<ept id="p1">](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)</ept>.) Para usar essa funcionalidade, seu aplicativo deve ser direcionado ao <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> ou posterior.</target>       </trans-unit>
        <trans-unit id="452" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.AssemblyBuilder.DefineVersionInfoResource(System.String,System.String,System.String,System.String,System.String)">
          <source>The example below illustrates the usage of <ph id="ph1">`DefineVersionInfoResource`</ph>.</source>
          <target state="translated">O exemplo a seguir ilustra o uso de <ph id="ph1">`DefineVersionInfoResource`</ph>.</target>       </trans-unit>
        <trans-unit id="453" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.AssemblyBuilder.DefineVersionInfoResource(System.String,System.String,System.String,System.String,System.String)">
          <source>An unmanaged version information resource was previously defined.</source>
          <target state="translated">Um recurso de informações de versão não gerenciada foi definido anteriormente.</target>       </trans-unit>
        <trans-unit id="454" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.AssemblyBuilder.DefineVersionInfoResource(System.String,System.String,System.String,System.String,System.String)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="455" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.AssemblyBuilder.DefineVersionInfoResource(System.String,System.String,System.String,System.String,System.String)">
          <source>The unmanaged version information is too large to persist.</source>
          <target state="translated">As informações de versão não gerenciadas são muito grandes para serem persistidas.</target>       </trans-unit>
        <trans-unit id="456" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.AssemblyBuilder.DefineVersionInfoResource(System.String,System.String,System.String,System.String,System.String)">
          <source>The caller does not have the required permission.</source>
          <target state="translated">O chamador não tem a permissão necessária.</target>       </trans-unit>
        <trans-unit id="457" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.AssemblyBuilder.DefineVersionInfoResource(System.String,System.String,System.String,System.String,System.String)">
          <source>when invoked late-bound through mechanisms such as <ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>.</source>
          <target state="translated">quando invocado com associação tardia por meio de mecanismos como <ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="458" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.AssemblyBuilder.DefineVersionInfoResource(System.String,System.String,System.String,System.String,System.String)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph>.</source>
          <target state="translated">Enumeração associada: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="459" translate="yes" xml:space="preserve" uid="P:System.Reflection.Emit.AssemblyBuilder.EntryPoint">
          <source>Returns the entry point of this assembly.</source>
          <target state="translated">Retorna o ponto de entrada desse assembly.</target>       </trans-unit>
        <trans-unit id="460" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.AssemblyBuilder.EntryPoint">
          <source>The entry point of this assembly.</source>
          <target state="translated">O ponto de entrada desse assembly.</target>       </trans-unit>
        <trans-unit id="461" translate="yes" xml:space="preserve" uid="P:System.Reflection.Emit.AssemblyBuilder.EntryPoint">
          <source>The caller does not have the required permission.</source>
          <target state="translated">O chamador não tem a permissão necessária.</target>       </trans-unit>
        <trans-unit id="462" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.AssemblyBuilder.EntryPoint">
          <source>when invoked late-bound through mechanisms such as <ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>.</source>
          <target state="translated">quando invocado com associação tardia por meio de mecanismos como <ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="463" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.AssemblyBuilder.EntryPoint">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph>.</source>
          <target state="translated">Enumeração associada: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="464" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.AssemblyBuilder.Equals(System.Object)">
          <source>An object to compare with this instance, or <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Um objeto a ser comparado com essa instância ou <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="465" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.AssemblyBuilder.Equals(System.Object)">
          <source>Returns a value that indicates whether this instance is equal to the specified object.</source>
          <target state="translated">Retorna um valor que indica se essa instância é igual ao objeto especificado.</target>       </trans-unit>
        <trans-unit id="466" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.AssemblyBuilder.Equals(System.Object)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if <ph id="ph2">&lt;paramref name="obj" /&gt;</ph> equals the type and value of this instance; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> se <ph id="ph2">&lt;paramref name="obj" /&gt;</ph> for igual ao tipo e ao valor dessa instância, caso contrário, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="467" translate="yes" xml:space="preserve" uid="P:System.Reflection.Emit.AssemblyBuilder.Evidence">
          <source>Gets the evidence for this assembly.</source>
          <target state="translated">Obtém a evidência para esse assembly.</target>       </trans-unit>
        <trans-unit id="468" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.AssemblyBuilder.Evidence">
          <source>The evidence for this assembly.</source>
          <target state="translated">A evidência para esse assembly.</target>       </trans-unit>
        <trans-unit id="469" translate="yes" xml:space="preserve" uid="P:System.Reflection.Emit.AssemblyBuilder.FullName">
          <source>Gets the display name of the current dynamic assembly.</source>
          <target state="translated">Obtém o nome de exibição do assembly dinâmico atual.</target>       </trans-unit>
        <trans-unit id="470" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.AssemblyBuilder.FullName">
          <source>The display name of the dynamic assembly.</source>
          <target state="translated">O nome para exibição do assembly dinâmico.</target>       </trans-unit>
        <trans-unit id="471" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.AssemblyBuilder.FullName">
          <source>See <ph id="ph1">&lt;xref:System.Reflection.AssemblyName&gt;</ph> for a description of the format of the display name of an assembly.</source>
          <target state="translated">Consulte <ph id="ph1">&lt;xref:System.Reflection.AssemblyName&gt;</ph> para obter uma descrição do formato do nome para exibição de um assembly.</target>       </trans-unit>
        <trans-unit id="472" translate="yes" xml:space="preserve" uid="T:System.Reflection.Emit.AssemblyBuilder">
          <source>Returns custom attributes that have been applied to the current <ph id="ph1">&lt;see cref="T:System.Reflection.Emit.AssemblyBuilder" /&gt;</ph></source>
          <target state="translated">Retorna atributos personalizados que foram aplicados ao <ph id="ph1">&lt;see cref="T:System.Reflection.Emit.AssemblyBuilder" /&gt;</ph> atual</target>       </trans-unit>
        <trans-unit id="473" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.AssemblyBuilder.GetCustomAttributes(System.Boolean)">
          <source>This argument is ignored for objects of this type.</source>
          <target state="translated">Este argumento é ignorado para objetos deste tipo.</target>       </trans-unit>
        <trans-unit id="474" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.AssemblyBuilder.GetCustomAttributes(System.Boolean)">
          <source>Returns all the custom attributes that have been applied to the current <ph id="ph1">&lt;see cref="T:System.Reflection.Emit.AssemblyBuilder" /&gt;</ph>.</source>
          <target state="translated">Retorna todos os atributos personalizados que foram aplicados ao <ph id="ph1">&lt;see cref="T:System.Reflection.Emit.AssemblyBuilder" /&gt;</ph> atual.</target>       </trans-unit>
        <trans-unit id="475" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.AssemblyBuilder.GetCustomAttributes(System.Boolean)">
          <source>An array that contains the custom attributes; the array is empty if there are no attributes.</source>
          <target state="translated">Uma matriz que contém os atributos personalizados; a matriz será vazia se não houver nenhum atributo.</target>       </trans-unit>
        <trans-unit id="476" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.AssemblyBuilder.GetCustomAttributes(System.Type,System.Boolean)">
          <source>The base type from which attributes derive.</source>
          <target state="translated">O tipo base do qual derivam os atributos.</target>       </trans-unit>
        <trans-unit id="477" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.AssemblyBuilder.GetCustomAttributes(System.Type,System.Boolean)">
          <source>This argument is ignored for objects of this type.</source>
          <target state="translated">Este argumento é ignorado para objetos deste tipo.</target>       </trans-unit>
        <trans-unit id="478" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.AssemblyBuilder.GetCustomAttributes(System.Type,System.Boolean)">
          <source>Returns all the custom attributes that have been applied to the current <ph id="ph1">&lt;see cref="T:System.Reflection.Emit.AssemblyBuilder" /&gt;</ph>, and that derive from a specified attribute type.</source>
          <target state="translated">Retorna todos os atributos personalizados que foram aplicados ao <ph id="ph1">&lt;see cref="T:System.Reflection.Emit.AssemblyBuilder" /&gt;</ph> atual e que derivam de um tipo de atributo especificado.</target>       </trans-unit>
        <trans-unit id="479" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.AssemblyBuilder.GetCustomAttributes(System.Type,System.Boolean)">
          <source>An array that contains the custom attributes that are derived at any level from <ph id="ph1">&lt;paramref name="attributeType" /&gt;</ph>; the array is empty if there are no such attributes.</source>
          <target state="translated">Uma matriz que contém os atributos personalizados que são derivados em qualquer nível de <ph id="ph1">&lt;paramref name="attributeType" /&gt;</ph>; a matriz será vazia se não houver nenhum desses atributos.</target>       </trans-unit>
        <trans-unit id="480" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.AssemblyBuilder.GetCustomAttributes(System.Type,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="attributeType" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="attributeType" /&gt;</ph> é <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="481" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.AssemblyBuilder.GetCustomAttributes(System.Type,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="attributeType" /&gt;</ph> is not a <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> object supplied by the runtime.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="attributeType" /&gt;</ph> não é um objeto <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> fornecido pelo tempo de execução.</target>       </trans-unit>
        <trans-unit id="482" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.AssemblyBuilder.GetCustomAttributes(System.Type,System.Boolean)">
          <source>For example, <ph id="ph1">&lt;paramref name="attributeType" /&gt;</ph> is a <ph id="ph2">&lt;see cref="T:System.Reflection.Emit.TypeBuilder" /&gt;</ph> object.</source>
          <target state="translated">Por exemplo, <ph id="ph1">&lt;paramref name="attributeType" /&gt;</ph> é um objeto <ph id="ph2">&lt;see cref="T:System.Reflection.Emit.TypeBuilder" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="483" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.AssemblyBuilder.GetCustomAttributesData">
          <source>Returns <ph id="ph1">&lt;see cref="T:System.Reflection.CustomAttributeData" /&gt;</ph> objects that contain information about the attributes that have been applied to the current <ph id="ph2">&lt;see cref="T:System.Reflection.Emit.AssemblyBuilder" /&gt;</ph>.</source>
          <target state="translated">Retorna objetos <ph id="ph1">&lt;see cref="T:System.Reflection.CustomAttributeData" /&gt;</ph> que contêm informações sobre os atributos que foram aplicados ao <ph id="ph2">&lt;see cref="T:System.Reflection.Emit.AssemblyBuilder" /&gt;</ph> atual.</target>       </trans-unit>
        <trans-unit id="484" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.AssemblyBuilder.GetCustomAttributesData">
          <source>A generic list of <ph id="ph1">&lt;see cref="T:System.Reflection.CustomAttributeData" /&gt;</ph> objects representing data about the attributes that have been applied to the current module.</source>
          <target state="translated">Uma lista genérica de objetos <ph id="ph1">&lt;see cref="T:System.Reflection.CustomAttributeData" /&gt;</ph> que representam dados sobre os atributos que foram aplicados ao módulo atual.</target>       </trans-unit>
        <trans-unit id="485" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.AssemblyBuilder.GetCustomAttributesData">
          <source>Use this method to examine the custom attributes of code in the reflection-only context, in cases where the custom attributes themselves are defined in code that is loaded into the reflection-only context.</source>
          <target state="translated">Use esse método para examinar os atributos personalizados de código no contexto exclusivo de reflexão, em casos onde os atributos personalizados próprios são definidos no código que é carregado no contexto exclusivo de reflexão.</target>       </trans-unit>
        <trans-unit id="486" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.AssemblyBuilder.GetCustomAttributesData">
          <source>Methods such as <ph id="ph1">&lt;xref:System.Attribute.GetCustomAttributes%2A?displayProperty=nameWithType&gt;</ph> and <ph id="ph2">&lt;xref:System.Reflection.Assembly.GetCustomAttributes%2A?displayProperty=nameWithType&gt;</ph> cannot be used in such cases, because they create instances of the attributes.</source>
          <target state="translated">Métodos como <ph id="ph1">&lt;xref:System.Attribute.GetCustomAttributes%2A?displayProperty=nameWithType&gt;</ph> e <ph id="ph2">&lt;xref:System.Reflection.Assembly.GetCustomAttributes%2A?displayProperty=nameWithType&gt;</ph> não pode ser usado em tais casos, porque eles criar instâncias dos atributos.</target>       </trans-unit>
        <trans-unit id="487" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.AssemblyBuilder.GetCustomAttributesData">
          <source>Code in the reflection-only context cannot be executed.</source>
          <target state="translated">O código no contexto exclusivo de reflexão não pode ser executado.</target>       </trans-unit>
        <trans-unit id="488" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.AssemblyBuilder.GetCustomAttributesData">
          <source>For more information and for example code, see the <ph id="ph1">&lt;xref:System.Reflection.CustomAttributeData&gt;</ph> class.</source>
          <target state="translated">Para obter mais informações e como código, consulte o <ph id="ph1">&lt;xref:System.Reflection.CustomAttributeData&gt;</ph> classe.</target>       </trans-unit>
        <trans-unit id="489" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.AssemblyBuilder.GetDynamicModule(System.String)">
          <source>The name of the requested dynamic module.</source>
          <target state="translated">O nome do módulo dinâmico solicitado.</target>       </trans-unit>
        <trans-unit id="490" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.AssemblyBuilder.GetDynamicModule(System.String)">
          <source>Returns the dynamic module with the specified name.</source>
          <target state="translated">Retorna o módulo dinâmico com o nome especificado.</target>       </trans-unit>
        <trans-unit id="491" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.AssemblyBuilder.GetDynamicModule(System.String)">
          <source>A ModuleBuilder object representing the requested dynamic module.</source>
          <target state="translated">Um objeto ModuleBuilder que representa o módulo dinâmico solicitado.</target>       </trans-unit>
        <trans-unit id="492" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.AssemblyBuilder.GetDynamicModule(System.String)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> é <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="493" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.AssemblyBuilder.GetDynamicModule(System.String)">
          <source>The length of <ph id="ph1">&lt;paramref name="name" /&gt;</ph> is zero.</source>
          <target state="translated">O comprimento de <ph id="ph1">&lt;paramref name="name" /&gt;</ph> é zero.</target>       </trans-unit>
        <trans-unit id="494" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.AssemblyBuilder.GetDynamicModule(System.String)">
          <source>The caller does not have the required permission.</source>
          <target state="translated">O chamador não tem a permissão necessária.</target>       </trans-unit>
        <trans-unit id="495" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.AssemblyBuilder.GetDynamicModule(System.String)">
          <source>when invoked late-bound through mechanisms such as <ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>.</source>
          <target state="translated">quando invocado com associação tardia por meio de mecanismos como <ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="496" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.AssemblyBuilder.GetDynamicModule(System.String)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph>.</source>
          <target state="translated">Enumeração associada: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="497" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.AssemblyBuilder.GetExportedTypes">
          <source>Gets the exported types defined in this assembly.</source>
          <target state="translated">Obtém os tipos exportados definidos neste assembly.</target>       </trans-unit>
        <trans-unit id="498" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.AssemblyBuilder.GetExportedTypes">
          <source>An array of <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> containing the exported types defined in this assembly.</source>
          <target state="translated">Uma matriz de <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> que contém os tipos exportados definidos neste assembly.</target>       </trans-unit>
        <trans-unit id="499" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.AssemblyBuilder.GetExportedTypes">
          <source>This method is not implemented.</source>
          <target state="translated">Este método não está implementado.</target>       </trans-unit>
        <trans-unit id="500" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.AssemblyBuilder.GetExportedTypes">
          <source>The caller does not have the required permission.</source>
          <target state="translated">O chamador não tem a permissão necessária.</target>       </trans-unit>
        <trans-unit id="501" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.AssemblyBuilder.GetExportedTypes">
          <source>when invoked late-bound through mechanisms such as <ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>.</source>
          <target state="translated">quando invocado com associação tardia por meio de mecanismos como <ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="502" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.AssemblyBuilder.GetExportedTypes">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph>.</source>
          <target state="translated">Enumeração associada: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="503" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.AssemblyBuilder.GetFile(System.String)">
          <source>The name of the specified file.</source>
          <target state="translated">O nome do arquivo especificado.</target>       </trans-unit>
        <trans-unit id="504" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.AssemblyBuilder.GetFile(System.String)">
          <source>Gets a <ph id="ph1">&lt;see cref="T:System.IO.FileStream" /&gt;</ph> for the specified file in the file table of the manifest of this assembly.</source>
          <target state="translated">Obtém um <ph id="ph1">&lt;see cref="T:System.IO.FileStream" /&gt;</ph> para o arquivo especificado na tabela de arquivo do manifesto desse assembly.</target>       </trans-unit>
        <trans-unit id="505" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.AssemblyBuilder.GetFile(System.String)">
          <source>A <ph id="ph1">&lt;see cref="T:System.IO.FileStream" /&gt;</ph> for the specified file, or <ph id="ph2">&lt;see langword="null" /&gt;</ph>, if the file is not found.</source>
          <target state="translated">Um <ph id="ph1">&lt;see cref="T:System.IO.FileStream" /&gt;</ph> para o arquivo especificado, ou <ph id="ph2">&lt;see langword="null" /&gt;</ph> se o arquivo não for encontrado.</target>       </trans-unit>
        <trans-unit id="506" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.AssemblyBuilder.GetFile(System.String)">
          <source><ph id="ph1">`name`</ph> should not include the path to the file.</source>
          <target state="translated"><ph id="ph1">`name`</ph> não deve incluir o caminho para o arquivo.</target>       </trans-unit>
        <trans-unit id="507" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.AssemblyBuilder.GetFile(System.String)">
          <source>This method is not currently supported.</source>
          <target state="translated">Não há suporte para este método atualmente.</target>       </trans-unit>
        <trans-unit id="508" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.AssemblyBuilder.GetFile(System.String)">
          <source>The caller does not have the required permission.</source>
          <target state="translated">O chamador não tem a permissão necessária.</target>       </trans-unit>
        <trans-unit id="509" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.AssemblyBuilder.GetFile(System.String)">
          <source>when invoked late-bound through mechanisms such as <ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>.</source>
          <target state="translated">quando invocado com associação tardia por meio de mecanismos como <ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="510" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.AssemblyBuilder.GetFile(System.String)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph>.</source>
          <target state="translated">Enumeração associada: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="511" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.AssemblyBuilder.GetFiles(System.Boolean)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> to include resource modules; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> para incluir os módulos de recursos; caso contrário, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="512" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.AssemblyBuilder.GetFiles(System.Boolean)">
          <source>Gets the files in the file table of an assembly manifest, specifying whether to include resource modules.</source>
          <target state="translated">Obtém os arquivos na tabela de arquivos de um manifesto do assembly, especificando se deseja-se incluir os módulos de recursos.</target>       </trans-unit>
        <trans-unit id="513" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.AssemblyBuilder.GetFiles(System.Boolean)">
          <source>An array of <ph id="ph1">&lt;see cref="T:System.IO.FileStream" /&gt;</ph> objects.</source>
          <target state="translated">Uma matriz de objetos de <ph id="ph1">&lt;see cref="T:System.IO.FileStream" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="514" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.AssemblyBuilder.GetFiles(System.Boolean)">
          <source>This method is not currently supported.</source>
          <target state="translated">Não há suporte para este método atualmente.</target>       </trans-unit>
        <trans-unit id="515" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.AssemblyBuilder.GetFiles(System.Boolean)">
          <source>The caller does not have the required permission.</source>
          <target state="translated">O chamador não tem a permissão necessária.</target>       </trans-unit>
        <trans-unit id="516" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.AssemblyBuilder.GetFiles(System.Boolean)">
          <source>when invoked late-bound through mechanisms such as <ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>.</source>
          <target state="translated">quando invocado com associação tardia por meio de mecanismos como <ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="517" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.AssemblyBuilder.GetFiles(System.Boolean)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph>.</source>
          <target state="translated">Enumeração associada: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="518" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.AssemblyBuilder.GetHashCode">
          <source>Returns the hash code for this instance.</source>
          <target state="translated">Retorna o código hash para essa instância.</target>       </trans-unit>
        <trans-unit id="519" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.AssemblyBuilder.GetHashCode">
          <source>A 32-bit signed integer hash code.</source>
          <target state="translated">Um código de hash do inteiro assinado de 32 bits.</target>       </trans-unit>
        <trans-unit id="520" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.AssemblyBuilder.GetLoadedModules(System.Boolean)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> to include resource modules; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> para incluir os módulos de recursos; caso contrário, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="521" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.AssemblyBuilder.GetLoadedModules(System.Boolean)">
          <source>Returns all the loaded modules that are part of this assembly, and optionally includes resource modules.</source>
          <target state="translated">Retorna todos os módulos carregados que fazem parte desse assembly e, opcionalmente, inclui módulos de recursos.</target>       </trans-unit>
        <trans-unit id="522" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.AssemblyBuilder.GetLoadedModules(System.Boolean)">
          <source>The loaded modules that are part of this assembly.</source>
          <target state="translated">Os módulos carregados que fazem parte desse assembly.</target>       </trans-unit>
        <trans-unit id="523" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.AssemblyBuilder.GetManifestResourceInfo(System.String)">
          <source>The name of the resource.</source>
          <target state="translated">O nome do recurso.</target>       </trans-unit>
        <trans-unit id="524" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.AssemblyBuilder.GetManifestResourceInfo(System.String)">
          <source>Returns information about how the given resource has been persisted.</source>
          <target state="translated">Retorna informações sobre como o recurso em questão foi persistido.</target>       </trans-unit>
        <trans-unit id="525" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.AssemblyBuilder.GetManifestResourceInfo(System.String)">
          <source><ph id="ph1">&lt;see cref="T:System.Reflection.ManifestResourceInfo" /&gt;</ph> populated with information about the resource's topology, or <ph id="ph2">&lt;see langword="null" /&gt;</ph> if the resource is not found.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Reflection.ManifestResourceInfo" /&gt;</ph> é preenchido com informações sobre a topologia do recurso ou <ph id="ph2">&lt;see langword="null" /&gt;</ph>, se o recurso não for encontrado.</target>       </trans-unit>
        <trans-unit id="526" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.AssemblyBuilder.GetManifestResourceInfo(System.String)">
          <source>This method is not currently supported.</source>
          <target state="translated">Não há suporte para este método atualmente.</target>       </trans-unit>
        <trans-unit id="527" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.AssemblyBuilder.GetManifestResourceInfo(System.String)">
          <source>The caller does not have the required permission.</source>
          <target state="translated">O chamador não tem a permissão necessária.</target>       </trans-unit>
        <trans-unit id="528" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.AssemblyBuilder.GetManifestResourceInfo(System.String)">
          <source>when invoked late-bound through mechanisms such as <ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>.</source>
          <target state="translated">quando invocado com associação tardia por meio de mecanismos como <ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="529" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.AssemblyBuilder.GetManifestResourceInfo(System.String)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph>.</source>
          <target state="translated">Enumeração associada: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="530" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.AssemblyBuilder.GetManifestResourceNames">
          <source>Loads the specified manifest resource from this assembly.</source>
          <target state="translated">Carrega o recurso de manifesto especificado desse assembly.</target>       </trans-unit>
        <trans-unit id="531" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.AssemblyBuilder.GetManifestResourceNames">
          <source>An array of type <ph id="ph1">&lt;see langword="String" /&gt;</ph> containing the names of all the resources.</source>
          <target state="translated">Uma matriz do tipo <ph id="ph1">&lt;see langword="String" /&gt;</ph> que contém os nomes de todos os recursos.</target>       </trans-unit>
        <trans-unit id="532" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.AssemblyBuilder.GetManifestResourceNames">
          <source>This method is not supported on a dynamic assembly.</source>
          <target state="translated">Este método não tem suporte em um assembly dinâmico.</target>       </trans-unit>
        <trans-unit id="533" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.AssemblyBuilder.GetManifestResourceNames">
          <source>To get the manifest resource names, use <ph id="ph1">&lt;see cref="M:System.Reflection.Assembly.GetManifestResourceNames" /&gt;</ph>.</source>
          <target state="translated">Para obter os nomes de recurso de manifesto, use <ph id="ph1">&lt;see cref="M:System.Reflection.Assembly.GetManifestResourceNames" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="534" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.AssemblyBuilder.GetManifestResourceNames">
          <source>The caller does not have the required permission.</source>
          <target state="translated">O chamador não tem a permissão necessária.</target>       </trans-unit>
        <trans-unit id="535" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.AssemblyBuilder.GetManifestResourceNames">
          <source>when invoked late-bound through mechanisms such as <ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>.</source>
          <target state="translated">quando invocado com associação tardia por meio de mecanismos como <ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="536" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.AssemblyBuilder.GetManifestResourceNames">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph>.</source>
          <target state="translated">Enumeração associada: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="537" translate="yes" xml:space="preserve" uid="T:System.Reflection.Emit.AssemblyBuilder">
          <source>Loads the specified manifest resource from this assembly.</source>
          <target state="translated">Carrega o recurso de manifesto especificado desse assembly.</target>       </trans-unit>
        <trans-unit id="538" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.AssemblyBuilder.GetManifestResourceStream(System.String)">
          <source>The name of the manifest resource being requested.</source>
          <target state="translated">O nome do recurso de manifesto solicitado.</target>       </trans-unit>
        <trans-unit id="539" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.AssemblyBuilder.GetManifestResourceStream(System.String)">
          <source>Loads the specified manifest resource from this assembly.</source>
          <target state="translated">Carrega o recurso de manifesto especificado desse assembly.</target>       </trans-unit>
        <trans-unit id="540" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.AssemblyBuilder.GetManifestResourceStream(System.String)">
          <source>A <ph id="ph1">&lt;see cref="T:System.IO.Stream" /&gt;</ph> representing this manifest resource.</source>
          <target state="translated">Um <ph id="ph1">&lt;see cref="T:System.IO.Stream" /&gt;</ph> que representa esse recurso de manifesto.</target>       </trans-unit>
        <trans-unit id="541" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.AssemblyBuilder.GetManifestResourceStream(System.String)">
          <source>This method is not currently supported.</source>
          <target state="translated">Não há suporte para este método atualmente.</target>       </trans-unit>
        <trans-unit id="542" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.AssemblyBuilder.GetManifestResourceStream(System.String)">
          <source>The caller does not have the required permission.</source>
          <target state="translated">O chamador não tem a permissão necessária.</target>       </trans-unit>
        <trans-unit id="543" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.AssemblyBuilder.GetManifestResourceStream(System.String)">
          <source>when invoked late-bound through mechanisms such as <ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>.</source>
          <target state="translated">quando invocado com associação tardia por meio de mecanismos como <ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="544" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.AssemblyBuilder.GetManifestResourceStream(System.String)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph>.</source>
          <target state="translated">Enumeração associada: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="545" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.AssemblyBuilder.GetManifestResourceStream(System.Type,System.String)">
          <source>The type whose namespace is used to scope the manifest resource name.</source>
          <target state="translated">O tipo cujo namespace é usado para definir o escopo do nome de recurso de manifesto.</target>       </trans-unit>
        <trans-unit id="546" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.AssemblyBuilder.GetManifestResourceStream(System.Type,System.String)">
          <source>The name of the manifest resource being requested.</source>
          <target state="translated">O nome do recurso de manifesto solicitado.</target>       </trans-unit>
        <trans-unit id="547" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.AssemblyBuilder.GetManifestResourceStream(System.Type,System.String)">
          <source>Loads the specified manifest resource, scoped by the namespace of the specified type, from this assembly.</source>
          <target state="translated">Carrega o recurso de manifesto especificado, o escopo pelo namespace do tipo especificado, desse assembly.</target>       </trans-unit>
        <trans-unit id="548" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.AssemblyBuilder.GetManifestResourceStream(System.Type,System.String)">
          <source>A <ph id="ph1">&lt;see cref="T:System.IO.Stream" /&gt;</ph> representing this manifest resource.</source>
          <target state="translated">Um <ph id="ph1">&lt;see cref="T:System.IO.Stream" /&gt;</ph> que representa esse recurso de manifesto.</target>       </trans-unit>
        <trans-unit id="549" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.AssemblyBuilder.GetManifestResourceStream(System.Type,System.String)">
          <source>The returned <ph id="ph1">&lt;xref:System.IO.Stream&gt;</ph> has its file pointer set to the beginning of the resource.</source>
          <target state="translated">Retornado <ph id="ph1">&lt;xref:System.IO.Stream&gt;</ph> tem o ponteiro de arquivo definido para o início do recurso.</target>       </trans-unit>
        <trans-unit id="550" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.AssemblyBuilder.GetManifestResourceStream(System.Type,System.String)">
          <source>If the full name of <ph id="ph1">`type`</ph> is "MyNameSpace.MyClasses" and <ph id="ph2">`name`</ph> is "Dot", <ph id="ph3">`GetManifestResourceStream`</ph> will search for a resource named MyNameSpace.Dot.</source>
          <target state="translated">Se o nome completo do <ph id="ph1">`type`</ph> é "MyNameSpace.MyClasses" e <ph id="ph2">`name`</ph> é "Dot" <ph id="ph3">`GetManifestResourceStream`</ph> procurará um recurso chamado MyNameSpace.Dot.</target>       </trans-unit>
        <trans-unit id="551" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.AssemblyBuilder.GetManifestResourceStream(System.Type,System.String)">
          <source>This method is not currently supported.</source>
          <target state="translated">Não há suporte para este método atualmente.</target>       </trans-unit>
        <trans-unit id="552" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.AssemblyBuilder.GetManifestResourceStream(System.Type,System.String)">
          <source>The caller does not have the required permission.</source>
          <target state="translated">O chamador não tem a permissão necessária.</target>       </trans-unit>
        <trans-unit id="553" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.AssemblyBuilder.GetManifestResourceStream(System.Type,System.String)">
          <source>when invoked late-bound through mechanisms such as <ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>.</source>
          <target state="translated">quando invocado com associação tardia por meio de mecanismos como <ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="554" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.AssemblyBuilder.GetManifestResourceStream(System.Type,System.String)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph>.</source>
          <target state="translated">Enumeração associada: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="555" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.AssemblyBuilder.GetModule(System.String)">
          <source>The name of the requested module.</source>
          <target state="translated">O nome do módulo solicitado.</target>       </trans-unit>
        <trans-unit id="556" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.AssemblyBuilder.GetModule(System.String)">
          <source>Gets the specified module in this assembly.</source>
          <target state="translated">Obtém o módulo especificado nesse assembly.</target>       </trans-unit>
        <trans-unit id="557" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.AssemblyBuilder.GetModule(System.String)">
          <source>The module being requested, or <ph id="ph1">&lt;see langword="null" /&gt;</ph> if the module is not found.</source>
          <target state="translated">O módulo que está sendo solicitado ou <ph id="ph1">&lt;see langword="null" /&gt;</ph>, se o módulo não tiver sido encontrado.</target>       </trans-unit>
        <trans-unit id="558" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.AssemblyBuilder.GetModules(System.Boolean)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> to include resource modules; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> para incluir os módulos de recursos; caso contrário, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="559" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.AssemblyBuilder.GetModules(System.Boolean)">
          <source>Gets all the modules that are part of this assembly, and optionally includes resource modules.</source>
          <target state="translated">Obtém todos os módulos que fazem parte desse assembly e, opcionalmente, inclui módulos de recursos.</target>       </trans-unit>
        <trans-unit id="560" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.AssemblyBuilder.GetModules(System.Boolean)">
          <source>The modules that are part of this assembly.</source>
          <target state="translated">Os módulos que fazem parte desse assembly.</target>       </trans-unit>
        <trans-unit id="561" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.AssemblyBuilder.GetName(System.Boolean)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> to set the code base to the location of the assembly after it is shadow-copied; <ph id="ph2">&lt;see langword="false" /&gt;</ph> to set the code base to the original location.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> para definir a base de código para o local do assembly depois que tiver sido feita uma cópia de sombra dele; <ph id="ph2">&lt;see langword="false" /&gt;</ph> para definir a base de código com o local original.</target>       </trans-unit>
        <trans-unit id="562" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.AssemblyBuilder.GetName(System.Boolean)">
          <source>Gets the <ph id="ph1">&lt;see cref="T:System.Reflection.AssemblyName" /&gt;</ph> that was specified when the current dynamic assembly was created, and sets the code base as specified.</source>
          <target state="translated">Obtém o <ph id="ph1">&lt;see cref="T:System.Reflection.AssemblyName" /&gt;</ph>, que foi especificado quando o assembly dinâmico atual foi criado e define a base de código como especificado.</target>       </trans-unit>
        <trans-unit id="563" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.AssemblyBuilder.GetName(System.Boolean)">
          <source>The name of the dynamic assembly.</source>
          <target state="translated">O nome do assembly dinâmico.</target>       </trans-unit>
        <trans-unit id="564" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.AssemblyBuilder.GetReferencedAssemblies">
          <source>Gets an incomplete list of <ph id="ph1">&lt;see cref="T:System.Reflection.AssemblyName" /&gt;</ph> objects for the assemblies that are referenced by this <ph id="ph2">&lt;see cref="T:System.Reflection.Emit.AssemblyBuilder" /&gt;</ph>.</source>
          <target state="translated">Obtém uma lista incompleta de objetos <ph id="ph1">&lt;see cref="T:System.Reflection.AssemblyName" /&gt;</ph> para os assemblies que são referenciados por este <ph id="ph2">&lt;see cref="T:System.Reflection.Emit.AssemblyBuilder" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="565" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.AssemblyBuilder.GetReferencedAssemblies">
          <source>An array of assembly names for the referenced assemblies.</source>
          <target state="translated">Uma matriz de nomes de assembly para os assemblies referenciados.</target>       </trans-unit>
        <trans-unit id="566" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.AssemblyBuilder.GetReferencedAssemblies">
          <source>This array is not a complete list.</source>
          <target state="translated">Esta matriz não é uma lista completa.</target>       </trans-unit>
        <trans-unit id="567" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.AssemblyBuilder.GetReferencedAssemblies">
          <source>This method does not return a complete list of referenced assemblies.</source>
          <target state="translated">Este método não retorna uma lista completa de assemblies referenciados.</target>       </trans-unit>
        <trans-unit id="568" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.AssemblyBuilder.GetReferencedAssemblies">
          <source>For example, if you apply a custom attribute to the <ph id="ph1">&lt;xref:System.Reflection.Emit.AssemblyBuilder&gt;</ph>, the assembly in which the attribute was defined is included in the list returned by this method.</source>
          <target state="translated">Por exemplo, se você aplicar um atributo personalizado para o <ph id="ph1">&lt;xref:System.Reflection.Emit.AssemblyBuilder&gt;</ph>, o assembly no qual o atributo foi definido está incluído na lista retornada por este método.</target>       </trans-unit>
        <trans-unit id="569" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.AssemblyBuilder.GetReferencedAssemblies">
          <source>However, if you use a <ph id="ph1">&lt;xref:System.Type&gt;</ph> object to specify the type of a method parameter, that type is not included.</source>
          <target state="translated">No entanto, se você usar um <ph id="ph1">&lt;xref:System.Type&gt;</ph> objeto para especificar o tipo de um parâmetro de método, que o tipo não é incluído.</target>       </trans-unit>
        <trans-unit id="570" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.AssemblyBuilder.GetReferencedAssemblies">
          <source>To get a complete list of referenced assemblies, save the assembly, load it into another application domain, and call the <ph id="ph1">&lt;xref:System.Reflection.Assembly.GetReferencedAssemblies%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Para obter uma lista completa de assemblies referenciados, salve o assembly, carregá-lo em outro domínio de aplicativo e chame o <ph id="ph1">&lt;xref:System.Reflection.Assembly.GetReferencedAssemblies%2A?displayProperty=nameWithType&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="571" translate="yes" xml:space="preserve" uid="T:System.Reflection.Emit.AssemblyBuilder">
          <source>Gets a specified satellite assembly.</source>
          <target state="translated">Obtém um assembly satélite especificado.</target>       </trans-unit>
        <trans-unit id="572" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.AssemblyBuilder.GetSatelliteAssembly(System.Globalization.CultureInfo)">
          <source>The specified culture.</source>
          <target state="translated">A cultura especificada.</target>       </trans-unit>
        <trans-unit id="573" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.AssemblyBuilder.GetSatelliteAssembly(System.Globalization.CultureInfo)">
          <source>Gets the satellite assembly for the specified culture.</source>
          <target state="translated">Obtém o assembly satélite para a cultura especificada.</target>       </trans-unit>
        <trans-unit id="574" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.AssemblyBuilder.GetSatelliteAssembly(System.Globalization.CultureInfo)">
          <source>The specified satellite assembly.</source>
          <target state="translated">O assembly satélite especificado.</target>       </trans-unit>
        <trans-unit id="575" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.AssemblyBuilder.GetSatelliteAssembly(System.Globalization.CultureInfo)">
          <source>Satellite assemblies contain localized resources, as distinct from main application assemblies, which contain non-localizable executable code and resources for a single culture that serve as the default or neutral culture.</source>
          <target state="translated">Assemblies satélites contém recursos localizados, diferentes de assemblies de aplicativo principal, que contêm código executável não localizáveis e recursos para uma única cultura que servem como o padrão ou a cultura neutra.</target>       </trans-unit>
        <trans-unit id="576" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.AssemblyBuilder.GetSatelliteAssembly(System.Globalization.CultureInfo)">
          <source>Call this method to use your current assembly version.</source>
          <target state="translated">Chame este método para usar a versão atual do assembly.</target>       </trans-unit>
        <trans-unit id="577" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.AssemblyBuilder.GetSatelliteAssembly(System.Globalization.CultureInfo)">
          <source><ph id="ph1">&lt;paramref name="culture" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="culture" /&gt;</ph> é <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="578" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.AssemblyBuilder.GetSatelliteAssembly(System.Globalization.CultureInfo)">
          <source>The assembly cannot be found.</source>
          <target state="translated">Não foi possível localizar o assembly.</target>       </trans-unit>
        <trans-unit id="579" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.AssemblyBuilder.GetSatelliteAssembly(System.Globalization.CultureInfo)">
          <source>The satellite assembly with a matching file name was found, but the <ph id="ph1">&lt;see langword="CultureInfo" /&gt;</ph> did not match the one specified.</source>
          <target state="translated">O assembly satélite com um nome de arquivo correspondente foi encontrado, mas o <ph id="ph1">&lt;see langword="CultureInfo" /&gt;</ph> não correspondia ao especificado.</target>       </trans-unit>
        <trans-unit id="580" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.AssemblyBuilder.GetSatelliteAssembly(System.Globalization.CultureInfo)">
          <source>The satellite assembly is not a valid assembly.</source>
          <target state="translated">O assembly satélite não é um assembly válido.</target>       </trans-unit>
        <trans-unit id="581" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.AssemblyBuilder.GetSatelliteAssembly(System.Globalization.CultureInfo,System.Version)">
          <source>The specified culture.</source>
          <target state="translated">A cultura especificada.</target>       </trans-unit>
        <trans-unit id="582" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.AssemblyBuilder.GetSatelliteAssembly(System.Globalization.CultureInfo,System.Version)">
          <source>The version of the satellite assembly.</source>
          <target state="translated">A versão do assembly satélite.</target>       </trans-unit>
        <trans-unit id="583" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.AssemblyBuilder.GetSatelliteAssembly(System.Globalization.CultureInfo,System.Version)">
          <source>Gets the specified version of the satellite assembly for the specified culture.</source>
          <target state="translated">Obtém a versão especificada do assembly satélite para a cultura especificada.</target>       </trans-unit>
        <trans-unit id="584" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.AssemblyBuilder.GetSatelliteAssembly(System.Globalization.CultureInfo,System.Version)">
          <source>The specified satellite assembly.</source>
          <target state="translated">O assembly satélite especificado.</target>       </trans-unit>
        <trans-unit id="585" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.AssemblyBuilder.GetSatelliteAssembly(System.Globalization.CultureInfo,System.Version)">
          <source>Satellite assemblies contain localized resources, as distinct from main application assemblies, which contain non-localizable executable code and resources for a single culture that serve as the default or neutral culture.</source>
          <target state="translated">Assemblies satélites contém recursos localizados, diferentes de assemblies de aplicativo principal, que contêm código executável não localizáveis e recursos para uma única cultura que servem como o padrão ou a cultura neutra.</target>       </trans-unit>
        <trans-unit id="586" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.AssemblyBuilder.GetSatelliteAssembly(System.Globalization.CultureInfo,System.Version)">
          <source>Call the <ph id="ph1">&lt;xref:System.Reflection.Assembly.GetSatelliteAssembly%28System.Globalization.CultureInfo%29&gt;</ph> overload to use your current assembly version.</source>
          <target state="translated">Chamar o <ph id="ph1">&lt;xref:System.Reflection.Assembly.GetSatelliteAssembly%28System.Globalization.CultureInfo%29&gt;</ph> sobrecarga para usar a versão atual do assembly.</target>       </trans-unit>
        <trans-unit id="587" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.AssemblyBuilder.GetSatelliteAssembly(System.Globalization.CultureInfo,System.Version)">
          <source><ph id="ph1">&lt;paramref name="culture" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="culture" /&gt;</ph> é <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="588" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.AssemblyBuilder.GetSatelliteAssembly(System.Globalization.CultureInfo,System.Version)">
          <source>The satellite assembly with a matching file name was found, but the <ph id="ph1">&lt;see langword="CultureInfo" /&gt;</ph> or the version did not match the one specified.</source>
          <target state="translated">O assembly satélite com um nome de arquivo correspondente foi encontrado, mas o <ph id="ph1">&lt;see langword="CultureInfo" /&gt;</ph> ou a versão não correspondia ao especificado.</target>       </trans-unit>
        <trans-unit id="589" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.AssemblyBuilder.GetSatelliteAssembly(System.Globalization.CultureInfo,System.Version)">
          <source>The assembly cannot be found.</source>
          <target state="translated">Não foi possível localizar o assembly.</target>       </trans-unit>
        <trans-unit id="590" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.AssemblyBuilder.GetSatelliteAssembly(System.Globalization.CultureInfo,System.Version)">
          <source>The satellite assembly is not a valid assembly.</source>
          <target state="translated">O assembly satélite não é um assembly válido.</target>       </trans-unit>
        <trans-unit id="591" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.AssemblyBuilder.GetType(System.String,System.Boolean,System.Boolean)">
          <source>The name of the type to search for.</source>
          <target state="translated">O nome do tipo a ser pesquisado.</target>       </trans-unit>
        <trans-unit id="592" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.AssemblyBuilder.GetType(System.String,System.Boolean,System.Boolean)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> to throw an exception if the type is not found; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> para gerar uma exceção se o tipo não for encontrado; caso contrário <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="593" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.AssemblyBuilder.GetType(System.String,System.Boolean,System.Boolean)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> to ignore the case of the type name when searching; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> para ignorar maiúsculas e minúsculas do nome do tipo durante a pesquisa; caso contrário, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="594" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.AssemblyBuilder.GetType(System.String,System.Boolean,System.Boolean)">
          <source>Gets the specified type from the types that have been defined and created in the current <ph id="ph1">&lt;see cref="T:System.Reflection.Emit.AssemblyBuilder" /&gt;</ph>.</source>
          <target state="translated">Obtém o tipo especificado dos tipos que foram definidos e criados no <ph id="ph1">&lt;see cref="T:System.Reflection.Emit.AssemblyBuilder" /&gt;</ph> atual.</target>       </trans-unit>
        <trans-unit id="595" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.AssemblyBuilder.GetType(System.String,System.Boolean,System.Boolean)">
          <source>The specified type, or <ph id="ph1">&lt;see langword="null" /&gt;</ph> if the type is not found or has not been created yet.</source>
          <target state="translated">O tipo especificado, ou <ph id="ph1">&lt;see langword="null" /&gt;</ph> se o tipo não for encontrado ou ainda não tiver sido criado.</target>       </trans-unit>
        <trans-unit id="596" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.AssemblyBuilder.GetType(System.String,System.Boolean,System.Boolean)">
          <source>A type cannot be found until it has been created by calling the <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.CreateType%2A&gt;</ph> method.</source>
          <target state="translated">Não é possível encontrar um tipo até que ela foi criada chamando o <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.CreateType%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="597" translate="yes" xml:space="preserve" uid="P:System.Reflection.Emit.AssemblyBuilder.GlobalAssemblyCache">
          <source>Gets a value that indicates whether the assembly was loaded from the global assembly cache.</source>
          <target state="translated">Obtém um valor que indica se o assembly foi carregado do cache de assembly global.</target>       </trans-unit>
        <trans-unit id="598" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.AssemblyBuilder.GlobalAssemblyCache">
          <source>Always <ph id="ph1">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Sempre <ph id="ph1">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="599" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.AssemblyBuilder.GlobalAssemblyCache">
          <source><ph id="ph1">&lt;xref:System.Reflection.Emit.AssemblyBuilder&gt;</ph> objects always represent dynamic assemblies, and therefore are never loaded from the global assembly cache.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Reflection.Emit.AssemblyBuilder&gt;</ph> objetos sempre representam assemblies dinâmicos e, portanto, nunca são carregados do cache de assembly global.</target>       </trans-unit>
        <trans-unit id="600" translate="yes" xml:space="preserve" uid="P:System.Reflection.Emit.AssemblyBuilder.HostContext">
          <source>Gets the host context where the dynamic assembly is being created.</source>
          <target state="translated">Obtém o contexto do host em que o assembly dinâmico está sendo criado.</target>       </trans-unit>
        <trans-unit id="601" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.AssemblyBuilder.HostContext">
          <source>A value that indicates the host context where the dynamic assembly is being created.</source>
          <target state="translated">Um valor que indica o contexto do host onde o assembly dinâmico está sendo criado.</target>       </trans-unit>
        <trans-unit id="602" translate="yes" xml:space="preserve" uid="P:System.Reflection.Emit.AssemblyBuilder.ImageRuntimeVersion">
          <source>Gets the version of the common language runtime that will be saved in the file containing the manifest.</source>
          <target state="translated">Obtém a versão do Common Language Runtime que será salvo no arquivo que contém o manifesto.</target>       </trans-unit>
        <trans-unit id="603" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.AssemblyBuilder.ImageRuntimeVersion">
          <source>A string representing the common language runtime version.</source>
          <target state="translated">Uma cadeia de caracteres que representa a versão de tempo de execução de linguagem comum.</target>       </trans-unit>
        <trans-unit id="604" translate="yes" xml:space="preserve" uid="P:System.Reflection.Emit.AssemblyBuilder.ImageRuntimeVersion">
          <source>The caller does not have the required permission.</source>
          <target state="translated">O chamador não tem a permissão necessária.</target>       </trans-unit>
        <trans-unit id="605" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.AssemblyBuilder.ImageRuntimeVersion">
          <source>when invoked late-bound through mechanisms such as <ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>.</source>
          <target state="translated">quando invocado com associação tardia por meio de mecanismos como <ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="606" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.AssemblyBuilder.ImageRuntimeVersion">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph>.</source>
          <target state="translated">Enumeração associada: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="607" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.AssemblyBuilder.IsDefined(System.Type,System.Boolean)">
          <source>The type of attribute to test for.</source>
          <target state="translated">O tipo de atributo a ser testado.</target>       </trans-unit>
        <trans-unit id="608" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.AssemblyBuilder.IsDefined(System.Type,System.Boolean)">
          <source>This argument is ignored for objects of this type.</source>
          <target state="translated">Este argumento é ignorado para objetos deste tipo.</target>       </trans-unit>
        <trans-unit id="609" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.AssemblyBuilder.IsDefined(System.Type,System.Boolean)">
          <source>Returns a value that indicates whether one or more instances of the specified attribute type is applied to this member.</source>
          <target state="translated">Retorna um valor que indica se uma ou mais instâncias do tipo de atributo especificado será aplicada a esse membro.</target>       </trans-unit>
        <trans-unit id="610" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.AssemblyBuilder.IsDefined(System.Type,System.Boolean)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if one or more instances of <ph id="ph2">&lt;paramref name="attributeType" /&gt;</ph> is applied to this dynamic assembly; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> se uma ou mais instâncias de <ph id="ph2">&lt;paramref name="attributeType" /&gt;</ph> for aplicada a este assembly dinâmico; caso contrário, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="611" translate="yes" xml:space="preserve" uid="P:System.Reflection.Emit.AssemblyBuilder.IsDynamic">
          <source>Gets a value that indicates that the current assembly is a dynamic assembly.</source>
          <target state="translated">Obtém um valor que indica que o assembly atual é um assembly dinâmico.</target>       </trans-unit>
        <trans-unit id="612" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.AssemblyBuilder.IsDynamic">
          <source>Always <ph id="ph1">&lt;see langword="true" /&gt;</ph>.</source>
          <target state="translated">Sempre <ph id="ph1">&lt;see langword="true" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="613" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.AssemblyBuilder.IsDynamic">
          <source>An <ph id="ph1">&lt;xref:System.Reflection.Emit.AssemblyBuilder&gt;</ph> object always represents a dynamic assembly.</source>
          <target state="translated">Um <ph id="ph1">&lt;xref:System.Reflection.Emit.AssemblyBuilder&gt;</ph> objeto sempre representa um assembly dinâmico.</target>       </trans-unit>
        <trans-unit id="614" translate="yes" xml:space="preserve" uid="P:System.Reflection.Emit.AssemblyBuilder.Location">
          <source>Gets the location, in codebase format, of the loaded file that contains the manifest if it is not shadow-copied.</source>
          <target state="translated">Obtém o local, no formato de base de código, do arquivo carregado que contém o manifesto, caso não tenha sido feita cópia de sombra dele.</target>       </trans-unit>
        <trans-unit id="615" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.AssemblyBuilder.Location">
          <source>The location of the loaded file that contains the manifest.</source>
          <target state="translated">A localização do arquivo carregado que contém o manifesto.</target>       </trans-unit>
        <trans-unit id="616" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.AssemblyBuilder.Location">
          <source>If the loaded file has been shadow-copied, the <ph id="ph1">&lt;see langword="Location" /&gt;</ph> is that of the file before being shadow-copied.</source>
          <target state="translated">Se o arquivo carregado tiver sido copiado de sombra, o <ph id="ph1">&lt;see langword="Location" /&gt;</ph> é que o arquivo antes de ser copiado de sombra.</target>       </trans-unit>
        <trans-unit id="617" translate="yes" xml:space="preserve" uid="P:System.Reflection.Emit.AssemblyBuilder.Location">
          <source>This method is not currently supported.</source>
          <target state="translated">Não há suporte para este método atualmente.</target>       </trans-unit>
        <trans-unit id="618" translate="yes" xml:space="preserve" uid="P:System.Reflection.Emit.AssemblyBuilder.Location">
          <source>The caller does not have the required permission.</source>
          <target state="translated">O chamador não tem a permissão necessária.</target>       </trans-unit>
        <trans-unit id="619" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.AssemblyBuilder.Location">
          <source>when invoked late-bound through mechanisms such as <ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>.</source>
          <target state="translated">quando invocado com associação tardia por meio de mecanismos como <ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="620" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.AssemblyBuilder.Location">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph>.</source>
          <target state="translated">Enumeração associada: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="621" translate="yes" xml:space="preserve" uid="P:System.Reflection.Emit.AssemblyBuilder.ManifestModule">
          <source>Gets the module in the current <ph id="ph1">&lt;see cref="T:System.Reflection.Emit.AssemblyBuilder" /&gt;</ph> that contains the assembly manifest.</source>
          <target state="translated">Obtém o módulo no <ph id="ph1">&lt;see cref="T:System.Reflection.Emit.AssemblyBuilder" /&gt;</ph> atual que contém o manifesto do assembly.</target>       </trans-unit>
        <trans-unit id="622" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.AssemblyBuilder.ManifestModule">
          <source>The manifest module.</source>
          <target state="translated">O módulo de manifesto.</target>       </trans-unit>
        <trans-unit id="623" translate="yes" xml:space="preserve" uid="P:System.Reflection.Emit.AssemblyBuilder.PermissionSet">
          <source>Gets the grant set of the current dynamic assembly.</source>
          <target state="translated">Obtém o conjunto de concessões do assembly dinâmico atual.</target>       </trans-unit>
        <trans-unit id="624" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.AssemblyBuilder.PermissionSet">
          <source>The grant set of the current dynamic assembly.</source>
          <target state="translated">O conjunto de concessão do assembly dinâmico atual.</target>       </trans-unit>
        <trans-unit id="625" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.AssemblyBuilder.PermissionSet">
          <source><ph id="ph1">&lt;xref:System.Security.PermissionSet&gt;</ph> objects can contain sensitive information such as paths.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Security.PermissionSet&gt;</ph> objetos podem conter informações confidenciais, como caminhos.</target>       </trans-unit>
        <trans-unit id="626" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.AssemblyBuilder.PermissionSet">
          <source>Therefore, full trust is required to access these objects.</source>
          <target state="translated">Portanto, a confiança total é necessária para acessar esses objetos.</target>       </trans-unit>
        <trans-unit id="627" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.AssemblyBuilder.PermissionSet">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">requer confiança total para o chamador imediato.</target>       </trans-unit>
        <trans-unit id="628" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.AssemblyBuilder.PermissionSet">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Este membro não pode ser usado pelo código transparente ou parcialmente confiável.</target>       </trans-unit>
        <trans-unit id="629" translate="yes" xml:space="preserve" uid="P:System.Reflection.Emit.AssemblyBuilder.ReflectionOnly">
          <source>Gets a value indicating whether the dynamic assembly is in the reflection-only context.</source>
          <target state="translated">Obtém um valor que indica se o assembly dinâmico está no contexto de somente reflexão.</target>       </trans-unit>
        <trans-unit id="630" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.AssemblyBuilder.ReflectionOnly">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the dynamic assembly is in the reflection-only context; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> Se o assembly dinâmico está no contexto exclusivo de reflexão; Caso contrário, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="631" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.AssemblyBuilder.ReflectionOnly">
          <source>To emit a dynamic assembly in the reflection-only context, specify <ph id="ph1">&lt;xref:System.Reflection.Emit.AssemblyBuilderAccess.ReflectionOnly?displayProperty=nameWithType&gt;</ph> when you create the <ph id="ph2">&lt;xref:System.Reflection.Emit.AssemblyBuilder&gt;</ph>.</source>
          <target state="translated">Para emitir um assembly dinâmico no contexto exclusivo de reflexão, especifique <ph id="ph1">&lt;xref:System.Reflection.Emit.AssemblyBuilderAccess.ReflectionOnly?displayProperty=nameWithType&gt;</ph> quando você cria o <ph id="ph2">&lt;xref:System.Reflection.Emit.AssemblyBuilder&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="632" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.AssemblyBuilder.ReflectionOnly">
          <source>If a dynamic assembly is emitted in the reflection-only context, its code cannot be executed.</source>
          <target state="translated">Se um assembly dinâmico é emitido no contexto exclusivo de reflexão, seu código não pode ser executado.</target>       </trans-unit>
        <trans-unit id="633" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.AssemblyBuilder.ReflectionOnly">
          <source>After you have saved a dynamic assembly to disk, you can use the <ph id="ph1">&lt;xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A?displayProperty=nameWithType&gt;</ph> method to load the completed assembly into the reflection-only context.</source>
          <target state="translated">Depois que você salvou um assembly dinâmico em disco, você pode usar o <ph id="ph1">&lt;xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A?displayProperty=nameWithType&gt;</ph> método para carregar o assembly concluído no contexto exclusivo de reflexão.</target>       </trans-unit>
        <trans-unit id="634" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.AssemblyBuilder.ReflectionOnly">
          <source>However, the assembly can no longer be modified.</source>
          <target state="translated">No entanto, o assembly não pode mais ser modificado.</target>       </trans-unit>
        <trans-unit id="635" translate="yes" xml:space="preserve" uid="T:System.Reflection.Emit.AssemblyBuilder">
          <source>Saves this dynamic assembly to disk.</source>
          <target state="translated">Salva esse assembly dinâmico em disco.</target>       </trans-unit>
        <trans-unit id="636" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.AssemblyBuilder.Save(System.String)">
          <source>The file name of the assembly.</source>
          <target state="translated">O nome do arquivo do assembly.</target>       </trans-unit>
        <trans-unit id="637" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.AssemblyBuilder.Save(System.String)">
          <source>Saves this dynamic assembly to disk.</source>
          <target state="translated">Salva esse assembly dinâmico em disco.</target>       </trans-unit>
        <trans-unit id="638" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.AssemblyBuilder.Save(System.String)">
          <source>This method saves all non-transient dynamic modules defined in this dynamic assembly.</source>
          <target state="translated">Esse método salva todos os módulos dinâmicos não transitório definidos neste assembly dinâmico.</target>       </trans-unit>
        <trans-unit id="639" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.AssemblyBuilder.Save(System.String)">
          <source>Transient dynamic modules are not saved.</source>
          <target state="translated">Transitórios módulos dinâmicos não são salvas.</target>       </trans-unit>
        <trans-unit id="640" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.AssemblyBuilder.Save(System.String)">
          <source>The assembly file name can be the same as the name of one of the modules.</source>
          <target state="translated">O nome do arquivo de assembly pode ser igual ao nome de um dos módulos.</target>       </trans-unit>
        <trans-unit id="641" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.AssemblyBuilder.Save(System.String)">
          <source>If so, the assembly manifest is stored within that module.</source>
          <target state="translated">Nesse caso, o manifesto do assembly é armazenado no módulo.</target>       </trans-unit>
        <trans-unit id="642" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.AssemblyBuilder.Save(System.String)">
          <source><ph id="ph1">`assemblyFileName`</ph> can be different from the names of all of the modules contained within the assembly.</source>
          <target state="translated"><ph id="ph1">`assemblyFileName`</ph> pode ser diferente dos nomes de todos os módulos contidos dentro do assembly.</target>       </trans-unit>
        <trans-unit id="643" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.AssemblyBuilder.Save(System.String)">
          <source>If so, the assembly file contains only the assembly manifest.</source>
          <target state="translated">Nesse caso, o arquivo de assembly contém somente o manifesto do assembly.</target>       </trans-unit>
        <trans-unit id="644" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.AssemblyBuilder.Save(System.String)">
          <source>For each <ph id="ph1">&lt;xref:System.Resources.ResourceWriter&gt;</ph> obtained using <ph id="ph2">&lt;xref:System.Reflection.Emit.AssemblyBuilder.DefineResource%2A&gt;</ph>, this method writes the .resources file and calls <ph id="ph3">&lt;xref:System.Resources.ResourceWriter.Close%2A&gt;</ph> to close the stream.</source>
          <target state="translated">Para cada <ph id="ph1">&lt;xref:System.Resources.ResourceWriter&gt;</ph> obtidos usando <ph id="ph2">&lt;xref:System.Reflection.Emit.AssemblyBuilder.DefineResource%2A&gt;</ph>, esse método grava o arquivo. Resources e chamadas <ph id="ph3">&lt;xref:System.Resources.ResourceWriter.Close%2A&gt;</ph> para fechar o fluxo.</target>       </trans-unit>
        <trans-unit id="645" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.AssemblyBuilder.Save(System.String)">
          <source>The <ph id="ph1">`assemblyFileName`</ph> needs to be a simple file name without a drive or directory component.</source>
          <target state="translated">O <ph id="ph1">`assemblyFileName`</ph> deve ser um nome de arquivo simples sem um componente de unidade ou pasta.</target>       </trans-unit>
        <trans-unit id="646" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.AssemblyBuilder.Save(System.String)">
          <source>To create an assembly in a specific directory, use one of the <ph id="ph1">&lt;xref:System.AppDomain.DefineDynamicAssembly%2A&gt;</ph> methods that takes a target directory argument.</source>
          <target state="translated">Para criar um assembly em um diretório específico, use uma da <ph id="ph1">&lt;xref:System.AppDomain.DefineDynamicAssembly%2A&gt;</ph> métodos que usa um argumento de diretório de destino.</target>       </trans-unit>
        <trans-unit id="647" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.AssemblyBuilder.Save(System.String)">
          <source>In the .NET Framework version 2.0, this overload of the <ph id="ph1">&lt;xref:System.Reflection.Emit.AssemblyBuilder.Save%2A&gt;</ph> method is equivalent to calling the <ph id="ph2">&lt;xref:System.Reflection.Emit.AssemblyBuilder.Save%28System.String%2CSystem.Reflection.PortableExecutableKinds%2CSystem.Reflection.ImageFileMachine%29&gt;</ph> method overload with <ph id="ph3">&lt;xref:System.Reflection.PortableExecutableKinds.ILOnly&gt;</ph> for the <ph id="ph4">`portableExecutableKind`</ph> parameter and <ph id="ph5">&lt;xref:System.Reflection.ImageFileMachine.I386&gt;</ph> for the <ph id="ph6">`imageFileMachine`</ph> parameter.</source>
          <target state="translated">No .NET Framework versão 2.0, essa sobrecarga do <ph id="ph1">&lt;xref:System.Reflection.Emit.AssemblyBuilder.Save%2A&gt;</ph> método é equivalente a chamar o <ph id="ph2">&lt;xref:System.Reflection.Emit.AssemblyBuilder.Save%28System.String%2CSystem.Reflection.PortableExecutableKinds%2CSystem.Reflection.ImageFileMachine%29&gt;</ph> sobrecarga de método com <ph id="ph3">&lt;xref:System.Reflection.PortableExecutableKinds.ILOnly&gt;</ph> para o <ph id="ph4">`portableExecutableKind`</ph> parâmetro e <ph id="ph5">&lt;xref:System.Reflection.ImageFileMachine.I386&gt;</ph> para o <ph id="ph6">`imageFileMachine`</ph> parâmetro.</target>       </trans-unit>
        <trans-unit id="648" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.AssemblyBuilder.Save(System.String)">
          <source>The following code sample creates a dynamic assembly and then persists it to a local disk using <ph id="ph1">`Save`</ph>.</source>
          <target state="translated">O exemplo de código a seguir cria um assembly dinâmico e, em seguida, persisti-lo em um disco local usando <ph id="ph1">`Save`</ph>.</target>       </trans-unit>
        <trans-unit id="649" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.AssemblyBuilder.Save(System.String)">
          <source>The length of <ph id="ph1">&lt;paramref name="assemblyFileName" /&gt;</ph> is 0.</source>
          <target state="translated">O tamanho de <ph id="ph1">&lt;paramref name="assemblyFileName" /&gt;</ph> é 0.</target>       </trans-unit>
        <trans-unit id="650" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.AssemblyBuilder.Save(System.String)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="651" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.AssemblyBuilder.Save(System.String)">
          <source>There are two or more modules resource files in the assembly with the same name.</source>
          <target state="translated">Existem dois ou mais arquivos de recursos de módulos no assembly com o mesmo nome.</target>       </trans-unit>
        <trans-unit id="652" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.AssemblyBuilder.Save(System.String)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="653" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.AssemblyBuilder.Save(System.String)">
          <source>The target directory of the assembly is invalid.</source>
          <target state="translated">O diretório de destino do assembly é inválido.</target>       </trans-unit>
        <trans-unit id="654" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.AssemblyBuilder.Save(System.String)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="655" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.AssemblyBuilder.Save(System.String)">
          <source><ph id="ph1">&lt;paramref name="assemblyFileName" /&gt;</ph> is not a simple file name (for example, has a directory or drive component), or more than one unmanaged resource, including a version information resource, was defined in this assembly.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="assemblyFileName" /&gt;</ph> não é um nome de arquivo simples (por exemplo, tem um diretório ou componente de unidade) ou mais de um recurso não gerenciado, incluindo um recurso de informações de versão, foi definido neste assembly.</target>       </trans-unit>
        <trans-unit id="656" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.AssemblyBuilder.Save(System.String)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="657" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.AssemblyBuilder.Save(System.String)">
          <source>The <ph id="ph1">&lt;see langword="CultureInfo" /&gt;</ph> string in <ph id="ph2">&lt;see cref="T:System.Reflection.AssemblyCultureAttribute" /&gt;</ph> is not a valid string and <ph id="ph3">&lt;see cref="M:System.Reflection.Emit.AssemblyBuilder.DefineVersionInfoResource(System.String,System.String,System.String,System.String,System.String)" /&gt;</ph> was called prior to calling this method.</source>
          <target state="translated">A cadeia de caracteres <ph id="ph1">&lt;see langword="CultureInfo" /&gt;</ph> em <ph id="ph2">&lt;see cref="T:System.Reflection.AssemblyCultureAttribute" /&gt;</ph> não é uma cadeia de caracteres válida e <ph id="ph3">&lt;see cref="M:System.Reflection.Emit.AssemblyBuilder.DefineVersionInfoResource(System.String,System.String,System.String,System.String,System.String)" /&gt;</ph> foi chamado antes de chamar esse método.</target>       </trans-unit>
        <trans-unit id="658" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.AssemblyBuilder.Save(System.String)">
          <source><ph id="ph1">&lt;paramref name="assemblyFileName" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="assemblyFileName" /&gt;</ph> é <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="659" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.AssemblyBuilder.Save(System.String)">
          <source>This assembly has been saved before.</source>
          <target state="translated">Esse assembly foi salvo antes.</target>       </trans-unit>
        <trans-unit id="660" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.AssemblyBuilder.Save(System.String)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="661" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.AssemblyBuilder.Save(System.String)">
          <source>This assembly has access <ph id="ph1">&lt;see langword="Run" /&gt;</ph><ph id="ph2">&lt;see cref="T:System.Reflection.Emit.AssemblyBuilderAccess" /&gt;</ph></source>
          <target state="translated">Esse assembly tem acesso <ph id="ph1">&lt;see langword="Run" /&gt;</ph><ph id="ph2">&lt;see cref="T:System.Reflection.Emit.AssemblyBuilderAccess" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="662" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.AssemblyBuilder.Save(System.String)">
          <source>An output error occurs during the save.</source>
          <target state="translated">Ocorre um erro de saída durante o salvamento.</target>       </trans-unit>
        <trans-unit id="663" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.AssemblyBuilder.Save(System.String)">
          <source><ph id="ph1">&lt;see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /&gt;</ph> has not been called for any of the types in the modules of the assembly to be written to disk.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /&gt;</ph> não foi chamado para qualquer um dos tipos nos módulos do assembly a ser gravado no disco.</target>       </trans-unit>
        <trans-unit id="664" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.AssemblyBuilder.Save(System.String)">
          <source>Write = true or Append = true is needed to save this assembly to the specified file name.</source>
          <target state="translated">Gravar = true ou acrescentar = true é necessária para salvar esse assembly para o nome de arquivo especificado.</target>       </trans-unit>
        <trans-unit id="665" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.AssemblyBuilder.Save(System.String)">
          <source>when invoked late-bound through mechanisms such as <ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>.</source>
          <target state="translated">quando invocado com associação tardia por meio de mecanismos como <ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="666" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.AssemblyBuilder.Save(System.String)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph>.</source>
          <target state="translated">Enumeração associada: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="667" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.AssemblyBuilder.Save(System.String,System.Reflection.PortableExecutableKinds,System.Reflection.ImageFileMachine)">
          <source>The file name of the assembly.</source>
          <target state="translated">O nome do arquivo do assembly.</target>       </trans-unit>
        <trans-unit id="668" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.AssemblyBuilder.Save(System.String,System.Reflection.PortableExecutableKinds,System.Reflection.ImageFileMachine)">
          <source>A bitwise combination of the <ph id="ph1">&lt;see cref="T:System.Reflection.PortableExecutableKinds" /&gt;</ph> values that specifies the nature of the code.</source>
          <target state="translated">Uma combinação bit a bit dos valores <ph id="ph1">&lt;see cref="T:System.Reflection.PortableExecutableKinds" /&gt;</ph> que especificam a natureza do código.</target>       </trans-unit>
        <trans-unit id="669" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.AssemblyBuilder.Save(System.String,System.Reflection.PortableExecutableKinds,System.Reflection.ImageFileMachine)">
          <source>One of the <ph id="ph1">&lt;see cref="T:System.Reflection.ImageFileMachine" /&gt;</ph> values that specifies the target platform.</source>
          <target state="translated">Um dos valores <ph id="ph1">&lt;see cref="T:System.Reflection.ImageFileMachine" /&gt;</ph> que especifica a plataforma de destino.</target>       </trans-unit>
        <trans-unit id="670" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.AssemblyBuilder.Save(System.String,System.Reflection.PortableExecutableKinds,System.Reflection.ImageFileMachine)">
          <source>Saves this dynamic assembly to disk, specifying the nature of code in the assembly's executables and the target platform.</source>
          <target state="translated">Salva esse assembly dinâmico no disco, especificando a natureza do código nos executáveis do assembly e na plataforma de destino.</target>       </trans-unit>
        <trans-unit id="671" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.AssemblyBuilder.Save(System.String,System.Reflection.PortableExecutableKinds,System.Reflection.ImageFileMachine)">
          <source>If <ph id="ph1">`imageFileMachine`</ph> and <ph id="ph2">`portableExecutableKind`</ph> are incompatible, <ph id="ph3">`imageFileMachine`</ph> takes precedence over <ph id="ph4">`portableExecutableKind`</ph>.</source>
          <target state="translated">Se <ph id="ph1">`imageFileMachine`</ph> e <ph id="ph2">`portableExecutableKind`</ph> são incompatíveis, <ph id="ph3">`imageFileMachine`</ph> tem precedência sobre <ph id="ph4">`portableExecutableKind`</ph>.</target>       </trans-unit>
        <trans-unit id="672" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.AssemblyBuilder.Save(System.String,System.Reflection.PortableExecutableKinds,System.Reflection.ImageFileMachine)">
          <source>No exception is thrown.</source>
          <target state="translated">Nenhuma exceção é lançada.</target>       </trans-unit>
        <trans-unit id="673" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.AssemblyBuilder.Save(System.String,System.Reflection.PortableExecutableKinds,System.Reflection.ImageFileMachine)">
          <source>For example, if you specify <ph id="ph1">&lt;xref:System.Reflection.ImageFileMachine.I386?displayProperty=nameWithType&gt;</ph> with <ph id="ph2">&lt;xref:System.Reflection.PortableExecutableKinds.PE32Plus?displayProperty=nameWithType&gt;</ph>, <ph id="ph3">&lt;xref:System.Reflection.PortableExecutableKinds.PE32Plus?displayProperty=nameWithType&gt;</ph> is ignored.</source>
          <target state="translated">Por exemplo, se você especificar <ph id="ph1">&lt;xref:System.Reflection.ImageFileMachine.I386?displayProperty=nameWithType&gt;</ph> com <ph id="ph2">&lt;xref:System.Reflection.PortableExecutableKinds.PE32Plus?displayProperty=nameWithType&gt;</ph>, <ph id="ph3">&lt;xref:System.Reflection.PortableExecutableKinds.PE32Plus?displayProperty=nameWithType&gt;</ph> será ignorado.</target>       </trans-unit>
        <trans-unit id="674" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.AssemblyBuilder.Save(System.String,System.Reflection.PortableExecutableKinds,System.Reflection.ImageFileMachine)">
          <source>This method saves all non-transient dynamic modules defined in this dynamic assembly.</source>
          <target state="translated">Esse método salva todos os módulos dinâmicos não transitório definidos neste assembly dinâmico.</target>       </trans-unit>
        <trans-unit id="675" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.AssemblyBuilder.Save(System.String,System.Reflection.PortableExecutableKinds,System.Reflection.ImageFileMachine)">
          <source>Transient dynamic modules are not saved.</source>
          <target state="translated">Transitórios módulos dinâmicos não são salvas.</target>       </trans-unit>
        <trans-unit id="676" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.AssemblyBuilder.Save(System.String,System.Reflection.PortableExecutableKinds,System.Reflection.ImageFileMachine)">
          <source>The assembly file name can be the same as the name of one of the module.</source>
          <target state="translated">O nome do arquivo de assembly pode ser o mesmo que o nome de um módulo.</target>       </trans-unit>
        <trans-unit id="677" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.AssemblyBuilder.Save(System.String,System.Reflection.PortableExecutableKinds,System.Reflection.ImageFileMachine)">
          <source>If so, the assembly manifest is stored within that module.</source>
          <target state="translated">Nesse caso, o manifesto do assembly é armazenado no módulo.</target>       </trans-unit>
        <trans-unit id="678" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.AssemblyBuilder.Save(System.String,System.Reflection.PortableExecutableKinds,System.Reflection.ImageFileMachine)">
          <source><ph id="ph1">`assemblyFileName`</ph> can be different from the names of all of the modules contained within the assembly.</source>
          <target state="translated"><ph id="ph1">`assemblyFileName`</ph> pode ser diferente dos nomes de todos os módulos contidos dentro do assembly.</target>       </trans-unit>
        <trans-unit id="679" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.AssemblyBuilder.Save(System.String,System.Reflection.PortableExecutableKinds,System.Reflection.ImageFileMachine)">
          <source>If so, the assembly file contains only the assembly manifest.</source>
          <target state="translated">Nesse caso, o arquivo de assembly contém somente o manifesto do assembly.</target>       </trans-unit>
        <trans-unit id="680" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.AssemblyBuilder.Save(System.String,System.Reflection.PortableExecutableKinds,System.Reflection.ImageFileMachine)">
          <source>For each <ph id="ph1">&lt;xref:System.Resources.ResourceWriter&gt;</ph> obtained using <ph id="ph2">&lt;xref:System.Reflection.Emit.AssemblyBuilder.DefineResource%2A&gt;</ph>, this method writes the .resources file and calls <ph id="ph3">&lt;xref:System.Resources.ResourceWriter.Close%2A&gt;</ph> to close the stream.</source>
          <target state="translated">Para cada <ph id="ph1">&lt;xref:System.Resources.ResourceWriter&gt;</ph> obtidos usando <ph id="ph2">&lt;xref:System.Reflection.Emit.AssemblyBuilder.DefineResource%2A&gt;</ph>, esse método grava o arquivo. Resources e chamadas <ph id="ph3">&lt;xref:System.Resources.ResourceWriter.Close%2A&gt;</ph> para fechar o fluxo.</target>       </trans-unit>
        <trans-unit id="681" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.AssemblyBuilder.Save(System.String,System.Reflection.PortableExecutableKinds,System.Reflection.ImageFileMachine)">
          <source>The <ph id="ph1">`assemblyFileName`</ph> needs to be a simple file name without a drive or directory component.</source>
          <target state="translated">O <ph id="ph1">`assemblyFileName`</ph> deve ser um nome de arquivo simples sem um componente de unidade ou pasta.</target>       </trans-unit>
        <trans-unit id="682" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.AssemblyBuilder.Save(System.String,System.Reflection.PortableExecutableKinds,System.Reflection.ImageFileMachine)">
          <source>To create an assembly in a specific directory, use one of the <ph id="ph1">&lt;xref:System.AppDomain.DefineDynamicAssembly%2A&gt;</ph> methods that takes a target directory argument.</source>
          <target state="translated">Para criar um assembly em um diretório específico, use uma da <ph id="ph1">&lt;xref:System.AppDomain.DefineDynamicAssembly%2A&gt;</ph> métodos que usa um argumento de diretório de destino.</target>       </trans-unit>
        <trans-unit id="683" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.AssemblyBuilder.Save(System.String,System.Reflection.PortableExecutableKinds,System.Reflection.ImageFileMachine)">
          <source>The length of <ph id="ph1">&lt;paramref name="assemblyFileName" /&gt;</ph> is 0.</source>
          <target state="translated">O tamanho de <ph id="ph1">&lt;paramref name="assemblyFileName" /&gt;</ph> é 0.</target>       </trans-unit>
        <trans-unit id="684" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.AssemblyBuilder.Save(System.String,System.Reflection.PortableExecutableKinds,System.Reflection.ImageFileMachine)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="685" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.AssemblyBuilder.Save(System.String,System.Reflection.PortableExecutableKinds,System.Reflection.ImageFileMachine)">
          <source>There are two or more modules resource files in the assembly with the same name.</source>
          <target state="translated">Existem dois ou mais arquivos de recursos de módulos no assembly com o mesmo nome.</target>       </trans-unit>
        <trans-unit id="686" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.AssemblyBuilder.Save(System.String,System.Reflection.PortableExecutableKinds,System.Reflection.ImageFileMachine)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="687" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.AssemblyBuilder.Save(System.String,System.Reflection.PortableExecutableKinds,System.Reflection.ImageFileMachine)">
          <source>The target directory of the assembly is invalid.</source>
          <target state="translated">O diretório de destino do assembly é inválido.</target>       </trans-unit>
        <trans-unit id="688" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.AssemblyBuilder.Save(System.String,System.Reflection.PortableExecutableKinds,System.Reflection.ImageFileMachine)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="689" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.AssemblyBuilder.Save(System.String,System.Reflection.PortableExecutableKinds,System.Reflection.ImageFileMachine)">
          <source><ph id="ph1">&lt;paramref name="assemblyFileName" /&gt;</ph> is not a simple file name (for example, has a directory or drive component), or more than one unmanaged resource, including a version information resources, was defined in this assembly.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="assemblyFileName" /&gt;</ph> não é um nome de arquivo simples (por exemplo, tem um diretório ou um componente de unidade) ou mais de um recurso não gerenciado, incluindo um recurso de informações de versão, foi definido neste assembly.</target>       </trans-unit>
        <trans-unit id="690" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.AssemblyBuilder.Save(System.String,System.Reflection.PortableExecutableKinds,System.Reflection.ImageFileMachine)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="691" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.AssemblyBuilder.Save(System.String,System.Reflection.PortableExecutableKinds,System.Reflection.ImageFileMachine)">
          <source>The <ph id="ph1">&lt;see langword="CultureInfo" /&gt;</ph> string in <ph id="ph2">&lt;see cref="T:System.Reflection.AssemblyCultureAttribute" /&gt;</ph> is not a valid string and <ph id="ph3">&lt;see cref="M:System.Reflection.Emit.AssemblyBuilder.DefineVersionInfoResource(System.String,System.String,System.String,System.String,System.String)" /&gt;</ph> was called prior to calling this method.</source>
          <target state="translated">A cadeia de caracteres <ph id="ph1">&lt;see langword="CultureInfo" /&gt;</ph> em <ph id="ph2">&lt;see cref="T:System.Reflection.AssemblyCultureAttribute" /&gt;</ph> não é uma cadeia de caracteres válida e <ph id="ph3">&lt;see cref="M:System.Reflection.Emit.AssemblyBuilder.DefineVersionInfoResource(System.String,System.String,System.String,System.String,System.String)" /&gt;</ph> foi chamado antes de chamar esse método.</target>       </trans-unit>
        <trans-unit id="692" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.AssemblyBuilder.Save(System.String,System.Reflection.PortableExecutableKinds,System.Reflection.ImageFileMachine)">
          <source><ph id="ph1">&lt;paramref name="assemblyFileName" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="assemblyFileName" /&gt;</ph> é <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="693" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.AssemblyBuilder.Save(System.String,System.Reflection.PortableExecutableKinds,System.Reflection.ImageFileMachine)">
          <source>This assembly has been saved before.</source>
          <target state="translated">Esse assembly foi salvo antes.</target>       </trans-unit>
        <trans-unit id="694" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.AssemblyBuilder.Save(System.String,System.Reflection.PortableExecutableKinds,System.Reflection.ImageFileMachine)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="695" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.AssemblyBuilder.Save(System.String,System.Reflection.PortableExecutableKinds,System.Reflection.ImageFileMachine)">
          <source>This assembly has access <ph id="ph1">&lt;see langword="Run" /&gt;</ph><ph id="ph2">&lt;see cref="T:System.Reflection.Emit.AssemblyBuilderAccess" /&gt;</ph></source>
          <target state="translated">Esse assembly tem acesso <ph id="ph1">&lt;see langword="Run" /&gt;</ph><ph id="ph2">&lt;see cref="T:System.Reflection.Emit.AssemblyBuilderAccess" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="696" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.AssemblyBuilder.Save(System.String,System.Reflection.PortableExecutableKinds,System.Reflection.ImageFileMachine)">
          <source>An output error occurs during the save.</source>
          <target state="translated">Ocorre um erro de saída durante o salvamento.</target>       </trans-unit>
        <trans-unit id="697" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.AssemblyBuilder.Save(System.String,System.Reflection.PortableExecutableKinds,System.Reflection.ImageFileMachine)">
          <source><ph id="ph1">&lt;see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /&gt;</ph> has not been called for any of the types in the modules of the assembly to be written to disk.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /&gt;</ph> não foi chamado para qualquer um dos tipos nos módulos do assembly a ser gravado no disco.</target>       </trans-unit>
        <trans-unit id="698" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.AssemblyBuilder.Save(System.String,System.Reflection.PortableExecutableKinds,System.Reflection.ImageFileMachine)">
          <source>Write = true or Append = true is needed to save this assembly to the specified file name.</source>
          <target state="translated">Gravar = true ou acrescentar = true é necessária para salvar esse assembly para o nome de arquivo especificado.</target>       </trans-unit>
        <trans-unit id="699" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.AssemblyBuilder.Save(System.String,System.Reflection.PortableExecutableKinds,System.Reflection.ImageFileMachine)">
          <source>when invoked late-bound through mechanisms such as <ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>.</source>
          <target state="translated">quando invocado com associação tardia por meio de mecanismos como <ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="700" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.AssemblyBuilder.Save(System.String,System.Reflection.PortableExecutableKinds,System.Reflection.ImageFileMachine)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph>.</source>
          <target state="translated">Enumeração associada: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="701" translate="yes" xml:space="preserve" uid="P:System.Reflection.Emit.AssemblyBuilder.SecurityRuleSet">
          <source>Gets a value that indicates which set of security rules the common language runtime (CLR) enforces for this assembly.</source>
          <target state="translated">Obtém um valor que indica qual conjunto de regras de segurança o CLR (Common Language Runtime) impõe a este assembly.</target>       </trans-unit>
        <trans-unit id="702" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.AssemblyBuilder.SecurityRuleSet">
          <source>The security rule set that the CLR enforces for this dynamic assembly.</source>
          <target state="translated">O conjunto de regras de segurança que o CLR impõe a este assembly dinâmico.</target>       </trans-unit>
        <trans-unit id="703" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.AssemblyBuilder.SecurityRuleSet">
          <source>The <ph id="ph1">[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]</ph> always enforces level 2 transparency (<ph id="ph2">&lt;xref:System.Security.SecurityRuleSet.Level2?displayProperty=nameWithType&gt;</ph>) for the dynamic assemblies it generates.</source>
          <target state="translated">O <ph id="ph1">[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]</ph> sempre impõe a transparência de nível 2 (<ph id="ph2">&lt;xref:System.Security.SecurityRuleSet.Level2?displayProperty=nameWithType&gt;</ph>) para os assemblies dinâmicos gera.</target>       </trans-unit>
        <trans-unit id="704" translate="yes" xml:space="preserve" uid="T:System.Reflection.Emit.AssemblyBuilder">
          <source>Sets a custom attribute on this assembly.</source>
          <target state="translated">Define um atributo personalizado neste assembly.</target>       </trans-unit>
        <trans-unit id="705" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.AssemblyBuilder.SetCustomAttribute(System.Reflection.Emit.CustomAttributeBuilder)">
          <source>An instance of a helper class to define the custom attribute.</source>
          <target state="translated">Uma instância de uma classe auxiliar para definir o atributo personalizado.</target>       </trans-unit>
        <trans-unit id="706" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.AssemblyBuilder.SetCustomAttribute(System.Reflection.Emit.CustomAttributeBuilder)">
          <source>Set a custom attribute on this assembly using a custom attribute builder.</source>
          <target state="translated">Defina um atributo personalizado neste assembly usando um construtor de atributos personalizados.</target>       </trans-unit>
        <trans-unit id="707" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.AssemblyBuilder.SetCustomAttribute(System.Reflection.Emit.CustomAttributeBuilder)">
          <source><ph id="ph1">&lt;xref:System.Reflection.Emit.AssemblyBuilder.SetCustomAttribute%2A&gt;</ph> cannot be used to set declarative security attributes.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Reflection.Emit.AssemblyBuilder.SetCustomAttribute%2A&gt;</ph> não pode ser usado para definir atributos de segurança declarativa.</target>       </trans-unit>
        <trans-unit id="708" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.AssemblyBuilder.SetCustomAttribute(System.Reflection.Emit.CustomAttributeBuilder)">
          <source>Use one of the overloads of <ph id="ph1">&lt;xref:System.AppDomain.DefineDynamicAssembly%2A&gt;</ph> that takes required, optional, and refused permissions.</source>
          <target state="translated">Use uma das sobrecargas de <ph id="ph1">&lt;xref:System.AppDomain.DefineDynamicAssembly%2A&gt;</ph> que usa exigido, opcionais e recusada permissões.</target>       </trans-unit>
        <trans-unit id="709" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.AssemblyBuilder.SetCustomAttribute(System.Reflection.Emit.CustomAttributeBuilder)">
          <source>Starting with the <ph id="ph1">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</ph>, this member no longer requires <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> with the <ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType&gt;</ph> flag.</source>
          <target state="translated">Começando com o <ph id="ph1">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</ph>, esse membro não requer mais <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> com o <ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType&gt;</ph> sinalizador.</target>       </trans-unit>
        <trans-unit id="710" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.AssemblyBuilder.SetCustomAttribute(System.Reflection.Emit.CustomAttributeBuilder)">
          <source>(See <bpt id="p1">[</bpt>Security Issues in Reflection Emit<ept id="p1">](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)</ept>.) To use this functionality, your application should target the <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> or later.</source>
          <target state="translated">(Consulte <bpt id="p1">[</bpt>problemas de segurança em reflexão emitir<ept id="p1">](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)</ept>.) Para usar essa funcionalidade, seu aplicativo deve ser direcionado ao <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> ou posterior.</target>       </trans-unit>
        <trans-unit id="711" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.AssemblyBuilder.SetCustomAttribute(System.Reflection.Emit.CustomAttributeBuilder)">
          <source>The following code sample illustrates the use of <ph id="ph1">`SetCustomAttribute`</ph> within <ph id="ph2">&lt;xref:System.Reflection.Emit.AssemblyBuilder&gt;</ph>, using a <ph id="ph3">&lt;xref:System.Reflection.Emit.CustomAttributeBuilder&gt;</ph>.</source>
          <target state="translated">O exemplo de código a seguir ilustra o uso de <ph id="ph1">`SetCustomAttribute`</ph> em <ph id="ph2">&lt;xref:System.Reflection.Emit.AssemblyBuilder&gt;</ph>usando um <ph id="ph3">&lt;xref:System.Reflection.Emit.CustomAttributeBuilder&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="712" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.AssemblyBuilder.SetCustomAttribute(System.Reflection.Emit.CustomAttributeBuilder)">
          <source><ph id="ph1">&lt;paramref name="con" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="con" /&gt;</ph> é <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="713" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.AssemblyBuilder.SetCustomAttribute(System.Reflection.Emit.CustomAttributeBuilder)">
          <source>The caller does not have the required permission.</source>
          <target state="translated">O chamador não tem a permissão necessária.</target>       </trans-unit>
        <trans-unit id="714" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.AssemblyBuilder.SetCustomAttribute(System.Reflection.Emit.CustomAttributeBuilder)">
          <source>when invoked late-bound through mechanisms such as <ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>.</source>
          <target state="translated">quando invocado com associação tardia por meio de mecanismos como <ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="715" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.AssemblyBuilder.SetCustomAttribute(System.Reflection.Emit.CustomAttributeBuilder)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph>.</source>
          <target state="translated">Enumeração associada: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="716" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.AssemblyBuilder.SetCustomAttribute(System.Reflection.ConstructorInfo,System.Byte[])">
          <source>The constructor for the custom attribute.</source>
          <target state="translated">O construtor do atributo personalizado.</target>       </trans-unit>
        <trans-unit id="717" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.AssemblyBuilder.SetCustomAttribute(System.Reflection.ConstructorInfo,System.Byte[])">
          <source>A byte blob representing the attributes.</source>
          <target state="translated">Um blob de bytes que representa os atributos.</target>       </trans-unit>
        <trans-unit id="718" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.AssemblyBuilder.SetCustomAttribute(System.Reflection.ConstructorInfo,System.Byte[])">
          <source>Set a custom attribute on this assembly using a specified custom attribute blob.</source>
          <target state="translated">Defina um atributo personalizado neste assembly usando um blob de atributos personalizados especificado.</target>       </trans-unit>
        <trans-unit id="719" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.AssemblyBuilder.SetCustomAttribute(System.Reflection.ConstructorInfo,System.Byte[])">
          <source>See the metadata specification in the ECMA Partition II documentation for details on how to format <ph id="ph1">`binaryAttribute`</ph>.</source>
          <target state="translated">Consulte a especificação de metadados na documentação do ECMA partição II para obter detalhes sobre como formatar <ph id="ph1">`binaryAttribute`</ph>.</target>       </trans-unit>
        <trans-unit id="720" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.AssemblyBuilder.SetCustomAttribute(System.Reflection.ConstructorInfo,System.Byte[])">
          <source>The documentation is available online; see <bpt id="p1">[</bpt>ECMA C# and Common Language Infrastructure Standards<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=99212)</ept> on MSDN and <bpt id="p2">[</bpt>Standard ECMA-335 - Common Language Infrastructure (CLI)<ept id="p2">](http://go.microsoft.com/fwlink/?LinkID=65552)</ept> on the Ecma International Web site.</source>
          <target state="translated">A documentação está disponível online; confira <bpt id="p1">[</bpt>ECMA C# and Common Language Infrastructure Standards<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=99212)</ept>, no MSDN, e <bpt id="p2">[</bpt>Standard ECMA-335 - Common Language Infrastructure (CLI)<ept id="p2">](http://go.microsoft.com/fwlink/?LinkID=65552)</ept>, no site internacional da Ecma.</target>       </trans-unit>
        <trans-unit id="721" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.AssemblyBuilder.SetCustomAttribute(System.Reflection.ConstructorInfo,System.Byte[])">
          <source><ph id="ph1">`RuntimeConstructorInfo`</ph> is a special type generated by the system.</source>
          <target state="translated"><ph id="ph1">`RuntimeConstructorInfo`</ph> um tipo especial é gerado pelo sistema.</target>       </trans-unit>
        <trans-unit id="722" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.AssemblyBuilder.SetCustomAttribute(System.Reflection.ConstructorInfo,System.Byte[])">
          <source>It derives from the <ph id="ph1">&lt;xref:System.Reflection.ConstructorInfo&gt;</ph> class, and any <ph id="ph2">&lt;xref:System.Reflection.ConstructorInfo&gt;</ph> object you obtain through reflection is actually an instance of <ph id="ph3">`RuntimeConstructorInfo`</ph>.</source>
          <target state="translated">Ele deriva o <ph id="ph1">&lt;xref:System.Reflection.ConstructorInfo&gt;</ph> classe e qualquer <ph id="ph2">&lt;xref:System.Reflection.ConstructorInfo&gt;</ph> obter por meio de reflexo de objeto é, na verdade, uma instância do <ph id="ph3">`RuntimeConstructorInfo`</ph>.</target>       </trans-unit>
        <trans-unit id="723" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.AssemblyBuilder.SetCustomAttribute(System.Reflection.ConstructorInfo,System.Byte[])">
          <source><ph id="ph1">&lt;xref:System.Reflection.Emit.AssemblyBuilder.SetCustomAttribute%2A&gt;</ph> cannot be used to set declarative security attributes.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Reflection.Emit.AssemblyBuilder.SetCustomAttribute%2A&gt;</ph> não pode ser usado para definir atributos de segurança declarativa.</target>       </trans-unit>
        <trans-unit id="724" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.AssemblyBuilder.SetCustomAttribute(System.Reflection.ConstructorInfo,System.Byte[])">
          <source>Use one of the overloads of <ph id="ph1">&lt;xref:System.AppDomain.DefineDynamicAssembly%2A&gt;</ph> that takes required, optional, and refused permissions.</source>
          <target state="translated">Use uma das sobrecargas de <ph id="ph1">&lt;xref:System.AppDomain.DefineDynamicAssembly%2A&gt;</ph> que usa exigido, opcionais e recusada permissões.</target>       </trans-unit>
        <trans-unit id="725" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.AssemblyBuilder.SetCustomAttribute(System.Reflection.ConstructorInfo,System.Byte[])">
          <source>Starting with the <ph id="ph1">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</ph>, this member no longer requires <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> with the <ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType&gt;</ph> flag.</source>
          <target state="translated">Começando com o <ph id="ph1">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</ph>, esse membro não requer mais <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> com o <ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType&gt;</ph> sinalizador.</target>       </trans-unit>
        <trans-unit id="726" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.AssemblyBuilder.SetCustomAttribute(System.Reflection.ConstructorInfo,System.Byte[])">
          <source>(See <bpt id="p1">[</bpt>Security Issues in Reflection Emit<ept id="p1">](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)</ept>.) To use this functionality, your application should target the <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> or later.</source>
          <target state="translated">(Consulte <bpt id="p1">[</bpt>problemas de segurança em reflexão emitir<ept id="p1">](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)</ept>.) Para usar essa funcionalidade, seu aplicativo deve ser direcionado ao <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> ou posterior.</target>       </trans-unit>
        <trans-unit id="727" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.AssemblyBuilder.SetCustomAttribute(System.Reflection.ConstructorInfo,System.Byte[])">
          <source>The following code sample illustrates the use of <ph id="ph1">`SetCustomAttribute`</ph> to attach a custom attribute to a dynamically generated assembly.</source>
          <target state="translated">O exemplo de código a seguir ilustra o uso de <ph id="ph1">`SetCustomAttribute`</ph> para anexar um atributo personalizado a um assembly gerado dinamicamente.</target>       </trans-unit>
        <trans-unit id="728" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.AssemblyBuilder.SetCustomAttribute(System.Reflection.ConstructorInfo,System.Byte[])">
          <source><ph id="ph1">&lt;paramref name="con" /&gt;</ph> or <ph id="ph2">&lt;paramref name="binaryAttribute" /&gt;</ph> is <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="con" /&gt;</ph> ou <ph id="ph2">&lt;paramref name="binaryAttribute" /&gt;</ph> é <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="729" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.AssemblyBuilder.SetCustomAttribute(System.Reflection.ConstructorInfo,System.Byte[])">
          <source>The caller does not have the required permission.</source>
          <target state="translated">O chamador não tem a permissão necessária.</target>       </trans-unit>
        <trans-unit id="730" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.AssemblyBuilder.SetCustomAttribute(System.Reflection.ConstructorInfo,System.Byte[])">
          <source><ph id="ph1">&lt;paramref name="con" /&gt;</ph> is not a <ph id="ph2">&lt;see langword="RuntimeConstructorInfo" /&gt;</ph> object.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="con" /&gt;</ph> não é um objeto <ph id="ph2">&lt;see langword="RuntimeConstructorInfo" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="731" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.AssemblyBuilder.SetCustomAttribute(System.Reflection.ConstructorInfo,System.Byte[])">
          <source>when invoked late-bound through mechanisms such as <ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>.</source>
          <target state="translated">quando invocado com associação tardia por meio de mecanismos como <ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="732" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.AssemblyBuilder.SetCustomAttribute(System.Reflection.ConstructorInfo,System.Byte[])">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph>.</source>
          <target state="translated">Enumeração associada: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="733" translate="yes" xml:space="preserve" uid="T:System.Reflection.Emit.AssemblyBuilder">
          <source>Sets the entry point for this dynamic assembly.</source>
          <target state="translated">Define o ponto de entrada para este assembly dinâmico.</target>       </trans-unit>
        <trans-unit id="734" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.AssemblyBuilder.SetEntryPoint(System.Reflection.MethodInfo)">
          <source>A reference to the method that represents the entry point for this dynamic assembly.</source>
          <target state="translated">Uma referência ao método que representa o ponto de entrada para este assembly dinâmico.</target>       </trans-unit>
        <trans-unit id="735" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.AssemblyBuilder.SetEntryPoint(System.Reflection.MethodInfo)">
          <source>Sets the entry point for this dynamic assembly, assuming that a console application is being built.</source>
          <target state="translated">Define o ponto de entrada para este assembly dinâmico, supondo que um aplicativo de console está sendo compilado.</target>       </trans-unit>
        <trans-unit id="736" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.AssemblyBuilder.SetEntryPoint(System.Reflection.MethodInfo)">
          <source><ph id="ph1">&lt;paramref name="entryMethod" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="entryMethod" /&gt;</ph> é <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="737" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.AssemblyBuilder.SetEntryPoint(System.Reflection.MethodInfo)">
          <source><ph id="ph1">&lt;paramref name="entryMethod" /&gt;</ph> is not contained within this assembly.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="entryMethod" /&gt;</ph> não está contido nesse assembly.</target>       </trans-unit>
        <trans-unit id="738" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.AssemblyBuilder.SetEntryPoint(System.Reflection.MethodInfo)">
          <source>The caller does not have the required permission.</source>
          <target state="translated">O chamador não tem a permissão necessária.</target>       </trans-unit>
        <trans-unit id="739" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.AssemblyBuilder.SetEntryPoint(System.Reflection.MethodInfo)">
          <source>when invoked late-bound through mechanisms such as <ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>.</source>
          <target state="translated">quando invocado com associação tardia por meio de mecanismos como <ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="740" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.AssemblyBuilder.SetEntryPoint(System.Reflection.MethodInfo)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph>.</source>
          <target state="translated">Enumeração associada: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="741" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.AssemblyBuilder.SetEntryPoint(System.Reflection.MethodInfo,System.Reflection.Emit.PEFileKinds)">
          <source>A reference to the method that represents the entry point for this dynamic assembly.</source>
          <target state="translated">Uma referência ao método que representa o ponto de entrada para este assembly dinâmico.</target>       </trans-unit>
        <trans-unit id="742" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.AssemblyBuilder.SetEntryPoint(System.Reflection.MethodInfo,System.Reflection.Emit.PEFileKinds)">
          <source>The type of the assembly executable being built.</source>
          <target state="translated">O tipo do executável do assembly que está sendo compilado.</target>       </trans-unit>
        <trans-unit id="743" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.AssemblyBuilder.SetEntryPoint(System.Reflection.MethodInfo,System.Reflection.Emit.PEFileKinds)">
          <source>Sets the entry point for this assembly and defines the type of the portable executable (PE file) being built.</source>
          <target state="translated">Define o ponto de entrada para este assembly e define o tipo de arquivo PE (executável portátil) que está sendo compilado.</target>       </trans-unit>
        <trans-unit id="744" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.AssemblyBuilder.SetEntryPoint(System.Reflection.MethodInfo,System.Reflection.Emit.PEFileKinds)">
          <source>Starting with the <ph id="ph1">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</ph>, this member no longer requires <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> with the <ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType&gt;</ph> flag.</source>
          <target state="translated">Começando com o <ph id="ph1">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</ph>, esse membro não requer mais <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> com o <ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType&gt;</ph> sinalizador.</target>       </trans-unit>
        <trans-unit id="745" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.AssemblyBuilder.SetEntryPoint(System.Reflection.MethodInfo,System.Reflection.Emit.PEFileKinds)">
          <source>(See <bpt id="p1">[</bpt>Security Issues in Reflection Emit<ept id="p1">](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)</ept>.) To use this functionality, your application should target the <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> or later.</source>
          <target state="translated">(Consulte <bpt id="p1">[</bpt>problemas de segurança em reflexão emitir<ept id="p1">](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)</ept>.) Para usar essa funcionalidade, seu aplicativo deve ser direcionado ao <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> ou posterior.</target>       </trans-unit>
        <trans-unit id="746" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.AssemblyBuilder.SetEntryPoint(System.Reflection.MethodInfo,System.Reflection.Emit.PEFileKinds)">
          <source><ph id="ph1">&lt;paramref name="entryMethod" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="entryMethod" /&gt;</ph> é <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="747" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.AssemblyBuilder.SetEntryPoint(System.Reflection.MethodInfo,System.Reflection.Emit.PEFileKinds)">
          <source><ph id="ph1">&lt;paramref name="entryMethod" /&gt;</ph> is not contained within this assembly.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="entryMethod" /&gt;</ph> não está contido nesse assembly.</target>       </trans-unit>
        <trans-unit id="748" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.AssemblyBuilder.SetEntryPoint(System.Reflection.MethodInfo,System.Reflection.Emit.PEFileKinds)">
          <source>The caller does not have the required permission.</source>
          <target state="translated">O chamador não tem a permissão necessária.</target>       </trans-unit>
        <trans-unit id="749" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.AssemblyBuilder.SetEntryPoint(System.Reflection.MethodInfo,System.Reflection.Emit.PEFileKinds)">
          <source>when invoked late-bound through mechanisms such as <ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>.</source>
          <target state="translated">quando invocado com associação tardia por meio de mecanismos como <ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="750" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.AssemblyBuilder.SetEntryPoint(System.Reflection.MethodInfo,System.Reflection.Emit.PEFileKinds)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph>.</source>
          <target state="translated">Enumeração associada: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="751" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.AssemblyBuilder.System#Runtime#InteropServices#_AssemblyBuilder#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)">
          <source>Reserved for future use.</source>
          <target state="translated">Reservado para uso futuro.</target>       </trans-unit>
        <trans-unit id="752" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.AssemblyBuilder.System#Runtime#InteropServices#_AssemblyBuilder#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)">
          <source>Must be IID_NULL.</source>
          <target state="translated">Deve ser IID_NULL.</target>       </trans-unit>
        <trans-unit id="753" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.AssemblyBuilder.System#Runtime#InteropServices#_AssemblyBuilder#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)">
          <source>Passed-in array of names to be mapped.</source>
          <target state="translated">Matriz passada de nomes a serem mapeados.</target>       </trans-unit>
        <trans-unit id="754" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.AssemblyBuilder.System#Runtime#InteropServices#_AssemblyBuilder#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)">
          <source>Count of the names to be mapped.</source>
          <target state="translated">Contagem dos nomes a serem mapeados.</target>       </trans-unit>
        <trans-unit id="755" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.AssemblyBuilder.System#Runtime#InteropServices#_AssemblyBuilder#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)">
          <source>The locale context in which to interpret the names.</source>
          <target state="translated">O contexto de localidade no qual interpretar os nomes.</target>       </trans-unit>
        <trans-unit id="756" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.AssemblyBuilder.System#Runtime#InteropServices#_AssemblyBuilder#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)">
          <source>Caller-allocated array which receives the IDs corresponding to the names.</source>
          <target state="translated">Matriz alocada pelo chamador que recebe os IDs correspondentes aos nomes.</target>       </trans-unit>
        <trans-unit id="757" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.AssemblyBuilder.System#Runtime#InteropServices#_AssemblyBuilder#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)">
          <source>Maps a set of names to a corresponding set of dispatch identifiers.</source>
          <target state="translated">Mapeia um conjunto de nomes para um conjunto correspondente de identificadores de expedição.</target>       </trans-unit>
        <trans-unit id="758" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.AssemblyBuilder.System#Runtime#InteropServices#_AssemblyBuilder#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)">
          <source>This method is for access to managed classes from unmanaged code, and should not be called from managed code.</source>
          <target state="translated">Este método é para acesso a classes gerenciadas de código não gerenciado e não deve ser chamado em código gerenciado.</target>       </trans-unit>
        <trans-unit id="759" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.AssemblyBuilder.System#Runtime#InteropServices#_AssemblyBuilder#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)">
          <source>For more information about <ph id="ph1">`IDispatch::GetIDsOfNames`</ph>, see the MSDN Library.</source>
          <target state="translated">Para obter mais informações sobre <ph id="ph1">`IDispatch::GetIDsOfNames`</ph>, consulte a Biblioteca MSDN.</target>       </trans-unit>
        <trans-unit id="760" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.AssemblyBuilder.System#Runtime#InteropServices#_AssemblyBuilder#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)">
          <source>The method is called late-bound using the COM <bpt id="p1">&lt;c&gt;</bpt>IDispatch<ept id="p1">&lt;/c&gt;</ept> interface.</source>
          <target state="translated">O método é chamado de associação tardia usando a interface <bpt id="p1">&lt;c&gt;</bpt>IDispatch<ept id="p1">&lt;/c&gt;</ept> do COM.</target>       </trans-unit>
        <trans-unit id="761" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.AssemblyBuilder.System#Runtime#InteropServices#_AssemblyBuilder#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)">
          <source>The type information to return.</source>
          <target state="translated">As informações de tipo a serem retornadas.</target>       </trans-unit>
        <trans-unit id="762" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.AssemblyBuilder.System#Runtime#InteropServices#_AssemblyBuilder#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)">
          <source>The locale identifier for the type information.</source>
          <target state="translated">O identificador de localidade das informações do tipo.</target>       </trans-unit>
        <trans-unit id="763" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.AssemblyBuilder.System#Runtime#InteropServices#_AssemblyBuilder#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)">
          <source>Receives a pointer to the requested type information object.</source>
          <target state="translated">Recebe um ponteiro para o objeto de informações de tipo solicitado.</target>       </trans-unit>
        <trans-unit id="764" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.AssemblyBuilder.System#Runtime#InteropServices#_AssemblyBuilder#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)">
          <source>Retrieves the type information for an object, which can then be used to get the type information for an interface.</source>
          <target state="translated">Recupera as informações do tipo de um objeto, que podem ser usadas para obter informações de tipo para uma interface.</target>       </trans-unit>
        <trans-unit id="765" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.AssemblyBuilder.System#Runtime#InteropServices#_AssemblyBuilder#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)">
          <source>This method is for access to managed classes from unmanaged code, and should not be called from managed code.</source>
          <target state="translated">Este método é para acesso a classes gerenciadas de código não gerenciado e não deve ser chamado em código gerenciado.</target>       </trans-unit>
        <trans-unit id="766" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.AssemblyBuilder.System#Runtime#InteropServices#_AssemblyBuilder#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)">
          <source>For more information about <ph id="ph1">`IDispatch::GetTypeInfo`</ph>, see the MSDN Library.</source>
          <target state="translated">Para obter mais informações sobre <ph id="ph1">`IDispatch::GetTypeInfo`</ph>, consulte a Biblioteca MSDN.</target>       </trans-unit>
        <trans-unit id="767" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.AssemblyBuilder.System#Runtime#InteropServices#_AssemblyBuilder#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)">
          <source>The method is called late-bound using the COM <bpt id="p1">&lt;c&gt;</bpt>IDispatch<ept id="p1">&lt;/c&gt;</ept> interface.</source>
          <target state="translated">O método é chamado de associação tardia usando a interface <bpt id="p1">&lt;c&gt;</bpt>IDispatch<ept id="p1">&lt;/c&gt;</ept> do COM.</target>       </trans-unit>
        <trans-unit id="768" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.AssemblyBuilder.System#Runtime#InteropServices#_AssemblyBuilder#GetTypeInfoCount(System.UInt32@)">
          <source>Points to a location that receives the number of type information interfaces provided by the object.</source>
          <target state="translated">Aponta para um local que recebe o número de interfaces de informações de tipo fornecido pelo objeto.</target>       </trans-unit>
        <trans-unit id="769" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.AssemblyBuilder.System#Runtime#InteropServices#_AssemblyBuilder#GetTypeInfoCount(System.UInt32@)">
          <source>Retrieves the number of type information interfaces that an object provides (either 0 or 1).</source>
          <target state="translated">Retorna o número de interfaces de informações do tipo que um objeto fornece (0 ou 1).</target>       </trans-unit>
        <trans-unit id="770" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.AssemblyBuilder.System#Runtime#InteropServices#_AssemblyBuilder#GetTypeInfoCount(System.UInt32@)">
          <source>This method is for access to managed classes from unmanaged code, and should not be called from managed code.</source>
          <target state="translated">Este método é para acesso a classes gerenciadas de código não gerenciado e não deve ser chamado em código gerenciado.</target>       </trans-unit>
        <trans-unit id="771" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.AssemblyBuilder.System#Runtime#InteropServices#_AssemblyBuilder#GetTypeInfoCount(System.UInt32@)">
          <source>For more information about <ph id="ph1">`IDispatch::GetTypeInfoCount`</ph>, see the MSDN Library.</source>
          <target state="translated">Para obter mais informações sobre <ph id="ph1">`IDispatch::GetTypeInfoCount`</ph>, consulte a Biblioteca MSDN.</target>       </trans-unit>
        <trans-unit id="772" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.AssemblyBuilder.System#Runtime#InteropServices#_AssemblyBuilder#GetTypeInfoCount(System.UInt32@)">
          <source>The method is called late-bound using the COM <bpt id="p1">&lt;c&gt;</bpt>IDispatch<ept id="p1">&lt;/c&gt;</ept> interface.</source>
          <target state="translated">O método é chamado de associação tardia usando a interface <bpt id="p1">&lt;c&gt;</bpt>IDispatch<ept id="p1">&lt;/c&gt;</ept> do COM.</target>       </trans-unit>
        <trans-unit id="773" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.AssemblyBuilder.System#Runtime#InteropServices#_AssemblyBuilder#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>Identifies the member.</source>
          <target state="translated">Identifica o membro.</target>       </trans-unit>
        <trans-unit id="774" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.AssemblyBuilder.System#Runtime#InteropServices#_AssemblyBuilder#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>Reserved for future use.</source>
          <target state="translated">Reservado para uso futuro.</target>       </trans-unit>
        <trans-unit id="775" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.AssemblyBuilder.System#Runtime#InteropServices#_AssemblyBuilder#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>Must be IID_NULL.</source>
          <target state="translated">Deve ser IID_NULL.</target>       </trans-unit>
        <trans-unit id="776" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.AssemblyBuilder.System#Runtime#InteropServices#_AssemblyBuilder#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>The locale context in which to interpret arguments.</source>
          <target state="translated">O contexto de localidade no qual interpretar argumentos.</target>       </trans-unit>
        <trans-unit id="777" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.AssemblyBuilder.System#Runtime#InteropServices#_AssemblyBuilder#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>Flags describing the context of the call.</source>
          <target state="translated">Sinalizadores que descrevem o contexto da chamada.</target>       </trans-unit>
        <trans-unit id="778" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.AssemblyBuilder.System#Runtime#InteropServices#_AssemblyBuilder#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>Pointer to a structure containing an array of arguments, an array of argument DISPIDs for named arguments, and counts for the number of elements in the arrays.</source>
          <target state="translated">Ponteiro para uma estrutura contendo uma matriz de argumentos, uma matriz de DISPIDs de argumento para argumentos nomeados e contagens para o número de elementos nas matrizes.</target>       </trans-unit>
        <trans-unit id="779" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.AssemblyBuilder.System#Runtime#InteropServices#_AssemblyBuilder#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>Pointer to the location where the result is to be stored.</source>
          <target state="translated">Ponteiro para o local onde o resultado deve ser armazenado.</target>       </trans-unit>
        <trans-unit id="780" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.AssemblyBuilder.System#Runtime#InteropServices#_AssemblyBuilder#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>Pointer to a structure that contains exception information.</source>
          <target state="translated">Ponteiro para uma estrutura que contém informações de exceção.</target>       </trans-unit>
        <trans-unit id="781" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.AssemblyBuilder.System#Runtime#InteropServices#_AssemblyBuilder#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>The index of the first argument that has an error.</source>
          <target state="translated">O índice do primeiro argumento que tem um erro.</target>       </trans-unit>
        <trans-unit id="782" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.AssemblyBuilder.System#Runtime#InteropServices#_AssemblyBuilder#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>Provides access to properties and methods exposed by an object.</source>
          <target state="translated">Fornece acesso a propriedades e métodos expostos por um objeto.</target>       </trans-unit>
        <trans-unit id="783" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.AssemblyBuilder.System#Runtime#InteropServices#_AssemblyBuilder#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>This method is for access to managed classes from unmanaged code, and should not be called from managed code.</source>
          <target state="translated">Este método é para acesso a classes gerenciadas de código não gerenciado e não deve ser chamado em código gerenciado.</target>       </trans-unit>
        <trans-unit id="784" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.AssemblyBuilder.System#Runtime#InteropServices#_AssemblyBuilder#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>For more information about <ph id="ph1">`IDispatch::Invoke`</ph>, see the MSDN Library.</source>
          <target state="translated">Para obter mais informações sobre <ph id="ph1">`IDispatch::Invoke`</ph>, consulte a Biblioteca MSDN.</target>       </trans-unit>
        <trans-unit id="785" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.AssemblyBuilder.System#Runtime#InteropServices#_AssemblyBuilder#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>The method is called late-bound using the COM <bpt id="p1">&lt;c&gt;</bpt>IDispatch<ept id="p1">&lt;/c&gt;</ept> interface.</source>
          <target state="translated">O método é chamado de associação tardia usando a interface <bpt id="p1">&lt;c&gt;</bpt>IDispatch<ept id="p1">&lt;/c&gt;</ept> do COM.</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>