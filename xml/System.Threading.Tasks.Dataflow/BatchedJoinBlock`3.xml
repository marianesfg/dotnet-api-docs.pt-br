<Type Name="BatchedJoinBlock&lt;T1,T2,T3&gt;" FullName="System.Threading.Tasks.Dataflow.BatchedJoinBlock&lt;T1,T2,T3&gt;">
  <TypeSignature Language="C#" Value="public sealed class BatchedJoinBlock&lt;T1,T2,T3&gt; : System.Threading.Tasks.Dataflow.IReceivableSourceBlock&lt;Tuple&lt;System.Collections.Generic.IList&lt;T1&gt;,System.Collections.Generic.IList&lt;T2&gt;,System.Collections.Generic.IList&lt;T3&gt;&gt;&gt;, System.Threading.Tasks.Dataflow.ISourceBlock&lt;Tuple&lt;System.Collections.Generic.IList&lt;T1&gt;,System.Collections.Generic.IList&lt;T2&gt;,System.Collections.Generic.IList&lt;T3&gt;&gt;&gt;" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit BatchedJoinBlock`3&lt;T1, T2, T3&gt; extends System.Object implements class System.Threading.Tasks.Dataflow.IDataflowBlock, class System.Threading.Tasks.Dataflow.IReceivableSourceBlock`1&lt;class System.Tuple`3&lt;class System.Collections.Generic.IList`1&lt;!T1&gt;, class System.Collections.Generic.IList`1&lt;!T2&gt;, class System.Collections.Generic.IList`1&lt;!T3&gt;&gt;&gt;, class System.Threading.Tasks.Dataflow.ISourceBlock`1&lt;class System.Tuple`3&lt;class System.Collections.Generic.IList`1&lt;!T1&gt;, class System.Collections.Generic.IList`1&lt;!T2&gt;, class System.Collections.Generic.IList`1&lt;!T3&gt;&gt;&gt;" />
  <TypeSignature Language="DocId" Value="T:System.Threading.Tasks.Dataflow.BatchedJoinBlock`3" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class BatchedJoinBlock(Of T1, T2, T3)&#xA;Implements IReceivableSourceBlock(Of Tuple(Of IList(Of T1), IList(Of T2), IList(Of T3))), ISourceBlock(Of Tuple(Of IList(Of T1), IList(Of T2), IList(Of T3)))" />
  <TypeSignature Language="C++ CLI" Value="generic &lt;typename T1, typename T2, typename T3&gt;&#xA;public ref class BatchedJoinBlock sealed : System::Threading::Tasks::Dataflow::IReceivableSourceBlock&lt;Tuple&lt;System::Collections::Generic::IList&lt;T1&gt; ^, System::Collections::Generic::IList&lt;T2&gt; ^, System::Collections::Generic::IList&lt;T3&gt; ^&gt; ^&gt;, System::Threading::Tasks::Dataflow::ISourceBlock&lt;Tuple&lt;System::Collections::Generic::IList&lt;T1&gt; ^, System::Collections::Generic::IList&lt;T2&gt; ^, System::Collections::Generic::IList&lt;T3&gt; ^&gt; ^&gt;" />
  <AssemblyInfo>
    <AssemblyName>System.Threading.Tasks.Dataflow</AssemblyName>
    <AssemblyVersion>4.6.0.0</AssemblyVersion>
    <AssemblyVersion>4.6.1.0</AssemblyVersion>
    <AssemblyVersion>4.6.2.0</AssemblyVersion>
    <AssemblyVersion>4.6.3.0</AssemblyVersion>
  </AssemblyInfo>
  <TypeParameters>
    <TypeParameter Name="T1" />
    <TypeParameter Name="T2" />
    <TypeParameter Name="T3" />
  </TypeParameters>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Threading.Tasks.Dataflow.IReceivableSourceBlock&lt;System.Tuple&lt;System.Collections.Generic.IList&lt;T1&gt;,System.Collections.Generic.IList&lt;T2&gt;,System.Collections.Generic.IList&lt;T3&gt;&gt;&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Threading.Tasks.Dataflow.ISourceBlock&lt;System.Tuple&lt;System.Collections.Generic.IList&lt;T1&gt;,System.Collections.Generic.IList&lt;T2&gt;,System.Collections.Generic.IList&lt;T3&gt;&gt;&gt;</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <typeparam name="T1"><span data-ttu-id="afef2-101">Especifica o tipo de dados aceitos pelo destino de primeiro do bloco.</span><span class="sxs-lookup"><span data-stu-id="afef2-101">Specifies the type of data accepted by the block's first target.</span></span></typeparam>
    <typeparam name="T2"><span data-ttu-id="afef2-102">Especifica o tipo de dados aceitos por segundo de destino do bloco.</span><span class="sxs-lookup"><span data-stu-id="afef2-102">Specifies the type of data accepted by the block's second target.</span></span></typeparam>
    <typeparam name="T3"><span data-ttu-id="afef2-103">Especifica o tipo de dados aceitos pelo destino terceiro do bloco.</span><span class="sxs-lookup"><span data-stu-id="afef2-103">Specifies the type of data accepted by the block's third target.</span></span></typeparam>
    <summary><span data-ttu-id="afef2-104">Fornece um bloco de fluxo de dados que processa em lotes um número especificado de entradas de possíveis tipos diferentes fornecidos a um ou mais de seus destinos.</span><span class="sxs-lookup"><span data-stu-id="afef2-104">Provides a dataflow block that batches a specified number of inputs of potentially differing types provided to one or more of its targets.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
[!INCLUDE [tpl-install-instructions](~/includes/tpl-install-instructions.md)]
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public BatchedJoinBlock (int batchSize);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 batchSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Dataflow.BatchedJoinBlock`3.#ctor(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (batchSize As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; BatchedJoinBlock(int batchSize);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Dataflow</AssemblyName>
        <AssemblyVersion>4.6.0.0</AssemblyVersion>
        <AssemblyVersion>4.6.1.0</AssemblyVersion>
        <AssemblyVersion>4.6.2.0</AssemblyVersion>
        <AssemblyVersion>4.6.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="batchSize" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="batchSize"><span data-ttu-id="afef2-105">O número de itens a serem agrupados em um lote.</span><span class="sxs-lookup"><span data-stu-id="afef2-105">The number of items to group into a batch.</span></span></param>
        <summary><span data-ttu-id="afef2-106">Inicializa um novo <see cref="T:System.Threading.Tasks.Dataflow.BatchedJoinBlock`3" /> com a configuração especificada.</span><span class="sxs-lookup"><span data-stu-id="afef2-106">Initializes a new <see cref="T:System.Threading.Tasks.Dataflow.BatchedJoinBlock`3" /> with the specified configuration.</span></span></summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="afef2-107">O <paramref name="batchSize" /> deve ser positivo.</span><span class="sxs-lookup"><span data-stu-id="afef2-107">The <paramref name="batchSize" /> must be positive.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public BatchedJoinBlock (int batchSize, System.Threading.Tasks.Dataflow.GroupingDataflowBlockOptions dataflowBlockOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 batchSize, class System.Threading.Tasks.Dataflow.GroupingDataflowBlockOptions dataflowBlockOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Dataflow.BatchedJoinBlock`3.#ctor(System.Int32,System.Threading.Tasks.Dataflow.GroupingDataflowBlockOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (batchSize As Integer, dataflowBlockOptions As GroupingDataflowBlockOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; BatchedJoinBlock(int batchSize, System::Threading::Tasks::Dataflow::GroupingDataflowBlockOptions ^ dataflowBlockOptions);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Dataflow</AssemblyName>
        <AssemblyVersion>4.6.0.0</AssemblyVersion>
        <AssemblyVersion>4.6.1.0</AssemblyVersion>
        <AssemblyVersion>4.6.2.0</AssemblyVersion>
        <AssemblyVersion>4.6.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="batchSize" Type="System.Int32" />
        <Parameter Name="dataflowBlockOptions" Type="System.Threading.Tasks.Dataflow.GroupingDataflowBlockOptions" />
      </Parameters>
      <Docs>
        <param name="batchSize"><span data-ttu-id="afef2-108">O número de itens a serem agrupados em um lote.</span><span class="sxs-lookup"><span data-stu-id="afef2-108">The number of items to group into a batch.</span></span></param>
        <param name="dataflowBlockOptions"><span data-ttu-id="afef2-109">As opções com as quais este <see cref="T:System.Threading.Tasks.Dataflow.BatchedJoinBlock`2" /> será configurado.</span><span class="sxs-lookup"><span data-stu-id="afef2-109">The options with which to configure this  <see cref="T:System.Threading.Tasks.Dataflow.BatchedJoinBlock`2" />.</span></span></param>
        <summary><span data-ttu-id="afef2-110">Inicializa um novo <see cref="T:System.Threading.Tasks.Dataflow.BatchedJoinBlock`3" /> com a configuração especificada.</span><span class="sxs-lookup"><span data-stu-id="afef2-110">Initializes a new <see cref="T:System.Threading.Tasks.Dataflow.BatchedJoinBlock`3" /> with the specified configuration.</span></span></summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="afef2-111">O <paramref name="batchSize" /> deve ser positivo.</span><span class="sxs-lookup"><span data-stu-id="afef2-111">The <paramref name="batchSize" /> must be positive.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="afef2-112">O <paramref name="dataflowBlockOptions" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="afef2-112">The <paramref name="dataflowBlockOptions" /> is <see langword="null" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="BatchSize">
      <MemberSignature Language="C#" Value="public int BatchSize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 BatchSize" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.Dataflow.BatchedJoinBlock`3.BatchSize" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property BatchSize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int BatchSize { int get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Dataflow</AssemblyName>
        <AssemblyVersion>4.6.0.0</AssemblyVersion>
        <AssemblyVersion>4.6.1.0</AssemblyVersion>
        <AssemblyVersion>4.6.2.0</AssemblyVersion>
        <AssemblyVersion>4.6.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="afef2-113">Obtém o tamanho dos lotes gerados por este <see cref="T:System.Threading.Tasks.Dataflow.BatchedJoinBlock`3" />.</span><span class="sxs-lookup"><span data-stu-id="afef2-113">Gets the size of the batches generated by this <see cref="T:System.Threading.Tasks.Dataflow.BatchedJoinBlock`3" />.</span></span></summary>
        <value><span data-ttu-id="afef2-114">O tamanho do lote.</span><span class="sxs-lookup"><span data-stu-id="afef2-114">The batch size.</span></span></value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Complete">
      <MemberSignature Language="C#" Value="public void Complete ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Complete() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Dataflow.BatchedJoinBlock`3.Complete" />
      <MemberSignature Language="VB.NET" Value="Public Sub Complete ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Complete();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Threading.Tasks.Dataflow.IDataflowBlock.Complete</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Dataflow</AssemblyName>
        <AssemblyVersion>4.6.0.0</AssemblyVersion>
        <AssemblyVersion>4.6.1.0</AssemblyVersion>
        <AssemblyVersion>4.6.2.0</AssemblyVersion>
        <AssemblyVersion>4.6.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="afef2-115">Sinaliza para o <see cref="T:System.Threading.Tasks.Dataflow.IDataflowBlock" /> que ele não deve aceitar nem produzir mais mensagens, e não deve consumir mais mensagens adiadas.</span><span class="sxs-lookup"><span data-stu-id="afef2-115">Signals to the <see cref="T:System.Threading.Tasks.Dataflow.IDataflowBlock" /> that it should not accept nor produce any more messages nor consume any more postponed messages.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="afef2-116">Depois de <xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%603.Complete%2A> foi chamado em um bloco de fluxo de dados, esse bloco será concluída e seu <xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%603.Completion%2A> tarefa entrará em um estado final depois que ele tiver processado todos os dados disponíveis anteriormente.</span><span class="sxs-lookup"><span data-stu-id="afef2-116">After <xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%603.Complete%2A> has been called on a dataflow block, that block will complete, and its  <xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%603.Completion%2A> task will enter a final state after it has processed all previously available data.</span></span> <span data-ttu-id="afef2-117"><xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%603.Complete%2A> será não bloco aguardando conclusão ocorra, mas em vez disso, iniciará a solicitação; para aguardar a conclusão ocorra, o <xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%603.Completion%2A> tarefa pode ser usada.</span><span class="sxs-lookup"><span data-stu-id="afef2-117"><xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%603.Complete%2A> will not block waiting for completion to occur, but rather will initiate the request; to wait for completion to occur, the  <xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%603.Completion%2A> task may be used.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Completion">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task Completion { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Threading.Tasks.Task Completion" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.Dataflow.BatchedJoinBlock`3.Completion" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Completion As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Threading::Tasks::Task ^ Completion { System::Threading::Tasks::Task ^ get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Threading.Tasks.Dataflow.IDataflowBlock.Completion</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Dataflow</AssemblyName>
        <AssemblyVersion>4.6.0.0</AssemblyVersion>
        <AssemblyVersion>4.6.1.0</AssemblyVersion>
        <AssemblyVersion>4.6.2.0</AssemblyVersion>
        <AssemblyVersion>4.6.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="afef2-118">Obtém um <see cref="T:System.Threading.Tasks.Task" /> que representa a operação assíncrona e a conclusão do bloco de fluxo de dados.</span><span class="sxs-lookup"><span data-stu-id="afef2-118">Gets a <see cref="T:System.Threading.Tasks.Task" /> that represents the asynchronous operation and completion of the dataflow block.</span></span></summary>
        <value><span data-ttu-id="afef2-119">A tarefa.</span><span class="sxs-lookup"><span data-stu-id="afef2-119">The task.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="afef2-120">Um bloco de fluxo de dados é considerado concluída quando ele não está processando uma mensagem e quando ele tem a garantia de que ele não processará mais mensagens.</span><span class="sxs-lookup"><span data-stu-id="afef2-120">A dataflow block is considered completed when it is not currently processing a message and when it has guaranteed that it will not process any more messages.</span></span> <span data-ttu-id="afef2-121">Retornado <xref:System.Threading.Tasks.Task> será a transição para um estado concluído quando o bloco associado foi concluída.</span><span class="sxs-lookup"><span data-stu-id="afef2-121">The returned <xref:System.Threading.Tasks.Task> will transition to a completed state when the associated block has completed.</span></span> <span data-ttu-id="afef2-122">Ela fará a transição para o <xref:System.Threading.Tasks.TaskStatus> <xref:System.Threading.Tasks.TaskStatus.RanToCompletion> quando o bloco for concluído o processamento com êxito de acordo com o bloco de fluxo de dados de estado definido semântica, ela fará a transição para o <xref:System.Threading.Tasks.TaskStatus> <xref:System.Threading.Tasks.TaskStatus.Faulted> estado quando o bloco de fluxo de dados concluiu o processamento prematuramente devido a uma exceção sem tratamento e ela fará a transição para o <xref:System.Threading.Tasks.TaskStatus> <xref:System.Threading.Tasks.TaskStatus.Canceled> estado quando o bloco de fluxo de dados concluiu o processamento prematuramente devido ao recebimento de uma solicitação de cancelamento.</span><span class="sxs-lookup"><span data-stu-id="afef2-122">It will transition to the <xref:System.Threading.Tasks.TaskStatus><xref:System.Threading.Tasks.TaskStatus.RanToCompletion> state when the block completes its processing successfully according to the dataflow block’s defined semantics, it will transition to the <xref:System.Threading.Tasks.TaskStatus><xref:System.Threading.Tasks.TaskStatus.Faulted> state when the dataflow block has completed processing prematurely due to an unhandled exception, and it will transition to the <xref:System.Threading.Tasks.TaskStatus><xref:System.Threading.Tasks.TaskStatus.Canceled> state when the dataflow block has completed processing prematurely due to receiving a cancellation request.</span></span> <span data-ttu-id="afef2-123">Se a tarefa é concluída no <xref:System.Threading.Tasks.TaskStatus.Faulted> estado, seu `Exception` propriedade retornará um <xref:System.AggregateException> que contém uma ou mais exceções que fez o bloco falha.</span><span class="sxs-lookup"><span data-stu-id="afef2-123">If the task completes in the <xref:System.Threading.Tasks.TaskStatus.Faulted> state, its `Exception` property will return an <xref:System.AggregateException> containing the one or more exceptions that caused the block to fail.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LinkTo">
      <MemberSignature Language="C#" Value="public IDisposable LinkTo (System.Threading.Tasks.Dataflow.ITargetBlock&lt;Tuple&lt;System.Collections.Generic.IList&lt;T1&gt;,System.Collections.Generic.IList&lt;T2&gt;,System.Collections.Generic.IList&lt;T3&gt;&gt;&gt; target, System.Threading.Tasks.Dataflow.DataflowLinkOptions linkOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IDisposable LinkTo(class System.Threading.Tasks.Dataflow.ITargetBlock`1&lt;class System.Tuple`3&lt;class System.Collections.Generic.IList`1&lt;!T1&gt;, class System.Collections.Generic.IList`1&lt;!T2&gt;, class System.Collections.Generic.IList`1&lt;!T3&gt;&gt;&gt; target, class System.Threading.Tasks.Dataflow.DataflowLinkOptions linkOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Dataflow.BatchedJoinBlock`3.LinkTo(System.Threading.Tasks.Dataflow.ITargetBlock{System.Tuple{System.Collections.Generic.IList{`0},System.Collections.Generic.IList{`1},System.Collections.Generic.IList{`2}}},System.Threading.Tasks.Dataflow.DataflowLinkOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function LinkTo (target As ITargetBlock(Of Tuple(Of IList(Of T1), IList(Of T2), IList(Of T3))), linkOptions As DataflowLinkOptions) As IDisposable" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual IDisposable ^ LinkTo(System::Threading::Tasks::Dataflow::ITargetBlock&lt;Tuple&lt;System::Collections::Generic::IList&lt;T1&gt; ^, System::Collections::Generic::IList&lt;T2&gt; ^, System::Collections::Generic::IList&lt;T3&gt; ^&gt; ^&gt; ^ target, System::Threading::Tasks::Dataflow::DataflowLinkOptions ^ linkOptions);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Threading.Tasks.Dataflow.ISourceBlock`1.LinkTo(System.Threading.Tasks.Dataflow.ITargetBlock{`0},System.Threading.Tasks.Dataflow.DataflowLinkOptions)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Dataflow</AssemblyName>
        <AssemblyVersion>4.6.0.0</AssemblyVersion>
        <AssemblyVersion>4.6.1.0</AssemblyVersion>
        <AssemblyVersion>4.6.2.0</AssemblyVersion>
        <AssemblyVersion>4.6.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IDisposable</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Threading.Tasks.Dataflow.ITargetBlock&lt;System.Tuple&lt;System.Collections.Generic.IList&lt;T1&gt;,System.Collections.Generic.IList&lt;T2&gt;,System.Collections.Generic.IList&lt;T3&gt;&gt;&gt;" />
        <Parameter Name="linkOptions" Type="System.Threading.Tasks.Dataflow.DataflowLinkOptions" />
      </Parameters>
      <Docs>
        <param name="target"><span data-ttu-id="afef2-124">O <see cref="T:System.Threading.Tasks.Dataflow.ITargetBlock`1" /> ao qual essa fonte será conectada.</span><span class="sxs-lookup"><span data-stu-id="afef2-124">The  <see cref="T:System.Threading.Tasks.Dataflow.ITargetBlock`1" /> to which to connect this source.</span></span></param>
        <param name="linkOptions">
          <span data-ttu-id="afef2-125"><see langword="true" /> se a origem deverá desvincular-se do destino após a propagação com êxito de uma única mensagem; <see langword="false" /> para permanecer conectado mesmo depois de uma única mensagem ter sido propagada.</span><span class="sxs-lookup"><span data-stu-id="afef2-125"><see langword="true" /> if the source should unlink from the target after successfully propagating a single message; <see langword="false" /> to remain connected even after a single message has been propagated.</span></span></param>
        <summary><span data-ttu-id="afef2-126">Vincula o <see cref="T:System.Threading.Tasks.Dataflow.ISourceBlock`1" /> ao <see cref="T:System.Threading.Tasks.Dataflow.ITargetBlock`1" /> especificado.</span><span class="sxs-lookup"><span data-stu-id="afef2-126">Links the  <see cref="T:System.Threading.Tasks.Dataflow.ISourceBlock`1" /> to the specified  <see cref="T:System.Threading.Tasks.Dataflow.ITargetBlock`1" /> .</span></span></summary>
        <returns><span data-ttu-id="afef2-127">Um IDisposable que, após chamar Dispose, desvinculará a origem do destino.</span><span class="sxs-lookup"><span data-stu-id="afef2-127">An IDisposable that, upon calling Dispose, will unlink the source from the target.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="afef2-128"><paramref name="target" /> é nulo (Nothing no Visual Basic) ou <paramref name="linkOptions" /> é nulo (Nothing no Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="afef2-128"><paramref name="target" /> is null (Nothing in Visual Basic) or  <paramref name="linkOptions" /> is null (Nothing in Visual Basic).</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="OutputCount">
      <MemberSignature Language="C#" Value="public int OutputCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 OutputCount" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.Dataflow.BatchedJoinBlock`3.OutputCount" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property OutputCount As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int OutputCount { int get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Dataflow</AssemblyName>
        <AssemblyVersion>4.6.0.0</AssemblyVersion>
        <AssemblyVersion>4.6.1.0</AssemblyVersion>
        <AssemblyVersion>4.6.2.0</AssemblyVersion>
        <AssemblyVersion>4.6.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="afef2-129">Obtém o número de itens de saída disponíveis para serem recebidos deste bloco.</span><span class="sxs-lookup"><span data-stu-id="afef2-129">Gets the number of output items available to be received from this block.</span></span></summary>
        <value><span data-ttu-id="afef2-130">O número de itens de saída.</span><span class="sxs-lookup"><span data-stu-id="afef2-130">The number of output items.</span></span></value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Threading.Tasks.Dataflow.IDataflowBlock.Fault">
      <MemberSignature Language="C#" Value="void IDataflowBlock.Fault (Exception exception);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Threading.Tasks.Dataflow.IDataflowBlock.Fault(class System.Exception exception) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Dataflow.BatchedJoinBlock`3.System#Threading#Tasks#Dataflow#IDataflowBlock#Fault(System.Exception)" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Threading.Tasks.Dataflow.IDataflowBlock.Fault(Exception ^ exception) = System::Threading::Tasks::Dataflow::IDataflowBlock::Fault;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Threading.Tasks.Dataflow.IDataflowBlock.Fault(System.Exception)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Dataflow</AssemblyName>
        <AssemblyVersion>4.6.0.0</AssemblyVersion>
        <AssemblyVersion>4.6.1.0</AssemblyVersion>
        <AssemblyVersion>4.6.2.0</AssemblyVersion>
        <AssemblyVersion>4.6.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="exception" Type="System.Exception" />
      </Parameters>
      <Docs>
        <param name="exception"><span data-ttu-id="afef2-131">O <see cref="T:System.Exception" /> que causou a falha.</span><span class="sxs-lookup"><span data-stu-id="afef2-131">The <see cref="T:System.Exception" /> that caused the faulting.</span></span></param>
        <summary><span data-ttu-id="afef2-132">Faz com que o <see cref="T:System.Threading.Tasks.Dataflow.IDataflowBlock" /> seja concluído em um estado <see cref="F:System.Threading.Tasks.TaskStatus.Faulted" />.</span><span class="sxs-lookup"><span data-stu-id="afef2-132">Causes the <see cref="T:System.Threading.Tasks.Dataflow.IDataflowBlock" /> to complete in a  <see cref="F:System.Threading.Tasks.TaskStatus.Faulted" /> state.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="afef2-133">Depois de <xref:System.Threading.Tasks.Dataflow.IDataflowBlock.Fault%2A> foi chamado em um bloco de fluxo de dados, esse bloco será concluída e seu <xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%603.Completion%2A> tarefa entrará em um estado final.</span><span class="sxs-lookup"><span data-stu-id="afef2-133">After <xref:System.Threading.Tasks.Dataflow.IDataflowBlock.Fault%2A> has been called on a dataflow block, that block will complete, and its <xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%603.Completion%2A> task will enter a final state.</span></span> <span data-ttu-id="afef2-134">A falha de um bloco, como cancelar um bloco, faz com que mensagens em buffer (mensagens de entrada não processadas, bem como mensagens de saída unoffered) serão perdidos.</span><span class="sxs-lookup"><span data-stu-id="afef2-134">Faulting a block, as with canceling a block, causes buffered messages (unprocessed input messages as well as unoffered output messages) to be lost.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="afef2-135">O <paramref name="exception" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="afef2-135">The <paramref name="exception" /> is <see langword="null" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="System.Threading.Tasks.Dataflow.ISourceBlock&lt;System.Tuple&lt;System.Collections.Generic.IList&lt;T1&gt;,System.Collections.Generic.IList&lt;T2&gt;,System.Collections.Generic.IList&lt;T3&gt;&gt;&gt;.ConsumeMessage">
      <MemberSignature Language="C#" Value="Tuple&lt;System.Collections.Generic.IList&lt;T1&gt;,System.Collections.Generic.IList&lt;T2&gt;,System.Collections.Generic.IList&lt;T3&gt;&gt; ISourceBlock&lt;Tuple&lt;IList&lt;T1&gt;,IList&lt;T2&gt;,IList&lt;T3&gt;&gt;&gt;.ConsumeMessage (System.Threading.Tasks.Dataflow.DataflowMessageHeader messageHeader, System.Threading.Tasks.Dataflow.ITargetBlock&lt;Tuple&lt;System.Collections.Generic.IList&lt;T1&gt;,System.Collections.Generic.IList&lt;T2&gt;,System.Collections.Generic.IList&lt;T3&gt;&gt;&gt; target, out bool messageConsumed);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Tuple`3&lt;class System.Collections.Generic.IList`1&lt;!T1&gt;, class System.Collections.Generic.IList`1&lt;!T2&gt;, class System.Collections.Generic.IList`1&lt;!T3&gt;&gt; System.Threading.Tasks.Dataflow.ISourceBlock&lt;System.Tuple&lt;System.Collections.Generic.IList&lt;T1&gt;,System.Collections.Generic.IList&lt;T2&gt;,System.Collections.Generic.IList&lt;T3&gt;&gt;&gt;.ConsumeMessage(valuetype System.Threading.Tasks.Dataflow.DataflowMessageHeader messageHeader, class System.Threading.Tasks.Dataflow.ITargetBlock`1&lt;class System.Tuple`3&lt;class System.Collections.Generic.IList`1&lt;!T1&gt;, class System.Collections.Generic.IList`1&lt;!T2&gt;, class System.Collections.Generic.IList`1&lt;!T3&gt;&gt;&gt; target, [out] bool&amp; messageConsumed) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Dataflow.BatchedJoinBlock`3.System#Threading#Tasks#Dataflow#ISourceBlock&lt;System#Tuple&lt;System#Collections#Generic#IList&lt;T1&gt;,System#Collections#Generic#IList&lt;T2&gt;,System#Collections#Generic#IList&lt;T3&gt;&gt;&gt;#ConsumeMessage(System.Threading.Tasks.Dataflow.DataflowMessageHeader,System.Threading.Tasks.Dataflow.ITargetBlock{System.Tuple{System.Collections.Generic.IList{`0},System.Collections.Generic.IList{`1},System.Collections.Generic.IList{`2}}},System.Boolean@)" />
      <MemberSignature Language="VB.NET" Value="Function ConsumeMessage (messageHeader As DataflowMessageHeader, target As ITargetBlock(Of Tuple(Of IList(Of T1), IList(Of T2), IList(Of T3))), ByRef messageConsumed As Boolean) As Tuple(Of IList(Of T1), IList(Of T2), IList(Of T3)) Implements ISourceBlock(Of Tuple(Of IList(Of T1), IList(Of T2), IList(Of T3))).ConsumeMessage" />
      <MemberSignature Language="C++ CLI" Value=" virtual Tuple&lt;System::Collections::Generic::IList&lt;T1&gt; ^, System::Collections::Generic::IList&lt;T2&gt; ^, System::Collections::Generic::IList&lt;T3&gt; ^&gt; ^ System.Threading.Tasks.Dataflow.ISourceBlock&lt;System.Tuple&lt;System.Collections.Generic.IList&lt;T1&gt;,System.Collections.Generic.IList&lt;T2&gt;,System.Collections.Generic.IList&lt;T3&gt;&gt;&gt;.ConsumeMessage(System::Threading::Tasks::Dataflow::DataflowMessageHeader messageHeader, System::Threading::Tasks::Dataflow::ITargetBlock&lt;Tuple&lt;System::Collections::Generic::IList&lt;T1&gt; ^, System::Collections::Generic::IList&lt;T2&gt; ^, System::Collections::Generic::IList&lt;T3&gt; ^&gt; ^&gt; ^ target, [Runtime::InteropServices::Out] bool % messageConsumed) = System::Threading::Tasks::Dataflow::ISourceBlock&lt;Tuple&lt;System::Collections::Generic::IList&lt;T1&gt; ^, System::Collections::Generic::IList&lt;T2&gt; ^, System::Collections::Generic::IList&lt;T3&gt; ^&gt; ^&gt;::ConsumeMessage;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Threading.Tasks.Dataflow.ISourceBlock`1.ConsumeMessage(System.Threading.Tasks.Dataflow.DataflowMessageHeader,System.Threading.Tasks.Dataflow.ITargetBlock{`0},System.Boolean@)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Dataflow</AssemblyName>
        <AssemblyVersion>4.6.0.0</AssemblyVersion>
        <AssemblyVersion>4.6.1.0</AssemblyVersion>
        <AssemblyVersion>4.6.2.0</AssemblyVersion>
        <AssemblyVersion>4.6.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Tuple&lt;System.Collections.Generic.IList&lt;T1&gt;,System.Collections.Generic.IList&lt;T2&gt;,System.Collections.Generic.IList&lt;T3&gt;&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="messageHeader" Type="System.Threading.Tasks.Dataflow.DataflowMessageHeader" />
        <Parameter Name="target" Type="System.Threading.Tasks.Dataflow.ITargetBlock&lt;System.Tuple&lt;System.Collections.Generic.IList&lt;T1&gt;,System.Collections.Generic.IList&lt;T2&gt;,System.Collections.Generic.IList&lt;T3&gt;&gt;&gt;" />
        <Parameter Name="messageConsumed" Type="System.Boolean&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="messageHeader">To be added.</param>
        <param name="target">To be added.</param>
        <param name="messageConsumed">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Threading.Tasks.Dataflow.ISourceBlock&lt;System.Tuple&lt;System.Collections.Generic.IList&lt;T1&gt;,System.Collections.Generic.IList&lt;T2&gt;,System.Collections.Generic.IList&lt;T3&gt;&gt;&gt;.ReleaseReservation">
      <MemberSignature Language="C#" Value="void ISourceBlock&lt;Tuple&lt;IList&lt;T1&gt;,IList&lt;T2&gt;,IList&lt;T3&gt;&gt;&gt;.ReleaseReservation (System.Threading.Tasks.Dataflow.DataflowMessageHeader messageHeader, System.Threading.Tasks.Dataflow.ITargetBlock&lt;Tuple&lt;System.Collections.Generic.IList&lt;T1&gt;,System.Collections.Generic.IList&lt;T2&gt;,System.Collections.Generic.IList&lt;T3&gt;&gt;&gt; target);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Threading.Tasks.Dataflow.ISourceBlock&lt;System.Tuple&lt;System.Collections.Generic.IList&lt;T1&gt;,System.Collections.Generic.IList&lt;T2&gt;,System.Collections.Generic.IList&lt;T3&gt;&gt;&gt;.ReleaseReservation(valuetype System.Threading.Tasks.Dataflow.DataflowMessageHeader messageHeader, class System.Threading.Tasks.Dataflow.ITargetBlock`1&lt;class System.Tuple`3&lt;class System.Collections.Generic.IList`1&lt;!T1&gt;, class System.Collections.Generic.IList`1&lt;!T2&gt;, class System.Collections.Generic.IList`1&lt;!T3&gt;&gt;&gt; target) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Dataflow.BatchedJoinBlock`3.System#Threading#Tasks#Dataflow#ISourceBlock&lt;System#Tuple&lt;System#Collections#Generic#IList&lt;T1&gt;,System#Collections#Generic#IList&lt;T2&gt;,System#Collections#Generic#IList&lt;T3&gt;&gt;&gt;#ReleaseReservation(System.Threading.Tasks.Dataflow.DataflowMessageHeader,System.Threading.Tasks.Dataflow.ITargetBlock{System.Tuple{System.Collections.Generic.IList{`0},System.Collections.Generic.IList{`1},System.Collections.Generic.IList{`2}}})" />
      <MemberSignature Language="VB.NET" Value="Sub ReleaseReservation (messageHeader As DataflowMessageHeader, target As ITargetBlock(Of Tuple(Of IList(Of T1), IList(Of T2), IList(Of T3)))) Implements ISourceBlock(Of Tuple(Of IList(Of T1), IList(Of T2), IList(Of T3))).ReleaseReservation" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Threading.Tasks.Dataflow.ISourceBlock&lt;System.Tuple&lt;System.Collections.Generic.IList&lt;T1&gt;,System.Collections.Generic.IList&lt;T2&gt;,System.Collections.Generic.IList&lt;T3&gt;&gt;&gt;.ReleaseReservation(System::Threading::Tasks::Dataflow::DataflowMessageHeader messageHeader, System::Threading::Tasks::Dataflow::ITargetBlock&lt;Tuple&lt;System::Collections::Generic::IList&lt;T1&gt; ^, System::Collections::Generic::IList&lt;T2&gt; ^, System::Collections::Generic::IList&lt;T3&gt; ^&gt; ^&gt; ^ target) = System::Threading::Tasks::Dataflow::ISourceBlock&lt;Tuple&lt;System::Collections::Generic::IList&lt;T1&gt; ^, System::Collections::Generic::IList&lt;T2&gt; ^, System::Collections::Generic::IList&lt;T3&gt; ^&gt; ^&gt;::ReleaseReservation;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Threading.Tasks.Dataflow.ISourceBlock`1.ReleaseReservation(System.Threading.Tasks.Dataflow.DataflowMessageHeader,System.Threading.Tasks.Dataflow.ITargetBlock{`0})</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Dataflow</AssemblyName>
        <AssemblyVersion>4.6.0.0</AssemblyVersion>
        <AssemblyVersion>4.6.1.0</AssemblyVersion>
        <AssemblyVersion>4.6.2.0</AssemblyVersion>
        <AssemblyVersion>4.6.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="messageHeader" Type="System.Threading.Tasks.Dataflow.DataflowMessageHeader" />
        <Parameter Name="target" Type="System.Threading.Tasks.Dataflow.ITargetBlock&lt;System.Tuple&lt;System.Collections.Generic.IList&lt;T1&gt;,System.Collections.Generic.IList&lt;T2&gt;,System.Collections.Generic.IList&lt;T3&gt;&gt;&gt;" />
      </Parameters>
      <Docs>
        <param name="messageHeader">To be added.</param>
        <param name="target">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Threading.Tasks.Dataflow.ISourceBlock&lt;System.Tuple&lt;System.Collections.Generic.IList&lt;T1&gt;,System.Collections.Generic.IList&lt;T2&gt;,System.Collections.Generic.IList&lt;T3&gt;&gt;&gt;.ReserveMessage">
      <MemberSignature Language="C#" Value="bool ISourceBlock&lt;Tuple&lt;IList&lt;T1&gt;,IList&lt;T2&gt;,IList&lt;T3&gt;&gt;&gt;.ReserveMessage (System.Threading.Tasks.Dataflow.DataflowMessageHeader messageHeader, System.Threading.Tasks.Dataflow.ITargetBlock&lt;Tuple&lt;System.Collections.Generic.IList&lt;T1&gt;,System.Collections.Generic.IList&lt;T2&gt;,System.Collections.Generic.IList&lt;T3&gt;&gt;&gt; target);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.Threading.Tasks.Dataflow.ISourceBlock&lt;System.Tuple&lt;System.Collections.Generic.IList&lt;T1&gt;,System.Collections.Generic.IList&lt;T2&gt;,System.Collections.Generic.IList&lt;T3&gt;&gt;&gt;.ReserveMessage(valuetype System.Threading.Tasks.Dataflow.DataflowMessageHeader messageHeader, class System.Threading.Tasks.Dataflow.ITargetBlock`1&lt;class System.Tuple`3&lt;class System.Collections.Generic.IList`1&lt;!T1&gt;, class System.Collections.Generic.IList`1&lt;!T2&gt;, class System.Collections.Generic.IList`1&lt;!T3&gt;&gt;&gt; target) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Dataflow.BatchedJoinBlock`3.System#Threading#Tasks#Dataflow#ISourceBlock&lt;System#Tuple&lt;System#Collections#Generic#IList&lt;T1&gt;,System#Collections#Generic#IList&lt;T2&gt;,System#Collections#Generic#IList&lt;T3&gt;&gt;&gt;#ReserveMessage(System.Threading.Tasks.Dataflow.DataflowMessageHeader,System.Threading.Tasks.Dataflow.ITargetBlock{System.Tuple{System.Collections.Generic.IList{`0},System.Collections.Generic.IList{`1},System.Collections.Generic.IList{`2}}})" />
      <MemberSignature Language="VB.NET" Value="Function ReserveMessage (messageHeader As DataflowMessageHeader, target As ITargetBlock(Of Tuple(Of IList(Of T1), IList(Of T2), IList(Of T3)))) As Boolean Implements ISourceBlock(Of Tuple(Of IList(Of T1), IList(Of T2), IList(Of T3))).ReserveMessage" />
      <MemberSignature Language="C++ CLI" Value=" virtual bool System.Threading.Tasks.Dataflow.ISourceBlock&lt;System.Tuple&lt;System.Collections.Generic.IList&lt;T1&gt;,System.Collections.Generic.IList&lt;T2&gt;,System.Collections.Generic.IList&lt;T3&gt;&gt;&gt;.ReserveMessage(System::Threading::Tasks::Dataflow::DataflowMessageHeader messageHeader, System::Threading::Tasks::Dataflow::ITargetBlock&lt;Tuple&lt;System::Collections::Generic::IList&lt;T1&gt; ^, System::Collections::Generic::IList&lt;T2&gt; ^, System::Collections::Generic::IList&lt;T3&gt; ^&gt; ^&gt; ^ target) = System::Threading::Tasks::Dataflow::ISourceBlock&lt;Tuple&lt;System::Collections::Generic::IList&lt;T1&gt; ^, System::Collections::Generic::IList&lt;T2&gt; ^, System::Collections::Generic::IList&lt;T3&gt; ^&gt; ^&gt;::ReserveMessage;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Threading.Tasks.Dataflow.ISourceBlock`1.ReserveMessage(System.Threading.Tasks.Dataflow.DataflowMessageHeader,System.Threading.Tasks.Dataflow.ITargetBlock{`0})</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Dataflow</AssemblyName>
        <AssemblyVersion>4.6.0.0</AssemblyVersion>
        <AssemblyVersion>4.6.1.0</AssemblyVersion>
        <AssemblyVersion>4.6.2.0</AssemblyVersion>
        <AssemblyVersion>4.6.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="messageHeader" Type="System.Threading.Tasks.Dataflow.DataflowMessageHeader" />
        <Parameter Name="target" Type="System.Threading.Tasks.Dataflow.ITargetBlock&lt;System.Tuple&lt;System.Collections.Generic.IList&lt;T1&gt;,System.Collections.Generic.IList&lt;T2&gt;,System.Collections.Generic.IList&lt;T3&gt;&gt;&gt;" />
      </Parameters>
      <Docs>
        <param name="messageHeader">To be added.</param>
        <param name="target">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Target1">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Dataflow.ITargetBlock&lt;T1&gt; Target1 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Threading.Tasks.Dataflow.ITargetBlock`1&lt;!T1&gt; Target1" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.Dataflow.BatchedJoinBlock`3.Target1" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Target1 As ITargetBlock(Of T1)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Threading::Tasks::Dataflow::ITargetBlock&lt;T1&gt; ^ Target1 { System::Threading::Tasks::Dataflow::ITargetBlock&lt;T1&gt; ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Dataflow</AssemblyName>
        <AssemblyVersion>4.6.0.0</AssemblyVersion>
        <AssemblyVersion>4.6.1.0</AssemblyVersion>
        <AssemblyVersion>4.6.2.0</AssemblyVersion>
        <AssemblyVersion>4.6.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Dataflow.ITargetBlock&lt;T1&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="afef2-136">Obtém um destino que pode ser usado para oferecer mensagens do primeiro tipo.</span><span class="sxs-lookup"><span data-stu-id="afef2-136">Gets a target that may be used to offer messages of the first type.</span></span></summary>
        <value><span data-ttu-id="afef2-137">O destino.</span><span class="sxs-lookup"><span data-stu-id="afef2-137">The target.</span></span></value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Target2">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Dataflow.ITargetBlock&lt;T2&gt; Target2 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Threading.Tasks.Dataflow.ITargetBlock`1&lt;!T2&gt; Target2" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.Dataflow.BatchedJoinBlock`3.Target2" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Target2 As ITargetBlock(Of T2)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Threading::Tasks::Dataflow::ITargetBlock&lt;T2&gt; ^ Target2 { System::Threading::Tasks::Dataflow::ITargetBlock&lt;T2&gt; ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Dataflow</AssemblyName>
        <AssemblyVersion>4.6.0.0</AssemblyVersion>
        <AssemblyVersion>4.6.1.0</AssemblyVersion>
        <AssemblyVersion>4.6.2.0</AssemblyVersion>
        <AssemblyVersion>4.6.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Dataflow.ITargetBlock&lt;T2&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="afef2-138">Obtém um destino que pode ser usado para oferecer mensagens do segundo tipo.</span><span class="sxs-lookup"><span data-stu-id="afef2-138">Gets a target that may be used to offer messages of the second type.</span></span></summary>
        <value><span data-ttu-id="afef2-139">O destino.</span><span class="sxs-lookup"><span data-stu-id="afef2-139">The target.</span></span></value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Target3">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Dataflow.ITargetBlock&lt;T3&gt; Target3 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Threading.Tasks.Dataflow.ITargetBlock`1&lt;!T3&gt; Target3" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.Dataflow.BatchedJoinBlock`3.Target3" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Target3 As ITargetBlock(Of T3)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Threading::Tasks::Dataflow::ITargetBlock&lt;T3&gt; ^ Target3 { System::Threading::Tasks::Dataflow::ITargetBlock&lt;T3&gt; ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Dataflow</AssemblyName>
        <AssemblyVersion>4.6.0.0</AssemblyVersion>
        <AssemblyVersion>4.6.1.0</AssemblyVersion>
        <AssemblyVersion>4.6.2.0</AssemblyVersion>
        <AssemblyVersion>4.6.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Dataflow.ITargetBlock&lt;T3&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="afef2-140">Obtém um destino que pode ser usado para oferecer mensagens do terceiro tipo.</span><span class="sxs-lookup"><span data-stu-id="afef2-140">Gets a target that may be used to offer messages of the third type.</span></span></summary>
        <value><span data-ttu-id="afef2-141">O destino.</span><span class="sxs-lookup"><span data-stu-id="afef2-141">The target.</span></span></value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Dataflow.BatchedJoinBlock`3.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Dataflow</AssemblyName>
        <AssemblyVersion>4.6.0.0</AssemblyVersion>
        <AssemblyVersion>4.6.1.0</AssemblyVersion>
        <AssemblyVersion>4.6.2.0</AssemblyVersion>
        <AssemblyVersion>4.6.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="afef2-142">Retorna uma cadeia de caracteres que representa o nome formatado desta instância <see cref="T:System.Threading.Tasks.Dataflow.IDataflowBlock" />.</span><span class="sxs-lookup"><span data-stu-id="afef2-142">Returns a string that represents the formatted name of this  <see cref="T:System.Threading.Tasks.Dataflow.IDataflowBlock" /> instance.</span></span></summary>
        <returns><span data-ttu-id="afef2-143">Uma cadeia de caracteres que representa o nome formatado desta instância <see cref="T:System.Threading.Tasks.Dataflow.IDataflowBlock" />.</span><span class="sxs-lookup"><span data-stu-id="afef2-143">A string that represents the formatted name of this  <see cref="T:System.Threading.Tasks.Dataflow.IDataflowBlock" /> instance.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryReceive">
      <MemberSignature Language="C#" Value="public bool TryReceive (Predicate&lt;Tuple&lt;System.Collections.Generic.IList&lt;T1&gt;,System.Collections.Generic.IList&lt;T2&gt;,System.Collections.Generic.IList&lt;T3&gt;&gt;&gt; filter, out Tuple&lt;System.Collections.Generic.IList&lt;T1&gt;,System.Collections.Generic.IList&lt;T2&gt;,System.Collections.Generic.IList&lt;T3&gt;&gt; item);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool TryReceive(class System.Predicate`1&lt;class System.Tuple`3&lt;class System.Collections.Generic.IList`1&lt;!T1&gt;, class System.Collections.Generic.IList`1&lt;!T2&gt;, class System.Collections.Generic.IList`1&lt;!T3&gt;&gt;&gt; filter, [out] class System.Tuple`3&lt;class System.Collections.Generic.IList`1&lt;!T1&gt;, class System.Collections.Generic.IList`1&lt;!T2&gt;, class System.Collections.Generic.IList`1&lt;!T3&gt;&gt;&amp; item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Dataflow.BatchedJoinBlock`3.TryReceive(System.Predicate{System.Tuple{System.Collections.Generic.IList{`0},System.Collections.Generic.IList{`1},System.Collections.Generic.IList{`2}}},System.Tuple{System.Collections.Generic.IList{`0},System.Collections.Generic.IList{`1},System.Collections.Generic.IList{`2}}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryReceive (filter As Predicate(Of Tuple(Of IList(Of T1), IList(Of T2), IList(Of T3))), ByRef item As Tuple(Of IList(Of T1), IList(Of T2), IList(Of T3))) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool TryReceive(Predicate&lt;Tuple&lt;System::Collections::Generic::IList&lt;T1&gt; ^, System::Collections::Generic::IList&lt;T2&gt; ^, System::Collections::Generic::IList&lt;T3&gt; ^&gt; ^&gt; ^ filter, [Runtime::InteropServices::Out] Tuple&lt;System::Collections::Generic::IList&lt;T1&gt; ^, System::Collections::Generic::IList&lt;T2&gt; ^, System::Collections::Generic::IList&lt;T3&gt; ^&gt; ^ % item);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Dataflow</AssemblyName>
        <AssemblyVersion>4.6.0.0</AssemblyVersion>
        <AssemblyVersion>4.6.1.0</AssemblyVersion>
        <AssemblyVersion>4.6.2.0</AssemblyVersion>
        <AssemblyVersion>4.6.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="filter" Type="System.Predicate&lt;System.Tuple&lt;System.Collections.Generic.IList&lt;T1&gt;,System.Collections.Generic.IList&lt;T2&gt;,System.Collections.Generic.IList&lt;T3&gt;&gt;&gt;" />
        <Parameter Name="item" Type="System.Tuple&lt;System.Collections.Generic.IList&lt;T1&gt;,System.Collections.Generic.IList&lt;T2&gt;,System.Collections.Generic.IList&lt;T3&gt;&gt;&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="filter"><span data-ttu-id="afef2-144">O predicado que um valor precisa passar com êxito para ser recebido.</span><span class="sxs-lookup"><span data-stu-id="afef2-144">The predicate a value must successfully pass in order for it to be received.</span></span>  <span data-ttu-id="afef2-145"><c>filter</c> pode ser <see langword="null" />, quanto então todos os itens passarão.</span><span class="sxs-lookup"><span data-stu-id="afef2-145"><c>filter</c> may be <see langword="null" /> in which case all items will pass.</span></span></param>
        <param name="item"><span data-ttu-id="afef2-146">O item recebido da origem.</span><span class="sxs-lookup"><span data-stu-id="afef2-146">The item received from the source.</span></span></param>
        <summary><span data-ttu-id="afef2-147">Tentativas de receber assincronamente um item de saída disponível do <see cref="T:System.Threading.Tasks.Dataflow.IReceivableSourceBlock`1" />.</span><span class="sxs-lookup"><span data-stu-id="afef2-147">Attempts to synchronously receive an available output item from the <see cref="T:System.Threading.Tasks.Dataflow.IReceivableSourceBlock`1" />.</span></span></summary>
        <returns>
          <span data-ttu-id="afef2-148"><see langword="true" /> se foi possível receber um item; caso contrário, <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="afef2-148"><see langword="true" /> if an item could be received; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="afef2-149">Esse método não bloqueia a espera para a fonte para fornecer um item.</span><span class="sxs-lookup"><span data-stu-id="afef2-149">This method does not block waiting for the source to provide an item.</span></span>  
  
 <span data-ttu-id="afef2-150">Será retornado após a verificação de um elemento, se um elemento estava disponível ou não.</span><span class="sxs-lookup"><span data-stu-id="afef2-150">It will return after checking for an element, whether or not an element was available.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryReceiveAll">
      <MemberSignature Language="C#" Value="public bool TryReceiveAll (out System.Collections.Generic.IList&lt;Tuple&lt;System.Collections.Generic.IList&lt;T1&gt;,System.Collections.Generic.IList&lt;T2&gt;,System.Collections.Generic.IList&lt;T3&gt;&gt;&gt; items);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool TryReceiveAll([out] class System.Collections.Generic.IList`1&lt;class System.Tuple`3&lt;class System.Collections.Generic.IList`1&lt;!T1&gt;, class System.Collections.Generic.IList`1&lt;!T2&gt;, class System.Collections.Generic.IList`1&lt;!T3&gt;&gt;&gt;&amp; items) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Dataflow.BatchedJoinBlock`3.TryReceiveAll(System.Collections.Generic.IList{System.Tuple{System.Collections.Generic.IList{`0},System.Collections.Generic.IList{`1},System.Collections.Generic.IList{`2}}}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryReceiveAll (ByRef items As IList(Of Tuple(Of IList(Of T1), IList(Of T2), IList(Of T3)))) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool TryReceiveAll([Runtime::InteropServices::Out] System::Collections::Generic::IList&lt;Tuple&lt;System::Collections::Generic::IList&lt;T1&gt; ^, System::Collections::Generic::IList&lt;T2&gt; ^, System::Collections::Generic::IList&lt;T3&gt; ^&gt; ^&gt; ^ % items);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Dataflow</AssemblyName>
        <AssemblyVersion>4.6.0.0</AssemblyVersion>
        <AssemblyVersion>4.6.1.0</AssemblyVersion>
        <AssemblyVersion>4.6.2.0</AssemblyVersion>
        <AssemblyVersion>4.6.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="items" Type="System.Collections.Generic.IList&lt;System.Tuple&lt;System.Collections.Generic.IList&lt;T1&gt;,System.Collections.Generic.IList&lt;T2&gt;,System.Collections.Generic.IList&lt;T3&gt;&gt;&gt;&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="items"><span data-ttu-id="afef2-151">Os itens recebidos da origem.</span><span class="sxs-lookup"><span data-stu-id="afef2-151">The items received from the source.</span></span></param>
        <summary><span data-ttu-id="afef2-152">Tentativas de receber assincronamente todos os itens disponíveis do <see cref="T:System.Threading.Tasks.Dataflow.IReceivableSourceBlock`1" />.</span><span class="sxs-lookup"><span data-stu-id="afef2-152">Attempts to synchronously receive all available items from the <see cref="T:System.Threading.Tasks.Dataflow.IReceivableSourceBlock`1" />.</span></span></summary>
        <returns>
          <span data-ttu-id="afef2-153"><see langword="true" /> se foi possível receber um ou mais itens; caso contrário, <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="afef2-153"><see langword="true" /> if one or more items could be received; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="afef2-154">Esse método não bloqueia a espera para a fonte para fornecer um item.</span><span class="sxs-lookup"><span data-stu-id="afef2-154">This method does not block waiting for the source to provide an item.</span></span>  
  
 <span data-ttu-id="afef2-155">Será retornado após a verificação de elementos, se um elemento estava disponível ou não.</span><span class="sxs-lookup"><span data-stu-id="afef2-155">It will return after checking for elements, whether or not an element was available.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>