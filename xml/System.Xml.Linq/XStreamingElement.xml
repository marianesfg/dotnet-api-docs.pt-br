<Type Name="XStreamingElement" FullName="System.Xml.Linq.XStreamingElement">
  <TypeSignature Language="C#" Value="public class XStreamingElement" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit XStreamingElement extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Xml.Linq.XStreamingElement" />
  <TypeSignature Language="VB.NET" Value="Public Class XStreamingElement" />
  <TypeSignature Language="C++ CLI" Value="public ref class XStreamingElement" />
  <AssemblyInfo>
    <AssemblyName>System.Xml.XDocument</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Xml.Linq</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary><span data-ttu-id="7f255-101">Representa os elementos em uma árvore XML que dá suporte à saída de transmissão adiada.</span><span class="sxs-lookup"><span data-stu-id="7f255-101">Represents elements in an XML tree that supports deferred streaming output.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="7f255-102">Essa classe permite que você crie uma árvore XML que dá suporte à saída de transmissão adiada.</span><span class="sxs-lookup"><span data-stu-id="7f255-102">This class allows you to create an XML tree that supports deferred streaming output.</span></span> <span data-ttu-id="7f255-103">Use essa classe para criar uma árvore XML de maneira muito semelhante à criação de uma árvore XML com <xref:System.Xml.Linq.XElement>.</span><span class="sxs-lookup"><span data-stu-id="7f255-103">You use this class to create an XML tree in a very similar fashion to creating an XML tree using <xref:System.Xml.Linq.XElement>.</span></span> <span data-ttu-id="7f255-104">No entanto, há uma diferença fundamental.</span><span class="sxs-lookup"><span data-stu-id="7f255-104">However, there is a fundamental difference.</span></span> <span data-ttu-id="7f255-105">Quando você usa uma consulta LINQ para especificar o conteúdo ao criar um XML de árvore usando <xref:System.Xml.Linq.XElement>, a variável de consulta é iterada no momento da construção da árvore XML e os resultados da consulta são adicionados à árvore XML.</span><span class="sxs-lookup"><span data-stu-id="7f255-105">When you use a LINQ query to specify content when creating an XML tree using <xref:System.Xml.Linq.XElement>, the query variable is iterated at the time of construction of the XML tree, and the results of the query are added to the XML tree.</span></span> <span data-ttu-id="7f255-106">Por outro lado, ao criar uma árvore XML com <xref:System.Xml.Linq.XStreamingElement>, uma referência à variável de consulta é armazenada na árvore XML sem iterado.</span><span class="sxs-lookup"><span data-stu-id="7f255-106">In contrast, when you create an XML tree using <xref:System.Xml.Linq.XStreamingElement>, a reference to the query variable is stored in the XML tree without being iterated.</span></span> <span data-ttu-id="7f255-107">Consultas são iteradas somente após a serialização.</span><span class="sxs-lookup"><span data-stu-id="7f255-107">Queries are iterated only upon serialization.</span></span> <span data-ttu-id="7f255-108">Isso permite que você crie maior árvores XML, mantendo um menor volume de memória.</span><span class="sxs-lookup"><span data-stu-id="7f255-108">This allows you to create larger XML trees while maintaining a smaller memory footprint.</span></span>  
  
 <span data-ttu-id="7f255-109">Se você estiver realizando o streaming de uma fonte de entrada, como um arquivo de texto, você pode ler um arquivo de texto muito grandes e gerar um documento XML muito grande, mantendo um espaço de memória pequenos.</span><span class="sxs-lookup"><span data-stu-id="7f255-109">If you are streaming from an input source, such as a text file, then you can read a very large text file, and generate a very large XML document while maintaining a small memory footprint.</span></span>  
  
 <span data-ttu-id="7f255-110">Outro cenário é que você tem uma grande árvore XML que tenha sido carregada na memória, e você deseja criar uma versão transformada do documento.</span><span class="sxs-lookup"><span data-stu-id="7f255-110">Another scenario is that you have a large XML tree that has been loaded into memory, and you want to create a transformed version of the document.</span></span> <span data-ttu-id="7f255-111">Se você criar um novo documento usando <xref:System.Xml.Linq.XElement>, em seguida, você terá duas árvores XML grandes na memória após a conclusão da transformação.</span><span class="sxs-lookup"><span data-stu-id="7f255-111">If you create a new document using <xref:System.Xml.Linq.XElement>, then you will have two large XML trees in memory upon completion of the transformation.</span></span> <span data-ttu-id="7f255-112">No entanto, se você criar a nova árvore XML com <xref:System.Xml.Linq.XStreamingElement>, em seguida, o conjunto de trabalho será retirado efetivamente na metade.</span><span class="sxs-lookup"><span data-stu-id="7f255-112">However, if you create the new XML tree using <xref:System.Xml.Linq.XStreamingElement>, then your working set will be effectively cut in half.</span></span>  
  
 <span data-ttu-id="7f255-113">Observe que durante a depuração de um programa que usa <xref:System.Xml.Linq.XStreamingElement>, exibir o valor de um objeto faz com que seu <xref:System.Xml.Linq.XStreamingElement.ToString%2A> método a ser chamado.</span><span class="sxs-lookup"><span data-stu-id="7f255-113">Note that when debugging a program that uses <xref:System.Xml.Linq.XStreamingElement>, displaying the value of an object causes its <xref:System.Xml.Linq.XStreamingElement.ToString%2A> method to be called.</span></span> <span data-ttu-id="7f255-114">Isso faz com que o XML a ser serializado.</span><span class="sxs-lookup"><span data-stu-id="7f255-114">This causes the XML to be serialized.</span></span> <span data-ttu-id="7f255-115">Se a semântica da consulta elemento streaming, de modo que o elemento de streaming só pode ser transmitido uma vez, isso pode causar comportamento indesejado na sua experiência de depuração.</span><span class="sxs-lookup"><span data-stu-id="7f255-115">If the semantics of your streaming element query are such that the streaming element can only be streamed once, this may cause undesirable behavior in your debugging experience.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="7f255-116">O exemplo a seguir cria uma árvore XML de origem.</span><span class="sxs-lookup"><span data-stu-id="7f255-116">The following example first creates a source XML tree.</span></span> <span data-ttu-id="7f255-117">Ele cria uma transformação de origem XML árvore usando <xref:System.Xml.Linq.XElement>.</span><span class="sxs-lookup"><span data-stu-id="7f255-117">It then creates a transform of the source XML tree using <xref:System.Xml.Linq.XElement>.</span></span> <span data-ttu-id="7f255-118">Essa transformação cria uma nova árvore na memória.</span><span class="sxs-lookup"><span data-stu-id="7f255-118">This transform creates a new tree in memory.</span></span> <span data-ttu-id="7f255-119">Ele cria uma transformação de origem XML árvore usando <xref:System.Xml.Linq.XStreamingElement>.</span><span class="sxs-lookup"><span data-stu-id="7f255-119">It then creates a transform of the source XML tree using <xref:System.Xml.Linq.XStreamingElement>.</span></span> <span data-ttu-id="7f255-120">Essa transformação não executa a consulta até que a árvore transformada é serializada no console.</span><span class="sxs-lookup"><span data-stu-id="7f255-120">This transform doesn't execute the query until the transformed tree is serialized to the console.</span></span> <span data-ttu-id="7f255-121">O uso de memória é menor.</span><span class="sxs-lookup"><span data-stu-id="7f255-121">Its memory usage is less.</span></span>  
  
```csharp  
XElement srcTree = new XElement("Root",  
                       new XElement("Child", 1),  
                       new XElement("Child", 2),  
                       new XElement("Child", 3),  
                       new XElement("Child", 4),  
                       new XElement("Child", 5)  
                   );  
  
XElement dstTree1 = new XElement("NewRoot",  
                        from el in srcTree.Elements()  
                        where (int)el >= 3  
                        select new XElement("DifferentChild", (int)el)  
                    );  
  
XStreamingElement dstTree2 = new XStreamingElement("NewRoot",  
                        from el in srcTree.Elements()  
                        where (int)el >= 3  
                        select new XElement("DifferentChild", (int)el)  
                    );  
  
Console.WriteLine(dstTree1);  
Console.WriteLine("------");  
Console.WriteLine(dstTree2);  
```  
  
```vb  
Dim srcTree As XElement = _  
        <Root>  
            <Child>1</Child>  
            <Child>2</Child>  
            <Child>3</Child>  
            <Child>4</Child>  
            <Child>5</Child>  
        </Root>  
  
Dim dstTree1 As XElement = _  
    <NewRoot>  
        <%= From el In srcTree.Elements _  
            Where (el.Value >= 3) _  
            Select <DifferentChild><%= el.Value %></DifferentChild> %>  
    </NewRoot>  
  
Dim dstTree2 As XStreamingElement = New XStreamingElement("NewRoot", _  
                From el In srcTree.Elements _  
                Where el.Value >= 3 _  
                Select <DifferentChild><%= el.Value %></DifferentChild> _  
            )  
  
Console.WriteLine(dstTree1)  
Console.WriteLine("------")  
Console.WriteLine(dstTree2)  
```  
  
 <span data-ttu-id="7f255-122">Este exemplo gera a seguinte saída:</span><span class="sxs-lookup"><span data-stu-id="7f255-122">This example produces the following output:</span></span>  
  
```  
<NewRoot>  
  <DifferentChild>3</DifferentChild>  
  <DifferentChild>4</DifferentChild>  
  <DifferentChild>5</DifferentChild>  
</NewRoot>  
------  
<NewRoot>  
  <DifferentChild>3</DifferentChild>  
  <DifferentChild>4</DifferentChild>  
  <DifferentChild>5</DifferentChild>  
</NewRoot>  
```  
  
 <span data-ttu-id="7f255-123">Uma abordagem para processar um arquivo de texto é escrever um método de extensão que passa o arquivo de texto uma linha em uma hora usando a compilação de `yield return` .</span><span class="sxs-lookup"><span data-stu-id="7f255-123">One approach to processing a text file is to write an extension method that streams the text file a line at a time using the `yield return` construct.</span></span> <span data-ttu-id="7f255-124">Você então pode escrever uma consulta LINQ que processa o arquivo de texto em uma forma adiada lazy.</span><span class="sxs-lookup"><span data-stu-id="7f255-124">You then can write a LINQ query that processes the text file in a lazy deferred fashion.</span></span> <span data-ttu-id="7f255-125">Se você usar o <xref:System.Xml.Linq.XStreamingElement> para saída de fluxo, você pode criar uma transformação do arquivo de texto para XML que usa uma quantidade mínima de memória, independentemente do tamanho do arquivo de texto de origem.</span><span class="sxs-lookup"><span data-stu-id="7f255-125">If you then use the <xref:System.Xml.Linq.XStreamingElement> to stream output, you then can create a transform from the text file to XML that uses a minimal amount of memory, regardless of the size of the source text file.</span></span>  
  
 <span data-ttu-id="7f255-126">O seguinte arquivo de texto, People.txt, é a fonte para esse exemplo.</span><span class="sxs-lookup"><span data-stu-id="7f255-126">The following text file, People.txt, is the source for this example.</span></span>  
  
```  
#This is a comment  
1,Tai,Yee,Writer  
2,Nikolay,Grachev,Programmer  
3,David,Wright,Inventor  
```  
  
 <span data-ttu-id="7f255-127">O código a seguir contém um método de extensão que passa as linhas do arquivo de texto em uma forma adiada.</span><span class="sxs-lookup"><span data-stu-id="7f255-127">The following code contains an extension method that streams the lines of the text file in a deferred fashion.</span></span>  
  
```csharp  
public static class StreamReaderSequence  
{  
    public static IEnumerable<string> Lines(this StreamReader source)  
    {  
        String line;  
  
        if (source == null)  
            throw new ArgumentNullException("source");  
        while ((line = source.ReadLine()) != null)  
        {  
            yield return line;  
        }  
    }  
}  
  
class Program  
{  
    static void Main(string[] args)  
    {  
        StreamReader sr = new StreamReader("People.txt");  
        XStreamingElement xmlTree = new XStreamingElement("Root",  
            from line in sr.Lines()  
            let items = line.Split(',')  
            where !line.StartsWith("#")  
            select new XElement("Person",  
                       new XAttribute("ID", items[0]),  
                       new XElement("First", items[1]),  
                       new XElement("Last", items[2]),  
                       new XElement("Occupation", items[3])  
                   )  
        );  
        Console.WriteLine(xmlTree);  
        sr.Close();  
    }  
}  
```  
  
```vb  
Module StreamReaderSequence  
  
    <Runtime.CompilerServices.Extension>  
    Public Iterator Function Lines(source As IO.StreamReader) As IEnumerable(Of String)  
        If source Is Nothing Then Throw New ArgumentNullException("source")  
        Dim line As String = source.ReadLine()  
        While (line <> Nothing)  
            Yield line  
            line = source.ReadLine()  
        End While  
    End Function  
  
End Module  
  
Module Module1  
    Sub Main()  
        Dim sr As New IO.StreamReader("People.txt")  
        Dim xmlTree As New XStreamingElement("Root",  
            From line In sr.Lines()  
            Let items = line.Split(","c)  
            Where Not line.StartsWith("#")  
            Select <Person ID=<%= items(0) %>>  
                       <First><%= items(1) %></First>  
                       <Last><%= items(2) %></Last>  
                       <Occupation><%= items(3) %></Occupation>  
                   </Person>)  
        Console.WriteLine(xmlTree)  
        sr.Close()  
    End Sub  
End Module  
```  
  
 <span data-ttu-id="7f255-128">Este exemplo gera a seguinte saída:</span><span class="sxs-lookup"><span data-stu-id="7f255-128">This example produces the following output:</span></span>  
  
```xml  
<Root>  
  <Person ID="1">  
    <First>Tai</First>  
    <Last>Yee</Last>  
    <Occupation>Writer</Occupation>  
  </Person>  
  <Person ID="2">  
    <First>Nikolay</First>  
    <Last>Grachev</Last>  
    <Occupation>Programmer</Occupation>  
  </Person>  
  <Person ID="3">  
    <First>David</First>  
    <Last>Wright</Last>  
    <Occupation>Inventor</Occupation>  
  </Person>  
</Root>  
```  
  
 <span data-ttu-id="7f255-129">Às vezes você precisa transformar grandes arquivos XML e escrever seu aplicativo de modo que os requisitos de memória do aplicativo sejam previsíveis.</span><span class="sxs-lookup"><span data-stu-id="7f255-129">Sometimes you have to transform large XML files, and write your application so that the memory footprint of the application is predictable.</span></span> <span data-ttu-id="7f255-130">Se você tentar preencher uma árvore XML com um arquivo XML muito grande, seu uso de memória será proporcional ao tamanho do arquivo (isto é, excessivo).</span><span class="sxs-lookup"><span data-stu-id="7f255-130">If you try to populate an XML tree with a very large XML file, your memory usage will be proportional to the size of the file (that is, excessive).</span></span> <span data-ttu-id="7f255-131">Portanto, você deve usar uma técnica de streaming em vez disso.</span><span class="sxs-lookup"><span data-stu-id="7f255-131">Therefore, you should use a streaming technique instead.</span></span>  
  
 <span data-ttu-id="7f255-132">Determinados operadores de consulta padrão, como <xref:System.Linq.Enumerable.OrderBy%2A>, iteram sua origem, coletam todos os dados, classificam e, em seguida, geram finalmente o primeiro item na sequência.</span><span class="sxs-lookup"><span data-stu-id="7f255-132">Certain standard query operators, such as <xref:System.Linq.Enumerable.OrderBy%2A>, iterate their source, collect all of the data, sort it, and then finally yield the first item in the sequence.</span></span> <span data-ttu-id="7f255-133">Observe que se você usar um operador de consulta que materializa sua origem antes de gerar o primeiro item, você não manterá um requisito pequeno de memória para seu aplicativo.</span><span class="sxs-lookup"><span data-stu-id="7f255-133">Note that if you use a query operator that materializes its source before yielding the first item, you will not retain a small memory footprint for your application.</span></span>  
  
 <span data-ttu-id="7f255-134">Mesmo se você usar a técnica descrita, se você tentar montar uma árvore XML que contém o documento transformado, uso de memória pode ser muito grande.</span><span class="sxs-lookup"><span data-stu-id="7f255-134">Even if you use the technique described in , if you try to assemble an XML tree that contains the transformed document, memory usage may be too great.</span></span>  
  
 <span data-ttu-id="7f255-135">O exemplo a seguir cria o exemplo na [como: fragmentos XML de fluxo com acesso a informações de cabeçalho](http://msdn.microsoft.com/library/01311522-9d03-4977-8641-2932c6f56092).</span><span class="sxs-lookup"><span data-stu-id="7f255-135">The following example builds on the example in [How to: Stream XML Fragments with Access to Header Information](http://msdn.microsoft.com/library/01311522-9d03-4977-8641-2932c6f56092).</span></span>  
  
 <span data-ttu-id="7f255-136">Este exemplo usa os recursos de execução adiada de <xref:System.Xml.Linq.XStreamingElement> para transmitir a saída.</span><span class="sxs-lookup"><span data-stu-id="7f255-136">This example uses the deferred execution capabilities of <xref:System.Xml.Linq.XStreamingElement> to stream the output.</span></span>  
  
 <span data-ttu-id="7f255-137">Observe que o eixo personalizado (`StreamCustomerItem`) é escrito especificamente para esperar um documento que tem os elementos `Customer`, `Name` e `Item`, e que esses elementos serão organizados como no documento Source.xml a seguir.</span><span class="sxs-lookup"><span data-stu-id="7f255-137">Note that the custom axis (`StreamCustomerItem`) is specifically written so that it expects a document that has `Customer`, `Name`, and `Item` elements, and that those elements will be arranged as in the following Source.xml document.</span></span> <span data-ttu-id="7f255-138">Uma implementação mais robusta, no entanto, validaria o documento de origem com um XSD ou seria preparada para analisar um documento inválido.</span><span class="sxs-lookup"><span data-stu-id="7f255-138">A more robust implementation, however, would either validate the source document with an XSD, or would be prepared to parse an invalid document.</span></span>  
  
 <span data-ttu-id="7f255-139">Veja a seguir o documento de origem, Source.xml:</span><span class="sxs-lookup"><span data-stu-id="7f255-139">The following is the source document, Source.xml:</span></span>  
  
```xml  
<?xml version="1.0" encoding="utf-8" ?>   
<Root>  
  <Customer>  
    <Name>A. Datum Corporation</Name>  
    <Item>  
      <Key>0001</Key>  
    </Item>  
    <Item>  
      <Key>0002</Key>  
    </Item>  
    <Item>  
      <Key>0003</Key>  
    </Item>  
    <Item>  
      <Key>0004</Key>  
    </Item>  
  </Customer>  
  <Customer>  
    <Name>Fabrikam, Inc.</Name>  
    <Item>  
      <Key>0005</Key>  
    </Item>  
    <Item>  
      <Key>0006</Key>  
    </Item>  
    <Item>  
      <Key>0007</Key>  
    </Item>  
    <Item>  
      <Key>0008</Key>  
    </Item>  
  </Customer>  
  <Customer>  
    <Name>Southridge Video</Name>  
    <Item>  
      <Key>0009</Key>  
    </Item>  
    <Item>  
      <Key>0010</Key>  
    </Item>  
  </Customer>  
</Root>  
```  
  
 <span data-ttu-id="7f255-140">O código a seguir contém um método que usa um <xref:System.Xml.XmlReader> para transmitir o XML de origem.</span><span class="sxs-lookup"><span data-stu-id="7f255-140">The following code contains a method that uses an <xref:System.Xml.XmlReader> to stream the source XML.</span></span> <span data-ttu-id="7f255-141">Ele usa <xref:System.Xml.Linq.XStreamingElement> para transmitir o novo XML.</span><span class="sxs-lookup"><span data-stu-id="7f255-141">It uses <xref:System.Xml.Linq.XStreamingElement> to stream the new XML.</span></span>  
  
```csharp  
static IEnumerable<XElement> StreamCustomerItem(string uri)  
{  
    using (XmlReader reader = XmlReader.Create(uri))  
    {  
        XElement name = null;  
        XElement item = null;  
  
        reader.MoveToContent();  
  
        // Parse the file, save header information when encountered, and yield the  
        // Item XElement objects as they are created.  
  
        // loop through Customer elements  
        while (reader.Read())  
        {  
            if (reader.NodeType == XmlNodeType.Element  
                && reader.Name == "Customer")  
            {  
                // move to Name element  
                while (reader.Read())  
                {  
                    if (reader.NodeType == XmlNodeType.Element &&  
                        reader.Name == "Name")  
                    {  
                        name = XElement.ReadFrom(reader) as XElement;  
                        break;  
                    }  
                }  
  
                // loop through Item elements  
                while (reader.Read())  
                {  
                    if (reader.NodeType == XmlNodeType.EndElement)  
                        break;  
                    if (reader.NodeType == XmlNodeType.Element  
                        && reader.Name == "Item")  
                    {  
                        item = XElement.ReadFrom(reader) as XElement;  
                        if (item != null)  
                        {  
                            XElement tempRoot = new XElement("Root",  
                                new XElement(name)  
                            );  
                            tempRoot.Add(item);  
                            yield return item;  
                        }  
                    }  
                }  
            }  
        }  
    }  
}  
  
static void Main(string[] args)  
{  
    XStreamingElement root = new XStreamingElement("Root",  
        from el in StreamCustomerItem("Source.xml")  
        select new XElement("Item",  
            new XElement("Customer", (string)el.Parent.Element("Name")),  
            new XElement(el.Element("Key"))  
        )  
    );  
    root.Save("Test.xml");  
    Console.WriteLine(File.ReadAllText("Test.xml"));  
}  
```  
  
```vb  
Iterator Function StreamCustomerItem(uri As String) As IEnumerable(Of XElement)  
  
    Dim name As XElement = Nothing  
    Dim item As XElement = Nothing  
  
    Dim reader As XmlReader = XmlReader.Create(uri)  
    reader.MoveToContent()  
  
    ' Parse the file, save header information when encountered, and yield the  
    ' Item XElement objects as they are created.  
  
    ' Loop through Customer elements.  
    While (reader.Read())  
        If (reader.NodeType = XmlNodeType.Element And reader.Name = "Customer") Then  
            While (reader.Read())  
                ' Move to Name element  
                If (reader.NodeType = XmlNodeType.Element And reader.Name = "Name") Then  
                    name = CType(XElement.ReadFrom(reader), XElement)  
                    Exit While  
                End If  
            End While  
  
            ' Loop through Item elements  
            While (reader.Read())  
                If (reader.NodeType = XmlNodeType.EndElement) Then  
                    Exit While  
                End If  
  
                If (reader.NodeType = XmlNodeType.Element And reader.Name = "Item") Then  
                    item = CType(XElement.ReadFrom(reader), XElement)  
                    If (Not (item Is Nothing)) Then  
                        Dim tempRoot = New XElement("Root",  
                            New XElement(name)  
                        )  
                        tempRoot.Add(item)  
                        Yield item  
                     End If  
                End If  
            End While  
        End If  
     End While  
    reader.Close()  
End Function  
  
Sub Main()  
    Dim root As New XStreamingElement("Root",  
        From el In StreamCustomerItem("c:\trash\Source.xml")  
        Select New XElement("Item",  
            New XElement("Customer", CStr(el.Parent.Element("Name"))),  
            New XElement(el.Element("Key"))))  
    root.Save("c:\trash\Test.xml")  
    Console.WriteLine(System.IO.File.ReadAllText("c:\trash\Test.xml"))  
End Sub  
```  
  
 <span data-ttu-id="7f255-142">Este exemplo gera a seguinte saída:</span><span class="sxs-lookup"><span data-stu-id="7f255-142">This example produces the following output:</span></span>  
  
```xml  
<?xml version="1.0" encoding="utf-8"?>  
<Root>  
  <Item>  
    <Customer>A. Datum Corporation</Customer>  
    <Key>0001</Key>  
  </Item>  
  <Item>  
    <Customer>A. Datum Corporation</Customer>  
    <Key>0002</Key>  
  </Item>  
  <Item>  
    <Customer>A. Datum Corporation</Customer>  
    <Key>0003</Key>  
  </Item>  
  <Item>  
    <Customer>A. Datum Corporation</Customer>  
    <Key>0004</Key>  
  </Item>  
  <Item>  
    <Customer>Fabrikam, Inc.</Customer>  
    <Key>0005</Key>  
  </Item>  
  <Item>  
    <Customer>Fabrikam, Inc.</Customer>  
    <Key>0006</Key>  
  </Item>  
  <Item>  
    <Customer>Fabrikam, Inc.</Customer>  
    <Key>0007</Key>  
  </Item>  
  <Item>  
    <Customer>Fabrikam, Inc.</Customer>  
    <Key>0008</Key>  
  </Item>  
  <Item>  
    <Customer>Southridge Video</Customer>  
    <Key>0009</Key>  
  </Item>  
  <Item>  
    <Customer>Southridge Video</Customer>  
    <Key>0010</Key>  
  </Item>  
</Root>  
```  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="7f255-143">Inicializa uma nova instância da classe <see cref="T:System.Xml.Linq.XStreamingElement" />.</span><span class="sxs-lookup"><span data-stu-id="7f255-143">Initializes a new instance of the <see cref="T:System.Xml.Linq.XStreamingElement" /> class.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="7f255-144">Consultas não são iteradas até que o <xref:System.Xml.Linq.XStreamingElement> é serializado.</span><span class="sxs-lookup"><span data-stu-id="7f255-144">Queries are not iterated until the <xref:System.Xml.Linq.XStreamingElement> is serialized.</span></span> <span data-ttu-id="7f255-145">Isso está em contraste com o uso de consultas para o conteúdo para um <xref:System.Xml.Linq.XElement>, onde consultas são iteradas no momento da construção do novo <xref:System.Xml.Linq.XElement>.</span><span class="sxs-lookup"><span data-stu-id="7f255-145">This is in contrast to using queries for content for an <xref:System.Xml.Linq.XElement>, where queries are iterated at the time of construction of the new <xref:System.Xml.Linq.XElement>.</span></span>  
  
 <span data-ttu-id="7f255-146">Para obter detalhes sobre o conteúdo válido que pode ser passado para o construtor, consulte [conteúdo válido de XElement e XDocument objetos](http://msdn.microsoft.com/library/aee2d319-5c5f-4b99-9bb4-2f58232577ae).</span><span class="sxs-lookup"><span data-stu-id="7f255-146">For details about the valid content that can be passed to this constructor, see [Valid Content of XElement and XDocument Objects](http://msdn.microsoft.com/library/aee2d319-5c5f-4b99-9bb4-2f58232577ae).</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XStreamingElement (System.Xml.Linq.XName name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Xml.Linq.XName name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XStreamingElement.#ctor(System.Xml.Linq.XName)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (name As XName)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; XStreamingElement(System::Xml::Linq::XName ^ name);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="name" Type="System.Xml.Linq.XName" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="7f255-147">Um <see cref="T:System.Xml.Linq.XName" /> que contém o nome do elemento.</span><span class="sxs-lookup"><span data-stu-id="7f255-147">An <see cref="T:System.Xml.Linq.XName" /> that contains the name of the element.</span></span></param>
        <summary><span data-ttu-id="7f255-148">Inicializa uma nova instância da classe <see cref="T:System.Xml.Linq.XElement" /> do <see cref="T:System.Xml.Linq.XName" /> especificado.</span><span class="sxs-lookup"><span data-stu-id="7f255-148">Initializes a new instance of the <see cref="T:System.Xml.Linq.XElement" /> class from the specified <see cref="T:System.Xml.Linq.XName" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="7f255-149">Este construtor cria um elemento de streaming com nenhum conteúdo e sem atributos.</span><span class="sxs-lookup"><span data-stu-id="7f255-149">This constructor creates a streaming element with no content and no attributes.</span></span>  
  
 <span data-ttu-id="7f255-150">Há uma conversão implícita de cadeia de caracteres para <xref:System.Xml.Linq.XName>.</span><span class="sxs-lookup"><span data-stu-id="7f255-150">There is an implicit conversion from string to <xref:System.Xml.Linq.XName>.</span></span> <span data-ttu-id="7f255-151">Um uso comum desse construtor é para especificar uma cadeia de caracteres como o parâmetro em vez de criar um novo <xref:System.Xml.Linq.XName>.</span><span class="sxs-lookup"><span data-stu-id="7f255-151">Typical use of this constructor is to specify a string as the parameter instead of creating a new <xref:System.Xml.Linq.XName>.</span></span>  
  
   
  
## Examples  
  
```csharp  
XElement srcTree = new XElement("Root",  
                       new XElement("Child", 1),  
                       new XElement("Child", 2),  
                       new XElement("Child", 3),  
                       new XElement("Child", 4),  
                       new XElement("Child", 5)  
                   );  
  
XStreamingElement dstTree = new XStreamingElement("NewRoot",  
                        from el in srcTree.Elements()  
                        where (int)el >= 3  
                        select new XElement("DifferentChild", (int)el)  
                    );  
  
Console.WriteLine(dstTree);  
```  
  
```vb  
Dim srcTree As XElement = _  
        <Root>  
            <Child>1</Child>  
            <Child>2</Child>  
            <Child>3</Child>  
            <Child>4</Child>  
            <Child>5</Child>  
        </Root>  
  
Dim dstTree As XStreamingElement = New XStreamingElement("NewRoot", _  
                From el In srcTree.Elements _  
                Where el.Value >= 3 _  
                Select <DifferentChild><%= el.Value %></DifferentChild> _  
            )  
  
Console.WriteLine(dstTree)  
```  
  
 <span data-ttu-id="7f255-152">Este exemplo gera a seguinte saída:</span><span class="sxs-lookup"><span data-stu-id="7f255-152">This example produces the following output:</span></span>  
  
```  
<NewRoot>  
  <DifferentChild>3</DifferentChild>  
  <DifferentChild>4</DifferentChild>  
  <DifferentChild>5</DifferentChild>  
</NewRoot>  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XStreamingElement (System.Xml.Linq.XName name, object content);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Xml.Linq.XName name, object content) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XStreamingElement.#ctor(System.Xml.Linq.XName,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (name As XName, content As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; XStreamingElement(System::Xml::Linq::XName ^ name, System::Object ^ content);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="name" Type="System.Xml.Linq.XName" />
        <Parameter Name="content" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="7f255-153">Um <see cref="T:System.Xml.Linq.XName" /> que contém o nome do elemento.</span><span class="sxs-lookup"><span data-stu-id="7f255-153">An <see cref="T:System.Xml.Linq.XName" /> that contains the element name.</span></span></param>
        <param name="content"><span data-ttu-id="7f255-154">O conteúdo do elemento.</span><span class="sxs-lookup"><span data-stu-id="7f255-154">The contents of the element.</span></span></param>
        <summary><span data-ttu-id="7f255-155">Inicializa uma nova instância da classe <see cref="T:System.Xml.Linq.XStreamingElement" /> com o nome e conteúdo especificados.</span><span class="sxs-lookup"><span data-stu-id="7f255-155">Initializes a new instance of the <see cref="T:System.Xml.Linq.XStreamingElement" /> class with the specified name and content.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="7f255-156">Este construtor cria um elemento de streaming com os atributos e o conteúdo especificado.</span><span class="sxs-lookup"><span data-stu-id="7f255-156">This constructor creates a streaming element with the specified content and attributes.</span></span>  
  
 <span data-ttu-id="7f255-157">Há uma conversão implícita de cadeia de caracteres para <xref:System.Xml.Linq.XName>.</span><span class="sxs-lookup"><span data-stu-id="7f255-157">There is an implicit conversion from string to <xref:System.Xml.Linq.XName>.</span></span> <span data-ttu-id="7f255-158">Um uso comum desse construtor é para especificar uma cadeia de caracteres como o parâmetro em vez de criar um novo <xref:System.Xml.Linq.XName>.</span><span class="sxs-lookup"><span data-stu-id="7f255-158">Typical use of this constructor is to specify a string as the parameter instead of creating a new <xref:System.Xml.Linq.XName>.</span></span>  
  
 <span data-ttu-id="7f255-159">Consultas não são iteradas até que o <xref:System.Xml.Linq.XStreamingElement> é serializado.</span><span class="sxs-lookup"><span data-stu-id="7f255-159">Queries are not iterated until the <xref:System.Xml.Linq.XStreamingElement> is serialized.</span></span> <span data-ttu-id="7f255-160">Isso está em contraste com o uso de consultas para o conteúdo para um <xref:System.Xml.Linq.XElement>, onde consultas são iteradas no momento da construção do novo <xref:System.Xml.Linq.XElement>.</span><span class="sxs-lookup"><span data-stu-id="7f255-160">This is in contrast to using queries for content for an <xref:System.Xml.Linq.XElement>, where queries are iterated at the time of construction of the new <xref:System.Xml.Linq.XElement>.</span></span>  
  
 <span data-ttu-id="7f255-161">Para obter detalhes sobre o conteúdo válido que pode ser passado para o construtor, consulte [conteúdo válido de XElement e XDocument objetos](http://msdn.microsoft.com/library/aee2d319-5c5f-4b99-9bb4-2f58232577ae).</span><span class="sxs-lookup"><span data-stu-id="7f255-161">For details about the valid content that can be passed to this constructor, see [Valid Content of XElement and XDocument Objects](http://msdn.microsoft.com/library/aee2d319-5c5f-4b99-9bb4-2f58232577ae).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="7f255-162">Este exemplo usa o arquivo XML a seguir, denominado Source.xml:</span><span class="sxs-lookup"><span data-stu-id="7f255-162">This example uses the following XML file, named Source.xml:</span></span>  
  
```xml  
<?xml version="1.0" encoding="utf-8" ?>   
<Root>  
  <Child Key="01">  
    <GrandChild>aaa</GrandChild>  
  </Child>  
  <Child Key="02">  
    <GrandChild>bbb</GrandChild>  
  </Child>  
  <Child Key="03">  
    <GrandChild>ccc</GrandChild>  
  </Child>  
</Root>  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XStreamingElement (System.Xml.Linq.XName name, params object[] content);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Xml.Linq.XName name, object[] content) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XStreamingElement.#ctor(System.Xml.Linq.XName,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (name As XName, ParamArray content As Object())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; XStreamingElement(System::Xml::Linq::XName ^ name, ... cli::array &lt;System::Object ^&gt; ^ content);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="name" Type="System.Xml.Linq.XName" />
        <Parameter Name="content" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="7f255-163">Um <see cref="T:System.Xml.Linq.XName" /> que contém o nome do elemento.</span><span class="sxs-lookup"><span data-stu-id="7f255-163">An <see cref="T:System.Xml.Linq.XName" /> that contains the element name.</span></span></param>
        <param name="content"><span data-ttu-id="7f255-164">O conteúdo do elemento.</span><span class="sxs-lookup"><span data-stu-id="7f255-164">The contents of the element.</span></span></param>
        <summary><span data-ttu-id="7f255-165">Inicializa uma nova instância da classe <see cref="T:System.Xml.Linq.XStreamingElement" /> com o nome e conteúdo especificados.</span><span class="sxs-lookup"><span data-stu-id="7f255-165">Initializes a new instance of the <see cref="T:System.Xml.Linq.XStreamingElement" /> class with the specified name and content.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="7f255-166">Este construtor cria um elemento de streaming com os atributos e o conteúdo especificado.</span><span class="sxs-lookup"><span data-stu-id="7f255-166">This constructor creates a streaming element with the specified content and attributes.</span></span>  
  
 <span data-ttu-id="7f255-167">Há uma conversão implícita de cadeia de caracteres para <xref:System.Xml.Linq.XName>.</span><span class="sxs-lookup"><span data-stu-id="7f255-167">There is an implicit conversion from string to <xref:System.Xml.Linq.XName>.</span></span> <span data-ttu-id="7f255-168">Um uso comum desse construtor é para especificar uma cadeia de caracteres como o parâmetro em vez de criar um novo <xref:System.Xml.Linq.XName>.</span><span class="sxs-lookup"><span data-stu-id="7f255-168">Typical use of this constructor is to specify a string as the parameter instead of creating a new <xref:System.Xml.Linq.XName>.</span></span>  
  
 <span data-ttu-id="7f255-169">Consultas não são iteradas até que o <xref:System.Xml.Linq.XStreamingElement> é serializado.</span><span class="sxs-lookup"><span data-stu-id="7f255-169">Queries are not iterated until the <xref:System.Xml.Linq.XStreamingElement> is serialized.</span></span> <span data-ttu-id="7f255-170">Isso está em contraste com o uso de consultas para o conteúdo para um <xref:System.Xml.Linq.XElement>, onde consultas são iteradas no momento da construção do novo <xref:System.Xml.Linq.XElement>.</span><span class="sxs-lookup"><span data-stu-id="7f255-170">This is in contrast to using queries for content for an <xref:System.Xml.Linq.XElement>, where queries are iterated at the time of construction of the new <xref:System.Xml.Linq.XElement>.</span></span>  
  
 <span data-ttu-id="7f255-171">Para obter detalhes sobre o conteúdo válido que pode ser passado para esta função, consulte [conteúdo válido de XElement e XDocument objetos](http://msdn.microsoft.com/library/aee2d319-5c5f-4b99-9bb4-2f58232577ae).</span><span class="sxs-lookup"><span data-stu-id="7f255-171">For details about the valid content that can be passed to this function, see [Valid Content of XElement and XDocument Objects](http://msdn.microsoft.com/library/aee2d319-5c5f-4b99-9bb4-2f58232577ae).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="7f255-172">Este exemplo usa o arquivo XML a seguir, denominado Source.xml:</span><span class="sxs-lookup"><span data-stu-id="7f255-172">This example uses the following XML file, named Source.xml:</span></span>  
  
```xml  
<?xml version="1.0" encoding="utf-8" ?>   
<Root>  
  <Child Key="01">  
    <GrandChild>aaa</GrandChild>  
  </Child>  
  <Child Key="02">  
    <GrandChild>bbb</GrandChild>  
  </Child>  
  <Child Key="03">  
    <GrandChild>ccc</GrandChild>  
  </Child>  
</Root>  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Add">
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="7f255-173">Adiciona o conteúdo especificado como filhos deste <see cref="T:System.Xml.Linq.XStreamingElement" />.</span><span class="sxs-lookup"><span data-stu-id="7f255-173">Adds the specified content as children to this <see cref="T:System.Xml.Linq.XStreamingElement" />.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public void Add (object content);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Add(object content) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XStreamingElement.Add(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Add (content As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Add(System::Object ^ content);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="content" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="content"><span data-ttu-id="7f255-174">Conteúdo a ser adicionado ao elemento de streaming.</span><span class="sxs-lookup"><span data-stu-id="7f255-174">Content to be added to the streaming element.</span></span></param>
        <summary><span data-ttu-id="7f255-175">Adiciona o conteúdo especificado como filhos deste <see cref="T:System.Xml.Linq.XStreamingElement" />.</span><span class="sxs-lookup"><span data-stu-id="7f255-175">Adds the specified content as children to this <see cref="T:System.Xml.Linq.XStreamingElement" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="7f255-176">Este construtor adiciona o conteúdo especificado e atributos para o <xref:System.Xml.Linq.XStreamingElement>.</span><span class="sxs-lookup"><span data-stu-id="7f255-176">This constructor adds the specified content and attributes to the <xref:System.Xml.Linq.XStreamingElement>.</span></span> <span data-ttu-id="7f255-177">Embora muitas vezes é possível construir o <xref:System.Xml.Linq.XStreamingElement> em uma única instrução, às vezes é mais conveniente adicionar conteúdo ao elemento streaming incrementalmente.</span><span class="sxs-lookup"><span data-stu-id="7f255-177">While it is often possible to construct the <xref:System.Xml.Linq.XStreamingElement> in a single statement, it is sometimes more convenient to add content to the streaming element incrementally.</span></span>  
  
 <span data-ttu-id="7f255-178">Consultas não são iteradas até que o <xref:System.Xml.Linq.XStreamingElement> é serializado.</span><span class="sxs-lookup"><span data-stu-id="7f255-178">Queries are not iterated until the <xref:System.Xml.Linq.XStreamingElement> is serialized.</span></span> <span data-ttu-id="7f255-179">Isso está em contraste com o uso de consultas para o conteúdo para um <xref:System.Xml.Linq.XElement>, onde consultas são iteradas no momento da construção do novo <xref:System.Xml.Linq.XElement>.</span><span class="sxs-lookup"><span data-stu-id="7f255-179">This is in contrast to using queries for content for an <xref:System.Xml.Linq.XElement>, where queries are iterated at the time of construction of the new <xref:System.Xml.Linq.XElement>.</span></span>  
  
 <span data-ttu-id="7f255-180">Para obter detalhes sobre o conteúdo válido que pode ser passado para esta função, consulte [conteúdo válido de XElement e XDocument objetos](http://msdn.microsoft.com/library/aee2d319-5c5f-4b99-9bb4-2f58232577ae).</span><span class="sxs-lookup"><span data-stu-id="7f255-180">For details about the valid content that can be passed to this function, see [Valid Content of XElement and XDocument Objects](http://msdn.microsoft.com/library/aee2d319-5c5f-4b99-9bb4-2f58232577ae).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="7f255-181">O exemplo a seguir cria um novo <xref:System.Xml.Linq.XStreamingElement>.</span><span class="sxs-lookup"><span data-stu-id="7f255-181">The following example creates a new <xref:System.Xml.Linq.XStreamingElement>.</span></span> <span data-ttu-id="7f255-182">Em seguida, ele adiciona duas consultas para o elemento de fluxo.</span><span class="sxs-lookup"><span data-stu-id="7f255-182">It then adds two queries to the streaming element.</span></span> <span data-ttu-id="7f255-183">As consultas não são iteradas até que o elemento de fluxo contínuo é serializado.</span><span class="sxs-lookup"><span data-stu-id="7f255-183">The queries are not iterated until the streaming element is serialized.</span></span>  
  
```csharp  
XElement srcTree = new XElement("Root",  
                       new XElement("Child", 1),  
                       new XElement("Child", 2),  
                       new XElement("Child", 3),  
                       new XElement("Child", 4),  
                       new XElement("Child", 5)  
                   );  
  
XStreamingElement dstTree = new XStreamingElement("NewRoot");  
  
dstTree.Add(  
    from el in srcTree.Elements()  
    where (int)el <= 1  
    select new XElement("Child", (int)el)  
);  
  
dstTree.Add(  
    from el in srcTree.Elements()  
    where (int)el >= 3  
    select new XElement("DifferentChild", (int)el)  
);  
  
Console.WriteLine(dstTree);  
```  
  
```vb  
Dim srcTree As XElement = _  
    <Root>  
        <Child>1</Child>  
        <Child>2</Child>  
        <Child>3</Child>  
        <Child>4</Child>  
        <Child>5</Child>  
    </Root>  
  
Dim dstTree As XStreamingElement = New XStreamingElement("NewRoot")  
  
dstTree.Add( _  
    From el In srcTree.Elements() _  
    Where el.Value <= 1 _  
    Select <Child><%= el.Value %></Child> _  
)  
  
dstTree.Add( _  
    From el In srcTree.Elements() _  
    Where el.Value >= 3 _  
    Select <DifferentChild><%= el.Value %></DifferentChild> _  
)  
  
Console.WriteLine(dstTree)  
```  
  
 <span data-ttu-id="7f255-184">Este exemplo gera a seguinte saída:</span><span class="sxs-lookup"><span data-stu-id="7f255-184">This example produces the following output:</span></span>  
  
```xml  
<NewRoot>  
  <Child>1</Child>  
  <DifferentChild>3</DifferentChild>  
  <DifferentChild>4</DifferentChild>  
  <DifferentChild>5</DifferentChild>  
</NewRoot>  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public void Add (params object[] content);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Add(object[] content) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XStreamingElement.Add(System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub Add (ParamArray content As Object())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Add(... cli::array &lt;System::Object ^&gt; ^ content);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="content" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="content"><span data-ttu-id="7f255-185">Conteúdo a ser adicionado ao elemento de streaming.</span><span class="sxs-lookup"><span data-stu-id="7f255-185">Content to be added to the streaming element.</span></span></param>
        <summary><span data-ttu-id="7f255-186">Adiciona o conteúdo especificado como filhos deste <see cref="T:System.Xml.Linq.XStreamingElement" />.</span><span class="sxs-lookup"><span data-stu-id="7f255-186">Adds the specified content as children to this <see cref="T:System.Xml.Linq.XStreamingElement" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="7f255-187">Este construtor adiciona o conteúdo especificado e atributos para o <xref:System.Xml.Linq.XStreamingElement>.</span><span class="sxs-lookup"><span data-stu-id="7f255-187">This constructor adds the specified content and attributes to the <xref:System.Xml.Linq.XStreamingElement>.</span></span> <span data-ttu-id="7f255-188">Embora muitas vezes é possível construir o <xref:System.Xml.Linq.XStreamingElement> em uma única instrução, às vezes é mais conveniente adicionar conteúdo ao elemento streaming incrementalmente.</span><span class="sxs-lookup"><span data-stu-id="7f255-188">While it is often possible to construct the <xref:System.Xml.Linq.XStreamingElement> in a single statement, it is sometimes more convenient to add content to the streaming element incrementally.</span></span>  
  
 <span data-ttu-id="7f255-189">Consultas não são iteradas até que o <xref:System.Xml.Linq.XStreamingElement> é serializado.</span><span class="sxs-lookup"><span data-stu-id="7f255-189">Queries are not iterated until the <xref:System.Xml.Linq.XStreamingElement> is serialized.</span></span> <span data-ttu-id="7f255-190">Isso está em contraste com o uso de consultas para o conteúdo para um <xref:System.Xml.Linq.XElement>, onde consultas são iteradas no momento da construção do novo <xref:System.Xml.Linq.XElement>.</span><span class="sxs-lookup"><span data-stu-id="7f255-190">This is in contrast to using queries for content for an <xref:System.Xml.Linq.XElement>, where queries are iterated at the time of construction of the new <xref:System.Xml.Linq.XElement>.</span></span>  
  
 <span data-ttu-id="7f255-191">Para obter detalhes sobre o conteúdo válido que pode ser passado para esta função, consulte [conteúdo válido de XElement e XDocument objetos](http://msdn.microsoft.com/library/aee2d319-5c5f-4b99-9bb4-2f58232577ae).</span><span class="sxs-lookup"><span data-stu-id="7f255-191">For details about the valid content that can be passed to this function, see [Valid Content of XElement and XDocument Objects](http://msdn.microsoft.com/library/aee2d319-5c5f-4b99-9bb4-2f58232577ae).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="7f255-192">O exemplo a seguir cria um novo <xref:System.Xml.Linq.XStreamingElement>.</span><span class="sxs-lookup"><span data-stu-id="7f255-192">The following example creates a new <xref:System.Xml.Linq.XStreamingElement>.</span></span> <span data-ttu-id="7f255-193">Em seguida, ele adiciona duas consultas para o elemento de fluxo.</span><span class="sxs-lookup"><span data-stu-id="7f255-193">It then adds two queries to the streaming element.</span></span> <span data-ttu-id="7f255-194">As consultas não são iteradas até que o elemento de fluxo contínuo é serializado.</span><span class="sxs-lookup"><span data-stu-id="7f255-194">The queries are not iterated until the streaming element is serialized.</span></span>  
  
```csharp  
XElement srcTree = new XElement("Root",  
                       new XElement("Child", 1),  
                       new XElement("Child", 2),  
                       new XElement("Child", 3),  
                       new XElement("Child", 4),  
                       new XElement("Child", 5)  
                   );  
  
XStreamingElement dstTree = new XStreamingElement("NewRoot");  
  
dstTree.Add(  
    from el in srcTree.Elements()  
    where (int)el <= 1  
    select new XElement("Child", (int)el)  
);  
  
dstTree.Add(  
    from el in srcTree.Elements()  
    where (int)el >= 3  
    select new XElement("DifferentChild", (int)el)  
);  
  
Console.WriteLine(dstTree);  
```  
  
```vb  
Dim srcTree As XElement = _  
    <Root>  
        <Child>1</Child>  
        <Child>2</Child>  
        <Child>3</Child>  
        <Child>4</Child>  
        <Child>5</Child>  
    </Root>  
  
Dim dstTree As XStreamingElement = New XStreamingElement("NewRoot")  
  
dstTree.Add( _  
    From el In srcTree.Elements() _  
    Where el.Value <= 1 _  
    Select <Child><%= el.Value %></Child> _  
)  
  
dstTree.Add( _  
    From el In srcTree.Elements() _  
    Where el.Value >= 3 _  
    Select <DifferentChild><%= el.Value %></DifferentChild> _  
)  
  
Console.WriteLine(dstTree)  
```  
  
 <span data-ttu-id="7f255-195">Este exemplo gera a seguinte saída:</span><span class="sxs-lookup"><span data-stu-id="7f255-195">This example produces the following output:</span></span>  
  
```xml  
<NewRoot>  
  <Child>1</Child>  
  <DifferentChild>3</DifferentChild>  
  <DifferentChild>4</DifferentChild>  
  <DifferentChild>5</DifferentChild>  
</NewRoot>  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public System.Xml.Linq.XName Name { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Xml.Linq.XName Name" />
      <MemberSignature Language="DocId" Value="P:System.Xml.Linq.XStreamingElement.Name" />
      <MemberSignature Language="VB.NET" Value="Public Property Name As XName" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Xml::Linq::XName ^ Name { System::Xml::Linq::XName ^ get(); void set(System::Xml::Linq::XName ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.Linq.XName</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="7f255-196">Obtém ou define o nome deste elemento de streaming.</span><span class="sxs-lookup"><span data-stu-id="7f255-196">Gets or sets the name of this streaming element.</span></span></summary>
        <value><span data-ttu-id="7f255-197">Um <see cref="T:System.Xml.Linq.XName" /> que contém o nome deste elemento de fluxo contínuo.</span><span class="sxs-lookup"><span data-stu-id="7f255-197">An <see cref="T:System.Xml.Linq.XName" /> that contains the name of this streaming element.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="7f255-198">Este exemplo cria um novo elemento de streaming e imprime o nome do elemento.</span><span class="sxs-lookup"><span data-stu-id="7f255-198">This example creates a new streaming element, and then prints the name of the element.</span></span>  
  
```csharp  
XElement srcTree = new XElement("Root",  
                       new XElement("Child", 1),  
                       new XElement("Child", 2),  
                       new XElement("Child", 3),  
                       new XElement("Child", 4),  
                       new XElement("Child", 5)  
                   );  
  
XStreamingElement dstTree = new XStreamingElement("NewRoot",  
                        from el in srcTree.Elements()  
                        where (int)el >= 3  
                        select new XElement("DifferentChild", (int)el)  
                    );  
  
Console.WriteLine(dstTree.Name);  
```  
  
```vb  
Dim srcTree As XElement = _  
        <Root>  
            <Child>1</Child>  
            <Child>2</Child>  
            <Child>3</Child>  
            <Child>4</Child>  
            <Child>5</Child>  
        </Root>  
  
Dim dstTree As XStreamingElement = New XStreamingElement("NewRoot", _  
                From el In srcTree.Elements _  
                Where el.Value >= 3 _  
                Select <DifferentChild><%= el.Value %></DifferentChild> _  
            )  
  
Console.WriteLine(dstTree.Name)  
```  
  
 <span data-ttu-id="7f255-199">Este exemplo gera a seguinte saída:</span><span class="sxs-lookup"><span data-stu-id="7f255-199">This example produces the following output:</span></span>  
  
```  
NewRoot  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Save">
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="7f255-200">Serialize este elemento de streaming.</span><span class="sxs-lookup"><span data-stu-id="7f255-200">Serialize this streaming element.</span></span> <span data-ttu-id="7f255-201">A saída pode ser salva em um arquivo, um <see cref="T:System.Xml.XmlTextWriter" />, um <see cref="T:System.IO.TextWriter" /> ou um <see cref="T:System.Xml.XmlWriter" />.</span><span class="sxs-lookup"><span data-stu-id="7f255-201">The output can be saved to a file, an <see cref="T:System.Xml.XmlTextWriter" />, a <see cref="T:System.IO.TextWriter" />, or an <see cref="T:System.Xml.XmlWriter" />.</span></span> <span data-ttu-id="7f255-202">Opcionalmente, a formatação (recuo) pode ser desabilitada.</span><span class="sxs-lookup"><span data-stu-id="7f255-202">Optionally, formatting (indenting) can be disabled.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Save">
      <MemberSignature Language="C#" Value="public void Save (System.IO.Stream stream);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Save(class System.IO.Stream stream) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XStreamingElement.Save(System.IO.Stream)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Save(System::IO::Stream ^ stream);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
      </Parameters>
      <Docs>
        <param name="stream"><span data-ttu-id="7f255-203">O fluxo para o qual este <see cref="T:System.Xml.Linq.XDocument" /> será gerado.</span><span class="sxs-lookup"><span data-stu-id="7f255-203">The stream to output this <see cref="T:System.Xml.Linq.XDocument" /> to.</span></span></param>
        <summary><span data-ttu-id="7f255-204">Gera este <see cref="T:System.Xml.Linq.XStreamingElement" /> para o <see cref="T:System.IO.Stream" /> especificado.</span><span class="sxs-lookup"><span data-stu-id="7f255-204">Outputs this <see cref="T:System.Xml.Linq.XStreamingElement" /> to the specified <see cref="T:System.IO.Stream" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="7f255-205">O XML serializado será recuado.</span><span class="sxs-lookup"><span data-stu-id="7f255-205">The serialized XML will be indented.</span></span> <span data-ttu-id="7f255-206">Todos os espaço em branco insignificante será removido e o espaço em branco adicional será adicionado para que o XML seja recuado corretamente.</span><span class="sxs-lookup"><span data-stu-id="7f255-206">All insignificant white space will be removed, and additional white space will be added so that the XML will be properly indented.</span></span> <span data-ttu-id="7f255-207">O comportamento desse método é que espaço em branco insignificante não será preservado.</span><span class="sxs-lookup"><span data-stu-id="7f255-207">The behavior of this method is that insignificant white space will not be preserved.</span></span>  
  
 <span data-ttu-id="7f255-208">Se você quiser controlar o espaço em branco, use a sobrecarga do <xref:System.Xml.Linq.XStreamingElement.Save%2A> que usa <xref:System.Xml.Linq.SaveOptions> como um parâmetro.</span><span class="sxs-lookup"><span data-stu-id="7f255-208">If you want to control white space, use the overload of <xref:System.Xml.Linq.XStreamingElement.Save%2A> that takes <xref:System.Xml.Linq.SaveOptions> as a parameter.</span></span> <span data-ttu-id="7f255-209">Use o <xref:System.Xml.Linq.SaveOptions.DisableFormatting> opção para salvar ou XML.</span><span class="sxs-lookup"><span data-stu-id="7f255-209">Use the <xref:System.Xml.Linq.SaveOptions.DisableFormatting> option to save unindented XML.</span></span> <span data-ttu-id="7f255-210">Isso fará com que o gravador gravar todos os espaços em branco exatamente conforme representado na árvore XML.</span><span class="sxs-lookup"><span data-stu-id="7f255-210">This will cause the writer to write all white spaces exactly as represented in the XML tree.</span></span>  
  
 <span data-ttu-id="7f255-211">Use <xref:System.Xml.Linq.SaveOptions.OmitDuplicateNamespaces> opção se você quiser remover declarações de namespace duplicados.</span><span class="sxs-lookup"><span data-stu-id="7f255-211">Use <xref:System.Xml.Linq.SaveOptions.OmitDuplicateNamespaces> option if you want to remove duplicate namespace declarations.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Save">
      <MemberSignature Language="C#" Value="public void Save (System.IO.TextWriter textWriter);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Save(class System.IO.TextWriter textWriter) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XStreamingElement.Save(System.IO.TextWriter)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Save(System::IO::TextWriter ^ textWriter);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="textWriter" Type="System.IO.TextWriter" />
      </Parameters>
      <Docs>
        <param name="textWriter"><span data-ttu-id="7f255-212">Um <see cref="T:System.IO.TextWriter" /> no qual o <see cref="T:System.Xml.Linq.XStreamingElement" /> será gravado.</span><span class="sxs-lookup"><span data-stu-id="7f255-212">A <see cref="T:System.IO.TextWriter" /> that the <see cref="T:System.Xml.Linq.XStreamingElement" /> will be written to.</span></span></param>
        <summary><span data-ttu-id="7f255-213">Serialize este elemento de streaming para um <see cref="T:System.IO.TextWriter" />.</span><span class="sxs-lookup"><span data-stu-id="7f255-213">Serialize this streaming element to a <see cref="T:System.IO.TextWriter" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="7f255-214">O XML serializado será recuado.</span><span class="sxs-lookup"><span data-stu-id="7f255-214">The serialized XML will be indented.</span></span> <span data-ttu-id="7f255-215">Todos os espaço em branco insignificante será removido e o espaço em branco adicional será adicionado para que o XML seja recuado corretamente.</span><span class="sxs-lookup"><span data-stu-id="7f255-215">All insignificant white space will be removed, and additional white space will be added so that the XML will be properly indented.</span></span> <span data-ttu-id="7f255-216">O comportamento desse método é que espaço em branco insignificante não serão preservados nós na árvore XML.</span><span class="sxs-lookup"><span data-stu-id="7f255-216">The behavior of this method is that insignificant white space nodes in the XML tree will not be preserved.</span></span>  
  
 <span data-ttu-id="7f255-217">Se você quiser controlar o espaço em branco, use uma das sobrecargas do <xref:System.Xml.Linq.XStreamingElement.Save%2A> que usam <xref:System.Xml.Linq.SaveOptions> como um parâmetro.</span><span class="sxs-lookup"><span data-stu-id="7f255-217">If you want to control white space, use one of the overloads of <xref:System.Xml.Linq.XStreamingElement.Save%2A> that take <xref:System.Xml.Linq.SaveOptions> as a parameter.</span></span> <span data-ttu-id="7f255-218">Para obter mais informações, consulte [preservar espaço em branco durante a análise de XML ou carregamento](http://msdn.microsoft.com/library/093a7169-a04e-4638-b08c-d1cb98aa650d) e [preservar espaço em branco ao serializar](http://msdn.microsoft.com/library/fb146217-0a49-4efc-ac84-7265b91d3939).</span><span class="sxs-lookup"><span data-stu-id="7f255-218">For more information, see [Preserving White Space while Loading or Parsing XML](http://msdn.microsoft.com/library/093a7169-a04e-4638-b08c-d1cb98aa650d) and [Preserving White Space While Serializing](http://msdn.microsoft.com/library/fb146217-0a49-4efc-ac84-7265b91d3939).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="7f255-219">O exemplo a seguir cria uma árvore XML de origem, em seguida, cria um <xref:System.Xml.Linq.XStreamingElement> usando uma consulta em árvore XML de origem.</span><span class="sxs-lookup"><span data-stu-id="7f255-219">The following example creates a source XML tree, then instantiates an <xref:System.Xml.Linq.XStreamingElement> using a query on the source XML tree.</span></span> <span data-ttu-id="7f255-220">Ele grava o elemento de fluxo para um <xref:System.IO.StringWriter>.</span><span class="sxs-lookup"><span data-stu-id="7f255-220">It then writes the streaming element to a <xref:System.IO.StringWriter>.</span></span>  
  
```csharp  
XElement srcTree = new XElement("Root",  
                       new XElement("Child", 1),  
                       new XElement("Child", 2),  
                       new XElement("Child", 3),  
                       new XElement("Child", 4),  
                       new XElement("Child", 5)  
                   );  
  
XStreamingElement dstTree = new XStreamingElement("NewRoot",  
                        from el in srcTree.Elements()  
                        where (int)el >= 3  
                        select new XElement("DifferentChild", (int)el)  
                    );  
  
StringBuilder sb = new StringBuilder();  
dstTree.Save(new StringWriter(sb));  
Console.WriteLine(sb.ToString());  
```  
  
```vb  
Dim srcTree As XElement = _  
    <Root>  
        <Child>1</Child>  
        <Child>2</Child>  
        <Child>3</Child>  
        <Child>4</Child>  
        <Child>5</Child>  
    </Root>  
  
Dim dstTree As XStreamingElement = New XStreamingElement("NewRoot", _  
                        From el In srcTree.Elements() _  
                        Where el.Value >= 3 _  
                        Select <DifferentChild><%= el.Value %></DifferentChild> _  
                    )  
  
Dim sb As StringBuilder = New StringBuilder()  
dstTree.Save(New StringWriter(sb))  
Console.WriteLine(sb.ToString())  
```  
  
 <span data-ttu-id="7f255-221">Este exemplo gera a seguinte saída:</span><span class="sxs-lookup"><span data-stu-id="7f255-221">This example produces the following output:</span></span>  
  
```xml  
<?xml version="1.0" encoding="utf-16"?>  
<NewRoot>  
  <DifferentChild>3</DifferentChild>  
  <DifferentChild>4</DifferentChild>  
  <DifferentChild>5</DifferentChild>  
</NewRoot>  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Save">
      <MemberSignature Language="C#" Value="public void Save (string fileName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Save(string fileName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XStreamingElement.Save(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Save (fileName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Save(System::String ^ fileName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="fileName"><span data-ttu-id="7f255-222">Um <see cref="T:System.String" /> que contém o nome do arquivo.</span><span class="sxs-lookup"><span data-stu-id="7f255-222">A <see cref="T:System.String" /> that contains the name of the file.</span></span></param>
        <summary><span data-ttu-id="7f255-223">Serialize este elemento de streaming para um arquivo.</span><span class="sxs-lookup"><span data-stu-id="7f255-223">Serialize this streaming element to a file.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="7f255-224">O XML serializado será recuado.</span><span class="sxs-lookup"><span data-stu-id="7f255-224">The serialized XML will be indented.</span></span> <span data-ttu-id="7f255-225">Todos os espaço em branco insignificante será removido e o espaço em branco adicional será adicionado para que o XML seja recuado corretamente.</span><span class="sxs-lookup"><span data-stu-id="7f255-225">All insignificant white space will be removed, and additional white space will be added so that the XML will be properly indented.</span></span> <span data-ttu-id="7f255-226">O comportamento desse método é que espaço em branco insignificante não serão preservados nós na árvore XML.</span><span class="sxs-lookup"><span data-stu-id="7f255-226">The behavior of this method is that insignificant white space nodes in the XML tree will not be preserved.</span></span>  
  
 <span data-ttu-id="7f255-227">Se você quiser controlar o espaço em branco, use uma das sobrecargas do <xref:System.Xml.Linq.XStreamingElement.Save%2A> que usam <xref:System.Xml.Linq.SaveOptions> como um parâmetro.</span><span class="sxs-lookup"><span data-stu-id="7f255-227">If you want to control white space, use one of the overloads of <xref:System.Xml.Linq.XStreamingElement.Save%2A> that take <xref:System.Xml.Linq.SaveOptions> as a parameter.</span></span> <span data-ttu-id="7f255-228">Para obter mais informações, consulte [preservar espaço em branco durante a análise de XML ou carregamento](http://msdn.microsoft.com/library/093a7169-a04e-4638-b08c-d1cb98aa650d) e [preservar espaço em branco ao serializar](http://msdn.microsoft.com/library/fb146217-0a49-4efc-ac84-7265b91d3939).</span><span class="sxs-lookup"><span data-stu-id="7f255-228">For more information, see [Preserving White Space while Loading or Parsing XML](http://msdn.microsoft.com/library/093a7169-a04e-4638-b08c-d1cb98aa650d) and [Preserving White Space While Serializing](http://msdn.microsoft.com/library/fb146217-0a49-4efc-ac84-7265b91d3939).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="7f255-229">O exemplo a seguir cria uma árvore XML de streaming.</span><span class="sxs-lookup"><span data-stu-id="7f255-229">The following example creates a streaming XML tree.</span></span> <span data-ttu-id="7f255-230">Ele, em seguida, serializa a árvore XML streaming em um arquivo.</span><span class="sxs-lookup"><span data-stu-id="7f255-230">It then serializes the streaming XML tree to a file.</span></span>  
  
```csharp  
XElement srcTree = new XElement("Root",  
                       new XElement("Child", 1),  
                       new XElement("Child", 2),  
                       new XElement("Child", 3),  
                       new XElement("Child", 4),  
                       new XElement("Child", 5)  
                   );  
  
XStreamingElement dstTree = new XStreamingElement("NewRoot",  
                        from el in srcTree.Elements()  
                        where (int)el >= 3  
                        select new XElement("DifferentChild", (int)el)  
                    );  
  
dstTree.Save("Test.xml");  
Console.WriteLine(File.ReadAllText("Test.xml"));  
```  
  
```vb  
Dim srcTree As XElement = _  
    <Root>  
        <Child>1</Child>  
        <Child>2</Child>  
        <Child>3</Child>  
        <Child>4</Child>  
        <Child>5</Child>  
    </Root>  
  
Dim dstTree As XStreamingElement = New XStreamingElement("NewRoot", _  
                        From el In srcTree.Elements() _  
                        Where el.Value >= 3 _  
                        Select <DifferentChild><%= el.Value %></DifferentChild> _  
                    )  
  
dstTree.Save("Test.xml")  
Console.WriteLine(File.ReadAllText("Test.xml"))  
```  
  
 <span data-ttu-id="7f255-231">Este exemplo gera a seguinte saída:</span><span class="sxs-lookup"><span data-stu-id="7f255-231">This example produces the following output:</span></span>  
  
```xml  
<?xml version="1.0" encoding="utf-8"?>  
<NewRoot>  
  <DifferentChild>3</DifferentChild>  
  <DifferentChild>4</DifferentChild>  
  <DifferentChild>5</DifferentChild>  
</NewRoot>  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Save">
      <MemberSignature Language="C#" Value="public void Save (System.Xml.XmlWriter writer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Save(class System.Xml.XmlWriter writer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XStreamingElement.Save(System.Xml.XmlWriter)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Save (writer As XmlWriter)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Save(System::Xml::XmlWriter ^ writer);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Xml.XmlWriter" />
      </Parameters>
      <Docs>
        <param name="writer"><span data-ttu-id="7f255-232">Um <see cref="T:System.Xml.XmlWriter" /> no qual o <see cref="T:System.Xml.Linq.XElement" /> será gravado.</span><span class="sxs-lookup"><span data-stu-id="7f255-232">A <see cref="T:System.Xml.XmlWriter" /> that the <see cref="T:System.Xml.Linq.XElement" /> will be written to.</span></span></param>
        <summary><span data-ttu-id="7f255-233">Serialize este elemento de streaming para um <see cref="T:System.Xml.XmlWriter" />.</span><span class="sxs-lookup"><span data-stu-id="7f255-233">Serialize this streaming element to an <see cref="T:System.Xml.XmlWriter" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="7f255-234">O exemplo a seguir cria um <xref:System.Xml.Linq.XStreamingElement> e grava-o para um <xref:System.Xml.XmlWriter>.</span><span class="sxs-lookup"><span data-stu-id="7f255-234">The following example creates an <xref:System.Xml.Linq.XStreamingElement> and writes it to an <xref:System.Xml.XmlWriter>.</span></span>  
  
```csharp  
XElement srcTree = new XElement("Root",  
                       new XElement("Child", 1),  
                       new XElement("Child", 2),  
                       new XElement("Child", 3),  
                       new XElement("Child", 4),  
                       new XElement("Child", 5)  
                   );  
  
StringBuilder sb = new StringBuilder();  
XmlWriterSettings xws = new XmlWriterSettings();  
xws.OmitXmlDeclaration = true;  
using (XmlWriter xw = XmlWriter.Create(sb, xws))  
{  
    XStreamingElement dstTree = new XStreamingElement("NewRoot",  
                            from el in srcTree.Elements()  
                            where (int)el == 5  
                            select new XElement("DifferentChild", (int)el)  
                        );  
  
    dstTree.Save(xw);  
}  
Console.WriteLine(sb.ToString());  
```  
  
```vb  
Dim srcTree As XElement = _  
    <Root>  
        <Child>1</Child>  
        <Child>2</Child>  
        <Child>3</Child>  
        <Child>4</Child>  
        <Child>5</Child>  
    </Root>  
  
Dim sb As StringBuilder = New StringBuilder()  
Dim xws As XmlWriterSettings = New XmlWriterSettings()  
xws.OmitXmlDeclaration = True  
Using xw As XmlWriter = XmlWriter.Create(sb, xws)  
    Dim dstTree As XStreamingElement = New XStreamingElement("NewRoot", _  
                            From el In srcTree.Elements() _  
                            Where el.Value = 5 _  
                            Select <DifferentChild><%= el.Value %></DifferentChild> _  
                        )  
    dstTree.Save(xw)  
End Using  
Console.WriteLine(sb.ToString())  
```  
  
 <span data-ttu-id="7f255-235">Este exemplo gera a seguinte saída:</span><span class="sxs-lookup"><span data-stu-id="7f255-235">This example produces the following output:</span></span>  
  
```xml  
<NewRoot><DifferentChild>5</DifferentChild></NewRoot>  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Save">
      <MemberSignature Language="C#" Value="public void Save (System.IO.Stream stream, System.Xml.Linq.SaveOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Save(class System.IO.Stream stream, valuetype System.Xml.Linq.SaveOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XStreamingElement.Save(System.IO.Stream,System.Xml.Linq.SaveOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Save(System::IO::Stream ^ stream, System::Xml::Linq::SaveOptions options);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
        <Parameter Name="options" Type="System.Xml.Linq.SaveOptions" />
      </Parameters>
      <Docs>
        <param name="stream"><span data-ttu-id="7f255-236">O fluxo para o qual este <see cref="T:System.Xml.Linq.XDocument" /> será gerado.</span><span class="sxs-lookup"><span data-stu-id="7f255-236">The stream to output this <see cref="T:System.Xml.Linq.XDocument" /> to.</span></span></param>
        <param name="options"><span data-ttu-id="7f255-237">Um objeto <see cref="T:System.Xml.Linq.SaveOptions" /> que especifica o comportamento de formatação.</span><span class="sxs-lookup"><span data-stu-id="7f255-237">A <see cref="T:System.Xml.Linq.SaveOptions" /> object that specifies formatting behavior.</span></span></param>
        <summary><span data-ttu-id="7f255-238">Gera esse <see cref="T:System.Xml.Linq.XStreamingElement" /> para o <see cref="T:System.IO.Stream" /> especificado, com a opção de especificar o comportamento de formatação.</span><span class="sxs-lookup"><span data-stu-id="7f255-238">Outputs this <see cref="T:System.Xml.Linq.XStreamingElement" /> to the specified <see cref="T:System.IO.Stream" />, optionally specifying formatting behavior.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="7f255-239">Por padrão o `options` são definidos como <xref:System.Xml.Linq.SaveOptions.None>.</span><span class="sxs-lookup"><span data-stu-id="7f255-239">By default the `options` are set to <xref:System.Xml.Linq.SaveOptions.None>.</span></span> <span data-ttu-id="7f255-240">Esta opção removerá todos os espaços em branco insignificante externos e adicionar espaço em branco insignificante apropriado para que o XML é recuado corretamente.</span><span class="sxs-lookup"><span data-stu-id="7f255-240">This option will remove all extraneous insignificant white space, and add appropriate insignificant white space so that the XML is properly indented.</span></span>  
  
 <span data-ttu-id="7f255-241">Se você deseja salvar ou XML, especifique o <xref:System.Xml.Linq.SaveOptions.DisableFormatting> sinalizador para `options`.</span><span class="sxs-lookup"><span data-stu-id="7f255-241">If you want to save unindented XML, specify the <xref:System.Xml.Linq.SaveOptions.DisableFormatting> flag for `options`.</span></span> <span data-ttu-id="7f255-242">Isso fará com que o gravador gravar todos os espaços em branco exatamente conforme representado na árvore XML.</span><span class="sxs-lookup"><span data-stu-id="7f255-242">This will cause the writer to write all white spaces exactly as represented in the XML tree.</span></span>  
  
 <span data-ttu-id="7f255-243">Use <xref:System.Xml.Linq.SaveOptions.OmitDuplicateNamespaces> opção se você quiser remover declarações de namespace duplicados.</span><span class="sxs-lookup"><span data-stu-id="7f255-243">Use <xref:System.Xml.Linq.SaveOptions.OmitDuplicateNamespaces> option if you want to remove duplicate namespace declarations.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Save">
      <MemberSignature Language="C#" Value="public void Save (System.IO.TextWriter textWriter, System.Xml.Linq.SaveOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Save(class System.IO.TextWriter textWriter, valuetype System.Xml.Linq.SaveOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XStreamingElement.Save(System.IO.TextWriter,System.Xml.Linq.SaveOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Save(System::IO::TextWriter ^ textWriter, System::Xml::Linq::SaveOptions options);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="textWriter" Type="System.IO.TextWriter" />
        <Parameter Name="options" Type="System.Xml.Linq.SaveOptions" />
      </Parameters>
      <Docs>
        <param name="textWriter"><span data-ttu-id="7f255-244">O <see cref="T:System.IO.TextWriter" /> para a saída do XML.</span><span class="sxs-lookup"><span data-stu-id="7f255-244">The <see cref="T:System.IO.TextWriter" /> to output the XML to.</span></span></param>
        <param name="options"><span data-ttu-id="7f255-245">Um <see cref="T:System.Xml.Linq.SaveOptions" /> que especifica o comportamento de formatação.</span><span class="sxs-lookup"><span data-stu-id="7f255-245">A <see cref="T:System.Xml.Linq.SaveOptions" /> that specifies formatting behavior.</span></span></param>
        <summary><span data-ttu-id="7f255-246">Serializar este elemento de streaming para um <see cref="T:System.IO.TextWriter" />, se desejar desabilitar a formatação.</span><span class="sxs-lookup"><span data-stu-id="7f255-246">Serialize this streaming element to a <see cref="T:System.IO.TextWriter" />, optionally disabling formatting.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="7f255-247">Se você deseja salvar ou XML, especifique o <xref:System.Xml.Linq.SaveOptions.DisableFormatting> sinalizador para `options`.</span><span class="sxs-lookup"><span data-stu-id="7f255-247">If you want to save unindented XML, specify the <xref:System.Xml.Linq.SaveOptions.DisableFormatting> flag for `options`.</span></span> <span data-ttu-id="7f255-248">Isso fará com que o gravador gravar todos os espaços em branco exatamente conforme representado na árvore XML.</span><span class="sxs-lookup"><span data-stu-id="7f255-248">This will cause the writer to write all white space exactly as represented in the XML tree.</span></span>  
  
 <span data-ttu-id="7f255-249">Se você deseja salvar o XML recuado, não especifique o <xref:System.Xml.Linq.SaveOptions.DisableFormatting> sinalizador para `options`.</span><span class="sxs-lookup"><span data-stu-id="7f255-249">If you want to save indented XML, do not specify the <xref:System.Xml.Linq.SaveOptions.DisableFormatting> flag for `options`.</span></span> <span data-ttu-id="7f255-250">Isso removerá todos os espaços em branco insignificante externos e adicionar espaço em branco insignificante apropriado para que o XML é recuado corretamente.</span><span class="sxs-lookup"><span data-stu-id="7f255-250">This will remove all extraneous insignificant white space, and add appropriate insignificant white space so that the XML is properly indented.</span></span> <span data-ttu-id="7f255-251">Este é o comportamento padrão e o comportamento das sobrecargas do <xref:System.Xml.Linq.XElement.Save%2A> métodos que não têm `options` como um parâmetro.</span><span class="sxs-lookup"><span data-stu-id="7f255-251">This is the default behavior, and the behavior of the overloads of the <xref:System.Xml.Linq.XElement.Save%2A> methods that do not take `options` as a parameter.</span></span>  
  
 <span data-ttu-id="7f255-252">Para obter mais informações, consulte [preservar espaço em branco durante a análise de XML ou carregamento](http://msdn.microsoft.com/library/093a7169-a04e-4638-b08c-d1cb98aa650d) e [preservar espaço em branco ao serializar](http://msdn.microsoft.com/library/fb146217-0a49-4efc-ac84-7265b91d3939).</span><span class="sxs-lookup"><span data-stu-id="7f255-252">For more information, see [Preserving White Space while Loading or Parsing XML](http://msdn.microsoft.com/library/093a7169-a04e-4638-b08c-d1cb98aa650d) and [Preserving White Space While Serializing](http://msdn.microsoft.com/library/fb146217-0a49-4efc-ac84-7265b91d3939).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="7f255-253">O exemplo a seguir mostra dois usos desse método.</span><span class="sxs-lookup"><span data-stu-id="7f255-253">The following example shows two uses of this method.</span></span> <span data-ttu-id="7f255-254">O primeiro uso preserva espaço em branco.</span><span class="sxs-lookup"><span data-stu-id="7f255-254">The first use preserves white space.</span></span> <span data-ttu-id="7f255-255">Segunda serializa o <xref:System.Xml.Linq.XStreamingElement> com formatação.</span><span class="sxs-lookup"><span data-stu-id="7f255-255">The second one serializes the <xref:System.Xml.Linq.XStreamingElement> with formatting.</span></span>  
  
```csharp  
XElement srcTree = new XElement("Root",  
                       new XElement("Child", 1),  
                       new XElement("Child", 2),  
                       new XElement("Child", 3),  
                       new XElement("Child", 4),  
                       new XElement("Child", 5)  
                   );  
  
XStreamingElement dstTree = new XStreamingElement("NewRoot",  
                        from el in srcTree.Elements()  
                        where (int)el == 3  
                        select new XElement("DifferentChild", (int)el)  
                    );  
  
StringBuilder sb = new StringBuilder();  
dstTree.Save(new StringWriter(sb), SaveOptions.DisableFormatting);  
Console.WriteLine(sb.ToString());  
Console.WriteLine("------");  
sb = new StringBuilder();  
dstTree.Save(new StringWriter(sb), SaveOptions.None);  
Console.WriteLine(sb.ToString());  
```  
  
```vb  
Dim srcTree As XElement = _  
    <Root>  
        <Child>1</Child>  
        <Child>2</Child>  
        <Child>3</Child>  
        <Child>4</Child>  
        <Child>5</Child>  
    </Root>  
  
Dim dstTree As XStreamingElement = New XStreamingElement("NewRoot", _  
                        From el In srcTree.Elements() _  
                        Where el.Value = 3 _  
                        Select <DifferentChild><%= el.Value %></DifferentChild> _  
                    )  
  
Dim sb As StringBuilder = New StringBuilder()  
dstTree.Save(New StringWriter(sb), SaveOptions.DisableFormatting)  
Console.WriteLine(sb.ToString())  
Console.WriteLine("------")  
sb = New StringBuilder()  
dstTree.Save(New StringWriter(sb), SaveOptions.None)  
Console.WriteLine(sb.ToString())  
```  
  
 <span data-ttu-id="7f255-256">Este exemplo gera a seguinte saída:</span><span class="sxs-lookup"><span data-stu-id="7f255-256">This example produces the following output:</span></span>  
  
```xml  
<?xml version="1.0" encoding="utf-16"?><NewRoot><DifferentChild>3</DifferentChild></NewRoot>  
------  
<?xml version="1.0" encoding="utf-16"?>  
<NewRoot>  
  <DifferentChild>3</DifferentChild>  
</NewRoot>  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Save">
      <MemberSignature Language="C#" Value="public void Save (string fileName, System.Xml.Linq.SaveOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Save(string fileName, valuetype System.Xml.Linq.SaveOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XStreamingElement.Save(System.String,System.Xml.Linq.SaveOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Save (fileName As String, options As SaveOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Save(System::String ^ fileName, System::Xml::Linq::SaveOptions options);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
        <Parameter Name="options" Type="System.Xml.Linq.SaveOptions" />
      </Parameters>
      <Docs>
        <param name="fileName"><span data-ttu-id="7f255-257">Um <see cref="T:System.String" /> que contém o nome do arquivo.</span><span class="sxs-lookup"><span data-stu-id="7f255-257">A <see cref="T:System.String" /> that contains the name of the file.</span></span></param>
        <param name="options"><span data-ttu-id="7f255-258">Um objeto <see cref="T:System.Xml.Linq.SaveOptions" /> que especifica o comportamento de formatação.</span><span class="sxs-lookup"><span data-stu-id="7f255-258">A <see cref="T:System.Xml.Linq.SaveOptions" /> object that specifies formatting behavior.</span></span></param>
        <summary><span data-ttu-id="7f255-259">Serialize este elemento de streaming em um arquivo, se desejar desabilitar a formatação.</span><span class="sxs-lookup"><span data-stu-id="7f255-259">Serialize this streaming element to a file, optionally disabling formatting.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="7f255-260">Se você deseja salvar ou XML, especifique o <xref:System.Xml.Linq.SaveOptions.DisableFormatting> sinalizador para `options`.</span><span class="sxs-lookup"><span data-stu-id="7f255-260">If you want to save unindented XML, specify the <xref:System.Xml.Linq.SaveOptions.DisableFormatting> flag for `options`.</span></span> <span data-ttu-id="7f255-261">Isso fará com que o gravador gravar todos os espaços em branco exatamente conforme representado na árvore XML.</span><span class="sxs-lookup"><span data-stu-id="7f255-261">This will cause the writer to write all white space exactly as represented in the XML tree.</span></span>  
  
 <span data-ttu-id="7f255-262">Se você deseja salvar o XML recuado, não especifique o <xref:System.Xml.Linq.SaveOptions.DisableFormatting> sinalizador para `options`.</span><span class="sxs-lookup"><span data-stu-id="7f255-262">If you want to save indented XML, do not specify the <xref:System.Xml.Linq.SaveOptions.DisableFormatting> flag for `options`.</span></span> <span data-ttu-id="7f255-263">Isso removerá todos os espaços em branco insignificante externos e adicionar espaço em branco insignificante apropriado para que o XML é recuado corretamente.</span><span class="sxs-lookup"><span data-stu-id="7f255-263">This will remove all extraneous insignificant white space, and add appropriate insignificant white space so that the XML is properly indented.</span></span> <span data-ttu-id="7f255-264">Este é o comportamento padrão e o comportamento das sobrecargas do <xref:System.Xml.Linq.XElement.Save%2A> métodos que não têm `options` como um parâmetro.</span><span class="sxs-lookup"><span data-stu-id="7f255-264">This is the default behavior, and the behavior of the overloads of the <xref:System.Xml.Linq.XElement.Save%2A> methods that do not take `options` as a parameter.</span></span>  
  
 <span data-ttu-id="7f255-265">Para obter mais informações, consulte [preservar espaço em branco durante a análise de XML ou carregamento](http://msdn.microsoft.com/library/093a7169-a04e-4638-b08c-d1cb98aa650d) e [preservar espaço em branco ao serializar](http://msdn.microsoft.com/library/fb146217-0a49-4efc-ac84-7265b91d3939).</span><span class="sxs-lookup"><span data-stu-id="7f255-265">For more information, see [Preserving White Space while Loading or Parsing XML](http://msdn.microsoft.com/library/093a7169-a04e-4638-b08c-d1cb98aa650d) and [Preserving White Space While Serializing](http://msdn.microsoft.com/library/fb146217-0a49-4efc-ac84-7265b91d3939).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="7f255-266">O exemplo a seguir mostra dois usos desse método.</span><span class="sxs-lookup"><span data-stu-id="7f255-266">The following example shows two uses of this method.</span></span> <span data-ttu-id="7f255-267">O primeiro uso preserva espaço em branco.</span><span class="sxs-lookup"><span data-stu-id="7f255-267">The first use preserves white space.</span></span> <span data-ttu-id="7f255-268">Segunda serializa o <xref:System.Xml.Linq.XStreamingElement> com formatação.</span><span class="sxs-lookup"><span data-stu-id="7f255-268">The second one serializes the <xref:System.Xml.Linq.XStreamingElement> with formatting.</span></span>  
  
```csharp  
XElement srcTree = new XElement("Root",  
                       new XElement("Child", 1),  
                       new XElement("Child", 2),  
                       new XElement("Child", 3),  
                       new XElement("Child", 4),  
                       new XElement("Child", 5)  
                   );  
  
XStreamingElement dstTree = new XStreamingElement("NewRoot",  
                        from el in srcTree.Elements()  
                        where (int)el == 3  
                        select new XElement("DifferentChild", (int)el)  
                    );  
  
dstTree.Save("Test1.xml", SaveOptions.DisableFormatting);  
dstTree.Save("Test2.xml", SaveOptions.None);  
Console.WriteLine(File.ReadAllText("Test1.xml"));  
Console.WriteLine("------");  
Console.WriteLine(File.ReadAllText("Test2.xml"));  
```  
  
```vb  
Dim srcTree As XElement = _  
    <Root>  
        <Child>1</Child>  
        <Child>2</Child>  
        <Child>3</Child>  
        <Child>4</Child>  
        <Child>5</Child>  
    </Root>  
  
Dim dstTree As XStreamingElement = New XStreamingElement("NewRoot", _  
                        From el In srcTree.Elements() _  
                        Where el.Value = 3 _  
                        Select <DifferentChild><%= el.Value %></DifferentChild> _  
                    )  
  
dstTree.Save("Test1.xml", SaveOptions.DisableFormatting)  
dstTree.Save("Test2.xml", SaveOptions.None)  
Console.WriteLine(File.ReadAllText("Test1.xml"))  
Console.WriteLine("------")  
Console.WriteLine(File.ReadAllText("Test2.xml"))  
```  
  
 <span data-ttu-id="7f255-269">Este exemplo gera a seguinte saída:</span><span class="sxs-lookup"><span data-stu-id="7f255-269">This example produces the following output:</span></span>  
  
```  
<?xml version="1.0" encoding="utf-8"?><NewRoot><DifferentChild>3</DifferentChild></NewRoot>  
------  
<?xml version="1.0" encoding="utf-8"?>  
<NewRoot>  
  <DifferentChild>3</DifferentChild>  
</NewRoot>  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="ToString">
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="7f255-270">Retorna o XML para este elemento de streaming, se desejar desabilitar a formatação.</span><span class="sxs-lookup"><span data-stu-id="7f255-270">Returns the XML for this streaming element, optionally disabling formatting.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="7f255-271">Observe que durante a depuração de um programa que usa <xref:System.Xml.Linq.XStreamingElement>, exibir o valor de um objeto faz com que seu <xref:System.Xml.Linq.XStreamingElement.ToString%2A> método a ser chamado.</span><span class="sxs-lookup"><span data-stu-id="7f255-271">Note that when debugging a program that uses <xref:System.Xml.Linq.XStreamingElement>, displaying the value of an object causes its <xref:System.Xml.Linq.XStreamingElement.ToString%2A> method to be called.</span></span> <span data-ttu-id="7f255-272">Isso faz com que o XML a ser serializado.</span><span class="sxs-lookup"><span data-stu-id="7f255-272">This causes the XML to be serialized.</span></span> <span data-ttu-id="7f255-273">Se a semântica da consulta elemento streaming, de modo que o elemento de streaming só pode ser transmitido uma vez, isso pode causar comportamento indesejado na sua experiência de depuração.</span><span class="sxs-lookup"><span data-stu-id="7f255-273">If the semantics of your streaming element query are such that the streaming element can only be streamed once, this may cause undesirable behavior in your debugging experience.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XStreamingElement.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="7f255-274">Retorna o XML formatado (recuado) para este elemento de streaming.</span><span class="sxs-lookup"><span data-stu-id="7f255-274">Returns the formatted (indented) XML for this streaming element.</span></span></summary>
        <returns><span data-ttu-id="7f255-275">Uma <see cref="T:System.String" /> que contém o XML recuado.</span><span class="sxs-lookup"><span data-stu-id="7f255-275">A <see cref="T:System.String" /> containing the indented XML.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="7f255-276">Observe que durante a depuração de um programa que usa <xref:System.Xml.Linq.XStreamingElement>, exibir o valor de um objeto faz com que seu <xref:System.Xml.Linq.XStreamingElement.ToString%2A> método a ser chamado.</span><span class="sxs-lookup"><span data-stu-id="7f255-276">Note that when debugging a program that uses <xref:System.Xml.Linq.XStreamingElement>, displaying the value of an object causes its <xref:System.Xml.Linq.XStreamingElement.ToString%2A> method to be called.</span></span> <span data-ttu-id="7f255-277">Isso faz com que o XML a ser serializado.</span><span class="sxs-lookup"><span data-stu-id="7f255-277">This causes the XML to be serialized.</span></span> <span data-ttu-id="7f255-278">Se a semântica da consulta elemento streaming, de modo que o elemento de streaming só pode ser transmitido uma vez, isso pode causar comportamento indesejado na sua experiência de depuração.</span><span class="sxs-lookup"><span data-stu-id="7f255-278">If the semantics of your streaming element query are such that the streaming element can only be streamed once, this may cause undesirable behavior in your debugging experience.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="7f255-279">O exemplo a seguir mostra dois usos do <xref:System.Xml.Linq.XStreamingElement.ToString%2A>.</span><span class="sxs-lookup"><span data-stu-id="7f255-279">The following example shows two uses of <xref:System.Xml.Linq.XStreamingElement.ToString%2A>.</span></span> <span data-ttu-id="7f255-280">O primeiro uso preserva espaço em branco.</span><span class="sxs-lookup"><span data-stu-id="7f255-280">The first use preserves white space.</span></span> <span data-ttu-id="7f255-281">Segunda serializa o <xref:System.Xml.Linq.XStreamingElement> com formatação.</span><span class="sxs-lookup"><span data-stu-id="7f255-281">The second one serializes the <xref:System.Xml.Linq.XStreamingElement> with formatting.</span></span>  
  
```csharp  
XElement srcTree = new XElement("Root",  
                       new XElement("Child", 1),  
                       new XElement("Child", 2),  
                       new XElement("Child", 3),  
                       new XElement("Child", 4),  
                       new XElement("Child", 5)  
                   );  
  
XStreamingElement dstTree = new XStreamingElement("NewRoot",  
                        from el in srcTree.Elements()  
                        where (int)el == 3  
                        select new XElement("DifferentChild", (int)el)  
                    );  
  
Console.WriteLine(dstTree.ToString(SaveOptions.DisableFormatting));  
Console.WriteLine("------");  
Console.WriteLine(dstTree.ToString());  
```  
  
```vb  
Dim srcTree As XElement = _  
    <Root>  
        <Child>1</Child>  
        <Child>2</Child>  
        <Child>3</Child>  
        <Child>4</Child>  
        <Child>5</Child>  
    </Root>  
  
Dim dstTree As XStreamingElement = New XStreamingElement("NewRoot", _  
                        From el In srcTree.Elements() _  
                        Where el.Value = 3 _  
                        Select <DifferentChild><%= el.Value %></DifferentChild> _  
                    )  
  
Console.WriteLine(dstTree.ToString(SaveOptions.DisableFormatting))  
Console.WriteLine("------")  
Console.WriteLine(dstTree.ToString())  
```  
  
 <span data-ttu-id="7f255-282">Este exemplo gera a seguinte saída:</span><span class="sxs-lookup"><span data-stu-id="7f255-282">This example produces the following output:</span></span>  
  
```  
<NewRoot><DifferentChild>3</DifferentChild></NewRoot>  
------  
<NewRoot>  
  <DifferentChild>3</DifferentChild>  
</NewRoot>  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public string ToString (System.Xml.Linq.SaveOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToString(valuetype System.Xml.Linq.SaveOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XStreamingElement.ToString(System.Xml.Linq.SaveOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToString (options As SaveOptions) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ToString(System::Xml::Linq::SaveOptions options);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="options" Type="System.Xml.Linq.SaveOptions" />
      </Parameters>
      <Docs>
        <param name="options"><span data-ttu-id="7f255-283">Um <see cref="T:System.Xml.Linq.SaveOptions" /> que especifica o comportamento de formatação.</span><span class="sxs-lookup"><span data-stu-id="7f255-283">A <see cref="T:System.Xml.Linq.SaveOptions" /> that specifies formatting behavior.</span></span></param>
        <summary><span data-ttu-id="7f255-284">Retorna o XML para este elemento de streaming, se desejar desabilitar a formatação.</span><span class="sxs-lookup"><span data-stu-id="7f255-284">Returns the XML for this streaming element, optionally disabling formatting.</span></span></summary>
        <returns><span data-ttu-id="7f255-285">Um <see cref="T:System.String" /> que contém o XML.</span><span class="sxs-lookup"><span data-stu-id="7f255-285">A <see cref="T:System.String" /> containing the XML.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="7f255-286">Observe que durante a depuração de um programa que usa <xref:System.Xml.Linq.XStreamingElement>, exibir o valor de um objeto faz com que seu <xref:System.Xml.Linq.XStreamingElement.ToString%2A> método a ser chamado.</span><span class="sxs-lookup"><span data-stu-id="7f255-286">Note that when debugging a program that uses <xref:System.Xml.Linq.XStreamingElement>, displaying the value of an object causes its <xref:System.Xml.Linq.XStreamingElement.ToString%2A> method to be called.</span></span> <span data-ttu-id="7f255-287">Isso faz com que o XML a ser serializado.</span><span class="sxs-lookup"><span data-stu-id="7f255-287">This causes the XML to be serialized.</span></span> <span data-ttu-id="7f255-288">Se a semântica da consulta elemento streaming, de modo que o elemento de streaming só pode ser transmitido uma vez, isso pode causar comportamento indesejado na sua experiência de depuração.</span><span class="sxs-lookup"><span data-stu-id="7f255-288">If the semantics of your streaming element query are such that the streaming element can only be streamed once, this may cause undesirable behavior in your debugging experience.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="7f255-289">O exemplo a seguir mostra dois usos do <xref:System.Xml.Linq.XStreamingElement.ToString%2A>.</span><span class="sxs-lookup"><span data-stu-id="7f255-289">The following example shows two uses of <xref:System.Xml.Linq.XStreamingElement.ToString%2A>.</span></span> <span data-ttu-id="7f255-290">O primeiro uso preserva espaço em branco.</span><span class="sxs-lookup"><span data-stu-id="7f255-290">The first use preserves white space.</span></span> <span data-ttu-id="7f255-291">Segunda serializa o <xref:System.Xml.Linq.XStreamingElement> com formatação.</span><span class="sxs-lookup"><span data-stu-id="7f255-291">The second one serializes the <xref:System.Xml.Linq.XStreamingElement> with formatting.</span></span>  
  
```csharp  
XElement srcTree = new XElement("Root",  
                       new XElement("Child", 1),  
                       new XElement("Child", 2),  
                       new XElement("Child", 3),  
                       new XElement("Child", 4),  
                       new XElement("Child", 5)  
                   );  
  
XStreamingElement dstTree = new XStreamingElement("NewRoot",  
                        from el in srcTree.Elements()  
                        where (int)el == 3  
                        select new XElement("DifferentChild", (int)el)  
                    );  
  
Console.WriteLine(dstTree.ToString(SaveOptions.DisableFormatting));  
Console.WriteLine("------");  
Console.WriteLine(dstTree.ToString());  
```  
  
```vb  
Dim srcTree As XElement = _  
    <Root>  
        <Child>1</Child>  
        <Child>2</Child>  
        <Child>3</Child>  
        <Child>4</Child>  
        <Child>5</Child>  
    </Root>  
  
Dim dstTree As XStreamingElement = New XStreamingElement("NewRoot", _  
                        From el In srcTree.Elements() _  
                        Where el.Value = 3 _  
                        Select <DifferentChild><%= el.Value %></DifferentChild> _  
                    )  
  
Console.WriteLine(dstTree.ToString(SaveOptions.DisableFormatting))  
Console.WriteLine("------")  
Console.WriteLine(dstTree.ToString())  
```  
  
 <span data-ttu-id="7f255-292">Este exemplo gera a seguinte saída:</span><span class="sxs-lookup"><span data-stu-id="7f255-292">This example produces the following output:</span></span>  
  
```  
<NewRoot><DifferentChild>3</DifferentChild></NewRoot>  
------  
<NewRoot>  
  <DifferentChild>3</DifferentChild>  
</NewRoot>  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteTo">
      <MemberSignature Language="C#" Value="public void WriteTo (System.Xml.XmlWriter writer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteTo(class System.Xml.XmlWriter writer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XStreamingElement.WriteTo(System.Xml.XmlWriter)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteTo (writer As XmlWriter)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteTo(System::Xml::XmlWriter ^ writer);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Xml.XmlWriter" />
      </Parameters>
      <Docs>
        <param name="writer"><span data-ttu-id="7f255-293">Um <see cref="T:System.Xml.XmlWriter" /> no qual esse método gravará.</span><span class="sxs-lookup"><span data-stu-id="7f255-293">An <see cref="T:System.Xml.XmlWriter" /> into which this method will write.</span></span></param>
        <summary><span data-ttu-id="7f255-294">Grava este elemento de streaming em um <see cref="T:System.Xml.XmlWriter" />.</span><span class="sxs-lookup"><span data-stu-id="7f255-294">Writes this streaming element to an <see cref="T:System.Xml.XmlWriter" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="7f255-295">O exemplo a seguir cria uma árvore XML com <xref:System.Xml.Linq.XStreamingElement>.</span><span class="sxs-lookup"><span data-stu-id="7f255-295">The following example creates an XML tree using <xref:System.Xml.Linq.XStreamingElement>.</span></span> <span data-ttu-id="7f255-296">Ele grava o elemento de fluxo para um <xref:System.Xml.XmlWriter>.</span><span class="sxs-lookup"><span data-stu-id="7f255-296">It then writes the streaming element to an <xref:System.Xml.XmlWriter>.</span></span>  
  
```csharp  
XElement srcTree = new XElement("Root",  
                       new XElement("Child", 1),  
                       new XElement("Child", 2),  
                       new XElement("Child", 3),  
                       new XElement("Child", 4),  
                       new XElement("Child", 5)  
                   );  
  
XStreamingElement dstTree = new XStreamingElement("NewRoot",  
                        from el in srcTree.Elements()  
                        where (int)el == 3  
                        select new XElement("DifferentChild", (int)el)  
                    );  
  
StringBuilder sb = new StringBuilder();  
XmlWriterSettings xws = new XmlWriterSettings();  
xws.OmitXmlDeclaration = true;  
xws.Indent = true;  
  
using (XmlWriter xw = XmlWriter.Create(sb, xws))  
{  
    dstTree.WriteTo(xw);  
}  
Console.WriteLine(sb.ToString());  
```  
  
```vb  
Dim srcTree As XElement = _  
    <Root>  
        <Child>1</Child>  
        <Child>2</Child>  
        <Child>3</Child>  
        <Child>4</Child>  
        <Child>5</Child>  
    </Root>  
  
Dim dstTree As XStreamingElement = _   
    New XStreamingElement("NewRoot", _  
        From el In srcTree.Elements() _  
        Where el.Value = 3 _  
        Select <DifferentChild><%= el.Value %></DifferentChild> )  
  
Dim sb As StringBuilder = New StringBuilder()  
Dim xws As XmlWriterSettings = New XmlWriterSettings()  
xws.OmitXmlDeclaration = True  
xws.Indent = True  
  
Using xw As XmlWriter = XmlWriter.Create(sb, xws)  
    dstTree.WriteTo(xw)  
End Using  
Console.WriteLine(sb.ToString())  
```  
  
 <span data-ttu-id="7f255-297">Este exemplo gera a seguinte saída:</span><span class="sxs-lookup"><span data-stu-id="7f255-297">This example produces the following output:</span></span>  
  
```xml  
<NewRoot>  
  <DifferentChild>3</DifferentChild>  
</NewRoot>  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>