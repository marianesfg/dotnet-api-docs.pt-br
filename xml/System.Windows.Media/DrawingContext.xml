<Type Name="DrawingContext" FullName="System.Windows.Media.DrawingContext">
  <Metadata><Meta Name="ms.openlocfilehash" Value="5c9f3989366e53fc7d89c61501edcc887835bd7b" /><Meta Name="ms.sourcegitcommit" Value="8e213bb5e6801f6e29861ba72664978ad00e34fa" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="pt-BR" /><Meta Name="ms.lasthandoff" Value="02/18/2019" /><Meta Name="ms.locfileid" Value="56379911" /></Metadata><TypeSignature Language="C#" Value="public abstract class DrawingContext : System.Windows.Threading.DispatcherObject, IDisposable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit DrawingContext extends System.Windows.Threading.DispatcherObject implements class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Media.DrawingContext" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class DrawingContext&#xA;Inherits DispatcherObject&#xA;Implements IDisposable" />
  <TypeSignature Language="C++ CLI" Value="public ref class DrawingContext abstract : System::Windows::Threading::DispatcherObject, IDisposable" />
  <TypeSignature Language="F#" Value="type DrawingContext = class&#xA;    inherit DispatcherObject&#xA;    interface IDisposable" />
  <AssemblyInfo>
    <AssemblyName>PresentationCore</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Windows.Threading.DispatcherObject</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Descreve o conteúdo visual usando os comandos draw, push e pop.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use uma <xref:System.Windows.Media.DrawingContext> para preencher um <xref:System.Windows.Media.Visual> ou um <xref:System.Windows.Media.Drawing> com conteúdo visual.  
  
 Embora o <xref:System.Windows.Media.DrawingContext> métodos de desenho pareçam semelhantes aos métodos de desenho a <xref:System.Drawing.Graphics?displayProperty=nameWithType> tipo, eles funcionam de forma muito diferente: <xref:System.Windows.Media.DrawingContext> é usada com um sistema de elementos gráficos de modo retido, enquanto o <xref:System.Drawing.Graphics?displayProperty=nameWithType> tipo é usado com um modo imediato sistema de elementos gráficos. Quando você usa um <xref:System.Windows.Media.DrawingContext> comandos de desenho do objeto, na verdade, você está armazenando um conjunto de instruções de renderização (embora o mecanismo de armazenamento exato depende do tipo de objeto que fornece o <xref:System.Windows.Media.DrawingContext>) que será usado posteriormente pelos elementos gráficos do sistema; você não está desenhando na tela em tempo real. Para obter mais informações sobre como funciona o sistema de elementos gráficos do Windows Presentation Foundation (WPF), consulte [visão geral de renderização do WPF gráficos](~/docs/framework/wpf/graphics-multimedia/wpf-graphics-rendering-overview.md).  
  
 Você nunca instancia diretamente uma <xref:System.Windows.Media.DrawingContext>; no entanto, você pode, adquirir um contexto de desenho de alguns métodos, tais como <xref:System.Windows.Media.DrawingGroup.Open%2A?displayProperty=nameWithType> e <xref:System.Windows.Media.DrawingVisual.RenderOpen%2A?displayProperty=nameWithType>.  
  
   
  
## Examples  
 O exemplo a seguir recupera uma <xref:System.Windows.Media.DrawingContext> de um <xref:System.Windows.Media.DrawingVisual> e usa-o para desenhar um retângulo.  
  
 [!code-csharp[drawingvisualsample#101](~/samples/snippets/csharp/VS_Snippets_Wpf/DrawingVisualSample/CSharp/Window1.xaml.cs#101)]
 [!code-vb[drawingvisualsample#101](~/samples/snippets/visualbasic/VS_Snippets_Wpf/DrawingVisualSample/visualbasic/window1.xaml.vb#101)]  
  
 O exemplo a seguir demonstra a <xref:System.Windows.Media.DrawingContext.PushOpacity%2A>, <xref:System.Windows.Media.DrawingContext.PushEffect%2A>, e <xref:System.Windows.Media.DrawingContext.Pop%2A> comandos. O <xref:System.Windows.Media.DrawingContext> é obtido de um <xref:System.Windows.Media.DrawingGroup> e exibida usando um <xref:System.Windows.Controls.Image> controle.  
  
 [!code-csharp[DrawingContext_procedural_snip#PushEffectExampleWholePage](~/samples/snippets/csharp/VS_Snippets_Wpf/DrawingContext_procedural_snip/CSharp/PushEffectExample.cs#pusheffectexamplewholepage)]
 [!code-vb[DrawingContext_procedural_snip#PushEffectExampleWholePage](~/samples/snippets/visualbasic/VS_Snippets_Wpf/DrawingContext_procedural_snip/visualbasic/pusheffectexample.vb#pusheffectexamplewholepage)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Windows.Media.DrawingGroup" />
    <altmember cref="T:System.Windows.Media.Drawing" />
  </Docs>
  <Members>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public abstract void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.DrawingContext.Close" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract void Close();" />
      <MemberSignature Language="F#" Value="abstract member Close : unit -&gt; unit" Usage="drawingContext.Close " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Fecha o <see cref="T:System.Windows.Media.DrawingContext" /> e libera o conteúdo. Depois disso, o <see cref="T:System.Windows.Media.DrawingContext" /> não pode ser modificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Um <xref:System.Windows.Media.DrawingContext> devem ser fechadas antes que seu conteúdo pode ser renderizado, mas após ele ter sido fechado, ele não pode ser modificado. Essa chamada não exige que todas as chamadas de envio por Push para foram disparados.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Este objeto já foi fechado ou descartado.</exception>
      </Docs>
    </Member>
    <Member MemberName="DisposeCore">
      <MemberSignature Language="C#" Value="protected abstract void DisposeCore ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void DisposeCore() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.DrawingContext.DisposeCore" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Sub DisposeCore ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract void DisposeCore();" />
      <MemberSignature Language="F#" Value="abstract member DisposeCore : unit -&gt; unit" Usage="drawingContext.DisposeCore " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Libera todos os recursos usados pelo <see cref="T:System.Windows.Media.DrawingContext" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Não chame este método diretamente do seu código; Use o <xref:System.Windows.Media.DrawingContext.System%23IDisposable%23Dispose%2A> método em vez disso.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">O objeto já foi fechado ou descartado.</exception>
        <altmember cref="M:System.Windows.Media.DrawingContext.System#IDisposable#Dispose" />
      </Docs>
    </Member>
    <Member MemberName="DrawDrawing">
      <MemberSignature Language="C#" Value="public abstract void DrawDrawing (System.Windows.Media.Drawing drawing);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void DrawDrawing(class System.Windows.Media.Drawing drawing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.DrawingContext.DrawDrawing(System.Windows.Media.Drawing)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract void DrawDrawing(System::Windows::Media::Drawing ^ drawing);" />
      <MemberSignature Language="F#" Value="abstract member DrawDrawing : System.Windows.Media.Drawing -&gt; unit" Usage="drawingContext.DrawDrawing drawing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="drawing" Type="System.Windows.Media.Drawing" />
      </Parameters>
      <Docs>
        <param name="drawing">O desenho a ser acrescentado.</param>
        <summary>Desenha o objeto <see cref="T:System.Windows.Media.Drawing" /> especificado.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="DrawEllipse">
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Desenha uma elipse.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="DrawEllipse">
      <MemberSignature Language="C#" Value="public abstract void DrawEllipse (System.Windows.Media.Brush brush, System.Windows.Media.Pen pen, System.Windows.Point center, double radiusX, double radiusY);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void DrawEllipse(class System.Windows.Media.Brush brush, class System.Windows.Media.Pen pen, valuetype System.Windows.Point center, float64 radiusX, float64 radiusY) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.DrawingContext.DrawEllipse(System.Windows.Media.Brush,System.Windows.Media.Pen,System.Windows.Point,System.Double,System.Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract void DrawEllipse(System::Windows::Media::Brush ^ brush, System::Windows::Media::Pen ^ pen, System::Windows::Point center, double radiusX, double radiusY);" />
      <MemberSignature Language="F#" Value="abstract member DrawEllipse : System.Windows.Media.Brush * System.Windows.Media.Pen * System.Windows.Point * double * double -&gt; unit" Usage="drawingContext.DrawEllipse (brush, pen, center, radiusX, radiusY)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="brush" Type="System.Windows.Media.Brush" />
        <Parameter Name="pen" Type="System.Windows.Media.Pen" />
        <Parameter Name="center" Type="System.Windows.Point" />
        <Parameter Name="radiusX" Type="System.Double" />
        <Parameter Name="radiusY" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="brush">O pincel com o qual preencher a elipse.  Isso é opcional e pode ser <see langword="null" />. Se o pincel for <see langword="null" />, nenhum preenchimento será desenhado.</param>
        <param name="pen">A caneta com a qual traçar a elipse.  Isso é opcional e pode ser <see langword="null" />. Se a caneta for <see langword="null" />, nenhum traço será desenhado.</param>
        <param name="center">A localização do centro da elipse.</param>
        <param name="radiusX">O raio horizontal da elipse.</param>
        <param name="radiusY">O raio vertical da elipse.</param>
        <summary>Desenha uma elipse com o <see cref="T:System.Windows.Media.Brush" /> e <see cref="T:System.Windows.Media.Pen" /> especificados.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A caneta e Pincel podem ser `null`.  Se o pincel for `null`, nenhum preenchimento será executada.  Se a caneta for `null`, nenhum traçado será executada.  Se a caneta e pincel são `null`, em seguida, o desenho não está visível.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DrawEllipse">
      <MemberSignature Language="C#" Value="public abstract void DrawEllipse (System.Windows.Media.Brush brush, System.Windows.Media.Pen pen, System.Windows.Point center, System.Windows.Media.Animation.AnimationClock centerAnimations, double radiusX, System.Windows.Media.Animation.AnimationClock radiusXAnimations, double radiusY, System.Windows.Media.Animation.AnimationClock radiusYAnimations);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void DrawEllipse(class System.Windows.Media.Brush brush, class System.Windows.Media.Pen pen, valuetype System.Windows.Point center, class System.Windows.Media.Animation.AnimationClock centerAnimations, float64 radiusX, class System.Windows.Media.Animation.AnimationClock radiusXAnimations, float64 radiusY, class System.Windows.Media.Animation.AnimationClock radiusYAnimations) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.DrawingContext.DrawEllipse(System.Windows.Media.Brush,System.Windows.Media.Pen,System.Windows.Point,System.Windows.Media.Animation.AnimationClock,System.Double,System.Windows.Media.Animation.AnimationClock,System.Double,System.Windows.Media.Animation.AnimationClock)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract void DrawEllipse(System::Windows::Media::Brush ^ brush, System::Windows::Media::Pen ^ pen, System::Windows::Point center, System::Windows::Media::Animation::AnimationClock ^ centerAnimations, double radiusX, System::Windows::Media::Animation::AnimationClock ^ radiusXAnimations, double radiusY, System::Windows::Media::Animation::AnimationClock ^ radiusYAnimations);" />
      <MemberSignature Language="F#" Value="abstract member DrawEllipse : System.Windows.Media.Brush * System.Windows.Media.Pen * System.Windows.Point * System.Windows.Media.Animation.AnimationClock * double * System.Windows.Media.Animation.AnimationClock * double * System.Windows.Media.Animation.AnimationClock -&gt; unit" Usage="drawingContext.DrawEllipse (brush, pen, center, centerAnimations, radiusX, radiusXAnimations, radiusY, radiusYAnimations)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="brush" Type="System.Windows.Media.Brush" />
        <Parameter Name="pen" Type="System.Windows.Media.Pen" />
        <Parameter Name="center" Type="System.Windows.Point" />
        <Parameter Name="centerAnimations" Type="System.Windows.Media.Animation.AnimationClock" />
        <Parameter Name="radiusX" Type="System.Double" />
        <Parameter Name="radiusXAnimations" Type="System.Windows.Media.Animation.AnimationClock" />
        <Parameter Name="radiusY" Type="System.Double" />
        <Parameter Name="radiusYAnimations" Type="System.Windows.Media.Animation.AnimationClock" />
      </Parameters>
      <Docs>
        <param name="brush">O pincel com o qual preencher a elipse.  Isso é opcional e pode ser <see langword="null" />. Se o pincel for <see langword="null" />, nenhum preenchimento será desenhado.</param>
        <param name="pen">A caneta com a qual traçar a elipse.  Isso é opcional e pode ser <see langword="null" />. Se a caneta for <see langword="null" />, nenhum traço será desenhado.</param>
        <param name="center">A localização do centro da elipse.</param>
        <param name="centerAnimations">O relógio com o qual animar a posição do centro da elipse ou <see langword="null" /> para nenhuma animação. Esse relógio deve ser criado com base em um <see cref="T:System.Windows.Media.Animation.AnimationTimeline" /> que pode animar objetos <see cref="T:System.Windows.Point" />.</param>
        <param name="radiusX">O raio horizontal da elipse.</param>
        <param name="radiusXAnimations">O relógio com o qual animar o raio x ou <see langword="null" /> para nenhuma animação. Esse relógio deve ser criado com base em um <see cref="T:System.Windows.Media.Animation.AnimationTimeline" /> que pode animar objetos <see cref="T:System.Double" />.</param>
        <param name="radiusY">O raio vertical da elipse.</param>
        <param name="radiusYAnimations">O relógio com o qual animar o raio y ou <see langword="null" /> para nenhuma animação. Esse relógio deve ser criado com base em um <see cref="T:System.Windows.Media.Animation.AnimationTimeline" /> que pode animar objetos <see cref="T:System.Double" />.</param>
        <summary>Desenha uma elipse com o <see cref="T:System.Windows.Media.Brush" /> e <see cref="T:System.Windows.Media.Pen" /> especificado e aplica os relógios de animação especificados.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A caneta e Pincel podem ser `null`.  Se o pincel for `null`, nenhum preenchimento será executada.  Se a caneta for `null`, nenhum traçado será executada.  Se a caneta e pincel são `null`, em seguida, o desenho não está visível.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DrawGeometry">
      <MemberSignature Language="C#" Value="public abstract void DrawGeometry (System.Windows.Media.Brush brush, System.Windows.Media.Pen pen, System.Windows.Media.Geometry geometry);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void DrawGeometry(class System.Windows.Media.Brush brush, class System.Windows.Media.Pen pen, class System.Windows.Media.Geometry geometry) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.DrawingContext.DrawGeometry(System.Windows.Media.Brush,System.Windows.Media.Pen,System.Windows.Media.Geometry)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract void DrawGeometry(System::Windows::Media::Brush ^ brush, System::Windows::Media::Pen ^ pen, System::Windows::Media::Geometry ^ geometry);" />
      <MemberSignature Language="F#" Value="abstract member DrawGeometry : System.Windows.Media.Brush * System.Windows.Media.Pen * System.Windows.Media.Geometry -&gt; unit" Usage="drawingContext.DrawGeometry (brush, pen, geometry)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="brush" Type="System.Windows.Media.Brush" />
        <Parameter Name="pen" Type="System.Windows.Media.Pen" />
        <Parameter Name="geometry" Type="System.Windows.Media.Geometry" />
      </Parameters>
      <Docs>
        <param name="brush">O <see cref="T:System.Windows.Media.Brush" /> com o qual preencher a <see cref="T:System.Windows.Media.Geometry" />. Isso é opcional e pode ser <see langword="null" />. Se o pincel for <see langword="null" />, nenhum preenchimento será desenhado.</param>
        <param name="pen">A <see cref="T:System.Windows.Media.Pen" /> com a qual traçar a <see cref="T:System.Windows.Media.Geometry" />. Isso é opcional e pode ser <see langword="null" />. Se a caneta for <see langword="null" />, nenhum traço será desenhado.</param>
        <param name="geometry">O <see cref="T:System.Windows.Media.Geometry" /> a ser desenhado.</param>
        <summary>Desenha a <see cref="T:System.Windows.Media.Geometry" /> especificada usando o <see cref="T:System.Windows.Media.Brush" /> e <see cref="T:System.Windows.Media.Pen" /> especificados.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DrawGlyphRun">
      <MemberSignature Language="C#" Value="public abstract void DrawGlyphRun (System.Windows.Media.Brush foregroundBrush, System.Windows.Media.GlyphRun glyphRun);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void DrawGlyphRun(class System.Windows.Media.Brush foregroundBrush, class System.Windows.Media.GlyphRun glyphRun) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.DrawingContext.DrawGlyphRun(System.Windows.Media.Brush,System.Windows.Media.GlyphRun)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract void DrawGlyphRun(System::Windows::Media::Brush ^ foregroundBrush, System::Windows::Media::GlyphRun ^ glyphRun);" />
      <MemberSignature Language="F#" Value="abstract member DrawGlyphRun : System.Windows.Media.Brush * System.Windows.Media.GlyphRun -&gt; unit" Usage="drawingContext.DrawGlyphRun (foregroundBrush, glyphRun)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="foregroundBrush" Type="System.Windows.Media.Brush" />
        <Parameter Name="glyphRun" Type="System.Windows.Media.GlyphRun" />
      </Parameters>
      <Docs>
        <param name="foregroundBrush">O pincel usado para pintar o texto.</param>
        <param name="glyphRun">O texto a ser desenhado.</param>
        <summary>Desenha o texto especificado.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="DrawImage">
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Desenha uma imagem na região definida pelo <see cref="T:System.Windows.Rect" /> especificado.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="DrawImage">
      <MemberSignature Language="C#" Value="public abstract void DrawImage (System.Windows.Media.ImageSource imageSource, System.Windows.Rect rectangle);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void DrawImage(class System.Windows.Media.ImageSource imageSource, valuetype System.Windows.Rect rectangle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.DrawingContext.DrawImage(System.Windows.Media.ImageSource,System.Windows.Rect)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract void DrawImage(System::Windows::Media::ImageSource ^ imageSource, System::Windows::Rect rectangle);" />
      <MemberSignature Language="F#" Value="abstract member DrawImage : System.Windows.Media.ImageSource * System.Windows.Rect -&gt; unit" Usage="drawingContext.DrawImage (imageSource, rectangle)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="imageSource" Type="System.Windows.Media.ImageSource" />
        <Parameter Name="rectangle" Type="System.Windows.Rect" />
      </Parameters>
      <Docs>
        <param name="imageSource">A imagem a ser desenhada.</param>
        <param name="rectangle">A região na qual desenhar <c>bitmapSource</c>.</param>
        <summary>Desenha uma imagem na região definida pelo <see cref="T:System.Windows.Rect" /> especificado.</summary>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.Permissions.MediaPermission">Para exibir imagens que não possuem <see cref="T:System.Net.WebPermission" /> ou <see cref="T:System.Security.Permissions.FileIOPermission" /> acessar para. Enumeração associada: <see cref="F:System.Security.Permissions.MediaPermissionImage.SafeImage" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="DrawImage">
      <MemberSignature Language="C#" Value="public abstract void DrawImage (System.Windows.Media.ImageSource imageSource, System.Windows.Rect rectangle, System.Windows.Media.Animation.AnimationClock rectangleAnimations);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void DrawImage(class System.Windows.Media.ImageSource imageSource, valuetype System.Windows.Rect rectangle, class System.Windows.Media.Animation.AnimationClock rectangleAnimations) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.DrawingContext.DrawImage(System.Windows.Media.ImageSource,System.Windows.Rect,System.Windows.Media.Animation.AnimationClock)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract void DrawImage(System::Windows::Media::ImageSource ^ imageSource, System::Windows::Rect rectangle, System::Windows::Media::Animation::AnimationClock ^ rectangleAnimations);" />
      <MemberSignature Language="F#" Value="abstract member DrawImage : System.Windows.Media.ImageSource * System.Windows.Rect * System.Windows.Media.Animation.AnimationClock -&gt; unit" Usage="drawingContext.DrawImage (imageSource, rectangle, rectangleAnimations)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="imageSource" Type="System.Windows.Media.ImageSource" />
        <Parameter Name="rectangle" Type="System.Windows.Rect" />
        <Parameter Name="rectangleAnimations" Type="System.Windows.Media.Animation.AnimationClock" />
      </Parameters>
      <Docs>
        <param name="imageSource">A imagem a ser desenhada.</param>
        <param name="rectangle">A região na qual desenhar <c>bitmapSource</c>.</param>
        <param name="rectangleAnimations">O relógio com o qual o tamanho e as dimensões do retângulo são animados ou <see langword="null" /> para nenhuma animação. Esse relógio deve ser criado com base em um <see cref="T:System.Windows.Media.Animation.AnimationTimeline" /> que pode animar objetos <see cref="T:System.Windows.Rect" />.</param>
        <summary>Desenha uma imagem na região definida pelo <see cref="T:System.Windows.Rect" /> especificado e aplica o relógio de animação especificado.</summary>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.Permissions.MediaPermission">Para exibir imagens que não possuem <see cref="T:System.Net.WebPermission" /> ou <see cref="T:System.Security.Permissions.FileIOPermission" /> acessar para. Enumeração associada: <see cref="F:System.Security.Permissions.MediaPermissionImage.SafeImage" />.</permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="DrawLine">
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Desenha uma linha com a <see cref="T:System.Windows.Media.Pen" /> especificada.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="DrawLine">
      <MemberSignature Language="C#" Value="public abstract void DrawLine (System.Windows.Media.Pen pen, System.Windows.Point point0, System.Windows.Point point1);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void DrawLine(class System.Windows.Media.Pen pen, valuetype System.Windows.Point point0, valuetype System.Windows.Point point1) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.DrawingContext.DrawLine(System.Windows.Media.Pen,System.Windows.Point,System.Windows.Point)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract void DrawLine(System::Windows::Media::Pen ^ pen, System::Windows::Point point0, System::Windows::Point point1);" />
      <MemberSignature Language="F#" Value="abstract member DrawLine : System.Windows.Media.Pen * System.Windows.Point * System.Windows.Point -&gt; unit" Usage="drawingContext.DrawLine (pen, point0, point1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pen" Type="System.Windows.Media.Pen" />
        <Parameter Name="point0" Type="System.Windows.Point" />
        <Parameter Name="point1" Type="System.Windows.Point" />
      </Parameters>
      <Docs>
        <param name="pen">A caneta com a qual a linha será traçada.</param>
        <param name="point0">O ponto inicial da linha.</param>
        <param name="point1">O ponto de extremidade da linha.</param>
        <summary>Desenha uma linha entre os pontos especificados usando o <see cref="T:System.Windows.Media.Pen" /> especificado.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DrawLine">
      <MemberSignature Language="C#" Value="public abstract void DrawLine (System.Windows.Media.Pen pen, System.Windows.Point point0, System.Windows.Media.Animation.AnimationClock point0Animations, System.Windows.Point point1, System.Windows.Media.Animation.AnimationClock point1Animations);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void DrawLine(class System.Windows.Media.Pen pen, valuetype System.Windows.Point point0, class System.Windows.Media.Animation.AnimationClock point0Animations, valuetype System.Windows.Point point1, class System.Windows.Media.Animation.AnimationClock point1Animations) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.DrawingContext.DrawLine(System.Windows.Media.Pen,System.Windows.Point,System.Windows.Media.Animation.AnimationClock,System.Windows.Point,System.Windows.Media.Animation.AnimationClock)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract void DrawLine(System::Windows::Media::Pen ^ pen, System::Windows::Point point0, System::Windows::Media::Animation::AnimationClock ^ point0Animations, System::Windows::Point point1, System::Windows::Media::Animation::AnimationClock ^ point1Animations);" />
      <MemberSignature Language="F#" Value="abstract member DrawLine : System.Windows.Media.Pen * System.Windows.Point * System.Windows.Media.Animation.AnimationClock * System.Windows.Point * System.Windows.Media.Animation.AnimationClock -&gt; unit" Usage="drawingContext.DrawLine (pen, point0, point0Animations, point1, point1Animations)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pen" Type="System.Windows.Media.Pen" />
        <Parameter Name="point0" Type="System.Windows.Point" />
        <Parameter Name="point0Animations" Type="System.Windows.Media.Animation.AnimationClock" />
        <Parameter Name="point1" Type="System.Windows.Point" />
        <Parameter Name="point1Animations" Type="System.Windows.Media.Animation.AnimationClock" />
      </Parameters>
      <Docs>
        <param name="pen">A caneta para traçar a linha.</param>
        <param name="point0">O ponto inicial da linha.</param>
        <param name="point0Animations">O relógio com o qual animar o ponto de partida da linha ou <see langword="null" /> para nenhuma animação. Esse relógio deve ser criado com base em um <see cref="T:System.Windows.Media.Animation.AnimationTimeline" /> que pode animar objetos <see cref="T:System.Windows.Point" />.</param>
        <param name="point1">O ponto de extremidade da linha.</param>
        <param name="point1Animations">O relógio com o qual animar o ponto de término da linha ou <see langword="null" /> para nenhuma animação. Esse relógio deve ser criado com base em um <see cref="T:System.Windows.Media.Animation.AnimationTimeline" /> que pode animar objetos <see cref="T:System.Windows.Point" />.</param>
        <summary>Desenha uma linha entre os pontos especificados usando o <see cref="T:System.Windows.Media.Pen" /> especificado e aplica os relógios de animação especificados.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="DrawRectangle">
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Desenha um retângulo.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="DrawRectangle">
      <MemberSignature Language="C#" Value="public abstract void DrawRectangle (System.Windows.Media.Brush brush, System.Windows.Media.Pen pen, System.Windows.Rect rectangle);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void DrawRectangle(class System.Windows.Media.Brush brush, class System.Windows.Media.Pen pen, valuetype System.Windows.Rect rectangle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.DrawingContext.DrawRectangle(System.Windows.Media.Brush,System.Windows.Media.Pen,System.Windows.Rect)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract void DrawRectangle(System::Windows::Media::Brush ^ brush, System::Windows::Media::Pen ^ pen, System::Windows::Rect rectangle);" />
      <MemberSignature Language="F#" Value="abstract member DrawRectangle : System.Windows.Media.Brush * System.Windows.Media.Pen * System.Windows.Rect -&gt; unit" Usage="drawingContext.DrawRectangle (brush, pen, rectangle)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="brush" Type="System.Windows.Media.Brush" />
        <Parameter Name="pen" Type="System.Windows.Media.Pen" />
        <Parameter Name="rectangle" Type="System.Windows.Rect" />
      </Parameters>
      <Docs>
        <param name="brush">O pincel com o qual preencher o retângulo.  Isso é opcional e pode ser <see langword="null" />. Se o pincel for <see langword="null" />, nenhum preenchimento será desenhado.</param>
        <param name="pen">A caneta com a qual traçar o retângulo.  Isso é opcional e pode ser <see langword="null" />. Se a caneta for <see langword="null" />, nenhum traço será desenhado.</param>
        <param name="rectangle">O retângulo a ser desenhado.</param>
        <summary>Desenha um retângulo com o <see cref="T:System.Windows.Media.Brush" /> e <see cref="T:System.Windows.Media.Pen" /> especificados. A caneta e o pincel podem ser <see langword="null" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A caneta e Pincel podem ser `null`.  Se o pincel for `null`, nenhum preenchimento será executada.  Se a caneta for `null`, nenhum traçado será executada.  Se a caneta e pincel são `null`, em seguida, o desenho não está visível.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DrawRectangle">
      <MemberSignature Language="C#" Value="public abstract void DrawRectangle (System.Windows.Media.Brush brush, System.Windows.Media.Pen pen, System.Windows.Rect rectangle, System.Windows.Media.Animation.AnimationClock rectangleAnimations);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void DrawRectangle(class System.Windows.Media.Brush brush, class System.Windows.Media.Pen pen, valuetype System.Windows.Rect rectangle, class System.Windows.Media.Animation.AnimationClock rectangleAnimations) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.DrawingContext.DrawRectangle(System.Windows.Media.Brush,System.Windows.Media.Pen,System.Windows.Rect,System.Windows.Media.Animation.AnimationClock)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract void DrawRectangle(System::Windows::Media::Brush ^ brush, System::Windows::Media::Pen ^ pen, System::Windows::Rect rectangle, System::Windows::Media::Animation::AnimationClock ^ rectangleAnimations);" />
      <MemberSignature Language="F#" Value="abstract member DrawRectangle : System.Windows.Media.Brush * System.Windows.Media.Pen * System.Windows.Rect * System.Windows.Media.Animation.AnimationClock -&gt; unit" Usage="drawingContext.DrawRectangle (brush, pen, rectangle, rectangleAnimations)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="brush" Type="System.Windows.Media.Brush" />
        <Parameter Name="pen" Type="System.Windows.Media.Pen" />
        <Parameter Name="rectangle" Type="System.Windows.Rect" />
        <Parameter Name="rectangleAnimations" Type="System.Windows.Media.Animation.AnimationClock" />
      </Parameters>
      <Docs>
        <param name="brush">O pincel com o qual preencher o retângulo.  Isso é opcional e pode ser <see langword="null" />. Se o pincel for <see langword="null" />, nenhum preenchimento será desenhado.</param>
        <param name="pen">A caneta com a qual traçar o retângulo.  Isso é opcional e pode ser <see langword="null" />. Se a caneta for <see langword="null" />, nenhum traço será desenhado.</param>
        <param name="rectangle">O retângulo a ser desenhado.</param>
        <param name="rectangleAnimations">O relógio com o qual o tamanho e as dimensões do retângulo são animados ou <see langword="null" /> para nenhuma animação. Esse relógio deve ser criado com base em um <see cref="T:System.Windows.Media.Animation.AnimationTimeline" /> que pode animar objetos <see cref="T:System.Windows.Rect" />.</param>
        <summary>Desenha um retângulo com o <see cref="T:System.Windows.Media.Brush" /> e <see cref="T:System.Windows.Media.Pen" /> especificado e aplica os relógios de animação especificados.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A caneta e Pincel podem ser `null`.  Se o pincel for `null`, nenhum preenchimento será executada.  Se a caneta for `null`, nenhum traçado será executada.  Se a caneta e pincel são `null`, em seguida, o desenho não está visível.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="DrawRoundedRectangle">
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Desenha um retângulo arredondado.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="DrawRoundedRectangle">
      <MemberSignature Language="C#" Value="public abstract void DrawRoundedRectangle (System.Windows.Media.Brush brush, System.Windows.Media.Pen pen, System.Windows.Rect rectangle, double radiusX, double radiusY);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void DrawRoundedRectangle(class System.Windows.Media.Brush brush, class System.Windows.Media.Pen pen, valuetype System.Windows.Rect rectangle, float64 radiusX, float64 radiusY) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.DrawingContext.DrawRoundedRectangle(System.Windows.Media.Brush,System.Windows.Media.Pen,System.Windows.Rect,System.Double,System.Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract void DrawRoundedRectangle(System::Windows::Media::Brush ^ brush, System::Windows::Media::Pen ^ pen, System::Windows::Rect rectangle, double radiusX, double radiusY);" />
      <MemberSignature Language="F#" Value="abstract member DrawRoundedRectangle : System.Windows.Media.Brush * System.Windows.Media.Pen * System.Windows.Rect * double * double -&gt; unit" Usage="drawingContext.DrawRoundedRectangle (brush, pen, rectangle, radiusX, radiusY)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="brush" Type="System.Windows.Media.Brush" />
        <Parameter Name="pen" Type="System.Windows.Media.Pen" />
        <Parameter Name="rectangle" Type="System.Windows.Rect" />
        <Parameter Name="radiusX" Type="System.Double" />
        <Parameter Name="radiusY" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="brush">O pincel usado para preencher o retângulo.</param>
        <param name="pen">A caneta usada para traçar o retângulo.</param>
        <param name="rectangle">O retângulo a ser desenhado.</param>
        <param name="radiusX">O raio da dimensão X dos cantos arredondados.  Esse valor será ser fixado no intervalo de 0 a <see cref="P:System.Windows.Rect.Width" />/2.</param>
        <param name="radiusY">O raio da dimensão Y dos cantos arredondados.  Esse valor será ser fixado como um valor entre 0 e <see cref="P:System.Windows.Rect.Height" />/2.</param>
        <summary>Desenha um retângulo arredondado com o <see cref="T:System.Windows.Media.Brush" /> e <see cref="T:System.Windows.Media.Pen" /> especificados.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A caneta e Pincel podem ser `null`.  Se o pincel for `null`, nenhum preenchimento será executada.  Se a caneta for `null`, nenhum traçado será executada.  Se a caneta e pincel são `null`, em seguida, o desenho não está visível.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DrawRoundedRectangle">
      <MemberSignature Language="C#" Value="public abstract void DrawRoundedRectangle (System.Windows.Media.Brush brush, System.Windows.Media.Pen pen, System.Windows.Rect rectangle, System.Windows.Media.Animation.AnimationClock rectangleAnimations, double radiusX, System.Windows.Media.Animation.AnimationClock radiusXAnimations, double radiusY, System.Windows.Media.Animation.AnimationClock radiusYAnimations);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void DrawRoundedRectangle(class System.Windows.Media.Brush brush, class System.Windows.Media.Pen pen, valuetype System.Windows.Rect rectangle, class System.Windows.Media.Animation.AnimationClock rectangleAnimations, float64 radiusX, class System.Windows.Media.Animation.AnimationClock radiusXAnimations, float64 radiusY, class System.Windows.Media.Animation.AnimationClock radiusYAnimations) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.DrawingContext.DrawRoundedRectangle(System.Windows.Media.Brush,System.Windows.Media.Pen,System.Windows.Rect,System.Windows.Media.Animation.AnimationClock,System.Double,System.Windows.Media.Animation.AnimationClock,System.Double,System.Windows.Media.Animation.AnimationClock)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract void DrawRoundedRectangle(System::Windows::Media::Brush ^ brush, System::Windows::Media::Pen ^ pen, System::Windows::Rect rectangle, System::Windows::Media::Animation::AnimationClock ^ rectangleAnimations, double radiusX, System::Windows::Media::Animation::AnimationClock ^ radiusXAnimations, double radiusY, System::Windows::Media::Animation::AnimationClock ^ radiusYAnimations);" />
      <MemberSignature Language="F#" Value="abstract member DrawRoundedRectangle : System.Windows.Media.Brush * System.Windows.Media.Pen * System.Windows.Rect * System.Windows.Media.Animation.AnimationClock * double * System.Windows.Media.Animation.AnimationClock * double * System.Windows.Media.Animation.AnimationClock -&gt; unit" Usage="drawingContext.DrawRoundedRectangle (brush, pen, rectangle, rectangleAnimations, radiusX, radiusXAnimations, radiusY, radiusYAnimations)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="brush" Type="System.Windows.Media.Brush" />
        <Parameter Name="pen" Type="System.Windows.Media.Pen" />
        <Parameter Name="rectangle" Type="System.Windows.Rect" />
        <Parameter Name="rectangleAnimations" Type="System.Windows.Media.Animation.AnimationClock" />
        <Parameter Name="radiusX" Type="System.Double" />
        <Parameter Name="radiusXAnimations" Type="System.Windows.Media.Animation.AnimationClock" />
        <Parameter Name="radiusY" Type="System.Double" />
        <Parameter Name="radiusYAnimations" Type="System.Windows.Media.Animation.AnimationClock" />
      </Parameters>
      <Docs>
        <param name="brush">O pincel usado para preencher o retângulo ou <see langword="null" /> para nenhum preenchimento.</param>
        <param name="pen">A caneta usada para traçar o retângulo ou <see langword="null" /> para nenhum traço.</param>
        <param name="rectangle">O retângulo a ser desenhado.</param>
        <param name="rectangleAnimations">O relógio com o qual o tamanho e as dimensões do retângulo são animados ou <see langword="null" /> para nenhuma animação. Esse relógio deve ser criado com base em um <see cref="T:System.Windows.Media.Animation.AnimationTimeline" /> que pode animar objetos <see cref="T:System.Windows.Rect" />.</param>
        <param name="radiusX">O raio da dimensão X dos cantos arredondados.  Esse valor será ser fixado no intervalo de 0 a <see cref="P:System.Windows.Rect.Width" />/2</param>
        <param name="radiusXAnimations">O relógio com o qual o valor <paramref name="radiusX" /> do retângulo é animado ou <see langword="null" /> para nenhuma animação. Esse relógio deve ser criado com base em um <see cref="T:System.Windows.Media.Animation.AnimationTimeline" /> que pode animar valores <see cref="T:System.Double" />.</param>
        <param name="radiusY">O raio da dimensão Y dos cantos arredondados.  Esse valor será ser fixado como um valor entre 0 e <see cref="P:System.Windows.Rect.Height" />/2.</param>
        <param name="radiusYAnimations">O relógio com o qual o valor <paramref name="radiusY" /> do retângulo é animado ou <see langword="null" /> para nenhuma animação. Esse relógio deve ser criado com base em um <see cref="T:System.Windows.Media.Animation.AnimationTimeline" /> que pode animar valores <see cref="T:System.Double" />.</param>
        <summary>Desenha um retângulo arredondado com o <see cref="T:System.Windows.Media.Brush" /> e <see cref="T:System.Windows.Media.Pen" /> especificado e aplica os relógios de animação especificados.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A caneta e Pincel podem ser `null`.  Se o pincel for `null`, nenhum preenchimento será executada.  Se a caneta for `null`, nenhum traçado será executada.  Se a caneta e pincel são `null`, em seguida, o desenho não está visível.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DrawText">
      <MemberSignature Language="C#" Value="public void DrawText (System.Windows.Media.FormattedText formattedText, System.Windows.Point origin);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawText(class System.Windows.Media.FormattedText formattedText, valuetype System.Windows.Point origin) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.DrawingContext.DrawText(System.Windows.Media.FormattedText,System.Windows.Point)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawText(System::Windows::Media::FormattedText ^ formattedText, System::Windows::Point origin);" />
      <MemberSignature Language="F#" Value="member this.DrawText : System.Windows.Media.FormattedText * System.Windows.Point -&gt; unit" Usage="drawingContext.DrawText (formattedText, origin)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="formattedText" Type="System.Windows.Media.FormattedText" />
        <Parameter Name="origin" Type="System.Windows.Point" />
      </Parameters>
      <Docs>
        <param name="formattedText">O texto formatado a ser desenhado.</param>
        <param name="origin">O local em que o texto deve ser desenhado.</param>
        <summary>Desenha texto formatado no local especificado.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException">O objeto já foi fechado ou descartado.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="DrawVideo">
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Desenha um vídeo na região especificada.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="DrawVideo">
      <MemberSignature Language="C#" Value="public abstract void DrawVideo (System.Windows.Media.MediaPlayer player, System.Windows.Rect rectangle);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void DrawVideo(class System.Windows.Media.MediaPlayer player, valuetype System.Windows.Rect rectangle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.DrawingContext.DrawVideo(System.Windows.Media.MediaPlayer,System.Windows.Rect)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Sub DrawVideo (player As MediaPlayer, rectangle As Rect)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract void DrawVideo(System::Windows::Media::MediaPlayer ^ player, System::Windows::Rect rectangle);" />
      <MemberSignature Language="F#" Value="abstract member DrawVideo : System.Windows.Media.MediaPlayer * System.Windows.Rect -&gt; unit" Usage="drawingContext.DrawVideo (player, rectangle)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="player" Type="System.Windows.Media.MediaPlayer" />
        <Parameter Name="rectangle" Type="System.Windows.Rect" />
      </Parameters>
      <Docs>
        <param name="player">A mídia para desenhar.</param>
        <param name="rectangle">A região na qual o <paramref name="player" /> será desenhado.</param>
        <summary>Desenha um vídeo na região especificada.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Observe que a mídia será ampliada para se ajustar dentro da área do definido pelo parâmetro do retângulo. Se o retângulo e mídia têm proporções diferentes, distorção irá ocorrer. Para obter mais controle sobre como a mídia é usada para preencher uma área, use o <xref:System.Windows.Media.DrawingContext.DrawRectangle%2A> comando para desenhar um retângulo e preenchê-lo com um <xref:System.Windows.Media.VisualBrush> que contém a mídia.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.MediaPermission">Para exibir a mídia que você não tem <see cref="T:System.Net.WebPermission" /> ou <see cref="T:System.Security.Permissions.FileIOPermission" /> acessar para. Enumeração associada: <see cref="F:System.Security.Permissions.MediaPermissionImage.SafeImage" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="DrawVideo">
      <MemberSignature Language="C#" Value="public abstract void DrawVideo (System.Windows.Media.MediaPlayer player, System.Windows.Rect rectangle, System.Windows.Media.Animation.AnimationClock rectangleAnimations);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void DrawVideo(class System.Windows.Media.MediaPlayer player, valuetype System.Windows.Rect rectangle, class System.Windows.Media.Animation.AnimationClock rectangleAnimations) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.DrawingContext.DrawVideo(System.Windows.Media.MediaPlayer,System.Windows.Rect,System.Windows.Media.Animation.AnimationClock)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Sub DrawVideo (player As MediaPlayer, rectangle As Rect, rectangleAnimations As AnimationClock)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract void DrawVideo(System::Windows::Media::MediaPlayer ^ player, System::Windows::Rect rectangle, System::Windows::Media::Animation::AnimationClock ^ rectangleAnimations);" />
      <MemberSignature Language="F#" Value="abstract member DrawVideo : System.Windows.Media.MediaPlayer * System.Windows.Rect * System.Windows.Media.Animation.AnimationClock -&gt; unit" Usage="drawingContext.DrawVideo (player, rectangle, rectangleAnimations)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="player" Type="System.Windows.Media.MediaPlayer" />
        <Parameter Name="rectangle" Type="System.Windows.Rect" />
        <Parameter Name="rectangleAnimations" Type="System.Windows.Media.Animation.AnimationClock" />
      </Parameters>
      <Docs>
        <param name="player">A mídia para desenhar.</param>
        <param name="rectangle">A área em que desenhar a mídia.</param>
        <param name="rectangleAnimations">O relógio com o qual o tamanho e as dimensões do retângulo são animados ou <see langword="null" /> para nenhuma animação. Esse relógio deve ser criado com base em um <see cref="T:System.Windows.Media.Animation.AnimationTimeline" /> que pode animar objetos <see cref="T:System.Windows.Rect" />.</param>
        <summary>Desenha um vídeo na região especificada e aplica o relógio de animação especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Observe que a mídia será ampliada para se ajustar dentro da área do definido pelo parâmetro do retângulo. Se o retângulo e mídia têm proporções diferentes, distorção irá ocorrer. Para obter mais controle sobre como a mídia é usada para preencher uma área, use o <xref:System.Windows.Media.DrawingContext.DrawRectangle%2A> comando para desenhar um retângulo e preenchê-lo com um <xref:System.Windows.Media.VisualBrush> que contém a mídia.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.MediaPermission">Para exibir a mídia que você não tem <see cref="T:System.Net.WebPermission" /> ou <see cref="T:System.Security.Permissions.FileIOPermission" /> acessar para. Enumeração associada: <see cref="F:System.Security.Permissions.MediaPermissionImage.SafeImage" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="Pop">
      <MemberSignature Language="C#" Value="public abstract void Pop ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Pop() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.DrawingContext.Pop" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Sub Pop ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract void Pop();" />
      <MemberSignature Language="F#" Value="abstract member Pop : unit -&gt; unit" Usage="drawingContext.Pop " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Exibe a última operação de máscara de opacidade, opacidade, recortar, efeito ou transformação que foi enviada por push no contexto de desenho.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Depois que uma operação é exibida, ela não for mais aplicada para comandos de desenho subsequentes.  
  
   
  
## Examples  
 O exemplo a seguir mostra o efeito do <xref:System.Windows.Media.DrawingContext.Pop%2A> comando.  
  
 [!code-csharp[DrawingContext_procedural_snip#PopExampleWholePage](~/samples/snippets/csharp/VS_Snippets_Wpf/DrawingContext_procedural_snip/CSharp/PopExample.cs#popexamplewholepage)]
 [!code-vb[DrawingContext_procedural_snip#PopExampleWholePage](~/samples/snippets/visualbasic/VS_Snippets_Wpf/DrawingContext_procedural_snip/visualbasic/popexample.vb#popexamplewholepage)]  
  
 A ilustração a seguir mostra a saída desse exemplo:  
  
 ![Retângulos desenhados com diferentes valores de opacidade](~/add/media/graphicsmm-drawingcontextpopexample.gif "retângulos desenhados com diferentes valores de opacidade")  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PushClip">
      <MemberSignature Language="C#" Value="public abstract void PushClip (System.Windows.Media.Geometry clipGeometry);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void PushClip(class System.Windows.Media.Geometry clipGeometry) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.DrawingContext.PushClip(System.Windows.Media.Geometry)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Sub PushClip (clipGeometry As Geometry)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract void PushClip(System::Windows::Media::Geometry ^ clipGeometry);" />
      <MemberSignature Language="F#" Value="abstract member PushClip : System.Windows.Media.Geometry -&gt; unit" Usage="drawingContext.PushClip clipGeometry" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="clipGeometry" Type="System.Windows.Media.Geometry" />
      </Parameters>
      <Docs>
        <param name="clipGeometry">A região de corte a ser aplicada aos comandos de desenho subsequentes.</param>
        <summary>Envia a região de corte especificada no contexto do desenho.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A região de corte se aplica a todos os comandos de desenho subsequentes até que ele seja removido pelo <xref:System.Windows.Media.DrawingContext.Pop%2A> comando.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PushEffect">
      <MemberSignature Language="C#" Value="public abstract void PushEffect (System.Windows.Media.Effects.BitmapEffect effect, System.Windows.Media.Effects.BitmapEffectInput effectInput);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void PushEffect(class System.Windows.Media.Effects.BitmapEffect effect, class System.Windows.Media.Effects.BitmapEffectInput effectInput) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.DrawingContext.PushEffect(System.Windows.Media.Effects.BitmapEffect,System.Windows.Media.Effects.BitmapEffectInput)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Sub PushEffect (effect As BitmapEffect, effectInput As BitmapEffectInput)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract void PushEffect(System::Windows::Media::Effects::BitmapEffect ^ effect, System::Windows::Media::Effects::BitmapEffectInput ^ effectInput);" />
      <MemberSignature Language="F#" Value="abstract member PushEffect : System.Windows.Media.Effects.BitmapEffect * System.Windows.Media.Effects.BitmapEffectInput -&gt; unit" Usage="drawingContext.PushEffect (effect, effectInput)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.Obsolete("BitmapEffects are deprecated and no longer function.  Consider using Effects where appropriate instead.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="effect" Type="System.Windows.Media.Effects.BitmapEffect" />
        <Parameter Name="effectInput" Type="System.Windows.Media.Effects.BitmapEffectInput" />
      </Parameters>
      <Docs>
        <param name="effect">O efeito a ser aplicado aos desenhos posteriores.</param>
        <param name="effectInput">A área à qual o efeito é aplicado ou <see langword="null" />, se o efeito deve ser aplicado a toda a área de desenhos posteriores.</param>
        <summary>Envia por push o <see cref="T:System.Windows.Media.Effects.BitmapEffect" /> especificado no contexto de desenho.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O efeito é aplicado a todas as operações de desenho subsequentes até que ele seja removido pelo <xref:System.Windows.Media.DrawingContext.Pop%2A> comando.  
  
   
  
## Examples  
 O exemplo a seguir demonstra a <xref:System.Windows.Media.DrawingContext.PushOpacity%2A>, <xref:System.Windows.Media.DrawingContext.PushEffect%2A>, e <xref:System.Windows.Media.DrawingContext.Pop%2A> comandos.  
  
 [!code-csharp[DrawingContext_procedural_snip#PushEffectExampleWholePage](~/samples/snippets/csharp/VS_Snippets_Wpf/DrawingContext_procedural_snip/CSharp/PushEffectExample.cs#pusheffectexamplewholepage)]
 [!code-vb[DrawingContext_procedural_snip#PushEffectExampleWholePage](~/samples/snippets/visualbasic/VS_Snippets_Wpf/DrawingContext_procedural_snip/visualbasic/pusheffectexample.vb#pusheffectexamplewholepage)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PushGuidelineSet">
      <MemberSignature Language="C#" Value="public abstract void PushGuidelineSet (System.Windows.Media.GuidelineSet guidelines);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void PushGuidelineSet(class System.Windows.Media.GuidelineSet guidelines) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.DrawingContext.PushGuidelineSet(System.Windows.Media.GuidelineSet)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Sub PushGuidelineSet (guidelines As GuidelineSet)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract void PushGuidelineSet(System::Windows::Media::GuidelineSet ^ guidelines);" />
      <MemberSignature Language="F#" Value="abstract member PushGuidelineSet : System.Windows.Media.GuidelineSet -&gt; unit" Usage="drawingContext.PushGuidelineSet guidelines" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="guidelines" Type="System.Windows.Media.GuidelineSet" />
      </Parameters>
      <Docs>
        <param name="guidelines">A definição de diretriz a ser aplicada aos comandos de desenho subsequentes.</param>
        <summary>Envia por push o <see cref="T:System.Windows.Media.GuidelineSet" /> especificado no contexto de desenho.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O conjunto de orientação se aplica a todos os comandos de desenho subsequentes até que ele seja removido pelo <xref:System.Windows.Media.DrawingContext.Pop%2A> operação.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Media.GuidelineSet" />
      </Docs>
    </Member>
    <MemberGroup MemberName="PushOpacity">
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Envia por push a configuração de opacidade especificada no contexto de desenho.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="PushOpacity">
      <MemberSignature Language="C#" Value="public abstract void PushOpacity (double opacity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void PushOpacity(float64 opacity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.DrawingContext.PushOpacity(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Sub PushOpacity (opacity As Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract void PushOpacity(double opacity);" />
      <MemberSignature Language="F#" Value="abstract member PushOpacity : double -&gt; unit" Usage="drawingContext.PushOpacity opacity" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="opacity" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="opacity">O fator de opacidade a ser aplicado aos comandos de desenho subsequentes. Esse fator é cumulativo com operações de <see cref="M:System.Windows.Media.DrawingContext.PushOpacity(System.Double)" /> anteriores.</param>
        <summary>Envia por push a configuração de opacidade especificada no contexto de desenho.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A opacidade é combinada em todos os comandos de desenho subsequentes até que ele seja removido pelo <xref:System.Windows.Media.DrawingContext.Pop%2A> comando.  
  
   
  
## Examples  
 O exemplo a seguir demonstra a <xref:System.Windows.Media.DrawingContext.PushOpacity%2A>, <xref:System.Windows.Media.DrawingContext.PushEffect%2A>, e <xref:System.Windows.Media.DrawingContext.Pop%2A> comandos.  
  
 [!code-csharp[DrawingContext_procedural_snip#PushEffectExampleWholePage](~/samples/snippets/csharp/VS_Snippets_Wpf/DrawingContext_procedural_snip/CSharp/PushEffectExample.cs#pusheffectexamplewholepage)]
 [!code-vb[DrawingContext_procedural_snip#PushEffectExampleWholePage](~/samples/snippets/visualbasic/VS_Snippets_Wpf/DrawingContext_procedural_snip/visualbasic/pusheffectexample.vb#pusheffectexamplewholepage)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PushOpacity">
      <MemberSignature Language="C#" Value="public abstract void PushOpacity (double opacity, System.Windows.Media.Animation.AnimationClock opacityAnimations);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void PushOpacity(float64 opacity, class System.Windows.Media.Animation.AnimationClock opacityAnimations) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.DrawingContext.PushOpacity(System.Double,System.Windows.Media.Animation.AnimationClock)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Sub PushOpacity (opacity As Double, opacityAnimations As AnimationClock)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract void PushOpacity(double opacity, System::Windows::Media::Animation::AnimationClock ^ opacityAnimations);" />
      <MemberSignature Language="F#" Value="abstract member PushOpacity : double * System.Windows.Media.Animation.AnimationClock -&gt; unit" Usage="drawingContext.PushOpacity (opacity, opacityAnimations)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="opacity" Type="System.Double" />
        <Parameter Name="opacityAnimations" Type="System.Windows.Media.Animation.AnimationClock" />
      </Parameters>
      <Docs>
        <param name="opacity">O fator de opacidade a ser aplicado aos comandos de desenho subsequentes. Esse fator é cumulativo com operações de <see cref="M:System.Windows.Media.DrawingContext.PushOpacity(System.Double)" /> anteriores.</param>
        <param name="opacityAnimations">O relógio com o qual o valor da opacidade é animado ou <see langword="null" /> para nenhuma animação. Esse relógio deve ser criado com base em um <see cref="T:System.Windows.Media.Animation.AnimationTimeline" /> que pode animar valores <see cref="T:System.Double" />.</param>
        <summary>Envia por push a configuração de opacidade especificada no contexto do desenho e aplica o relógio de animação especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A opacidade é combinada em todos os comandos de desenho subsequentes até que ele seja removido pelo <xref:System.Windows.Media.DrawingContext.Pop%2A> comando.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PushOpacityMask">
      <MemberSignature Language="C#" Value="public abstract void PushOpacityMask (System.Windows.Media.Brush opacityMask);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void PushOpacityMask(class System.Windows.Media.Brush opacityMask) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.DrawingContext.PushOpacityMask(System.Windows.Media.Brush)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Sub PushOpacityMask (opacityMask As Brush)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract void PushOpacityMask(System::Windows::Media::Brush ^ opacityMask);" />
      <MemberSignature Language="F#" Value="abstract member PushOpacityMask : System.Windows.Media.Brush -&gt; unit" Usage="drawingContext.PushOpacityMask opacityMask" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="opacityMask" Type="System.Windows.Media.Brush" />
      </Parameters>
      <Docs>
        <param name="opacityMask">A máscara de opacidade a ser aplicada aos desenhos posteriores. Os valores alfa desse pincel determinam a opacidade do desenho ao qual ela é aplicada.</param>
        <summary>Envia por push a máscara de opacidade especificada no contexto de desenho.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A máscara é aplicada a todos os comandos de desenho subsequentes até que ele seja removido pelo <xref:System.Windows.Media.DrawingContext.Pop%2A> operação.  
  
 Para obter mais informações sobre como criar máscaras de opacidade, consulte [visão geral de máscaras de opacidade](~/docs/framework/wpf/graphics-multimedia/opacity-masks-overview.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PushTransform">
      <MemberSignature Language="C#" Value="public abstract void PushTransform (System.Windows.Media.Transform transform);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void PushTransform(class System.Windows.Media.Transform transform) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.DrawingContext.PushTransform(System.Windows.Media.Transform)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract void PushTransform(System::Windows::Media::Transform ^ transform);" />
      <MemberSignature Language="F#" Value="abstract member PushTransform : System.Windows.Media.Transform -&gt; unit" Usage="drawingContext.PushTransform transform" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="transform" Type="System.Windows.Media.Transform" />
      </Parameters>
      <Docs>
        <param name="transform">A transformação a ser aplicada aos comandos de desenho subsequentes.</param>
        <summary>Envia por push o <see cref="T:System.Windows.Media.Transform" /> especificado no contexto de desenho.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A transformação se aplica a todos os comandos de desenho subsequentes até que ele seja removido pelo <xref:System.Windows.Media.DrawingContext.Pop%2A> comando.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IDisposable.Dispose">
      <MemberSignature Language="C#" Value="void IDisposable.Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.IDisposable.Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.DrawingContext.System#IDisposable#Dispose" />
      <MemberSignature Language="VB.NET" Value="Sub Dispose () Implements IDisposable.Dispose" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.IDisposable.Dispose() = IDisposable::Dispose;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Este membro dá suporte à infraestrutura [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)] e não se destina a ser usado diretamente do código.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="VerifyApiNonstructuralChange">
      <MemberSignature Language="C#" Value="protected virtual void VerifyApiNonstructuralChange ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void VerifyApiNonstructuralChange() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.DrawingContext.VerifyApiNonstructuralChange" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub VerifyApiNonstructuralChange ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void VerifyApiNonstructuralChange();" />
      <MemberSignature Language="F#" Value="abstract member VerifyApiNonstructuralChange : unit -&gt; unit&#xA;override this.VerifyApiNonstructuralChange : unit -&gt; unit" Usage="drawingContext.VerifyApiNonstructuralChange " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Este membro dá suporte à infraestrutura [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] e não se destina a ser usado diretamente do código.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>