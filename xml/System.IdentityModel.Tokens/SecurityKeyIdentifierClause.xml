<Type Name="SecurityKeyIdentifierClause" FullName="System.IdentityModel.Tokens.SecurityKeyIdentifierClause">
  <Metadata><Meta Name="ms.openlocfilehash" Value="fdcf2ef17267cab60cd0109b7fa289ae48330a46" /><Meta Name="ms.sourcegitcommit" Value="0ec122ee5f3681159b8460ab15b409fd6e3d3ae0" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="pt-BR" /><Meta Name="ms.lasthandoff" Value="10/04/2018" /><Meta Name="ms.locfileid" Value="48710229" /></Metadata><TypeSignature Language="C#" Value="public abstract class SecurityKeyIdentifierClause" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit SecurityKeyIdentifierClause extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.IdentityModel.Tokens.SecurityKeyIdentifierClause" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class SecurityKeyIdentifierClause" />
  <TypeSignature Language="C++ CLI" Value="public ref class SecurityKeyIdentifierClause abstract" />
  <TypeSignature Language="F#" Value="type SecurityKeyIdentifierClause = class" />
  <AssemblyInfo>
    <AssemblyName>System.IdentityModel</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Representa uma classe base abstrata para uma cláusula de identificador de chave.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Normalmente, o <xref:System.IdentityModel.Tokens.SecurityKeyIdentifierClause> não precisa ser usado, diferente de quando um serviço de token de segurança personalizada é criado. Quando um serviço de token de segurança retorna um token de segurança, o token de segurança emitido contém referências aos tokens de segurança anexados ou não. Referências associadas se referem aos tokens de segurança que estão contidos no cabeçalho de segurança de uma mensagem SOAP e referências desanexadas fazer referência a tokens de segurança que não estão incluídas no cabeçalho de segurança de uma mensagem SOAP. Normalmente, essas referências confirmar a autenticidade do token de segurança emitido.  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicializa uma nova instância da classe <see cref="T:System.IdentityModel.Tokens.SecurityKeyIdentifierClause" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected SecurityKeyIdentifierClause (string clauseType);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(string clauseType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Tokens.SecurityKeyIdentifierClause.#ctor(System.String)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New (clauseType As String)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; SecurityKeyIdentifierClause(System::String ^ clauseType);" />
      <MemberSignature Language="F#" Value="new System.IdentityModel.Tokens.SecurityKeyIdentifierClause : string -&gt; System.IdentityModel.Tokens.SecurityKeyIdentifierClause" Usage="new System.IdentityModel.Tokens.SecurityKeyIdentifierClause clauseType" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="clauseType" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="clauseType">O tipo de cláusula de identificador de chave. Define o valor da propriedade <see cref="P:System.IdentityModel.Tokens.SecurityKeyIdentifierClause.ClauseType" />.</param>
        <summary>Inicializa uma nova instância da classe <see cref="T:System.IdentityModel.Tokens.SecurityKeyIdentifierClause" /> usando o tipo de cláusula de identificador de chave especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando esse identificador de chave de segurança é serializada em XML, o `clauseType` parâmetro é serializado como o `ValueType` atributo do `<SecurityTokenReference>` elemento.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected SecurityKeyIdentifierClause (string clauseType, byte[] nonce, int length);" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(string clauseType, unsigned int8[] nonce, int32 length) cil managed" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New (clauseType As String, nonce As Byte(), length As Integer)" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; SecurityKeyIdentifierClause(System::String ^ clauseType, cli::array &lt;System::Byte&gt; ^ nonce, int length);" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8" />
      <MemberSignature Language="C#" Value="protected SecurityKeyIdentifierClause (string clauseType, byte[] derivationNonce, int derivationLength);" FrameworkAlternate="xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(string clauseType, unsigned int8[] derivationNonce, int32 derivationLength) cil managed" FrameworkAlternate="xamarinmac-3.0" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Tokens.SecurityKeyIdentifierClause.#ctor(System.String,System.Byte[],System.Int32)" FrameworkAlternate="xamarinmac-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New (clauseType As String, derivationNonce As Byte(), derivationLength As Integer)" FrameworkAlternate="xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; SecurityKeyIdentifierClause(System::String ^ clauseType, cli::array &lt;System::Byte&gt; ^ derivationNonce, int derivationLength);" FrameworkAlternate="xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="new System.IdentityModel.Tokens.SecurityKeyIdentifierClause : string * byte[] * int -&gt; System.IdentityModel.Tokens.SecurityKeyIdentifierClause" Usage="new System.IdentityModel.Tokens.SecurityKeyIdentifierClause (clauseType, derivationNonce, derivationLength)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="clauseType" Type="System.String" Index="0" />
        <Parameter Name="nonce" Type="System.Byte[]" Index="1" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8" />
        <Parameter Name="derivationNonce" Type="System.Byte[]" Index="1" FrameworkAlternate="xamarinmac-3.0" />
        <Parameter Name="length" Type="System.Int32" Index="2" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8" />
        <Parameter Name="derivationLength" Type="System.Int32" Index="2" FrameworkAlternate="xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="clauseType">O tipo de cláusula de identificador de chave. Define o valor da propriedade <see cref="P:System.IdentityModel.Tokens.SecurityKeyIdentifierClause.ClauseType" />.</param>
        <param name="nonce">Uma matriz de <see cref="T:System.Byte" /> que contém o nonce que foi usado para criar uma chave derivada. Define o valor retornado pelo método <see cref="M:System.IdentityModel.Tokens.SecurityKeyIdentifierClause.GetDerivationNonce" />.</param>
        <param name="derivationNonce">Uma matriz de <see cref="T:System.Byte" /> que contém o nonce que foi usado para criar uma chave derivada. Define o valor retornado pelo método <see cref="M:System.IdentityModel.Tokens.SecurityKeyIdentifierClause.GetDerivationNonce" />.</param>
        <param name="length">O tamanho da chave derivada. Define o valor da propriedade <see cref="P:System.IdentityModel.Tokens.SecurityKeyIdentifierClause.DerivationLength" />.</param>
        <param name="derivationLength">O tamanho da chave derivada. Define o valor da propriedade <see cref="P:System.IdentityModel.Tokens.SecurityKeyIdentifierClause.DerivationLength" />.</param>
        <summary>Inicializa uma nova instância da classe <see cref="T:System.IdentityModel.Tokens.SecurityKeyIdentifierClause" /> usando o tipo de cláusula de identificador de chave, o nonce e o comprimento de chave derivada especificados.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Windows Communication Foundation (WCF) não suporta a criação de identificadores de chave derivadas implícitas. No entanto, o WCF processa mensagens SOAP de entrada que contêm o identificador de chave implícito.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CanCreateKey">
      <MemberSignature Language="C#" Value="public virtual bool CanCreateKey { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanCreateKey" />
      <MemberSignature Language="DocId" Value="P:System.IdentityModel.Tokens.SecurityKeyIdentifierClause.CanCreateKey" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property CanCreateKey As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool CanCreateKey { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanCreateKey : bool" Usage="System.IdentityModel.Tokens.SecurityKeyIdentifierClause.CanCreateKey" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém um valor que indica se uma chave pode ser criada.</summary>
        <value><see langword="true" /> Se uma chave pode ser criada; Caso contrário, <see langword="false" />. O padrão é <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando uma chave pode ser criada usando os parâmetros passados para um construtor, substituir os <xref:System.IdentityModel.Tokens.SecurityKeyIdentifierClause.CanCreateKey%2A> método para retornar `true` e implementar o <xref:System.IdentityModel.Tokens.SecurityKeyIdentifierClause.CreateKey%2A> método.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ClauseType">
      <MemberSignature Language="C#" Value="public string ClauseType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ClauseType" />
      <MemberSignature Language="DocId" Value="P:System.IdentityModel.Tokens.SecurityKeyIdentifierClause.ClauseType" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ClauseType As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ ClauseType { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ClauseType : string" Usage="System.IdentityModel.Tokens.SecurityKeyIdentifierClause.ClauseType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém o tipo de cláusula do identificador de chave.</summary>
        <value>O tipo de cláusula de identificador de chave.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateKey">
      <MemberSignature Language="C#" Value="public virtual System.IdentityModel.Tokens.SecurityKey CreateKey ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IdentityModel.Tokens.SecurityKey CreateKey() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Tokens.SecurityKeyIdentifierClause.CreateKey" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function CreateKey () As SecurityKey" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IdentityModel::Tokens::SecurityKey ^ CreateKey();" />
      <MemberSignature Language="F#" Value="abstract member CreateKey : unit -&gt; System.IdentityModel.Tokens.SecurityKey&#xA;override this.CreateKey : unit -&gt; System.IdentityModel.Tokens.SecurityKey" Usage="securityKeyIdentifierClause.CreateKey " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IdentityModel.Tokens.SecurityKey</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Cria uma chave com base nos parâmetros passados para o construtor.</summary>
        <returns>Um <see cref="T:System.IdentityModel.Tokens.SecurityKey" /> que contém a chave criada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando uma chave pode ser criada usando os parâmetros passados para um construtor, substituir os <xref:System.IdentityModel.Tokens.SecurityKeyIdentifierClause.CanCreateKey%2A> método para retornar `true` e implementar o <xref:System.IdentityModel.Tokens.SecurityKeyIdentifierClause.CreateKey%2A> método.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DerivationLength">
      <MemberSignature Language="C#" Value="public int DerivationLength { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 DerivationLength" />
      <MemberSignature Language="DocId" Value="P:System.IdentityModel.Tokens.SecurityKeyIdentifierClause.DerivationLength" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DerivationLength As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int DerivationLength { int get(); };" />
      <MemberSignature Language="F#" Value="member this.DerivationLength : int" Usage="System.IdentityModel.Tokens.SecurityKeyIdentifierClause.DerivationLength" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém o tamanho da chave derivada.</summary>
        <value>O tamanho da chave derivada.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Windows Communication Foundation (WCF) não suporta a criação de identificadores de chave derivadas implícitas. No entanto, o WCF processa mensagens SOAP de entrada que contêm o identificador de chave implícito.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetDerivationNonce">
      <MemberSignature Language="C#" Value="public byte[] GetDerivationNonce ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance unsigned int8[] GetDerivationNonce() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Tokens.SecurityKeyIdentifierClause.GetDerivationNonce" />
      <MemberSignature Language="VB.NET" Value="Public Function GetDerivationNonce () As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Byte&gt; ^ GetDerivationNonce();" />
      <MemberSignature Language="F#" Value="member this.GetDerivationNonce : unit -&gt; byte[]" Usage="securityKeyIdentifierClause.GetDerivationNonce " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Obtém o nonce que foi usado para gerar a chave derivada.</summary>
        <returns>Uma matriz de <see cref="T:System.Byte" /> que contém o nonce que foi usado para gerar a chave derivada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Windows Communication Foundation (WCF) não suporta a criação de identificadores de chave derivadas implícitas. No entanto, o WCF processa mensagens SOAP de entrada que contêm o identificador de chave implícito.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Id">
      <MemberSignature Language="C#" Value="public string Id { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Id" />
      <MemberSignature Language="DocId" Value="P:System.IdentityModel.Tokens.SecurityKeyIdentifierClause.Id" />
      <MemberSignature Language="VB.NET" Value="Public Property Id As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Id { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Id : string with get, set" Usage="System.IdentityModel.Tokens.SecurityKeyIdentifierClause.Id" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define a ID da cláusula do identificador de chave.</summary>
        <value>A ID da cláusula de identificador de chave. O padrão é <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando esse identificador de chave de segurança é serializada em XML, o <xref:System.IdentityModel.Tokens.SecurityKeyIdentifierClause.Id%2A> propriedade é serializada como o `Id` atributo do `<SecurityTokenReference>` elemento. Se a propriedade estiver `null`, uma `Id` atributo não está incluído no `<SecurityTokenReference>` elemento.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Matches">
      <MemberSignature Language="C#" Value="public virtual bool Matches (System.IdentityModel.Tokens.SecurityKeyIdentifierClause keyIdentifierClause);" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Matches(class System.IdentityModel.Tokens.SecurityKeyIdentifierClause keyIdentifierClause) cil managed" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Matches (keyIdentifierClause As SecurityKeyIdentifierClause) As Boolean" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Matches(System::IdentityModel::Tokens::SecurityKeyIdentifierClause ^ keyIdentifierClause);" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8" />
      <MemberSignature Language="C#" Value="public virtual bool Matches (System.IdentityModel.Tokens.SecurityKeyIdentifierClause clause);" FrameworkAlternate="xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Matches(class System.IdentityModel.Tokens.SecurityKeyIdentifierClause clause) cil managed" FrameworkAlternate="xamarinmac-3.0" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Tokens.SecurityKeyIdentifierClause.Matches(System.IdentityModel.Tokens.SecurityKeyIdentifierClause)" FrameworkAlternate="xamarinmac-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Matches (clause As SecurityKeyIdentifierClause) As Boolean" FrameworkAlternate="xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Matches(System::IdentityModel::Tokens::SecurityKeyIdentifierClause ^ clause);" FrameworkAlternate="xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="abstract member Matches : System.IdentityModel.Tokens.SecurityKeyIdentifierClause -&gt; bool&#xA;override this.Matches : System.IdentityModel.Tokens.SecurityKeyIdentifierClause -&gt; bool" Usage="securityKeyIdentifierClause.Matches clause" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="keyIdentifierClause" Type="System.IdentityModel.Tokens.SecurityKeyIdentifierClause" Index="0" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8" />
        <Parameter Name="clause" Type="System.IdentityModel.Tokens.SecurityKeyIdentifierClause" Index="0" FrameworkAlternate="xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="keyIdentifierClause">Um <see cref="T:System.IdentityModel.Tokens.SecurityKeyIdentifierClause" /> ao qual comparar.</param>
        <param name="clause">Um <see cref="T:System.IdentityModel.Tokens.SecurityKeyIdentifierClause" /> ao qual comparar.</param>
        <summary>Retorna um valor que indica se o identificador de chave para esta instância é equivalente à cláusula de identificador de chave especificada.</summary>
        <returns><see langword="true" /> se <paramref name="keyIdentifierClause" /> é a mesma instância que a instância atual; caso contrário, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="keyIdentifierClause" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
  </Members>
</Type>