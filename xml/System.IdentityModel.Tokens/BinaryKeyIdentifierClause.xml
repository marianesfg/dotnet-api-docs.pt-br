<Type Name="BinaryKeyIdentifierClause" FullName="System.IdentityModel.Tokens.BinaryKeyIdentifierClause">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="06f770f565b50995ba94cfe36d2d174e48dfd7f6" />
    <Meta Name="ms.sourcegitcommit" Value="65fc8d8b5a6c6a18be3191c2944c7fcc43f38fa6" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="pt-BR" />
    <Meta Name="ms.lasthandoff" Value="07/18/2018" />
    <Meta Name="ms.locfileid" Value="39119037" />
  </Metadata>
  <TypeSignature Language="C#" Value="public abstract class BinaryKeyIdentifierClause : System.IdentityModel.Tokens.SecurityKeyIdentifierClause" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit BinaryKeyIdentifierClause extends System.IdentityModel.Tokens.SecurityKeyIdentifierClause" />
  <TypeSignature Language="DocId" Value="T:System.IdentityModel.Tokens.BinaryKeyIdentifierClause" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class BinaryKeyIdentifierClause&#xA;Inherits SecurityKeyIdentifierClause" />
  <TypeSignature Language="C++ CLI" Value="public ref class BinaryKeyIdentifierClause abstract : System::IdentityModel::Tokens::SecurityKeyIdentifierClause" />
  <TypeSignature Language="F#" Value="type BinaryKeyIdentifierClause = class&#xA;    inherit SecurityKeyIdentifierClause" />
  <AssemblyInfo>
    <AssemblyName>System.IdentityModel</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.IdentityModel.Tokens.SecurityKeyIdentifierClause</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Representa uma classe base para cláusulas de identificador de chave baseadas em dados binários.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Normalmente, o <xref:System.IdentityModel.Tokens.BinaryKeyIdentifierClause> não precisa ser usado, diferente de quando um serviço de token de segurança personalizada é criado. Quando um serviço de token de segurança retorna um token de segurança, o token de segurança emitido contém referências aos tokens de segurança anexados ou não. Referências associadas se referem aos tokens de segurança que estão contidos no cabeçalho de segurança de uma mensagem SOAP e referências desconectadas são tokens de segurança que não estão incluídas no cabeçalho de segurança da mensagem SOAP. Normalmente, essas referências confirmar a autenticidade do token de segurança emitido.  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicializa uma nova instância da classe <see cref="T:System.IdentityModel.Tokens.BinaryKeyIdentifierClause" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected BinaryKeyIdentifierClause (string clauseType, byte[] identificationData, bool cloneBuffer);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(string clauseType, unsigned int8[] identificationData, bool cloneBuffer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Tokens.BinaryKeyIdentifierClause.#ctor(System.String,System.Byte[],System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New (clauseType As String, identificationData As Byte(), cloneBuffer As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; BinaryKeyIdentifierClause(System::String ^ clauseType, cli::array &lt;System::Byte&gt; ^ identificationData, bool cloneBuffer);" />
      <MemberSignature Language="F#" Value="new System.IdentityModel.Tokens.BinaryKeyIdentifierClause : string * byte[] * bool -&gt; System.IdentityModel.Tokens.BinaryKeyIdentifierClause" Usage="new System.IdentityModel.Tokens.BinaryKeyIdentifierClause (clauseType, identificationData, cloneBuffer)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="clauseType" Type="System.String" />
        <Parameter Name="identificationData" Type="System.Byte[]" />
        <Parameter Name="cloneBuffer" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="clauseType">O tipo de cláusula de identificador de chave. Define o valor da propriedade <see cref="P:System.IdentityModel.Tokens.SecurityKeyIdentifierClause.ClauseType" />.</param>
        <param name="identificationData">Uma matriz de <see cref="T:System.Byte" /> que contém os dados binários que representam o identificador de chave.</param>
        <param name="cloneBuffer">
          <see langword="true" /> para clonar a matriz passada para o parâmetro <c>identificationData</c>; caso contrário, <see langword="false" />.</param>
        <summary>Inicializa uma nova instância da classe <see cref="T:System.IdentityModel.Tokens.BinaryKeyIdentifierClause" /> usando o tipo de cláusula de identificador de chave especificado, dados binários e um valor que indica se os dados binários devem ser clonados.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="identificationData" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="identificationData" /> tem tamanho zero.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected BinaryKeyIdentifierClause (string clauseType, byte[] identificationData, bool cloneBuffer, byte[] derivationNonce, int derivationLength);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(string clauseType, unsigned int8[] identificationData, bool cloneBuffer, unsigned int8[] derivationNonce, int32 derivationLength) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Tokens.BinaryKeyIdentifierClause.#ctor(System.String,System.Byte[],System.Boolean,System.Byte[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New (clauseType As String, identificationData As Byte(), cloneBuffer As Boolean, derivationNonce As Byte(), derivationLength As Integer)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; BinaryKeyIdentifierClause(System::String ^ clauseType, cli::array &lt;System::Byte&gt; ^ identificationData, bool cloneBuffer, cli::array &lt;System::Byte&gt; ^ derivationNonce, int derivationLength);" />
      <MemberSignature Language="F#" Value="new System.IdentityModel.Tokens.BinaryKeyIdentifierClause : string * byte[] * bool * byte[] * int -&gt; System.IdentityModel.Tokens.BinaryKeyIdentifierClause" Usage="new System.IdentityModel.Tokens.BinaryKeyIdentifierClause (clauseType, identificationData, cloneBuffer, derivationNonce, derivationLength)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="clauseType" Type="System.String" />
        <Parameter Name="identificationData" Type="System.Byte[]" />
        <Parameter Name="cloneBuffer" Type="System.Boolean" />
        <Parameter Name="derivationNonce" Type="System.Byte[]" />
        <Parameter Name="derivationLength" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="clauseType">O tipo de cláusula de identificador de chave. Define o valor da propriedade <see cref="P:System.IdentityModel.Tokens.SecurityKeyIdentifierClause.ClauseType" />.</param>
        <param name="identificationData">Uma matriz de <see cref="T:System.Byte" /> que contém os dados binários que representam o identificador de chave. Define os dados binários retornados pelo método <see cref="M:System.IdentityModel.Tokens.BinaryKeyIdentifierClause.GetBuffer" />.</param>
        <param name="cloneBuffer">
          <see langword="true" /> para clonar a matriz passada para o parâmetro <c>identificationData</c>; caso contrário, <see langword="false" />.</param>
        <param name="derivationNonce">Uma matriz de <see cref="T:System.Byte" /> que contém o nonce que foi usado para criar uma chave derivada. Define o valor retornado pelo método <see cref="M:System.IdentityModel.Tokens.SecurityKeyIdentifierClause.GetDerivationNonce" />.</param>
        <param name="derivationLength">O tamanho da chave derivada. Define o valor da propriedade <see cref="P:System.IdentityModel.Tokens.SecurityKeyIdentifierClause.DerivationLength" />.</param>
        <summary>Inicializa uma nova instância da classe <see cref="T:System.IdentityModel.Tokens.BinaryKeyIdentifierClause" /> usando o tipo de cláusula de identificador de chave especificado, dados binários, um valor que indica se os dados binários devem ser clonados, um nonce e o comprimento da chave.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando o `derivationNonce` e `derivationLength` são especificados, a chave derivada implícita é usada em vez da chave de segurança direto do token.  
  
 Independentemente do valor passado para o `cloneBuffer` parâmetro, o <xref:System.IdentityModel.Tokens.BinaryKeyIdentifierClause.GetBuffer%2A> método sempre retorna um clone da matriz passado para o `identificationData` parâmetro.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="identificationData" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="identificationData" /> tem tamanho zero.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetBuffer">
      <MemberSignature Language="C#" Value="public byte[] GetBuffer ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance unsigned int8[] GetBuffer() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Tokens.BinaryKeyIdentifierClause.GetBuffer" />
      <MemberSignature Language="VB.NET" Value="Public Function GetBuffer () As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Byte&gt; ^ GetBuffer();" />
      <MemberSignature Language="F#" Value="member this.GetBuffer : unit -&gt; byte[]" Usage="binaryKeyIdentifierClause.GetBuffer " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Obtém os dados binários que representam o identificador de chave.</summary>
        <returns>Uma matriz de <see cref="T:System.Byte" /> que contém os dados binários que representam o identificador de chave.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Independentemente do valor passado para o construtor `cloneBuffer` parâmetro, o <xref:System.IdentityModel.Tokens.BinaryKeyIdentifierClause.GetBuffer%2A> método sempre retorna um clone da matriz passado para o construtor `identificationData` parâmetro.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.IdentityModel.Tokens.BinaryKeyIdentifierClause.GetRawBuffer" />
      </Docs>
    </Member>
    <Member MemberName="GetRawBuffer">
      <MemberSignature Language="C#" Value="protected byte[] GetRawBuffer ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance unsigned int8[] GetRawBuffer() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Tokens.BinaryKeyIdentifierClause.GetRawBuffer" />
      <MemberSignature Language="VB.NET" Value="Protected Function GetRawBuffer () As Byte()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; cli::array &lt;System::Byte&gt; ^ GetRawBuffer();" />
      <MemberSignature Language="F#" Value="member this.GetRawBuffer : unit -&gt; byte[]" Usage="binaryKeyIdentifierClause.GetRawBuffer " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Obtém os dados binários que representam o identificador de chave.</summary>
        <returns>Uma matriz de <see cref="T:System.Byte" /> que contém os dados binários que representam o identificador de chave.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A matriz retornada pela <xref:System.IdentityModel.Tokens.BinaryKeyIdentifierClause.GetRawBuffer%2A> método é um clone do construtor `identificationData` parâmetro quando o valor passado para o `cloneBuffer` é `true`; caso contrário, será a mesma matriz.  
  
 O <xref:System.IdentityModel.Tokens.BinaryKeyIdentifierClause.GetBuffer%2A> método sempre retorna um clone da matriz passado para o construtor `identificationData` parâmetro.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.IdentityModel.Tokens.BinaryKeyIdentifierClause.GetBuffer" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Matches">
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Retorna um valor que indica se o identificador de chave desta instância corresponde ao objeto especificado.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Matches">
      <MemberSignature Language="C#" Value="public bool Matches (byte[] data);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Matches(unsigned int8[] data) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Tokens.BinaryKeyIdentifierClause.Matches(System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Function Matches (data As Byte()) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Matches(cli::array &lt;System::Byte&gt; ^ data);" />
      <MemberSignature Language="F#" Value="override this.Matches : byte[] -&gt; bool" Usage="binaryKeyIdentifierClause.Matches data" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="data">Uma matriz de <see cref="T:System.Byte" /> com a qual comparar.</param>
        <summary>Retorna um valor que indica se os dados binários da instância atual corresponde aos dados binários especificados.</summary>
        <returns>
          <see langword="true" /> se <paramref name="data" /> for equivalente aos dados binários retornados pelo método <see cref="M:System.IdentityModel.Tokens.BinaryKeyIdentifierClause.GetBuffer" />; caso contrário, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Matches">
      <MemberSignature Language="C#" Value="public bool Matches (byte[] data, int offset);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Matches(unsigned int8[] data, int32 offset) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Tokens.BinaryKeyIdentifierClause.Matches(System.Byte[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Matches (data As Byte(), offset As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Matches(cli::array &lt;System::Byte&gt; ^ data, int offset);" />
      <MemberSignature Language="F#" Value="override this.Matches : byte[] * int -&gt; bool" Usage="binaryKeyIdentifierClause.Matches (data, offset)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="data">Uma matriz de <see cref="T:System.Byte" /> com a qual comparar.</param>
        <param name="offset">O índice na matriz no qual a comparação é iniciada.</param>
        <summary>Retorna um valor que indica se os dados binários da instância atual são equivalentes aos dados binários especificados no deslocamento especificado.</summary>
        <returns>
          <see langword="true" /> se os dados binários no parâmetro <paramref name="data" /> começando no índice especificado no parâmetro <paramref name="offset" /> forem equivalentes aos dados binários retornados pelo método <see cref="M:System.IdentityModel.Tokens.BinaryKeyIdentifierClause.GetBuffer" /> (a partir do índice zero); caso contrário, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Matches">
      <MemberSignature Language="C#" Value="public override bool Matches (System.IdentityModel.Tokens.SecurityKeyIdentifierClause keyIdentifierClause);" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-3.0;netframework-3.5;netframework-4.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Matches(class System.IdentityModel.Tokens.SecurityKeyIdentifierClause keyIdentifierClause) cil managed" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-3.0;netframework-3.5;netframework-4.0" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Matches (keyIdentifierClause As SecurityKeyIdentifierClause) As Boolean" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-3.0;netframework-3.5;netframework-4.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Matches(System::IdentityModel::Tokens::SecurityKeyIdentifierClause ^ keyIdentifierClause);" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-3.0;netframework-3.5;netframework-4.0" />
      <MemberSignature Language="C#" Value="public override bool Matches (System.IdentityModel.Tokens.SecurityKeyIdentifierClause clause);" FrameworkAlternate="xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Matches(class System.IdentityModel.Tokens.SecurityKeyIdentifierClause clause) cil managed" FrameworkAlternate="xamarinmac-3.0" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Tokens.BinaryKeyIdentifierClause.Matches(System.IdentityModel.Tokens.SecurityKeyIdentifierClause)" FrameworkAlternate="xamarinmac-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-3.0;netframework-3.5;netframework-4.0" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Matches (clause As SecurityKeyIdentifierClause) As Boolean" FrameworkAlternate="xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Matches(System::IdentityModel::Tokens::SecurityKeyIdentifierClause ^ clause);" FrameworkAlternate="xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="override this.Matches : System.IdentityModel.Tokens.SecurityKeyIdentifierClause -&gt; bool" Usage="binaryKeyIdentifierClause.Matches clause" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="keyIdentifierClause" Type="System.IdentityModel.Tokens.SecurityKeyIdentifierClause" Index="0" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-3.0;netframework-3.5;netframework-4.0" />
        <Parameter Name="clause" Type="System.IdentityModel.Tokens.SecurityKeyIdentifierClause" Index="0" FrameworkAlternate="xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="keyIdentifierClause">Um <see cref="T:System.IdentityModel.Tokens.SecurityKeyIdentifierClause" /> ao qual comparar.</param>
        <param name="clause">Um <see cref="T:System.IdentityModel.Tokens.SecurityKeyIdentifierClause" /> ao qual comparar.</param>
        <summary>Retorna um valor que indica se o identificador de chave para esta instância é equivalente à cláusula de identificador de chave especificada.</summary>
        <returns>
          <see langword="true" /> se <paramref name="keyIdentifierClause" /> for do tipo <see cref="T:System.IdentityModel.Tokens.BinaryKeyIdentifierClause" /> e os dados binários retornados pelo método <see cref="M:System.IdentityModel.Tokens.BinaryKeyIdentifierClause.GetBuffer" /> forem idênticos ao parâmetro <paramref name="keyIdentifierClause" /> e à instância atual; caso contrário, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>