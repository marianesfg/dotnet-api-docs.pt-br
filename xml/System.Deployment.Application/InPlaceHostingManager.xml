<Type Name="InPlaceHostingManager" FullName="System.Deployment.Application.InPlaceHostingManager">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="318b3adb922726e41d39a80b9e59598efbc9e92e" />
    <Meta Name="ms.sourcegitcommit" Value="4b4804968da1dfdf71c501075a5b66957b54f2e8" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="pt-BR" />
    <Meta Name="ms.lasthandoff" Value="04/27/2018" />
    <Meta Name="ms.locfileid" Value="32037164" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class InPlaceHostingManager : IDisposable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit InPlaceHostingManager extends System.Object implements class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.Deployment.Application.InPlaceHostingManager" />
  <TypeSignature Language="VB.NET" Value="Public Class InPlaceHostingManager&#xA;Implements IDisposable" />
  <TypeSignature Language="C++ CLI" Value="public ref class InPlaceHostingManager : IDisposable" />
  <AssemblyInfo>
    <AssemblyName>System.Deployment</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Instalar ou atualizar uma implantação do ClickOnce em um computador.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Você pode usar <xref:System.Deployment.Application.InPlaceHostingManager> gravar programas de instalação [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)] aplicativos por meio de programação. Por exemplo, você pode usar essa classe em um ambiente de software (SMS) de gerenciamento controlada do sistema ou em situações em que você precisa de uma instalação complexas que realiza uma série de operações de pré-instalação ou pós-instalação no computador local. Em geral, você deve usar os membros dessa classe em uma ordem específica:  
  
1.  Criar uma nova instância de <xref:System.Deployment.Application.InPlaceHostingManager>.  
  
2.  Baixe o manifesto de implantação usando <xref:System.Deployment.Application.InPlaceHostingManager.GetManifestAsync%2A>.  
  
3.  Verifique se o aplicativo pode ser executado com as permissões apropriadas usando <xref:System.Deployment.Application.InPlaceHostingManager.AssertApplicationRequirements%2A>.  
  
4.  Baixar e instalar o aplicativo usando <xref:System.Deployment.Application.InPlaceHostingManager.DownloadApplicationAsync%2A>.  
  
-   Se você chamar qualquer um desses parâmetros fora de ordem, eles lançará uma exceção.  
  
 <xref:System.Deployment.Application.InPlaceHostingManager> pode instalar um [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)] aplicativo, mas não é possível executá-lo. Alguns métodos na classe, como <xref:System.Deployment.Application.InPlaceHostingManager.Execute%2A>, são reservados para uso durante o download de um aplicativo baseado em Windows Presentation Foundation que é executado dentro de um navegador da Web.  
  
 Para usar <xref:System.Deployment.Application.InPlaceHostingManager> para baixar e instalar aplicativos, você deve garantir que o certificado para assinar o [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)] aplicativos você planeja instalar já está instalado nos computadores cliente como um editor confiável. Para obter mais informações sobre editores confiáveis, consulte [visão geral de implantação do aplicativo confiável](http://msdn.microsoft.com/library/b24a1702-8fbe-45b1-87a0-9618a0708f1d).  
  
> [!NOTE]
>  Atualmente, há uma limitação do produto que impede <xref:System.Deployment.Application.InPlaceHostingManager> funcionem corretamente ao depurar seu código usando o Visual Studio. Se você depurar seu aplicativo no Visual Studio usando a tecla F5, o exemplo lançarão exceções misteriosas ao chamar <xref:System.Deployment.Application.InPlaceHostingManager.DownloadApplicationAsync%2A>. Para depurar usando o Visual Studio, inicie o aplicativo sem depuração e, em seguida, anexar o depurador. Como alternativa, você pode usar outro depurador, como o WinDbg.  
  
   
  
## Examples  
 O exemplo de código a seguir mostra como usar <xref:System.Deployment.Application.InPlaceHostingManager> para instalar um [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)] aplicativo programaticamente em um computador cliente.  
  
 [!code-csharp[System.Deployment.Application.InPlaceHostingManager#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Deployment.Application.InPlaceHostingManager/CS/Form1.cs#1)]
 [!code-vb[System.Deployment.Application.InPlaceHostingManager#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Deployment.Application.InPlaceHostingManager/VB/Form1.vb#1)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Deployment</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Cria uma nova instância de <see cref="T:System.Deployment.Application.InPlaceHostingManager" /> para baixar e instalar o aplicativo especificado.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public InPlaceHostingManager (Uri deploymentManifest);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Uri deploymentManifest) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Deployment.Application.InPlaceHostingManager.#ctor(System.Uri)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (deploymentManifest As Uri)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; InPlaceHostingManager(Uri ^ deploymentManifest);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Deployment</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="deploymentManifest" Type="System.Uri" />
      </Parameters>
      <Docs>
        <param name="deploymentManifest">Um Uniform Resource Identifier (<see cref="T:System.Uri" />) para o manifesto de implantação de um aplicativo [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)].</param>
        <summary>Cria uma nova instância de <see cref="T:System.Deployment.Application.InPlaceHostingManager" /> para baixar e instalar o aplicativo hospedado pelo navegador especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este construtor é usado quando você deseja baixar um aplicativo baseado em Windows Presentation Foundation que é hospedado em um navegador da Web. Para baixar aplicativos baseados em Windows Forms que são implantados usando [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)], use o <xref:System.Deployment.Application.InPlaceHostingManager.%23ctor%2A> construtor com a `launchInHostProcess` parâmetro definido como `false`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">
          <see cref="T:System.Deployment.Application.InPlaceHostingManager" /> pode ser usado somente no Windows XP ou em versões posteriores do sistema operacional Windows.</exception>
        <exception cref="T:System.ArgumentNullException">Não é possível passar <see langword="null" /> para o argumento <paramref name="deploymentManifest" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="deploymentManifest" /> usa um esquema de URI sem suporte de [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)].</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public InPlaceHostingManager (Uri deploymentManifest, bool launchInHostProcess);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Uri deploymentManifest, bool launchInHostProcess) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Deployment.Application.InPlaceHostingManager.#ctor(System.Uri,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (deploymentManifest As Uri, launchInHostProcess As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; InPlaceHostingManager(Uri ^ deploymentManifest, bool launchInHostProcess);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Deployment</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="deploymentManifest" Type="System.Uri" />
        <Parameter Name="launchInHostProcess" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="deploymentManifest">O URI (Uniform Resource Identifier) do manifesto de implantação do aplicativo que será instalado.</param>
        <param name="launchInHostProcess">Se este aplicativo for executado em um host, como um navegador da Web. Para um aplicativo autônomo, defina esse valor como <see langword="false" />.</param>
        <summary>Cria uma nova instância de <see cref="T:System.Deployment.Application.InPlaceHostingManager" /> para baixar e instalar o aplicativo especificado, que pode ser um aplicativo autônomo baseado no Windows Forms ou um aplicativo hospedado em um navegador da Web.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O exemplo de código a seguir demonstra como criar uma instância de <xref:System.Deployment.Application.InPlaceHostingManager> que permite que você baixe os aplicativos baseados em Windows Forms implantados usando [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)].  
  
 [!code-csharp[System.Deployment.Application.InPlaceHostingManager#2](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Deployment.Application.InPlaceHostingManager/CS/Form1.cs#2)]
 [!code-vb[System.Deployment.Application.InPlaceHostingManager#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Deployment.Application.InPlaceHostingManager/VB/Form1.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">
          <see cref="T:System.Deployment.Application.InPlaceHostingManager" /> pode ser usado somente no Windows XP ou em versões posteriores do sistema operacional Windows.</exception>
        <exception cref="T:System.ArgumentNullException">Não é possível passar <see langword="null" /> para o argumento <paramref name="deploymentManifest" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="deploymentManifest" /> usa um esquema de URI sem suporte de [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)].</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="AssertApplicationRequirements">
      <AssemblyInfo>
        <AssemblyName>System.Deployment</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Determina se o aplicativo ClickOnce tem as permissões e dependências de plataforma adequadas para ser executado no computador local.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AssertApplicationRequirements">
      <MemberSignature Language="C#" Value="public void AssertApplicationRequirements ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AssertApplicationRequirements() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Deployment.Application.InPlaceHostingManager.AssertApplicationRequirements" />
      <MemberSignature Language="VB.NET" Value="Public Sub AssertApplicationRequirements ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AssertApplicationRequirements();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Deployment</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Determina se o aplicativo [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)] tem as permissões e dependências de plataforma adequadas para ser executado no computador local.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Você deve chamar <xref:System.Deployment.Application.InPlaceHostingManager.AssertApplicationRequirements%2A> depois <xref:System.Deployment.Application.InPlaceHostingManager.GetManifestAsync%2A> retorna com êxito. Você não deve chamar <xref:System.Deployment.Application.InPlaceHostingManager.DownloadApplicationAsync%2A> , a menos que você chame <xref:System.Deployment.Application.InPlaceHostingManager.AssertApplicationRequirements%2A>, e retorna sem erro.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra o uso de <xref:System.Deployment.Application.InPlaceHostingManager.AssertApplicationRequirements%2A>, que chama no corpo de um bem-sucedida <xref:System.Deployment.Application.InPlaceHostingManager.GetManifestCompleted> manipulador de eventos.  
  
 [!code-csharp[System.Deployment.Application.InPlaceHostingManager#3](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Deployment.Application.InPlaceHostingManager/CS/Form1.cs#3)]
 [!code-vb[System.Deployment.Application.InPlaceHostingManager#3](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Deployment.Application.InPlaceHostingManager/VB/Form1.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Gerado se este método for chamado antes do método <see cref="M:System.Deployment.Application.InPlaceHostingManager.GetManifestAsync" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="AssertApplicationRequirements">
      <MemberSignature Language="C#" Value="public void AssertApplicationRequirements (bool grantApplicationTrust);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AssertApplicationRequirements(bool grantApplicationTrust) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Deployment.Application.InPlaceHostingManager.AssertApplicationRequirements(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AssertApplicationRequirements (grantApplicationTrust As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AssertApplicationRequirements(bool grantApplicationTrust);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Deployment</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="grantApplicationTrust" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="grantApplicationTrust">Se <see langword="true" />, o aplicativo tentará elevar as permissões para o nível necessário.</param>
        <summary>Determina se o aplicativo [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)] tem as permissões e dependências de plataforma adequadas para ser executado no computador local.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se `grantApplicationTrust` é `true`, <xref:System.Deployment.Application.InPlaceHostingManager> concederá ao aplicativo permissões elevadas se necessário. Isso só é possível se <xref:System.Deployment.Application.InPlaceHostingManager> é capaz de conceder essas permissões. Por exemplo, se um [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)] aplicativo está sendo instalado como parte de um pacote maior e o instalador tenha confiança total, <xref:System.Deployment.Application.InPlaceHostingManager> poderá conceder o [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)] confiança total do aplicativo. Se `grantApplicationTrust` é `false`, o aplicativo não receberá nenhuma permissão.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CancelAsync">
      <MemberSignature Language="C#" Value="public void CancelAsync ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CancelAsync() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Deployment.Application.InPlaceHostingManager.CancelAsync" />
      <MemberSignature Language="VB.NET" Value="Public Sub CancelAsync ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CancelAsync();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Deployment</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Cancela uma operação de download assíncrona.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Deployment.Application.InPlaceHostingManager.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Deployment</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Libera todos os recursos usados pelo <see cref="T:System.Deployment.Application.InPlaceHostingManager" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Chamar <xref:System.Deployment.Application.InPlaceHostingManager.Dispose%2A> quando tiver terminado de usar o <xref:System.Deployment.Application.InPlaceHostingManager>. O <xref:System.Deployment.Application.InPlaceHostingManager.Dispose%2A> método deixa o <xref:System.Deployment.Application.InPlaceHostingManager> em um estado inutilizável. Depois de chamar <xref:System.Deployment.Application.InPlaceHostingManager.Dispose%2A>, você deve liberar todas as referências para o <xref:System.Deployment.Application.InPlaceHostingManager> para o coletor de lixo possa recuperar a memória que o <xref:System.Deployment.Application.InPlaceHostingManager> estava ocupando. Para obter mais informações, consulte [limpeza de recursos não gerenciados](~/docs/standard/garbage-collection/unmanaged.md) e [implementar um método Dispose](~/docs/standard/garbage-collection/implementing-dispose.md).  
  
> [!NOTE]
>  Sempre chamar <xref:System.Deployment.Application.InPlaceHostingManager.Dispose%2A> antes de liberar sua última referência para o <xref:System.Deployment.Application.InPlaceHostingManager>. Caso contrário, os recursos que está usando não serão liberados até que o coletor de lixo chame o <xref:System.Deployment.Application.InPlaceHostingManager> do objeto `Finalize` método.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DownloadApplicationAsync">
      <MemberSignature Language="C#" Value="public void DownloadApplicationAsync ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DownloadApplicationAsync() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Deployment.Application.InPlaceHostingManager.DownloadApplicationAsync" />
      <MemberSignature Language="VB.NET" Value="Public Sub DownloadApplicationAsync ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DownloadApplicationAsync();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Deployment</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Baixa uma atualização de aplicativo em segundo plano.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Você deve chamar este método depois de chamar <xref:System.Deployment.Application.InPlaceHostingManager.AssertApplicationRequirements%2A>.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra o uso de <xref:System.Deployment.Application.InPlaceHostingManager.DownloadApplicationAsync%2A>, que chama no final de um bem-sucedida <xref:System.Deployment.Application.InPlaceHostingManager.GetManifestCompleted> manipulador de eventos.  
  
 Os exemplos de código a seguir pressupõem que você já definiu e criou uma instância de <xref:System.Deployment.Application.InPlaceHostingManager> chamado `iphm`.  
  
 [!code-csharp[System.Deployment.Application.InPlaceHostingManager#3](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Deployment.Application.InPlaceHostingManager/CS/Form1.cs#3)]
 [!code-vb[System.Deployment.Application.InPlaceHostingManager#3](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Deployment.Application.InPlaceHostingManager/VB/Form1.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Acionado se este método for chamado antes dos métodos <see cref="M:System.Deployment.Application.InPlaceHostingManager.GetManifestAsync" /> e <see cref="M:System.Deployment.Application.InPlaceHostingManager.AssertApplicationRequirements" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="DownloadApplicationCompleted">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Deployment.Application.DownloadApplicationCompletedEventArgs&gt; DownloadApplicationCompleted;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Deployment.Application.DownloadApplicationCompletedEventArgs&gt; DownloadApplicationCompleted" />
      <MemberSignature Language="DocId" Value="E:System.Deployment.Application.InPlaceHostingManager.DownloadApplicationCompleted" />
      <MemberSignature Language="VB.NET" Value="Public Event DownloadApplicationCompleted As EventHandler(Of DownloadApplicationCompletedEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::Deployment::Application::DownloadApplicationCompletedEventArgs ^&gt; ^ DownloadApplicationCompleted;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Deployment</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Deployment.Application.DownloadApplicationCompletedEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ocorre quando o aplicativo termina de ser baixado no computador local.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se você estiver instalando um aplicativo baseado em formulários do Windows, você precisará instruir os usuários para iniciar o aplicativo em si; Você não pode iniciar aplicativos baseados em Windows Forms programaticamente usando o <xref:System.Deployment.Application.InPlaceHostingManager.Execute%2A> método.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra um manipulador para o <xref:System.Deployment.Application.InPlaceHostingManager.DownloadApplicationCompleted> evento.  
  
 [!code-csharp[System.Deployment.Application.InPlaceHostingManager#7](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Deployment.Application.InPlaceHostingManager/CS/Form1.cs#7)]
 [!code-vb[System.Deployment.Application.InPlaceHostingManager#7](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Deployment.Application.InPlaceHostingManager/VB/Form1.vb#7)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DownloadProgressChanged">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Deployment.Application.DownloadProgressChangedEventArgs&gt; DownloadProgressChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Deployment.Application.DownloadProgressChangedEventArgs&gt; DownloadProgressChanged" />
      <MemberSignature Language="DocId" Value="E:System.Deployment.Application.InPlaceHostingManager.DownloadProgressChanged" />
      <MemberSignature Language="VB.NET" Value="Public Event DownloadProgressChanged As EventHandler(Of DownloadProgressChangedEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::Deployment::Application::DownloadProgressChangedEventArgs ^&gt; ^ DownloadProgressChanged;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Deployment</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Deployment.Application.DownloadProgressChangedEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ocorre quando há uma alteração no status do download de um aplicativo ou manifesto.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Em um aplicativo de console, eventos são atribuídos a threads em um pool de threads. Portanto, você pode receber eventos de atualização de andamento fora de ordem, com um evento subsequente mostrando uma redução em comparação com um evento anterior. Você não verá esse comportamento em um aplicativo baseado em Windows Forms, porque eventos em formulários do Windows são processados sequencialmente fora da fila de mensagens do thread da interface do usuário do usuário.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como atualizar um <xref:System.Windows.Forms.ToolStripProgressBar> que está contido dentro de um <xref:System.Windows.Forms.StatusStrip>.  
  
 [!code-csharp[System.Deployment.Application.InPlaceHostingManager#6](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Deployment.Application.InPlaceHostingManager/CS/Form1.cs#6)]
 [!code-vb[System.Deployment.Application.InPlaceHostingManager#6](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Deployment.Application.InPlaceHostingManager/VB/Form1.vb#6)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Execute">
      <MemberSignature Language="C#" Value="public System.Runtime.Remoting.ObjectHandle Execute ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Runtime.Remoting.ObjectHandle Execute() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Deployment.Application.InPlaceHostingManager.Execute" />
      <MemberSignature Language="VB.NET" Value="Public Function Execute () As ObjectHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Runtime::Remoting::ObjectHandle ^ Execute();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Deployment</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Inicializa o aplicativo [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)], se e somente se ele for um aplicativo baseado no Windows Presentation Foundation em execução em um navegador da Web.</summary>
        <returns>Um <see cref="T:System.Runtime.Remoting.ObjectHandle" /> correspondente ao aplicativo inicializado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método é válido somente para aplicativos baseados em Windows Presentation Foundation que podem ser hospedados em um navegador da Web (ou seja, seus manifestos de implantação é definir o `hostInBrowser` elemento XML).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetManifestAsync">
      <MemberSignature Language="C#" Value="public void GetManifestAsync ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void GetManifestAsync() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Deployment.Application.InPlaceHostingManager.GetManifestAsync" />
      <MemberSignature Language="VB.NET" Value="Public Sub GetManifestAsync ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void GetManifestAsync();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Deployment</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Baixa o manifesto de implantação do aplicativo [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)] em segundo plano e aciona um evento quando a operação é concluída ou encontra um erro.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para receber notificação de quando esse evento for concluído, criar um manipulador de eventos para o <xref:System.Deployment.Application.InPlaceHostingManager.GetManifestCompleted> evento. Se esse evento é chamado e nenhum erro é indicado por <xref:System.Deployment.Application.GetManifestCompletedEventArgs>, em seguida, você deve chamar <xref:System.Deployment.Application.InPlaceHostingManager.AssertApplicationRequirements%2A> para verificar que o aplicativo terá permissão para executar no computador local.  
  
   
  
## Examples  
 Os exemplos de código a seguir demonstram como chamar o <xref:System.Deployment.Application.InPlaceHostingManager.GetManifestAsync%2A> método. O manipulador para o <xref:System.Deployment.Application.InPlaceHostingManager.GetManifestCompleted> verificações de retorno de chamada de evento para ver se o download do manifesto foi concluída com êxito e nesse caso, solicita que o usuário com informações adicionais sobre o aplicativo. Se o usuário concordar em continuar a instalação, chama o manipulador <xref:System.Deployment.Application.InPlaceHostingManager.DownloadApplicationAsync%2A>.  
  
 Os exemplos de código a seguir pressupõem que você já definiu e criou uma instância de <xref:System.Deployment.Application.InPlaceHostingManager> chamado `iphm`.  
  
 [!code-csharp[System.Deployment.Application.InPlaceHostingManager#3](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Deployment.Application.InPlaceHostingManager/CS/Form1.cs#3)]
 [!code-vb[System.Deployment.Application.InPlaceHostingManager#3](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Deployment.Application.InPlaceHostingManager/VB/Form1.vb#3)]  
  
 [!code-csharp[System.Deployment.Application.InPlaceHostingManager#4](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Deployment.Application.InPlaceHostingManager/CS/Form1.cs#4)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetManifestCompleted">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Deployment.Application.GetManifestCompletedEventArgs&gt; GetManifestCompleted;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Deployment.Application.GetManifestCompletedEventArgs&gt; GetManifestCompleted" />
      <MemberSignature Language="DocId" Value="E:System.Deployment.Application.InPlaceHostingManager.GetManifestCompleted" />
      <MemberSignature Language="VB.NET" Value="Public Event GetManifestCompleted As EventHandler(Of GetManifestCompletedEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::Deployment::Application::GetManifestCompletedEventArgs ^&gt; ^ GetManifestCompleted;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Deployment</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Deployment.Application.GetManifestCompletedEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ocorre quando o manifesto de implantação foi baixado no computador local.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use o <xref:System.ComponentModel.AsyncCompletedEventArgs.Error%2A> propriedade <xref:System.Deployment.Application.GetManifestCompletedEventArgs> para verificar se <xref:System.Deployment.Application.InPlaceHostingManager.GetManifestAsync%2A> foi concluída com êxito ou retornou um erro. Se <xref:System.ComponentModel.AsyncCompletedEventArgs.Error%2A> for nulo, <xref:System.Deployment.Application.InPlaceHostingManager.GetManifestAsync%2A> foi concluída com êxito, e você pode chamar <xref:System.Deployment.Application.InPlaceHostingManager.AssertApplicationRequirements%2A>.  
  
   
  
## Examples  
 Os exemplos de código a seguir demonstram como chamar o <xref:System.Deployment.Application.InPlaceHostingManager.GetManifestAsync%2A> método. O manipulador para o <xref:System.Deployment.Application.InPlaceHostingManager.GetManifestCompleted> verificações de retorno de chamada de evento para ver se o download do manifesto foi concluída com êxito e nesse caso, solicita que o usuário com informações adicionais sobre o aplicativo. Se o usuário concordar em continuar a instalação, chama o manipulador <xref:System.Deployment.Application.InPlaceHostingManager.DownloadApplicationAsync%2A>.  
  
 Os exemplos de código a seguir pressupõem que você já definiu e criou uma instância de <xref:System.Deployment.Application.InPlaceHostingManager> chamado `iphm`.  
  
 [!code-csharp[System.Deployment.Application.InPlaceHostingManager#2](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Deployment.Application.InPlaceHostingManager/CS/Form1.cs#2)]
 [!code-vb[System.Deployment.Application.InPlaceHostingManager#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Deployment.Application.InPlaceHostingManager/VB/Form1.vb#2)]  
  
 [!code-csharp[System.Deployment.Application.InPlaceHostingManager#3](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Deployment.Application.InPlaceHostingManager/CS/Form1.cs#3)]
 [!code-vb[System.Deployment.Application.InPlaceHostingManager#3](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Deployment.Application.InPlaceHostingManager/VB/Form1.vb#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UninstallCustomAddIn">
      <MemberSignature Language="C#" Value="public static void UninstallCustomAddIn (string subscriptionId);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void UninstallCustomAddIn(string subscriptionId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Deployment.Application.InPlaceHostingManager.UninstallCustomAddIn(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub UninstallCustomAddIn (subscriptionId As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void UninstallCustomAddIn(System::String ^ subscriptionId);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Deployment</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="subscriptionId" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="subscriptionId">Uma cadeia de caracteres que contém um identificador de assinatura, que indica o suplemento a ser removido.</param>
        <summary>Remove um componente de um aplicativo definido pelo usuário instalado anteriormente.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="subscriptionId" /> não é uma identidade de assinatura válida ou não inclui um nome, token de chave pública, arquitetura de processador e número de versão.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="subscriptionId" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="UninstallCustomUXApplication">
      <MemberSignature Language="C#" Value="public static void UninstallCustomUXApplication (string subscriptionId);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void UninstallCustomUXApplication(string subscriptionId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Deployment.Application.InPlaceHostingManager.UninstallCustomUXApplication(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub UninstallCustomUXApplication (subscriptionId As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void UninstallCustomUXApplication(System::String ^ subscriptionId);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Deployment</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="subscriptionId" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="subscriptionId">Uma cadeia de caracteres que contém um identificador de assinatura, que indica o aplicativo [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)] a ser removido.</param>
        <summary>Remove um aplicativo [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)] que inclui o elemento &lt;customUX&gt;.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método desinstala instalado anteriormente [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)] aplicativo que usa o `<customUX>` elemento o [ &lt;entryPoint&gt; elemento](http://msdn.microsoft.com/library/10ad3083-10c1-4189-a870-9bba2eab244f).  
  
 Instaladores personalizados que não criam uma entrada de adicionar ou remover programas para o [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)] aplicativo precisa armazenar o identificador de assinatura encontrado no <xref:System.Deployment.Application.GetManifestCompletedEventArgs.SubscriptionIdentity%2A> propriedade durante a instalação.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>