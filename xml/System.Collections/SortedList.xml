<Type Name="SortedList" FullName="System.Collections.SortedList">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="a9512aa383743642ea72c68cda07bcf3b09cf2e0" />
    <Meta Name="ms.sourcegitcommit" Value="0ec122ee5f3681159b8460ab15b409fd6e3d3ae0" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="pt-BR" />
    <Meta Name="ms.lasthandoff" Value="10/04/2018" />
    <Meta Name="ms.locfileid" Value="48773305" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class SortedList : ICloneable, System.Collections.IDictionary" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit SortedList extends System.Object implements class System.Collections.ICollection, class System.Collections.IDictionary, class System.Collections.IEnumerable, class System.ICloneable" />
  <TypeSignature Language="DocId" Value="T:System.Collections.SortedList" />
  <TypeSignature Language="VB.NET" Value="Public Class SortedList&#xA;Implements ICloneable, IDictionary" />
  <TypeSignature Language="C++ CLI" Value="public ref class SortedList : ICloneable, System::Collections::IDictionary" />
  <TypeSignature Language="F#" Value="type SortedList = class&#xA;    interface IDictionary&#xA;    interface ICloneable&#xA;    interface ICollection&#xA;    interface IEnumerable" />
  <AssemblyInfo>
    <AssemblyName>System.Collections.NonGeneric</AssemblyName>
    <AssemblyVersion>4.0.1.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Collections.IDictionary</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.ICloneable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Diagnostics.DebuggerDisplay("Count = {Count}")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Diagnostics.DebuggerTypeProxy(typeof(System.Collections.SortedList/SortedListDebugView))</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Representa uma coleção de pares chave/valor que são classificados pelas chaves e são acessíveis por chave e por índice.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para obter a versão genérica dessa coleção, consulte <xref:System.Collections.Generic.SortedList%602?displayProperty=nameWithType>.  
  
 Um <xref:System.Collections.SortedList> elemento pode ser acessado por sua chave, como um elemento em qualquer <xref:System.Collections.IDictionary> implementação, ou por seu índice, como um elemento em qualquer <xref:System.Collections.IList> implementação.  
  
 Um <xref:System.Collections.SortedList> objeto mantém internamente duas matrizes para armazenar os elementos da lista; ou seja, uma matriz das chaves e outra matriz para os valores associados. Cada elemento é um par chave/valor que pode ser acessado como um <xref:System.Collections.DictionaryEntry> objeto. Uma chave não pode ser `null`, mas um valor pode ser.  
  
 A capacidade de um <xref:System.Collections.SortedList> objeto é o número de elementos a <xref:System.Collections.SortedList> pode conter. Como os elementos são adicionados a um <xref:System.Collections.SortedList>, a capacidade é aumentada automaticamente conforme necessário por meio de realocação. A capacidade pode ser diminuída chamando <xref:System.Collections.SortedList.TrimToSize%2A> ou definindo o <xref:System.Collections.SortedList.Capacity%2A> propriedade explicitamente.  
  
 Para grandes <xref:System.Collections.SortedList> objetos, você pode aumentar a capacidade máxima para 2 bilhões de elementos em um sistema de 64 bits, definindo o `enabled` atributo do elemento de configuração para `true` no ambiente de tempo de execução.  
  
 Os elementos de uma <xref:System.Collections.SortedList> objeto são classificados pelas chaves de qualquer um de acordo com um determinado <xref:System.Collections.IComparer> implementação especificado quando o <xref:System.Collections.SortedList> é criado ou de acordo com o <xref:System.IComparable> implementação fornecida pelas chaves em si. Em ambos os casos, um <xref:System.Collections.SortedList> não permitem chaves duplicadas.  
  
 A sequência de índice se baseia na sequência de classificação. Quando um elemento for adicionado, ele é inserido na <xref:System.Collections.SortedList> na classificação correta ordem e a indexação é ajustada de acordo. Quando um elemento for removido, a indexação também ajusta adequadamente. Portanto, o índice de um par chave/valor específicos pode mudar à medida que elementos são adicionados ou removidos do <xref:System.Collections.SortedList> objeto.  
  
 Operações em uma <xref:System.Collections.SortedList> objeto tendem a ser mais lento do que operações em um <xref:System.Collections.Hashtable> objeto devido à classificação. No entanto, o <xref:System.Collections.SortedList> oferece mais flexibilidade, permitindo o acesso aos valores por meio das chaves associadas ou os índices.  
  
 Elementos nesta coleção podem ser acessados usando um índice de inteiro.  Nesta coleção, os índices são baseados em zero.  
  
 O `foreach` instrução da linguagem c# (`for each` no Visual Basic) retorna um objeto do tipo dos elementos na coleção. Desde que cada elemento do <xref:System.Collections.SortedList> objeto é um par chave/valor, o tipo de elemento não é o tipo da chave ou o tipo do valor. Em vez disso, o tipo de elemento é <xref:System.Collections.DictionaryEntry>. Por exemplo:  
  
 [!code-cpp[Classic SortedList Example#2](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic SortedList Example/CPP/remarks.cpp#2)]
 [!code-csharp[Classic SortedList Example#2](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic SortedList Example/CS/remarks.cs#2)]
 [!code-vb[Classic SortedList Example#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic SortedList Example/VB/remarks.vb#2)]  
  
 O `foreach` instrução é um wrapper em torno de enumerador, que permite que somente a leitura de não gravação para a coleção.  
  
   
  
## Examples  
 O exemplo de código a seguir mostra como criar e inicializar um <xref:System.Collections.SortedList> objeto e como imprimir suas chaves e valores.  
  
 [!code-cpp[Classic SortedList Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic SortedList Example/CPP/source.cpp#1)]
 [!code-csharp[Classic SortedList Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic SortedList Example/CS/source.cs#1)]
 [!code-vb[Classic SortedList Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic SortedList Example/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe>Os membros estáticos públicos (<see langword="Shared" /> no Visual Basic) desse são thread-safe. Não há garantia de que qualquer membro de instância seja thread-safe.  
  
Um <see cref="T:System.Collections.SortedList" /> objeto pode dar suporte a vários leitores simultaneamente, desde que a coleção não será modificada. Para garantir a segurança do thread do <see cref="T:System.Collections.SortedList" />, todas as operações devem ser feitas por meio de wrapper retornado pelo <see cref="M:System.Collections.SortedList.Synchronized(System.Collections.SortedList)" /> método.  
  
A enumeração por meio de uma coleção não é um procedimento thread-safe intrínseco. Mesmo quando uma coleção está sincronizada, outros threads ainda podem modificar a coleção, o que faz o enumerador lançar uma exceção. Para garantir thread-safe durante a enumeração, é possível bloquear a coleção durante toda a enumeração ou verificar as exceções resultantes das alterações feitas por outros threads.</threadsafe>
    <altmember cref="T:System.IComparable" />
    <altmember cref="T:System.Collections.IComparer" />
    <altmember cref="T:System.Collections.IDictionary" />
    <altmember cref="T:System.Collections.Hashtable" />
    <altmember cref="T:System.Collections.Generic.SortedList`2" />
    <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-collections.md">Executando operações de cadeia de caracteres que não levam em conta a cultura em coleções</related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicializa uma nova instância da classe <see cref="T:System.Collections.SortedList" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public SortedList ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.SortedList.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; SortedList();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inicializa uma nova instância da classe <see cref="T:System.Collections.SortedList" /> que está vazia, tem a capacidade inicial padrão e é classificada de acordo com a interface <see cref="T:System.IComparable" /> implementada por cada chave adicionada ao objeto <see cref="T:System.Collections.SortedList" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cada chave deve implementar o <xref:System.IComparable> interface devem ser capazes de comparações com todas as outras chaves no <xref:System.Collections.SortedList> objeto. Os elementos são classificados de acordo com o <xref:System.IComparable> implementação de cada chave adicionada ao <xref:System.Collections.SortedList>.  
  
 A capacidade de um <xref:System.Collections.SortedList> objeto é o número de elementos que o <xref:System.Collections.SortedList> pode conter. Como os elementos são adicionados a um <xref:System.Collections.SortedList>, a capacidade é aumentada automaticamente conforme necessário, realocando a matriz interna.  
  
 Se o tamanho da coleção pode ser estimado, especificando a capacidade inicial elimina a necessidade de executar um número de operações de redimensionamento durante a adição de elementos para o <xref:System.Collections.SortedList> objeto.  
  
 Este construtor é uma operação O(1).  
  
   
  
## Examples  
 O exemplo de código a seguir cria coleções usando diferentes <xref:System.Collections.SortedList> construtores e demonstra as diferenças no comportamento das coleções.  
  
 [!code-cpp[System.Collections.SortedList_ctor#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Collections.SortedList_ctor/CPP/sortedlist_ctor.cpp#1)]
 [!code-csharp[System.Collections.SortedList_ctor#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.SortedList_ctor/CS/sortedlist_ctor.cs#1)]
 [!code-vb[System.Collections.SortedList_ctor#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.SortedList_ctor/VB/sortedlist_ctor.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.IComparable" />
        <altmember cref="P:System.Collections.SortedList.Capacity" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-collections.md">Executando operações de cadeia de caracteres que não levam em conta a cultura em coleções</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public SortedList (System.Collections.IComparer comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Collections.IComparer comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.SortedList.#ctor(System.Collections.IComparer)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (comparer As IComparer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; SortedList(System::Collections::IComparer ^ comparer);" />
      <MemberSignature Language="F#" Value="new System.Collections.SortedList : System.Collections.IComparer -&gt; System.Collections.SortedList" Usage="new System.Collections.SortedList comparer" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="comparer" Type="System.Collections.IComparer" />
      </Parameters>
      <Docs>
        <param name="comparer">A implementação de <see cref="T:System.Collections.IComparer" /> a ser usada ao comparar chaves.  
  
- ou - 
 <see langword="null" /> para usar a implementação de <see cref="T:System.IComparable" /> de cada chave.</param>
        <summary>Inicializa uma nova instância da classe <see cref="T:System.Collections.SortedList" /> que está vazia, tem a capacidade inicial padrão e é classificada de acordo com a interface <see cref="T:System.Collections.IComparer" /> especificada.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Os elementos são classificados de acordo com o especificado <xref:System.Collections.IComparer> implementação. Se o `comparer` parâmetro é `null`, o <xref:System.IComparable> implementação de cada chave é usada; portanto, cada chave deve implementar a <xref:System.IComparable> interface devem ser capazes de comparações com todas as outras chaves no <xref:System.Collections.SortedList> objeto.  
  
 A capacidade de um <xref:System.Collections.SortedList> objeto é o número de elementos que o <xref:System.Collections.SortedList> pode conter. Como os elementos são adicionados a um <xref:System.Collections.SortedList>, a capacidade é aumentada automaticamente conforme necessário, realocando a matriz interna.  
  
 Se o tamanho da coleção pode ser estimado, especificando a capacidade inicial elimina a necessidade de executar um número de operações de redimensionamento durante a adição de elementos para o <xref:System.Collections.SortedList> objeto.  
  
 Este construtor é uma operação O(1).  
  
   
  
## Examples  
 O exemplo de código a seguir cria coleções usando diferentes <xref:System.Collections.SortedList> construtores e demonstra as diferenças no comportamento das coleções.  
  
 [!code-cpp[System.Collections.SortedList_ctor#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Collections.SortedList_ctor/CPP/sortedlist_ctor.cpp#1)]
 [!code-csharp[System.Collections.SortedList_ctor#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.SortedList_ctor/CS/sortedlist_ctor.cs#1)]
 [!code-vb[System.Collections.SortedList_ctor#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.SortedList_ctor/VB/sortedlist_ctor.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.IComparer" />
        <altmember cref="T:System.IComparable" />
        <altmember cref="P:System.Collections.SortedList.Capacity" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-collections.md">Executando operações de cadeia de caracteres que não levam em conta a cultura em coleções</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public SortedList (System.Collections.IDictionary d);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Collections.IDictionary d) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.SortedList.#ctor(System.Collections.IDictionary)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (d As IDictionary)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; SortedList(System::Collections::IDictionary ^ d);" />
      <MemberSignature Language="F#" Value="new System.Collections.SortedList : System.Collections.IDictionary -&gt; System.Collections.SortedList" Usage="new System.Collections.SortedList d" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="d" Type="System.Collections.IDictionary" />
      </Parameters>
      <Docs>
        <param name="d">A implementação de <see cref="T:System.Collections.IDictionary" /> para copiar para um novo objeto <see cref="T:System.Collections.SortedList" />.</param>
        <summary>Inicializa uma nova instância da classe <see cref="T:System.Collections.SortedList" /> que contém elementos copiados do dicionário especificado, tem a mesma capacidade inicial que o número de elementos copiados e é classificada segundo a interface <see cref="T:System.IComparable" /> implementada por cada chave.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cada chave deve implementar o <xref:System.IComparable> interface devem ser capazes de comparações com todas as outras chaves no <xref:System.Collections.SortedList> objeto. Os elementos são classificados de acordo com o <xref:System.IComparable> implementação de cada chave adicionada ao <xref:System.Collections.SortedList>.  
  
 Um <xref:System.Collections.Hashtable> objeto é um exemplo de um <xref:System.Collections.IDictionary> implementação que pode ser passada para esse construtor. O novo <xref:System.Collections.SortedList> objeto contém uma cópia das chaves e valores armazenados no <xref:System.Collections.Hashtable>.  
  
 A capacidade de um <xref:System.Collections.SortedList> objeto é o número de elementos que o <xref:System.Collections.SortedList> pode conter. Como os elementos são adicionados a um <xref:System.Collections.SortedList>, a capacidade é aumentada automaticamente conforme necessário, realocando a matriz interna.  
  
 Se o tamanho da coleção pode ser estimado, especificando a capacidade inicial elimina a necessidade de executar um número de operações de redimensionamento durante a adição de elementos para o <xref:System.Collections.SortedList> objeto.  
  
 Este construtor é um O (`n`) a operação, onde `n` é o número de elementos em `d`.  
  
   
  
## Examples  
 O exemplo de código a seguir cria coleções usando diferentes <xref:System.Collections.SortedList> construtores e demonstra as diferenças no comportamento das coleções.  
  
 [!code-cpp[System.Collections.SortedList_ctorDictionary#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Collections.SortedList_ctorDictionary/CPP/sortedlist_ctordictionary.cpp#1)]
 [!code-csharp[System.Collections.SortedList_ctorDictionary#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.SortedList_ctorDictionary/CS/sortedlist_ctordictionary.cs#1)]
 [!code-vb[System.Collections.SortedList_ctorDictionary#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.SortedList_ctorDictionary/VB/sortedlist_ctordictionary.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="d" /> é <see langword="null" />.</exception>
        <exception cref="T:System.InvalidCastException">Um ou mais elementos em <paramref name="d" /> não implementam a interface <see cref="T:System.IComparable" />.</exception>
        <altmember cref="T:System.Collections.IDictionary" />
        <altmember cref="T:System.IComparable" />
        <altmember cref="T:System.Collections.Hashtable" />
        <altmember cref="P:System.Collections.SortedList.Capacity" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-collections.md">Executando operações de cadeia de caracteres que não levam em conta a cultura em coleções</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public SortedList (int initialCapacity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 initialCapacity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.SortedList.#ctor(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (initialCapacity As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; SortedList(int initialCapacity);" />
      <MemberSignature Language="F#" Value="new System.Collections.SortedList : int -&gt; System.Collections.SortedList" Usage="new System.Collections.SortedList initialCapacity" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="initialCapacity" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="initialCapacity">O número inicial de elementos que o objeto <see cref="T:System.Collections.SortedList" /> pode conter.</param>
        <summary>Inicializa uma nova instância da classe <see cref="T:System.Collections.SortedList" /> que está vazia, tem a capacidade inicial especificada e é classificada de acordo com a interface <see cref="T:System.IComparable" /> implementada por cada chave adicionada ao objeto <see cref="T:System.Collections.SortedList" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cada chave deve implementar o <xref:System.IComparable> interface devem ser capazes de comparações com todas as outras chaves no <xref:System.Collections.SortedList> objeto. Os elementos são classificados de acordo com o <xref:System.IComparable> implementação de cada chave adicionada ao <xref:System.Collections.SortedList>.  
  
 A capacidade de um <xref:System.Collections.SortedList> objeto é o número de elementos que o <xref:System.Collections.SortedList> pode conter. Como os elementos são adicionados a um <xref:System.Collections.SortedList>, a capacidade é aumentada automaticamente conforme necessário, realocando a matriz interna.  
  
 Se o tamanho da coleção pode ser estimado, especificando a capacidade inicial elimina a necessidade de executar um número de operações de redimensionamento durante a adição de elementos para o <xref:System.Collections.SortedList> objeto.  
  
 Este construtor é um O (`n`) a operação, onde `n` é `initialCapacity`.  
  
   
  
## Examples  
 O exemplo de código a seguir cria coleções usando diferentes <xref:System.Collections.SortedList> construtores e demonstra as diferenças no comportamento das coleções.  
  
 [!code-cpp[System.Collections.SortedList_ctorInt#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Collections.SortedList_ctorInt/CPP/sortedlist_ctorint.cpp#1)]
 [!code-csharp[System.Collections.SortedList_ctorInt#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.SortedList_ctorInt/CS/sortedlist_ctorint.cs#1)]
 [!code-vb[System.Collections.SortedList_ctorInt#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.SortedList_ctorInt/VB/sortedlist_ctorint.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="initialCapacity" /> é menor que zero.</exception>
        <exception cref="T:System.OutOfMemoryException">Não há memória suficiente disponível para criar um objeto <see cref="T:System.Collections.SortedList" /> com o <paramref name="initialCapacity" /> especificado.</exception>
        <altmember cref="T:System.IComparable" />
        <altmember cref="P:System.Collections.SortedList.Capacity" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-collections.md">Executando operações de cadeia de caracteres que não levam em conta a cultura em coleções</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public SortedList (System.Collections.IComparer comparer, int capacity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Collections.IComparer comparer, int32 capacity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.SortedList.#ctor(System.Collections.IComparer,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (comparer As IComparer, capacity As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; SortedList(System::Collections::IComparer ^ comparer, int capacity);" />
      <MemberSignature Language="F#" Value="new System.Collections.SortedList : System.Collections.IComparer * int -&gt; System.Collections.SortedList" Usage="new System.Collections.SortedList (comparer, capacity)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="comparer" Type="System.Collections.IComparer" />
        <Parameter Name="capacity" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="comparer">A implementação de <see cref="T:System.Collections.IComparer" /> a ser usada ao comparar chaves.  
  
- ou - 
 <see langword="null" /> para usar a implementação de <see cref="T:System.IComparable" /> de cada chave.</param>
        <param name="capacity">O número inicial de elementos que o objeto <see cref="T:System.Collections.SortedList" /> pode conter.</param>
        <summary>Inicializa uma nova instância da classe <see cref="T:System.Collections.SortedList" /> que está vazia, tem a capacidade inicial especificada e é classificada de acordo com a interface <see cref="T:System.Collections.IComparer" /> especificada.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Os elementos são classificados de acordo com o especificado <xref:System.Collections.IComparer> implementação. Se o `comparer` parâmetro é `null`, o <xref:System.IComparable> implementação de cada chave é usada; portanto, cada chave deve implementar a <xref:System.IComparable> interface devem ser capazes de comparações com todas as outras chaves no <xref:System.Collections.SortedList> objeto.  
  
 A capacidade de um <xref:System.Collections.SortedList> objeto é o número de elementos que o <xref:System.Collections.SortedList> pode conter. Como os elementos são adicionados a um <xref:System.Collections.SortedList>, a capacidade é aumentada automaticamente conforme necessário, realocando a matriz interna.  
  
 Se o tamanho da coleção pode ser estimado, especificando a capacidade inicial elimina a necessidade de executar um número de operações de redimensionamento durante a adição de elementos para o <xref:System.Collections.SortedList> objeto.  
  
 Este construtor é um O (`n`) a operação, onde `n` é `capacity`.  
  
   
  
## Examples  
 O exemplo de código a seguir cria coleções usando diferentes <xref:System.Collections.SortedList> construtores e demonstra as diferenças no comportamento das coleções.  
  
 [!code-cpp[System.Collections.SortedList_ctorInt#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Collections.SortedList_ctorInt/CPP/sortedlist_ctorint.cpp#1)]
 [!code-csharp[System.Collections.SortedList_ctorInt#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.SortedList_ctorInt/CS/sortedlist_ctorint.cs#1)]
 [!code-vb[System.Collections.SortedList_ctorInt#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.SortedList_ctorInt/VB/sortedlist_ctorint.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="capacity" /> é menor que zero.</exception>
        <exception cref="T:System.OutOfMemoryException">Não há memória suficiente disponível para criar um objeto <see cref="T:System.Collections.SortedList" /> com o <paramref name="capacity" /> especificado.</exception>
        <altmember cref="T:System.Collections.IComparer" />
        <altmember cref="T:System.IComparable" />
        <altmember cref="P:System.Collections.SortedList.Capacity" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-collections.md">Executando operações de cadeia de caracteres que não levam em conta a cultura em coleções</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public SortedList (System.Collections.IDictionary d, System.Collections.IComparer comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Collections.IDictionary d, class System.Collections.IComparer comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.SortedList.#ctor(System.Collections.IDictionary,System.Collections.IComparer)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (d As IDictionary, comparer As IComparer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; SortedList(System::Collections::IDictionary ^ d, System::Collections::IComparer ^ comparer);" />
      <MemberSignature Language="F#" Value="new System.Collections.SortedList : System.Collections.IDictionary * System.Collections.IComparer -&gt; System.Collections.SortedList" Usage="new System.Collections.SortedList (d, comparer)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="d" Type="System.Collections.IDictionary" />
        <Parameter Name="comparer" Type="System.Collections.IComparer" />
      </Parameters>
      <Docs>
        <param name="d">A implementação de <see cref="T:System.Collections.IDictionary" /> para copiar para um novo objeto <see cref="T:System.Collections.SortedList" />.</param>
        <param name="comparer">A implementação de <see cref="T:System.Collections.IComparer" /> a ser usada ao comparar chaves.  
  
- ou - 
 <see langword="null" /> para usar a implementação de <see cref="T:System.IComparable" /> de cada chave.</param>
        <summary>Inicializa uma nova instância da classe <see cref="T:System.Collections.SortedList" /> que contém elementos copiados do dicionário especificado, tem a mesma capacidade inicial que o número de elementos copiados e é classificada segundo a interface <see cref="T:System.Collections.IComparer" /> especificada.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Os elementos são classificados de acordo com o especificado <xref:System.Collections.IComparer> implementação. Se o `comparer` parâmetro é `null`, o <xref:System.IComparable> implementação de cada chave é usada; portanto, cada chave deve implementar a <xref:System.IComparable> interface devem ser capazes de comparações com todas as outras chaves no <xref:System.Collections.SortedList> objeto.  
  
 Um <xref:System.Collections.Hashtable> objeto é um exemplo de um <xref:System.Collections.IDictionary> implementação que pode ser passada para esse construtor. O novo <xref:System.Collections.SortedList> objeto contém uma cópia das chaves e valores armazenados no <xref:System.Collections.Hashtable>.  
  
 A capacidade de um <xref:System.Collections.SortedList> objeto é o número de elementos que o <xref:System.Collections.SortedList> pode conter. Como os elementos são adicionados a um <xref:System.Collections.SortedList>, a capacidade é aumentada automaticamente conforme necessário, realocando a matriz interna.  
  
 Se o tamanho da coleção pode ser estimado, especificando a capacidade inicial elimina a necessidade de executar um número de operações de redimensionamento durante a adição de elementos para o <xref:System.Collections.SortedList> objeto.  
  
 Este construtor é um O (`n`) a operação, onde `n` é o número de elementos em `d`.  
  
   
  
## Examples  
 O exemplo de código a seguir cria coleções usando diferentes <xref:System.Collections.SortedList> construtores e demonstra as diferenças no comportamento das coleções.  
  
 [!code-cpp[System.Collections.SortedList_ctorDictionary#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Collections.SortedList_ctorDictionary/CPP/sortedlist_ctordictionary.cpp#1)]
 [!code-csharp[System.Collections.SortedList_ctorDictionary#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.SortedList_ctorDictionary/CS/sortedlist_ctordictionary.cs#1)]
 [!code-vb[System.Collections.SortedList_ctorDictionary#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.SortedList_ctorDictionary/VB/sortedlist_ctordictionary.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="d" /> é <see langword="null" />.</exception>
        <exception cref="T:System.InvalidCastException">
          <paramref name="comparer" /> é <see langword="null" />, e um ou mais elementos em <paramref name="d" /> não implementam a interface <see cref="T:System.IComparable" />.</exception>
        <altmember cref="T:System.Collections.IDictionary" />
        <altmember cref="T:System.Collections.IComparer" />
        <altmember cref="T:System.IComparable" />
        <altmember cref="T:System.Collections.Hashtable" />
        <altmember cref="P:System.Collections.SortedList.Capacity" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-collections.md">Executando operações de cadeia de caracteres que não levam em conta a cultura em coleções</related>
      </Docs>
    </Member>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public virtual void Add (object key, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Add(object key, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.SortedList.Add(System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Add (key As Object, value As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Add(System::Object ^ key, System::Object ^ value);" />
      <MemberSignature Language="F#" Value="abstract member Add : obj * obj -&gt; unit&#xA;override this.Add : obj * obj -&gt; unit" Usage="sortedList.Add (key, value)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IDictionary.Add(System.Object,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.Object" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="key">A chave do elemento a ser adicionada.</param>
        <param name="value">O valor do elemento a ser adicionado. O valor pode ser <see langword="null" />.</param>
        <summary>Adiciona um elemento com a chave e o valor especificados a um objeto <see cref="T:System.Collections.SortedList" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O ponto de inserção é determinado com base no comparador selecionado, explicitamente ou por padrão, quando o <xref:System.Collections.SortedList> objeto foi criado.  
  
 Se <xref:System.Collections.SortedList.Count%2A> já for igual a <xref:System.Collections.SortedList.Capacity%2A>, a capacidade do <xref:System.Collections.SortedList> objeto é aumentado, automaticamente realocando a matriz interna e os elementos existentes são copiados para a nova matriz antes do novo elemento é adicionado.  
  
 Você também pode usar o <xref:System.Collections.SortedList.Item%2A> propriedade para adicionar novos elementos ao definir o valor de uma chave que não existe na <xref:System.Collections.SortedList> objeto (por exemplo, `myCollection["myNonexistentKey"] = myValue`). No entanto, se a chave especificada já existe na <xref:System.Collections.SortedList>, definindo o <xref:System.Collections.SortedList.Item%2A> propriedade substitui o valor antigo. Em contraste, o <xref:System.Collections.SortedList.Add%2A> método não modifica os elementos existentes.  
  
 Os elementos de uma <xref:System.Collections.SortedList> objeto são classificados pelas chaves de qualquer um de acordo com um determinado <xref:System.Collections.IComparer> implementação especificado quando o <xref:System.Collections.SortedList> é criado ou de acordo com o <xref:System.IComparable> implementação fornecida pelas chaves em si.  
  
 Uma chave não pode ser `null`, mas um valor pode ser.  
  
 Esse método é um O (`n`) a operação para dados não classificados, onde `n` é <xref:System.Collections.SortedList.Count%2A>. É um O (log `n`) operação se o novo elemento é adicionado ao final da lista. Se a inserção faz com que um redimensionamento, a operação é O (`n`).  
  
   
  
## Examples  
 O exemplo de código a seguir mostra como adicionar elementos a uma <xref:System.Collections.SortedList> objeto.  
  
 [!code-cpp[Classic SortedList.Add Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic SortedList.Add Example/CPP/source.cpp#1)]
 [!code-csharp[Classic SortedList.Add Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic SortedList.Add Example/CS/source.cs#1)]
 [!code-vb[Classic SortedList.Add Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic SortedList.Add Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="key" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Já existe um elemento com o <paramref name="key" /> especificado no objeto <see cref="T:System.Collections.SortedList" />.  
  
- ou - 
O <see cref="T:System.Collections.SortedList" /> está definido para usar a interface <see cref="T:System.IComparable" /> e <paramref name="key" /> não implementa a interface <see cref="T:System.IComparable" />.</exception>
        <exception cref="T:System.NotSupportedException">O <see cref="T:System.Collections.SortedList" /> é somente leitura.  
  
- ou - 
O <see cref="T:System.Collections.SortedList" /> tem um tamanho fixo.</exception>
        <exception cref="T:System.OutOfMemoryException">Não há memória suficiente disponível para adicionar o elemento ao <see cref="T:System.Collections.SortedList" />.</exception>
        <exception cref="T:System.InvalidOperationException">O comparador gera uma exceção.</exception>
        <altmember cref="P:System.Collections.SortedList.Item(System.Object)" />
        <altmember cref="T:System.Collections.IComparer" />
        <altmember cref="T:System.IComparable" />
        <altmember cref="P:System.Collections.SortedList.Capacity" />
      </Docs>
    </Member>
    <Member MemberName="Capacity">
      <MemberSignature Language="C#" Value="public virtual int Capacity { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Capacity" />
      <MemberSignature Language="DocId" Value="P:System.Collections.SortedList.Capacity" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property Capacity As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int Capacity { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.Capacity : int with get, set" Usage="System.Collections.SortedList.Capacity" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define a capacidade de um objeto <see cref="T:System.Collections.SortedList" />.</summary>
        <value>O número de elementos que o objeto <see cref="T:System.Collections.SortedList" /> pode conter.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.SortedList.Capacity%2A> é o número de elementos que o <xref:System.Collections.SortedList> objeto pode armazenar. <xref:System.Collections.SortedList.Count%2A> é o número de elementos que estão realmente no <xref:System.Collections.SortedList>.  
  
 <xref:System.Collections.SortedList.Capacity%2A> é sempre maior que ou igual a <xref:System.Collections.SortedList.Count%2A>. Se <xref:System.Collections.SortedList.Count%2A> excede <xref:System.Collections.SortedList.Capacity%2A> durante a adição de elementos, a capacidade é aumentada automaticamente, realocando a matriz interna antes de copiar os elementos antigos e adição de novos elementos.  
  
 A capacidade pode ser diminuída chamando <xref:System.Collections.SortedList.TrimToSize%2A> ou definindo o <xref:System.Collections.SortedList.Capacity%2A> propriedade explicitamente. Quando o valor de <xref:System.Collections.SortedList.Capacity%2A> for definido explicitamente, a matriz interna é também realocada para acomodar a capacidade especificada.  
  
 Recuperando o valor dessa propriedade é uma operação de (1); configuração da propriedade é um O (`n`) a operação, onde `n` é a nova capacidade.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">O valor atribuído é menor que o número atual de elementos no objeto <see cref="T:System.Collections.SortedList" />.</exception>
        <exception cref="T:System.OutOfMemoryException">Não há memória suficiente disponível no sistema.</exception>
        <altmember cref="M:System.Collections.SortedList.TrimToSize" />
      </Docs>
    </Member>
    <Member MemberName="Clear">
      <MemberSignature Language="C#" Value="public virtual void Clear ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Clear() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.SortedList.Clear" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Clear ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Clear();" />
      <MemberSignature Language="F#" Value="abstract member Clear : unit -&gt; unit&#xA;override this.Clear : unit -&gt; unit" Usage="sortedList.Clear " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IDictionary.Clear</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Remove todos os elementos de um objeto <see cref="T:System.Collections.SortedList" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.SortedList.Count%2A> é definido como zero e referências a outros objetos de elementos da coleção também são liberadas.  
  
 <xref:System.Collections.SortedList.Capacity%2A> permanece inalterado. Para redefinir a capacidade do <xref:System.Collections.SortedList> do objeto, chame <xref:System.Collections.SortedList.TrimToSize%2A> ou defina o <xref:System.Collections.SortedList.Capacity%2A> propriedade diretamente. Cortar um vazio <xref:System.Collections.SortedList> define a capacidade do <xref:System.Collections.SortedList> para a capacidade padrão.  
  
 Este método é uma operação O(`n`), em que `n` é <xref:System.Collections.SortedList.Count%2A>.  
  
   
  
## Examples  
 O exemplo de código a seguir mostra como cortar as partes não usadas de uma <xref:System.Collections.SortedList> objeto e como limpar os valores da <xref:System.Collections.SortedList>.  
  
 [!code-cpp[Classic SortedList.Clear Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic SortedList.Clear Example/CPP/source.cpp#1)]
 [!code-csharp[Classic SortedList.Clear Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic SortedList.Clear Example/CS/source.cs#1)]
 [!code-vb[Classic SortedList.Clear Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic SortedList.Clear Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">O objeto <see cref="T:System.Collections.SortedList" /> é somente leitura.  
  
- ou - 
O <see cref="T:System.Collections.SortedList" /> tem um tamanho fixo.</exception>
        <altmember cref="M:System.Collections.SortedList.TrimToSize" />
        <altmember cref="P:System.Collections.SortedList.Capacity" />
        <altmember cref="P:System.Collections.SortedList.Count" />
      </Docs>
    </Member>
    <Member MemberName="Clone">
      <MemberSignature Language="C#" Value="public virtual object Clone ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object Clone() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.SortedList.Clone" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Clone () As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ Clone();" />
      <MemberSignature Language="F#" Value="abstract member Clone : unit -&gt; obj&#xA;override this.Clone : unit -&gt; obj" Usage="sortedList.Clone " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ICloneable.Clone</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Cria uma cópia superficial de um objeto <see cref="T:System.Collections.SortedList" />.</summary>
        <returns>Uma cópia superficial do objeto <see cref="T:System.Collections.SortedList" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Uma cópia superficial de uma coleção copia apenas os elementos da coleção, se eles são tipos de referência ou valor de tipos, mas não copia os objetos que referenciam as referências. As referências na nova coleção apontam para os mesmos objetos que as referências na coleção original apontem para.  
  
 Em contraste, uma cópia em profundidade de uma coleção copia os elementos e tudo direta ou indiretamente referenciado pelos elementos.  
  
 Este método é uma operação O(`n`), em que `n` é <xref:System.Collections.SortedList.Count%2A>.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Collections.SortedList.CopyTo(System.Array,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Contains">
      <MemberSignature Language="C#" Value="public virtual bool Contains (object key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Contains(object key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.SortedList.Contains(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Contains (key As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Contains(System::Object ^ key);" />
      <MemberSignature Language="F#" Value="abstract member Contains : obj -&gt; bool&#xA;override this.Contains : obj -&gt; bool" Usage="sortedList.Contains key" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IDictionary.Contains(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="key">A chave a ser localizada no objeto <see cref="T:System.Collections.SortedList" />.</param>
        <summary>Determina se um objeto <see cref="T:System.Collections.SortedList" /> contém uma chave específica.</summary>
        <returns>
          <see langword="true" /> se o objeto <see cref="T:System.Collections.SortedList" /> contiver um elemento com o <paramref name="key" /> especificado, caso contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Os elementos de uma <xref:System.Collections.SortedList> objeto são classificados pelas chaves de qualquer um de acordo com um determinado <xref:System.Collections.IComparer> implementação especificado quando o <xref:System.Collections.SortedList> é criado ou de acordo com o <xref:System.IComparable> implementação fornecida pelas chaves em si.  
  
 <xref:System.Collections.SortedList.Contains%2A> implementa <xref:System.Collections.IDictionary.Contains%2A?displayProperty=nameWithType>. Ele se comporta exatamente como <xref:System.Collections.SortedList.ContainsKey%2A>.  
  
 Esse método usa um algoritmo de pesquisa binária; Portanto, esse método é um O (log `n`) a operação, onde `n` é <xref:System.Collections.SortedList.Count%2A>.  
  
 Começando pelo .NET Framework 2.0, esse método usa os métodos <xref:System.Object.Equals%2A> e <xref:System.IComparable.CompareTo%2A> do objeto da coleção em `item` para determinar se o item existe. Em versões anteriores do .NET Framework, essa decisão era tomada usando-se os métodos <xref:System.Object.Equals%2A> e <xref:System.IComparable.CompareTo%2A> do parâmetro `item` nos objetos na coleção.  
  
   
  
## Examples  
 O exemplo de código a seguir mostra como determinar se um <xref:System.Collections.SortedList> objeto contém um elemento específico.  
  
 [!code-cpp[Classic SortedList.Contains Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic SortedList.Contains Example/CPP/source.cpp#1)]
 [!code-csharp[Classic SortedList.Contains Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic SortedList.Contains Example/CS/source.cs#1)]
 [!code-vb[Classic SortedList.Contains Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic SortedList.Contains Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="key" /> é <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">O comparador gera uma exceção.</exception>
        <altmember cref="M:System.Collections.SortedList.ContainsKey(System.Object)" />
        <altmember cref="M:System.Collections.SortedList.IndexOfKey(System.Object)" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-collections.md">Executando operações de cadeia de caracteres que não levam em conta a cultura em coleções</related>
      </Docs>
    </Member>
    <Member MemberName="ContainsKey">
      <MemberSignature Language="C#" Value="public virtual bool ContainsKey (object key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool ContainsKey(object key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.SortedList.ContainsKey(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ContainsKey (key As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool ContainsKey(System::Object ^ key);" />
      <MemberSignature Language="F#" Value="abstract member ContainsKey : obj -&gt; bool&#xA;override this.ContainsKey : obj -&gt; bool" Usage="sortedList.ContainsKey key" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="key">A chave a ser localizada no objeto <see cref="T:System.Collections.SortedList" />.</param>
        <summary>Determina se um objeto <see cref="T:System.Collections.SortedList" /> contém uma chave específica.</summary>
        <returns>
          <see langword="true" /> se o objeto <see cref="T:System.Collections.SortedList" /> contiver um elemento com o <paramref name="key" /> especificado, caso contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Os elementos de uma <xref:System.Collections.SortedList> objeto são classificados pelas chaves de qualquer um de acordo com um determinado <xref:System.Collections.IComparer> implementação especificado quando o <xref:System.Collections.SortedList> é criado ou de acordo com o <xref:System.IComparable> implementação fornecida pelas chaves em si.  
  
 Esse método se comporta exatamente como o <xref:System.Collections.SortedList.Contains%2A> método.  
  
 Esse método usa um algoritmo de pesquisa binária; Portanto, esse método é um O (log `n`) a operação, onde `n` é <xref:System.Collections.SortedList.Count%2A>.  
  
 Começando pelo .NET Framework 2.0, esse método usa os métodos <xref:System.Object.Equals%2A> e <xref:System.IComparable.CompareTo%2A> do objeto da coleção em `item` para determinar se o item existe. Em versões anteriores do .NET Framework, essa decisão era tomada usando-se os métodos <xref:System.Object.Equals%2A> e <xref:System.IComparable.CompareTo%2A> do parâmetro `item` nos objetos na coleção.  
  
   
  
## Examples  
 O exemplo de código a seguir mostra como determinar se um <xref:System.Collections.SortedList> objeto contém um elemento específico.  
  
 [!code-cpp[Classic SortedList.Contains Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic SortedList.Contains Example/CPP/source.cpp#1)]
 [!code-csharp[Classic SortedList.Contains Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic SortedList.Contains Example/CS/source.cs#1)]
 [!code-vb[Classic SortedList.Contains Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic SortedList.Contains Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="key" /> é <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">O comparador gera uma exceção.</exception>
        <altmember cref="M:System.Collections.SortedList.Contains(System.Object)" />
        <altmember cref="M:System.Collections.SortedList.ContainsValue(System.Object)" />
        <altmember cref="M:System.Collections.SortedList.IndexOfKey(System.Object)" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-collections.md">Executando operações de cadeia de caracteres que não levam em conta a cultura em coleções</related>
      </Docs>
    </Member>
    <Member MemberName="ContainsValue">
      <MemberSignature Language="C#" Value="public virtual bool ContainsValue (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool ContainsValue(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.SortedList.ContainsValue(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ContainsValue (value As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool ContainsValue(System::Object ^ value);" />
      <MemberSignature Language="F#" Value="abstract member ContainsValue : obj -&gt; bool&#xA;override this.ContainsValue : obj -&gt; bool" Usage="sortedList.ContainsValue value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">O valor a ser localizado no objeto <see cref="T:System.Collections.SortedList" />. O valor pode ser <see langword="null" />.</param>
        <summary>Determina se um objeto <see cref="T:System.Collections.SortedList" /> contém um valor específico.</summary>
        <returns>
          <see langword="true" /> se o objeto <see cref="T:System.Collections.SortedList" /> contiver um elemento com o <paramref name="value" /> especificado, caso contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Os valores dos elementos dos <xref:System.Collections.SortedList> objeto são comparados com o valor especificado usando o <xref:System.Object.Equals%2A> método.  
  
 Esse método executa uma pesquisa linear. Portanto, o tempo médio de execução é proporcional ao <xref:System.Collections.SortedList.Count%2A>. Ou seja, esse método é um O (`n`) a operação, onde `n` é <xref:System.Collections.SortedList.Count%2A>.  
  
 Começando pelo .NET Framework 2.0, esse método usa os métodos <xref:System.Object.Equals%2A> e <xref:System.IComparable.CompareTo%2A> do objeto da coleção em `item` para determinar se o item existe. Em versões anteriores do .NET Framework, essa decisão era tomada usando-se os métodos <xref:System.Object.Equals%2A> e <xref:System.IComparable.CompareTo%2A> do parâmetro `item` nos objetos na coleção.  
  
   
  
## Examples  
 O exemplo de código a seguir mostra como determinar se um <xref:System.Collections.SortedList> objeto contém um elemento específico.  
  
 [!code-cpp[Classic SortedList.Contains Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic SortedList.Contains Example/CPP/source.cpp#1)]
 [!code-csharp[Classic SortedList.Contains Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic SortedList.Contains Example/CS/source.cs#1)]
 [!code-vb[Classic SortedList.Contains Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic SortedList.Contains Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Collections.SortedList.ContainsKey(System.Object)" />
        <altmember cref="M:System.Collections.SortedList.IndexOfValue(System.Object)" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-collections.md">Executando operações de cadeia de caracteres que não levam em conta a cultura em coleções</related>
      </Docs>
    </Member>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public virtual void CopyTo (Array array, int arrayIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void CopyTo(class System.Array array, int32 arrayIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.SortedList.CopyTo(System.Array,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void CopyTo(Array ^ array, int arrayIndex);" />
      <MemberSignature Language="F#" Value="abstract member CopyTo : Array * int -&gt; unit&#xA;override this.CopyTo : Array * int -&gt; unit" Usage="sortedList.CopyTo (array, arrayIndex)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.ICollection.CopyTo(System.Array,System.Int32)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="arrayIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">O <see cref="T:System.Array" /> unidimensional que é o destino dos objetos <see cref="T:System.Collections.DictionaryEntry" /> copiados de <see cref="T:System.Collections.SortedList" />. O <see cref="T:System.Array" /> deve ter indexação com base em zero.</param>
        <param name="arrayIndex">O índice baseado em zero na <c>array</c> na qual a cópia começa.</param>
        <summary>Copia <see cref="T:System.Collections.SortedList" /> elementos para um objeto <see cref="T:System.Array" /> unidimensional, iniciando no índice especificado na matriz.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Os pares chave/valor são copiados para o <xref:System.Array> objeto na mesma ordem em que o enumerador que itera por meio de <xref:System.Collections.SortedList> objeto.  
  
 Para copiar somente as chaves na <xref:System.Collections.SortedList>, use `SortedList.Keys.CopyTo`.  
  
 Para copiar apenas os valores na <xref:System.Collections.SortedList>, use `SortedList.Values.CopyTo`.  
  
 Este método é uma operação O(`n`), em que `n` é <xref:System.Collections.SortedList.Count%2A>.  
  
   
  
## Examples  
 O exemplo de código a seguir mostra como copiar os valores em uma <xref:System.Collections.SortedList> o objeto para um unidimensional <xref:System.Array> objeto.  
  
 [!code-cpp[Classic SortedList.CopyTo Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic SortedList.CopyTo Example/CPP/source.cpp#1)]
 [!code-csharp[Classic SortedList.CopyTo Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic SortedList.CopyTo Example/CS/source.cs#1)]
 [!code-vb[Classic SortedList.CopyTo Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic SortedList.CopyTo Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="arrayIndex" /> é menor que zero.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="array" /> é multidimensional.  
  
- ou - 
O número de elementos no objeto de origem <see cref="T:System.Collections.SortedList" /> é maior do que o espaço disponível de <paramref name="arrayIndex" /> até o final do <paramref name="array" /> de destino.</exception>
        <exception cref="T:System.InvalidCastException">O tipo do <see cref="T:System.Collections.SortedList" /> de origem não pode ser automaticamente convertido para o tipo de <paramref name="array" /> de destino.</exception>
        <altmember cref="T:System.Array" />
        <altmember cref="T:System.Collections.DictionaryEntry" />
        <altmember cref="M:System.Collections.SortedList.GetEnumerator" />
      </Docs>
    </Member>
    <Member MemberName="Count">
      <MemberSignature Language="C#" Value="public virtual int Count { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Count" />
      <MemberSignature Language="DocId" Value="P:System.Collections.SortedList.Count" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property Count As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int Count { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Count : int" Usage="System.Collections.SortedList.Count" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.Count</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém o número de elementos contidos em um objeto <see cref="T:System.Collections.SortedList" />.</summary>
        <value>O número de elementos contidos no objeto <see cref="T:System.Collections.SortedList" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cada elemento é um par chave/valor que pode ser acessado como um <xref:System.Collections.DictionaryEntry> objeto.  
  
 <xref:System.Collections.SortedList.Capacity%2A> é o número de elementos que o <xref:System.Collections.SortedList> objeto pode armazenar. <xref:System.Collections.SortedList.Count%2A> é o número de elementos que estão realmente no <xref:System.Collections.SortedList>.  
  
 <xref:System.Collections.SortedList.Capacity%2A> é sempre maior que ou igual a <xref:System.Collections.SortedList.Count%2A>. Se <xref:System.Collections.SortedList.Count%2A> excede <xref:System.Collections.SortedList.Capacity%2A> durante a adição de elementos, a capacidade é aumentada automaticamente, realocando a matriz interna antes de copiar os elementos antigos e adição de novos elementos.  
  
 A recuperação do valor dessa propriedade é uma operação O(1).  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Collections.SortedList.Capacity" />
      </Docs>
    </Member>
    <Member MemberName="GetByIndex">
      <MemberSignature Language="C#" Value="public virtual object GetByIndex (int index);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object GetByIndex(int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.SortedList.GetByIndex(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetByIndex (index As Integer) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ GetByIndex(int index);" />
      <MemberSignature Language="F#" Value="abstract member GetByIndex : int -&gt; obj&#xA;override this.GetByIndex : int -&gt; obj" Usage="sortedList.GetByIndex index" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">O índice baseado em zero do valor a ser obtido.</param>
        <summary>Obtém o valor no índice especificado de um objeto <see cref="T:System.Collections.SortedList" />.</summary>
        <returns>O valor no índice especificado do objeto <see cref="T:System.Collections.SortedList" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A sequência de índice se baseia na sequência de classificação. Quando um elemento for adicionado, ele é inserido na <xref:System.Collections.SortedList> na classificação correta ordem e a indexação é ajustada de acordo. Quando um elemento for removido, a indexação também ajusta adequadamente. Portanto, o índice de um par chave/valor específicos pode mudar à medida que elementos são adicionados ou removidos do <xref:System.Collections.SortedList> objeto.  
  
 Este método é uma operação O(1).  
  
   
  
## Examples  
 O exemplo de código a seguir mostra como obter uma ou todas as chaves ou valores em uma <xref:System.Collections.SortedList> objeto.  
  
 [!code-cpp[Classic SortedList.GetByIndex Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic SortedList.GetByIndex Example/CPP/source.cpp#1)]
 [!code-csharp[Classic SortedList.GetByIndex Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic SortedList.GetByIndex Example/CS/source.cs#1)]
 [!code-vb[Classic SortedList.GetByIndex Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic SortedList.GetByIndex Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> está fora do intervalo de índices válidos para o objeto <see cref="T:System.Collections.SortedList" />.</exception>
        <altmember cref="M:System.Collections.SortedList.IndexOfKey(System.Object)" />
        <altmember cref="M:System.Collections.SortedList.IndexOfValue(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="GetEnumerator">
      <MemberSignature Language="C#" Value="public virtual System.Collections.IDictionaryEnumerator GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.IDictionaryEnumerator GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.SortedList.GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetEnumerator () As IDictionaryEnumerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Collections::IDictionaryEnumerator ^ GetEnumerator();" />
      <MemberSignature Language="F#" Value="abstract member GetEnumerator : unit -&gt; System.Collections.IDictionaryEnumerator&#xA;override this.GetEnumerator : unit -&gt; System.Collections.IDictionaryEnumerator" Usage="sortedList.GetEnumerator " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IDictionary.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IDictionaryEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retorna um objeto <see cref="T:System.Collections.IDictionaryEnumerator" /> que itera por um objeto <see cref="T:System.Collections.SortedList" />.</summary>
        <returns>Um objeto <see cref="T:System.Collections.IDictionaryEnumerator" /> para o objeto <see cref="T:System.Collections.SortedList" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O `foreach` instrução da linguagem c# (`for each` no Visual Basic) oculta a complexidade dos enumeradores.  Portanto, o uso de `foreach` é recomendado, em vez de manipular diretamente o enumerador.  
  
 Os enumeradores podem ser usados para ler os dados na coleção, mas não podem ser usados para modificar a coleção subjacente.  
  
 Inicialmente, o enumerador é posicionado antes do primeiro elemento da coleção. <xref:System.Collections.IEnumerator.Reset%2A> também traz o enumerador de volta para essa posição.  Nesta posição, <xref:System.Collections.IEnumerator.Current%2A> está indefinido. Por isso, você deve chamar <xref:System.Collections.IEnumerator.MoveNext%2A> para avançar o enumerador até o primeiro elemento da coleção antes de ler o valor de <xref:System.Collections.IEnumerator.Current%2A>.  
  
 <xref:System.Collections.IEnumerator.Current%2A> retorna o mesmo objeto até <xref:System.Collections.IEnumerator.MoveNext%2A> ou <xref:System.Collections.IEnumerator.Reset%2A> ser chamado. <xref:System.Collections.IEnumerator.MoveNext%2A> define <xref:System.Collections.IEnumerator.Current%2A> como o próximo elemento.  
  
 Caso <xref:System.Collections.IEnumerator.MoveNext%2A> passe o final da coleção, o enumerador é posicionado após o último elemento na coleção e <xref:System.Collections.IEnumerator.MoveNext%2A> retorna `false`. Quando o enumerador está nessa posição, as chamadas subsequentes para <xref:System.Collections.IEnumerator.MoveNext%2A> também retornam `false`. Caso a última chamada para <xref:System.Collections.IEnumerator.MoveNext%2A> tenha retornado `false`, <xref:System.Collections.IEnumerator.Current%2A> está indefinido. Para definir <xref:System.Collections.IEnumerator.Current%2A> como o primeiro elemento da coleção novamente, é possível chamar <xref:System.Collections.IEnumerator.Reset%2A> seguido de <xref:System.Collections.IEnumerator.MoveNext%2A>.  
  
 Um enumerador permanece válido desde que a coleção continue inalterada. Se forem feitas alterações na coleção, como adicionar, modificar ou excluir elementos, o enumerador será invalidado de maneira irrevogável e seu comportamento permanecerá indefinido.  
  
 O enumerador não tem acesso exclusivo à coleção; por isso, a enumeração por meio de uma coleção não é um procedimento thread-safe intrínseco.  Para garantir acesso thread-safe durante a enumeração, é possível bloquear a coleção durante toda a enumeração.  Para permitir que a coleção seja acessada por vários threads para leitura e gravação, você deve implementar sua própria sincronização.  
  
 Este método é uma operação O(1).  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.IDictionaryEnumerator" />
        <altmember cref="T:System.Collections.IEnumerator" />
      </Docs>
    </Member>
    <Member MemberName="GetKey">
      <MemberSignature Language="C#" Value="public virtual object GetKey (int index);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object GetKey(int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.SortedList.GetKey(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetKey (index As Integer) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ GetKey(int index);" />
      <MemberSignature Language="F#" Value="abstract member GetKey : int -&gt; obj&#xA;override this.GetKey : int -&gt; obj" Usage="sortedList.GetKey index" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">O índice de base zero da chave a ser obtida.</param>
        <summary>Obtém a chave no índice especificado de um objeto <see cref="T:System.Collections.SortedList" />.</summary>
        <returns>A chave no índice especificado do objeto <see cref="T:System.Collections.SortedList" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A sequência de índice se baseia na sequência de classificação. Quando um elemento for adicionado, ele é inserido na <xref:System.Collections.SortedList> na classificação correta ordem e a indexação é ajustada de acordo. Quando um elemento for removido, a indexação também ajusta adequadamente. Portanto, o índice de um par chave/valor específicos pode mudar à medida que elementos são adicionados ou removidos do <xref:System.Collections.SortedList> objeto.  
  
 Este método é uma operação O(1).  
  
   
  
## Examples  
 O exemplo de código a seguir mostra como obter uma ou todas as chaves ou valores em uma <xref:System.Collections.SortedList> objeto.  
  
 [!code-cpp[Classic SortedList.GetByIndex Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic SortedList.GetByIndex Example/CPP/source.cpp#1)]
 [!code-csharp[Classic SortedList.GetByIndex Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic SortedList.GetByIndex Example/CS/source.cs#1)]
 [!code-vb[Classic SortedList.GetByIndex Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic SortedList.GetByIndex Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> está fora do intervalo de índices válidos para o objeto <see cref="T:System.Collections.SortedList" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetKeyList">
      <MemberSignature Language="C#" Value="public virtual System.Collections.IList GetKeyList ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.IList GetKeyList() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.SortedList.GetKeyList" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetKeyList () As IList" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Collections::IList ^ GetKeyList();" />
      <MemberSignature Language="F#" Value="abstract member GetKeyList : unit -&gt; System.Collections.IList&#xA;override this.GetKeyList : unit -&gt; System.Collections.IList" Usage="sortedList.GetKeyList " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IList</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Obtém as chaves em um objeto <see cref="T:System.Collections.SortedList" />.</summary>
        <returns>Um objeto <see cref="T:System.Collections.IList" /> que contém as chaves no objeto <see cref="T:System.Collections.SortedList" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Retornado <xref:System.Collections.IList> objeto é uma exibição somente leitura das chaves do <xref:System.Collections.SortedList> objeto. As modificações feitas na subjacente <xref:System.Collections.SortedList> são refletidas imediatamente no <xref:System.Collections.IList>.  
  
 Os elementos de retornado <xref:System.Collections.IList> são classificados na mesma ordem que as chaves do <xref:System.Collections.SortedList>.  
  
 Esse método é semelhante para o <xref:System.Collections.SortedList.Keys%2A> propriedade, mas retorna um <xref:System.Collections.IList> do objeto, em vez de um <xref:System.Collections.ICollection> objeto.  
  
 Este método é uma operação O(1).  
  
   
  
## Examples  
 O exemplo de código a seguir mostra como obter uma ou todas as chaves ou valores em uma <xref:System.Collections.SortedList> objeto.  
  
 [!code-cpp[Classic SortedList.GetByIndex Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic SortedList.GetByIndex Example/CPP/source.cpp#1)]
 [!code-csharp[Classic SortedList.GetByIndex Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic SortedList.GetByIndex Example/CS/source.cs#1)]
 [!code-vb[Classic SortedList.GetByIndex Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic SortedList.GetByIndex Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.IList" />
        <altmember cref="M:System.Collections.SortedList.GetValueList" />
        <altmember cref="P:System.Collections.SortedList.Keys" />
      </Docs>
    </Member>
    <Member MemberName="GetValueList">
      <MemberSignature Language="C#" Value="public virtual System.Collections.IList GetValueList ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.IList GetValueList() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.SortedList.GetValueList" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetValueList () As IList" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Collections::IList ^ GetValueList();" />
      <MemberSignature Language="F#" Value="abstract member GetValueList : unit -&gt; System.Collections.IList&#xA;override this.GetValueList : unit -&gt; System.Collections.IList" Usage="sortedList.GetValueList " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IList</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Obtém os valores em um objeto <see cref="T:System.Collections.SortedList" />.</summary>
        <returns>Um objeto <see cref="T:System.Collections.IList" /> que contém os valores no objeto <see cref="T:System.Collections.SortedList" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Retornado <xref:System.Collections.IList> objeto é uma exibição somente leitura dos valores da <xref:System.Collections.SortedList> objeto. As modificações feitas na subjacente <xref:System.Collections.SortedList> são refletidas imediatamente no <xref:System.Collections.IList>.  
  
 Os elementos de retornado <xref:System.Collections.IList> são classificados na mesma ordem que os valores da <xref:System.Collections.SortedList>.  
  
 Esse método é semelhante para o <xref:System.Collections.SortedList.Values%2A> propriedade, mas retorna um <xref:System.Collections.IList> do objeto, em vez de um <xref:System.Collections.ICollection> objeto.  
  
 Este método é uma operação O(1).  
  
   
  
## Examples  
 O exemplo de código a seguir mostra como obter uma ou todas as chaves ou valores em uma <xref:System.Collections.SortedList> objeto.  
  
 [!code-cpp[Classic SortedList.GetByIndex Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic SortedList.GetByIndex Example/CPP/source.cpp#1)]
 [!code-csharp[Classic SortedList.GetByIndex Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic SortedList.GetByIndex Example/CS/source.cs#1)]
 [!code-vb[Classic SortedList.GetByIndex Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic SortedList.GetByIndex Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.IList" />
        <altmember cref="M:System.Collections.SortedList.GetKeyList" />
        <altmember cref="P:System.Collections.SortedList.Values" />
      </Docs>
    </Member>
    <Member MemberName="IndexOfKey">
      <MemberSignature Language="C#" Value="public virtual int IndexOfKey (object key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 IndexOfKey(object key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.SortedList.IndexOfKey(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function IndexOfKey (key As Object) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int IndexOfKey(System::Object ^ key);" />
      <MemberSignature Language="F#" Value="abstract member IndexOfKey : obj -&gt; int&#xA;override this.IndexOfKey : obj -&gt; int" Usage="sortedList.IndexOfKey key" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="key">A chave a ser localizada no objeto <see cref="T:System.Collections.SortedList" />.</param>
        <summary>Retorna o índice baseado em zero da chave especificada em um objeto <see cref="T:System.Collections.SortedList" />.</summary>
        <returns>O índice baseado em zero do parâmetro <paramref name="key" />, se <paramref name="key" /> for encontrado no objeto <see cref="T:System.Collections.SortedList" />; caso contrário, -1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Os elementos de uma <xref:System.Collections.SortedList> objeto são classificados pelas chaves de qualquer um de acordo com um determinado <xref:System.Collections.IComparer> implementação especificado quando o <xref:System.Collections.SortedList> é criado, ou de acordo com o <xref:System.IComparable> implementação fornecida pelas chaves em si.  
  
 A sequência de índice se baseia na sequência de classificação. Quando um elemento for adicionado, ele é inserido na <xref:System.Collections.SortedList> na classificação correta ordem e a indexação é ajustada de acordo. Quando um elemento for removido, a indexação também ajusta adequadamente. Portanto, o índice de um par chave/valor específicos pode mudar à medida que elementos são adicionados ou removidos do <xref:System.Collections.SortedList>.  
  
 Esse método usa um algoritmo de pesquisa binária; Portanto, esse método é um O (log `n`) a operação, onde `n` é <xref:System.Collections.SortedList.Count%2A>.  
  
 Começando pelo .NET Framework 2.0, esse método usa os métodos <xref:System.Object.Equals%2A> e <xref:System.IComparable.CompareTo%2A> do objeto da coleção em `item` para determinar se o item existe. Em versões anteriores do .NET Framework, essa decisão era tomada usando-se os métodos <xref:System.Object.Equals%2A> e <xref:System.IComparable.CompareTo%2A> do parâmetro `item` nos objetos na coleção.  
  
   
  
## Examples  
 O exemplo de código a seguir mostra como determinar o índice de uma chave ou um valor em uma <xref:System.Collections.SortedList> objeto.  
  
 [!code-cpp[Classic SortedList.IndexOfKey Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic SortedList.IndexOfKey Example/CPP/source.cpp#1)]
 [!code-csharp[Classic SortedList.IndexOfKey Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic SortedList.IndexOfKey Example/CS/source.cs#1)]
 [!code-vb[Classic SortedList.IndexOfKey Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic SortedList.IndexOfKey Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="key" /> é <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">O comparador gera uma exceção.</exception>
        <altmember cref="M:System.Collections.SortedList.ContainsKey(System.Object)" />
        <altmember cref="M:System.Collections.SortedList.IndexOfValue(System.Object)" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-collections.md">Executando operações de cadeia de caracteres que não levam em conta a cultura em coleções</related>
      </Docs>
    </Member>
    <Member MemberName="IndexOfValue">
      <MemberSignature Language="C#" Value="public virtual int IndexOfValue (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 IndexOfValue(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.SortedList.IndexOfValue(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function IndexOfValue (value As Object) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int IndexOfValue(System::Object ^ value);" />
      <MemberSignature Language="F#" Value="abstract member IndexOfValue : obj -&gt; int&#xA;override this.IndexOfValue : obj -&gt; int" Usage="sortedList.IndexOfValue value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">O valor a ser localizado no objeto <see cref="T:System.Collections.SortedList" />. O valor pode ser <see langword="null" />.</param>
        <summary>Retorna o índice baseado em zero da primeira ocorrência do valor especificado em um objeto <see cref="T:System.Collections.SortedList" />.</summary>
        <returns>O índice baseado em zero da primeira ocorrência do parâmetro <paramref name="value" />, se <paramref name="value" /> for encontrado no objeto <see cref="T:System.Collections.SortedList" />; caso contrário, -1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A sequência de índice se baseia na sequência de classificação. Quando um elemento for adicionado, ele é inserido na <xref:System.Collections.SortedList> na classificação correta ordem e a indexação é ajustada de acordo. Quando um elemento for removido, a indexação também ajusta adequadamente. Portanto, o índice de um par chave/valor específicos pode mudar à medida que elementos são adicionados ou removidos do <xref:System.Collections.SortedList> objeto.  
  
 Os valores dos elementos dos <xref:System.Collections.SortedList> são comparados com o valor especificado usando o <xref:System.Object.Equals%2A> método.  
  
 Esse método usa uma pesquisa linear. Portanto, esse método é um O (`n`) a operação, onde `n` é <xref:System.Collections.SortedList.Count%2A>.  
  
 Começando pelo .NET Framework 2.0, esse método usa os métodos <xref:System.Object.Equals%2A> e <xref:System.IComparable.CompareTo%2A> do objeto da coleção em `item` para determinar se o item existe. Em versões anteriores do .NET Framework, essa decisão era tomada usando-se os métodos <xref:System.Object.Equals%2A> e <xref:System.IComparable.CompareTo%2A> do parâmetro `item` nos objetos na coleção.  
  
   
  
## Examples  
 O exemplo de código a seguir mostra como determinar o índice de uma chave ou um valor em uma <xref:System.Collections.SortedList> objeto.  
  
 [!code-cpp[Classic SortedList.IndexOfKey Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic SortedList.IndexOfKey Example/CPP/source.cpp#1)]
 [!code-csharp[Classic SortedList.IndexOfKey Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic SortedList.IndexOfKey Example/CS/source.cs#1)]
 [!code-vb[Classic SortedList.IndexOfKey Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic SortedList.IndexOfKey Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Collections.SortedList.ContainsValue(System.Object)" />
        <altmember cref="M:System.Collections.SortedList.IndexOfKey(System.Object)" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-collections.md">Executando operações de cadeia de caracteres que não levam em conta a cultura em coleções</related>
      </Docs>
    </Member>
    <Member MemberName="IsFixedSize">
      <MemberSignature Language="C#" Value="public virtual bool IsFixedSize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsFixedSize" />
      <MemberSignature Language="DocId" Value="P:System.Collections.SortedList.IsFixedSize" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsFixedSize As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsFixedSize { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsFixedSize : bool" Usage="System.Collections.SortedList.IsFixedSize" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IDictionary.IsFixedSize</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém um valor que indica se o objeto <see cref="T:System.Collections.SortedList" /> tem um tamanho fixo.</summary>
        <value>
          <see langword="true" /> Se o <see cref="T:System.Collections.SortedList" /> objeto tem um fixo; caso contrário, <see langword="false" />. O padrão é <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Uma coleção com um tamanho fixo não permite a adição ou remoção de elementos após a coleção é criada, mas permitir a modificação de elementos existentes.  
  
 Uma coleção com um tamanho fixo é simplesmente uma coleção com um wrapper que impede a adição e a remoção de elementos; por isso, caso as alterações sejam feitas na coleção subjacente, inclusive a adição ou a remoção de elementos, a coleção de tamanho fixo reflete essas alterações.  
  
 A recuperação do valor dessa propriedade é uma operação O(1).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsReadOnly">
      <MemberSignature Language="C#" Value="public virtual bool IsReadOnly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsReadOnly" />
      <MemberSignature Language="DocId" Value="P:System.Collections.SortedList.IsReadOnly" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsReadOnly As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsReadOnly { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsReadOnly : bool" Usage="System.Collections.SortedList.IsReadOnly" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IDictionary.IsReadOnly</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém um valor que indica se um objeto <see cref="T:System.Collections.SortedList" /> é somente leitura.</summary>
        <value>
          <see langword="true" /> se o objeto <see cref="T:System.Collections.SortedList" /> for somente leitura; caso contrário, <see langword="false" />. O padrão é <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Uma coleção que seja somente leitura não permite a adição, a remoção ou a modificação de elementos após a coleção ser criada.  
  
 Uma coleção somente leitura é apenas uma coleção com um wrapper que impede a modificação da coleção; por isso, caso as alterações sejam feitas na coleção subjacente, a coleção somente leitura reflete as alterações.  
  
 A recuperação do valor dessa propriedade é uma operação O(1).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsSynchronized">
      <MemberSignature Language="C#" Value="public virtual bool IsSynchronized { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSynchronized" />
      <MemberSignature Language="DocId" Value="P:System.Collections.SortedList.IsSynchronized" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsSynchronized As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSynchronized { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSynchronized : bool" Usage="System.Collections.SortedList.IsSynchronized" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.IsSynchronized</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém um valor que indica se o acesso a um objeto <see cref="T:System.Collections.SortedList" /> é sincronizado (thread-safe).</summary>
        <value>
          <see langword="true" /> Se acessar para o <see cref="T:System.Collections.SortedList" /> objeto é sincronizado (thread-safe); caso contrário, <see langword="false" />. O padrão é <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para garantir a segurança de segmentos de uma <xref:System.Collections.SortedList> do objeto, todas as operações devem ser feitas por meio de wrapper retornado pelo <xref:System.Collections.SortedList.Synchronized%2A> método.  
  
 A enumeração por meio de uma coleção não é um procedimento thread-safe intrínseco. Mesmo quando uma coleção está sincronizada, outros threads ainda podem modificar a coleção, o que faz o enumerador lançar uma exceção. Para garantir thread-safe durante a enumeração, é possível bloquear a coleção durante toda a enumeração ou verificar as exceções resultantes das alterações feitas por outros threads.  
  
   
  
## Examples  
 O exemplo de código a seguir mostra como bloquear uma coleção usando o <xref:System.Collections.SortedList.SyncRoot%2A> propriedade durante toda a enumeração.  
  
 [!code-cpp[Classic SortedList.IsSynchronized Example#2](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic SortedList.IsSynchronized Example/CPP/source2.cpp#2)]
 [!code-csharp[Classic SortedList.IsSynchronized Example#2](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic SortedList.IsSynchronized Example/CS/source2.cs#2)]
 [!code-vb[Classic SortedList.IsSynchronized Example#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic SortedList.IsSynchronized Example/VB/source2.vb#2)]  
  
 A recuperação do valor dessa propriedade é uma operação O(1).  
  
 O exemplo de código a seguir mostra como sincronizar um <xref:System.Collections.SortedList> do objeto, determine se um <xref:System.Collections.SortedList> são sincronizados e usar um sincronizada <xref:System.Collections.SortedList>.  
  
 [!code-cpp[Classic SortedList.IsSynchronized Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic SortedList.IsSynchronized Example/CPP/source.cpp#1)]
 [!code-csharp[Classic SortedList.IsSynchronized Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic SortedList.IsSynchronized Example/CS/source.cs#1)]
 [!code-vb[Classic SortedList.IsSynchronized Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic SortedList.IsSynchronized Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Collections.SortedList.SyncRoot" />
        <altmember cref="M:System.Collections.SortedList.Synchronized(System.Collections.SortedList)" />
      </Docs>
    </Member>
    <Member MemberName="Item">
      <MemberSignature Language="C#" Value="public virtual object this[object key] { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object Item(object)" />
      <MemberSignature Language="DocId" Value="P:System.Collections.SortedList.Item(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Default Public Overridable Property Item(key As Object) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Object ^ default[System::Object ^] { System::Object ^ get(System::Object ^ key); void set(System::Object ^ key, System::Object ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Item(obj) : obj with get, set" Usage="System.Collections.SortedList.Item" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IDictionary.Item(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="key">A chave associada com o valor a ser obtido ou definido.</param>
        <summary>Obtém e define o valor associado com uma chave específica em um objeto <see cref="T:System.Collections.SortedList" />.</summary>
        <value>O valor associado ao parâmetro <paramref name="key" /> no objeto <see cref="T:System.Collections.SortedList" /> se <paramref name="key" /> for localizado; caso contrário, <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Você pode usar o <xref:System.Collections.SortedList.Item%2A> propriedade para acessar um elemento específico em uma coleção, especificando a seguinte sintaxe: `myCollection[key]`.  
  
 Você também pode usar essa propriedade para adicionar novos elementos ao definir o valor de uma chave que não existe na <xref:System.Collections.SortedList> objeto (por exemplo, `myCollection["myNonexistentKey"] = myValue)`. No entanto, se a chave especificada já existe na <xref:System.Collections.SortedList>, definindo o <xref:System.Collections.SortedList.Item%2A> propriedade substitui o valor antigo. Em contraste, o <xref:System.Collections.SortedList.Add%2A> método não modifica os elementos existentes.  
  
 Uma chave não pode ser `null`, mas um valor pode ser. Para distinguir `null` que é retornado porque a chave especificada não for encontrada e `null` que é retornado porque o valor da chave especificada é `null`, use o <xref:System.Collections.SortedList.Contains%2A> método ou o <xref:System.Collections.SortedList.ContainsKey%2A> método para determinar se a chave existe na lista.  
  
 Os elementos de uma <xref:System.Collections.SortedList> são classificados pelas chaves de qualquer um de acordo com um determinado <xref:System.Collections.IComparer> implementação especificado quando o <xref:System.Collections.SortedList> é criado ou de acordo com o <xref:System.IComparable> implementação fornecida pelas chaves em si.  
  
 A linguagem c# usa a palavra-chave para definir os indexadores em vez de implementar o <xref:System.Collections.SortedList.Keys%2A> propriedade. Visual Basic implementa <xref:System.Collections.SortedList.Item%2A> como uma propriedade padrão, que fornece a mesma funcionalidade de indexação.  
  
 Recuperando o valor dessa propriedade é um O (log `n`) a operação, onde `n` é <xref:System.Collections.SortedList.Count%2A>. Configuração da propriedade é um O (log `n`) operação se a chave já está no <xref:System.Collections.SortedList>. Se a chave não estiver na lista, a configuração da propriedade é um O (`n`) a operação para dados não classificados, ou O (log `n`) se o novo elemento é adicionado ao final da lista. Se a inserção faz com que um redimensionamento, a operação é O (`n`).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="key" /> é <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException">A propriedade é definida e o objeto <see cref="T:System.Collections.SortedList" /> é somente leitura.  
  
- ou - 
A propriedade é definida, <paramref name="key" /> não existe na coleção e o <see cref="T:System.Collections.SortedList" /> tem um tamanho fixo.</exception>
        <exception cref="T:System.OutOfMemoryException">Não há memória suficiente disponível para adicionar o elemento ao <see cref="T:System.Collections.SortedList" />.</exception>
        <exception cref="T:System.InvalidOperationException">O comparador gera uma exceção.</exception>
        <altmember cref="M:System.Collections.SortedList.Add(System.Object,System.Object)" />
        <altmember cref="M:System.Collections.SortedList.Contains(System.Object)" />
        <altmember cref="M:System.Collections.SortedList.ContainsKey(System.Object)" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-collections.md">Executando operações de cadeia de caracteres que não levam em conta a cultura em coleções</related>
      </Docs>
    </Member>
    <Member MemberName="Keys">
      <MemberSignature Language="C#" Value="public virtual System.Collections.ICollection Keys { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.ICollection Keys" />
      <MemberSignature Language="DocId" Value="P:System.Collections.SortedList.Keys" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property Keys As ICollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Collections::ICollection ^ Keys { System::Collections::ICollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Keys : System.Collections.ICollection" Usage="System.Collections.SortedList.Keys" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IDictionary.Keys</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ICollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém as chaves em um objeto <see cref="T:System.Collections.SortedList" />.</summary>
        <value>Um objeto <see cref="T:System.Collections.ICollection" /> que contém as chaves no objeto <see cref="T:System.Collections.SortedList" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Collections.ICollection> objeto é uma exibição somente leitura das chaves do <xref:System.Collections.SortedList> objeto. As modificações feitas na subjacente <xref:System.Collections.SortedList> são refletidas imediatamente no <xref:System.Collections.ICollection>.  
  
 Os elementos do <xref:System.Collections.ICollection> são classificados na mesma ordem que as chaves do <xref:System.Collections.SortedList>.  
  
 Esta propriedade é semelhante para o <xref:System.Collections.SortedList.GetKeyList%2A> método, mas retorna um <xref:System.Collections.ICollection> do objeto, em vez de um <xref:System.Collections.IList> objeto.  
  
 Este método é uma operação O(1).  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.ICollection" />
        <altmember cref="P:System.Collections.SortedList.Values" />
        <altmember cref="M:System.Collections.SortedList.GetKeyList" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-collections.md">Executando operações de cadeia de caracteres que não levam em conta a cultura em coleções</related>
      </Docs>
    </Member>
    <Member MemberName="Remove">
      <MemberSignature Language="C#" Value="public virtual void Remove (object key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Remove(object key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.SortedList.Remove(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Remove (key As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Remove(System::Object ^ key);" />
      <MemberSignature Language="F#" Value="abstract member Remove : obj -&gt; unit&#xA;override this.Remove : obj -&gt; unit" Usage="sortedList.Remove key" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IDictionary.Remove(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="key">A chave do elemento a ser removido.</param>
        <summary>Remove o elemento com a chave especificada de um objeto <see cref="T:System.Collections.SortedList" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se o <xref:System.Collections.SortedList> objeto não contém um elemento com a chave especificada, o <xref:System.Collections.SortedList> permanece inalterado. Nenhuma exceção é lançada.  
  
 Em coleções de elementos contíguos, como listas, os elementos que seguem o elemento removido sobem para ocupar o ponto vazio. Caso a coleção seja indexada, os índices dos elementos que são movidos também são atualizados. Este comportamento não se aplica às coleções em que elementos sejam agrupados conceitualmente em buckets, como uma tabela de hash.  
  
 Este método é uma operação O(`n`), em que `n` é <xref:System.Collections.SortedList.Count%2A>.  
  
   
  
## Examples  
 O exemplo de código a seguir mostra como remover elementos de uma <xref:System.Collections.SortedList> objeto.  
  
 [!code-cpp[Classic SortedList.RemoveAt Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic SortedList.RemoveAt Example/CPP/source.cpp#1)]
 [!code-csharp[Classic SortedList.RemoveAt Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic SortedList.RemoveAt Example/CS/source.cs#1)]
 [!code-vb[Classic SortedList.RemoveAt Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic SortedList.RemoveAt Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="key" /> é <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException">O objeto <see cref="T:System.Collections.SortedList" /> é somente leitura.  
  
- ou - 
O <see cref="T:System.Collections.SortedList" /> tem um tamanho fixo.</exception>
        <altmember cref="M:System.Collections.SortedList.RemoveAt(System.Int32)" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-collections.md">Executando operações de cadeia de caracteres que não levam em conta a cultura em coleções</related>
      </Docs>
    </Member>
    <Member MemberName="RemoveAt">
      <MemberSignature Language="C#" Value="public virtual void RemoveAt (int index);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void RemoveAt(int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.SortedList.RemoveAt(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub RemoveAt (index As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void RemoveAt(int index);" />
      <MemberSignature Language="F#" Value="abstract member RemoveAt : int -&gt; unit&#xA;override this.RemoveAt : int -&gt; unit" Usage="sortedList.RemoveAt index" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">O índice de base zero do elemento a ser removido.</param>
        <summary>Remove o elemento no índice especificado de um objeto <see cref="T:System.Collections.SortedList" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A sequência de índice se baseia na sequência de classificação. Quando um elemento for adicionado, ele é inserido na <xref:System.Collections.SortedList> na classificação correta ordem e a indexação é ajustada de acordo. Quando um elemento for removido, a indexação também ajusta adequadamente. Portanto, o índice de um par chave/valor específicos pode mudar à medida que elementos são adicionados ou removidos do <xref:System.Collections.SortedList> objeto.  
  
 Em coleções de elementos contíguos, como listas, os elementos que seguem o elemento removido sobem para ocupar o ponto vazio. Caso a coleção seja indexada, os índices dos elementos que são movidos também são atualizados. Este comportamento não se aplica às coleções em que elementos sejam agrupados conceitualmente em buckets, como uma tabela de hash.  
  
 Este método é uma operação O(`n`), em que `n` é <xref:System.Collections.SortedList.Count%2A>.  
  
   
  
## Examples  
 O exemplo de código a seguir mostra como remover elementos de uma <xref:System.Collections.SortedList> objeto.  
  
 [!code-cpp[Classic SortedList.RemoveAt Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic SortedList.RemoveAt Example/CPP/source.cpp#1)]
 [!code-csharp[Classic SortedList.RemoveAt Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic SortedList.RemoveAt Example/CS/source.cs#1)]
 [!code-vb[Classic SortedList.RemoveAt Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic SortedList.RemoveAt Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> está fora do intervalo de índices válidos para o objeto <see cref="T:System.Collections.SortedList" />.</exception>
        <exception cref="T:System.NotSupportedException">O <see cref="T:System.Collections.SortedList" /> é somente leitura.  
  
- ou - 
O <see cref="T:System.Collections.SortedList" /> tem um tamanho fixo.</exception>
        <altmember cref="M:System.Collections.SortedList.Remove(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="SetByIndex">
      <MemberSignature Language="C#" Value="public virtual void SetByIndex (int index, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void SetByIndex(int32 index, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.SortedList.SetByIndex(System.Int32,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub SetByIndex (index As Integer, value As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void SetByIndex(int index, System::Object ^ value);" />
      <MemberSignature Language="F#" Value="abstract member SetByIndex : int * obj -&gt; unit&#xA;override this.SetByIndex : int * obj -&gt; unit" Usage="sortedList.SetByIndex (index, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="index">O índice baseado em zero no qual salvar <c>value</c>.</param>
        <param name="value">O <see cref="T:System.Object" /> a salvar no objeto <see cref="T:System.Collections.SortedList" />. O valor pode ser <see langword="null" />.</param>
        <summary>Substitui o valor em um índice específico em um objeto <see cref="T:System.Collections.SortedList" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A sequência de índice se baseia na sequência de classificação. Quando um elemento for adicionado, ele é inserido na <xref:System.Collections.SortedList> na classificação correta ordem e a indexação é ajustada de acordo. Quando um elemento for removido, a indexação também ajusta adequadamente. Portanto, o índice de um par chave/valor específicos pode mudar à medida que elementos são adicionados ou removidos do <xref:System.Collections.SortedList> objeto.  
  
 Este método é uma operação O(1).  
  
   
  
## Examples  
 O exemplo de código a seguir mostra como substituir o valor de um elemento existente em um <xref:System.Collections.SortedList> objeto.  
  
 [!code-cpp[Classic SortedList.SetByIndex Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic SortedList.SetByIndex Example/CPP/source.cpp#1)]
 [!code-csharp[Classic SortedList.SetByIndex Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic SortedList.SetByIndex Example/CS/source.cs#1)]
 [!code-vb[Classic SortedList.SetByIndex Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic SortedList.SetByIndex Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> está fora do intervalo de índices válidos para o objeto <see cref="T:System.Collections.SortedList" />.</exception>
        <altmember cref="M:System.Collections.SortedList.IndexOfKey(System.Object)" />
        <altmember cref="M:System.Collections.SortedList.IndexOfValue(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Synchronized">
      <MemberSignature Language="C#" Value="public static System.Collections.SortedList Synchronized (System.Collections.SortedList list);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.SortedList Synchronized(class System.Collections.SortedList list) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.SortedList.Synchronized(System.Collections.SortedList)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Synchronized (list As SortedList) As SortedList" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Collections::SortedList ^ Synchronized(System::Collections::SortedList ^ list);" />
      <MemberSignature Language="F#" Value="static member Synchronized : System.Collections.SortedList -&gt; System.Collections.SortedList" Usage="System.Collections.SortedList.Synchronized list" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.SortedList</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="list" Type="System.Collections.SortedList" />
      </Parameters>
      <Docs>
        <param name="list">O objeto <see cref="T:System.Collections.SortedList" /> a ser sincronizado.</param>
        <summary>Retorna o wrapper sincronizado (thread-safe) para um objeto <see cref="T:System.Collections.SortedList" />.</summary>
        <returns>Um wrapper sincronizado (thread-safe) para o objeto <see cref="T:System.Collections.SortedList" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para garantir a segurança do thread de um <xref:System.Collections.SortedList> do objeto, todas as operações devem ser feitas por meio de apenas esse wrapper.  
  
 A enumeração por meio de uma coleção não é um procedimento thread-safe intrínseco. Mesmo quando uma coleção está sincronizada, outros threads ainda podem modificar a coleção, o que faz o enumerador lançar uma exceção. Para garantir thread-safe durante a enumeração, é possível bloquear a coleção durante toda a enumeração ou verificar as exceções resultantes das alterações feitas por outros threads.  
  
   
  
## Examples  
 O exemplo de código a seguir mostra como bloquear a coleção usando o <xref:System.Collections.SortedList.SyncRoot%2A> propriedade durante toda a enumeração.  
  
 [!code-cpp[Classic SortedList.IsSynchronized Example#2](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic SortedList.IsSynchronized Example/CPP/source2.cpp#2)]
 [!code-csharp[Classic SortedList.IsSynchronized Example#2](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic SortedList.IsSynchronized Example/CS/source2.cs#2)]
 [!code-vb[Classic SortedList.IsSynchronized Example#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic SortedList.IsSynchronized Example/VB/source2.vb#2)]  
  
 Este método é uma operação O(1).  
  
 O exemplo de código a seguir mostra como sincronizar um <xref:System.Collections.SortedList> do objeto, determine se um <xref:System.Collections.SortedList> são sincronizados e usar um sincronizada <xref:System.Collections.SortedList>.  
  
 [!code-cpp[Classic SortedList.IsSynchronized Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic SortedList.IsSynchronized Example/CPP/source.cpp#1)]
 [!code-csharp[Classic SortedList.IsSynchronized Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic SortedList.IsSynchronized Example/CS/source.cs#1)]
 [!code-vb[Classic SortedList.IsSynchronized Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic SortedList.IsSynchronized Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="list" /> é <see langword="null" />.</exception>
        <altmember cref="P:System.Collections.SortedList.IsSynchronized" />
        <altmember cref="P:System.Collections.SortedList.SyncRoot" />
      </Docs>
    </Member>
    <Member MemberName="SyncRoot">
      <MemberSignature Language="C#" Value="public virtual object SyncRoot { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object SyncRoot" />
      <MemberSignature Language="DocId" Value="P:System.Collections.SortedList.SyncRoot" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property SyncRoot As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Object ^ SyncRoot { System::Object ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SyncRoot : obj" Usage="System.Collections.SortedList.SyncRoot" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.SyncRoot</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém um objeto que pode ser usado para sincronizar o acesso a um objeto <see cref="T:System.Collections.SortedList" />.</summary>
        <value>Um objeto que pode ser usado para sincronizar o acesso para o <see cref="T:System.Collections.SortedList" /> objeto.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para criar uma versão sincronizada do <xref:System.Collections.SortedList> do objeto, use o <xref:System.Collections.SortedList.Synchronized%2A> método. No entanto, as classes derivadas podem fornecer sua própria versão sincronizada do <xref:System.Collections.SortedList> usando o <xref:System.Collections.SortedList.SyncRoot%2A> propriedade. O código de sincronização necessário realizar operações na <xref:System.Collections.SortedList.SyncRoot%2A> do <xref:System.Collections.SortedList>, não diretamente no <xref:System.Collections.SortedList>. Isso garante a operação apropriada das coleções que são derivadas de outros objetos. Especificamente, ele mantém uma sincronização adequada com outros threads que podem ser simultaneamente modificando o <xref:System.Collections.SortedList> objeto.  
  
 A enumeração por meio de uma coleção não é um procedimento thread-safe intrínseco. Mesmo quando uma coleção está sincronizada, outros threads ainda podem modificar a coleção, o que faz o enumerador lançar uma exceção. Para garantir thread-safe durante a enumeração, é possível bloquear a coleção durante toda a enumeração ou verificar as exceções resultantes das alterações feitas por outros threads.  
  
   
  
## Examples  
 O exemplo de código a seguir mostra como bloquear a coleção usando o <xref:System.Collections.SortedList.SyncRoot%2A> propriedade durante toda a enumeração.  
  
 [!code-cpp[Classic SortedList.IsSynchronized Example#2](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic SortedList.IsSynchronized Example/CPP/source2.cpp#2)]
 [!code-csharp[Classic SortedList.IsSynchronized Example#2](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic SortedList.IsSynchronized Example/CS/source2.cs#2)]
 [!code-vb[Classic SortedList.IsSynchronized Example#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic SortedList.IsSynchronized Example/VB/source2.vb#2)]  
  
 A recuperação do valor dessa propriedade é uma operação O(1).  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Collections.SortedList.IsSynchronized" />
        <altmember cref="M:System.Collections.SortedList.Synchronized(System.Collections.SortedList)" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IEnumerable.GetEnumerator">
      <MemberSignature Language="C#" Value="System.Collections.IEnumerator IEnumerable.GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.SortedList.System#Collections#IEnumerable#GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Function GetEnumerator () As IEnumerator Implements IEnumerable.GetEnumerator" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::IEnumerator ^ System.Collections.IEnumerable.GetEnumerator() = System::Collections::IEnumerable::GetEnumerator;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IEnumerable.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retorna um <see cref="T:System.Collections.IEnumerator" /> que itera pelo <see cref="T:System.Collections.SortedList" />.</summary>
        <returns>Um <see cref="T:System.Collections.IEnumerator" /> para o <see cref="T:System.Collections.SortedList" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 [Visual Basic, C#]  
  
 O `foreach` instrução da linguagem c# (`for each` no Visual Basic) oculta a complexidade dos enumeradores.  Portanto, o uso de `foreach` é recomendado, em vez de manipular diretamente o enumerador.  
  
 Os enumeradores podem ser usados para ler os dados na coleção, mas não podem ser usados para modificar a coleção subjacente.  
  
 Inicialmente, o enumerador é posicionado antes do primeiro elemento da coleção. <xref:System.Collections.IEnumerator.Reset%2A> também traz o enumerador de volta para essa posição. AT isso posicionar, chamar <xref:System.Collections.IEnumerator.Current%2A> gera uma exceção. Por isso, você deve chamar <xref:System.Collections.IEnumerator.MoveNext%2A> para avançar o enumerador até o primeiro elemento da coleção antes de ler o valor de <xref:System.Collections.IEnumerator.Current%2A>.  
  
 <xref:System.Collections.IEnumerator.Current%2A> retorna o mesmo objeto até <xref:System.Collections.IEnumerator.MoveNext%2A> ou <xref:System.Collections.IEnumerator.Reset%2A> ser chamado. <xref:System.Collections.IEnumerator.MoveNext%2A> define <xref:System.Collections.IEnumerator.Current%2A> como o próximo elemento.  
  
 Caso <xref:System.Collections.IEnumerator.MoveNext%2A> passe o final da coleção, o enumerador é posicionado após o último elemento na coleção e <xref:System.Collections.IEnumerator.MoveNext%2A> retorna `false`. Quando o enumerador está nessa posição, as chamadas subsequentes para <xref:System.Collections.IEnumerator.MoveNext%2A> também retornam `false`. Se a última chamada para <xref:System.Collections.IEnumerator.MoveNext%2A> retornou `false`, chamar <xref:System.Collections.IEnumerator.Current%2A> gera uma exceção. Para definir <xref:System.Collections.IEnumerator.Current%2A> como o primeiro elemento da coleção novamente, é possível chamar <xref:System.Collections.IEnumerator.Reset%2A> seguido de <xref:System.Collections.IEnumerator.MoveNext%2A>.  
  
 Um enumerador permanece válido desde que a coleção continue inalterada. Se as alterações são feitas na coleção, como adicionar, modificar, ou excluir elementos, o enumerador é invalidado invalidado e a próxima chamada para <xref:System.Collections.IEnumerator.MoveNext%2A> ou <xref:System.Collections.IEnumerator.Reset%2A> lança um <xref:System.InvalidOperationException>. Se a coleção é modificada entre <xref:System.Collections.IEnumerator.MoveNext%2A> e <xref:System.Collections.IEnumerator.Current%2A>, <xref:System.Collections.IEnumerator.Current%2A> retorna o elemento que é definido como, mesmo se o enumerador já é invalidado.  
  
 O enumerador não tem acesso exclusivo à coleção; por isso, a enumeração por meio de uma coleção não é um procedimento thread-safe intrínseco. Mesmo quando uma coleção está sincronizada, outros threads ainda podem modificar a coleção, o que faz o enumerador lançar uma exceção. Para garantir thread-safe durante a enumeração, é possível bloquear a coleção durante toda a enumeração ou verificar as exceções resultantes das alterações feitas por outros threads.  
  
 Este método é uma operação O(1).  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.IDictionaryEnumerator" />
        <altmember cref="T:System.Collections.IEnumerator" />
      </Docs>
    </Member>
    <Member MemberName="TrimToSize">
      <MemberSignature Language="C#" Value="public virtual void TrimToSize ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void TrimToSize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.SortedList.TrimToSize" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub TrimToSize ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void TrimToSize();" />
      <MemberSignature Language="F#" Value="abstract member TrimToSize : unit -&gt; unit&#xA;override this.TrimToSize : unit -&gt; unit" Usage="sortedList.TrimToSize " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Define a capacidade para o número real de elementos em um objeto <see cref="T:System.Collections.SortedList" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método pode ser usado para minimizar a memória de uma coleção sobrecarga se nenhum elemento novo será adicionado à coleção.  
  
 Para redefinir uma <xref:System.Collections.SortedList> objeto para seu estado inicial, a chamada a <xref:System.Collections.SortedList.Clear%2A> método antes de chamar <xref:System.Collections.SortedList.TrimToSize%2A>. Cortar um vazio <xref:System.Collections.SortedList> define a capacidade do <xref:System.Collections.SortedList> para a capacidade padrão.  
  
 Este método é uma operação O(`n`), em que `n` é <xref:System.Collections.SortedList.Count%2A>.  
  
   
  
## Examples  
 O exemplo de código a seguir mostra como cortar as partes não usadas de uma <xref:System.Collections.SortedList> objeto e como limpar seus valores.  
  
 [!code-cpp[Classic SortedList.Clear Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic SortedList.Clear Example/CPP/source.cpp#1)]
 [!code-csharp[Classic SortedList.Clear Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic SortedList.Clear Example/CS/source.cs#1)]
 [!code-vb[Classic SortedList.Clear Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic SortedList.Clear Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">O objeto <see cref="T:System.Collections.SortedList" /> é somente leitura.  
  
- ou - 
O <see cref="T:System.Collections.SortedList" /> tem um tamanho fixo.</exception>
        <altmember cref="M:System.Collections.SortedList.Clear" />
        <altmember cref="P:System.Collections.SortedList.Capacity" />
        <altmember cref="P:System.Collections.SortedList.Count" />
      </Docs>
    </Member>
    <Member MemberName="Values">
      <MemberSignature Language="C#" Value="public virtual System.Collections.ICollection Values { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.ICollection Values" />
      <MemberSignature Language="DocId" Value="P:System.Collections.SortedList.Values" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property Values As ICollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Collections::ICollection ^ Values { System::Collections::ICollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Values : System.Collections.ICollection" Usage="System.Collections.SortedList.Values" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IDictionary.Values</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ICollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém os valores em um objeto <see cref="T:System.Collections.SortedList" />.</summary>
        <value>Um objeto <see cref="T:System.Collections.ICollection" /> que contém os valores no objeto <see cref="T:System.Collections.SortedList" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Collections.ICollection> objeto é uma exibição somente leitura dos valores da <xref:System.Collections.SortedList> objeto. As modificações feitas na subjacente <xref:System.Collections.SortedList> são refletidas imediatamente no <xref:System.Collections.ICollection>.  
  
 Os elementos do <xref:System.Collections.ICollection> são classificados na mesma ordem que os valores da <xref:System.Collections.SortedList>.  
  
 Esta propriedade é semelhante para o <xref:System.Collections.SortedList.GetValueList%2A> método, mas retorna um <xref:System.Collections.ICollection> do objeto, em vez de um <xref:System.Collections.IList> objeto.  
  
 Este método é uma operação O(1).  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.ICollection" />
        <altmember cref="P:System.Collections.SortedList.Keys" />
        <altmember cref="M:System.Collections.SortedList.GetValueList" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-collections.md">Executando operações de cadeia de caracteres que não levam em conta a cultura em coleções</related>
      </Docs>
    </Member>
  </Members>
</Type>