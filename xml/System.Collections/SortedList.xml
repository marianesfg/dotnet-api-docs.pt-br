<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="SortedList.xml" source-language="en-US" target-language="pt-BR">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-15c36f0" tool-company="Microsoft" />
      <xliffext:skl_file_name xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">02cd5861-7ce2-4a82-b358-31f8435a0ac5d3124b7bda8739a20a75d51b771ab675fd3a27c3.skl</xliffext:skl_file_name>
      <xliffext:version xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">1.2</xliffext:version>
      <xliffext:ms.openlocfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">d3124b7bda8739a20a75d51b771ab675fd3a27c3</xliffext:ms.openlocfilehash>
      <xliffext:ms.sourcegitcommit xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b</xliffext:ms.sourcegitcommit>
      <xliffext:ms.lasthandoff xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">04/03/2018</xliffext:ms.lasthandoff>
      <xliffext:moniker_ids xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">netcore-1.0,netcore-1.1,netcore-2.0,netcore-2.1,netframework-4.5.1,netframework-4.5.2,netframework-4.5,netframework-4.6.1,netframework-4.6.2,netframework-4.6,netframework-4.7.1,netframework-4.7,netstandard-2.0,xamarinandroid-7.1,xamarinios-10.8,xamarinmac-3.0</xliffext:moniker_ids>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve" uid="T:System.Collections.SortedList">
          <source>Represents a collection of key/value pairs that are sorted by the keys and are accessible by key and by index.</source>
          <target state="translated">Representa uma coleção de pares chave/valor que são classificados pelas chaves e são acessíveis por chave e por índice.</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.SortedList">
          <source>For the generic version of this collection, see <ph id="ph1">&lt;xref:System.Collections.Generic.SortedList%602?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Para obter a versão genérica dessa coleção, consulte <ph id="ph1">&lt;xref:System.Collections.Generic.SortedList%602?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.SortedList">
          <source>A <ph id="ph1">&lt;xref:System.Collections.SortedList&gt;</ph> element can be accessed by its key, like an element in any <ph id="ph2">&lt;xref:System.Collections.IDictionary&gt;</ph> implementation, or by its index, like an element in any <ph id="ph3">&lt;xref:System.Collections.IList&gt;</ph> implementation.</source>
          <target state="translated">Um <ph id="ph1">&lt;xref:System.Collections.SortedList&gt;</ph> elemento pode ser acessado por sua chave, como um elemento em qualquer <ph id="ph2">&lt;xref:System.Collections.IDictionary&gt;</ph> implementação, ou por seu índice, como um elemento em qualquer <ph id="ph3">&lt;xref:System.Collections.IList&gt;</ph> implementação.</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.SortedList">
          <source>A <ph id="ph1">&lt;xref:System.Collections.SortedList&gt;</ph> object internally maintains two arrays to store the elements of the list; that is, one array for the keys and another array for the associated values.</source>
          <target state="translated">Um <ph id="ph1">&lt;xref:System.Collections.SortedList&gt;</ph> objeto internamente mantém duas matrizes para armazenar os elementos da lista; ou seja, uma matriz para as chaves e outra matriz de valores associados.</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.SortedList">
          <source>Each element is a key/value pair that can be accessed as a <ph id="ph1">&lt;xref:System.Collections.DictionaryEntry&gt;</ph> object.</source>
          <target state="translated">Cada elemento é um par chave/valor que pode ser acessado como uma <ph id="ph1">&lt;xref:System.Collections.DictionaryEntry&gt;</ph> objeto.</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.SortedList">
          <source>A key cannot be <ph id="ph1">`null`</ph>, but a value can be.</source>
          <target state="translated">Uma chave não pode ser <ph id="ph1">`null`</ph>, mas pode ser um valor.</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.SortedList">
          <source>The capacity of a <ph id="ph1">&lt;xref:System.Collections.SortedList&gt;</ph> object is the number of elements the <ph id="ph2">&lt;xref:System.Collections.SortedList&gt;</ph> can hold.</source>
          <target state="translated">A capacidade de um <ph id="ph1">&lt;xref:System.Collections.SortedList&gt;</ph> objeto é o número de elementos de <ph id="ph2">&lt;xref:System.Collections.SortedList&gt;</ph> pode conter.</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.SortedList">
          <source>As elements are added to a <ph id="ph1">&lt;xref:System.Collections.SortedList&gt;</ph>, the capacity is automatically increased as required through reallocation.</source>
          <target state="translated">Como os elementos são adicionados a um <ph id="ph1">&lt;xref:System.Collections.SortedList&gt;</ph>, a capacidade é aumentada automaticamente conforme necessário por meio de realocação.</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.SortedList">
          <source>The capacity can be decreased by calling <ph id="ph1">&lt;xref:System.Collections.SortedList.TrimToSize%2A&gt;</ph> or by setting the <ph id="ph2">&lt;xref:System.Collections.SortedList.Capacity%2A&gt;</ph> property explicitly.</source>
          <target state="translated">A capacidade pode ser diminuída chamando <ph id="ph1">&lt;xref:System.Collections.SortedList.TrimToSize%2A&gt;</ph> ou definindo o <ph id="ph2">&lt;xref:System.Collections.SortedList.Capacity%2A&gt;</ph> propriedade explicitamente.</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.SortedList">
          <source>For very large <ph id="ph1">&lt;xref:System.Collections.SortedList&gt;</ph> objects, you can increase the maximum capacity to 2 billion elements on a 64-bit system by setting the <ph id="ph2">`enabled`</ph> attribute of the  configuration element to <ph id="ph3">`true`</ph> in the run-time environment.</source>
          <target state="translated">Para grandes <ph id="ph1">&lt;xref:System.Collections.SortedList&gt;</ph> objetos, você pode aumentar a capacidade máxima para 2 bilhões de elementos em um sistema de 64 bits definindo o <ph id="ph2">`enabled`</ph> atributo do elemento de configuração para <ph id="ph3">`true`</ph> no ambiente de tempo de execução.</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.SortedList">
          <source>The elements of a <ph id="ph1">&lt;xref:System.Collections.SortedList&gt;</ph> object are sorted by the keys either according to a specific <ph id="ph2">&lt;xref:System.Collections.IComparer&gt;</ph> implementation specified when the <ph id="ph3">&lt;xref:System.Collections.SortedList&gt;</ph> is created or according to the <ph id="ph4">&lt;xref:System.IComparable&gt;</ph> implementation provided by the keys themselves.</source>
          <target state="translated">Os elementos de um <ph id="ph1">&lt;xref:System.Collections.SortedList&gt;</ph> objeto são classificados pelas chaves de um acordo com um determinado <ph id="ph2">&lt;xref:System.Collections.IComparer&gt;</ph> implementação especificado quando o <ph id="ph3">&lt;xref:System.Collections.SortedList&gt;</ph> é criado ou acordo para o <ph id="ph4">&lt;xref:System.IComparable&gt;</ph> as próprias chaves a implementação.</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.SortedList">
          <source>In either case, a <ph id="ph1">&lt;xref:System.Collections.SortedList&gt;</ph> does not allow duplicate keys.</source>
          <target state="translated">Em ambos os casos, um <ph id="ph1">&lt;xref:System.Collections.SortedList&gt;</ph> não permitem chaves duplicadas.</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.SortedList">
          <source>The index sequence is based on the sort sequence.</source>
          <target state="translated">A sequência de índice é baseada na sequência de classificação.</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.SortedList">
          <source>When an element is added, it is inserted into <ph id="ph1">&lt;xref:System.Collections.SortedList&gt;</ph> in the correct sort order, and the indexing adjusts accordingly.</source>
          <target state="translated">Quando um elemento é adicionado, ele será inserido na <ph id="ph1">&lt;xref:System.Collections.SortedList&gt;</ph> na classificação correta ordem e a indexação é ajustada de acordo.</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.SortedList">
          <source>When an element is removed, the indexing also adjusts accordingly.</source>
          <target state="translated">Quando um elemento for removido, a indexação também se ajusta.</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.SortedList">
          <source>Therefore, the index of a specific key/value pair might change as elements are added or removed from the <ph id="ph1">&lt;xref:System.Collections.SortedList&gt;</ph> object.</source>
          <target state="translated">Portanto, o índice de um par chave/valor específico pode alterar como os elementos são adicionados ou removidos do <ph id="ph1">&lt;xref:System.Collections.SortedList&gt;</ph> objeto.</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.SortedList">
          <source>Operations on a <ph id="ph1">&lt;xref:System.Collections.SortedList&gt;</ph> object tend to be slower than operations on a <ph id="ph2">&lt;xref:System.Collections.Hashtable&gt;</ph> object because of the sorting.</source>
          <target state="translated">Operações em um <ph id="ph1">&lt;xref:System.Collections.SortedList&gt;</ph> objeto tendem a ser mais lento do que operações em um <ph id="ph2">&lt;xref:System.Collections.Hashtable&gt;</ph> objeto devido a classificação.</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.SortedList">
          <source>However, the <ph id="ph1">&lt;xref:System.Collections.SortedList&gt;</ph> offers more flexibility by allowing access to the values either through the associated keys or through the indexes.</source>
          <target state="translated">No entanto, o <ph id="ph1">&lt;xref:System.Collections.SortedList&gt;</ph> oferece mais flexibilidade ao permitir o acesso aos valores por meio das chaves associadas ou os índices.</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.SortedList">
          <source>Elements in this collection can be accessed using an integer index.</source>
          <target state="translated">Elementos nesta coleção podem ser acessados usando um índice de inteiro.</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.SortedList">
          <source>Indexes in this collection are zero-based.</source>
          <target state="translated">Índices nesta coleção são baseadas em zero.</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.SortedList">
          <source>The <ph id="ph1">`foreach`</ph> statement of the C# language (<ph id="ph2">`for each`</ph> in Visual Basic) returns an object of the type of the elements in the collection.</source>
          <target state="translated">O <ph id="ph1">`foreach`</ph> instrução de linguagem c# (<ph id="ph2">`for each`</ph> no Visual Basic) retorna um objeto do tipo dos elementos na coleção.</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.SortedList">
          <source>Since each element of the <ph id="ph1">&lt;xref:System.Collections.SortedList&gt;</ph> object is a key/value pair, the element type is not the type of the key or the type of the value.</source>
          <target state="translated">Desde que cada elemento do <ph id="ph1">&lt;xref:System.Collections.SortedList&gt;</ph> objeto é um par chave/valor, o tipo de elemento não é o tipo de chave ou o tipo do valor.</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.SortedList">
          <source>Rather, the element type is <ph id="ph1">&lt;xref:System.Collections.DictionaryEntry&gt;</ph>.</source>
          <target state="translated">Em vez disso, o tipo de elemento é <ph id="ph1">&lt;xref:System.Collections.DictionaryEntry&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.SortedList">
          <source>For example:</source>
          <target state="translated">Por exemplo:</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.SortedList">
          <source>The <ph id="ph1">`foreach`</ph> statement is a wrapper around the enumerator, which allows only reading from, not writing to, the collection.</source>
          <target state="translated">O <ph id="ph1">`foreach`</ph> instrução é um wrapper em torno de enumerador, que permite que somente leitura de não gravar à coleção.</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.SortedList">
          <source>The following code example shows how to create and initialize a <ph id="ph1">&lt;xref:System.Collections.SortedList&gt;</ph> object and how to print out its keys and values.</source>
          <target state="translated">O exemplo de código a seguir mostra como criar e inicializar uma <ph id="ph1">&lt;xref:System.Collections.SortedList&gt;</ph> objeto e como imprimir suas chaves e valores.</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.SortedList">
          <source>Public static (<ph id="ph1">&lt;see langword="Shared" /&gt;</ph> in Visual Basic) members of this type are thread safe.</source>
          <target state="translated">Os membros estáticos públicos (<ph id="ph1">&lt;see langword="Shared" /&gt;</ph> no Visual Basic) desse são thread-safe.</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.SortedList">
          <source>Any instance members are not guaranteed to be thread safe.</source>
          <target state="translated">Não há garantia de que qualquer membro de instância seja thread-safe.</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.SortedList">
          <source>A <ph id="ph1">&lt;see cref="T:System.Collections.SortedList" /&gt;</ph> object can support multiple readers concurrently, as long as the collection is not modified.</source>
          <target state="translated">Um <ph id="ph1">&lt;see cref="T:System.Collections.SortedList" /&gt;</ph> objeto pode dar suporte a vários leitores simultaneamente, desde que a coleção não é modificada.</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.SortedList">
          <source>To guarantee the thread safety of the <ph id="ph1">&lt;see cref="T:System.Collections.SortedList" /&gt;</ph>, all operations must be done through the wrapper returned by the <ph id="ph2">&lt;see cref="M:System.Collections.SortedList.Synchronized(System.Collections.SortedList)" /&gt;</ph> method.</source>
          <target state="translated">Para garantir a segurança de thread do <ph id="ph1">&lt;see cref="T:System.Collections.SortedList" /&gt;</ph>, todas as operações devem ser feitas por meio do wrapper retornado pelo <ph id="ph2">&lt;see cref="M:System.Collections.SortedList.Synchronized(System.Collections.SortedList)" /&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.SortedList">
          <source>Enumerating through a collection is intrinsically not a thread-safe procedure.</source>
          <target state="translated">A enumeração por meio de uma coleção não é um procedimento thread-safe intrínseco.</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.SortedList">
          <source>Even when a collection is synchronized, other threads can still modify the collection, which causes the enumerator to throw an exception.</source>
          <target state="translated">Mesmo quando uma coleção está sincronizada, outros threads ainda podem modificar a coleção, o que faz o enumerador lançar uma exceção.</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.SortedList">
          <source>To guarantee thread safety during enumeration, you can either lock the collection during the entire enumeration or catch the exceptions resulting from changes made by other threads.</source>
          <target state="translated">Para garantir thread-safe durante a enumeração, é possível bloquear a coleção durante toda a enumeração ou verificar as exceções resultantes das alterações feitas por outros threads.</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve" uid="T:System.Collections.SortedList">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Collections.SortedList" /&gt;</ph> class.</source>
          <target state="translated">Inicializa uma nova instância da classe <ph id="ph1">&lt;see cref="T:System.Collections.SortedList" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve" uid="M:System.Collections.SortedList.#ctor">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Collections.SortedList" /&gt;</ph> class that is empty, has the default initial capacity, and is sorted according to the <ph id="ph2">&lt;see cref="T:System.IComparable" /&gt;</ph> interface implemented by each key added to the <ph id="ph3">&lt;see cref="T:System.Collections.SortedList" /&gt;</ph> object.</source>
          <target state="translated">Inicializa uma nova instância da classe <ph id="ph1">&lt;see cref="T:System.Collections.SortedList" /&gt;</ph> que está vazia, tem a capacidade inicial padrão e é classificada de acordo com a interface <ph id="ph2">&lt;see cref="T:System.IComparable" /&gt;</ph> implementada por cada chave adicionada ao objeto <ph id="ph3">&lt;see cref="T:System.Collections.SortedList" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.SortedList.#ctor">
          <source>Each key must implement the <ph id="ph1">&lt;xref:System.IComparable&gt;</ph> interface to be capable of comparisons with every other key in the <ph id="ph2">&lt;xref:System.Collections.SortedList&gt;</ph> object.</source>
          <target state="translated">Cada chave deve implementar o <ph id="ph1">&lt;xref:System.IComparable&gt;</ph> interface devem ser capazes de comparações com todas as outras chaves no <ph id="ph2">&lt;xref:System.Collections.SortedList&gt;</ph> objeto.</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.SortedList.#ctor">
          <source>The elements are sorted according to the <ph id="ph1">&lt;xref:System.IComparable&gt;</ph> implementation of each key added to the <ph id="ph2">&lt;xref:System.Collections.SortedList&gt;</ph>.</source>
          <target state="translated">Os elementos são classificados de acordo com o <ph id="ph1">&lt;xref:System.IComparable&gt;</ph> implementação de cada chave adicionada para o <ph id="ph2">&lt;xref:System.Collections.SortedList&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.SortedList.#ctor">
          <source>The capacity of a <ph id="ph1">&lt;xref:System.Collections.SortedList&gt;</ph> object is the number of elements that the <ph id="ph2">&lt;xref:System.Collections.SortedList&gt;</ph> can hold.</source>
          <target state="translated">A capacidade de um <ph id="ph1">&lt;xref:System.Collections.SortedList&gt;</ph> objeto é o número de elementos que o <ph id="ph2">&lt;xref:System.Collections.SortedList&gt;</ph> pode conter.</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.SortedList.#ctor">
          <source>As elements are added to a <ph id="ph1">&lt;xref:System.Collections.SortedList&gt;</ph>, the capacity is automatically increased as required by reallocating the internal array.</source>
          <target state="translated">Como os elementos são adicionados a um <ph id="ph1">&lt;xref:System.Collections.SortedList&gt;</ph>, a capacidade é aumentada automaticamente conforme necessário ao realocar a matriz interna.</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.SortedList.#ctor">
          <source>If the size of the collection can be estimated, specifying the initial capacity eliminates the need to perform a number of resizing operations while adding elements to the <ph id="ph1">&lt;xref:System.Collections.SortedList&gt;</ph> object.</source>
          <target state="translated">Se o tamanho da coleção pode ser estimado, especificando a capacidade inicial elimina a necessidade de executar um número de operações de redimensionamento durante a adição de elementos para o <ph id="ph1">&lt;xref:System.Collections.SortedList&gt;</ph> objeto.</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.SortedList.#ctor">
          <source>This constructor is an O(1) operation.</source>
          <target state="translated">Este construtor é uma operação O(1).</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.SortedList.#ctor">
          <source>The following code example creates collections using different <ph id="ph1">&lt;xref:System.Collections.SortedList&gt;</ph> constructors and demonstrates the differences in the behavior of the collections.</source>
          <target state="translated">O exemplo de código a seguir cria coleções usando diferentes <ph id="ph1">&lt;xref:System.Collections.SortedList&gt;</ph> construtores e demonstra as diferenças no comportamento das coleções.</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve" uid="M:System.Collections.SortedList.#ctor(System.Collections.IComparer)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.IComparer" /&gt;</ph> implementation to use when comparing keys.</source>
          <target state="translated">A implementação de <ph id="ph1">&lt;see cref="T:System.Collections.IComparer" /&gt;</ph> a ser usada ao comparar chaves.</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve" uid="M:System.Collections.SortedList.#ctor(System.Collections.IComparer)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve" uid="M:System.Collections.SortedList.#ctor(System.Collections.IComparer)">
          <source><ph id="ph1">&lt;see langword="null" /&gt;</ph> to use the <ph id="ph2">&lt;see cref="T:System.IComparable" /&gt;</ph> implementation of each key.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="null" /&gt;</ph> para usar a implementação de <ph id="ph2">&lt;see cref="T:System.IComparable" /&gt;</ph> de cada chave.</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve" uid="M:System.Collections.SortedList.#ctor(System.Collections.IComparer)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Collections.SortedList" /&gt;</ph> class that is empty, has the default initial capacity, and is sorted according to the specified <ph id="ph2">&lt;see cref="T:System.Collections.IComparer" /&gt;</ph> interface.</source>
          <target state="translated">Inicializa uma nova instância da classe <ph id="ph1">&lt;see cref="T:System.Collections.SortedList" /&gt;</ph> que está vazia, tem a capacidade inicial padrão e é classificada de acordo com a interface <ph id="ph2">&lt;see cref="T:System.Collections.IComparer" /&gt;</ph> especificada.</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.SortedList.#ctor(System.Collections.IComparer)">
          <source>The elements are sorted according to the specified <ph id="ph1">&lt;xref:System.Collections.IComparer&gt;</ph> implementation.</source>
          <target state="translated">Os elementos são classificados de acordo com a especificada <ph id="ph1">&lt;xref:System.Collections.IComparer&gt;</ph> implementação.</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.SortedList.#ctor(System.Collections.IComparer)">
          <source>If the <ph id="ph1">`comparer`</ph> parameter is <ph id="ph2">`null`</ph>, the <ph id="ph3">&lt;xref:System.IComparable&gt;</ph> implementation of each key is used; therefore, each key must implement the <ph id="ph4">&lt;xref:System.IComparable&gt;</ph> interface to be capable of comparisons with every other key in the <ph id="ph5">&lt;xref:System.Collections.SortedList&gt;</ph> object.</source>
          <target state="translated">Se o <ph id="ph1">`comparer`</ph> parâmetro é <ph id="ph2">`null`</ph>, o <ph id="ph3">&lt;xref:System.IComparable&gt;</ph> implementação de cada chave é usada; portanto, cada chave deve implementar o <ph id="ph4">&lt;xref:System.IComparable&gt;</ph> interface devem ser capazes de comparações com todas as outras chaves no <ph id="ph5">&lt;xref:System.Collections.SortedList&gt;</ph> objeto.</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.SortedList.#ctor(System.Collections.IComparer)">
          <source>The capacity of a <ph id="ph1">&lt;xref:System.Collections.SortedList&gt;</ph> object is the number of elements that the <ph id="ph2">&lt;xref:System.Collections.SortedList&gt;</ph> can hold.</source>
          <target state="translated">A capacidade de um <ph id="ph1">&lt;xref:System.Collections.SortedList&gt;</ph> objeto é o número de elementos que o <ph id="ph2">&lt;xref:System.Collections.SortedList&gt;</ph> pode conter.</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.SortedList.#ctor(System.Collections.IComparer)">
          <source>As elements are added to a <ph id="ph1">&lt;xref:System.Collections.SortedList&gt;</ph>, the capacity is automatically increased as required by reallocating the internal array.</source>
          <target state="translated">Como os elementos são adicionados a um <ph id="ph1">&lt;xref:System.Collections.SortedList&gt;</ph>, a capacidade é aumentada automaticamente conforme necessário ao realocar a matriz interna.</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.SortedList.#ctor(System.Collections.IComparer)">
          <source>If the size of the collection can be estimated, specifying the initial capacity eliminates the need to perform a number of resizing operations while adding elements to the <ph id="ph1">&lt;xref:System.Collections.SortedList&gt;</ph> object.</source>
          <target state="translated">Se o tamanho da coleção pode ser estimado, especificando a capacidade inicial elimina a necessidade de executar um número de operações de redimensionamento durante a adição de elementos para o <ph id="ph1">&lt;xref:System.Collections.SortedList&gt;</ph> objeto.</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.SortedList.#ctor(System.Collections.IComparer)">
          <source>This constructor is an O(1) operation.</source>
          <target state="translated">Este construtor é uma operação O(1).</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.SortedList.#ctor(System.Collections.IComparer)">
          <source>The following code example creates collections using different <ph id="ph1">&lt;xref:System.Collections.SortedList&gt;</ph> constructors and demonstrates the differences in the behavior of the collections.</source>
          <target state="translated">O exemplo de código a seguir cria coleções usando diferentes <ph id="ph1">&lt;xref:System.Collections.SortedList&gt;</ph> construtores e demonstra as diferenças no comportamento das coleções.</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve" uid="M:System.Collections.SortedList.#ctor(System.Collections.IDictionary)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.IDictionary" /&gt;</ph> implementation to copy to a new <ph id="ph2">&lt;see cref="T:System.Collections.SortedList" /&gt;</ph> object.</source>
          <target state="translated">A implementação de <ph id="ph1">&lt;see cref="T:System.Collections.IDictionary" /&gt;</ph> para copiar para um novo objeto <ph id="ph2">&lt;see cref="T:System.Collections.SortedList" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve" uid="M:System.Collections.SortedList.#ctor(System.Collections.IDictionary)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Collections.SortedList" /&gt;</ph> class that contains elements copied from the specified dictionary, has the same initial capacity as the number of elements copied, and is sorted according to the <ph id="ph2">&lt;see cref="T:System.IComparable" /&gt;</ph> interface implemented by each key.</source>
          <target state="translated">Inicializa uma nova instância da classe <ph id="ph1">&lt;see cref="T:System.Collections.SortedList" /&gt;</ph> que contém elementos copiados do dicionário especificado, tem a mesma capacidade inicial que o número de elementos copiados e é classificada segundo a interface <ph id="ph2">&lt;see cref="T:System.IComparable" /&gt;</ph> implementada por cada chave.</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.SortedList.#ctor(System.Collections.IDictionary)">
          <source>Each key must implement the <ph id="ph1">&lt;xref:System.IComparable&gt;</ph> interface to be capable of comparisons with every other key in the <ph id="ph2">&lt;xref:System.Collections.SortedList&gt;</ph> object.</source>
          <target state="translated">Cada chave deve implementar o <ph id="ph1">&lt;xref:System.IComparable&gt;</ph> interface devem ser capazes de comparações com todas as outras chaves no <ph id="ph2">&lt;xref:System.Collections.SortedList&gt;</ph> objeto.</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.SortedList.#ctor(System.Collections.IDictionary)">
          <source>The elements are sorted according to the <ph id="ph1">&lt;xref:System.IComparable&gt;</ph> implementation of each key added to the <ph id="ph2">&lt;xref:System.Collections.SortedList&gt;</ph>.</source>
          <target state="translated">Os elementos são classificados de acordo com o <ph id="ph1">&lt;xref:System.IComparable&gt;</ph> implementação de cada chave adicionada para o <ph id="ph2">&lt;xref:System.Collections.SortedList&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.SortedList.#ctor(System.Collections.IDictionary)">
          <source>A <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> object is an example of an <ph id="ph2">&lt;xref:System.Collections.IDictionary&gt;</ph> implementation that can be passed to this constructor.</source>
          <target state="translated">Um <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> objeto é um exemplo de um <ph id="ph2">&lt;xref:System.Collections.IDictionary&gt;</ph> implementação que pode ser passada para o construtor.</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.SortedList.#ctor(System.Collections.IDictionary)">
          <source>The new <ph id="ph1">&lt;xref:System.Collections.SortedList&gt;</ph> object contains a copy of the keys and values stored in the <ph id="ph2">&lt;xref:System.Collections.Hashtable&gt;</ph>.</source>
          <target state="translated">O novo <ph id="ph1">&lt;xref:System.Collections.SortedList&gt;</ph> objeto contém uma cópia das chaves e valores armazenados no <ph id="ph2">&lt;xref:System.Collections.Hashtable&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.SortedList.#ctor(System.Collections.IDictionary)">
          <source>The capacity of a <ph id="ph1">&lt;xref:System.Collections.SortedList&gt;</ph> object is the number of elements that the <ph id="ph2">&lt;xref:System.Collections.SortedList&gt;</ph> can hold.</source>
          <target state="translated">A capacidade de um <ph id="ph1">&lt;xref:System.Collections.SortedList&gt;</ph> objeto é o número de elementos que o <ph id="ph2">&lt;xref:System.Collections.SortedList&gt;</ph> pode conter.</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.SortedList.#ctor(System.Collections.IDictionary)">
          <source>As elements are added to a <ph id="ph1">&lt;xref:System.Collections.SortedList&gt;</ph>, the capacity is automatically increased as required by reallocating the internal array.</source>
          <target state="translated">Como os elementos são adicionados a um <ph id="ph1">&lt;xref:System.Collections.SortedList&gt;</ph>, a capacidade é aumentada automaticamente conforme necessário ao realocar a matriz interna.</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.SortedList.#ctor(System.Collections.IDictionary)">
          <source>If the size of the collection can be estimated, specifying the initial capacity eliminates the need to perform a number of resizing operations while adding elements to the <ph id="ph1">&lt;xref:System.Collections.SortedList&gt;</ph> object.</source>
          <target state="translated">Se o tamanho da coleção pode ser estimado, especificando a capacidade inicial elimina a necessidade de executar um número de operações de redimensionamento durante a adição de elementos para o <ph id="ph1">&lt;xref:System.Collections.SortedList&gt;</ph> objeto.</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.SortedList.#ctor(System.Collections.IDictionary)">
          <source>This constructor is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is the number of elements in <ph id="ph3">`d`</ph>.</source>
          <target state="translated">Este construtor é um O (<ph id="ph1">`n`</ph>) operação, onde <ph id="ph2">`n`</ph> é o número de elementos em <ph id="ph3">`d`</ph>.</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.SortedList.#ctor(System.Collections.IDictionary)">
          <source>The following code example creates collections using different <ph id="ph1">&lt;xref:System.Collections.SortedList&gt;</ph> constructors and demonstrates the differences in the behavior of the collections.</source>
          <target state="translated">O exemplo de código a seguir cria coleções usando diferentes <ph id="ph1">&lt;xref:System.Collections.SortedList&gt;</ph> construtores e demonstra as diferenças no comportamento das coleções.</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve" uid="M:System.Collections.SortedList.#ctor(System.Collections.IDictionary)">
          <source><ph id="ph1">&lt;paramref name="d" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="d" /&gt;</ph> é <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve" uid="M:System.Collections.SortedList.#ctor(System.Collections.IDictionary)">
          <source>One or more elements in <ph id="ph1">&lt;paramref name="d" /&gt;</ph> do not implement the <ph id="ph2">&lt;see cref="T:System.IComparable" /&gt;</ph> interface.</source>
          <target state="translated">Um ou mais elementos em <ph id="ph1">&lt;paramref name="d" /&gt;</ph> não implementam a interface <ph id="ph2">&lt;see cref="T:System.IComparable" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve" uid="M:System.Collections.SortedList.#ctor(System.Int32)">
          <source>The initial number of elements that the <ph id="ph1">&lt;see cref="T:System.Collections.SortedList" /&gt;</ph> object can contain.</source>
          <target state="translated">O número inicial de elementos que o objeto <ph id="ph1">&lt;see cref="T:System.Collections.SortedList" /&gt;</ph> pode conter.</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve" uid="M:System.Collections.SortedList.#ctor(System.Int32)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Collections.SortedList" /&gt;</ph> class that is empty, has the specified initial capacity, and is sorted according to the <ph id="ph2">&lt;see cref="T:System.IComparable" /&gt;</ph> interface implemented by each key added to the <ph id="ph3">&lt;see cref="T:System.Collections.SortedList" /&gt;</ph> object.</source>
          <target state="translated">Inicializa uma nova instância da classe <ph id="ph1">&lt;see cref="T:System.Collections.SortedList" /&gt;</ph> que está vazia, tem a capacidade inicial especificada e é classificada de acordo com a interface <ph id="ph2">&lt;see cref="T:System.IComparable" /&gt;</ph> implementada por cada chave adicionada ao objeto <ph id="ph3">&lt;see cref="T:System.Collections.SortedList" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.SortedList.#ctor(System.Int32)">
          <source>Each key must implement the <ph id="ph1">&lt;xref:System.IComparable&gt;</ph> interface to be capable of comparisons with every other key in the <ph id="ph2">&lt;xref:System.Collections.SortedList&gt;</ph> object.</source>
          <target state="translated">Cada chave deve implementar o <ph id="ph1">&lt;xref:System.IComparable&gt;</ph> interface devem ser capazes de comparações com todas as outras chaves no <ph id="ph2">&lt;xref:System.Collections.SortedList&gt;</ph> objeto.</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.SortedList.#ctor(System.Int32)">
          <source>The elements are sorted according to the <ph id="ph1">&lt;xref:System.IComparable&gt;</ph> implementation of each key added to the <ph id="ph2">&lt;xref:System.Collections.SortedList&gt;</ph>.</source>
          <target state="translated">Os elementos são classificados de acordo com o <ph id="ph1">&lt;xref:System.IComparable&gt;</ph> implementação de cada chave adicionada para o <ph id="ph2">&lt;xref:System.Collections.SortedList&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.SortedList.#ctor(System.Int32)">
          <source>The capacity of a <ph id="ph1">&lt;xref:System.Collections.SortedList&gt;</ph> object is the number of elements that the <ph id="ph2">&lt;xref:System.Collections.SortedList&gt;</ph> can hold.</source>
          <target state="translated">A capacidade de um <ph id="ph1">&lt;xref:System.Collections.SortedList&gt;</ph> objeto é o número de elementos que o <ph id="ph2">&lt;xref:System.Collections.SortedList&gt;</ph> pode conter.</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.SortedList.#ctor(System.Int32)">
          <source>As elements are added to a <ph id="ph1">&lt;xref:System.Collections.SortedList&gt;</ph>, the capacity is automatically increased as required by reallocating the internal array.</source>
          <target state="translated">Como os elementos são adicionados a um <ph id="ph1">&lt;xref:System.Collections.SortedList&gt;</ph>, a capacidade é aumentada automaticamente conforme necessário ao realocar a matriz interna.</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.SortedList.#ctor(System.Int32)">
          <source>If the size of the collection can be estimated, specifying the initial capacity eliminates the need to perform a number of resizing operations while adding elements to the <ph id="ph1">&lt;xref:System.Collections.SortedList&gt;</ph> object.</source>
          <target state="translated">Se o tamanho da coleção pode ser estimado, especificando a capacidade inicial elimina a necessidade de executar um número de operações de redimensionamento durante a adição de elementos para o <ph id="ph1">&lt;xref:System.Collections.SortedList&gt;</ph> objeto.</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.SortedList.#ctor(System.Int32)">
          <source>This constructor is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is <ph id="ph3">`initialCapacity`</ph>.</source>
          <target state="translated">Este construtor é um O (<ph id="ph1">`n`</ph>) operação, onde <ph id="ph2">`n`</ph> é <ph id="ph3">`initialCapacity`</ph>.</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.SortedList.#ctor(System.Int32)">
          <source>The following code example creates collections using different <ph id="ph1">&lt;xref:System.Collections.SortedList&gt;</ph> constructors and demonstrates the differences in the behavior of the collections.</source>
          <target state="translated">O exemplo de código a seguir cria coleções usando diferentes <ph id="ph1">&lt;xref:System.Collections.SortedList&gt;</ph> construtores e demonstra as diferenças no comportamento das coleções.</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve" uid="M:System.Collections.SortedList.#ctor(System.Int32)">
          <source><ph id="ph1">&lt;paramref name="initialCapacity" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="initialCapacity" /&gt;</ph> é menor que zero.</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve" uid="M:System.Collections.SortedList.#ctor(System.Int32)">
          <source>There is not enough available memory to create a <ph id="ph1">&lt;see cref="T:System.Collections.SortedList" /&gt;</ph> object with the specified <ph id="ph2">&lt;paramref name="initialCapacity" /&gt;</ph>.</source>
          <target state="translated">Não há memória suficiente disponível para criar um objeto <ph id="ph1">&lt;see cref="T:System.Collections.SortedList" /&gt;</ph> com o <ph id="ph2">&lt;paramref name="initialCapacity" /&gt;</ph> especificado.</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve" uid="M:System.Collections.SortedList.#ctor(System.Collections.IComparer,System.Int32)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.IComparer" /&gt;</ph> implementation to use when comparing keys.</source>
          <target state="translated">A implementação de <ph id="ph1">&lt;see cref="T:System.Collections.IComparer" /&gt;</ph> a ser usada ao comparar chaves.</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve" uid="M:System.Collections.SortedList.#ctor(System.Collections.IComparer,System.Int32)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve" uid="M:System.Collections.SortedList.#ctor(System.Collections.IComparer,System.Int32)">
          <source><ph id="ph1">&lt;see langword="null" /&gt;</ph> to use the <ph id="ph2">&lt;see cref="T:System.IComparable" /&gt;</ph> implementation of each key.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="null" /&gt;</ph> para usar a implementação de <ph id="ph2">&lt;see cref="T:System.IComparable" /&gt;</ph> de cada chave.</target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve" uid="M:System.Collections.SortedList.#ctor(System.Collections.IComparer,System.Int32)">
          <source>The initial number of elements that the <ph id="ph1">&lt;see cref="T:System.Collections.SortedList" /&gt;</ph> object can contain.</source>
          <target state="translated">O número inicial de elementos que o objeto <ph id="ph1">&lt;see cref="T:System.Collections.SortedList" /&gt;</ph> pode conter.</target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve" uid="M:System.Collections.SortedList.#ctor(System.Collections.IComparer,System.Int32)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Collections.SortedList" /&gt;</ph> class that is empty, has the specified initial capacity, and is sorted according to the specified <ph id="ph2">&lt;see cref="T:System.Collections.IComparer" /&gt;</ph> interface.</source>
          <target state="translated">Inicializa uma nova instância da classe <ph id="ph1">&lt;see cref="T:System.Collections.SortedList" /&gt;</ph> que está vazia, tem a capacidade inicial especificada e é classificada de acordo com a interface <ph id="ph2">&lt;see cref="T:System.Collections.IComparer" /&gt;</ph> especificada.</target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.SortedList.#ctor(System.Collections.IComparer,System.Int32)">
          <source>The elements are sorted according to the specified <ph id="ph1">&lt;xref:System.Collections.IComparer&gt;</ph> implementation.</source>
          <target state="translated">Os elementos são classificados de acordo com a especificada <ph id="ph1">&lt;xref:System.Collections.IComparer&gt;</ph> implementação.</target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.SortedList.#ctor(System.Collections.IComparer,System.Int32)">
          <source>If the <ph id="ph1">`comparer`</ph> parameter is <ph id="ph2">`null`</ph>, the <ph id="ph3">&lt;xref:System.IComparable&gt;</ph> implementation of each key is used; therefore, each key must implement the <ph id="ph4">&lt;xref:System.IComparable&gt;</ph> interface to be capable of comparisons with every other key in the <ph id="ph5">&lt;xref:System.Collections.SortedList&gt;</ph> object.</source>
          <target state="translated">Se o <ph id="ph1">`comparer`</ph> parâmetro é <ph id="ph2">`null`</ph>, o <ph id="ph3">&lt;xref:System.IComparable&gt;</ph> implementação de cada chave é usada; portanto, cada chave deve implementar o <ph id="ph4">&lt;xref:System.IComparable&gt;</ph> interface devem ser capazes de comparações com todas as outras chaves no <ph id="ph5">&lt;xref:System.Collections.SortedList&gt;</ph> objeto.</target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.SortedList.#ctor(System.Collections.IComparer,System.Int32)">
          <source>The capacity of a <ph id="ph1">&lt;xref:System.Collections.SortedList&gt;</ph> object is the number of elements that the <ph id="ph2">&lt;xref:System.Collections.SortedList&gt;</ph> can hold.</source>
          <target state="translated">A capacidade de um <ph id="ph1">&lt;xref:System.Collections.SortedList&gt;</ph> objeto é o número de elementos que o <ph id="ph2">&lt;xref:System.Collections.SortedList&gt;</ph> pode conter.</target>       </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.SortedList.#ctor(System.Collections.IComparer,System.Int32)">
          <source>As elements are added to a <ph id="ph1">&lt;xref:System.Collections.SortedList&gt;</ph>, the capacity is automatically increased as required by reallocating the internal array.</source>
          <target state="translated">Como os elementos são adicionados a um <ph id="ph1">&lt;xref:System.Collections.SortedList&gt;</ph>, a capacidade é aumentada automaticamente conforme necessário ao realocar a matriz interna.</target>       </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.SortedList.#ctor(System.Collections.IComparer,System.Int32)">
          <source>If the size of the collection can be estimated, specifying the initial capacity eliminates the need to perform a number of resizing operations while adding elements to the <ph id="ph1">&lt;xref:System.Collections.SortedList&gt;</ph> object.</source>
          <target state="translated">Se o tamanho da coleção pode ser estimado, especificando a capacidade inicial elimina a necessidade de executar um número de operações de redimensionamento durante a adição de elementos para o <ph id="ph1">&lt;xref:System.Collections.SortedList&gt;</ph> objeto.</target>       </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.SortedList.#ctor(System.Collections.IComparer,System.Int32)">
          <source>This constructor is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is <ph id="ph3">`capacity`</ph>.</source>
          <target state="translated">Este construtor é um O (<ph id="ph1">`n`</ph>) operação, onde <ph id="ph2">`n`</ph> é <ph id="ph3">`capacity`</ph>.</target>       </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.SortedList.#ctor(System.Collections.IComparer,System.Int32)">
          <source>The following code example creates collections using different <ph id="ph1">&lt;xref:System.Collections.SortedList&gt;</ph> constructors and demonstrates the differences in the behavior of the collections.</source>
          <target state="translated">O exemplo de código a seguir cria coleções usando diferentes <ph id="ph1">&lt;xref:System.Collections.SortedList&gt;</ph> construtores e demonstra as diferenças no comportamento das coleções.</target>       </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve" uid="M:System.Collections.SortedList.#ctor(System.Collections.IComparer,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="capacity" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="capacity" /&gt;</ph> é menor que zero.</target>       </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve" uid="M:System.Collections.SortedList.#ctor(System.Collections.IComparer,System.Int32)">
          <source>There is not enough available memory to create a <ph id="ph1">&lt;see cref="T:System.Collections.SortedList" /&gt;</ph> object with the specified <ph id="ph2">&lt;paramref name="capacity" /&gt;</ph>.</source>
          <target state="translated">Não há memória suficiente disponível para criar um objeto <ph id="ph1">&lt;see cref="T:System.Collections.SortedList" /&gt;</ph> com o <ph id="ph2">&lt;paramref name="capacity" /&gt;</ph> especificado.</target>       </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve" uid="M:System.Collections.SortedList.#ctor(System.Collections.IDictionary,System.Collections.IComparer)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.IDictionary" /&gt;</ph> implementation to copy to a new <ph id="ph2">&lt;see cref="T:System.Collections.SortedList" /&gt;</ph> object.</source>
          <target state="translated">A implementação de <ph id="ph1">&lt;see cref="T:System.Collections.IDictionary" /&gt;</ph> para copiar para um novo objeto <ph id="ph2">&lt;see cref="T:System.Collections.SortedList" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve" uid="M:System.Collections.SortedList.#ctor(System.Collections.IDictionary,System.Collections.IComparer)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.IComparer" /&gt;</ph> implementation to use when comparing keys.</source>
          <target state="translated">A implementação de <ph id="ph1">&lt;see cref="T:System.Collections.IComparer" /&gt;</ph> a ser usada ao comparar chaves.</target>       </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve" uid="M:System.Collections.SortedList.#ctor(System.Collections.IDictionary,System.Collections.IComparer)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve" uid="M:System.Collections.SortedList.#ctor(System.Collections.IDictionary,System.Collections.IComparer)">
          <source><ph id="ph1">&lt;see langword="null" /&gt;</ph> to use the <ph id="ph2">&lt;see cref="T:System.IComparable" /&gt;</ph> implementation of each key.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="null" /&gt;</ph> para usar a implementação de <ph id="ph2">&lt;see cref="T:System.IComparable" /&gt;</ph> de cada chave.</target>       </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve" uid="M:System.Collections.SortedList.#ctor(System.Collections.IDictionary,System.Collections.IComparer)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Collections.SortedList" /&gt;</ph> class that contains elements copied from the specified dictionary, has the same initial capacity as the number of elements copied, and is sorted according to the specified <ph id="ph2">&lt;see cref="T:System.Collections.IComparer" /&gt;</ph> interface.</source>
          <target state="translated">Inicializa uma nova instância da classe <ph id="ph1">&lt;see cref="T:System.Collections.SortedList" /&gt;</ph> que contém elementos copiados do dicionário especificado, tem a mesma capacidade inicial que o número de elementos copiados e é classificada segundo a interface <ph id="ph2">&lt;see cref="T:System.Collections.IComparer" /&gt;</ph> especificada.</target>       </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.SortedList.#ctor(System.Collections.IDictionary,System.Collections.IComparer)">
          <source>The elements are sorted according to the specified <ph id="ph1">&lt;xref:System.Collections.IComparer&gt;</ph> implementation.</source>
          <target state="translated">Os elementos são classificados de acordo com a especificada <ph id="ph1">&lt;xref:System.Collections.IComparer&gt;</ph> implementação.</target>       </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.SortedList.#ctor(System.Collections.IDictionary,System.Collections.IComparer)">
          <source>If the <ph id="ph1">`comparer`</ph> parameter is <ph id="ph2">`null`</ph>, the <ph id="ph3">&lt;xref:System.IComparable&gt;</ph> implementation of each key is used; therefore, each key must implement the <ph id="ph4">&lt;xref:System.IComparable&gt;</ph> interface to be capable of comparisons with every other key in the <ph id="ph5">&lt;xref:System.Collections.SortedList&gt;</ph> object.</source>
          <target state="translated">Se o <ph id="ph1">`comparer`</ph> parâmetro é <ph id="ph2">`null`</ph>, o <ph id="ph3">&lt;xref:System.IComparable&gt;</ph> implementação de cada chave é usada; portanto, cada chave deve implementar o <ph id="ph4">&lt;xref:System.IComparable&gt;</ph> interface devem ser capazes de comparações com todas as outras chaves no <ph id="ph5">&lt;xref:System.Collections.SortedList&gt;</ph> objeto.</target>       </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.SortedList.#ctor(System.Collections.IDictionary,System.Collections.IComparer)">
          <source>A <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> object is an example of an <ph id="ph2">&lt;xref:System.Collections.IDictionary&gt;</ph> implementation that can be passed to this constructor.</source>
          <target state="translated">Um <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> objeto é um exemplo de um <ph id="ph2">&lt;xref:System.Collections.IDictionary&gt;</ph> implementação que pode ser passada para o construtor.</target>       </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.SortedList.#ctor(System.Collections.IDictionary,System.Collections.IComparer)">
          <source>The new <ph id="ph1">&lt;xref:System.Collections.SortedList&gt;</ph> object contains a copy of the keys and values stored in the <ph id="ph2">&lt;xref:System.Collections.Hashtable&gt;</ph>.</source>
          <target state="translated">O novo <ph id="ph1">&lt;xref:System.Collections.SortedList&gt;</ph> objeto contém uma cópia das chaves e valores armazenados no <ph id="ph2">&lt;xref:System.Collections.Hashtable&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.SortedList.#ctor(System.Collections.IDictionary,System.Collections.IComparer)">
          <source>The capacity of a <ph id="ph1">&lt;xref:System.Collections.SortedList&gt;</ph> object is the number of elements that the <ph id="ph2">&lt;xref:System.Collections.SortedList&gt;</ph> can hold.</source>
          <target state="translated">A capacidade de um <ph id="ph1">&lt;xref:System.Collections.SortedList&gt;</ph> objeto é o número de elementos que o <ph id="ph2">&lt;xref:System.Collections.SortedList&gt;</ph> pode conter.</target>       </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.SortedList.#ctor(System.Collections.IDictionary,System.Collections.IComparer)">
          <source>As elements are added to a <ph id="ph1">&lt;xref:System.Collections.SortedList&gt;</ph>, the capacity is automatically increased as required by reallocating the internal array.</source>
          <target state="translated">Como os elementos são adicionados a um <ph id="ph1">&lt;xref:System.Collections.SortedList&gt;</ph>, a capacidade é aumentada automaticamente conforme necessário ao realocar a matriz interna.</target>       </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.SortedList.#ctor(System.Collections.IDictionary,System.Collections.IComparer)">
          <source>If the size of the collection can be estimated, specifying the initial capacity eliminates the need to perform a number of resizing operations while adding elements to the <ph id="ph1">&lt;xref:System.Collections.SortedList&gt;</ph> object.</source>
          <target state="translated">Se o tamanho da coleção pode ser estimado, especificando a capacidade inicial elimina a necessidade de executar um número de operações de redimensionamento durante a adição de elementos para o <ph id="ph1">&lt;xref:System.Collections.SortedList&gt;</ph> objeto.</target>       </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.SortedList.#ctor(System.Collections.IDictionary,System.Collections.IComparer)">
          <source>This constructor is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is the number of elements in <ph id="ph3">`d`</ph>.</source>
          <target state="translated">Este construtor é um O (<ph id="ph1">`n`</ph>) operação, onde <ph id="ph2">`n`</ph> é o número de elementos em <ph id="ph3">`d`</ph>.</target>       </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.SortedList.#ctor(System.Collections.IDictionary,System.Collections.IComparer)">
          <source>The following code example creates collections using different <ph id="ph1">&lt;xref:System.Collections.SortedList&gt;</ph> constructors and demonstrates the differences in the behavior of the collections.</source>
          <target state="translated">O exemplo de código a seguir cria coleções usando diferentes <ph id="ph1">&lt;xref:System.Collections.SortedList&gt;</ph> construtores e demonstra as diferenças no comportamento das coleções.</target>       </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve" uid="M:System.Collections.SortedList.#ctor(System.Collections.IDictionary,System.Collections.IComparer)">
          <source><ph id="ph1">&lt;paramref name="d" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="d" /&gt;</ph> é <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve" uid="M:System.Collections.SortedList.#ctor(System.Collections.IDictionary,System.Collections.IComparer)">
          <source><ph id="ph1">&lt;paramref name="comparer" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>, and one or more elements in <ph id="ph3">&lt;paramref name="d" /&gt;</ph> do not implement the <ph id="ph4">&lt;see cref="T:System.IComparable" /&gt;</ph> interface.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="comparer" /&gt;</ph> é <ph id="ph2">&lt;see langword="null" /&gt;</ph>, e um ou mais elementos em <ph id="ph3">&lt;paramref name="d" /&gt;</ph> não implementam a interface <ph id="ph4">&lt;see cref="T:System.IComparable" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve" uid="M:System.Collections.SortedList.Add(System.Object,System.Object)">
          <source>The key of the element to add.</source>
          <target state="translated">A chave do elemento a ser adicionada.</target>       </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve" uid="M:System.Collections.SortedList.Add(System.Object,System.Object)">
          <source>The value of the element to add.</source>
          <target state="translated">O valor do elemento a ser adicionado.</target>       </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve" uid="M:System.Collections.SortedList.Add(System.Object,System.Object)">
          <source>The value can be <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">O valor pode ser <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve" uid="M:System.Collections.SortedList.Add(System.Object,System.Object)">
          <source>Adds an element with the specified key and value to a <ph id="ph1">&lt;see cref="T:System.Collections.SortedList" /&gt;</ph> object.</source>
          <target state="translated">Adiciona um elemento com a chave e o valor especificados a um objeto <ph id="ph1">&lt;see cref="T:System.Collections.SortedList" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.SortedList.Add(System.Object,System.Object)">
          <source>The insertion point is determined based on the comparer selected, either explicitly or by default, when the <ph id="ph1">&lt;xref:System.Collections.SortedList&gt;</ph> object was created.</source>
          <target state="translated">O ponto de inserção é determinado com base no comparador selecionado, ou explicitamente por padrão, quando o <ph id="ph1">&lt;xref:System.Collections.SortedList&gt;</ph> objeto foi criado.</target>       </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.SortedList.Add(System.Object,System.Object)">
          <source>If <ph id="ph1">&lt;xref:System.Collections.SortedList.Count%2A&gt;</ph> already equals <ph id="ph2">&lt;xref:System.Collections.SortedList.Capacity%2A&gt;</ph>, the capacity of the <ph id="ph3">&lt;xref:System.Collections.SortedList&gt;</ph> object is increased by automatically reallocating the internal array, and the existing elements are copied to the new array before the new element is added.</source>
          <target state="translated">Se <ph id="ph1">&lt;xref:System.Collections.SortedList.Count%2A&gt;</ph> já for igual a <ph id="ph2">&lt;xref:System.Collections.SortedList.Capacity%2A&gt;</ph>, a capacidade do <ph id="ph3">&lt;xref:System.Collections.SortedList&gt;</ph> objeto é aumentado, automaticamente realocando a matriz interna e os elementos existentes são copiados para a nova matriz antes de adicionar o novo elemento.</target>       </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.SortedList.Add(System.Object,System.Object)">
          <source>You can also use the <ph id="ph1">&lt;xref:System.Collections.SortedList.Item%2A&gt;</ph> property to add new elements by setting the value of a key that does not exist in the <ph id="ph2">&lt;xref:System.Collections.SortedList&gt;</ph> object (for example, <ph id="ph3">`myCollection["myNonexistentKey"] = myValue`</ph>).</source>
          <target state="translated">Você também pode usar o <ph id="ph1">&lt;xref:System.Collections.SortedList.Item%2A&gt;</ph> propriedade para adicionar novos elementos, definindo o valor de uma chave que não existe no <ph id="ph2">&lt;xref:System.Collections.SortedList&gt;</ph> objeto (por exemplo, <ph id="ph3">`myCollection["myNonexistentKey"] = myValue`</ph>).</target>       </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.SortedList.Add(System.Object,System.Object)">
          <source>However, if the specified key already exists in the <ph id="ph1">&lt;xref:System.Collections.SortedList&gt;</ph>, setting the <ph id="ph2">&lt;xref:System.Collections.SortedList.Item%2A&gt;</ph> property overwrites the old value.</source>
          <target state="translated">No entanto, se a chave especificada já existe no <ph id="ph1">&lt;xref:System.Collections.SortedList&gt;</ph>, a definição de <ph id="ph2">&lt;xref:System.Collections.SortedList.Item%2A&gt;</ph> propriedade substitui o valor antigo.</target>       </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.SortedList.Add(System.Object,System.Object)">
          <source>In contrast, the <ph id="ph1">&lt;xref:System.Collections.SortedList.Add%2A&gt;</ph> method does not modify existing elements.</source>
          <target state="translated">Em contraste, o <ph id="ph1">&lt;xref:System.Collections.SortedList.Add%2A&gt;</ph> método não modifica os elementos existentes.</target>       </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.SortedList.Add(System.Object,System.Object)">
          <source>The elements of a <ph id="ph1">&lt;xref:System.Collections.SortedList&gt;</ph> object are sorted by the keys either according to a specific <ph id="ph2">&lt;xref:System.Collections.IComparer&gt;</ph> implementation specified when the <ph id="ph3">&lt;xref:System.Collections.SortedList&gt;</ph> is created or according to the <ph id="ph4">&lt;xref:System.IComparable&gt;</ph> implementation provided by the keys themselves.</source>
          <target state="translated">Os elementos de um <ph id="ph1">&lt;xref:System.Collections.SortedList&gt;</ph> objeto são classificados pelas chaves de um acordo com um determinado <ph id="ph2">&lt;xref:System.Collections.IComparer&gt;</ph> implementação especificado quando o <ph id="ph3">&lt;xref:System.Collections.SortedList&gt;</ph> é criado ou acordo para o <ph id="ph4">&lt;xref:System.IComparable&gt;</ph> as próprias chaves a implementação.</target>       </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.SortedList.Add(System.Object,System.Object)">
          <source>A key cannot be <ph id="ph1">`null`</ph>, but a value can be.</source>
          <target state="translated">Uma chave não pode ser <ph id="ph1">`null`</ph>, mas pode ser um valor.</target>       </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.SortedList.Add(System.Object,System.Object)">
          <source>This method is an O(<ph id="ph1">`n`</ph>) operation for unsorted data, where <ph id="ph2">`n`</ph> is <ph id="ph3">&lt;xref:System.Collections.SortedList.Count%2A&gt;</ph>.</source>
          <target state="translated">Esse método é um O (<ph id="ph1">`n`</ph>) a operação de dados classificados, onde <ph id="ph2">`n`</ph> é <ph id="ph3">&lt;xref:System.Collections.SortedList.Count%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.SortedList.Add(System.Object,System.Object)">
          <source>It is an O(log <ph id="ph1">`n`</ph>) operation if the new element is added at the end of the list.</source>
          <target state="translated">É um O (log <ph id="ph1">`n`</ph>) se o novo elemento é adicionado ao final da lista de operação.</target>       </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.SortedList.Add(System.Object,System.Object)">
          <source>If insertion causes a resize, the operation is O(<ph id="ph1">`n`</ph>).</source>
          <target state="translated">Se a inserção faz com que um redimensionamento, a operação é O (<ph id="ph1">`n`</ph>).</target>       </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.SortedList.Add(System.Object,System.Object)">
          <source>The following code example shows how to add elements to a <ph id="ph1">&lt;xref:System.Collections.SortedList&gt;</ph> object.</source>
          <target state="translated">O exemplo de código a seguir mostra como adicionar elementos a uma <ph id="ph1">&lt;xref:System.Collections.SortedList&gt;</ph> objeto.</target>       </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve" uid="M:System.Collections.SortedList.Add(System.Object,System.Object)">
          <source><ph id="ph1">&lt;paramref name="key" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="key" /&gt;</ph> é <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve" uid="M:System.Collections.SortedList.Add(System.Object,System.Object)">
          <source>An element with the specified <ph id="ph1">&lt;paramref name="key" /&gt;</ph> already exists in the <ph id="ph2">&lt;see cref="T:System.Collections.SortedList" /&gt;</ph> object.</source>
          <target state="translated">Já existe um elemento com o <ph id="ph1">&lt;paramref name="key" /&gt;</ph> especificado no objeto <ph id="ph2">&lt;see cref="T:System.Collections.SortedList" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve" uid="M:System.Collections.SortedList.Add(System.Object,System.Object)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve" uid="M:System.Collections.SortedList.Add(System.Object,System.Object)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.SortedList" /&gt;</ph> is set to use the <ph id="ph2">&lt;see cref="T:System.IComparable" /&gt;</ph> interface, and <ph id="ph3">&lt;paramref name="key" /&gt;</ph> does not implement the <ph id="ph4">&lt;see cref="T:System.IComparable" /&gt;</ph> interface.</source>
          <target state="translated">O <ph id="ph1">&lt;see cref="T:System.Collections.SortedList" /&gt;</ph> está definido para usar a interface <ph id="ph2">&lt;see cref="T:System.IComparable" /&gt;</ph> e <ph id="ph3">&lt;paramref name="key" /&gt;</ph> não implementa a interface <ph id="ph4">&lt;see cref="T:System.IComparable" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve" uid="M:System.Collections.SortedList.Add(System.Object,System.Object)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.SortedList" /&gt;</ph> is read-only.</source>
          <target state="translated">O <ph id="ph1">&lt;see cref="T:System.Collections.SortedList" /&gt;</ph> é somente leitura.</target>       </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve" uid="M:System.Collections.SortedList.Add(System.Object,System.Object)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve" uid="M:System.Collections.SortedList.Add(System.Object,System.Object)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.SortedList" /&gt;</ph> has a fixed size.</source>
          <target state="translated">O <ph id="ph1">&lt;see cref="T:System.Collections.SortedList" /&gt;</ph> tem um tamanho fixo.</target>       </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve" uid="M:System.Collections.SortedList.Add(System.Object,System.Object)">
          <source>There is not enough available memory to add the element to the <ph id="ph1">&lt;see cref="T:System.Collections.SortedList" /&gt;</ph>.</source>
          <target state="translated">Não há memória suficiente disponível para adicionar o elemento ao <ph id="ph1">&lt;see cref="T:System.Collections.SortedList" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve" uid="M:System.Collections.SortedList.Add(System.Object,System.Object)">
          <source>The comparer throws an exception.</source>
          <target state="translated">O comparador gera uma exceção.</target>       </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve" uid="P:System.Collections.SortedList.Capacity">
          <source>Gets or sets the capacity of a <ph id="ph1">&lt;see cref="T:System.Collections.SortedList" /&gt;</ph> object.</source>
          <target state="translated">Obtém ou define a capacidade de um objeto <ph id="ph1">&lt;see cref="T:System.Collections.SortedList" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.SortedList.Capacity">
          <source>The number of elements that the <ph id="ph1">&lt;see cref="T:System.Collections.SortedList" /&gt;</ph> object can contain.</source>
          <target state="translated">O número de elementos que o objeto <ph id="ph1">&lt;see cref="T:System.Collections.SortedList" /&gt;</ph> pode conter.</target>       </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.SortedList.Capacity">
          <source><ph id="ph1">&lt;xref:System.Collections.SortedList.Capacity%2A&gt;</ph> is the number of elements that the <ph id="ph2">&lt;xref:System.Collections.SortedList&gt;</ph> object can store.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Collections.SortedList.Capacity%2A&gt;</ph> é o número de elementos que o <ph id="ph2">&lt;xref:System.Collections.SortedList&gt;</ph> objeto pode armazenar.</target>       </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.SortedList.Capacity">
          <source><ph id="ph1">&lt;xref:System.Collections.SortedList.Count%2A&gt;</ph> is the number of elements that are actually in the <ph id="ph2">&lt;xref:System.Collections.SortedList&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Collections.SortedList.Count%2A&gt;</ph> é o número de elementos que estão realmente no <ph id="ph2">&lt;xref:System.Collections.SortedList&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.SortedList.Capacity">
          <source><ph id="ph1">&lt;xref:System.Collections.SortedList.Capacity%2A&gt;</ph> is always greater than or equal to <ph id="ph2">&lt;xref:System.Collections.SortedList.Count%2A&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Collections.SortedList.Capacity%2A&gt;</ph> sempre é maior que ou igual a <ph id="ph2">&lt;xref:System.Collections.SortedList.Count%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.SortedList.Capacity">
          <source>If <ph id="ph1">&lt;xref:System.Collections.SortedList.Count%2A&gt;</ph> exceeds <ph id="ph2">&lt;xref:System.Collections.SortedList.Capacity%2A&gt;</ph> while adding elements, the capacity is automatically increased by reallocating the internal array before copying the old elements and adding the new elements.</source>
          <target state="translated">Se <ph id="ph1">&lt;xref:System.Collections.SortedList.Count%2A&gt;</ph> excede <ph id="ph2">&lt;xref:System.Collections.SortedList.Capacity%2A&gt;</ph> durante a adição de elementos, a capacidade é aumentada automaticamente realocando a matriz interna antes de copiar os elementos antigos e adição de novos elementos.</target>       </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.SortedList.Capacity">
          <source>The capacity can be decreased by calling <ph id="ph1">&lt;xref:System.Collections.SortedList.TrimToSize%2A&gt;</ph> or by setting the <ph id="ph2">&lt;xref:System.Collections.SortedList.Capacity%2A&gt;</ph> property explicitly.</source>
          <target state="translated">A capacidade pode ser diminuída chamando <ph id="ph1">&lt;xref:System.Collections.SortedList.TrimToSize%2A&gt;</ph> ou definindo o <ph id="ph2">&lt;xref:System.Collections.SortedList.Capacity%2A&gt;</ph> propriedade explicitamente.</target>       </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.SortedList.Capacity">
          <source>When the value of <ph id="ph1">&lt;xref:System.Collections.SortedList.Capacity%2A&gt;</ph> is set explicitly, the internal array is also reallocated to accommodate the specified capacity.</source>
          <target state="translated">Quando o valor de <ph id="ph1">&lt;xref:System.Collections.SortedList.Capacity%2A&gt;</ph> é definido explicitamente, a matriz interna também seja realocada para acomodar a capacidade especificada.</target>       </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.SortedList.Capacity">
          <source>Retrieving the value of this property is an O(1) operation; setting the property is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is the new capacity.</source>
          <target state="translated">Recuperar o valor dessa propriedade é uma operação de (1); configuração da propriedade é um O (<ph id="ph1">`n`</ph>) operação, onde <ph id="ph2">`n`</ph> é a nova capacidade.</target>       </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve" uid="P:System.Collections.SortedList.Capacity">
          <source>The value assigned is less than the current number of elements in the <ph id="ph1">&lt;see cref="T:System.Collections.SortedList" /&gt;</ph> object.</source>
          <target state="translated">O valor atribuído é menor que o número atual de elementos no objeto <ph id="ph1">&lt;see cref="T:System.Collections.SortedList" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve" uid="P:System.Collections.SortedList.Capacity">
          <source>There is not enough memory available on the system.</source>
          <target state="translated">Não há memória suficiente disponível no sistema.</target>       </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve" uid="M:System.Collections.SortedList.Clear">
          <source>Removes all elements from a <ph id="ph1">&lt;see cref="T:System.Collections.SortedList" /&gt;</ph> object.</source>
          <target state="translated">Remove todos os elementos de um objeto <ph id="ph1">&lt;see cref="T:System.Collections.SortedList" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.SortedList.Clear">
          <source><ph id="ph1">&lt;xref:System.Collections.SortedList.Count%2A&gt;</ph> is set to zero and references to other objects from elements of the collection are also released.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Collections.SortedList.Count%2A&gt;</ph> é definido como zero e referências a outros objetos de elementos da coleção também são liberadas.</target>       </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.SortedList.Clear">
          <source><ph id="ph1">&lt;xref:System.Collections.SortedList.Capacity%2A&gt;</ph> remains unchanged.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Collections.SortedList.Capacity%2A&gt;</ph> permanece inalterado.</target>       </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.SortedList.Clear">
          <source>To reset the capacity of the <ph id="ph1">&lt;xref:System.Collections.SortedList&gt;</ph> object, call <ph id="ph2">&lt;xref:System.Collections.SortedList.TrimToSize%2A&gt;</ph> or set the <ph id="ph3">&lt;xref:System.Collections.SortedList.Capacity%2A&gt;</ph> property directly.</source>
          <target state="translated">Para redefinir a capacidade do <ph id="ph1">&lt;xref:System.Collections.SortedList&gt;</ph> de objeto, chame <ph id="ph2">&lt;xref:System.Collections.SortedList.TrimToSize%2A&gt;</ph> ou defina o <ph id="ph3">&lt;xref:System.Collections.SortedList.Capacity%2A&gt;</ph> propriedade diretamente.</target>       </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.SortedList.Clear">
          <source>Trimming an empty <ph id="ph1">&lt;xref:System.Collections.SortedList&gt;</ph> sets the capacity of the <ph id="ph2">&lt;xref:System.Collections.SortedList&gt;</ph> to the default capacity.</source>
          <target state="translated">Cortar vazio <ph id="ph1">&lt;xref:System.Collections.SortedList&gt;</ph> define a capacidade do <ph id="ph2">&lt;xref:System.Collections.SortedList&gt;</ph> à capacidade padrão.</target>       </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.SortedList.Clear">
          <source>This method is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is <ph id="ph3">&lt;xref:System.Collections.SortedList.Count%2A&gt;</ph>.</source>
          <target state="translated">Este método é uma operação O(<ph id="ph1">`n`</ph>), em que <ph id="ph2">`n`</ph> é <ph id="ph3">&lt;xref:System.Collections.SortedList.Count%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.SortedList.Clear">
          <source>The following code example shows how to trim the unused portions of a <ph id="ph1">&lt;xref:System.Collections.SortedList&gt;</ph> object and how to clear the values of the <ph id="ph2">&lt;xref:System.Collections.SortedList&gt;</ph>.</source>
          <target state="translated">O exemplo de código a seguir mostra como cortar as partes não utilizadas de um <ph id="ph1">&lt;xref:System.Collections.SortedList&gt;</ph> objeto e como limpar os valores a <ph id="ph2">&lt;xref:System.Collections.SortedList&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve" uid="M:System.Collections.SortedList.Clear">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.SortedList" /&gt;</ph> object is read-only.</source>
          <target state="translated">O objeto <ph id="ph1">&lt;see cref="T:System.Collections.SortedList" /&gt;</ph> é somente leitura.</target>       </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve" uid="M:System.Collections.SortedList.Clear">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve" uid="M:System.Collections.SortedList.Clear">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.SortedList" /&gt;</ph> has a fixed size.</source>
          <target state="translated">O <ph id="ph1">&lt;see cref="T:System.Collections.SortedList" /&gt;</ph> tem um tamanho fixo.</target>       </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve" uid="M:System.Collections.SortedList.Clone">
          <source>Creates a shallow copy of a <ph id="ph1">&lt;see cref="T:System.Collections.SortedList" /&gt;</ph> object.</source>
          <target state="translated">Cria uma cópia superficial de um objeto <ph id="ph1">&lt;see cref="T:System.Collections.SortedList" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve" uid="M:System.Collections.SortedList.Clone">
          <source>A shallow copy of the <ph id="ph1">&lt;see cref="T:System.Collections.SortedList" /&gt;</ph> object.</source>
          <target state="translated">Uma cópia superficial do objeto <ph id="ph1">&lt;see cref="T:System.Collections.SortedList" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.SortedList.Clone">
          <source>A shallow copy of a collection copies only the elements of the collection, whether they are reference types or value types, but does not copy the objects that the references refer to.</source>
          <target state="translated">Uma cópia superficial de uma coleção copia apenas os elementos da coleção, se eles são tipos de referência ou valor de tipos, mas não copiar os objetos que se referem as referências a.</target>       </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.SortedList.Clone">
          <source>The references in the new collection point to the same objects that the references in the original collection point to.</source>
          <target state="translated">As referências na nova coleção apontam para os mesmos objetos que as referências na coleção original apontem para.</target>       </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.SortedList.Clone">
          <source>In contrast, a deep copy of a collection copies the elements and everything directly or indirectly referenced by the elements.</source>
          <target state="translated">Em contraste, uma cópia profunda de uma coleção copia os elementos e tudo direta ou indiretamente referenciado por elementos.</target>       </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.SortedList.Clone">
          <source>This method is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is <ph id="ph3">&lt;xref:System.Collections.SortedList.Count%2A&gt;</ph>.</source>
          <target state="translated">Este método é uma operação O(<ph id="ph1">`n`</ph>), em que <ph id="ph2">`n`</ph> é <ph id="ph3">&lt;xref:System.Collections.SortedList.Count%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve" uid="M:System.Collections.SortedList.Contains(System.Object)">
          <source>The key to locate in the <ph id="ph1">&lt;see cref="T:System.Collections.SortedList" /&gt;</ph> object.</source>
          <target state="translated">A chave a ser localizada no objeto <ph id="ph1">&lt;see cref="T:System.Collections.SortedList" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="260" translate="yes" xml:space="preserve" uid="M:System.Collections.SortedList.Contains(System.Object)">
          <source>Determines whether a <ph id="ph1">&lt;see cref="T:System.Collections.SortedList" /&gt;</ph> object contains a specific key.</source>
          <target state="translated">Determina se um objeto <ph id="ph1">&lt;see cref="T:System.Collections.SortedList" /&gt;</ph> contém uma chave específica.</target>       </trans-unit>
        <trans-unit id="261" translate="yes" xml:space="preserve" uid="M:System.Collections.SortedList.Contains(System.Object)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the <ph id="ph2">&lt;see cref="T:System.Collections.SortedList" /&gt;</ph> object contains an element with the specified <ph id="ph3">&lt;paramref name="key" /&gt;</ph>; otherwise, <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> se o objeto <ph id="ph2">&lt;see cref="T:System.Collections.SortedList" /&gt;</ph> contiver um elemento com o <ph id="ph3">&lt;paramref name="key" /&gt;</ph> especificado, caso contrário, <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="262" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.SortedList.Contains(System.Object)">
          <source>The elements of a <ph id="ph1">&lt;xref:System.Collections.SortedList&gt;</ph> object are sorted by the keys either according to a specific <ph id="ph2">&lt;xref:System.Collections.IComparer&gt;</ph> implementation specified when the <ph id="ph3">&lt;xref:System.Collections.SortedList&gt;</ph> is created or according to the <ph id="ph4">&lt;xref:System.IComparable&gt;</ph> implementation provided by the keys themselves.</source>
          <target state="translated">Os elementos de um <ph id="ph1">&lt;xref:System.Collections.SortedList&gt;</ph> objeto são classificados pelas chaves de um acordo com um determinado <ph id="ph2">&lt;xref:System.Collections.IComparer&gt;</ph> implementação especificado quando o <ph id="ph3">&lt;xref:System.Collections.SortedList&gt;</ph> é criado ou acordo para o <ph id="ph4">&lt;xref:System.IComparable&gt;</ph> as próprias chaves a implementação.</target>       </trans-unit>
        <trans-unit id="263" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.SortedList.Contains(System.Object)">
          <source><ph id="ph1">&lt;xref:System.Collections.SortedList.Contains%2A&gt;</ph> implements <ph id="ph2">&lt;xref:System.Collections.IDictionary.Contains%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Collections.SortedList.Contains%2A&gt;</ph> implementa <ph id="ph2">&lt;xref:System.Collections.IDictionary.Contains%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="264" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.SortedList.Contains(System.Object)">
          <source>It behaves exactly as <ph id="ph1">&lt;xref:System.Collections.SortedList.ContainsKey%2A&gt;</ph>.</source>
          <target state="translated">Ele se comporta exatamente como <ph id="ph1">&lt;xref:System.Collections.SortedList.ContainsKey%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="265" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.SortedList.Contains(System.Object)">
          <source>This method uses a binary search algorithm; therefore, this method is an O(log <ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is <ph id="ph3">&lt;xref:System.Collections.SortedList.Count%2A&gt;</ph>.</source>
          <target state="translated">Esse método usa um algoritmo de pesquisa binário; Portanto, esse método é um O (log <ph id="ph1">`n`</ph>) operação, onde <ph id="ph2">`n`</ph> é <ph id="ph3">&lt;xref:System.Collections.SortedList.Count%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="266" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.SortedList.Contains(System.Object)">
          <source>Starting with the .NET Framework 2.0, this method uses the collection’s objects’ <ph id="ph1">&lt;xref:System.Object.Equals%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.IComparable.CompareTo%2A&gt;</ph> methods on <ph id="ph3">`item`</ph> to determine whether item exists.</source>
          <target state="translated">Começando pelo .NET Framework 2.0, esse método usa os métodos <ph id="ph1">&lt;xref:System.Object.Equals%2A&gt;</ph> e <ph id="ph2">&lt;xref:System.IComparable.CompareTo%2A&gt;</ph> do objeto da coleção em <ph id="ph3">`item`</ph> para determinar se o item existe.</target>       </trans-unit>
        <trans-unit id="267" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.SortedList.Contains(System.Object)">
          <source>In the earlier versions of the .NET Framework, this determination was made by using the <ph id="ph1">&lt;xref:System.Object.Equals%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.IComparable.CompareTo%2A&gt;</ph> methods of the <ph id="ph3">`item`</ph> parameter on the objects in the collection.</source>
          <target state="translated">Em versões anteriores do .NET Framework, essa decisão era tomada usando-se os métodos <ph id="ph1">&lt;xref:System.Object.Equals%2A&gt;</ph> e <ph id="ph2">&lt;xref:System.IComparable.CompareTo%2A&gt;</ph> do parâmetro <ph id="ph3">`item`</ph> nos objetos na coleção.</target>       </trans-unit>
        <trans-unit id="268" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.SortedList.Contains(System.Object)">
          <source>The following code example shows how to determine whether a <ph id="ph1">&lt;xref:System.Collections.SortedList&gt;</ph> object contains a specific element.</source>
          <target state="translated">O exemplo de código a seguir mostra como determinar se um <ph id="ph1">&lt;xref:System.Collections.SortedList&gt;</ph> objeto contém um elemento específico.</target>       </trans-unit>
        <trans-unit id="269" translate="yes" xml:space="preserve" uid="M:System.Collections.SortedList.Contains(System.Object)">
          <source><ph id="ph1">&lt;paramref name="key" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="key" /&gt;</ph> é <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="270" translate="yes" xml:space="preserve" uid="M:System.Collections.SortedList.Contains(System.Object)">
          <source>The comparer throws an exception.</source>
          <target state="translated">O comparador gera uma exceção.</target>       </trans-unit>
        <trans-unit id="271" translate="yes" xml:space="preserve" uid="M:System.Collections.SortedList.ContainsKey(System.Object)">
          <source>The key to locate in the <ph id="ph1">&lt;see cref="T:System.Collections.SortedList" /&gt;</ph> object.</source>
          <target state="translated">A chave a ser localizada no objeto <ph id="ph1">&lt;see cref="T:System.Collections.SortedList" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="272" translate="yes" xml:space="preserve" uid="M:System.Collections.SortedList.ContainsKey(System.Object)">
          <source>Determines whether a <ph id="ph1">&lt;see cref="T:System.Collections.SortedList" /&gt;</ph> object contains a specific key.</source>
          <target state="translated">Determina se um objeto <ph id="ph1">&lt;see cref="T:System.Collections.SortedList" /&gt;</ph> contém uma chave específica.</target>       </trans-unit>
        <trans-unit id="273" translate="yes" xml:space="preserve" uid="M:System.Collections.SortedList.ContainsKey(System.Object)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the <ph id="ph2">&lt;see cref="T:System.Collections.SortedList" /&gt;</ph> object contains an element with the specified <ph id="ph3">&lt;paramref name="key" /&gt;</ph>; otherwise, <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> se o objeto <ph id="ph2">&lt;see cref="T:System.Collections.SortedList" /&gt;</ph> contiver um elemento com o <ph id="ph3">&lt;paramref name="key" /&gt;</ph> especificado, caso contrário, <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="274" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.SortedList.ContainsKey(System.Object)">
          <source>The elements of a <ph id="ph1">&lt;xref:System.Collections.SortedList&gt;</ph> object are sorted by the keys either according to a specific <ph id="ph2">&lt;xref:System.Collections.IComparer&gt;</ph> implementation specified when the <ph id="ph3">&lt;xref:System.Collections.SortedList&gt;</ph> is created or according to the <ph id="ph4">&lt;xref:System.IComparable&gt;</ph> implementation provided by the keys themselves.</source>
          <target state="translated">Os elementos de um <ph id="ph1">&lt;xref:System.Collections.SortedList&gt;</ph> objeto são classificados pelas chaves de um acordo com um determinado <ph id="ph2">&lt;xref:System.Collections.IComparer&gt;</ph> implementação especificado quando o <ph id="ph3">&lt;xref:System.Collections.SortedList&gt;</ph> é criado ou acordo para o <ph id="ph4">&lt;xref:System.IComparable&gt;</ph> as próprias chaves a implementação.</target>       </trans-unit>
        <trans-unit id="275" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.SortedList.ContainsKey(System.Object)">
          <source>This method behaves exactly as the <ph id="ph1">&lt;xref:System.Collections.SortedList.Contains%2A&gt;</ph> method.</source>
          <target state="translated">Esse método se comporta exatamente como o <ph id="ph1">&lt;xref:System.Collections.SortedList.Contains%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="276" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.SortedList.ContainsKey(System.Object)">
          <source>This method uses a binary search algorithm; therefore, this method is an O(log <ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is <ph id="ph3">&lt;xref:System.Collections.SortedList.Count%2A&gt;</ph>.</source>
          <target state="translated">Esse método usa um algoritmo de pesquisa binário; Portanto, esse método é um O (log <ph id="ph1">`n`</ph>) operação, onde <ph id="ph2">`n`</ph> é <ph id="ph3">&lt;xref:System.Collections.SortedList.Count%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="277" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.SortedList.ContainsKey(System.Object)">
          <source>Starting with the .NET Framework 2.0, this method uses the collection’s objects’ <ph id="ph1">&lt;xref:System.Object.Equals%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.IComparable.CompareTo%2A&gt;</ph> methods on <ph id="ph3">`item`</ph> to determine whether item exists.</source>
          <target state="translated">Começando pelo .NET Framework 2.0, esse método usa os métodos <ph id="ph1">&lt;xref:System.Object.Equals%2A&gt;</ph> e <ph id="ph2">&lt;xref:System.IComparable.CompareTo%2A&gt;</ph> do objeto da coleção em <ph id="ph3">`item`</ph> para determinar se o item existe.</target>       </trans-unit>
        <trans-unit id="278" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.SortedList.ContainsKey(System.Object)">
          <source>In the earlier versions of the .NET Framework, this determination was made by using the <ph id="ph1">&lt;xref:System.Object.Equals%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.IComparable.CompareTo%2A&gt;</ph> methods of the <ph id="ph3">`item`</ph> parameter on the objects in the collection.</source>
          <target state="translated">Em versões anteriores do .NET Framework, essa decisão era tomada usando-se os métodos <ph id="ph1">&lt;xref:System.Object.Equals%2A&gt;</ph> e <ph id="ph2">&lt;xref:System.IComparable.CompareTo%2A&gt;</ph> do parâmetro <ph id="ph3">`item`</ph> nos objetos na coleção.</target>       </trans-unit>
        <trans-unit id="279" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.SortedList.ContainsKey(System.Object)">
          <source>The following code example shows how to determine whether a <ph id="ph1">&lt;xref:System.Collections.SortedList&gt;</ph> object contains a specific element.</source>
          <target state="translated">O exemplo de código a seguir mostra como determinar se um <ph id="ph1">&lt;xref:System.Collections.SortedList&gt;</ph> objeto contém um elemento específico.</target>       </trans-unit>
        <trans-unit id="280" translate="yes" xml:space="preserve" uid="M:System.Collections.SortedList.ContainsKey(System.Object)">
          <source><ph id="ph1">&lt;paramref name="key" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="key" /&gt;</ph> é <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="281" translate="yes" xml:space="preserve" uid="M:System.Collections.SortedList.ContainsKey(System.Object)">
          <source>The comparer throws an exception.</source>
          <target state="translated">O comparador gera uma exceção.</target>       </trans-unit>
        <trans-unit id="282" translate="yes" xml:space="preserve" uid="M:System.Collections.SortedList.ContainsValue(System.Object)">
          <source>The value to locate in the <ph id="ph1">&lt;see cref="T:System.Collections.SortedList" /&gt;</ph> object.</source>
          <target state="translated">O valor a ser localizado no objeto <ph id="ph1">&lt;see cref="T:System.Collections.SortedList" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="283" translate="yes" xml:space="preserve" uid="M:System.Collections.SortedList.ContainsValue(System.Object)">
          <source>The value can be <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">O valor pode ser <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="284" translate="yes" xml:space="preserve" uid="M:System.Collections.SortedList.ContainsValue(System.Object)">
          <source>Determines whether a <ph id="ph1">&lt;see cref="T:System.Collections.SortedList" /&gt;</ph> object contains a specific value.</source>
          <target state="translated">Determina se um objeto <ph id="ph1">&lt;see cref="T:System.Collections.SortedList" /&gt;</ph> contém um valor específico.</target>       </trans-unit>
        <trans-unit id="285" translate="yes" xml:space="preserve" uid="M:System.Collections.SortedList.ContainsValue(System.Object)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the <ph id="ph2">&lt;see cref="T:System.Collections.SortedList" /&gt;</ph> object contains an element with the specified <ph id="ph3">&lt;paramref name="value" /&gt;</ph>; otherwise, <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> se o objeto <ph id="ph2">&lt;see cref="T:System.Collections.SortedList" /&gt;</ph> contiver um elemento com o <ph id="ph3">&lt;paramref name="value" /&gt;</ph> especificado, caso contrário, <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="286" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.SortedList.ContainsValue(System.Object)">
          <source>The values of the elements of the <ph id="ph1">&lt;xref:System.Collections.SortedList&gt;</ph> object are compared to the specified value using the <ph id="ph2">&lt;xref:System.Object.Equals%2A&gt;</ph> method.</source>
          <target state="translated">Os valores dos elementos do <ph id="ph1">&lt;xref:System.Collections.SortedList&gt;</ph> objeto são comparados com o valor especificado usando o <ph id="ph2">&lt;xref:System.Object.Equals%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="287" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.SortedList.ContainsValue(System.Object)">
          <source>This method performs a linear search; therefore, the average execution time is proportional to <ph id="ph1">&lt;xref:System.Collections.SortedList.Count%2A&gt;</ph>.</source>
          <target state="translated">Esse método executa uma pesquisa linear; Portanto, o tempo médio de execução é proporcional ao <ph id="ph1">&lt;xref:System.Collections.SortedList.Count%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="288" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.SortedList.ContainsValue(System.Object)">
          <source>That is, this method is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is <ph id="ph3">&lt;xref:System.Collections.SortedList.Count%2A&gt;</ph>.</source>
          <target state="translated">Ou seja, esse método é um O (<ph id="ph1">`n`</ph>) operação, onde <ph id="ph2">`n`</ph> é <ph id="ph3">&lt;xref:System.Collections.SortedList.Count%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="289" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.SortedList.ContainsValue(System.Object)">
          <source>Starting with the .NET Framework 2.0, this method uses the collection’s objects’ <ph id="ph1">&lt;xref:System.Object.Equals%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.IComparable.CompareTo%2A&gt;</ph> methods on <ph id="ph3">`item`</ph> to determine whether item exists.</source>
          <target state="translated">Começando pelo .NET Framework 2.0, esse método usa os métodos <ph id="ph1">&lt;xref:System.Object.Equals%2A&gt;</ph> e <ph id="ph2">&lt;xref:System.IComparable.CompareTo%2A&gt;</ph> do objeto da coleção em <ph id="ph3">`item`</ph> para determinar se o item existe.</target>       </trans-unit>
        <trans-unit id="290" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.SortedList.ContainsValue(System.Object)">
          <source>In the earlier versions of the .NET Framework, this determination was made by using the <ph id="ph1">&lt;xref:System.Object.Equals%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.IComparable.CompareTo%2A&gt;</ph> methods of the <ph id="ph3">`item`</ph> parameter on the objects in the collection.</source>
          <target state="translated">Em versões anteriores do .NET Framework, essa decisão era tomada usando-se os métodos <ph id="ph1">&lt;xref:System.Object.Equals%2A&gt;</ph> e <ph id="ph2">&lt;xref:System.IComparable.CompareTo%2A&gt;</ph> do parâmetro <ph id="ph3">`item`</ph> nos objetos na coleção.</target>       </trans-unit>
        <trans-unit id="291" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.SortedList.ContainsValue(System.Object)">
          <source>The following code example shows how to determine whether a <ph id="ph1">&lt;xref:System.Collections.SortedList&gt;</ph> object contains a specific element.</source>
          <target state="translated">O exemplo de código a seguir mostra como determinar se um <ph id="ph1">&lt;xref:System.Collections.SortedList&gt;</ph> objeto contém um elemento específico.</target>       </trans-unit>
        <trans-unit id="292" translate="yes" xml:space="preserve" uid="M:System.Collections.SortedList.CopyTo(System.Array,System.Int32)">
          <source>The one-dimensional <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> object that is the destination of the <ph id="ph2">&lt;see cref="T:System.Collections.DictionaryEntry" /&gt;</ph> objects copied from <ph id="ph3">&lt;see cref="T:System.Collections.SortedList" /&gt;</ph>.</source>
          <target state="translated">O <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> unidimensional que é o destino dos objetos <ph id="ph2">&lt;see cref="T:System.Collections.DictionaryEntry" /&gt;</ph> copiados de <ph id="ph3">&lt;see cref="T:System.Collections.SortedList" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="293" translate="yes" xml:space="preserve" uid="M:System.Collections.SortedList.CopyTo(System.Array,System.Int32)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> must have zero-based indexing.</source>
          <target state="translated">O <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> deve ter indexação com base em zero.</target>       </trans-unit>
        <trans-unit id="294" translate="yes" xml:space="preserve" uid="M:System.Collections.SortedList.CopyTo(System.Array,System.Int32)">
          <source>The zero-based index in <bpt id="p1">&lt;c&gt;</bpt>array<ept id="p1">&lt;/c&gt;</ept> at which copying begins.</source>
          <target state="translated">O índice baseado em zero na <bpt id="p1">&lt;c&gt;</bpt>array<ept id="p1">&lt;/c&gt;</ept> na qual a cópia começa.</target>       </trans-unit>
        <trans-unit id="295" translate="yes" xml:space="preserve" uid="M:System.Collections.SortedList.CopyTo(System.Array,System.Int32)">
          <source>Copies <ph id="ph1">&lt;see cref="T:System.Collections.SortedList" /&gt;</ph> elements to a one-dimensional <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph> object, starting at the specified index in the array.</source>
          <target state="translated">Copia <ph id="ph1">&lt;see cref="T:System.Collections.SortedList" /&gt;</ph> elementos para um objeto <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph> unidimensional, iniciando no índice especificado na matriz.</target>       </trans-unit>
        <trans-unit id="296" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.SortedList.CopyTo(System.Array,System.Int32)">
          <source>The key/value pairs are copied to the <ph id="ph1">&lt;xref:System.Array&gt;</ph> object in the same order in which the enumerator iterates through the <ph id="ph2">&lt;xref:System.Collections.SortedList&gt;</ph> object.</source>
          <target state="translated">Os pares chave/valor são copiados para o <ph id="ph1">&lt;xref:System.Array&gt;</ph> objeto na mesma ordem em que o enumerador que itera por meio de <ph id="ph2">&lt;xref:System.Collections.SortedList&gt;</ph> objeto.</target>       </trans-unit>
        <trans-unit id="297" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.SortedList.CopyTo(System.Array,System.Int32)">
          <source>To copy only the keys in the <ph id="ph1">&lt;xref:System.Collections.SortedList&gt;</ph>, use <ph id="ph2">`SortedList.Keys.CopyTo`</ph>.</source>
          <target state="translated">Para copiar somente as chaves de <ph id="ph1">&lt;xref:System.Collections.SortedList&gt;</ph>, use <ph id="ph2">`SortedList.Keys.CopyTo`</ph>.</target>       </trans-unit>
        <trans-unit id="298" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.SortedList.CopyTo(System.Array,System.Int32)">
          <source>To copy only the values in the <ph id="ph1">&lt;xref:System.Collections.SortedList&gt;</ph>, use <ph id="ph2">`SortedList.Values.CopyTo`</ph>.</source>
          <target state="translated">Para copiar somente os valores no <ph id="ph1">&lt;xref:System.Collections.SortedList&gt;</ph>, use <ph id="ph2">`SortedList.Values.CopyTo`</ph>.</target>       </trans-unit>
        <trans-unit id="299" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.SortedList.CopyTo(System.Array,System.Int32)">
          <source>This method is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is <ph id="ph3">&lt;xref:System.Collections.SortedList.Count%2A&gt;</ph>.</source>
          <target state="translated">Este método é uma operação O(<ph id="ph1">`n`</ph>), em que <ph id="ph2">`n`</ph> é <ph id="ph3">&lt;xref:System.Collections.SortedList.Count%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="300" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.SortedList.CopyTo(System.Array,System.Int32)">
          <source>The following code example shows how to copy the values in a <ph id="ph1">&lt;xref:System.Collections.SortedList&gt;</ph> object into a one-dimensional <ph id="ph2">&lt;xref:System.Array&gt;</ph> object.</source>
          <target state="translated">O exemplo de código a seguir mostra como copiar os valores em uma <ph id="ph1">&lt;xref:System.Collections.SortedList&gt;</ph> objeto em um unidimensional <ph id="ph2">&lt;xref:System.Array&gt;</ph> objeto.</target>       </trans-unit>
        <trans-unit id="301" translate="yes" xml:space="preserve" uid="M:System.Collections.SortedList.CopyTo(System.Array,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="array" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="array" /&gt;</ph> é <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="302" translate="yes" xml:space="preserve" uid="M:System.Collections.SortedList.CopyTo(System.Array,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="arrayIndex" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="arrayIndex" /&gt;</ph> é menor que zero.</target>       </trans-unit>
        <trans-unit id="303" translate="yes" xml:space="preserve" uid="M:System.Collections.SortedList.CopyTo(System.Array,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="array" /&gt;</ph> is multidimensional.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="array" /&gt;</ph> é multidimensional.</target>       </trans-unit>
        <trans-unit id="304" translate="yes" xml:space="preserve" uid="M:System.Collections.SortedList.CopyTo(System.Array,System.Int32)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="305" translate="yes" xml:space="preserve" uid="M:System.Collections.SortedList.CopyTo(System.Array,System.Int32)">
          <source>The number of elements in the source <ph id="ph1">&lt;see cref="T:System.Collections.SortedList" /&gt;</ph> object is greater than the available space from <ph id="ph2">&lt;paramref name="arrayIndex" /&gt;</ph> to the end of the destination <ph id="ph3">&lt;paramref name="array" /&gt;</ph>.</source>
          <target state="translated">O número de elementos no objeto de origem <ph id="ph1">&lt;see cref="T:System.Collections.SortedList" /&gt;</ph> é maior do que o espaço disponível de <ph id="ph2">&lt;paramref name="arrayIndex" /&gt;</ph> até o final do <ph id="ph3">&lt;paramref name="array" /&gt;</ph> de destino.</target>       </trans-unit>
        <trans-unit id="306" translate="yes" xml:space="preserve" uid="M:System.Collections.SortedList.CopyTo(System.Array,System.Int32)">
          <source>The type of the source <ph id="ph1">&lt;see cref="T:System.Collections.SortedList" /&gt;</ph> cannot be cast automatically to the type of the destination <ph id="ph2">&lt;paramref name="array" /&gt;</ph>.</source>
          <target state="translated">O tipo do <ph id="ph1">&lt;see cref="T:System.Collections.SortedList" /&gt;</ph> de origem não pode ser automaticamente convertido para o tipo de <ph id="ph2">&lt;paramref name="array" /&gt;</ph> de destino.</target>       </trans-unit>
        <trans-unit id="307" translate="yes" xml:space="preserve" uid="P:System.Collections.SortedList.Count">
          <source>Gets the number of elements contained in a <ph id="ph1">&lt;see cref="T:System.Collections.SortedList" /&gt;</ph> object.</source>
          <target state="translated">Obtém o número de elementos contidos em um objeto <ph id="ph1">&lt;see cref="T:System.Collections.SortedList" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="308" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.SortedList.Count">
          <source>The number of elements contained in the <ph id="ph1">&lt;see cref="T:System.Collections.SortedList" /&gt;</ph> object.</source>
          <target state="translated">O número de elementos contidos no objeto <ph id="ph1">&lt;see cref="T:System.Collections.SortedList" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="309" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.SortedList.Count">
          <source>Each element is a key/value pair that can be accessed as a <ph id="ph1">&lt;xref:System.Collections.DictionaryEntry&gt;</ph> object.</source>
          <target state="translated">Cada elemento é um par chave/valor que pode ser acessado como uma <ph id="ph1">&lt;xref:System.Collections.DictionaryEntry&gt;</ph> objeto.</target>       </trans-unit>
        <trans-unit id="310" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.SortedList.Count">
          <source><ph id="ph1">&lt;xref:System.Collections.SortedList.Capacity%2A&gt;</ph> is the number of elements that the <ph id="ph2">&lt;xref:System.Collections.SortedList&gt;</ph> object can store.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Collections.SortedList.Capacity%2A&gt;</ph> é o número de elementos que o <ph id="ph2">&lt;xref:System.Collections.SortedList&gt;</ph> objeto pode armazenar.</target>       </trans-unit>
        <trans-unit id="311" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.SortedList.Count">
          <source><ph id="ph1">&lt;xref:System.Collections.SortedList.Count%2A&gt;</ph> is the number of elements that are actually in the <ph id="ph2">&lt;xref:System.Collections.SortedList&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Collections.SortedList.Count%2A&gt;</ph> é o número de elementos que estão realmente no <ph id="ph2">&lt;xref:System.Collections.SortedList&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="312" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.SortedList.Count">
          <source><ph id="ph1">&lt;xref:System.Collections.SortedList.Capacity%2A&gt;</ph> is always greater than or equal to <ph id="ph2">&lt;xref:System.Collections.SortedList.Count%2A&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Collections.SortedList.Capacity%2A&gt;</ph> sempre é maior que ou igual a <ph id="ph2">&lt;xref:System.Collections.SortedList.Count%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="313" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.SortedList.Count">
          <source>If <ph id="ph1">&lt;xref:System.Collections.SortedList.Count%2A&gt;</ph> exceeds <ph id="ph2">&lt;xref:System.Collections.SortedList.Capacity%2A&gt;</ph> while adding elements, the capacity is automatically increased by reallocating the internal array before copying the old elements and adding the new elements.</source>
          <target state="translated">Se <ph id="ph1">&lt;xref:System.Collections.SortedList.Count%2A&gt;</ph> excede <ph id="ph2">&lt;xref:System.Collections.SortedList.Capacity%2A&gt;</ph> durante a adição de elementos, a capacidade é aumentada automaticamente realocando a matriz interna antes de copiar os elementos antigos e adição de novos elementos.</target>       </trans-unit>
        <trans-unit id="314" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.SortedList.Count">
          <source>Retrieving the value of this property is an O(1) operation.</source>
          <target state="translated">A recuperação do valor dessa propriedade é uma operação O(1).</target>       </trans-unit>
        <trans-unit id="315" translate="yes" xml:space="preserve" uid="M:System.Collections.SortedList.GetByIndex(System.Int32)">
          <source>The zero-based index of the value to get.</source>
          <target state="translated">O índice baseado em zero do valor a ser obtido.</target>       </trans-unit>
        <trans-unit id="316" translate="yes" xml:space="preserve" uid="M:System.Collections.SortedList.GetByIndex(System.Int32)">
          <source>Gets the value at the specified index of a <ph id="ph1">&lt;see cref="T:System.Collections.SortedList" /&gt;</ph> object.</source>
          <target state="translated">Obtém o valor no índice especificado de um objeto <ph id="ph1">&lt;see cref="T:System.Collections.SortedList" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="317" translate="yes" xml:space="preserve" uid="M:System.Collections.SortedList.GetByIndex(System.Int32)">
          <source>The value at the specified index of the <ph id="ph1">&lt;see cref="T:System.Collections.SortedList" /&gt;</ph> object.</source>
          <target state="translated">O valor no índice especificado do objeto <ph id="ph1">&lt;see cref="T:System.Collections.SortedList" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="318" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.SortedList.GetByIndex(System.Int32)">
          <source>The index sequence is based on the sort sequence.</source>
          <target state="translated">A sequência de índice é baseada na sequência de classificação.</target>       </trans-unit>
        <trans-unit id="319" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.SortedList.GetByIndex(System.Int32)">
          <source>When an element is added, it is inserted into <ph id="ph1">&lt;xref:System.Collections.SortedList&gt;</ph> in the correct sort order, and the indexing adjusts accordingly.</source>
          <target state="translated">Quando um elemento é adicionado, ele será inserido na <ph id="ph1">&lt;xref:System.Collections.SortedList&gt;</ph> na classificação correta ordem e a indexação é ajustada de acordo.</target>       </trans-unit>
        <trans-unit id="320" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.SortedList.GetByIndex(System.Int32)">
          <source>When an element is removed, the indexing also adjusts accordingly.</source>
          <target state="translated">Quando um elemento for removido, a indexação também se ajusta.</target>       </trans-unit>
        <trans-unit id="321" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.SortedList.GetByIndex(System.Int32)">
          <source>Therefore, the index of a specific key/value pair might change as elements are added or removed from the <ph id="ph1">&lt;xref:System.Collections.SortedList&gt;</ph> object.</source>
          <target state="translated">Portanto, o índice de um par chave/valor específico pode alterar como os elementos são adicionados ou removidos do <ph id="ph1">&lt;xref:System.Collections.SortedList&gt;</ph> objeto.</target>       </trans-unit>
        <trans-unit id="322" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.SortedList.GetByIndex(System.Int32)">
          <source>This method is an O(1) operation.</source>
          <target state="translated">Este método é uma operação O(1).</target>       </trans-unit>
        <trans-unit id="323" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.SortedList.GetByIndex(System.Int32)">
          <source>The following code example shows how to get one or all the keys or values in a <ph id="ph1">&lt;xref:System.Collections.SortedList&gt;</ph> object.</source>
          <target state="translated">O exemplo de código a seguir mostra como obter uma ou todas as chaves ou valores em uma <ph id="ph1">&lt;xref:System.Collections.SortedList&gt;</ph> objeto.</target>       </trans-unit>
        <trans-unit id="324" translate="yes" xml:space="preserve" uid="M:System.Collections.SortedList.GetByIndex(System.Int32)">
          <source><ph id="ph1">&lt;paramref name="index" /&gt;</ph> is outside the range of valid indexes for the <ph id="ph2">&lt;see cref="T:System.Collections.SortedList" /&gt;</ph> object.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="index" /&gt;</ph> está fora do intervalo de índices válidos para o objeto <ph id="ph2">&lt;see cref="T:System.Collections.SortedList" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="325" translate="yes" xml:space="preserve" uid="M:System.Collections.SortedList.GetEnumerator">
          <source>Returns an <ph id="ph1">&lt;see cref="T:System.Collections.IDictionaryEnumerator" /&gt;</ph> object that iterates through a <ph id="ph2">&lt;see cref="T:System.Collections.SortedList" /&gt;</ph> object.</source>
          <target state="translated">Retorna um objeto <ph id="ph1">&lt;see cref="T:System.Collections.IDictionaryEnumerator" /&gt;</ph> que itera por um objeto <ph id="ph2">&lt;see cref="T:System.Collections.SortedList" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="326" translate="yes" xml:space="preserve" uid="M:System.Collections.SortedList.GetEnumerator">
          <source>An <ph id="ph1">&lt;see cref="T:System.Collections.IDictionaryEnumerator" /&gt;</ph> object for the <ph id="ph2">&lt;see cref="T:System.Collections.SortedList" /&gt;</ph> object.</source>
          <target state="translated">Um objeto <ph id="ph1">&lt;see cref="T:System.Collections.IDictionaryEnumerator" /&gt;</ph> para o objeto <ph id="ph2">&lt;see cref="T:System.Collections.SortedList" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="327" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.SortedList.GetEnumerator">
          <source>The <ph id="ph1">`foreach`</ph> statement of the C# language (<ph id="ph2">`for each`</ph> in Visual Basic) hides the complexity of the enumerators.</source>
          <target state="translated">O <ph id="ph1">`foreach`</ph> instrução de linguagem c# (<ph id="ph2">`for each`</ph> no Visual Basic) oculta a complexidade dos enumeradores.</target>       </trans-unit>
        <trans-unit id="328" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.SortedList.GetEnumerator">
          <source>Therefore, using <ph id="ph1">`foreach`</ph> is recommended, instead of directly manipulating the enumerator.</source>
          <target state="translated">Portanto, o uso de <ph id="ph1">`foreach`</ph> é recomendado, em vez de manipular diretamente o enumerador.</target>       </trans-unit>
        <trans-unit id="329" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.SortedList.GetEnumerator">
          <source>Enumerators can be used to read the data in the collection, but they cannot be used to modify the underlying collection.</source>
          <target state="translated">Os enumeradores podem ser usados para ler os dados na coleção, mas não podem ser usados para modificar a coleção subjacente.</target>       </trans-unit>
        <trans-unit id="330" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.SortedList.GetEnumerator">
          <source>Initially, the enumerator is positioned before the first element in the collection.</source>
          <target state="translated">Inicialmente, o enumerador é posicionado antes do primeiro elemento da coleção.</target>       </trans-unit>
        <trans-unit id="331" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.SortedList.GetEnumerator">
          <source><ph id="ph1">&lt;xref:System.Collections.IEnumerator.Reset%2A&gt;</ph> also brings the enumerator back to this position.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Collections.IEnumerator.Reset%2A&gt;</ph> também traz o enumerador de volta para essa posição.</target>       </trans-unit>
        <trans-unit id="332" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.SortedList.GetEnumerator">
          <source>At this position, <ph id="ph1">&lt;xref:System.Collections.IEnumerator.Current%2A&gt;</ph> is undefined.</source>
          <target state="translated">Nesta posição, <ph id="ph1">&lt;xref:System.Collections.IEnumerator.Current%2A&gt;</ph> está indefinido.</target>       </trans-unit>
        <trans-unit id="333" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.SortedList.GetEnumerator">
          <source>Therefore, you must call <ph id="ph1">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> to advance the enumerator to the first element of the collection before reading the value of <ph id="ph2">&lt;xref:System.Collections.IEnumerator.Current%2A&gt;</ph>.</source>
          <target state="translated">Por isso, você deve chamar <ph id="ph1">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> para avançar o enumerador até o primeiro elemento da coleção antes de ler o valor de <ph id="ph2">&lt;xref:System.Collections.IEnumerator.Current%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="334" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.SortedList.GetEnumerator">
          <source><ph id="ph1">&lt;xref:System.Collections.IEnumerator.Current%2A&gt;</ph> returns the same object until either <ph id="ph2">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> or <ph id="ph3">&lt;xref:System.Collections.IEnumerator.Reset%2A&gt;</ph> is called.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Collections.IEnumerator.Current%2A&gt;</ph> retorna o mesmo objeto até <ph id="ph2">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> ou <ph id="ph3">&lt;xref:System.Collections.IEnumerator.Reset%2A&gt;</ph> ser chamado.</target>       </trans-unit>
        <trans-unit id="335" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.SortedList.GetEnumerator">
          <source><ph id="ph1">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> sets <ph id="ph2">&lt;xref:System.Collections.IEnumerator.Current%2A&gt;</ph> to the next element.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> define <ph id="ph2">&lt;xref:System.Collections.IEnumerator.Current%2A&gt;</ph> como o próximo elemento.</target>       </trans-unit>
        <trans-unit id="336" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.SortedList.GetEnumerator">
          <source>If <ph id="ph1">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> passes the end of the collection, the enumerator is positioned after the last element in the collection and <ph id="ph2">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> returns <ph id="ph3">`false`</ph>.</source>
          <target state="translated">Caso <ph id="ph1">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> passe o final da coleção, o enumerador é posicionado após o último elemento na coleção e <ph id="ph2">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> retorna <ph id="ph3">`false`</ph>.</target>       </trans-unit>
        <trans-unit id="337" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.SortedList.GetEnumerator">
          <source>When the enumerator is at this position, subsequent calls to <ph id="ph1">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> also return <ph id="ph2">`false`</ph>.</source>
          <target state="translated">Quando o enumerador está nessa posição, as chamadas subsequentes para <ph id="ph1">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> também retornam <ph id="ph2">`false`</ph>.</target>       </trans-unit>
        <trans-unit id="338" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.SortedList.GetEnumerator">
          <source>If the last call to <ph id="ph1">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> returned <ph id="ph2">`false`</ph>, <ph id="ph3">&lt;xref:System.Collections.IEnumerator.Current%2A&gt;</ph> is undefined.</source>
          <target state="translated">Caso a última chamada para <ph id="ph1">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> tenha retornado <ph id="ph2">`false`</ph>, <ph id="ph3">&lt;xref:System.Collections.IEnumerator.Current%2A&gt;</ph> está indefinido.</target>       </trans-unit>
        <trans-unit id="339" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.SortedList.GetEnumerator">
          <source>To set <ph id="ph1">&lt;xref:System.Collections.IEnumerator.Current%2A&gt;</ph> to the first element of the collection again, you can call <ph id="ph2">&lt;xref:System.Collections.IEnumerator.Reset%2A&gt;</ph> followed by <ph id="ph3">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph>.</source>
          <target state="translated">Para definir <ph id="ph1">&lt;xref:System.Collections.IEnumerator.Current%2A&gt;</ph> como o primeiro elemento da coleção novamente, é possível chamar <ph id="ph2">&lt;xref:System.Collections.IEnumerator.Reset%2A&gt;</ph> seguido de <ph id="ph3">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="340" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.SortedList.GetEnumerator">
          <source>An enumerator remains valid as long as the collection remains unchanged.</source>
          <target state="translated">Um enumerador permanece válido desde que a coleção continue inalterada.</target>       </trans-unit>
        <trans-unit id="341" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.SortedList.GetEnumerator">
          <source>If changes are made to the collection, such as adding, modifying, or deleting elements, the enumerator is irrecoverably invalidated and its behavior is undefined.</source>
          <target state="translated">Se forem feitas alterações na coleção, como adicionar, modificar ou excluir elementos, o enumerador será invalidado de maneira irrevogável e seu comportamento permanecerá indefinido.</target>       </trans-unit>
        <trans-unit id="342" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.SortedList.GetEnumerator">
          <source>The enumerator does not have exclusive access to the collection; therefore, enumerating through a collection is intrinsically not a thread-safe procedure.</source>
          <target state="translated">O enumerador não tem acesso exclusivo à coleção; por isso, a enumeração por meio de uma coleção não é um procedimento thread-safe intrínseco.</target>       </trans-unit>
        <trans-unit id="343" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.SortedList.GetEnumerator">
          <source>To guarantee thread safety during enumeration, you can lock the collection during the entire enumeration.</source>
          <target state="translated">Para garantir acesso thread-safe durante a enumeração, é possível bloquear a coleção durante toda a enumeração.</target>       </trans-unit>
        <trans-unit id="344" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.SortedList.GetEnumerator">
          <source>To allow the collection to be accessed by multiple threads for reading and writing, you must implement your own synchronization.</source>
          <target state="translated">Para permitir que a coleção a ser acessado por vários threads para leitura e gravação, você deve implementar sua sincronização.</target>       </trans-unit>
        <trans-unit id="345" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.SortedList.GetEnumerator">
          <source>This method is an O(1) operation.</source>
          <target state="translated">Este método é uma operação O(1).</target>       </trans-unit>
        <trans-unit id="346" translate="yes" xml:space="preserve" uid="M:System.Collections.SortedList.GetKey(System.Int32)">
          <source>The zero-based index of the key to get.</source>
          <target state="translated">O índice de base zero da chave a ser obtida.</target>       </trans-unit>
        <trans-unit id="347" translate="yes" xml:space="preserve" uid="M:System.Collections.SortedList.GetKey(System.Int32)">
          <source>Gets the key at the specified index of a <ph id="ph1">&lt;see cref="T:System.Collections.SortedList" /&gt;</ph> object.</source>
          <target state="translated">Obtém a chave no índice especificado de um objeto <ph id="ph1">&lt;see cref="T:System.Collections.SortedList" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="348" translate="yes" xml:space="preserve" uid="M:System.Collections.SortedList.GetKey(System.Int32)">
          <source>The key at the specified index of the <ph id="ph1">&lt;see cref="T:System.Collections.SortedList" /&gt;</ph> object.</source>
          <target state="translated">A chave no índice especificado do objeto <ph id="ph1">&lt;see cref="T:System.Collections.SortedList" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="349" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.SortedList.GetKey(System.Int32)">
          <source>The index sequence is based on the sort sequence.</source>
          <target state="translated">A sequência de índice é baseada na sequência de classificação.</target>       </trans-unit>
        <trans-unit id="350" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.SortedList.GetKey(System.Int32)">
          <source>When an element is added, it is inserted into <ph id="ph1">&lt;xref:System.Collections.SortedList&gt;</ph> in the correct sort order, and the indexing adjusts accordingly.</source>
          <target state="translated">Quando um elemento é adicionado, ele será inserido na <ph id="ph1">&lt;xref:System.Collections.SortedList&gt;</ph> na classificação correta ordem e a indexação é ajustada de acordo.</target>       </trans-unit>
        <trans-unit id="351" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.SortedList.GetKey(System.Int32)">
          <source>When an element is removed, the indexing also adjusts accordingly.</source>
          <target state="translated">Quando um elemento for removido, a indexação também se ajusta.</target>       </trans-unit>
        <trans-unit id="352" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.SortedList.GetKey(System.Int32)">
          <source>Therefore, the index of a specific key/value pair might change as elements are added or removed from the <ph id="ph1">&lt;xref:System.Collections.SortedList&gt;</ph> object.</source>
          <target state="translated">Portanto, o índice de um par chave/valor específico pode alterar como os elementos são adicionados ou removidos do <ph id="ph1">&lt;xref:System.Collections.SortedList&gt;</ph> objeto.</target>       </trans-unit>
        <trans-unit id="353" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.SortedList.GetKey(System.Int32)">
          <source>This method is an O(1) operation.</source>
          <target state="translated">Este método é uma operação O(1).</target>       </trans-unit>
        <trans-unit id="354" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.SortedList.GetKey(System.Int32)">
          <source>The following code example shows how to get one or all the keys or values in a <ph id="ph1">&lt;xref:System.Collections.SortedList&gt;</ph> object.</source>
          <target state="translated">O exemplo de código a seguir mostra como obter uma ou todas as chaves ou valores em uma <ph id="ph1">&lt;xref:System.Collections.SortedList&gt;</ph> objeto.</target>       </trans-unit>
        <trans-unit id="355" translate="yes" xml:space="preserve" uid="M:System.Collections.SortedList.GetKey(System.Int32)">
          <source><ph id="ph1">&lt;paramref name="index" /&gt;</ph> is outside the range of valid indexes for the <ph id="ph2">&lt;see cref="T:System.Collections.SortedList" /&gt;</ph> object.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="index" /&gt;</ph> está fora do intervalo de índices válidos para o objeto <ph id="ph2">&lt;see cref="T:System.Collections.SortedList" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="356" translate="yes" xml:space="preserve" uid="M:System.Collections.SortedList.GetKeyList">
          <source>Gets the keys in a <ph id="ph1">&lt;see cref="T:System.Collections.SortedList" /&gt;</ph> object.</source>
          <target state="translated">Obtém as chaves em um objeto <ph id="ph1">&lt;see cref="T:System.Collections.SortedList" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="357" translate="yes" xml:space="preserve" uid="M:System.Collections.SortedList.GetKeyList">
          <source>An <ph id="ph1">&lt;see cref="T:System.Collections.IList" /&gt;</ph> object containing the keys in the <ph id="ph2">&lt;see cref="T:System.Collections.SortedList" /&gt;</ph> object.</source>
          <target state="translated">Um objeto <ph id="ph1">&lt;see cref="T:System.Collections.IList" /&gt;</ph> que contém as chaves no objeto <ph id="ph2">&lt;see cref="T:System.Collections.SortedList" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="358" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.SortedList.GetKeyList">
          <source>The returned <ph id="ph1">&lt;xref:System.Collections.IList&gt;</ph> object is a read-only view of the keys of the <ph id="ph2">&lt;xref:System.Collections.SortedList&gt;</ph> object.</source>
          <target state="translated">Retornado <ph id="ph1">&lt;xref:System.Collections.IList&gt;</ph> objeto é uma exibição somente leitura das chaves do <ph id="ph2">&lt;xref:System.Collections.SortedList&gt;</ph> objeto.</target>       </trans-unit>
        <trans-unit id="359" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.SortedList.GetKeyList">
          <source>Modifications made to the underlying <ph id="ph1">&lt;xref:System.Collections.SortedList&gt;</ph> are immediately reflected in the <ph id="ph2">&lt;xref:System.Collections.IList&gt;</ph>.</source>
          <target state="translated">As modificações feitas subjacente <ph id="ph1">&lt;xref:System.Collections.SortedList&gt;</ph> são imediatamente refletidos no <ph id="ph2">&lt;xref:System.Collections.IList&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="360" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.SortedList.GetKeyList">
          <source>The elements of the returned <ph id="ph1">&lt;xref:System.Collections.IList&gt;</ph> are sorted in the same order as the keys of the <ph id="ph2">&lt;xref:System.Collections.SortedList&gt;</ph>.</source>
          <target state="translated">Os elementos de retornado <ph id="ph1">&lt;xref:System.Collections.IList&gt;</ph> são classificados na mesma ordem que as chaves dos <ph id="ph2">&lt;xref:System.Collections.SortedList&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="361" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.SortedList.GetKeyList">
          <source>This method is similar to the <ph id="ph1">&lt;xref:System.Collections.SortedList.Keys%2A&gt;</ph> property, but returns an <ph id="ph2">&lt;xref:System.Collections.IList&gt;</ph> object instead of an <ph id="ph3">&lt;xref:System.Collections.ICollection&gt;</ph> object.</source>
          <target state="translated">Esse método é semelhante do <ph id="ph1">&lt;xref:System.Collections.SortedList.Keys%2A&gt;</ph> propriedade, mas retorna um <ph id="ph2">&lt;xref:System.Collections.IList&gt;</ph> do objeto, em vez de um <ph id="ph3">&lt;xref:System.Collections.ICollection&gt;</ph> objeto.</target>       </trans-unit>
        <trans-unit id="362" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.SortedList.GetKeyList">
          <source>This method is an O(1) operation.</source>
          <target state="translated">Este método é uma operação O(1).</target>       </trans-unit>
        <trans-unit id="363" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.SortedList.GetKeyList">
          <source>The following code example shows how to get one or all the keys or values in a <ph id="ph1">&lt;xref:System.Collections.SortedList&gt;</ph> object.</source>
          <target state="translated">O exemplo de código a seguir mostra como obter uma ou todas as chaves ou valores em uma <ph id="ph1">&lt;xref:System.Collections.SortedList&gt;</ph> objeto.</target>       </trans-unit>
        <trans-unit id="364" translate="yes" xml:space="preserve" uid="M:System.Collections.SortedList.GetValueList">
          <source>Gets the values in a <ph id="ph1">&lt;see cref="T:System.Collections.SortedList" /&gt;</ph> object.</source>
          <target state="translated">Obtém os valores em um objeto <ph id="ph1">&lt;see cref="T:System.Collections.SortedList" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="365" translate="yes" xml:space="preserve" uid="M:System.Collections.SortedList.GetValueList">
          <source>An <ph id="ph1">&lt;see cref="T:System.Collections.IList" /&gt;</ph> object containing the values in the <ph id="ph2">&lt;see cref="T:System.Collections.SortedList" /&gt;</ph> object.</source>
          <target state="translated">Um objeto <ph id="ph1">&lt;see cref="T:System.Collections.IList" /&gt;</ph> que contém os valores no objeto <ph id="ph2">&lt;see cref="T:System.Collections.SortedList" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="366" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.SortedList.GetValueList">
          <source>The returned <ph id="ph1">&lt;xref:System.Collections.IList&gt;</ph> object is a read-only view of the values of the <ph id="ph2">&lt;xref:System.Collections.SortedList&gt;</ph> object.</source>
          <target state="translated">Retornado <ph id="ph1">&lt;xref:System.Collections.IList&gt;</ph> objeto é uma exibição somente leitura dos valores da <ph id="ph2">&lt;xref:System.Collections.SortedList&gt;</ph> objeto.</target>       </trans-unit>
        <trans-unit id="367" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.SortedList.GetValueList">
          <source>Modifications made to the underlying <ph id="ph1">&lt;xref:System.Collections.SortedList&gt;</ph> are immediately reflected in the <ph id="ph2">&lt;xref:System.Collections.IList&gt;</ph>.</source>
          <target state="translated">As modificações feitas subjacente <ph id="ph1">&lt;xref:System.Collections.SortedList&gt;</ph> são imediatamente refletidos no <ph id="ph2">&lt;xref:System.Collections.IList&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="368" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.SortedList.GetValueList">
          <source>The elements of the returned <ph id="ph1">&lt;xref:System.Collections.IList&gt;</ph> are sorted in the same order as the values of the <ph id="ph2">&lt;xref:System.Collections.SortedList&gt;</ph>.</source>
          <target state="translated">Os elementos de retornado <ph id="ph1">&lt;xref:System.Collections.IList&gt;</ph> são classificados na mesma ordem que os valores de <ph id="ph2">&lt;xref:System.Collections.SortedList&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="369" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.SortedList.GetValueList">
          <source>This method is similar to the <ph id="ph1">&lt;xref:System.Collections.SortedList.Values%2A&gt;</ph> property, but returns an <ph id="ph2">&lt;xref:System.Collections.IList&gt;</ph> object instead of an <ph id="ph3">&lt;xref:System.Collections.ICollection&gt;</ph> object.</source>
          <target state="translated">Esse método é semelhante do <ph id="ph1">&lt;xref:System.Collections.SortedList.Values%2A&gt;</ph> propriedade, mas retorna um <ph id="ph2">&lt;xref:System.Collections.IList&gt;</ph> do objeto, em vez de um <ph id="ph3">&lt;xref:System.Collections.ICollection&gt;</ph> objeto.</target>       </trans-unit>
        <trans-unit id="370" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.SortedList.GetValueList">
          <source>This method is an O(1) operation.</source>
          <target state="translated">Este método é uma operação O(1).</target>       </trans-unit>
        <trans-unit id="371" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.SortedList.GetValueList">
          <source>The following code example shows how to get one or all the keys or values in a <ph id="ph1">&lt;xref:System.Collections.SortedList&gt;</ph> object.</source>
          <target state="translated">O exemplo de código a seguir mostra como obter uma ou todas as chaves ou valores em uma <ph id="ph1">&lt;xref:System.Collections.SortedList&gt;</ph> objeto.</target>       </trans-unit>
        <trans-unit id="372" translate="yes" xml:space="preserve" uid="M:System.Collections.SortedList.IndexOfKey(System.Object)">
          <source>The key to locate in the <ph id="ph1">&lt;see cref="T:System.Collections.SortedList" /&gt;</ph> object.</source>
          <target state="translated">A chave a ser localizada no objeto <ph id="ph1">&lt;see cref="T:System.Collections.SortedList" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="373" translate="yes" xml:space="preserve" uid="M:System.Collections.SortedList.IndexOfKey(System.Object)">
          <source>Returns the zero-based index of the specified key in a <ph id="ph1">&lt;see cref="T:System.Collections.SortedList" /&gt;</ph> object.</source>
          <target state="translated">Retorna o índice baseado em zero da chave especificada em um objeto <ph id="ph1">&lt;see cref="T:System.Collections.SortedList" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="374" translate="yes" xml:space="preserve" uid="M:System.Collections.SortedList.IndexOfKey(System.Object)">
          <source>The zero-based index of the <ph id="ph1">&lt;paramref name="key" /&gt;</ph> parameter, if <ph id="ph2">&lt;paramref name="key" /&gt;</ph> is found in the <ph id="ph3">&lt;see cref="T:System.Collections.SortedList" /&gt;</ph> object; otherwise, -1.</source>
          <target state="translated">O índice baseado em zero do parâmetro <ph id="ph1">&lt;paramref name="key" /&gt;</ph>, se <ph id="ph2">&lt;paramref name="key" /&gt;</ph> for encontrado no objeto <ph id="ph3">&lt;see cref="T:System.Collections.SortedList" /&gt;</ph>; caso contrário, -1.</target>       </trans-unit>
        <trans-unit id="375" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.SortedList.IndexOfKey(System.Object)">
          <source>The elements of a <ph id="ph1">&lt;xref:System.Collections.SortedList&gt;</ph> object are sorted by the keys either according to a specific <ph id="ph2">&lt;xref:System.Collections.IComparer&gt;</ph> implementation specified when the <ph id="ph3">&lt;xref:System.Collections.SortedList&gt;</ph> is created, or according to the <ph id="ph4">&lt;xref:System.IComparable&gt;</ph> implementation provided by the keys themselves.</source>
          <target state="translated">Os elementos de um <ph id="ph1">&lt;xref:System.Collections.SortedList&gt;</ph> objeto são classificados pelas chaves de um acordo com um determinado <ph id="ph2">&lt;xref:System.Collections.IComparer&gt;</ph> implementação especificado quando o <ph id="ph3">&lt;xref:System.Collections.SortedList&gt;</ph> é criado ou acordo para o <ph id="ph4">&lt;xref:System.IComparable&gt;</ph> as próprias chaves a implementação.</target>       </trans-unit>
        <trans-unit id="376" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.SortedList.IndexOfKey(System.Object)">
          <source>The index sequence is based on the sort sequence.</source>
          <target state="translated">A sequência de índice é baseada na sequência de classificação.</target>       </trans-unit>
        <trans-unit id="377" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.SortedList.IndexOfKey(System.Object)">
          <source>When an element is added, it is inserted into <ph id="ph1">&lt;xref:System.Collections.SortedList&gt;</ph> in the correct sort order, and the indexing adjusts accordingly.</source>
          <target state="translated">Quando um elemento é adicionado, ele será inserido na <ph id="ph1">&lt;xref:System.Collections.SortedList&gt;</ph> na classificação correta ordem e a indexação é ajustada de acordo.</target>       </trans-unit>
        <trans-unit id="378" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.SortedList.IndexOfKey(System.Object)">
          <source>When an element is removed, the indexing also adjusts accordingly.</source>
          <target state="translated">Quando um elemento for removido, a indexação também se ajusta.</target>       </trans-unit>
        <trans-unit id="379" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.SortedList.IndexOfKey(System.Object)">
          <source>Therefore, the index of a specific key/value pair might change as elements are added or removed from the <ph id="ph1">&lt;xref:System.Collections.SortedList&gt;</ph>.</source>
          <target state="translated">Portanto, o índice de um par chave/valor específico pode alterar como os elementos são adicionados ou removidos do <ph id="ph1">&lt;xref:System.Collections.SortedList&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="380" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.SortedList.IndexOfKey(System.Object)">
          <source>This method uses a binary search algorithm; therefore, this method is an O(log <ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is <ph id="ph3">&lt;xref:System.Collections.SortedList.Count%2A&gt;</ph>.</source>
          <target state="translated">Esse método usa um algoritmo de pesquisa binário; Portanto, esse método é um O (log <ph id="ph1">`n`</ph>) operação, onde <ph id="ph2">`n`</ph> é <ph id="ph3">&lt;xref:System.Collections.SortedList.Count%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="381" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.SortedList.IndexOfKey(System.Object)">
          <source>Starting with the .NET Framework 2.0, this method uses the collection’s objects’ <ph id="ph1">&lt;xref:System.Object.Equals%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.IComparable.CompareTo%2A&gt;</ph> methods on <ph id="ph3">`item`</ph> to determine whether item exists.</source>
          <target state="translated">Começando pelo .NET Framework 2.0, esse método usa os métodos <ph id="ph1">&lt;xref:System.Object.Equals%2A&gt;</ph> e <ph id="ph2">&lt;xref:System.IComparable.CompareTo%2A&gt;</ph> do objeto da coleção em <ph id="ph3">`item`</ph> para determinar se o item existe.</target>       </trans-unit>
        <trans-unit id="382" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.SortedList.IndexOfKey(System.Object)">
          <source>In the earlier versions of the .NET Framework, this determination was made by using the <ph id="ph1">&lt;xref:System.Object.Equals%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.IComparable.CompareTo%2A&gt;</ph> methods of the <ph id="ph3">`item`</ph> parameter on the objects in the collection.</source>
          <target state="translated">Em versões anteriores do .NET Framework, essa decisão era tomada usando-se os métodos <ph id="ph1">&lt;xref:System.Object.Equals%2A&gt;</ph> e <ph id="ph2">&lt;xref:System.IComparable.CompareTo%2A&gt;</ph> do parâmetro <ph id="ph3">`item`</ph> nos objetos na coleção.</target>       </trans-unit>
        <trans-unit id="383" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.SortedList.IndexOfKey(System.Object)">
          <source>The following code example shows how to determine the index of a key or a value in a <ph id="ph1">&lt;xref:System.Collections.SortedList&gt;</ph> object.</source>
          <target state="translated">O exemplo de código a seguir mostra como determinar o índice de uma chave ou um valor em uma <ph id="ph1">&lt;xref:System.Collections.SortedList&gt;</ph> objeto.</target>       </trans-unit>
        <trans-unit id="384" translate="yes" xml:space="preserve" uid="M:System.Collections.SortedList.IndexOfKey(System.Object)">
          <source><ph id="ph1">&lt;paramref name="key" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="key" /&gt;</ph> é <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="385" translate="yes" xml:space="preserve" uid="M:System.Collections.SortedList.IndexOfKey(System.Object)">
          <source>The comparer throws an exception.</source>
          <target state="translated">O comparador gera uma exceção.</target>       </trans-unit>
        <trans-unit id="386" translate="yes" xml:space="preserve" uid="M:System.Collections.SortedList.IndexOfValue(System.Object)">
          <source>The value to locate in the <ph id="ph1">&lt;see cref="T:System.Collections.SortedList" /&gt;</ph> object.</source>
          <target state="translated">O valor a ser localizado no objeto <ph id="ph1">&lt;see cref="T:System.Collections.SortedList" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="387" translate="yes" xml:space="preserve" uid="M:System.Collections.SortedList.IndexOfValue(System.Object)">
          <source>The value can be <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">O valor pode ser <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="388" translate="yes" xml:space="preserve" uid="M:System.Collections.SortedList.IndexOfValue(System.Object)">
          <source>Returns the zero-based index of the first occurrence of the specified value in a <ph id="ph1">&lt;see cref="T:System.Collections.SortedList" /&gt;</ph> object.</source>
          <target state="translated">Retorna o índice baseado em zero da primeira ocorrência do valor especificado em um objeto <ph id="ph1">&lt;see cref="T:System.Collections.SortedList" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="389" translate="yes" xml:space="preserve" uid="M:System.Collections.SortedList.IndexOfValue(System.Object)">
          <source>The zero-based index of the first occurrence of the <ph id="ph1">&lt;paramref name="value" /&gt;</ph> parameter, if <ph id="ph2">&lt;paramref name="value" /&gt;</ph> is found in the <ph id="ph3">&lt;see cref="T:System.Collections.SortedList" /&gt;</ph> object; otherwise, -1.</source>
          <target state="translated">O índice baseado em zero da primeira ocorrência do parâmetro <ph id="ph1">&lt;paramref name="value" /&gt;</ph>, se <ph id="ph2">&lt;paramref name="value" /&gt;</ph> for encontrado no objeto <ph id="ph3">&lt;see cref="T:System.Collections.SortedList" /&gt;</ph>; caso contrário, -1.</target>       </trans-unit>
        <trans-unit id="390" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.SortedList.IndexOfValue(System.Object)">
          <source>The index sequence is based on the sort sequence.</source>
          <target state="translated">A sequência de índice é baseada na sequência de classificação.</target>       </trans-unit>
        <trans-unit id="391" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.SortedList.IndexOfValue(System.Object)">
          <source>When an element is added, it is inserted into <ph id="ph1">&lt;xref:System.Collections.SortedList&gt;</ph> in the correct sort order, and the indexing adjusts accordingly.</source>
          <target state="translated">Quando um elemento é adicionado, ele será inserido na <ph id="ph1">&lt;xref:System.Collections.SortedList&gt;</ph> na classificação correta ordem e a indexação é ajustada de acordo.</target>       </trans-unit>
        <trans-unit id="392" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.SortedList.IndexOfValue(System.Object)">
          <source>When an element is removed, the indexing also adjusts accordingly.</source>
          <target state="translated">Quando um elemento for removido, a indexação também se ajusta.</target>       </trans-unit>
        <trans-unit id="393" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.SortedList.IndexOfValue(System.Object)">
          <source>Therefore, the index of a specific key/value pair might change as elements are added or removed from the <ph id="ph1">&lt;xref:System.Collections.SortedList&gt;</ph> object.</source>
          <target state="translated">Portanto, o índice de um par chave/valor específico pode alterar como os elementos são adicionados ou removidos do <ph id="ph1">&lt;xref:System.Collections.SortedList&gt;</ph> objeto.</target>       </trans-unit>
        <trans-unit id="394" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.SortedList.IndexOfValue(System.Object)">
          <source>The values of the elements of the <ph id="ph1">&lt;xref:System.Collections.SortedList&gt;</ph> are compared to the specified value using the <ph id="ph2">&lt;xref:System.Object.Equals%2A&gt;</ph> method.</source>
          <target state="translated">Os valores dos elementos do <ph id="ph1">&lt;xref:System.Collections.SortedList&gt;</ph> são comparados com o valor especificado usando o <ph id="ph2">&lt;xref:System.Object.Equals%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="395" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.SortedList.IndexOfValue(System.Object)">
          <source>This method uses a linear search; therefore, this method is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is <ph id="ph3">&lt;xref:System.Collections.SortedList.Count%2A&gt;</ph>.</source>
          <target state="translated">Esse método usa uma pesquisa linear; Portanto, esse método é um O (<ph id="ph1">`n`</ph>) operação, onde <ph id="ph2">`n`</ph> é <ph id="ph3">&lt;xref:System.Collections.SortedList.Count%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="396" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.SortedList.IndexOfValue(System.Object)">
          <source>Starting with the .NET Framework 2.0, this method uses the collection’s objects’ <ph id="ph1">&lt;xref:System.Object.Equals%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.IComparable.CompareTo%2A&gt;</ph> methods on <ph id="ph3">`item`</ph> to determine whether item exists.</source>
          <target state="translated">Começando pelo .NET Framework 2.0, esse método usa os métodos <ph id="ph1">&lt;xref:System.Object.Equals%2A&gt;</ph> e <ph id="ph2">&lt;xref:System.IComparable.CompareTo%2A&gt;</ph> do objeto da coleção em <ph id="ph3">`item`</ph> para determinar se o item existe.</target>       </trans-unit>
        <trans-unit id="397" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.SortedList.IndexOfValue(System.Object)">
          <source>In the earlier versions of the .NET Framework, this determination was made by using the <ph id="ph1">&lt;xref:System.Object.Equals%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.IComparable.CompareTo%2A&gt;</ph> methods of the <ph id="ph3">`item`</ph> parameter on the objects in the collection.</source>
          <target state="translated">Em versões anteriores do .NET Framework, essa decisão era tomada usando-se os métodos <ph id="ph1">&lt;xref:System.Object.Equals%2A&gt;</ph> e <ph id="ph2">&lt;xref:System.IComparable.CompareTo%2A&gt;</ph> do parâmetro <ph id="ph3">`item`</ph> nos objetos na coleção.</target>       </trans-unit>
        <trans-unit id="398" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.SortedList.IndexOfValue(System.Object)">
          <source>The following code example shows how to determine the index of a key or a value in a <ph id="ph1">&lt;xref:System.Collections.SortedList&gt;</ph> object.</source>
          <target state="translated">O exemplo de código a seguir mostra como determinar o índice de uma chave ou um valor em uma <ph id="ph1">&lt;xref:System.Collections.SortedList&gt;</ph> objeto.</target>       </trans-unit>
        <trans-unit id="399" translate="yes" xml:space="preserve" uid="P:System.Collections.SortedList.IsFixedSize">
          <source>Gets a value indicating whether a <ph id="ph1">&lt;see cref="T:System.Collections.SortedList" /&gt;</ph> object has a fixed size.</source>
          <target state="translated">Obtém um valor que indica se o objeto <ph id="ph1">&lt;see cref="T:System.Collections.SortedList" /&gt;</ph> tem um tamanho fixo.</target>       </trans-unit>
        <trans-unit id="400" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.SortedList.IsFixedSize">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the <ph id="ph2">&lt;see cref="T:System.Collections.SortedList" /&gt;</ph> object has a fixed size; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> Se o <ph id="ph2">&lt;see cref="T:System.Collections.SortedList" /&gt;</ph> objeto tem um fixa tamanho; caso contrário, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="401" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.SortedList.IsFixedSize">
          <source>The default is <ph id="ph1">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">O padrão é <ph id="ph1">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="402" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.SortedList.IsFixedSize">
          <source>A collection with a fixed size does not allow the addition or removal of elements after the collection is created, but does allow the modification of existing elements.</source>
          <target state="translated">Uma coleção com um tamanho fixo não permite a adição ou remoção de elementos após a coleção é criada, mas permitir a modificação de elementos existentes.</target>       </trans-unit>
        <trans-unit id="403" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.SortedList.IsFixedSize">
          <source>A collection with a fixed size is simply a collection with a wrapper that prevents adding and removing elements; therefore, if changes are made to the underlying collection, including the addition or removal of elements, the fixed-size collection reflects those changes.</source>
          <target state="translated">Uma coleção com um tamanho fixo é simplesmente uma coleção com um wrapper que impede a adição e a remoção de elementos; por isso, caso as alterações sejam feitas na coleção subjacente, inclusive a adição ou a remoção de elementos, a coleção de tamanho fixo reflete essas alterações.</target>       </trans-unit>
        <trans-unit id="404" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.SortedList.IsFixedSize">
          <source>Retrieving the value of this property is an O(1) operation.</source>
          <target state="translated">A recuperação do valor dessa propriedade é uma operação O(1).</target>       </trans-unit>
        <trans-unit id="405" translate="yes" xml:space="preserve" uid="P:System.Collections.SortedList.IsReadOnly">
          <source>Gets a value indicating whether a <ph id="ph1">&lt;see cref="T:System.Collections.SortedList" /&gt;</ph> object is read-only.</source>
          <target state="translated">Obtém um valor que indica se um objeto <ph id="ph1">&lt;see cref="T:System.Collections.SortedList" /&gt;</ph> é somente leitura.</target>       </trans-unit>
        <trans-unit id="406" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.SortedList.IsReadOnly">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the <ph id="ph2">&lt;see cref="T:System.Collections.SortedList" /&gt;</ph> object is read-only; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> se o objeto <ph id="ph2">&lt;see cref="T:System.Collections.SortedList" /&gt;</ph> for somente leitura; caso contrário, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="407" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.SortedList.IsReadOnly">
          <source>The default is <ph id="ph1">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">O padrão é <ph id="ph1">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="408" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.SortedList.IsReadOnly">
          <source>A collection that is read-only does not allow the addition, removal, or modification of elements after the collection is created.</source>
          <target state="translated">Uma coleção que seja somente leitura não permite a adição, a remoção ou a modificação de elementos após a coleção ser criada.</target>       </trans-unit>
        <trans-unit id="409" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.SortedList.IsReadOnly">
          <source>A collection that is read-only is simply a collection with a wrapper that prevents modifying the collection; therefore, if changes are made to the underlying collection, the read-only collection reflects those changes.</source>
          <target state="translated">Uma coleção somente leitura é apenas uma coleção com um wrapper que impede a modificação da coleção; por isso, caso as alterações sejam feitas na coleção subjacente, a coleção somente leitura reflete as alterações.</target>       </trans-unit>
        <trans-unit id="410" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.SortedList.IsReadOnly">
          <source>Retrieving the value of this property is an O(1) operation.</source>
          <target state="translated">A recuperação do valor dessa propriedade é uma operação O(1).</target>       </trans-unit>
        <trans-unit id="411" translate="yes" xml:space="preserve" uid="P:System.Collections.SortedList.IsSynchronized">
          <source>Gets a value indicating whether access to a <ph id="ph1">&lt;see cref="T:System.Collections.SortedList" /&gt;</ph> object is synchronized (thread safe).</source>
          <target state="translated">Obtém um valor que indica se o acesso a um objeto <ph id="ph1">&lt;see cref="T:System.Collections.SortedList" /&gt;</ph> é sincronizado (thread-safe).</target>       </trans-unit>
        <trans-unit id="412" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.SortedList.IsSynchronized">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if access to the <ph id="ph2">&lt;see cref="T:System.Collections.SortedList" /&gt;</ph> object is synchronized (thread safe); otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> Se acessar para o <ph id="ph2">&lt;see cref="T:System.Collections.SortedList" /&gt;</ph> objeto for sincronizado (thread-safe); caso contrário, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="413" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.SortedList.IsSynchronized">
          <source>The default is <ph id="ph1">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">O padrão é <ph id="ph1">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="414" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.SortedList.IsSynchronized">
          <source>To guarantee the thread safety of a <ph id="ph1">&lt;xref:System.Collections.SortedList&gt;</ph> object, all operations must be done through the wrapper returned by the <ph id="ph2">&lt;xref:System.Collections.SortedList.Synchronized%2A&gt;</ph> method.</source>
          <target state="translated">Para garantir a segurança de thread de um <ph id="ph1">&lt;xref:System.Collections.SortedList&gt;</ph> do objeto, todas as operações devem ser feitas por meio do wrapper retornado pelo <ph id="ph2">&lt;xref:System.Collections.SortedList.Synchronized%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="415" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.SortedList.IsSynchronized">
          <source>Enumerating through a collection is intrinsically not a thread-safe procedure.</source>
          <target state="translated">A enumeração por meio de uma coleção não é um procedimento thread-safe intrínseco.</target>       </trans-unit>
        <trans-unit id="416" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.SortedList.IsSynchronized">
          <source>Even when a collection is synchronized, other threads can still modify the collection, which causes the enumerator to throw an exception.</source>
          <target state="translated">Mesmo quando uma coleção está sincronizada, outros threads ainda podem modificar a coleção, o que faz o enumerador lançar uma exceção.</target>       </trans-unit>
        <trans-unit id="417" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.SortedList.IsSynchronized">
          <source>To guarantee thread safety during enumeration, you can either lock the collection during the entire enumeration or catch the exceptions resulting from changes made by other threads.</source>
          <target state="translated">Para garantir thread-safe durante a enumeração, é possível bloquear a coleção durante toda a enumeração ou verificar as exceções resultantes das alterações feitas por outros threads.</target>       </trans-unit>
        <trans-unit id="418" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.SortedList.IsSynchronized">
          <source>The following code example shows how to lock a collection using the <ph id="ph1">&lt;xref:System.Collections.SortedList.SyncRoot%2A&gt;</ph> property during the entire enumeration.</source>
          <target state="translated">O exemplo de código a seguir mostra como bloquear uma coleção usando o <ph id="ph1">&lt;xref:System.Collections.SortedList.SyncRoot%2A&gt;</ph> propriedade durante toda a enumeração.</target>       </trans-unit>
        <trans-unit id="419" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.SortedList.IsSynchronized">
          <source>Retrieving the value of this property is an O(1) operation.</source>
          <target state="translated">A recuperação do valor dessa propriedade é uma operação O(1).</target>       </trans-unit>
        <trans-unit id="420" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.SortedList.IsSynchronized">
          <source>The following code example shows how to synchronize a <ph id="ph1">&lt;xref:System.Collections.SortedList&gt;</ph> object, determine whether a <ph id="ph2">&lt;xref:System.Collections.SortedList&gt;</ph> is synchronized, and use a synchronized <ph id="ph3">&lt;xref:System.Collections.SortedList&gt;</ph>.</source>
          <target state="translated">O exemplo de código a seguir mostra como sincronizar um <ph id="ph1">&lt;xref:System.Collections.SortedList&gt;</ph> de objeto, determinar se um <ph id="ph2">&lt;xref:System.Collections.SortedList&gt;</ph> está sincronizado e usar um sincronizado <ph id="ph3">&lt;xref:System.Collections.SortedList&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="421" translate="yes" xml:space="preserve" uid="P:System.Collections.SortedList.Item(System.Object)">
          <source>The key associated with the value to get or set.</source>
          <target state="translated">A chave associada com o valor a ser obtido ou definido.</target>       </trans-unit>
        <trans-unit id="422" translate="yes" xml:space="preserve" uid="P:System.Collections.SortedList.Item(System.Object)">
          <source>Gets and sets the value associated with a specific key in a <ph id="ph1">&lt;see cref="T:System.Collections.SortedList" /&gt;</ph> object.</source>
          <target state="translated">Obtém e define o valor associado com uma chave específica em um objeto <ph id="ph1">&lt;see cref="T:System.Collections.SortedList" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="423" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.SortedList.Item(System.Object)">
          <source>The value associated with the <ph id="ph1">&lt;paramref name="key" /&gt;</ph> parameter in the <ph id="ph2">&lt;see cref="T:System.Collections.SortedList" /&gt;</ph> object, if <ph id="ph3">&lt;paramref name="key" /&gt;</ph> is found; otherwise, <ph id="ph4">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">O valor associado ao parâmetro <ph id="ph1">&lt;paramref name="key" /&gt;</ph> no objeto <ph id="ph2">&lt;see cref="T:System.Collections.SortedList" /&gt;</ph> se <ph id="ph3">&lt;paramref name="key" /&gt;</ph> for localizado; caso contrário, <ph id="ph4">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="424" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.SortedList.Item(System.Object)">
          <source>You can use the <ph id="ph1">&lt;xref:System.Collections.SortedList.Item%2A&gt;</ph> property to access a specific element in a collection by specifying the following syntax: <ph id="ph2">`myCollection[key]`</ph>.</source>
          <target state="translated">Você pode usar o <ph id="ph1">&lt;xref:System.Collections.SortedList.Item%2A&gt;</ph> propriedade para acessar um elemento específico em uma coleção, especificando a seguinte sintaxe: <ph id="ph2">`myCollection[key]`</ph>.</target>       </trans-unit>
        <trans-unit id="425" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.SortedList.Item(System.Object)">
          <source>You can also use this property to add new elements by setting the value of a key that does not exist in the <ph id="ph1">&lt;xref:System.Collections.SortedList&gt;</ph> object (for example, <ph id="ph2">`myCollection["myNonexistentKey"] = myValue)`</ph>.</source>
          <target state="translated">Você também pode usar essa propriedade para adicionar novos elementos, definindo o valor de uma chave que não existe no <ph id="ph1">&lt;xref:System.Collections.SortedList&gt;</ph> objeto (por exemplo, <ph id="ph2">`myCollection["myNonexistentKey"] = myValue)`</ph>.</target>       </trans-unit>
        <trans-unit id="426" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.SortedList.Item(System.Object)">
          <source>However, if the specified key already exists in the <ph id="ph1">&lt;xref:System.Collections.SortedList&gt;</ph>, setting the <ph id="ph2">&lt;xref:System.Collections.SortedList.Item%2A&gt;</ph> property overwrites the old value.</source>
          <target state="translated">No entanto, se a chave especificada já existe no <ph id="ph1">&lt;xref:System.Collections.SortedList&gt;</ph>, a definição de <ph id="ph2">&lt;xref:System.Collections.SortedList.Item%2A&gt;</ph> propriedade substitui o valor antigo.</target>       </trans-unit>
        <trans-unit id="427" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.SortedList.Item(System.Object)">
          <source>In contrast, the <ph id="ph1">&lt;xref:System.Collections.SortedList.Add%2A&gt;</ph> method does not modify existing elements.</source>
          <target state="translated">Em contraste, o <ph id="ph1">&lt;xref:System.Collections.SortedList.Add%2A&gt;</ph> método não modifica os elementos existentes.</target>       </trans-unit>
        <trans-unit id="428" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.SortedList.Item(System.Object)">
          <source>A key cannot be <ph id="ph1">`null`</ph>, but a value can be.</source>
          <target state="translated">Uma chave não pode ser <ph id="ph1">`null`</ph>, mas pode ser um valor.</target>       </trans-unit>
        <trans-unit id="429" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.SortedList.Item(System.Object)">
          <source>To distinguish between <ph id="ph1">`null`</ph> that is returned because the specified key is not found and <ph id="ph2">`null`</ph> that is returned because the value of the specified key is <ph id="ph3">`null`</ph>, use the <ph id="ph4">&lt;xref:System.Collections.SortedList.Contains%2A&gt;</ph> method or the <ph id="ph5">&lt;xref:System.Collections.SortedList.ContainsKey%2A&gt;</ph> method to determine if the key exists in the list.</source>
          <target state="translated">Para distinguir entre <ph id="ph1">`null`</ph> que é retornado porque a chave especificada não foi encontrada e <ph id="ph2">`null`</ph> que é retornado porque o valor da chave especificada é <ph id="ph3">`null`</ph>, use o <ph id="ph4">&lt;xref:System.Collections.SortedList.Contains%2A&gt;</ph> método ou o <ph id="ph5">&lt;xref:System.Collections.SortedList.ContainsKey%2A&gt;</ph> método para determinar se a chave existe na lista.</target>       </trans-unit>
        <trans-unit id="430" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.SortedList.Item(System.Object)">
          <source>The elements of a <ph id="ph1">&lt;xref:System.Collections.SortedList&gt;</ph> are sorted by the keys either according to a specific <ph id="ph2">&lt;xref:System.Collections.IComparer&gt;</ph> implementation specified when the <ph id="ph3">&lt;xref:System.Collections.SortedList&gt;</ph> is created or according to the <ph id="ph4">&lt;xref:System.IComparable&gt;</ph> implementation provided by the keys themselves.</source>
          <target state="translated">Os elementos de um <ph id="ph1">&lt;xref:System.Collections.SortedList&gt;</ph> são classificados pelas chaves de um acordo com um determinado <ph id="ph2">&lt;xref:System.Collections.IComparer&gt;</ph> implementação especificado quando o <ph id="ph3">&lt;xref:System.Collections.SortedList&gt;</ph> é criado ou acordo para o <ph id="ph4">&lt;xref:System.IComparable&gt;</ph> as próprias chaves a implementação.</target>       </trans-unit>
        <trans-unit id="431" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.SortedList.Item(System.Object)">
          <source>The C# language uses the  keyword to define the indexers instead of implementing the <ph id="ph1">&lt;xref:System.Collections.SortedList.Keys%2A&gt;</ph> property.</source>
          <target state="translated">A linguagem c# usa a palavra-chave para definir os indexadores em vez de implementar o <ph id="ph1">&lt;xref:System.Collections.SortedList.Keys%2A&gt;</ph> propriedade.</target>       </trans-unit>
        <trans-unit id="432" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.SortedList.Item(System.Object)">
          <source>Visual Basic implements <ph id="ph1">&lt;xref:System.Collections.SortedList.Item%2A&gt;</ph> as a default property, which provides the same indexing functionality.</source>
          <target state="translated">Visual Basic implementa <ph id="ph1">&lt;xref:System.Collections.SortedList.Item%2A&gt;</ph> como uma propriedade padrão, que fornece a mesma funcionalidade de indexação.</target>       </trans-unit>
        <trans-unit id="433" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.SortedList.Item(System.Object)">
          <source>Retrieving the value of this property is an O(log <ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is <ph id="ph3">&lt;xref:System.Collections.SortedList.Count%2A&gt;</ph>.</source>
          <target state="translated">Recuperar o valor dessa propriedade é um O (log <ph id="ph1">`n`</ph>) operação, onde <ph id="ph2">`n`</ph> é <ph id="ph3">&lt;xref:System.Collections.SortedList.Count%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="434" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.SortedList.Item(System.Object)">
          <source>Setting the property is an O(log <ph id="ph1">`n`</ph>) operation if the key is already in the <ph id="ph2">&lt;xref:System.Collections.SortedList&gt;</ph>.</source>
          <target state="translated">Configuração da propriedade é um O (log <ph id="ph1">`n`</ph>) operação se a chave já está no <ph id="ph2">&lt;xref:System.Collections.SortedList&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="435" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.SortedList.Item(System.Object)">
          <source>If the key is not in the list, setting the property is an O(<ph id="ph1">`n`</ph>) operation for unsorted data, or O(log <ph id="ph2">`n`</ph>) if the new element is added at the end of the list.</source>
          <target state="translated">Se a chave não estiver na lista, a configuração da propriedade é um O (<ph id="ph1">`n`</ph>) a operação de dados classificados e O (log <ph id="ph2">`n`</ph>) se o novo elemento é adicionado ao final da lista.</target>       </trans-unit>
        <trans-unit id="436" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.SortedList.Item(System.Object)">
          <source>If insertion causes a resize, the operation is O(<ph id="ph1">`n`</ph>).</source>
          <target state="translated">Se a inserção faz com que um redimensionamento, a operação é O (<ph id="ph1">`n`</ph>).</target>       </trans-unit>
        <trans-unit id="437" translate="yes" xml:space="preserve" uid="P:System.Collections.SortedList.Item(System.Object)">
          <source><ph id="ph1">&lt;paramref name="key" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="key" /&gt;</ph> é <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="438" translate="yes" xml:space="preserve" uid="P:System.Collections.SortedList.Item(System.Object)">
          <source>The property is set and the <ph id="ph1">&lt;see cref="T:System.Collections.SortedList" /&gt;</ph> object is read-only.</source>
          <target state="translated">A propriedade é definida e o objeto <ph id="ph1">&lt;see cref="T:System.Collections.SortedList" /&gt;</ph> é somente leitura.</target>       </trans-unit>
        <trans-unit id="439" translate="yes" xml:space="preserve" uid="P:System.Collections.SortedList.Item(System.Object)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="440" translate="yes" xml:space="preserve" uid="P:System.Collections.SortedList.Item(System.Object)">
          <source>The property is set, <ph id="ph1">&lt;paramref name="key" /&gt;</ph> does not exist in the collection, and the <ph id="ph2">&lt;see cref="T:System.Collections.SortedList" /&gt;</ph> has a fixed size.</source>
          <target state="translated">A propriedade é definida, <ph id="ph1">&lt;paramref name="key" /&gt;</ph> não existe na coleção e o <ph id="ph2">&lt;see cref="T:System.Collections.SortedList" /&gt;</ph> tem um tamanho fixo.</target>       </trans-unit>
        <trans-unit id="441" translate="yes" xml:space="preserve" uid="P:System.Collections.SortedList.Item(System.Object)">
          <source>There is not enough available memory to add the element to the <ph id="ph1">&lt;see cref="T:System.Collections.SortedList" /&gt;</ph>.</source>
          <target state="translated">Não há memória suficiente disponível para adicionar o elemento ao <ph id="ph1">&lt;see cref="T:System.Collections.SortedList" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="442" translate="yes" xml:space="preserve" uid="P:System.Collections.SortedList.Item(System.Object)">
          <source>The comparer throws an exception.</source>
          <target state="translated">O comparador gera uma exceção.</target>       </trans-unit>
        <trans-unit id="443" translate="yes" xml:space="preserve" uid="P:System.Collections.SortedList.Keys">
          <source>Gets the keys in a <ph id="ph1">&lt;see cref="T:System.Collections.SortedList" /&gt;</ph> object.</source>
          <target state="translated">Obtém as chaves em um objeto <ph id="ph1">&lt;see cref="T:System.Collections.SortedList" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="444" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.SortedList.Keys">
          <source>An <ph id="ph1">&lt;see cref="T:System.Collections.ICollection" /&gt;</ph> object containing the keys in the <ph id="ph2">&lt;see cref="T:System.Collections.SortedList" /&gt;</ph> object.</source>
          <target state="translated">Um objeto <ph id="ph1">&lt;see cref="T:System.Collections.ICollection" /&gt;</ph> que contém as chaves no objeto <ph id="ph2">&lt;see cref="T:System.Collections.SortedList" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="445" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.SortedList.Keys">
          <source>The <ph id="ph1">&lt;xref:System.Collections.ICollection&gt;</ph> object is a read-only view of the keys of the <ph id="ph2">&lt;xref:System.Collections.SortedList&gt;</ph> object.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Collections.ICollection&gt;</ph> objeto é uma exibição somente leitura das chaves do <ph id="ph2">&lt;xref:System.Collections.SortedList&gt;</ph> objeto.</target>       </trans-unit>
        <trans-unit id="446" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.SortedList.Keys">
          <source>Modifications made to the underlying <ph id="ph1">&lt;xref:System.Collections.SortedList&gt;</ph> are immediately reflected in the <ph id="ph2">&lt;xref:System.Collections.ICollection&gt;</ph>.</source>
          <target state="translated">As modificações feitas subjacente <ph id="ph1">&lt;xref:System.Collections.SortedList&gt;</ph> são imediatamente refletidos no <ph id="ph2">&lt;xref:System.Collections.ICollection&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="447" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.SortedList.Keys">
          <source>The elements of the <ph id="ph1">&lt;xref:System.Collections.ICollection&gt;</ph> are sorted in the same order as the keys of the <ph id="ph2">&lt;xref:System.Collections.SortedList&gt;</ph>.</source>
          <target state="translated">Os elementos do <ph id="ph1">&lt;xref:System.Collections.ICollection&gt;</ph> são classificados na mesma ordem que as chaves dos <ph id="ph2">&lt;xref:System.Collections.SortedList&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="448" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.SortedList.Keys">
          <source>This property is similar to the <ph id="ph1">&lt;xref:System.Collections.SortedList.GetKeyList%2A&gt;</ph> method, but returns an <ph id="ph2">&lt;xref:System.Collections.ICollection&gt;</ph> object instead of an <ph id="ph3">&lt;xref:System.Collections.IList&gt;</ph> object.</source>
          <target state="translated">Esta propriedade é semelhante de <ph id="ph1">&lt;xref:System.Collections.SortedList.GetKeyList%2A&gt;</ph> método, mas retorna um <ph id="ph2">&lt;xref:System.Collections.ICollection&gt;</ph> do objeto, em vez de um <ph id="ph3">&lt;xref:System.Collections.IList&gt;</ph> objeto.</target>       </trans-unit>
        <trans-unit id="449" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.SortedList.Keys">
          <source>This method is an O(1) operation.</source>
          <target state="translated">Este método é uma operação O(1).</target>       </trans-unit>
        <trans-unit id="450" translate="yes" xml:space="preserve" uid="M:System.Collections.SortedList.Remove(System.Object)">
          <source>The key of the element to remove.</source>
          <target state="translated">A chave do elemento a ser removido.</target>       </trans-unit>
        <trans-unit id="451" translate="yes" xml:space="preserve" uid="M:System.Collections.SortedList.Remove(System.Object)">
          <source>Removes the element with the specified key from a <ph id="ph1">&lt;see cref="T:System.Collections.SortedList" /&gt;</ph> object.</source>
          <target state="translated">Remove o elemento com a chave especificada de um objeto <ph id="ph1">&lt;see cref="T:System.Collections.SortedList" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="452" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.SortedList.Remove(System.Object)">
          <source>If the <ph id="ph1">&lt;xref:System.Collections.SortedList&gt;</ph> object does not contain an element with the specified key, the <ph id="ph2">&lt;xref:System.Collections.SortedList&gt;</ph> remains unchanged.</source>
          <target state="translated">Se o <ph id="ph1">&lt;xref:System.Collections.SortedList&gt;</ph> objeto não contém um elemento com a chave especificada, o <ph id="ph2">&lt;xref:System.Collections.SortedList&gt;</ph> permanece inalterado.</target>       </trans-unit>
        <trans-unit id="453" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.SortedList.Remove(System.Object)">
          <source>No exception is thrown.</source>
          <target state="translated">Nenhuma exceção é lançada.</target>       </trans-unit>
        <trans-unit id="454" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.SortedList.Remove(System.Object)">
          <source>In collections of contiguous elements, such as lists, the elements that follow the removed element move up to occupy the vacated spot.</source>
          <target state="translated">Em coleções de elementos contíguos, como listas, os elementos que seguem o elemento removido sobem para ocupar o ponto vazio.</target>       </trans-unit>
        <trans-unit id="455" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.SortedList.Remove(System.Object)">
          <source>If the collection is indexed, the indexes of the elements that are moved are also updated.</source>
          <target state="translated">Caso a coleção seja indexada, os índices dos elementos que são movidos também são atualizados.</target>       </trans-unit>
        <trans-unit id="456" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.SortedList.Remove(System.Object)">
          <source>This behavior does not apply to collections where elements are conceptually grouped into buckets, such as a hash table.</source>
          <target state="translated">Este comportamento não se aplica às coleções em que elementos sejam agrupados conceitualmente em buckets, como uma tabela de hash.</target>       </trans-unit>
        <trans-unit id="457" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.SortedList.Remove(System.Object)">
          <source>This method is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is <ph id="ph3">&lt;xref:System.Collections.SortedList.Count%2A&gt;</ph>.</source>
          <target state="translated">Este método é uma operação O(<ph id="ph1">`n`</ph>), em que <ph id="ph2">`n`</ph> é <ph id="ph3">&lt;xref:System.Collections.SortedList.Count%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="458" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.SortedList.Remove(System.Object)">
          <source>The following code example shows how to remove elements from a <ph id="ph1">&lt;xref:System.Collections.SortedList&gt;</ph> object.</source>
          <target state="translated">O exemplo de código a seguir mostra como remover elementos de uma <ph id="ph1">&lt;xref:System.Collections.SortedList&gt;</ph> objeto.</target>       </trans-unit>
        <trans-unit id="459" translate="yes" xml:space="preserve" uid="M:System.Collections.SortedList.Remove(System.Object)">
          <source><ph id="ph1">&lt;paramref name="key" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="key" /&gt;</ph> é <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="460" translate="yes" xml:space="preserve" uid="M:System.Collections.SortedList.Remove(System.Object)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.SortedList" /&gt;</ph> object is read-only.</source>
          <target state="translated">O objeto <ph id="ph1">&lt;see cref="T:System.Collections.SortedList" /&gt;</ph> é somente leitura.</target>       </trans-unit>
        <trans-unit id="461" translate="yes" xml:space="preserve" uid="M:System.Collections.SortedList.Remove(System.Object)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="462" translate="yes" xml:space="preserve" uid="M:System.Collections.SortedList.Remove(System.Object)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.SortedList" /&gt;</ph> has a fixed size.</source>
          <target state="translated">O <ph id="ph1">&lt;see cref="T:System.Collections.SortedList" /&gt;</ph> tem um tamanho fixo.</target>       </trans-unit>
        <trans-unit id="463" translate="yes" xml:space="preserve" uid="M:System.Collections.SortedList.RemoveAt(System.Int32)">
          <source>The zero-based index of the element to remove.</source>
          <target state="translated">O índice de base zero do elemento a ser removido.</target>       </trans-unit>
        <trans-unit id="464" translate="yes" xml:space="preserve" uid="M:System.Collections.SortedList.RemoveAt(System.Int32)">
          <source>Removes the element at the specified index of a <ph id="ph1">&lt;see cref="T:System.Collections.SortedList" /&gt;</ph> object.</source>
          <target state="translated">Remove o elemento no índice especificado de um objeto <ph id="ph1">&lt;see cref="T:System.Collections.SortedList" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="465" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.SortedList.RemoveAt(System.Int32)">
          <source>The index sequence is based on the sort sequence.</source>
          <target state="translated">A sequência de índice é baseada na sequência de classificação.</target>       </trans-unit>
        <trans-unit id="466" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.SortedList.RemoveAt(System.Int32)">
          <source>When an element is added, it is inserted into <ph id="ph1">&lt;xref:System.Collections.SortedList&gt;</ph> in the correct sort order, and the indexing adjusts accordingly.</source>
          <target state="translated">Quando um elemento é adicionado, ele será inserido na <ph id="ph1">&lt;xref:System.Collections.SortedList&gt;</ph> na classificação correta ordem e a indexação é ajustada de acordo.</target>       </trans-unit>
        <trans-unit id="467" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.SortedList.RemoveAt(System.Int32)">
          <source>When an element is removed, the indexing also adjusts accordingly.</source>
          <target state="translated">Quando um elemento for removido, a indexação também se ajusta.</target>       </trans-unit>
        <trans-unit id="468" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.SortedList.RemoveAt(System.Int32)">
          <source>Therefore, the index of a specific key/value pair might change as elements are added or removed from the <ph id="ph1">&lt;xref:System.Collections.SortedList&gt;</ph> object.</source>
          <target state="translated">Portanto, o índice de um par chave/valor específico pode alterar como os elementos são adicionados ou removidos do <ph id="ph1">&lt;xref:System.Collections.SortedList&gt;</ph> objeto.</target>       </trans-unit>
        <trans-unit id="469" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.SortedList.RemoveAt(System.Int32)">
          <source>In collections of contiguous elements, such as lists, the elements that follow the removed element move up to occupy the vacated spot.</source>
          <target state="translated">Em coleções de elementos contíguos, como listas, os elementos que seguem o elemento removido sobem para ocupar o ponto vazio.</target>       </trans-unit>
        <trans-unit id="470" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.SortedList.RemoveAt(System.Int32)">
          <source>If the collection is indexed, the indexes of the elements that are moved are also updated.</source>
          <target state="translated">Caso a coleção seja indexada, os índices dos elementos que são movidos também são atualizados.</target>       </trans-unit>
        <trans-unit id="471" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.SortedList.RemoveAt(System.Int32)">
          <source>This behavior does not apply to collections where elements are conceptually grouped into buckets, such as a hash table.</source>
          <target state="translated">Este comportamento não se aplica às coleções em que elementos sejam agrupados conceitualmente em buckets, como uma tabela de hash.</target>       </trans-unit>
        <trans-unit id="472" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.SortedList.RemoveAt(System.Int32)">
          <source>This method is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is <ph id="ph3">&lt;xref:System.Collections.SortedList.Count%2A&gt;</ph>.</source>
          <target state="translated">Este método é uma operação O(<ph id="ph1">`n`</ph>), em que <ph id="ph2">`n`</ph> é <ph id="ph3">&lt;xref:System.Collections.SortedList.Count%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="473" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.SortedList.RemoveAt(System.Int32)">
          <source>The following code example shows how to remove elements from a <ph id="ph1">&lt;xref:System.Collections.SortedList&gt;</ph> object.</source>
          <target state="translated">O exemplo de código a seguir mostra como remover elementos de uma <ph id="ph1">&lt;xref:System.Collections.SortedList&gt;</ph> objeto.</target>       </trans-unit>
        <trans-unit id="474" translate="yes" xml:space="preserve" uid="M:System.Collections.SortedList.RemoveAt(System.Int32)">
          <source><ph id="ph1">&lt;paramref name="index" /&gt;</ph> is outside the range of valid indexes for the <ph id="ph2">&lt;see cref="T:System.Collections.SortedList" /&gt;</ph> object.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="index" /&gt;</ph> está fora do intervalo de índices válidos para o objeto <ph id="ph2">&lt;see cref="T:System.Collections.SortedList" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="475" translate="yes" xml:space="preserve" uid="M:System.Collections.SortedList.RemoveAt(System.Int32)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.SortedList" /&gt;</ph> is read-only.</source>
          <target state="translated">O <ph id="ph1">&lt;see cref="T:System.Collections.SortedList" /&gt;</ph> é somente leitura.</target>       </trans-unit>
        <trans-unit id="476" translate="yes" xml:space="preserve" uid="M:System.Collections.SortedList.RemoveAt(System.Int32)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="477" translate="yes" xml:space="preserve" uid="M:System.Collections.SortedList.RemoveAt(System.Int32)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.SortedList" /&gt;</ph> has a fixed size.</source>
          <target state="translated">O <ph id="ph1">&lt;see cref="T:System.Collections.SortedList" /&gt;</ph> tem um tamanho fixo.</target>       </trans-unit>
        <trans-unit id="478" translate="yes" xml:space="preserve" uid="M:System.Collections.SortedList.SetByIndex(System.Int32,System.Object)">
          <source>The zero-based index at which to save <bpt id="p1">&lt;c&gt;</bpt>value<ept id="p1">&lt;/c&gt;</ept>.</source>
          <target state="translated">O índice baseado em zero no qual salvar <bpt id="p1">&lt;c&gt;</bpt>value<ept id="p1">&lt;/c&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="479" translate="yes" xml:space="preserve" uid="M:System.Collections.SortedList.SetByIndex(System.Int32,System.Object)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Object" /&gt;</ph> to save into the <ph id="ph2">&lt;see cref="T:System.Collections.SortedList" /&gt;</ph> object.</source>
          <target state="translated">O <ph id="ph1">&lt;see cref="T:System.Object" /&gt;</ph> a salvar no objeto <ph id="ph2">&lt;see cref="T:System.Collections.SortedList" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="480" translate="yes" xml:space="preserve" uid="M:System.Collections.SortedList.SetByIndex(System.Int32,System.Object)">
          <source>The value can be <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">O valor pode ser <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="481" translate="yes" xml:space="preserve" uid="M:System.Collections.SortedList.SetByIndex(System.Int32,System.Object)">
          <source>Replaces the value at a specific index in a <ph id="ph1">&lt;see cref="T:System.Collections.SortedList" /&gt;</ph> object.</source>
          <target state="translated">Substitui o valor em um índice específico em um objeto <ph id="ph1">&lt;see cref="T:System.Collections.SortedList" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="482" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.SortedList.SetByIndex(System.Int32,System.Object)">
          <source>The index sequence is based on the sort sequence.</source>
          <target state="translated">A sequência de índice é baseada na sequência de classificação.</target>       </trans-unit>
        <trans-unit id="483" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.SortedList.SetByIndex(System.Int32,System.Object)">
          <source>When an element is added, it is inserted into <ph id="ph1">&lt;xref:System.Collections.SortedList&gt;</ph> in the correct sort order, and the indexing adjusts accordingly.</source>
          <target state="translated">Quando um elemento é adicionado, ele será inserido na <ph id="ph1">&lt;xref:System.Collections.SortedList&gt;</ph> na classificação correta ordem e a indexação é ajustada de acordo.</target>       </trans-unit>
        <trans-unit id="484" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.SortedList.SetByIndex(System.Int32,System.Object)">
          <source>When an element is removed, the indexing also adjusts accordingly.</source>
          <target state="translated">Quando um elemento for removido, a indexação também se ajusta.</target>       </trans-unit>
        <trans-unit id="485" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.SortedList.SetByIndex(System.Int32,System.Object)">
          <source>Therefore, the index of a specific key/value pair might change as elements are added or removed from the <ph id="ph1">&lt;xref:System.Collections.SortedList&gt;</ph> object.</source>
          <target state="translated">Portanto, o índice de um par chave/valor específico pode alterar como os elementos são adicionados ou removidos do <ph id="ph1">&lt;xref:System.Collections.SortedList&gt;</ph> objeto.</target>       </trans-unit>
        <trans-unit id="486" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.SortedList.SetByIndex(System.Int32,System.Object)">
          <source>This method is an O(1) operation.</source>
          <target state="translated">Este método é uma operação O(1).</target>       </trans-unit>
        <trans-unit id="487" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.SortedList.SetByIndex(System.Int32,System.Object)">
          <source>The following code example shows how to replace the value of an existing element in a <ph id="ph1">&lt;xref:System.Collections.SortedList&gt;</ph> object.</source>
          <target state="translated">O exemplo de código a seguir mostra como substituir o valor de um elemento existente em um <ph id="ph1">&lt;xref:System.Collections.SortedList&gt;</ph> objeto.</target>       </trans-unit>
        <trans-unit id="488" translate="yes" xml:space="preserve" uid="M:System.Collections.SortedList.SetByIndex(System.Int32,System.Object)">
          <source><ph id="ph1">&lt;paramref name="index" /&gt;</ph> is outside the range of valid indexes for the <ph id="ph2">&lt;see cref="T:System.Collections.SortedList" /&gt;</ph> object.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="index" /&gt;</ph> está fora do intervalo de índices válidos para o objeto <ph id="ph2">&lt;see cref="T:System.Collections.SortedList" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="489" translate="yes" xml:space="preserve" uid="M:System.Collections.SortedList.Synchronized(System.Collections.SortedList)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.SortedList" /&gt;</ph> object to synchronize.</source>
          <target state="translated">O objeto <ph id="ph1">&lt;see cref="T:System.Collections.SortedList" /&gt;</ph> a ser sincronizado.</target>       </trans-unit>
        <trans-unit id="490" translate="yes" xml:space="preserve" uid="M:System.Collections.SortedList.Synchronized(System.Collections.SortedList)">
          <source>Returns a synchronized (thread-safe) wrapper for a <ph id="ph1">&lt;see cref="T:System.Collections.SortedList" /&gt;</ph> object.</source>
          <target state="translated">Retorna o wrapper sincronizado (thread-safe) para um objeto <ph id="ph1">&lt;see cref="T:System.Collections.SortedList" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="491" translate="yes" xml:space="preserve" uid="M:System.Collections.SortedList.Synchronized(System.Collections.SortedList)">
          <source>A synchronized (thread-safe) wrapper for the <ph id="ph1">&lt;see cref="T:System.Collections.SortedList" /&gt;</ph> object.</source>
          <target state="translated">Um wrapper sincronizado (thread-safe) para o objeto <ph id="ph1">&lt;see cref="T:System.Collections.SortedList" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="492" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.SortedList.Synchronized(System.Collections.SortedList)">
          <source>To guarantee the thread safety of a <ph id="ph1">&lt;xref:System.Collections.SortedList&gt;</ph> object, all operations must be done through this wrapper only.</source>
          <target state="translated">Para garantir a segurança de thread de um <ph id="ph1">&lt;xref:System.Collections.SortedList&gt;</ph> do objeto, todas as operações devem ser feitas por meio de apenas esse wrapper.</target>       </trans-unit>
        <trans-unit id="493" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.SortedList.Synchronized(System.Collections.SortedList)">
          <source>Enumerating through a collection is intrinsically not a thread-safe procedure.</source>
          <target state="translated">A enumeração por meio de uma coleção não é um procedimento thread-safe intrínseco.</target>       </trans-unit>
        <trans-unit id="494" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.SortedList.Synchronized(System.Collections.SortedList)">
          <source>Even when a collection is synchronized, other threads can still modify the collection, which causes the enumerator to throw an exception.</source>
          <target state="translated">Mesmo quando uma coleção está sincronizada, outros threads ainda podem modificar a coleção, o que faz o enumerador lançar uma exceção.</target>       </trans-unit>
        <trans-unit id="495" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.SortedList.Synchronized(System.Collections.SortedList)">
          <source>To guarantee thread safety during enumeration, you can either lock the collection during the entire enumeration or catch the exceptions resulting from changes made by other threads.</source>
          <target state="translated">Para garantir thread-safe durante a enumeração, é possível bloquear a coleção durante toda a enumeração ou verificar as exceções resultantes das alterações feitas por outros threads.</target>       </trans-unit>
        <trans-unit id="496" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.SortedList.Synchronized(System.Collections.SortedList)">
          <source>The following code example shows how to lock the collection using the <ph id="ph1">&lt;xref:System.Collections.SortedList.SyncRoot%2A&gt;</ph> property during the entire enumeration.</source>
          <target state="translated">O exemplo de código a seguir mostra como bloquear a coleção usando o <ph id="ph1">&lt;xref:System.Collections.SortedList.SyncRoot%2A&gt;</ph> propriedade durante toda a enumeração.</target>       </trans-unit>
        <trans-unit id="497" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.SortedList.Synchronized(System.Collections.SortedList)">
          <source>This method is an O(1) operation.</source>
          <target state="translated">Este método é uma operação O(1).</target>       </trans-unit>
        <trans-unit id="498" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.SortedList.Synchronized(System.Collections.SortedList)">
          <source>The following code example shows how to synchronize a <ph id="ph1">&lt;xref:System.Collections.SortedList&gt;</ph> object, determine whether a <ph id="ph2">&lt;xref:System.Collections.SortedList&gt;</ph> is synchronized, and use a synchronized <ph id="ph3">&lt;xref:System.Collections.SortedList&gt;</ph>.</source>
          <target state="translated">O exemplo de código a seguir mostra como sincronizar um <ph id="ph1">&lt;xref:System.Collections.SortedList&gt;</ph> de objeto, determinar se um <ph id="ph2">&lt;xref:System.Collections.SortedList&gt;</ph> está sincronizado e usar um sincronizado <ph id="ph3">&lt;xref:System.Collections.SortedList&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="499" translate="yes" xml:space="preserve" uid="M:System.Collections.SortedList.Synchronized(System.Collections.SortedList)">
          <source><ph id="ph1">&lt;paramref name="list" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="list" /&gt;</ph> é <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="500" translate="yes" xml:space="preserve" uid="P:System.Collections.SortedList.SyncRoot">
          <source>Gets an object that can be used to synchronize access to a <ph id="ph1">&lt;see cref="T:System.Collections.SortedList" /&gt;</ph> object.</source>
          <target state="translated">Obtém um objeto que pode ser usado para sincronizar o acesso a um objeto <ph id="ph1">&lt;see cref="T:System.Collections.SortedList" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="501" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.SortedList.SyncRoot">
          <source>An object that can be used to synchronize access to the <ph id="ph1">&lt;see cref="T:System.Collections.SortedList" /&gt;</ph> object.</source>
          <target state="translated">Um objeto que pode ser usado para sincronizar o acesso a <ph id="ph1">&lt;see cref="T:System.Collections.SortedList" /&gt;</ph> objeto.</target>       </trans-unit>
        <trans-unit id="502" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.SortedList.SyncRoot">
          <source>To create a synchronized version of the <ph id="ph1">&lt;xref:System.Collections.SortedList&gt;</ph> object, use the <ph id="ph2">&lt;xref:System.Collections.SortedList.Synchronized%2A&gt;</ph> method.</source>
          <target state="translated">Para criar uma versão sincronizada do <ph id="ph1">&lt;xref:System.Collections.SortedList&gt;</ph> de objeto, use o <ph id="ph2">&lt;xref:System.Collections.SortedList.Synchronized%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="503" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.SortedList.SyncRoot">
          <source>However, derived classes can provide their own synchronized version of the <ph id="ph1">&lt;xref:System.Collections.SortedList&gt;</ph> using the <ph id="ph2">&lt;xref:System.Collections.SortedList.SyncRoot%2A&gt;</ph> property.</source>
          <target state="translated">No entanto, as classes derivadas podem fornecer sua própria versão sincronizada de <ph id="ph1">&lt;xref:System.Collections.SortedList&gt;</ph> usando o <ph id="ph2">&lt;xref:System.Collections.SortedList.SyncRoot%2A&gt;</ph> propriedade.</target>       </trans-unit>
        <trans-unit id="504" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.SortedList.SyncRoot">
          <source>The synchronizing code must perform operations on the <ph id="ph1">&lt;xref:System.Collections.SortedList.SyncRoot%2A&gt;</ph> of the <ph id="ph2">&lt;xref:System.Collections.SortedList&gt;</ph>, not directly on the <ph id="ph3">&lt;xref:System.Collections.SortedList&gt;</ph>.</source>
          <target state="translated">O código de sincronização necessário realizar operações no <ph id="ph1">&lt;xref:System.Collections.SortedList.SyncRoot%2A&gt;</ph> do <ph id="ph2">&lt;xref:System.Collections.SortedList&gt;</ph>, não diretamente no <ph id="ph3">&lt;xref:System.Collections.SortedList&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="505" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.SortedList.SyncRoot">
          <source>This ensures proper operation of collections that are derived from other objects.</source>
          <target state="translated">Isso garante a operação apropriada das coleções que são derivadas de outros objetos.</target>       </trans-unit>
        <trans-unit id="506" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.SortedList.SyncRoot">
          <source>Specifically, it maintains proper synchronization with other threads that might be simultaneously modifying the <ph id="ph1">&lt;xref:System.Collections.SortedList&gt;</ph> object.</source>
          <target state="translated">Especificamente, ele mantém uma sincronização adequada com outros threads que podem ser simultaneamente modificando o <ph id="ph1">&lt;xref:System.Collections.SortedList&gt;</ph> objeto.</target>       </trans-unit>
        <trans-unit id="507" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.SortedList.SyncRoot">
          <source>Enumerating through a collection is intrinsically not a thread-safe procedure.</source>
          <target state="translated">A enumeração por meio de uma coleção não é um procedimento thread-safe intrínseco.</target>       </trans-unit>
        <trans-unit id="508" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.SortedList.SyncRoot">
          <source>Even when a collection is synchronized, other threads can still modify the collection, which causes the enumerator to throw an exception.</source>
          <target state="translated">Mesmo quando uma coleção está sincronizada, outros threads ainda podem modificar a coleção, o que faz o enumerador lançar uma exceção.</target>       </trans-unit>
        <trans-unit id="509" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.SortedList.SyncRoot">
          <source>To guarantee thread safety during enumeration, you can either lock the collection during the entire enumeration or catch the exceptions resulting from changes made by other threads.</source>
          <target state="translated">Para garantir thread-safe durante a enumeração, é possível bloquear a coleção durante toda a enumeração ou verificar as exceções resultantes das alterações feitas por outros threads.</target>       </trans-unit>
        <trans-unit id="510" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.SortedList.SyncRoot">
          <source>The following code example shows how to lock the collection using the <ph id="ph1">&lt;xref:System.Collections.SortedList.SyncRoot%2A&gt;</ph> property during the entire enumeration.</source>
          <target state="translated">O exemplo de código a seguir mostra como bloquear a coleção usando o <ph id="ph1">&lt;xref:System.Collections.SortedList.SyncRoot%2A&gt;</ph> propriedade durante toda a enumeração.</target>       </trans-unit>
        <trans-unit id="511" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.SortedList.SyncRoot">
          <source>Retrieving the value of this property is an O(1) operation.</source>
          <target state="translated">A recuperação do valor dessa propriedade é uma operação O(1).</target>       </trans-unit>
        <trans-unit id="512" translate="yes" xml:space="preserve" uid="M:System.Collections.SortedList.System#Collections#IEnumerable#GetEnumerator">
          <source>Returns an <ph id="ph1">&lt;see cref="T:System.Collections.IEnumerator" /&gt;</ph> that iterates through the <ph id="ph2">&lt;see cref="T:System.Collections.SortedList" /&gt;</ph>.</source>
          <target state="translated">Retorna um <ph id="ph1">&lt;see cref="T:System.Collections.IEnumerator" /&gt;</ph> que itera pelo <ph id="ph2">&lt;see cref="T:System.Collections.SortedList" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="513" translate="yes" xml:space="preserve" uid="M:System.Collections.SortedList.System#Collections#IEnumerable#GetEnumerator">
          <source>An <ph id="ph1">&lt;see cref="T:System.Collections.IEnumerator" /&gt;</ph> for the <ph id="ph2">&lt;see cref="T:System.Collections.SortedList" /&gt;</ph>.</source>
          <target state="translated">Um <ph id="ph1">&lt;see cref="T:System.Collections.IEnumerator" /&gt;</ph> para o <ph id="ph2">&lt;see cref="T:System.Collections.SortedList" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="514" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.SortedList.System#Collections#IEnumerable#GetEnumerator">
          <source>[Visual Basic, C#]</source>
          <target state="translated">[Visual Basic, C#]</target>       </trans-unit>
        <trans-unit id="515" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.SortedList.System#Collections#IEnumerable#GetEnumerator">
          <source>The <ph id="ph1">`foreach`</ph> statement of the C# language (<ph id="ph2">`for each`</ph> in Visual Basic) hides the complexity of the enumerators.</source>
          <target state="translated">O <ph id="ph1">`foreach`</ph> instrução de linguagem c# (<ph id="ph2">`for each`</ph> no Visual Basic) oculta a complexidade dos enumeradores.</target>       </trans-unit>
        <trans-unit id="516" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.SortedList.System#Collections#IEnumerable#GetEnumerator">
          <source>Therefore, using <ph id="ph1">`foreach`</ph> is recommended, instead of directly manipulating the enumerator.</source>
          <target state="translated">Portanto, o uso de <ph id="ph1">`foreach`</ph> é recomendado, em vez de manipular diretamente o enumerador.</target>       </trans-unit>
        <trans-unit id="517" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.SortedList.System#Collections#IEnumerable#GetEnumerator">
          <source>Enumerators can be used to read the data in the collection, but they cannot be used to modify the underlying collection.</source>
          <target state="translated">Os enumeradores podem ser usados para ler os dados na coleção, mas não podem ser usados para modificar a coleção subjacente.</target>       </trans-unit>
        <trans-unit id="518" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.SortedList.System#Collections#IEnumerable#GetEnumerator">
          <source>Initially, the enumerator is positioned before the first element in the collection.</source>
          <target state="translated">Inicialmente, o enumerador é posicionado antes do primeiro elemento da coleção.</target>       </trans-unit>
        <trans-unit id="519" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.SortedList.System#Collections#IEnumerable#GetEnumerator">
          <source><ph id="ph1">&lt;xref:System.Collections.IEnumerator.Reset%2A&gt;</ph> also brings the enumerator back to this position.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Collections.IEnumerator.Reset%2A&gt;</ph> também traz o enumerador de volta para essa posição.</target>       </trans-unit>
        <trans-unit id="520" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.SortedList.System#Collections#IEnumerable#GetEnumerator">
          <source>At this position, calling <ph id="ph1">&lt;xref:System.Collections.IEnumerator.Current%2A&gt;</ph> throws an exception.</source>
          <target state="translated">AT isso posicionar, chamando <ph id="ph1">&lt;xref:System.Collections.IEnumerator.Current%2A&gt;</ph> lança uma exceção.</target>       </trans-unit>
        <trans-unit id="521" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.SortedList.System#Collections#IEnumerable#GetEnumerator">
          <source>Therefore, you must call <ph id="ph1">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> to advance the enumerator to the first element of the collection before reading the value of <ph id="ph2">&lt;xref:System.Collections.IEnumerator.Current%2A&gt;</ph>.</source>
          <target state="translated">Por isso, você deve chamar <ph id="ph1">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> para avançar o enumerador até o primeiro elemento da coleção antes de ler o valor de <ph id="ph2">&lt;xref:System.Collections.IEnumerator.Current%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="522" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.SortedList.System#Collections#IEnumerable#GetEnumerator">
          <source><ph id="ph1">&lt;xref:System.Collections.IEnumerator.Current%2A&gt;</ph> returns the same object until either <ph id="ph2">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> or <ph id="ph3">&lt;xref:System.Collections.IEnumerator.Reset%2A&gt;</ph> is called.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Collections.IEnumerator.Current%2A&gt;</ph> retorna o mesmo objeto até <ph id="ph2">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> ou <ph id="ph3">&lt;xref:System.Collections.IEnumerator.Reset%2A&gt;</ph> ser chamado.</target>       </trans-unit>
        <trans-unit id="523" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.SortedList.System#Collections#IEnumerable#GetEnumerator">
          <source><ph id="ph1">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> sets <ph id="ph2">&lt;xref:System.Collections.IEnumerator.Current%2A&gt;</ph> to the next element.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> define <ph id="ph2">&lt;xref:System.Collections.IEnumerator.Current%2A&gt;</ph> como o próximo elemento.</target>       </trans-unit>
        <trans-unit id="524" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.SortedList.System#Collections#IEnumerable#GetEnumerator">
          <source>If <ph id="ph1">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> passes the end of the collection, the enumerator is positioned after the last element in the collection and <ph id="ph2">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> returns <ph id="ph3">`false`</ph>.</source>
          <target state="translated">Caso <ph id="ph1">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> passe o final da coleção, o enumerador é posicionado após o último elemento na coleção e <ph id="ph2">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> retorna <ph id="ph3">`false`</ph>.</target>       </trans-unit>
        <trans-unit id="525" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.SortedList.System#Collections#IEnumerable#GetEnumerator">
          <source>When the enumerator is at this position, subsequent calls to <ph id="ph1">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> also return <ph id="ph2">`false`</ph>.</source>
          <target state="translated">Quando o enumerador está nessa posição, as chamadas subsequentes para <ph id="ph1">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> também retornam <ph id="ph2">`false`</ph>.</target>       </trans-unit>
        <trans-unit id="526" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.SortedList.System#Collections#IEnumerable#GetEnumerator">
          <source>If the last call to <ph id="ph1">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> returned <ph id="ph2">`false`</ph>, calling <ph id="ph3">&lt;xref:System.Collections.IEnumerator.Current%2A&gt;</ph> throws an exception.</source>
          <target state="translated">Se a última chamada <ph id="ph1">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> retornou <ph id="ph2">`false`</ph>, chamar <ph id="ph3">&lt;xref:System.Collections.IEnumerator.Current%2A&gt;</ph> lança uma exceção.</target>       </trans-unit>
        <trans-unit id="527" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.SortedList.System#Collections#IEnumerable#GetEnumerator">
          <source>To set <ph id="ph1">&lt;xref:System.Collections.IEnumerator.Current%2A&gt;</ph> to the first element of the collection again, you can call <ph id="ph2">&lt;xref:System.Collections.IEnumerator.Reset%2A&gt;</ph> followed by <ph id="ph3">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph>.</source>
          <target state="translated">Para definir <ph id="ph1">&lt;xref:System.Collections.IEnumerator.Current%2A&gt;</ph> como o primeiro elemento da coleção novamente, é possível chamar <ph id="ph2">&lt;xref:System.Collections.IEnumerator.Reset%2A&gt;</ph> seguido de <ph id="ph3">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="528" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.SortedList.System#Collections#IEnumerable#GetEnumerator">
          <source>An enumerator remains valid as long as the collection remains unchanged.</source>
          <target state="translated">Um enumerador permanece válido desde que a coleção continue inalterada.</target>       </trans-unit>
        <trans-unit id="529" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.SortedList.System#Collections#IEnumerable#GetEnumerator">
          <source>If changes are made to the collection, such as adding, modifying, or deleting elements, the enumerator is irrecoverably invalidated and the next call to <ph id="ph1">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.Collections.IEnumerator.Reset%2A&gt;</ph> throws an <ph id="ph3">&lt;xref:System.InvalidOperationException&gt;</ph>.</source>
          <target state="translated">Se forem feitas alterações na coleção, como adicionar, modificar, ou excluir elementos, o enumerador é invalidado invalidado e a próxima chamada para <ph id="ph1">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> ou <ph id="ph2">&lt;xref:System.Collections.IEnumerator.Reset%2A&gt;</ph> lança um <ph id="ph3">&lt;xref:System.InvalidOperationException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="530" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.SortedList.System#Collections#IEnumerable#GetEnumerator">
          <source>If the collection is modified between <ph id="ph1">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Collections.IEnumerator.Current%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.Collections.IEnumerator.Current%2A&gt;</ph> returns the element that it is set to, even if the enumerator is already invalidated.</source>
          <target state="translated">Se a coleção é modificada entre <ph id="ph1">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> e <ph id="ph2">&lt;xref:System.Collections.IEnumerator.Current%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.Collections.IEnumerator.Current%2A&gt;</ph> retorna o elemento que está definido como, mesmo se o enumerador já é invalidado.</target>       </trans-unit>
        <trans-unit id="531" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.SortedList.System#Collections#IEnumerable#GetEnumerator">
          <source>The enumerator does not have exclusive access to the collection; therefore, enumerating through a collection is intrinsically not a thread-safe procedure.</source>
          <target state="translated">O enumerador não tem acesso exclusivo à coleção; por isso, a enumeração por meio de uma coleção não é um procedimento thread-safe intrínseco.</target>       </trans-unit>
        <trans-unit id="532" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.SortedList.System#Collections#IEnumerable#GetEnumerator">
          <source>Even when a collection is synchronized, other threads can still modify the collection, which causes the enumerator to throw an exception.</source>
          <target state="translated">Mesmo quando uma coleção está sincronizada, outros threads ainda podem modificar a coleção, o que faz o enumerador lançar uma exceção.</target>       </trans-unit>
        <trans-unit id="533" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.SortedList.System#Collections#IEnumerable#GetEnumerator">
          <source>To guarantee thread safety during enumeration, you can either lock the collection during the entire enumeration or catch the exceptions resulting from changes made by other threads.</source>
          <target state="translated">Para garantir thread-safe durante a enumeração, é possível bloquear a coleção durante toda a enumeração ou verificar as exceções resultantes das alterações feitas por outros threads.</target>       </trans-unit>
        <trans-unit id="534" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.SortedList.System#Collections#IEnumerable#GetEnumerator">
          <source>This method is an O(1) operation.</source>
          <target state="translated">Este método é uma operação O(1).</target>       </trans-unit>
        <trans-unit id="535" translate="yes" xml:space="preserve" uid="M:System.Collections.SortedList.TrimToSize">
          <source>Sets the capacity to the actual number of elements in a <ph id="ph1">&lt;see cref="T:System.Collections.SortedList" /&gt;</ph> object.</source>
          <target state="translated">Define a capacidade para o número real de elementos em um objeto <ph id="ph1">&lt;see cref="T:System.Collections.SortedList" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="536" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.SortedList.TrimToSize">
          <source>This method can be used to minimize a collection's memory overhead if no new elements will be added to the collection.</source>
          <target state="translated">Esse método pode ser usado para minimizar a memória da coleção sobrecarga se nenhum elemento novo será adicionado à coleção.</target>       </trans-unit>
        <trans-unit id="537" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.SortedList.TrimToSize">
          <source>To reset a <ph id="ph1">&lt;xref:System.Collections.SortedList&gt;</ph> object to its initial state, call the <ph id="ph2">&lt;xref:System.Collections.SortedList.Clear%2A&gt;</ph> method before calling <ph id="ph3">&lt;xref:System.Collections.SortedList.TrimToSize%2A&gt;</ph>.</source>
          <target state="translated">Para redefinir um <ph id="ph1">&lt;xref:System.Collections.SortedList&gt;</ph> objeto para o estado inicial, a chamada a <ph id="ph2">&lt;xref:System.Collections.SortedList.Clear%2A&gt;</ph> método antes de chamar <ph id="ph3">&lt;xref:System.Collections.SortedList.TrimToSize%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="538" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.SortedList.TrimToSize">
          <source>Trimming an empty <ph id="ph1">&lt;xref:System.Collections.SortedList&gt;</ph> sets the capacity of the <ph id="ph2">&lt;xref:System.Collections.SortedList&gt;</ph> to the default capacity.</source>
          <target state="translated">Cortar vazio <ph id="ph1">&lt;xref:System.Collections.SortedList&gt;</ph> define a capacidade do <ph id="ph2">&lt;xref:System.Collections.SortedList&gt;</ph> à capacidade padrão.</target>       </trans-unit>
        <trans-unit id="539" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.SortedList.TrimToSize">
          <source>This method is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is <ph id="ph3">&lt;xref:System.Collections.SortedList.Count%2A&gt;</ph>.</source>
          <target state="translated">Este método é uma operação O(<ph id="ph1">`n`</ph>), em que <ph id="ph2">`n`</ph> é <ph id="ph3">&lt;xref:System.Collections.SortedList.Count%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="540" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.SortedList.TrimToSize">
          <source>The following code example shows how to trim the unused portions of a <ph id="ph1">&lt;xref:System.Collections.SortedList&gt;</ph> object and how to clear its values.</source>
          <target state="translated">O exemplo de código a seguir mostra como cortar as partes não utilizadas de um <ph id="ph1">&lt;xref:System.Collections.SortedList&gt;</ph> objeto e como limpar seus valores.</target>       </trans-unit>
        <trans-unit id="541" translate="yes" xml:space="preserve" uid="M:System.Collections.SortedList.TrimToSize">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.SortedList" /&gt;</ph> object is read-only.</source>
          <target state="translated">O objeto <ph id="ph1">&lt;see cref="T:System.Collections.SortedList" /&gt;</ph> é somente leitura.</target>       </trans-unit>
        <trans-unit id="542" translate="yes" xml:space="preserve" uid="M:System.Collections.SortedList.TrimToSize">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="543" translate="yes" xml:space="preserve" uid="M:System.Collections.SortedList.TrimToSize">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.SortedList" /&gt;</ph> has a fixed size.</source>
          <target state="translated">O <ph id="ph1">&lt;see cref="T:System.Collections.SortedList" /&gt;</ph> tem um tamanho fixo.</target>       </trans-unit>
        <trans-unit id="544" translate="yes" xml:space="preserve" uid="P:System.Collections.SortedList.Values">
          <source>Gets the values in a <ph id="ph1">&lt;see cref="T:System.Collections.SortedList" /&gt;</ph> object.</source>
          <target state="translated">Obtém os valores em um objeto <ph id="ph1">&lt;see cref="T:System.Collections.SortedList" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="545" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.SortedList.Values">
          <source>An <ph id="ph1">&lt;see cref="T:System.Collections.ICollection" /&gt;</ph> object containing the values in the <ph id="ph2">&lt;see cref="T:System.Collections.SortedList" /&gt;</ph> object.</source>
          <target state="translated">Um objeto <ph id="ph1">&lt;see cref="T:System.Collections.ICollection" /&gt;</ph> que contém os valores no objeto <ph id="ph2">&lt;see cref="T:System.Collections.SortedList" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="546" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.SortedList.Values">
          <source>The <ph id="ph1">&lt;xref:System.Collections.ICollection&gt;</ph> object is a read-only view of the values of the <ph id="ph2">&lt;xref:System.Collections.SortedList&gt;</ph> object.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Collections.ICollection&gt;</ph> objeto é uma exibição somente leitura dos valores da <ph id="ph2">&lt;xref:System.Collections.SortedList&gt;</ph> objeto.</target>       </trans-unit>
        <trans-unit id="547" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.SortedList.Values">
          <source>Modifications made to the underlying <ph id="ph1">&lt;xref:System.Collections.SortedList&gt;</ph> are immediately reflected in the <ph id="ph2">&lt;xref:System.Collections.ICollection&gt;</ph>.</source>
          <target state="translated">As modificações feitas subjacente <ph id="ph1">&lt;xref:System.Collections.SortedList&gt;</ph> são imediatamente refletidos no <ph id="ph2">&lt;xref:System.Collections.ICollection&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="548" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.SortedList.Values">
          <source>The elements of the <ph id="ph1">&lt;xref:System.Collections.ICollection&gt;</ph> are sorted in the same order as the values of the <ph id="ph2">&lt;xref:System.Collections.SortedList&gt;</ph>.</source>
          <target state="translated">Os elementos do <ph id="ph1">&lt;xref:System.Collections.ICollection&gt;</ph> são classificados na mesma ordem que os valores da <ph id="ph2">&lt;xref:System.Collections.SortedList&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="549" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.SortedList.Values">
          <source>This property is similar to the <ph id="ph1">&lt;xref:System.Collections.SortedList.GetValueList%2A&gt;</ph> method, but returns an <ph id="ph2">&lt;xref:System.Collections.ICollection&gt;</ph> object instead of an <ph id="ph3">&lt;xref:System.Collections.IList&gt;</ph> object.</source>
          <target state="translated">Esta propriedade é semelhante de <ph id="ph1">&lt;xref:System.Collections.SortedList.GetValueList%2A&gt;</ph> método, mas retorna um <ph id="ph2">&lt;xref:System.Collections.ICollection&gt;</ph> do objeto, em vez de um <ph id="ph3">&lt;xref:System.Collections.IList&gt;</ph> objeto.</target>       </trans-unit>
        <trans-unit id="550" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.SortedList.Values">
          <source>This method is an O(1) operation.</source>
          <target state="translated">Este método é uma operação O(1).</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>