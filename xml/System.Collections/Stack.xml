<Type Name="Stack" FullName="System.Collections.Stack">
  <TypeSignature Language="C#" Value="public class Stack : ICloneable, System.Collections.ICollection" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit Stack extends System.Object implements class System.Collections.ICollection, class System.Collections.IEnumerable, class System.ICloneable" />
  <TypeSignature Language="DocId" Value="T:System.Collections.Stack" />
  <TypeSignature Language="VB.NET" Value="Public Class Stack&#xA;Implements ICloneable, ICollection" />
  <TypeSignature Language="C++ CLI" Value="public ref class Stack : ICloneable, System::Collections::ICollection" />
  <AssemblyInfo>
    <AssemblyName>System.Collections.NonGeneric</AssemblyName>
    <AssemblyVersion>4.0.1.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Collections.ICollection</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.ICloneable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Diagnostics.DebuggerDisplay("Count = {Count}")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Diagnostics.DebuggerTypeProxy(typeof(System.Collections.Stack/StackDebugView))</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary><span data-ttu-id="21d3a-101">Representa uma coleção não genérica simples UEPS (último a entrar, primeiro a sair) de objetos.</span><span class="sxs-lookup"><span data-stu-id="21d3a-101">Represents a simple last-in-first-out (LIFO) non-generic collection of objects.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="21d3a-102">Para obter a versão genérica dessa coleção, consulte <xref:System.Collections.Generic.Stack%601?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="21d3a-102">For the generic version of this collection, see <xref:System.Collections.Generic.Stack%601?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="21d3a-103">A capacidade de um <xref:System.Collections.Stack> é o número de elementos de <xref:System.Collections.Stack> pode conter.</span><span class="sxs-lookup"><span data-stu-id="21d3a-103">The capacity of a <xref:System.Collections.Stack> is the number of elements the <xref:System.Collections.Stack> can hold.</span></span> <span data-ttu-id="21d3a-104">Como os elementos são adicionados a um <xref:System.Collections.Stack>, a capacidade é aumentada automaticamente conforme necessário por meio de realocação.</span><span class="sxs-lookup"><span data-stu-id="21d3a-104">As elements are added to a <xref:System.Collections.Stack>, the capacity is automatically increased as required through reallocation.</span></span>  
  
 <span data-ttu-id="21d3a-105">Se <xref:System.Collections.Stack.Count%2A> é menor que a capacidade da pilha, <xref:System.Collections.Stack.Push%2A> é uma operação de (1).</span><span class="sxs-lookup"><span data-stu-id="21d3a-105">If <xref:System.Collections.Stack.Count%2A> is less than the capacity of the stack, <xref:System.Collections.Stack.Push%2A> is an O(1) operation.</span></span> <span data-ttu-id="21d3a-106">Se a capacidade precisa ser aumentado para acomodar o novo elemento, <xref:System.Collections.Stack.Push%2A> se torna um O (`n`) operação, onde `n` é <xref:System.Collections.Stack.Count%2A>.</span><span class="sxs-lookup"><span data-stu-id="21d3a-106">If the capacity needs to be increased to accommodate the new element, <xref:System.Collections.Stack.Push%2A> becomes an O(`n`) operation, where `n` is <xref:System.Collections.Stack.Count%2A>.</span></span> <span data-ttu-id="21d3a-107"><xref:System.Collections.Stack.Pop%2A> é uma operação de (1).</span><span class="sxs-lookup"><span data-stu-id="21d3a-107"><xref:System.Collections.Stack.Pop%2A> is an O(1) operation.</span></span>  
  
 <span data-ttu-id="21d3a-108"><xref:System.Collections.Stack> aceita `null` como um valor válido e permite elementos duplicados.</span><span class="sxs-lookup"><span data-stu-id="21d3a-108"><xref:System.Collections.Stack> accepts `null` as a valid value and allows duplicate elements.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="21d3a-109">O exemplo a seguir mostra como criar e adicionar valores para um <xref:System.Collections.Stack> e como exibir seus valores.</span><span class="sxs-lookup"><span data-stu-id="21d3a-109">The following example shows how to create and add values to a <xref:System.Collections.Stack> and how to display its values.</span></span>  
  
 [!code-cpp[Classic Stack Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Stack Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Stack Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Stack Example/CS/source.cs#1)]
 [!code-vb[Classic Stack Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Stack Example/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe><span data-ttu-id="21d3a-110">Os membros estáticos públicos (<see langword="Shared" /> no Visual Basic) desse são thread-safe.</span><span class="sxs-lookup"><span data-stu-id="21d3a-110">Public static (<see langword="Shared" /> in Visual Basic) members of this type are thread safe.</span></span> <span data-ttu-id="21d3a-111">Não há garantia de que qualquer membro de instância seja thread-safe.</span><span class="sxs-lookup"><span data-stu-id="21d3a-111">Any instance members are not guaranteed to be thread safe.</span></span>  
  
 <span data-ttu-id="21d3a-112">Para garantir a segurança de thread do <see cref="T:System.Collections.Stack" />, todas as operações devem ser feitas por meio do wrapper retornado pelo <see cref="M:System.Collections.Stack.Synchronized(System.Collections.Stack)" /> método.</span><span class="sxs-lookup"><span data-stu-id="21d3a-112">To guarantee the thread safety of the <see cref="T:System.Collections.Stack" />, all operations must be done through the wrapper returned by the <see cref="M:System.Collections.Stack.Synchronized(System.Collections.Stack)" /> method.</span></span>  
  
 <span data-ttu-id="21d3a-113">A enumeração por meio de uma coleção não é um procedimento thread-safe intrínseco.</span><span class="sxs-lookup"><span data-stu-id="21d3a-113">Enumerating through a collection is intrinsically not a thread-safe procedure.</span></span> <span data-ttu-id="21d3a-114">Mesmo quando uma coleção está sincronizada, outros threads ainda podem modificar a coleção, o que faz o enumerador lançar uma exceção.</span><span class="sxs-lookup"><span data-stu-id="21d3a-114">Even when a collection is synchronized, other threads can still modify the collection, which causes the enumerator to throw an exception.</span></span> <span data-ttu-id="21d3a-115">Para garantir thread-safe durante a enumeração, é possível bloquear a coleção durante toda a enumeração ou verificar as exceções resultantes das alterações feitas por outros threads.</span><span class="sxs-lookup"><span data-stu-id="21d3a-115">To guarantee thread safety during enumeration, you can either lock the collection during the entire enumeration or catch the exceptions resulting from changes made by other threads.</span></span></threadsafe>
    <altmember cref="T:System.Collections.Generic.Stack`1" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="21d3a-116">Inicializa uma nova instância da classe <see cref="T:System.Collections.Stack" />.</span><span class="sxs-lookup"><span data-stu-id="21d3a-116">Initializes a new instance of the <see cref="T:System.Collections.Stack" /> class.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Stack ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Stack.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Stack();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="21d3a-117">Inicializa uma nova instância da classe <see cref="T:System.Collections.Stack" /> que está vazia e tem a capacidade inicial padrão.</span><span class="sxs-lookup"><span data-stu-id="21d3a-117">Initializes a new instance of the <see cref="T:System.Collections.Stack" /> class that is empty and has the default initial capacity.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="21d3a-118">A capacidade de um <xref:System.Collections.Stack> é o número de elementos que o <xref:System.Collections.Stack> pode conter.</span><span class="sxs-lookup"><span data-stu-id="21d3a-118">The capacity of a <xref:System.Collections.Stack> is the number of elements that the <xref:System.Collections.Stack> can hold.</span></span> <span data-ttu-id="21d3a-119">Como os elementos são adicionados a um <xref:System.Collections.Stack>, a capacidade é aumentada automaticamente conforme necessário ao realocar a matriz interna.</span><span class="sxs-lookup"><span data-stu-id="21d3a-119">As elements are added to a <xref:System.Collections.Stack>, the capacity is automatically increased as required by reallocating the internal array.</span></span>  
  
 <span data-ttu-id="21d3a-120">Se o tamanho da coleção pode ser estimado, especificando a capacidade inicial elimina a necessidade de executar um número de operações de redimensionamento durante a adição de elementos para o <xref:System.Collections.Stack>.</span><span class="sxs-lookup"><span data-stu-id="21d3a-120">If the size of the collection can be estimated, specifying the initial capacity eliminates the need to perform a number of resizing operations while adding elements to the <xref:System.Collections.Stack>.</span></span>  
  
 <span data-ttu-id="21d3a-121">Este construtor é uma operação O(1).</span><span class="sxs-lookup"><span data-stu-id="21d3a-121">This constructor is an O(1) operation.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Stack (System.Collections.ICollection col);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Collections.ICollection col) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Stack.#ctor(System.Collections.ICollection)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (col As ICollection)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Stack(System::Collections::ICollection ^ col);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="col" Type="System.Collections.ICollection" />
      </Parameters>
      <Docs>
        <param name="col"><span data-ttu-id="21d3a-122">A <see cref="T:System.Collections.ICollection" /> da qual copiar elementos.</span><span class="sxs-lookup"><span data-stu-id="21d3a-122">The <see cref="T:System.Collections.ICollection" /> to copy elements from.</span></span></param>
        <summary><span data-ttu-id="21d3a-123">Inicializa uma nova instância da classe <see cref="T:System.Collections.Stack" />, que contém os elementos copiados da coleção especificada e tem a mesma capacidade inicial que o número de elementos copiados.</span><span class="sxs-lookup"><span data-stu-id="21d3a-123">Initializes a new instance of the <see cref="T:System.Collections.Stack" /> class that contains elements copied from the specified collection and has the same initial capacity as the number of elements copied.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="21d3a-124">A capacidade de um <xref:System.Collections.Stack> é o número de elementos que o <xref:System.Collections.Stack> pode conter.</span><span class="sxs-lookup"><span data-stu-id="21d3a-124">The capacity of a <xref:System.Collections.Stack> is the number of elements that the <xref:System.Collections.Stack> can hold.</span></span> <span data-ttu-id="21d3a-125">Como os elementos são adicionados a um <xref:System.Collections.Stack>, a capacidade é aumentada automaticamente conforme necessário ao realocar a matriz interna.</span><span class="sxs-lookup"><span data-stu-id="21d3a-125">As elements are added to a <xref:System.Collections.Stack>, the capacity is automatically increased as required by reallocating the internal array.</span></span>  
  
 <span data-ttu-id="21d3a-126">Se o tamanho da coleção pode ser estimado, especificando a capacidade inicial elimina a necessidade de executar um número de operações de redimensionamento durante a adição de elementos para o <xref:System.Collections.Stack>.</span><span class="sxs-lookup"><span data-stu-id="21d3a-126">If the size of the collection can be estimated, specifying the initial capacity eliminates the need to perform a number of resizing operations while adding elements to the <xref:System.Collections.Stack>.</span></span>  
  
 <span data-ttu-id="21d3a-127">Os elementos são copiados para o <xref:System.Collections.Stack> na mesma ordem em que são lidas pelo <xref:System.Collections.IEnumerator> do <xref:System.Collections.ICollection>.</span><span class="sxs-lookup"><span data-stu-id="21d3a-127">The elements are copied onto the <xref:System.Collections.Stack> in the same order they are read by the <xref:System.Collections.IEnumerator> of the <xref:System.Collections.ICollection>.</span></span>  
  
 <span data-ttu-id="21d3a-128">Este construtor é um O (`n`) operação, onde `n` é o número de elementos em `col`.</span><span class="sxs-lookup"><span data-stu-id="21d3a-128">This constructor is an O(`n`) operation, where `n` is the number of elements in `col`.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="21d3a-129"><paramref name="col" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="21d3a-129"><paramref name="col" /> is <see langword="null" />.</span></span></exception>
        <altmember cref="T:System.Collections.ICollection" />
        <altmember cref="T:System.Collections.IEnumerator" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Stack (int initialCapacity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 initialCapacity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Stack.#ctor(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (initialCapacity As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Stack(int initialCapacity);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="initialCapacity" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="initialCapacity"><span data-ttu-id="21d3a-130">O número inicial de elementos que o <see cref="T:System.Collections.Stack" /> pode conter.</span><span class="sxs-lookup"><span data-stu-id="21d3a-130">The initial number of elements that the <see cref="T:System.Collections.Stack" /> can contain.</span></span></param>
        <summary><span data-ttu-id="21d3a-131">Inicializa uma nova instância da classe <see cref="T:System.Collections.Stack" /> que está vazia e tem a capacidade inicial especificada ou a capacidade inicial padrão, a que for maior.</span><span class="sxs-lookup"><span data-stu-id="21d3a-131">Initializes a new instance of the <see cref="T:System.Collections.Stack" /> class that is empty and has the specified initial capacity or the default initial capacity, whichever is greater.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="21d3a-132">A capacidade de um <xref:System.Collections.Stack> é o número de elementos que o <xref:System.Collections.Stack> pode conter.</span><span class="sxs-lookup"><span data-stu-id="21d3a-132">The capacity of a <xref:System.Collections.Stack> is the number of elements that the <xref:System.Collections.Stack> can hold.</span></span> <span data-ttu-id="21d3a-133">Como os elementos são adicionados a um <xref:System.Collections.Stack>, a capacidade é aumentada automaticamente conforme necessário ao realocar a matriz interna.</span><span class="sxs-lookup"><span data-stu-id="21d3a-133">As elements are added to a <xref:System.Collections.Stack>, the capacity is automatically increased as required by reallocating the internal array.</span></span>  
  
 <span data-ttu-id="21d3a-134">Se o tamanho da coleção pode ser estimado, especificando a capacidade inicial elimina a necessidade de executar um número de operações de redimensionamento durante a adição de elementos para o <xref:System.Collections.Stack>.</span><span class="sxs-lookup"><span data-stu-id="21d3a-134">If the size of the collection can be estimated, specifying the initial capacity eliminates the need to perform a number of resizing operations while adding elements to the <xref:System.Collections.Stack>.</span></span>  
  
 <span data-ttu-id="21d3a-135">Este construtor é um O (`n`) operação, onde `n` é `initialCapacity`.</span><span class="sxs-lookup"><span data-stu-id="21d3a-135">This constructor is an O(`n`) operation, where `n` is `initialCapacity`.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="21d3a-136"><paramref name="initialCapacity" /> é menor que zero.</span><span class="sxs-lookup"><span data-stu-id="21d3a-136"><paramref name="initialCapacity" /> is less than zero.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Clear">
      <MemberSignature Language="C#" Value="public virtual void Clear ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Clear() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Stack.Clear" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Clear ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Clear();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="21d3a-137">Remove todos os objetos da <see cref="T:System.Collections.Stack" />.</span><span class="sxs-lookup"><span data-stu-id="21d3a-137">Removes all objects from the <see cref="T:System.Collections.Stack" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="21d3a-138"><xref:System.Collections.Stack.Count%2A> é definido como zero, e referências a outros objetos de elementos da coleção também são liberadas.</span><span class="sxs-lookup"><span data-stu-id="21d3a-138"><xref:System.Collections.Stack.Count%2A> is set to zero, and references to other objects from elements of the collection are also released.</span></span>  
  
 <span data-ttu-id="21d3a-139">Este método é uma operação O(`n`), em que `n` é <xref:System.Collections.Stack.Count%2A>.</span><span class="sxs-lookup"><span data-stu-id="21d3a-139">This method is an O(`n`) operation, where `n` is <xref:System.Collections.Stack.Count%2A>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="21d3a-140">O exemplo a seguir mostra como limpar os valores de <xref:System.Collections.Stack>.</span><span class="sxs-lookup"><span data-stu-id="21d3a-140">The following example shows how to clear the values of the <xref:System.Collections.Stack>.</span></span>  
  
 [!code-cpp[Classic Stack.Clear Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Stack.Clear Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Stack.Clear Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Stack.Clear Example/CS/source.cs#1)]
 [!code-vb[Classic Stack.Clear Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Stack.Clear Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Clone">
      <MemberSignature Language="C#" Value="public virtual object Clone ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object Clone() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Stack.Clone" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Clone () As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ Clone();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ICloneable.Clone</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="21d3a-141">Cria uma cópia superficial do <see cref="T:System.Collections.Stack" />.</span><span class="sxs-lookup"><span data-stu-id="21d3a-141">Creates a shallow copy of the <see cref="T:System.Collections.Stack" />.</span></span></summary>
        <returns><span data-ttu-id="21d3a-142">Uma cópia superficial do <see cref="T:System.Collections.Stack" />.</span><span class="sxs-lookup"><span data-stu-id="21d3a-142">A shallow copy of the <see cref="T:System.Collections.Stack" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="21d3a-143">Uma cópia superficial de uma coleção copia apenas os elementos da coleção, se eles são tipos de referência ou tipos de valor, mas não copia os objetos que se referem as referências a.</span><span class="sxs-lookup"><span data-stu-id="21d3a-143">A shallow copy of a collection copies only the elements of the collection, whether they are reference types or value types, but it does not copy the objects that the references refer to.</span></span> <span data-ttu-id="21d3a-144">As referências na nova coleção apontam para os mesmos objetos que as referências na coleção original apontem para.</span><span class="sxs-lookup"><span data-stu-id="21d3a-144">The references in the new collection point to the same objects that the references in the original collection point to.</span></span>  
  
 <span data-ttu-id="21d3a-145">Em contraste, uma cópia profunda de uma coleção copia os elementos e tudo direta ou indiretamente referenciado por elementos.</span><span class="sxs-lookup"><span data-stu-id="21d3a-145">In contrast, a deep copy of a collection copies the elements and everything directly or indirectly referenced by the elements.</span></span>  
  
 <span data-ttu-id="21d3a-146">Este método é uma operação O(`n`), em que `n` é <xref:System.Collections.Stack.Count%2A>.</span><span class="sxs-lookup"><span data-stu-id="21d3a-146">This method is an O(`n`) operation, where `n` is <xref:System.Collections.Stack.Count%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Contains">
      <MemberSignature Language="C#" Value="public virtual bool Contains (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Contains(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Stack.Contains(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Contains (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Contains(System::Object ^ obj);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj"><span data-ttu-id="21d3a-147">O objeto a ser localizado no <see cref="T:System.Collections.Stack" />.</span><span class="sxs-lookup"><span data-stu-id="21d3a-147">The object to locate in the <see cref="T:System.Collections.Stack" />.</span></span> <span data-ttu-id="21d3a-148">O valor pode ser <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="21d3a-148">The value can be <see langword="null" />.</span></span></param>
        <summary><span data-ttu-id="21d3a-149">Determina se um elemento está no <see cref="T:System.Collections.Stack" />.</span><span class="sxs-lookup"><span data-stu-id="21d3a-149">Determines whether an element is in the <see cref="T:System.Collections.Stack" />.</span></span></summary>
        <returns>
          <span data-ttu-id="21d3a-150"><see langword="true" /> se <paramref name="obj" /> for encontrado no <see cref="T:System.Collections.Stack" />; caso contrário, <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="21d3a-150"><see langword="true" />, if <paramref name="obj" /> is found in the <see cref="T:System.Collections.Stack" />; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="21d3a-151">Este método determina a igualdade chamando o <xref:System.Object.Equals%2A?displayProperty=nameWithType> método.</span><span class="sxs-lookup"><span data-stu-id="21d3a-151">This method determines equality by calling the <xref:System.Object.Equals%2A?displayProperty=nameWithType> method.</span></span>  
  
 <span data-ttu-id="21d3a-152">Este método executa uma pesquisa linear; por isso, esse método é uma operação O(`n`), em que `n` é <xref:System.Collections.Stack.Count%2A>.</span><span class="sxs-lookup"><span data-stu-id="21d3a-152">This method performs a linear search; therefore, this method is an O(`n`) operation, where `n` is <xref:System.Collections.Stack.Count%2A>.</span></span>  
  
 <span data-ttu-id="21d3a-153">Começando com o .NET Framework 2.0, este método testa a igualdade passando o `obj` argumento para o <xref:System.Object.Equals%2A> método objetos individuais na coleção.</span><span class="sxs-lookup"><span data-stu-id="21d3a-153">Starting with the .NET Framework 2.0, this method tests for equality by passing the `obj` argument to the <xref:System.Object.Equals%2A> method of individual objects in the collection.</span></span> <span data-ttu-id="21d3a-154">Nas versões anteriores do .NET Framework, isso foi feito usando passando os itens individuais na coleção para a <xref:System.Object.Equals%2A> método o `obj` argumento.</span><span class="sxs-lookup"><span data-stu-id="21d3a-154">In the earlier versions of the .NET Framework, this determination was made by using passing the individual items in the collection to the <xref:System.Object.Equals%2A> method of the `obj` argument.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public virtual void CopyTo (Array array, int index);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void CopyTo(class System.Array array, int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Stack.CopyTo(System.Array,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void CopyTo(Array ^ array, int index);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.ICollection.CopyTo(System.Array,System.Int32)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array"><span data-ttu-id="21d3a-155">O <see cref="T:System.Array" /> unidimensional que é o destino dos elementos copiados de <see cref="T:System.Collections.Stack" />.</span><span class="sxs-lookup"><span data-stu-id="21d3a-155">The one-dimensional <see cref="T:System.Array" /> that is the destination of the elements copied from <see cref="T:System.Collections.Stack" />.</span></span> <span data-ttu-id="21d3a-156">O <see cref="T:System.Array" /> deve ter indexação com base em zero.</span><span class="sxs-lookup"><span data-stu-id="21d3a-156">The <see cref="T:System.Array" /> must have zero-based indexing.</span></span></param>
        <param name="index"><span data-ttu-id="21d3a-157">O índice baseado em zero na <c>array</c> na qual a cópia começa.</span><span class="sxs-lookup"><span data-stu-id="21d3a-157">The zero-based index in <c>array</c> at which copying begins.</span></span></param>
        <summary><span data-ttu-id="21d3a-158">Copia o <see cref="T:System.Collections.Stack" /> para um unidimensional <see cref="T:System.Array" /> existente, começando no índice da matriz especificada.</span><span class="sxs-lookup"><span data-stu-id="21d3a-158">Copies the <see cref="T:System.Collections.Stack" /> to an existing one-dimensional <see cref="T:System.Array" />, starting at the specified array index.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="21d3a-159">Os elementos são copiados para a matriz na ordem do último a entrar, primeiro a sair (UEPS), semelhante à ordem dos elementos retornados por uma sucessão de chamadas para <xref:System.Collections.Stack.Pop%2A>.</span><span class="sxs-lookup"><span data-stu-id="21d3a-159">The elements are copied onto the array in last-in-first-out (LIFO) order, similar to the order of the elements returned by a succession of calls to <xref:System.Collections.Stack.Pop%2A>.</span></span>  
  
 <span data-ttu-id="21d3a-160">Este método é uma operação O(`n`), em que `n` é <xref:System.Collections.Stack.Count%2A>.</span><span class="sxs-lookup"><span data-stu-id="21d3a-160">This method is an O(`n`) operation, where `n` is <xref:System.Collections.Stack.Count%2A>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="21d3a-161">O exemplo a seguir mostra como copiar um <xref:System.Collections.Stack> em uma matriz unidimensional.</span><span class="sxs-lookup"><span data-stu-id="21d3a-161">The following example shows how to copy a <xref:System.Collections.Stack> into a one-dimensional array.</span></span>  
  
 [!code-cpp[Classic Stack.CopyTo Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Stack.CopyTo Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Stack.CopyTo Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Stack.CopyTo Example/CS/source.cs#1)]
 [!code-vb[Classic Stack.CopyTo Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Stack.CopyTo Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="21d3a-162"><paramref name="array" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="21d3a-162"><paramref name="array" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="21d3a-163"><paramref name="index" /> é menor que zero.</span><span class="sxs-lookup"><span data-stu-id="21d3a-163"><paramref name="index" /> is less than zero.</span></span></exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="21d3a-164"><paramref name="array" /> é multidimensional.</span><span class="sxs-lookup"><span data-stu-id="21d3a-164"><paramref name="array" /> is multidimensional.</span></span>  
  
 <span data-ttu-id="21d3a-165">- ou -</span><span class="sxs-lookup"><span data-stu-id="21d3a-165">-or-</span></span>  
  
 <span data-ttu-id="21d3a-166">O número de elementos na origem <see cref="T:System.Collections.Stack" /> é maior do que o espaço disponível de <paramref name="index" /> até o final do <paramref name="array" /> de destino.</span><span class="sxs-lookup"><span data-stu-id="21d3a-166">The number of elements in the source <see cref="T:System.Collections.Stack" /> is greater than the available space from <paramref name="index" /> to the end of the destination <paramref name="array" />.</span></span></exception>
        <exception cref="T:System.InvalidCastException"><span data-ttu-id="21d3a-167">O tipo do <see cref="T:System.Collections.Stack" /> de origem não pode ser automaticamente convertido para o tipo de <paramref name="array" /> de destino.</span><span class="sxs-lookup"><span data-stu-id="21d3a-167">The type of the source <see cref="T:System.Collections.Stack" /> cannot be cast automatically to the type of the destination <paramref name="array" />.</span></span></exception>
        <altmember cref="M:System.Collections.Stack.ToArray" />
      </Docs>
    </Member>
    <Member MemberName="Count">
      <MemberSignature Language="C#" Value="public virtual int Count { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Count" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Stack.Count" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property Count As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int Count { int get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.Count</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="21d3a-168">Obtém o número de elementos contidos no <see cref="T:System.Collections.Stack" />.</span><span class="sxs-lookup"><span data-stu-id="21d3a-168">Gets the number of elements contained in the <see cref="T:System.Collections.Stack" />.</span></span></summary>
        <value><span data-ttu-id="21d3a-169">O número de elementos contidos no <see cref="T:System.Collections.Stack" />.</span><span class="sxs-lookup"><span data-stu-id="21d3a-169">The number of elements contained in the <see cref="T:System.Collections.Stack" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="21d3a-170">A capacidade é o número de elementos que o <xref:System.Collections.Stack> pode armazenar.</span><span class="sxs-lookup"><span data-stu-id="21d3a-170">The capacity is the number of elements that the <xref:System.Collections.Stack> can store.</span></span> <span data-ttu-id="21d3a-171"><xref:System.Collections.Stack.Count%2A> é o número de elementos que estão realmente no <xref:System.Collections.Stack>.</span><span class="sxs-lookup"><span data-stu-id="21d3a-171"><xref:System.Collections.Stack.Count%2A> is the number of elements that are actually in the <xref:System.Collections.Stack>.</span></span>  
  
 <span data-ttu-id="21d3a-172">A capacidade é sempre maior que ou igual a <xref:System.Collections.Stack.Count%2A>.</span><span class="sxs-lookup"><span data-stu-id="21d3a-172">The capacity is always greater than or equal to <xref:System.Collections.Stack.Count%2A>.</span></span> <span data-ttu-id="21d3a-173">Se <xref:System.Collections.Stack.Count%2A> excede a capacidade durante a adição de elementos, a capacidade é aumentada automaticamente realocando a matriz interna antes de copiar os elementos antigos e adição de novos elementos.</span><span class="sxs-lookup"><span data-stu-id="21d3a-173">If <xref:System.Collections.Stack.Count%2A> exceeds the capacity while adding elements, the capacity is automatically increased by reallocating the internal array before copying the old elements and adding the new elements.</span></span>  
  
 <span data-ttu-id="21d3a-174">A recuperação do valor dessa propriedade é uma operação O(1).</span><span class="sxs-lookup"><span data-stu-id="21d3a-174">Retrieving the value of this property is an O(1) operation.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetEnumerator">
      <MemberSignature Language="C#" Value="public virtual System.Collections.IEnumerator GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.IEnumerator GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Stack.GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetEnumerator () As IEnumerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Collections::IEnumerator ^ GetEnumerator();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IEnumerable.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="21d3a-175">Retorna um <see cref="T:System.Collections.IEnumerator" /> para o <see cref="T:System.Collections.Stack" />.</span><span class="sxs-lookup"><span data-stu-id="21d3a-175">Returns an <see cref="T:System.Collections.IEnumerator" /> for the <see cref="T:System.Collections.Stack" />.</span></span></summary>
        <returns><span data-ttu-id="21d3a-176">Um <see cref="T:System.Collections.IEnumerator" /> para o <see cref="T:System.Collections.Stack" />.</span><span class="sxs-lookup"><span data-stu-id="21d3a-176">An <see cref="T:System.Collections.IEnumerator" /> for the <see cref="T:System.Collections.Stack" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="21d3a-177">[Visual Basic, C#]</span><span class="sxs-lookup"><span data-stu-id="21d3a-177">[Visual Basic, C#]</span></span>  
  
 <span data-ttu-id="21d3a-178">O `foreach` instrução de linguagem c# (`for each` no Visual Basic) oculta a complexidade dos enumeradores.</span><span class="sxs-lookup"><span data-stu-id="21d3a-178">The `foreach` statement of the C# language (`for each` in Visual Basic) hides the complexity of the enumerators.</span></span>  <span data-ttu-id="21d3a-179">Portanto, o uso de `foreach` é recomendado, em vez de manipular diretamente o enumerador.</span><span class="sxs-lookup"><span data-stu-id="21d3a-179">Therefore, using `foreach` is recommended, instead of directly manipulating the enumerator.</span></span>  
  
 <span data-ttu-id="21d3a-180">Os enumeradores podem ser usados para ler os dados na coleção, mas não podem ser usados para modificar a coleção subjacente.</span><span class="sxs-lookup"><span data-stu-id="21d3a-180">Enumerators can be used to read the data in the collection, but they cannot be used to modify the underlying collection.</span></span>  
  
 <span data-ttu-id="21d3a-181">Inicialmente, o enumerador é posicionado antes do primeiro elemento da coleção.</span><span class="sxs-lookup"><span data-stu-id="21d3a-181">Initially, the enumerator is positioned before the first element in the collection.</span></span> <span data-ttu-id="21d3a-182"><xref:System.Collections.IEnumerator.Reset%2A> também traz o enumerador de volta para essa posição.</span><span class="sxs-lookup"><span data-stu-id="21d3a-182"><xref:System.Collections.IEnumerator.Reset%2A> also brings the enumerator back to this position.</span></span>  <span data-ttu-id="21d3a-183">Nesta posição, <xref:System.Collections.IEnumerator.Current%2A> está indefinido.</span><span class="sxs-lookup"><span data-stu-id="21d3a-183">At this position, <xref:System.Collections.IEnumerator.Current%2A> is undefined.</span></span> <span data-ttu-id="21d3a-184">Por isso, você deve chamar <xref:System.Collections.IEnumerator.MoveNext%2A> para avançar o enumerador até o primeiro elemento da coleção antes de ler o valor de <xref:System.Collections.IEnumerator.Current%2A>.</span><span class="sxs-lookup"><span data-stu-id="21d3a-184">Therefore, you must call <xref:System.Collections.IEnumerator.MoveNext%2A> to advance the enumerator to the first element of the collection before reading the value of <xref:System.Collections.IEnumerator.Current%2A>.</span></span>  
  
 <span data-ttu-id="21d3a-185"><xref:System.Collections.IEnumerator.Current%2A> retorna o mesmo objeto até <xref:System.Collections.IEnumerator.MoveNext%2A> ou <xref:System.Collections.IEnumerator.Reset%2A> ser chamado.</span><span class="sxs-lookup"><span data-stu-id="21d3a-185"><xref:System.Collections.IEnumerator.Current%2A> returns the same object until either <xref:System.Collections.IEnumerator.MoveNext%2A> or <xref:System.Collections.IEnumerator.Reset%2A> is called.</span></span> <span data-ttu-id="21d3a-186"><xref:System.Collections.IEnumerator.MoveNext%2A> define <xref:System.Collections.IEnumerator.Current%2A> como o próximo elemento.</span><span class="sxs-lookup"><span data-stu-id="21d3a-186"><xref:System.Collections.IEnumerator.MoveNext%2A> sets <xref:System.Collections.IEnumerator.Current%2A> to the next element.</span></span>  
  
 <span data-ttu-id="21d3a-187">Caso <xref:System.Collections.IEnumerator.MoveNext%2A> passe o final da coleção, o enumerador é posicionado após o último elemento na coleção e <xref:System.Collections.IEnumerator.MoveNext%2A> retorna `false`.</span><span class="sxs-lookup"><span data-stu-id="21d3a-187">If <xref:System.Collections.IEnumerator.MoveNext%2A> passes the end of the collection, the enumerator is positioned after the last element in the collection and <xref:System.Collections.IEnumerator.MoveNext%2A> returns `false`.</span></span> <span data-ttu-id="21d3a-188">Quando o enumerador está nessa posição, as chamadas subsequentes para <xref:System.Collections.IEnumerator.MoveNext%2A> também retornam `false`.</span><span class="sxs-lookup"><span data-stu-id="21d3a-188">When the enumerator is at this position, subsequent calls to <xref:System.Collections.IEnumerator.MoveNext%2A> also return `false`.</span></span> <span data-ttu-id="21d3a-189">Caso a última chamada para <xref:System.Collections.IEnumerator.MoveNext%2A> tenha retornado `false`, <xref:System.Collections.IEnumerator.Current%2A> está indefinido.</span><span class="sxs-lookup"><span data-stu-id="21d3a-189">If the last call to <xref:System.Collections.IEnumerator.MoveNext%2A> returned `false`, <xref:System.Collections.IEnumerator.Current%2A> is undefined.</span></span> <span data-ttu-id="21d3a-190">Para definir <xref:System.Collections.IEnumerator.Current%2A> como o primeiro elemento da coleção novamente, é possível chamar <xref:System.Collections.IEnumerator.Reset%2A> seguido de <xref:System.Collections.IEnumerator.MoveNext%2A>.</span><span class="sxs-lookup"><span data-stu-id="21d3a-190">To set <xref:System.Collections.IEnumerator.Current%2A> to the first element of the collection again, you can call <xref:System.Collections.IEnumerator.Reset%2A> followed by <xref:System.Collections.IEnumerator.MoveNext%2A>.</span></span>  
  
 <span data-ttu-id="21d3a-191">Um enumerador permanece válido desde que a coleção continue inalterada.</span><span class="sxs-lookup"><span data-stu-id="21d3a-191">An enumerator remains valid as long as the collection remains unchanged.</span></span> <span data-ttu-id="21d3a-192">Se forem feitas alterações na coleção, como adicionar, modificar ou excluir elementos, o enumerador será invalidado de maneira irrevogável e seu comportamento permanecerá indefinido.</span><span class="sxs-lookup"><span data-stu-id="21d3a-192">If changes are made to the collection, such as adding, modifying, or deleting elements, the enumerator is irrecoverably invalidated and its behavior is undefined.</span></span>  
  
 <span data-ttu-id="21d3a-193">O enumerador não tem acesso exclusivo à coleção; por isso, a enumeração por meio de uma coleção não é um procedimento thread-safe intrínseco.</span><span class="sxs-lookup"><span data-stu-id="21d3a-193">The enumerator does not have exclusive access to the collection; therefore, enumerating through a collection is intrinsically not a thread-safe procedure.</span></span>  <span data-ttu-id="21d3a-194">Para garantir acesso thread-safe durante a enumeração, é possível bloquear a coleção durante toda a enumeração.</span><span class="sxs-lookup"><span data-stu-id="21d3a-194">To guarantee thread safety during enumeration, you can lock the collection during the entire enumeration.</span></span>  <span data-ttu-id="21d3a-195">Para permitir que a coleção a ser acessado por vários threads para leitura e gravação, você deve implementar sua sincronização.</span><span class="sxs-lookup"><span data-stu-id="21d3a-195">To allow the collection to be accessed by multiple threads for reading and writing, you must implement your own synchronization.</span></span>  
  
 <span data-ttu-id="21d3a-196">Este método é uma operação O(1).</span><span class="sxs-lookup"><span data-stu-id="21d3a-196">This method is an O(1) operation.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.IEnumerator" />
      </Docs>
    </Member>
    <Member MemberName="IsSynchronized">
      <MemberSignature Language="C#" Value="public virtual bool IsSynchronized { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSynchronized" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Stack.IsSynchronized" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsSynchronized As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSynchronized { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.IsSynchronized</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="21d3a-197">Obtém um valor que indica se o acesso à <see cref="T:System.Collections.Stack" /> é sincronizado (thread-safe).</span><span class="sxs-lookup"><span data-stu-id="21d3a-197">Gets a value indicating whether access to the <see cref="T:System.Collections.Stack" /> is synchronized (thread safe).</span></span></summary>
        <value>
          <span data-ttu-id="21d3a-198"><see langword="true" />, se acesse o <see cref="T:System.Collections.Stack" /> é sincronizado (thread-safe); caso contrário, <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="21d3a-198"><see langword="true" />, if access to the <see cref="T:System.Collections.Stack" /> is synchronized (thread safe); otherwise, <see langword="false" />.</span></span> <span data-ttu-id="21d3a-199">O padrão é <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="21d3a-199">The default is <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="21d3a-200">Para garantir a segurança de thread do <xref:System.Collections.Stack>, todas as operações devem ser feitas por meio do wrapper retornado pelo <xref:System.Collections.Stack.Synchronized%2A> método.</span><span class="sxs-lookup"><span data-stu-id="21d3a-200">To guarantee the thread safety of the <xref:System.Collections.Stack>, all operations must be done through the wrapper returned by the <xref:System.Collections.Stack.Synchronized%2A> method.</span></span>  
  
 <span data-ttu-id="21d3a-201">A enumeração por meio de uma coleção não é um procedimento thread-safe intrínseco.</span><span class="sxs-lookup"><span data-stu-id="21d3a-201">Enumerating through a collection is intrinsically not a thread-safe procedure.</span></span> <span data-ttu-id="21d3a-202">Mesmo quando uma coleção está sincronizada, outros threads ainda podem modificar a coleção, o que faz o enumerador lançar uma exceção.</span><span class="sxs-lookup"><span data-stu-id="21d3a-202">Even when a collection is synchronized, other threads can still modify the collection, which causes the enumerator to throw an exception.</span></span> <span data-ttu-id="21d3a-203">Para garantir thread-safe durante a enumeração, é possível bloquear a coleção durante toda a enumeração ou verificar as exceções resultantes das alterações feitas por outros threads.</span><span class="sxs-lookup"><span data-stu-id="21d3a-203">To guarantee thread safety during enumeration, you can either lock the collection during the entire enumeration or catch the exceptions resulting from changes made by other threads.</span></span>  
  
 <span data-ttu-id="21d3a-204">O exemplo de código a seguir mostra como bloquear a coleção usando o <xref:System.Collections.Stack.SyncRoot%2A> durante toda a enumeração.</span><span class="sxs-lookup"><span data-stu-id="21d3a-204">The following code example shows how to lock the collection using the <xref:System.Collections.Stack.SyncRoot%2A> during the entire enumeration.</span></span>  
  
 [!code-cpp[Classic Stack.IsSynchronized Example#2](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Stack.IsSynchronized Example/CPP/source2.cpp#2)]
 [!code-csharp[Classic Stack.IsSynchronized Example#2](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Stack.IsSynchronized Example/CS/source2.cs#2)]
 [!code-vb[Classic Stack.IsSynchronized Example#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Stack.IsSynchronized Example/VB/source2.vb#2)]  
  
 <span data-ttu-id="21d3a-205">A recuperação do valor dessa propriedade é uma operação O(1).</span><span class="sxs-lookup"><span data-stu-id="21d3a-205">Retrieving the value of this property is an O(1) operation.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="21d3a-206">O exemplo a seguir mostra como sincronizar um <xref:System.Collections.Stack>, determinar se um <xref:System.Collections.Stack> está sincronizado e usar um sincronizado <xref:System.Collections.Stack>.</span><span class="sxs-lookup"><span data-stu-id="21d3a-206">The following example shows how to synchronize a <xref:System.Collections.Stack>, determine if a <xref:System.Collections.Stack> is synchronized, and use a synchronized <xref:System.Collections.Stack>.</span></span>  
  
 [!code-cpp[Classic Stack.IsSynchronized Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Stack.IsSynchronized Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Stack.IsSynchronized Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Stack.IsSynchronized Example/CS/source.cs#1)]
 [!code-vb[Classic Stack.IsSynchronized Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Stack.IsSynchronized Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Peek">
      <MemberSignature Language="C#" Value="public virtual object Peek ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object Peek() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Stack.Peek" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Peek () As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ Peek();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="21d3a-207">Remove o objeto na parte superior do <see cref="T:System.Collections.Stack" /> sem removê-lo.</span><span class="sxs-lookup"><span data-stu-id="21d3a-207">Returns the object at the top of the <see cref="T:System.Collections.Stack" /> without removing it.</span></span></summary>
        <returns><span data-ttu-id="21d3a-208">O <see cref="T:System.Object" /> na parte superior do <see cref="T:System.Collections.Stack" />.</span><span class="sxs-lookup"><span data-stu-id="21d3a-208">The <see cref="T:System.Object" /> at the top of the <see cref="T:System.Collections.Stack" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="21d3a-209">Esse método é semelhante do <xref:System.Collections.Stack.Pop%2A> método, mas <xref:System.Collections.Stack.Peek%2A> não modifica o <xref:System.Collections.Stack>.</span><span class="sxs-lookup"><span data-stu-id="21d3a-209">This method is similar to the <xref:System.Collections.Stack.Pop%2A> method, but <xref:System.Collections.Stack.Peek%2A> does not modify the <xref:System.Collections.Stack>.</span></span>  
  
 <span data-ttu-id="21d3a-210">`null` pode ser enviado para o <xref:System.Collections.Stack> como um espaço reservado, se necessário.</span><span class="sxs-lookup"><span data-stu-id="21d3a-210">`null` can be pushed onto the <xref:System.Collections.Stack> as a placeholder, if needed.</span></span> <span data-ttu-id="21d3a-211">Para distinguir entre um valor nulo e o fim da pilha, verifique o <xref:System.Collections.Stack.Count%2A> catch ou propriedade de <xref:System.InvalidOperationException>, que é gerado quando o <xref:System.Collections.Stack> está vazio.</span><span class="sxs-lookup"><span data-stu-id="21d3a-211">To distinguish between a null value and the end of the stack, check the <xref:System.Collections.Stack.Count%2A> property or catch the <xref:System.InvalidOperationException>, which is thrown when the <xref:System.Collections.Stack> is empty.</span></span>  
  
 <span data-ttu-id="21d3a-212">Este método é uma operação O(1).</span><span class="sxs-lookup"><span data-stu-id="21d3a-212">This method is an O(1) operation.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="21d3a-213">O exemplo a seguir mostra como adicionar elementos para o <xref:System.Collections.Stack>, remover elementos do <xref:System.Collections.Stack>, ou exibir o elemento na parte superior do <xref:System.Collections.Stack>.</span><span class="sxs-lookup"><span data-stu-id="21d3a-213">The following example shows how to add elements to the <xref:System.Collections.Stack>, remove elements from the <xref:System.Collections.Stack>, or view the element at the top of the <xref:System.Collections.Stack>.</span></span>  
  
 [!code-cpp[Classic Stack.Peek Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Stack.Peek Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Stack.Peek Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Stack.Peek Example/CS/source.cs#1)]
 [!code-vb[Classic Stack.Peek Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Stack.Peek Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="21d3a-214">O <see cref="T:System.Collections.Stack" /> está vazio.</span><span class="sxs-lookup"><span data-stu-id="21d3a-214">The <see cref="T:System.Collections.Stack" /> is empty.</span></span></exception>
        <altmember cref="M:System.Collections.Stack.Pop" />
        <altmember cref="M:System.Collections.Stack.Push(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Pop">
      <MemberSignature Language="C#" Value="public virtual object Pop ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object Pop() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Stack.Pop" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Pop () As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ Pop();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="21d3a-215">Remove e retorna o objeto na parte superior do <see cref="T:System.Collections.Stack" />.</span><span class="sxs-lookup"><span data-stu-id="21d3a-215">Removes and returns the object at the top of the <see cref="T:System.Collections.Stack" />.</span></span></summary>
        <returns><span data-ttu-id="21d3a-216">O <see cref="T:System.Object" /> foi removido da parte superior do <see cref="T:System.Collections.Stack" />.</span><span class="sxs-lookup"><span data-stu-id="21d3a-216">The <see cref="T:System.Object" /> removed from the top of the <see cref="T:System.Collections.Stack" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="21d3a-217">Esse método é semelhante do <xref:System.Collections.Stack.Peek%2A> método, mas <xref:System.Collections.Stack.Peek%2A> não modifica o <xref:System.Collections.Stack>.</span><span class="sxs-lookup"><span data-stu-id="21d3a-217">This method is similar to the <xref:System.Collections.Stack.Peek%2A> method, but <xref:System.Collections.Stack.Peek%2A> does not modify the <xref:System.Collections.Stack>.</span></span>  
  
 <span data-ttu-id="21d3a-218">`null` pode ser enviado para o <xref:System.Collections.Stack> como um espaço reservado, se necessário.</span><span class="sxs-lookup"><span data-stu-id="21d3a-218">`null` can be pushed onto the <xref:System.Collections.Stack> as a placeholder, if needed.</span></span> <span data-ttu-id="21d3a-219">Para distinguir entre um valor nulo e o fim da pilha, verifique o <xref:System.Collections.Stack.Count%2A> catch ou propriedade de <xref:System.InvalidOperationException>, que é gerado quando o <xref:System.Collections.Stack> está vazio.</span><span class="sxs-lookup"><span data-stu-id="21d3a-219">To distinguish between a null value and the end of the stack, check the <xref:System.Collections.Stack.Count%2A> property or catch the <xref:System.InvalidOperationException>, which is thrown when the <xref:System.Collections.Stack> is empty.</span></span>  
  
 <span data-ttu-id="21d3a-220">Este método é uma operação O(1).</span><span class="sxs-lookup"><span data-stu-id="21d3a-220">This method is an O(1) operation.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="21d3a-221">O exemplo a seguir mostra como adicionar elementos para o <xref:System.Collections.Stack>, remover elementos do <xref:System.Collections.Stack>, ou exibir o elemento na parte superior do <xref:System.Collections.Stack>.</span><span class="sxs-lookup"><span data-stu-id="21d3a-221">The following example shows how to add elements to the <xref:System.Collections.Stack>, remove elements from the <xref:System.Collections.Stack>, or view the element at the top of the <xref:System.Collections.Stack>.</span></span>  
  
 [!code-cpp[Classic Stack.Peek Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Stack.Peek Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Stack.Peek Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Stack.Peek Example/CS/source.cs#1)]
 [!code-vb[Classic Stack.Peek Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Stack.Peek Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="21d3a-222">O <see cref="T:System.Collections.Stack" /> está vazio.</span><span class="sxs-lookup"><span data-stu-id="21d3a-222">The <see cref="T:System.Collections.Stack" /> is empty.</span></span></exception>
        <altmember cref="M:System.Collections.Stack.Peek" />
        <altmember cref="M:System.Collections.Stack.Push(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Push">
      <MemberSignature Language="C#" Value="public virtual void Push (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Push(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Stack.Push(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Push (obj As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Push(System::Object ^ obj);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj"><span data-ttu-id="21d3a-223">O <see cref="T:System.Object" /> a ser enviado por push para o <see cref="T:System.Collections.Stack" />.</span><span class="sxs-lookup"><span data-stu-id="21d3a-223">The <see cref="T:System.Object" /> to push onto the <see cref="T:System.Collections.Stack" />.</span></span> <span data-ttu-id="21d3a-224">O valor pode ser <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="21d3a-224">The value can be <see langword="null" />.</span></span></param>
        <summary><span data-ttu-id="21d3a-225">Insere um objeto na parte superior do <see cref="T:System.Collections.Stack" />.</span><span class="sxs-lookup"><span data-stu-id="21d3a-225">Inserts an object at the top of the <see cref="T:System.Collections.Stack" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="21d3a-226">Se <xref:System.Collections.Stack.Count%2A> já for igual à capacidade, a capacidade do <xref:System.Collections.Stack> é aumentado, automaticamente realocando matriz interna, e os elementos existentes são copiados para a nova matriz antes de adicionar o novo elemento.</span><span class="sxs-lookup"><span data-stu-id="21d3a-226">If <xref:System.Collections.Stack.Count%2A> already equals the capacity, the capacity of the <xref:System.Collections.Stack> is increased by automatically reallocating the internal array, and the existing elements are copied to the new array before the new element is added.</span></span>  
  
 <span data-ttu-id="21d3a-227">`null` pode ser enviado para o <xref:System.Collections.Stack> como um espaço reservado, se necessário.</span><span class="sxs-lookup"><span data-stu-id="21d3a-227">`null` can be pushed onto the <xref:System.Collections.Stack> as a placeholder, if needed.</span></span> <span data-ttu-id="21d3a-228">Ele ocupa um slot da pilha e é tratado como qualquer objeto.</span><span class="sxs-lookup"><span data-stu-id="21d3a-228">It occupies a slot in the stack and is treated like any object.</span></span>  
  
 <span data-ttu-id="21d3a-229">Se <xref:System.Collections.Stack.Count%2A> é menor que a capacidade da pilha, <xref:System.Collections.Stack.Push%2A> é uma operação de (1).</span><span class="sxs-lookup"><span data-stu-id="21d3a-229">If <xref:System.Collections.Stack.Count%2A> is less than the capacity of the stack, <xref:System.Collections.Stack.Push%2A> is an O(1) operation.</span></span> <span data-ttu-id="21d3a-230">Se a capacidade precisa ser aumentado para acomodar o novo elemento, <xref:System.Collections.Stack.Push%2A> se torna um O (`n`) operação, onde `n` é <xref:System.Collections.Stack.Count%2A>.</span><span class="sxs-lookup"><span data-stu-id="21d3a-230">If the capacity needs to be increased to accommodate the new element, <xref:System.Collections.Stack.Push%2A> becomes an O(`n`) operation, where `n` is <xref:System.Collections.Stack.Count%2A>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="21d3a-231">O exemplo a seguir mostra como adicionar elementos para o <xref:System.Collections.Stack>, remover elementos do <xref:System.Collections.Stack>, ou exibir o elemento na parte superior do <xref:System.Collections.Stack>.</span><span class="sxs-lookup"><span data-stu-id="21d3a-231">The following example shows how to add elements to the <xref:System.Collections.Stack>, remove elements from the <xref:System.Collections.Stack>, or view the element at the top of the <xref:System.Collections.Stack>.</span></span>  
  
 [!code-cpp[Classic Stack.Peek Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Stack.Peek Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Stack.Peek Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Stack.Peek Example/CS/source.cs#1)]
 [!code-vb[Classic Stack.Peek Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Stack.Peek Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Collections.Stack.Peek" />
        <altmember cref="M:System.Collections.Stack.Pop" />
      </Docs>
    </Member>
    <Member MemberName="Synchronized">
      <MemberSignature Language="C#" Value="public static System.Collections.Stack Synchronized (System.Collections.Stack stack);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Stack Synchronized(class System.Collections.Stack stack) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Stack.Synchronized(System.Collections.Stack)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Collections::Stack ^ Synchronized(System::Collections::Stack ^ stack);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Stack</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stack" Type="System.Collections.Stack" />
      </Parameters>
      <Docs>
        <param name="stack"><span data-ttu-id="21d3a-232">O <see cref="T:System.Collections.Stack" /> a ser sincronizado.</span><span class="sxs-lookup"><span data-stu-id="21d3a-232">The <see cref="T:System.Collections.Stack" /> to synchronize.</span></span></param>
        <summary><span data-ttu-id="21d3a-233">Retorna um wrapper sincronizado (thread-safe) para o <see cref="T:System.Collections.Stack" />.</span><span class="sxs-lookup"><span data-stu-id="21d3a-233">Returns a synchronized (thread safe) wrapper for the <see cref="T:System.Collections.Stack" />.</span></span></summary>
        <returns><span data-ttu-id="21d3a-234">Um wrapper sincronizado em torno do <see cref="T:System.Collections.Stack" />.</span><span class="sxs-lookup"><span data-stu-id="21d3a-234">A synchronized wrapper around the <see cref="T:System.Collections.Stack" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="21d3a-235">Para garantir a segurança de thread do <xref:System.Collections.Stack>, todas as operações devem ser feitas por meio desse wrapper.</span><span class="sxs-lookup"><span data-stu-id="21d3a-235">To guarantee the thread safety of the <xref:System.Collections.Stack>, all operations must be done through this wrapper.</span></span>  
  
 <span data-ttu-id="21d3a-236">A enumeração por meio de uma coleção não é um procedimento thread-safe intrínseco.</span><span class="sxs-lookup"><span data-stu-id="21d3a-236">Enumerating through a collection is intrinsically not a thread-safe procedure.</span></span> <span data-ttu-id="21d3a-237">Mesmo quando uma coleção está sincronizada, outros threads ainda podem modificar a coleção, o que faz o enumerador lançar uma exceção.</span><span class="sxs-lookup"><span data-stu-id="21d3a-237">Even when a collection is synchronized, other threads can still modify the collection, which causes the enumerator to throw an exception.</span></span> <span data-ttu-id="21d3a-238">Para garantir thread-safe durante a enumeração, é possível bloquear a coleção durante toda a enumeração ou verificar as exceções resultantes das alterações feitas por outros threads.</span><span class="sxs-lookup"><span data-stu-id="21d3a-238">To guarantee thread safety during enumeration, you can either lock the collection during the entire enumeration or catch the exceptions resulting from changes made by other threads.</span></span>  
  
 <span data-ttu-id="21d3a-239">O exemplo de código a seguir mostra como bloquear a coleção usando o <xref:System.Collections.Stack.SyncRoot%2A> durante toda a enumeração.</span><span class="sxs-lookup"><span data-stu-id="21d3a-239">The following code example shows how to lock the collection using the <xref:System.Collections.Stack.SyncRoot%2A> during the entire enumeration.</span></span>  
  
 [!code-cpp[Classic Stack.IsSynchronized Example#2](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Stack.IsSynchronized Example/CPP/source2.cpp#2)]
 [!code-csharp[Classic Stack.IsSynchronized Example#2](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Stack.IsSynchronized Example/CS/source2.cs#2)]
 [!code-vb[Classic Stack.IsSynchronized Example#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Stack.IsSynchronized Example/VB/source2.vb#2)]  
  
 <span data-ttu-id="21d3a-240">Este método é uma operação O(1).</span><span class="sxs-lookup"><span data-stu-id="21d3a-240">This method is an O(1) operation.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="21d3a-241">O exemplo a seguir mostra como sincronizar um <xref:System.Collections.Stack>, determinar se um <xref:System.Collections.Stack> está sincronizado e usar um sincronizado <xref:System.Collections.Stack>.</span><span class="sxs-lookup"><span data-stu-id="21d3a-241">The following example shows how to synchronize a <xref:System.Collections.Stack>, determine if a <xref:System.Collections.Stack> is synchronized, and use a synchronized <xref:System.Collections.Stack>.</span></span>  
  
 [!code-cpp[Classic Stack.IsSynchronized Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Stack.IsSynchronized Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Stack.IsSynchronized Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Stack.IsSynchronized Example/CS/source.cs#1)]
 [!code-vb[Classic Stack.IsSynchronized Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Stack.IsSynchronized Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="21d3a-242"><paramref name="stack" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="21d3a-242"><paramref name="stack" /> is <see langword="null" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="SyncRoot">
      <MemberSignature Language="C#" Value="public virtual object SyncRoot { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object SyncRoot" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Stack.SyncRoot" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property SyncRoot As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Object ^ SyncRoot { System::Object ^ get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.SyncRoot</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="21d3a-243">Obtém um objeto que pode ser usado para sincronizar o acesso ao <see cref="T:System.Collections.Stack" />.</span><span class="sxs-lookup"><span data-stu-id="21d3a-243">Gets an object that can be used to synchronize access to the <see cref="T:System.Collections.Stack" />.</span></span></summary>
        <value><span data-ttu-id="21d3a-244">Um <see cref="T:System.Object" /> que pode ser usado para sincronizar o acesso a <see cref="T:System.Collections.Stack" />.</span><span class="sxs-lookup"><span data-stu-id="21d3a-244">An <see cref="T:System.Object" /> that can be used to synchronize access to the <see cref="T:System.Collections.Stack" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="21d3a-245">Para criar uma versão sincronizada do <xref:System.Collections.Stack>, use o <xref:System.Collections.Stack.Synchronized%2A> método.</span><span class="sxs-lookup"><span data-stu-id="21d3a-245">To create a synchronized version of the <xref:System.Collections.Stack>, use the <xref:System.Collections.Stack.Synchronized%2A> method.</span></span> <span data-ttu-id="21d3a-246">No entanto, as classes derivadas podem fornecer sua própria versão sincronizada de <xref:System.Collections.Stack> usando o <xref:System.Collections.Stack.SyncRoot%2A> propriedade.</span><span class="sxs-lookup"><span data-stu-id="21d3a-246">However, derived classes can provide their own synchronized version of the <xref:System.Collections.Stack> using the <xref:System.Collections.Stack.SyncRoot%2A> property.</span></span> <span data-ttu-id="21d3a-247">O código de sincronização necessário realizar operações no <xref:System.Collections.Stack.SyncRoot%2A> do <xref:System.Collections.Stack>, não diretamente no <xref:System.Collections.Stack>.</span><span class="sxs-lookup"><span data-stu-id="21d3a-247">The synchronizing code must perform operations on the <xref:System.Collections.Stack.SyncRoot%2A> of the <xref:System.Collections.Stack>, not directly on the <xref:System.Collections.Stack>.</span></span> <span data-ttu-id="21d3a-248">Isso garante a operação apropriada das coleções que são derivadas de outros objetos.</span><span class="sxs-lookup"><span data-stu-id="21d3a-248">This ensures proper operation of collections that are derived from other objects.</span></span> <span data-ttu-id="21d3a-249">Especificamente, ele mantém uma sincronização adequada com outros threads que podem ser simultaneamente modificando o <xref:System.Collections.Stack> objeto.</span><span class="sxs-lookup"><span data-stu-id="21d3a-249">Specifically, it maintains proper synchronization with other threads that might be simultaneously modifying the <xref:System.Collections.Stack> object.</span></span>  
  
 <span data-ttu-id="21d3a-250">A enumeração por meio de uma coleção não é um procedimento thread-safe intrínseco.</span><span class="sxs-lookup"><span data-stu-id="21d3a-250">Enumerating through a collection is intrinsically not a thread-safe procedure.</span></span> <span data-ttu-id="21d3a-251">Mesmo quando uma coleção está sincronizada, outros threads ainda podem modificar a coleção, o que faz o enumerador lançar uma exceção.</span><span class="sxs-lookup"><span data-stu-id="21d3a-251">Even when a collection is synchronized, other threads can still modify the collection, which causes the enumerator to throw an exception.</span></span> <span data-ttu-id="21d3a-252">Para garantir thread-safe durante a enumeração, é possível bloquear a coleção durante toda a enumeração ou verificar as exceções resultantes das alterações feitas por outros threads.</span><span class="sxs-lookup"><span data-stu-id="21d3a-252">To guarantee thread safety during enumeration, you can either lock the collection during the entire enumeration or catch the exceptions resulting from changes made by other threads.</span></span>  
  
 <span data-ttu-id="21d3a-253">O exemplo de código a seguir mostra como bloquear a coleção usando o <xref:System.Collections.Stack.SyncRoot%2A> durante toda a enumeração.</span><span class="sxs-lookup"><span data-stu-id="21d3a-253">The following code example shows how to lock the collection using the <xref:System.Collections.Stack.SyncRoot%2A> during the entire enumeration.</span></span>  
  
 [!code-cpp[Classic Stack.IsSynchronized Example#2](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Stack.IsSynchronized Example/CPP/source2.cpp#2)]
 [!code-csharp[Classic Stack.IsSynchronized Example#2](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Stack.IsSynchronized Example/CS/source2.cs#2)]
 [!code-vb[Classic Stack.IsSynchronized Example#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Stack.IsSynchronized Example/VB/source2.vb#2)]  
  
 <span data-ttu-id="21d3a-254">A recuperação do valor dessa propriedade é uma operação O(1).</span><span class="sxs-lookup"><span data-stu-id="21d3a-254">Retrieving the value of this property is an O(1) operation.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToArray">
      <MemberSignature Language="C#" Value="public virtual object[] ToArray ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object[] ToArray() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Stack.ToArray" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ToArray () As Object()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Object ^&gt; ^ ToArray();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="21d3a-255">Copia o <see cref="T:System.Collections.Stack" /> em uma nova matriz.</span><span class="sxs-lookup"><span data-stu-id="21d3a-255">Copies the <see cref="T:System.Collections.Stack" /> to a new array.</span></span></summary>
        <returns><span data-ttu-id="21d3a-256">Uma nova matriz que contém cópias dos elementos do <see cref="T:System.Collections.Stack" />.</span><span class="sxs-lookup"><span data-stu-id="21d3a-256">A new array containing copies of the elements of the <see cref="T:System.Collections.Stack" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="21d3a-257">Os elementos são copiados para a matriz na ordem do último a entrar, primeiro a sair (UEPS), semelhante à ordem dos elementos retornados por uma sucessão de chamadas para <xref:System.Collections.Stack.Pop%2A>.</span><span class="sxs-lookup"><span data-stu-id="21d3a-257">The elements are copied onto the array in last-in-first-out (LIFO) order, similar to the order of the elements returned by a succession of calls to <xref:System.Collections.Stack.Pop%2A>.</span></span>  
  
 <span data-ttu-id="21d3a-258">Este método é uma operação O(`n`), em que `n` é <xref:System.Collections.Stack.Count%2A>.</span><span class="sxs-lookup"><span data-stu-id="21d3a-258">This method is an O(`n`) operation, where `n` is <xref:System.Collections.Stack.Count%2A>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="21d3a-259">O exemplo a seguir mostra como copiar um <xref:System.Collections.Stack> em uma matriz unidimensional.</span><span class="sxs-lookup"><span data-stu-id="21d3a-259">The following example shows how to copy a <xref:System.Collections.Stack> into a one-dimensional array.</span></span>  
  
 [!code-cpp[Classic Stack.CopyTo Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Stack.CopyTo Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Stack.CopyTo Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Stack.CopyTo Example/CS/source.cs#1)]
 [!code-vb[Classic Stack.CopyTo Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Stack.CopyTo Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Collections.Stack.CopyTo(System.Array,System.Int32)" />
        <altmember cref="M:System.Collections.Stack.Pop" />
      </Docs>
    </Member>
  </Members>
</Type>