<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="Queue.xml" source-language="en-US" target-language="pt-BR">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-15c36f0" tool-company="Microsoft" />
      <xliffext:skl_file_name xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">02cd5861-7ce2-4a82-b358-31f8435a0ac535a21c57df8f37e412b63620230c911fe166fb4d.skl</xliffext:skl_file_name>
      <xliffext:version xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">1.2</xliffext:version>
      <xliffext:ms.openlocfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">35a21c57df8f37e412b63620230c911fe166fb4d</xliffext:ms.openlocfilehash>
      <xliffext:ms.sourcegitcommit xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b</xliffext:ms.sourcegitcommit>
      <xliffext:ms.lasthandoff xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">04/03/2018</xliffext:ms.lasthandoff>
      <xliffext:moniker_ids xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">netcore-1.0,netcore-1.1,netcore-2.0,netcore-2.1,netframework-4.5.1,netframework-4.5.2,netframework-4.5,netframework-4.6.1,netframework-4.6.2,netframework-4.6,netframework-4.7.1,netframework-4.7,netstandard-2.0,xamarinandroid-7.1,xamarinios-10.8,xamarinmac-3.0</xliffext:moniker_ids>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve" uid="T:System.Collections.Queue">
          <source>Represents a first-in, first-out collection of objects.</source>
          
        </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Queue">
          <source>This class implements a queue as a circular array.</source>
          <target state="translated">Essa classe implementa uma fila como uma matriz circular.</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Queue">
          <source>Objects stored in a <ph id="ph1">&lt;xref:System.Collections.Queue&gt;</ph> are inserted at one end and removed from the other.</source>
          <target state="translated">Objetos armazenados em um <ph id="ph1">&lt;xref:System.Collections.Queue&gt;</ph> são inseridas em uma extremidade e removido da outra.</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Queue">
          <source>Queues and stacks are useful when you need temporary storage for information; that is, when you might want to discard an element after retrieving its value.</source>
          <target state="translated">Pilhas e filas são úteis quando você precisa de armazenamento temporário para informações. ou seja, quando você quiser descartar um elemento após recuperar seu valor.</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Queue">
          <source>Use <ph id="ph1">&lt;xref:System.Collections.Queue&gt;</ph> if you need to access the information in the same order that it is stored in the collection.</source>
          <target state="translated">Use <ph id="ph1">&lt;xref:System.Collections.Queue&gt;</ph> se você precisar acessar as informações na mesma ordem em que ela está armazenada na coleção.</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Queue">
          <source>Use <ph id="ph1">&lt;xref:System.Collections.Stack&gt;</ph> if you need to access the information in reverse order.</source>
          <target state="translated">Use <ph id="ph1">&lt;xref:System.Collections.Stack&gt;</ph> se você precisar acessar as informações na ordem inversa.</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Queue">
          <source>Use <ph id="ph1">&lt;xref:System.Collections.Concurrent.ConcurrentQueue%601&gt;</ph> or <ph id="ph2">&lt;xref:System.Collections.Concurrent.ConcurrentStack%601&gt;</ph> if you need to access the collection from multiple threads concurrently.</source>
          <target state="translated">Use <ph id="ph1">&lt;xref:System.Collections.Concurrent.ConcurrentQueue%601&gt;</ph> ou <ph id="ph2">&lt;xref:System.Collections.Concurrent.ConcurrentStack%601&gt;</ph> se você precisar acessar a coleção de vários threads simultaneamente.</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Queue">
          <source>Three main operations can be performed on a <ph id="ph1">&lt;xref:System.Collections.Queue&gt;</ph> and its elements:</source>
          <target state="translated">Três operações principais podem ser executadas em um <ph id="ph1">&lt;xref:System.Collections.Queue&gt;</ph> e seus elementos:</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Queue">
          <source><ph id="ph1">&lt;xref:System.Collections.Queue.Enqueue%2A&gt;</ph> adds an element to the end of the <ph id="ph2">&lt;xref:System.Collections.Queue&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Collections.Queue.Enqueue%2A&gt;</ph> Adiciona um elemento ao final do <ph id="ph2">&lt;xref:System.Collections.Queue&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Queue">
          <source><ph id="ph1">&lt;xref:System.Collections.Queue.Dequeue%2A&gt;</ph> removes the oldest element from the start of the <ph id="ph2">&lt;xref:System.Collections.Queue&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Collections.Queue.Dequeue%2A&gt;</ph> Remove o elemento mais antigo do início do <ph id="ph2">&lt;xref:System.Collections.Queue&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Queue">
          <source><ph id="ph1">&lt;xref:System.Collections.Queue.Peek%2A&gt;</ph> returns the oldest element that is at the start of the <ph id="ph2">&lt;xref:System.Collections.Queue&gt;</ph> but does not remove it from the <ph id="ph3">&lt;xref:System.Collections.Queue&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Collections.Queue.Peek%2A&gt;</ph> Retorna o elemento mais antigo que está no início do <ph id="ph2">&lt;xref:System.Collections.Queue&gt;</ph> mas não removê-lo a <ph id="ph3">&lt;xref:System.Collections.Queue&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Queue">
          <source>The capacity of a <ph id="ph1">&lt;xref:System.Collections.Queue&gt;</ph> is the number of elements the <ph id="ph2">&lt;xref:System.Collections.Queue&gt;</ph> can hold.</source>
          <target state="translated">A capacidade de um <ph id="ph1">&lt;xref:System.Collections.Queue&gt;</ph> é o número de elementos de <ph id="ph2">&lt;xref:System.Collections.Queue&gt;</ph> pode conter.</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Queue">
          <source>As elements are added to a <ph id="ph1">&lt;xref:System.Collections.Queue&gt;</ph>, the capacity is automatically increased as required through reallocation.</source>
          <target state="translated">Como os elementos são adicionados a um <ph id="ph1">&lt;xref:System.Collections.Queue&gt;</ph>, a capacidade é aumentada automaticamente conforme necessário por meio de realocação.</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Queue">
          <source>The capacity can be decreased by calling <ph id="ph1">&lt;xref:System.Collections.Queue.TrimToSize%2A&gt;</ph>.</source>
          <target state="translated">A capacidade pode ser diminuída chamando <ph id="ph1">&lt;xref:System.Collections.Queue.TrimToSize%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Queue">
          <source>The growth factor is the number by which the current capacity is multiplied when a greater capacity is required.</source>
          <target state="translated">O fator de crescimento é o número pelo qual a capacidade atual é multiplicada quando for necessária uma maior capacidade.</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Queue">
          <source>The growth factor is determined when the <ph id="ph1">&lt;xref:System.Collections.Queue&gt;</ph> is constructed.</source>
          <target state="translated">O fator de crescimento é determinado quando o <ph id="ph1">&lt;xref:System.Collections.Queue&gt;</ph> é construído.</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Queue">
          <source>The default growth factor is 2.0.</source>
          <target state="translated">O fator de crescimento padrão é 2.0.</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Queue">
          <source>The capacity of the <ph id="ph1">&lt;xref:System.Collections.Queue&gt;</ph> will always increase by at least a minimum of four, regardless of the growth factor.</source>
          <target state="translated">A capacidade do <ph id="ph1">&lt;xref:System.Collections.Queue&gt;</ph> sempre será aumentado em um mínimo de quatro, independentemente do fator de crescimento.</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Queue">
          <source>For example, a <ph id="ph1">&lt;xref:System.Collections.Queue&gt;</ph> with a growth factor of 1.0 will always increase in capacity by four when a greater capacity is required.</source>
          <target state="translated">Por exemplo, um <ph id="ph1">&lt;xref:System.Collections.Queue&gt;</ph> com um fator de crescimento de 1.0 sempre aumentará de capacidade por quatro quando for necessária uma maior capacidade.</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Queue">
          <source><ph id="ph1">&lt;xref:System.Collections.Queue&gt;</ph> accepts <ph id="ph2">`null`</ph> as a valid value and allows duplicate elements.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Collections.Queue&gt;</ph> aceita <ph id="ph2">`null`</ph> como um valor válido e permite elementos duplicados.</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Queue">
          <source>For the generic version of this collection, see <ph id="ph1">&lt;xref:System.Collections.Generic.Queue%601?displayProperty=nameWithType&gt;</ph></source>
          <target state="translated">Para obter a versão genérica dessa coleção, consulte <ph id="ph1">&lt;xref:System.Collections.Generic.Queue%601?displayProperty=nameWithType&gt;</ph></target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Queue">
          <source>The following example shows how to create and add values to a <ph id="ph1">&lt;xref:System.Collections.Queue&gt;</ph> and how to print out its values.</source>
          <target state="translated">O exemplo a seguir mostra como criar e adicionar valores para um <ph id="ph1">&lt;xref:System.Collections.Queue&gt;</ph> e como imprimir seus valores.</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Queue">
          <source>Public static (<ph id="ph1">&lt;see langword="Shared" /&gt;</ph> in Visual Basic) members of this type are thread safe.</source>
          <target state="translated">Os membros estáticos públicos (<ph id="ph1">&lt;see langword="Shared" /&gt;</ph> no Visual Basic) desse são thread-safe.</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Queue">
          <source>Any instance members are not guaranteed to be thread safe.</source>
          <target state="translated">Não há garantia de que qualquer membro de instância seja thread-safe.</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Queue">
          <source>To guarantee the thread safety of the <ph id="ph1">&lt;see cref="T:System.Collections.Queue" /&gt;</ph>, all operations must be done through the wrapper returned by the <ph id="ph2">&lt;see cref="M:System.Collections.Queue.Synchronized(System.Collections.Queue)" /&gt;</ph> method.</source>
          <target state="translated">Para garantir a segurança de thread do <ph id="ph1">&lt;see cref="T:System.Collections.Queue" /&gt;</ph>, todas as operações devem ser feitas por meio do wrapper retornado pelo <ph id="ph2">&lt;see cref="M:System.Collections.Queue.Synchronized(System.Collections.Queue)" /&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Queue">
          <source>Enumerating through a collection is intrinsically not a thread-safe procedure.</source>
          <target state="translated">A enumeração por meio de uma coleção não é um procedimento thread-safe intrínseco.</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Queue">
          <source>Even when a collection is synchronized, other threads can still modify the collection, which causes the enumerator to throw an exception.</source>
          <target state="translated">Mesmo quando uma coleção está sincronizada, outros threads ainda podem modificar a coleção, o que faz o enumerador lançar uma exceção.</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Queue">
          <source>To guarantee thread safety during enumeration, you can either lock the collection during the entire enumeration or catch the exceptions resulting from changes made by other threads.</source>
          <target state="translated">Para garantir thread-safe durante a enumeração, é possível bloquear a coleção durante toda a enumeração ou verificar as exceções resultantes das alterações feitas por outros threads.</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve" uid="T:System.Collections.Queue">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Collections.Queue" /&gt;</ph> class.</source>
          
        </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve" uid="M:System.Collections.Queue.#ctor">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Collections.Queue" /&gt;</ph> class that is empty, has the default initial capacity, and uses the default growth factor.</source>
          
        </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Queue.#ctor">
          <source>The capacity of a <ph id="ph1">&lt;xref:System.Collections.Queue&gt;</ph> is the number of elements the <ph id="ph2">&lt;xref:System.Collections.Queue&gt;</ph> can hold.</source>
          <target state="translated">A capacidade de um <ph id="ph1">&lt;xref:System.Collections.Queue&gt;</ph> é o número de elementos de <ph id="ph2">&lt;xref:System.Collections.Queue&gt;</ph> pode conter.</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Queue.#ctor">
          <source>As elements are added to a <ph id="ph1">&lt;xref:System.Collections.Queue&gt;</ph>, the capacity is automatically increased as required through reallocation.</source>
          <target state="translated">Como os elementos são adicionados a um <ph id="ph1">&lt;xref:System.Collections.Queue&gt;</ph>, a capacidade é aumentada automaticamente conforme necessário por meio de realocação.</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Queue.#ctor">
          <source>The capacity can be decreased by calling <ph id="ph1">&lt;xref:System.Collections.Queue.TrimToSize%2A&gt;</ph>.</source>
          <target state="translated">A capacidade pode ser diminuída chamando <ph id="ph1">&lt;xref:System.Collections.Queue.TrimToSize%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Queue.#ctor">
          <source>The growth factor is the number by which the current capacity is multiplied when a greater capacity is required.</source>
          <target state="translated">O fator de crescimento é o número pelo qual a capacidade atual é multiplicada quando for necessária uma maior capacidade.</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Queue.#ctor">
          <source>The growth factor is determined when the <ph id="ph1">&lt;xref:System.Collections.Queue&gt;</ph> is constructed.</source>
          <target state="translated">O fator de crescimento é determinado quando o <ph id="ph1">&lt;xref:System.Collections.Queue&gt;</ph> é construído.</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Queue.#ctor">
          <source>This constructor is an O(1) operation.</source>
          <target state="translated">Este construtor é uma operação O(1).</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve" uid="M:System.Collections.Queue.#ctor(System.Collections.ICollection)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.ICollection" /&gt;</ph> to copy elements from.</source>
          
        </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve" uid="M:System.Collections.Queue.#ctor(System.Collections.ICollection)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Collections.Queue" /&gt;</ph> class that contains elements copied from the specified collection, has the same initial capacity as the number of elements copied, and uses the default growth factor.</source>
          
        </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Queue.#ctor(System.Collections.ICollection)">
          <source>The capacity of a <ph id="ph1">&lt;xref:System.Collections.Queue&gt;</ph> is the number of elements the <ph id="ph2">&lt;xref:System.Collections.Queue&gt;</ph> can hold.</source>
          <target state="translated">A capacidade de um <ph id="ph1">&lt;xref:System.Collections.Queue&gt;</ph> é o número de elementos de <ph id="ph2">&lt;xref:System.Collections.Queue&gt;</ph> pode conter.</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Queue.#ctor(System.Collections.ICollection)">
          <source>As elements are added to a <ph id="ph1">&lt;xref:System.Collections.Queue&gt;</ph>, the capacity is automatically increased as required through reallocation.</source>
          <target state="translated">Como os elementos são adicionados a um <ph id="ph1">&lt;xref:System.Collections.Queue&gt;</ph>, a capacidade é aumentada automaticamente conforme necessário por meio de realocação.</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Queue.#ctor(System.Collections.ICollection)">
          <source>The capacity can be decreased by calling <ph id="ph1">&lt;xref:System.Collections.Queue.TrimToSize%2A&gt;</ph>.</source>
          <target state="translated">A capacidade pode ser diminuída chamando <ph id="ph1">&lt;xref:System.Collections.Queue.TrimToSize%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Queue.#ctor(System.Collections.ICollection)">
          <source>The growth factor is the number by which the current capacity is multiplied when a greater capacity is required.</source>
          <target state="translated">O fator de crescimento é o número pelo qual a capacidade atual é multiplicada quando for necessária uma maior capacidade.</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Queue.#ctor(System.Collections.ICollection)">
          <source>The growth factor is determined when the <ph id="ph1">&lt;xref:System.Collections.Queue&gt;</ph> is constructed.</source>
          <target state="translated">O fator de crescimento é determinado quando o <ph id="ph1">&lt;xref:System.Collections.Queue&gt;</ph> é construído.</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Queue.#ctor(System.Collections.ICollection)">
          <source>The elements are copied onto the <ph id="ph1">&lt;xref:System.Collections.Queue&gt;</ph> in the same order they are read by the <ph id="ph2">&lt;xref:System.Collections.IEnumerator&gt;</ph> of the <ph id="ph3">&lt;xref:System.Collections.ICollection&gt;</ph>.</source>
          <target state="translated">Os elementos são copiados para o <ph id="ph1">&lt;xref:System.Collections.Queue&gt;</ph> na mesma ordem em que são lidas pelo <ph id="ph2">&lt;xref:System.Collections.IEnumerator&gt;</ph> do <ph id="ph3">&lt;xref:System.Collections.ICollection&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Queue.#ctor(System.Collections.ICollection)">
          <source>This constructor is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is the number of elements in <ph id="ph3">`col`</ph>.</source>
          <target state="translated">Este construtor é um O (<ph id="ph1">`n`</ph>) operação, onde <ph id="ph2">`n`</ph> é o número de elementos em <ph id="ph3">`col`</ph>.</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve" uid="M:System.Collections.Queue.#ctor(System.Collections.ICollection)">
          <source><ph id="ph1">&lt;paramref name="col" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          
        </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve" uid="M:System.Collections.Queue.#ctor(System.Int32)">
          <source>The initial number of elements that the <ph id="ph1">&lt;see cref="T:System.Collections.Queue" /&gt;</ph> can contain.</source>
          
        </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve" uid="M:System.Collections.Queue.#ctor(System.Int32)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Collections.Queue" /&gt;</ph> class that is empty, has the specified initial capacity, and uses the default growth factor.</source>
          
        </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Queue.#ctor(System.Int32)">
          <source>The capacity of a <ph id="ph1">&lt;xref:System.Collections.Queue&gt;</ph> is the number of elements the <ph id="ph2">&lt;xref:System.Collections.Queue&gt;</ph> can hold.</source>
          <target state="translated">A capacidade de um <ph id="ph1">&lt;xref:System.Collections.Queue&gt;</ph> é o número de elementos de <ph id="ph2">&lt;xref:System.Collections.Queue&gt;</ph> pode conter.</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Queue.#ctor(System.Int32)">
          <source>As elements are added to a <ph id="ph1">&lt;xref:System.Collections.Queue&gt;</ph>, the capacity is automatically increased as required through reallocation.</source>
          <target state="translated">Como os elementos são adicionados a um <ph id="ph1">&lt;xref:System.Collections.Queue&gt;</ph>, a capacidade é aumentada automaticamente conforme necessário por meio de realocação.</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Queue.#ctor(System.Int32)">
          <source>The capacity can be decreased by calling <ph id="ph1">&lt;xref:System.Collections.Queue.TrimToSize%2A&gt;</ph>.</source>
          <target state="translated">A capacidade pode ser diminuída chamando <ph id="ph1">&lt;xref:System.Collections.Queue.TrimToSize%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Queue.#ctor(System.Int32)">
          <source>The growth factor is the number by which the current capacity is multiplied when a greater capacity is required.</source>
          <target state="translated">O fator de crescimento é o número pelo qual a capacidade atual é multiplicada quando for necessária uma maior capacidade.</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Queue.#ctor(System.Int32)">
          <source>The growth factor is determined when the <ph id="ph1">&lt;xref:System.Collections.Queue&gt;</ph> is constructed.</source>
          <target state="translated">O fator de crescimento é determinado quando o <ph id="ph1">&lt;xref:System.Collections.Queue&gt;</ph> é construído.</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Queue.#ctor(System.Int32)">
          <source>If the size of the collection can be estimated, specifying the initial capacity eliminates the need to perform a number of resizing operations while adding elements to the <ph id="ph1">&lt;xref:System.Collections.Queue&gt;</ph>.</source>
          <target state="translated">Se o tamanho da coleção pode ser estimado, especificando a capacidade inicial elimina a necessidade de executar um número de operações de redimensionamento durante a adição de elementos para o <ph id="ph1">&lt;xref:System.Collections.Queue&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Queue.#ctor(System.Int32)">
          <source>This constructor is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is <ph id="ph3">`capacity`</ph>.</source>
          <target state="translated">Este construtor é um O (<ph id="ph1">`n`</ph>) operação, onde <ph id="ph2">`n`</ph> é <ph id="ph3">`capacity`</ph>.</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve" uid="M:System.Collections.Queue.#ctor(System.Int32)">
          <source><ph id="ph1">&lt;paramref name="capacity" /&gt;</ph> is less than zero.</source>
          
        </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve" uid="M:System.Collections.Queue.#ctor(System.Int32,System.Single)">
          <source>The initial number of elements that the <ph id="ph1">&lt;see cref="T:System.Collections.Queue" /&gt;</ph> can contain.</source>
          
        </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve" uid="M:System.Collections.Queue.#ctor(System.Int32,System.Single)">
          <source>The factor by which the capacity of the <ph id="ph1">&lt;see cref="T:System.Collections.Queue" /&gt;</ph> is expanded.</source>
          
        </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve" uid="M:System.Collections.Queue.#ctor(System.Int32,System.Single)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Collections.Queue" /&gt;</ph> class that is empty, has the specified initial capacity, and uses the specified growth factor.</source>
          
        </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Queue.#ctor(System.Int32,System.Single)">
          <source>The capacity of a <ph id="ph1">&lt;xref:System.Collections.Queue&gt;</ph> is the number of elements the <ph id="ph2">&lt;xref:System.Collections.Queue&gt;</ph> can hold.</source>
          <target state="translated">A capacidade de um <ph id="ph1">&lt;xref:System.Collections.Queue&gt;</ph> é o número de elementos de <ph id="ph2">&lt;xref:System.Collections.Queue&gt;</ph> pode conter.</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Queue.#ctor(System.Int32,System.Single)">
          <source>As elements are added to a <ph id="ph1">&lt;xref:System.Collections.Queue&gt;</ph>, the capacity is automatically increased as required through reallocation.</source>
          <target state="translated">Como os elementos são adicionados a um <ph id="ph1">&lt;xref:System.Collections.Queue&gt;</ph>, a capacidade é aumentada automaticamente conforme necessário por meio de realocação.</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Queue.#ctor(System.Int32,System.Single)">
          <source>The capacity can be decreased by calling <ph id="ph1">&lt;xref:System.Collections.Queue.TrimToSize%2A&gt;</ph>.</source>
          <target state="translated">A capacidade pode ser diminuída chamando <ph id="ph1">&lt;xref:System.Collections.Queue.TrimToSize%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Queue.#ctor(System.Int32,System.Single)">
          <source>The growth factor is the number by which the current capacity is multiplied when a greater capacity is required.</source>
          <target state="translated">O fator de crescimento é o número pelo qual a capacidade atual é multiplicada quando for necessária uma maior capacidade.</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Queue.#ctor(System.Int32,System.Single)">
          <source>The growth factor is determined when the <ph id="ph1">&lt;xref:System.Collections.Queue&gt;</ph> is constructed.</source>
          <target state="translated">O fator de crescimento é determinado quando o <ph id="ph1">&lt;xref:System.Collections.Queue&gt;</ph> é construído.</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Queue.#ctor(System.Int32,System.Single)">
          <source>The capacity of the <ph id="ph1">&lt;xref:System.Collections.Queue&gt;</ph> will always increase by a minimum value, regardless of the growth factor; a growth factor of 1.0 will not prevent the <ph id="ph2">&lt;xref:System.Collections.Queue&gt;</ph> from increasing in size.</source>
          <target state="translated">A capacidade do <ph id="ph1">&lt;xref:System.Collections.Queue&gt;</ph> sempre será aumentado em um valor mínimo, independentemente do fator de crescimento; um fator de crescimento de 1.0 não impedirá o <ph id="ph2">&lt;xref:System.Collections.Queue&gt;</ph> de aumentarem de tamanho.</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Queue.#ctor(System.Int32,System.Single)">
          <source>If the size of the collection can be estimated, specifying the initial capacity eliminates the need to perform a number of resizing operations while adding elements to the <ph id="ph1">&lt;xref:System.Collections.Queue&gt;</ph>.</source>
          <target state="translated">Se o tamanho da coleção pode ser estimado, especificando a capacidade inicial elimina a necessidade de executar um número de operações de redimensionamento durante a adição de elementos para o <ph id="ph1">&lt;xref:System.Collections.Queue&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Queue.#ctor(System.Int32,System.Single)">
          <source>This constructor is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is <ph id="ph3">`capacity`</ph>.</source>
          <target state="translated">Este construtor é um O (<ph id="ph1">`n`</ph>) operação, onde <ph id="ph2">`n`</ph> é <ph id="ph3">`capacity`</ph>.</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve" uid="M:System.Collections.Queue.#ctor(System.Int32,System.Single)">
          <source><ph id="ph1">&lt;paramref name="capacity" /&gt;</ph> is less than zero.</source>
          
        </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve" uid="M:System.Collections.Queue.#ctor(System.Int32,System.Single)">
          <source>-or-</source>
          
        </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve" uid="M:System.Collections.Queue.#ctor(System.Int32,System.Single)">
          <source><ph id="ph1">&lt;paramref name="growFactor" /&gt;</ph> is less than 1.0 or greater than 10.0.</source>
          
        </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve" uid="M:System.Collections.Queue.Clear">
          <source>Removes all objects from the <ph id="ph1">&lt;see cref="T:System.Collections.Queue" /&gt;</ph>.</source>
          
        </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Queue.Clear">
          <source><ph id="ph1">&lt;xref:System.Collections.Queue.Count%2A&gt;</ph> is set to zero, and references to other objects from elements of the collection are also released.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Collections.Queue.Count%2A&gt;</ph> é definido como zero, e referências a outros objetos de elementos da coleção também são liberadas.</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Queue.Clear">
          <source>The capacity remains unchanged.</source>
          <target state="translated">A capacidade permanece inalterada.</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Queue.Clear">
          <source>To reset the capacity of the <ph id="ph1">&lt;xref:System.Collections.Queue&gt;</ph>, call <ph id="ph2">&lt;xref:System.Collections.Queue.TrimToSize%2A&gt;</ph>.</source>
          <target state="translated">Para redefinir a capacidade do <ph id="ph1">&lt;xref:System.Collections.Queue&gt;</ph>, chame <ph id="ph2">&lt;xref:System.Collections.Queue.TrimToSize%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Queue.Clear">
          <source>Trimming an empty <ph id="ph1">&lt;xref:System.Collections.Queue&gt;</ph> sets the capacity of the <ph id="ph2">&lt;xref:System.Collections.Queue&gt;</ph> to the default capacity.</source>
          <target state="translated">Cortar vazio <ph id="ph1">&lt;xref:System.Collections.Queue&gt;</ph> define a capacidade do <ph id="ph2">&lt;xref:System.Collections.Queue&gt;</ph> à capacidade padrão.</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Queue.Clear">
          <source>This method is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is <ph id="ph3">&lt;xref:System.Collections.Queue.Count%2A&gt;</ph>.</source>
          <target state="translated">Este método é uma operação O(<ph id="ph1">`n`</ph>), em que <ph id="ph2">`n`</ph> é <ph id="ph3">&lt;xref:System.Collections.Queue.Count%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Queue.Clear">
          <source>The following example shows how to clear the values of the <ph id="ph1">&lt;xref:System.Collections.Queue&gt;</ph>.</source>
          <target state="translated">O exemplo a seguir mostra como limpar os valores de <ph id="ph1">&lt;xref:System.Collections.Queue&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve" uid="M:System.Collections.Queue.Clone">
          <source>Creates a shallow copy of the <ph id="ph1">&lt;see cref="T:System.Collections.Queue" /&gt;</ph>.</source>
          
        </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve" uid="M:System.Collections.Queue.Clone">
          <source>A shallow copy of the <ph id="ph1">&lt;see cref="T:System.Collections.Queue" /&gt;</ph>.</source>
          
        </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Queue.Clone">
          <source>A shallow copy of a collection copies only the elements of the collection, whether they are reference types or value types, but it does not copy the objects that the references refer to.</source>
          <target state="translated">Uma cópia superficial de uma coleção copia apenas os elementos da coleção, se eles são tipos de referência ou tipos de valor, mas não copia os objetos que se referem as referências a.</target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Queue.Clone">
          <source>The references in the new collection point to the same objects that the references in the original collection point to.</source>
          <target state="translated">As referências na nova coleção apontam para os mesmos objetos que as referências na coleção original apontem para.</target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Queue.Clone">
          <source>In contrast, a deep copy of a collection copies the elements and everything directly or indirectly referenced by the elements.</source>
          <target state="translated">Em contraste, uma cópia profunda de uma coleção copia os elementos e tudo direta ou indiretamente referenciado por elementos.</target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Queue.Clone">
          <source>This method is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is <ph id="ph3">&lt;xref:System.Collections.Queue.Count%2A&gt;</ph>.</source>
          <target state="translated">Este método é uma operação O(<ph id="ph1">`n`</ph>), em que <ph id="ph2">`n`</ph> é <ph id="ph3">&lt;xref:System.Collections.Queue.Count%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve" uid="M:System.Collections.Queue.Contains(System.Object)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Object" /&gt;</ph> to locate in the <ph id="ph2">&lt;see cref="T:System.Collections.Queue" /&gt;</ph>.</source>
          
        </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve" uid="M:System.Collections.Queue.Contains(System.Object)">
          <source>The value can be <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          
        </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve" uid="M:System.Collections.Queue.Contains(System.Object)">
          <source>Determines whether an element is in the <ph id="ph1">&lt;see cref="T:System.Collections.Queue" /&gt;</ph>.</source>
          
        </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve" uid="M:System.Collections.Queue.Contains(System.Object)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if <ph id="ph2">&lt;paramref name="obj" /&gt;</ph> is found in the <ph id="ph3">&lt;see cref="T:System.Collections.Queue" /&gt;</ph>; otherwise, <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</source>
          
        </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Queue.Contains(System.Object)">
          <source>This method determines equality by calling <ph id="ph1">&lt;xref:System.Object.Equals%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Este método determina a igualdade chamando <ph id="ph1">&lt;xref:System.Object.Equals%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Queue.Contains(System.Object)">
          <source>This method performs a linear search; therefore, this method is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is <ph id="ph3">&lt;xref:System.Collections.Queue.Count%2A&gt;</ph>.</source>
          <target state="translated">Este método executa uma pesquisa linear; por isso, esse método é uma operação O(<ph id="ph1">`n`</ph>), em que <ph id="ph2">`n`</ph> é <ph id="ph3">&lt;xref:System.Collections.Queue.Count%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Queue.Contains(System.Object)">
          <source>Starting with the .NET Framework 2.0, this method uses the collection’s objects’ <ph id="ph1">&lt;xref:System.Object.Equals%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.IComparable.CompareTo%2A&gt;</ph> methods on <ph id="ph3">`obj`</ph> to determine whether <ph id="ph4">`item`</ph> exists.</source>
          <target state="translated">Começando com o .NET Framework 2.0, esse método usa objetos da coleção <ph id="ph1">&lt;xref:System.Object.Equals%2A&gt;</ph> e <ph id="ph2">&lt;xref:System.IComparable.CompareTo%2A&gt;</ph> métodos em <ph id="ph3">`obj`</ph> para determinar se <ph id="ph4">`item`</ph> existe.</target>       </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Queue.Contains(System.Object)">
          <source>In the earlier versions of the .NET Framework, this determination was made by using the <ph id="ph1">&lt;xref:System.Object.Equals%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.IComparable.CompareTo%2A&gt;</ph> methods of the <ph id="ph3">`obj`</ph> parameter on the objects in the collection.</source>
          <target state="translated">Em versões anteriores do .NET Framework, essa decisão era tomada usando-se os métodos <ph id="ph1">&lt;xref:System.Object.Equals%2A&gt;</ph> e <ph id="ph2">&lt;xref:System.IComparable.CompareTo%2A&gt;</ph> do parâmetro <ph id="ph3">`obj`</ph> nos objetos na coleção.</target>       </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve" uid="M:System.Collections.Queue.CopyTo(System.Array,System.Int32)">
          <source>The one-dimensional <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> that is the destination of the elements copied from <ph id="ph2">&lt;see cref="T:System.Collections.Queue" /&gt;</ph>.</source>
          
        </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve" uid="M:System.Collections.Queue.CopyTo(System.Array,System.Int32)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> must have zero-based indexing.</source>
          
        </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve" uid="M:System.Collections.Queue.CopyTo(System.Array,System.Int32)">
          <source>The zero-based index in <bpt id="p1">&lt;c&gt;</bpt>array<ept id="p1">&lt;/c&gt;</ept> at which copying begins.</source>
          
        </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve" uid="M:System.Collections.Queue.CopyTo(System.Array,System.Int32)">
          <source>Copies the <ph id="ph1">&lt;see cref="T:System.Collections.Queue" /&gt;</ph> elements to an existing one-dimensional <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph>, starting at the specified array index.</source>
          
        </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Queue.CopyTo(System.Array,System.Int32)">
          <source>The elements are copied to the <ph id="ph1">&lt;xref:System.Array&gt;</ph> in the same order in which the enumerator iterates through the <ph id="ph2">&lt;xref:System.Collections.Queue&gt;</ph>.</source>
          <target state="translated">Os elementos são copiados para o <ph id="ph1">&lt;xref:System.Array&gt;</ph> na mesma ordem em que o enumerador que itera por meio de <ph id="ph2">&lt;xref:System.Collections.Queue&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Queue.CopyTo(System.Array,System.Int32)">
          <source>This method is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is <ph id="ph3">&lt;xref:System.Collections.Queue.Count%2A&gt;</ph>.</source>
          <target state="translated">Este método é uma operação O(<ph id="ph1">`n`</ph>), em que <ph id="ph2">`n`</ph> é <ph id="ph3">&lt;xref:System.Collections.Queue.Count%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Queue.CopyTo(System.Array,System.Int32)">
          <source>The following example shows how to copy a <ph id="ph1">&lt;xref:System.Collections.Queue&gt;</ph> into a one-dimensional array.</source>
          <target state="translated">O exemplo a seguir mostra como copiar um <ph id="ph1">&lt;xref:System.Collections.Queue&gt;</ph> em uma matriz unidimensional.</target>       </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve" uid="M:System.Collections.Queue.CopyTo(System.Array,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="array" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          
        </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve" uid="M:System.Collections.Queue.CopyTo(System.Array,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="index" /&gt;</ph> is less than zero.</source>
          
        </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve" uid="M:System.Collections.Queue.CopyTo(System.Array,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="array" /&gt;</ph> is multidimensional.</source>
          
        </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve" uid="M:System.Collections.Queue.CopyTo(System.Array,System.Int32)">
          <source>-or-</source>
          
        </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve" uid="M:System.Collections.Queue.CopyTo(System.Array,System.Int32)">
          <source>The number of elements in the source <ph id="ph1">&lt;see cref="T:System.Collections.Queue" /&gt;</ph> is greater than the available space from <ph id="ph2">&lt;paramref name="index" /&gt;</ph> to the end of the destination <ph id="ph3">&lt;paramref name="array" /&gt;</ph>.</source>
          
        </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve" uid="M:System.Collections.Queue.CopyTo(System.Array,System.Int32)">
          <source>The type of the source <ph id="ph1">&lt;see cref="T:System.Collections.Queue" /&gt;</ph> cannot be cast automatically to the type of the destination <ph id="ph2">&lt;paramref name="array" /&gt;</ph>.</source>
          
        </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve" uid="P:System.Collections.Queue.Count">
          <source>Gets the number of elements contained in the <ph id="ph1">&lt;see cref="T:System.Collections.Queue" /&gt;</ph>.</source>
          
        </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.Queue.Count">
          <source>The number of elements contained in the <ph id="ph1">&lt;see cref="T:System.Collections.Queue" /&gt;</ph>.</source>
          <target state="translated">O número de elementos contidos no <ph id="ph1">&lt;see cref="T:System.Collections.Queue" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.Queue.Count">
          <source>The capacity of a <ph id="ph1">&lt;xref:System.Collections.Queue&gt;</ph> is the number of elements that the <ph id="ph2">&lt;xref:System.Collections.Queue&gt;</ph> can store.</source>
          <target state="translated">A capacidade de um <ph id="ph1">&lt;xref:System.Collections.Queue&gt;</ph> é o número de elementos que o <ph id="ph2">&lt;xref:System.Collections.Queue&gt;</ph> pode armazenar.</target>       </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.Queue.Count">
          <source><ph id="ph1">&lt;xref:System.Collections.Queue.Count%2A&gt;</ph> is the number of elements that are actually in the <ph id="ph2">&lt;xref:System.Collections.Queue&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Collections.Queue.Count%2A&gt;</ph> é o número de elementos que estão realmente no <ph id="ph2">&lt;xref:System.Collections.Queue&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.Queue.Count">
          <source>The capacity of a <ph id="ph1">&lt;xref:System.Collections.Queue&gt;</ph> is always greater than or equal to <ph id="ph2">&lt;xref:System.Collections.Queue.Count%2A&gt;</ph>.</source>
          <target state="translated">A capacidade de um <ph id="ph1">&lt;xref:System.Collections.Queue&gt;</ph> é sempre maior que ou igual a <ph id="ph2">&lt;xref:System.Collections.Queue.Count%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.Queue.Count">
          <source>If <ph id="ph1">&lt;xref:System.Collections.Queue.Count%2A&gt;</ph> exceeds the capacity while adding elements, the capacity is automatically increased by reallocating the internal array before copying the old elements and adding the new elements.</source>
          <target state="translated">Se <ph id="ph1">&lt;xref:System.Collections.Queue.Count%2A&gt;</ph> excede a capacidade durante a adição de elementos, a capacidade é aumentada automaticamente realocando a matriz interna antes de copiar os elementos antigos e adição de novos elementos.</target>       </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.Queue.Count">
          <source>The new capacity is determined by multiplying the current capacity by the growth factor, which is determined when the <ph id="ph1">&lt;xref:System.Collections.Queue&gt;</ph> is constructed.</source>
          <target state="translated">A nova capacidade é determinada multiplicando a capacidade atual pelo fator de crescimento, o que é determinado quando o <ph id="ph1">&lt;xref:System.Collections.Queue&gt;</ph> é construído.</target>       </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.Queue.Count">
          <source>The capacity of the <ph id="ph1">&lt;xref:System.Collections.Queue&gt;</ph> will always increase by a minimum value, regardless of the growth factor; a growth factor of 1.0 will not prevent the <ph id="ph2">&lt;xref:System.Collections.Queue&gt;</ph> from increasing in size.</source>
          <target state="translated">A capacidade do <ph id="ph1">&lt;xref:System.Collections.Queue&gt;</ph> sempre será aumentado em um valor mínimo, independentemente do fator de crescimento; um fator de crescimento de 1.0 não impedirá o <ph id="ph2">&lt;xref:System.Collections.Queue&gt;</ph> de aumentarem de tamanho.</target>       </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.Queue.Count">
          <source>The capacity can be decreased by calling <ph id="ph1">&lt;xref:System.Collections.Queue.TrimToSize%2A&gt;</ph>.</source>
          <target state="translated">A capacidade pode ser diminuída chamando <ph id="ph1">&lt;xref:System.Collections.Queue.TrimToSize%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.Queue.Count">
          <source>Retrieving the value of this property is an O(1) operation.</source>
          <target state="translated">A recuperação do valor dessa propriedade é uma operação O(1).</target>       </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve" uid="M:System.Collections.Queue.Dequeue">
          <source>Removes and returns the object at the beginning of the <ph id="ph1">&lt;see cref="T:System.Collections.Queue" /&gt;</ph>.</source>
          
        </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve" uid="M:System.Collections.Queue.Dequeue">
          <source>The object that is removed from the beginning of the <ph id="ph1">&lt;see cref="T:System.Collections.Queue" /&gt;</ph>.</source>
          
        </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Queue.Dequeue">
          <source>This method is similar to the <ph id="ph1">&lt;xref:System.Collections.Queue.Peek%2A&gt;</ph> method, but <ph id="ph2">&lt;xref:System.Collections.Queue.Peek%2A&gt;</ph> does not modify the <ph id="ph3">&lt;xref:System.Collections.Queue&gt;</ph>.</source>
          <target state="translated">Esse método é semelhante do <ph id="ph1">&lt;xref:System.Collections.Queue.Peek%2A&gt;</ph> método, mas <ph id="ph2">&lt;xref:System.Collections.Queue.Peek%2A&gt;</ph> não modifica o <ph id="ph3">&lt;xref:System.Collections.Queue&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Queue.Dequeue">
          <source><ph id="ph1">`null`</ph> can be added to the <ph id="ph2">&lt;xref:System.Collections.Queue&gt;</ph> as a value.</source>
          <target state="translated"><ph id="ph1">`null`</ph> podem ser adicionados para o <ph id="ph2">&lt;xref:System.Collections.Queue&gt;</ph> como um valor.</target>       </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Queue.Dequeue">
          <source>To distinguish between a null value and the end of the <ph id="ph1">&lt;xref:System.Collections.Queue&gt;</ph>, check the <ph id="ph2">&lt;xref:System.Collections.Queue.Count%2A&gt;</ph> property or catch the <ph id="ph3">&lt;xref:System.InvalidOperationException&gt;</ph>, which is thrown when the <ph id="ph4">&lt;xref:System.Collections.Queue&gt;</ph> is empty.</source>
          <target state="translated">Para distinguir entre um valor nulo e o término do <ph id="ph1">&lt;xref:System.Collections.Queue&gt;</ph>, verifique o <ph id="ph2">&lt;xref:System.Collections.Queue.Count%2A&gt;</ph> propriedade ou catch o <ph id="ph3">&lt;xref:System.InvalidOperationException&gt;</ph>, que é gerado quando o <ph id="ph4">&lt;xref:System.Collections.Queue&gt;</ph> está vazio.</target>       </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Queue.Dequeue">
          <source>This method is an O(1) operation.</source>
          <target state="translated">Este método é uma operação O(1).</target>       </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Queue.Dequeue">
          <source>The following example shows how to add elements to the <ph id="ph1">&lt;xref:System.Collections.Queue&gt;</ph>, remove elements from the <ph id="ph2">&lt;xref:System.Collections.Queue&gt;</ph>, or view the element at the beginning of the <ph id="ph3">&lt;xref:System.Collections.Queue&gt;</ph>.</source>
          <target state="translated">O exemplo a seguir mostra como adicionar elementos para o <ph id="ph1">&lt;xref:System.Collections.Queue&gt;</ph>, remover elementos do <ph id="ph2">&lt;xref:System.Collections.Queue&gt;</ph>, ou exibir o elemento no início do <ph id="ph3">&lt;xref:System.Collections.Queue&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve" uid="M:System.Collections.Queue.Dequeue">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.Queue" /&gt;</ph> is empty.</source>
          
        </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve" uid="M:System.Collections.Queue.Enqueue(System.Object)">
          <source>The object to add to the <ph id="ph1">&lt;see cref="T:System.Collections.Queue" /&gt;</ph>.</source>
          
        </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve" uid="M:System.Collections.Queue.Enqueue(System.Object)">
          <source>The value can be <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          
        </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve" uid="M:System.Collections.Queue.Enqueue(System.Object)">
          <source>Adds an object to the end of the <ph id="ph1">&lt;see cref="T:System.Collections.Queue" /&gt;</ph>.</source>
          
        </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Queue.Enqueue(System.Object)">
          <source>The capacity of a <ph id="ph1">&lt;xref:System.Collections.Queue&gt;</ph> is the number of elements the <ph id="ph2">&lt;xref:System.Collections.Queue&gt;</ph> can hold.</source>
          <target state="translated">A capacidade de um <ph id="ph1">&lt;xref:System.Collections.Queue&gt;</ph> é o número de elementos de <ph id="ph2">&lt;xref:System.Collections.Queue&gt;</ph> pode conter.</target>       </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Queue.Enqueue(System.Object)">
          <source>As elements are added to a <ph id="ph1">&lt;xref:System.Collections.Queue&gt;</ph>, the capacity is automatically increased as required through reallocation.</source>
          <target state="translated">Como os elementos são adicionados a um <ph id="ph1">&lt;xref:System.Collections.Queue&gt;</ph>, a capacidade é aumentada automaticamente conforme necessário por meio de realocação.</target>       </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Queue.Enqueue(System.Object)">
          <source>The capacity can be decreased by calling <ph id="ph1">&lt;xref:System.Collections.Queue.TrimToSize%2A&gt;</ph>.</source>
          <target state="translated">A capacidade pode ser diminuída chamando <ph id="ph1">&lt;xref:System.Collections.Queue.TrimToSize%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Queue.Enqueue(System.Object)">
          <source>The growth factor is the number by which the current capacity is multiplied when a greater capacity is required.</source>
          <target state="translated">O fator de crescimento é o número pelo qual a capacidade atual é multiplicada quando for necessária uma maior capacidade.</target>       </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Queue.Enqueue(System.Object)">
          <source>The growth factor is determined when the <ph id="ph1">&lt;xref:System.Collections.Queue&gt;</ph> is constructed.</source>
          <target state="translated">O fator de crescimento é determinado quando o <ph id="ph1">&lt;xref:System.Collections.Queue&gt;</ph> é construído.</target>       </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Queue.Enqueue(System.Object)">
          <source>The capacity of the <ph id="ph1">&lt;xref:System.Collections.Queue&gt;</ph> will always increase by a minimum value, regardless of the growth factor; a growth factor of 1.0 will not prevent the <ph id="ph2">&lt;xref:System.Collections.Queue&gt;</ph> from increasing in size.</source>
          <target state="translated">A capacidade do <ph id="ph1">&lt;xref:System.Collections.Queue&gt;</ph> sempre será aumentado em um valor mínimo, independentemente do fator de crescimento; um fator de crescimento de 1.0 não impedirá o <ph id="ph2">&lt;xref:System.Collections.Queue&gt;</ph> de aumentarem de tamanho.</target>       </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Queue.Enqueue(System.Object)">
          <source>If <ph id="ph1">&lt;xref:System.Collections.Queue.Count%2A&gt;</ph> is less than the capacity of the internal array, this method is an O(1) operation.</source>
          <target state="translated">Se <ph id="ph1">&lt;xref:System.Collections.Queue.Count%2A&gt;</ph> é menor que a capacidade da matriz interna, esse método é uma operação de (1).</target>       </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Queue.Enqueue(System.Object)">
          <source>If the internal array needs to be reallocated to accommodate the new element, this method becomes an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is <ph id="ph3">&lt;xref:System.Collections.Queue.Count%2A&gt;</ph>.</source>
          <target state="translated">Se a matriz interna precisa ser realocada para acomodar o novo elemento, esse método se torna um O (<ph id="ph1">`n`</ph>) operação, onde <ph id="ph2">`n`</ph> é <ph id="ph3">&lt;xref:System.Collections.Queue.Count%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Queue.Enqueue(System.Object)">
          <source>The following example shows how to add elements to the <ph id="ph1">&lt;xref:System.Collections.Queue&gt;</ph>, remove elements from the <ph id="ph2">&lt;xref:System.Collections.Queue&gt;</ph>, or view the element at the beginning of the <ph id="ph3">&lt;xref:System.Collections.Queue&gt;</ph>.</source>
          <target state="translated">O exemplo a seguir mostra como adicionar elementos para o <ph id="ph1">&lt;xref:System.Collections.Queue&gt;</ph>, remover elementos do <ph id="ph2">&lt;xref:System.Collections.Queue&gt;</ph>, ou exibir o elemento no início do <ph id="ph3">&lt;xref:System.Collections.Queue&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve" uid="M:System.Collections.Queue.GetEnumerator">
          <source>Returns an enumerator that iterates through the <ph id="ph1">&lt;see cref="T:System.Collections.Queue" /&gt;</ph>.</source>
          
        </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve" uid="M:System.Collections.Queue.GetEnumerator">
          <source>An <ph id="ph1">&lt;see cref="T:System.Collections.IEnumerator" /&gt;</ph> for the <ph id="ph2">&lt;see cref="T:System.Collections.Queue" /&gt;</ph>.</source>
          
        </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Queue.GetEnumerator">
          <source>The <ph id="ph1">`foreach`</ph> statement of the C# language (<ph id="ph2">`for each`</ph> in Visual Basic) hides the complexity of the enumerators.</source>
          <target state="translated">O <ph id="ph1">`foreach`</ph> instrução de linguagem c# (<ph id="ph2">`for each`</ph> no Visual Basic) oculta a complexidade dos enumeradores.</target>       </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Queue.GetEnumerator">
          <source>Therefore, using <ph id="ph1">`foreach`</ph> is recommended, instead of directly manipulating the enumerator.</source>
          <target state="translated">Portanto, o uso de <ph id="ph1">`foreach`</ph> é recomendado, em vez de manipular diretamente o enumerador.</target>       </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Queue.GetEnumerator">
          <source>Enumerators can be used to read the data in the collection, but they cannot be used to modify the underlying collection.</source>
          <target state="translated">Os enumeradores podem ser usados para ler os dados na coleção, mas não podem ser usados para modificar a coleção subjacente.</target>       </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Queue.GetEnumerator">
          <source>Initially, the enumerator is positioned before the first element in the collection.</source>
          <target state="translated">Inicialmente, o enumerador é posicionado antes do primeiro elemento da coleção.</target>       </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Queue.GetEnumerator">
          <source><ph id="ph1">&lt;xref:System.Collections.IEnumerator.Reset%2A&gt;</ph> also brings the enumerator back to this position.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Collections.IEnumerator.Reset%2A&gt;</ph> também traz o enumerador de volta para essa posição.</target>       </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Queue.GetEnumerator">
          <source>At this position, <ph id="ph1">&lt;xref:System.Collections.IEnumerator.Current%2A&gt;</ph> is undefined.</source>
          <target state="translated">Nesta posição, <ph id="ph1">&lt;xref:System.Collections.IEnumerator.Current%2A&gt;</ph> está indefinido.</target>       </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Queue.GetEnumerator">
          <source>Therefore, you must call <ph id="ph1">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> to advance the enumerator to the first element of the collection before reading the value of <ph id="ph2">&lt;xref:System.Collections.IEnumerator.Current%2A&gt;</ph>.</source>
          <target state="translated">Por isso, você deve chamar <ph id="ph1">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> para avançar o enumerador até o primeiro elemento da coleção antes de ler o valor de <ph id="ph2">&lt;xref:System.Collections.IEnumerator.Current%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Queue.GetEnumerator">
          <source><ph id="ph1">&lt;xref:System.Collections.IEnumerator.Current%2A&gt;</ph> returns the same object until either <ph id="ph2">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> or <ph id="ph3">&lt;xref:System.Collections.IEnumerator.Reset%2A&gt;</ph> is called.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Collections.IEnumerator.Current%2A&gt;</ph> retorna o mesmo objeto até <ph id="ph2">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> ou <ph id="ph3">&lt;xref:System.Collections.IEnumerator.Reset%2A&gt;</ph> ser chamado.</target>       </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Queue.GetEnumerator">
          <source><ph id="ph1">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> sets <ph id="ph2">&lt;xref:System.Collections.IEnumerator.Current%2A&gt;</ph> to the next element.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> define <ph id="ph2">&lt;xref:System.Collections.IEnumerator.Current%2A&gt;</ph> como o próximo elemento.</target>       </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Queue.GetEnumerator">
          <source>If <ph id="ph1">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> passes the end of the collection, the enumerator is positioned after the last element in the collection and <ph id="ph2">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> returns <ph id="ph3">`false`</ph>.</source>
          <target state="translated">Caso <ph id="ph1">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> passe o final da coleção, o enumerador é posicionado após o último elemento na coleção e <ph id="ph2">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> retorna <ph id="ph3">`false`</ph>.</target>       </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Queue.GetEnumerator">
          <source>When the enumerator is at this position, subsequent calls to <ph id="ph1">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> also return <ph id="ph2">`false`</ph>.</source>
          <target state="translated">Quando o enumerador está nessa posição, as chamadas subsequentes para <ph id="ph1">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> também retornam <ph id="ph2">`false`</ph>.</target>       </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Queue.GetEnumerator">
          <source>If the last call to <ph id="ph1">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> returned <ph id="ph2">`false`</ph>, <ph id="ph3">&lt;xref:System.Collections.IEnumerator.Current%2A&gt;</ph> is undefined.</source>
          <target state="translated">Caso a última chamada para <ph id="ph1">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> tenha retornado <ph id="ph2">`false`</ph>, <ph id="ph3">&lt;xref:System.Collections.IEnumerator.Current%2A&gt;</ph> está indefinido.</target>       </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Queue.GetEnumerator">
          <source>To set <ph id="ph1">&lt;xref:System.Collections.IEnumerator.Current%2A&gt;</ph> to the first element of the collection again, you can call <ph id="ph2">&lt;xref:System.Collections.IEnumerator.Reset%2A&gt;</ph> followed by <ph id="ph3">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph>.</source>
          <target state="translated">Para definir <ph id="ph1">&lt;xref:System.Collections.IEnumerator.Current%2A&gt;</ph> como o primeiro elemento da coleção novamente, é possível chamar <ph id="ph2">&lt;xref:System.Collections.IEnumerator.Reset%2A&gt;</ph> seguido de <ph id="ph3">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Queue.GetEnumerator">
          <source>An enumerator remains valid as long as the collection remains unchanged.</source>
          <target state="translated">Um enumerador permanece válido desde que a coleção continue inalterada.</target>       </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Queue.GetEnumerator">
          <source>If changes are made to the collection, such as adding, modifying, or deleting elements, the enumerator is irrecoverably invalidated and its behavior is undefined.</source>
          <target state="translated">Se forem feitas alterações na coleção, como adicionar, modificar ou excluir elementos, o enumerador será invalidado de maneira irrevogável e seu comportamento permanecerá indefinido.</target>       </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Queue.GetEnumerator">
          <source>The enumerator does not have exclusive access to the collection; therefore, enumerating through a collection is intrinsically not a thread-safe procedure.</source>
          <target state="translated">O enumerador não tem acesso exclusivo à coleção; por isso, a enumeração por meio de uma coleção não é um procedimento thread-safe intrínseco.</target>       </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Queue.GetEnumerator">
          <source>To guarantee thread safety during enumeration, you can lock the collection during the entire enumeration.</source>
          <target state="translated">Para garantir acesso thread-safe durante a enumeração, é possível bloquear a coleção durante toda a enumeração.</target>       </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Queue.GetEnumerator">
          <source>To allow the collection to be accessed by multiple threads for reading and writing, you must implement your own synchronization.</source>
          <target state="translated">Para permitir que a coleção a ser acessado por vários threads para leitura e gravação, você deve implementar sua sincronização.</target>       </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Queue.GetEnumerator">
          <source>This method is an O(1) operation.</source>
          <target state="translated">Este método é uma operação O(1).</target>       </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve" uid="P:System.Collections.Queue.IsSynchronized">
          <source>Gets a value indicating whether access to the <ph id="ph1">&lt;see cref="T:System.Collections.Queue" /&gt;</ph> is synchronized (thread safe).</source>
          
        </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.Queue.IsSynchronized">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if access to the <ph id="ph2">&lt;see cref="T:System.Collections.Queue" /&gt;</ph> is synchronized (thread safe); otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> caso o acesso ao <ph id="ph2">&lt;see cref="T:System.Collections.Queue" /&gt;</ph> seja sincronizado (thread-safe); do contrário, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.Queue.IsSynchronized">
          <source>The default is <ph id="ph1">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">O padrão é <ph id="ph1">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.Queue.IsSynchronized">
          <source>To guarantee the thread safety of the <ph id="ph1">&lt;xref:System.Collections.Queue&gt;</ph>, all operations must be done through the wrapper returned by the <ph id="ph2">&lt;xref:System.Collections.Queue.Synchronized%2A&gt;</ph> method.</source>
          <target state="translated">Para garantir a segurança de thread do <ph id="ph1">&lt;xref:System.Collections.Queue&gt;</ph>, todas as operações devem ser feitas por meio do wrapper retornado pelo <ph id="ph2">&lt;xref:System.Collections.Queue.Synchronized%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="260" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.Queue.IsSynchronized">
          <source>Enumerating through a collection is intrinsically not a thread-safe procedure.</source>
          <target state="translated">A enumeração por meio de uma coleção não é um procedimento thread-safe intrínseco.</target>       </trans-unit>
        <trans-unit id="261" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.Queue.IsSynchronized">
          <source>Even when a collection is synchronized, other threads can still modify the collection, which causes the enumerator to throw an exception.</source>
          <target state="translated">Mesmo quando uma coleção está sincronizada, outros threads ainda podem modificar a coleção, o que faz o enumerador lançar uma exceção.</target>       </trans-unit>
        <trans-unit id="262" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.Queue.IsSynchronized">
          <source>To guarantee thread safety during enumeration, you can either lock the collection during the entire enumeration or catch the exceptions resulting from changes made by other threads.</source>
          <target state="translated">Para garantir thread-safe durante a enumeração, é possível bloquear a coleção durante toda a enumeração ou verificar as exceções resultantes das alterações feitas por outros threads.</target>       </trans-unit>
        <trans-unit id="263" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.Queue.IsSynchronized">
          <source>The following code example shows how to lock the collection using the <ph id="ph1">&lt;xref:System.Collections.Queue.SyncRoot%2A&gt;</ph> during the entire enumeration.</source>
          <target state="translated">O exemplo de código a seguir mostra como bloquear a coleção usando o <ph id="ph1">&lt;xref:System.Collections.Queue.SyncRoot%2A&gt;</ph> durante toda a enumeração.</target>       </trans-unit>
        <trans-unit id="264" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.Queue.IsSynchronized">
          <source>Retrieving the value of this property is an O(1) operation.</source>
          <target state="translated">A recuperação do valor dessa propriedade é uma operação O(1).</target>       </trans-unit>
        <trans-unit id="265" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.Queue.IsSynchronized">
          <source>The following example shows how to synchronize a <ph id="ph1">&lt;xref:System.Collections.Queue&gt;</ph>, determine if a <ph id="ph2">&lt;xref:System.Collections.Queue&gt;</ph> is synchronized, and use a synchronized <ph id="ph3">&lt;xref:System.Collections.Queue&gt;</ph>.</source>
          <target state="translated">O exemplo a seguir mostra como sincronizar um <ph id="ph1">&lt;xref:System.Collections.Queue&gt;</ph>, determinar se um <ph id="ph2">&lt;xref:System.Collections.Queue&gt;</ph> está sincronizado e usar um sincronizado <ph id="ph3">&lt;xref:System.Collections.Queue&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="266" translate="yes" xml:space="preserve" uid="M:System.Collections.Queue.Peek">
          <source>Returns the object at the beginning of the <ph id="ph1">&lt;see cref="T:System.Collections.Queue" /&gt;</ph> without removing it.</source>
          
        </trans-unit>
        <trans-unit id="267" translate="yes" xml:space="preserve" uid="M:System.Collections.Queue.Peek">
          <source>The object at the beginning of the <ph id="ph1">&lt;see cref="T:System.Collections.Queue" /&gt;</ph>.</source>
          
        </trans-unit>
        <trans-unit id="268" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Queue.Peek">
          <source>This method is similar to the <ph id="ph1">&lt;xref:System.Collections.Queue.Dequeue%2A&gt;</ph> method, but <ph id="ph2">&lt;xref:System.Collections.Queue.Peek%2A&gt;</ph> does not modify the <ph id="ph3">&lt;xref:System.Collections.Queue&gt;</ph>.</source>
          <target state="translated">Esse método é semelhante do <ph id="ph1">&lt;xref:System.Collections.Queue.Dequeue%2A&gt;</ph> método, mas <ph id="ph2">&lt;xref:System.Collections.Queue.Peek%2A&gt;</ph> não modifica o <ph id="ph3">&lt;xref:System.Collections.Queue&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="269" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Queue.Peek">
          <source><ph id="ph1">`null`</ph> can be added to the <ph id="ph2">&lt;xref:System.Collections.Queue&gt;</ph> as a value.</source>
          <target state="translated"><ph id="ph1">`null`</ph> podem ser adicionados para o <ph id="ph2">&lt;xref:System.Collections.Queue&gt;</ph> como um valor.</target>       </trans-unit>
        <trans-unit id="270" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Queue.Peek">
          <source>To distinguish between a null value and the end of the <ph id="ph1">&lt;xref:System.Collections.Queue&gt;</ph>, check the <ph id="ph2">&lt;xref:System.Collections.Queue.Count%2A&gt;</ph> property or catch the <ph id="ph3">&lt;xref:System.InvalidOperationException&gt;</ph>, which is thrown when the <ph id="ph4">&lt;xref:System.Collections.Queue&gt;</ph> is empty.</source>
          <target state="translated">Para distinguir entre um valor nulo e o término do <ph id="ph1">&lt;xref:System.Collections.Queue&gt;</ph>, verifique o <ph id="ph2">&lt;xref:System.Collections.Queue.Count%2A&gt;</ph> propriedade ou catch o <ph id="ph3">&lt;xref:System.InvalidOperationException&gt;</ph>, que é gerado quando o <ph id="ph4">&lt;xref:System.Collections.Queue&gt;</ph> está vazio.</target>       </trans-unit>
        <trans-unit id="271" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Queue.Peek">
          <source>This method is an O(1) operation.</source>
          <target state="translated">Este método é uma operação O(1).</target>       </trans-unit>
        <trans-unit id="272" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Queue.Peek">
          <source>The following example shows how to add elements to the <ph id="ph1">&lt;xref:System.Collections.Queue&gt;</ph>, remove elements from the <ph id="ph2">&lt;xref:System.Collections.Queue&gt;</ph>, or view the element at the beginning of the <ph id="ph3">&lt;xref:System.Collections.Queue&gt;</ph>.</source>
          <target state="translated">O exemplo a seguir mostra como adicionar elementos para o <ph id="ph1">&lt;xref:System.Collections.Queue&gt;</ph>, remover elementos do <ph id="ph2">&lt;xref:System.Collections.Queue&gt;</ph>, ou exibir o elemento no início do <ph id="ph3">&lt;xref:System.Collections.Queue&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="273" translate="yes" xml:space="preserve" uid="M:System.Collections.Queue.Peek">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.Queue" /&gt;</ph> is empty.</source>
          
        </trans-unit>
        <trans-unit id="274" translate="yes" xml:space="preserve" uid="M:System.Collections.Queue.Synchronized(System.Collections.Queue)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.Queue" /&gt;</ph> to synchronize.</source>
          
        </trans-unit>
        <trans-unit id="275" translate="yes" xml:space="preserve" uid="M:System.Collections.Queue.Synchronized(System.Collections.Queue)">
          <source>Returns a new <ph id="ph1">&lt;see cref="T:System.Collections.Queue" /&gt;</ph> that wraps the original queue, and is thread safe.</source>
          
        </trans-unit>
        <trans-unit id="276" translate="yes" xml:space="preserve" uid="M:System.Collections.Queue.Synchronized(System.Collections.Queue)">
          <source>A <ph id="ph1">&lt;see cref="T:System.Collections.Queue" /&gt;</ph> wrapper that is synchronized (thread safe).</source>
          
        </trans-unit>
        <trans-unit id="277" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Queue.Synchronized(System.Collections.Queue)">
          <source>The wrapper returned by this method locks the queue before an operation is performed so that it is performed in a thread-safe manner.</source>
          <target state="translated">O wrapper retornado por este método bloqueia a fila antes de uma operação é executada de forma que ele é executado em uma forma thread-safe.</target>       </trans-unit>
        <trans-unit id="278" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Queue.Synchronized(System.Collections.Queue)">
          <source>To guarantee the thread safety of the <ph id="ph1">&lt;xref:System.Collections.Queue&gt;</ph>, all operations must be done through this wrapper only.</source>
          <target state="translated">Para garantir a segurança de thread do <ph id="ph1">&lt;xref:System.Collections.Queue&gt;</ph>, todas as operações devem ser feitas por meio de apenas esse wrapper.</target>       </trans-unit>
        <trans-unit id="279" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Queue.Synchronized(System.Collections.Queue)">
          <source>Enumerating through a collection is intrinsically not a thread-safe procedure.</source>
          <target state="translated">A enumeração por meio de uma coleção não é um procedimento thread-safe intrínseco.</target>       </trans-unit>
        <trans-unit id="280" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Queue.Synchronized(System.Collections.Queue)">
          <source>Even when a collection is synchronized, other threads can still modify the collection, which causes the enumerator to throw an exception.</source>
          <target state="translated">Mesmo quando uma coleção está sincronizada, outros threads ainda podem modificar a coleção, o que faz o enumerador lançar uma exceção.</target>       </trans-unit>
        <trans-unit id="281" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Queue.Synchronized(System.Collections.Queue)">
          <source>To guarantee thread safety during enumeration, you can either lock the collection during the entire enumeration or catch the exceptions resulting from changes made by other threads.</source>
          <target state="translated">Para garantir thread-safe durante a enumeração, é possível bloquear a coleção durante toda a enumeração ou verificar as exceções resultantes das alterações feitas por outros threads.</target>       </trans-unit>
        <trans-unit id="282" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Queue.Synchronized(System.Collections.Queue)">
          <source>The following code example shows how to lock the collection using the <ph id="ph1">&lt;xref:System.Collections.Queue.SyncRoot%2A&gt;</ph> during the entire enumeration.</source>
          <target state="translated">O exemplo de código a seguir mostra como bloquear a coleção usando o <ph id="ph1">&lt;xref:System.Collections.Queue.SyncRoot%2A&gt;</ph> durante toda a enumeração.</target>       </trans-unit>
        <trans-unit id="283" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Queue.Synchronized(System.Collections.Queue)">
          <source>This method is an O(1) operation.</source>
          <target state="translated">Este método é uma operação O(1).</target>       </trans-unit>
        <trans-unit id="284" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Queue.Synchronized(System.Collections.Queue)">
          <source>The following example shows how to synchronize a <ph id="ph1">&lt;xref:System.Collections.Queue&gt;</ph>, determine if a <ph id="ph2">&lt;xref:System.Collections.Queue&gt;</ph> is synchronized and use a synchronized <ph id="ph3">&lt;xref:System.Collections.Queue&gt;</ph>.</source>
          <target state="translated">O exemplo a seguir mostra como sincronizar um <ph id="ph1">&lt;xref:System.Collections.Queue&gt;</ph>, determinar se um <ph id="ph2">&lt;xref:System.Collections.Queue&gt;</ph> é sincronizado e usar um sincronizado <ph id="ph3">&lt;xref:System.Collections.Queue&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="285" translate="yes" xml:space="preserve" uid="M:System.Collections.Queue.Synchronized(System.Collections.Queue)">
          <source><ph id="ph1">&lt;paramref name="queue" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          
        </trans-unit>
        <trans-unit id="286" translate="yes" xml:space="preserve" uid="P:System.Collections.Queue.SyncRoot">
          <source>Gets an object that can be used to synchronize access to the <ph id="ph1">&lt;see cref="T:System.Collections.Queue" /&gt;</ph>.</source>
          
        </trans-unit>
        <trans-unit id="287" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.Queue.SyncRoot">
          <source>An object that can be used to synchronize access to the <ph id="ph1">&lt;see cref="T:System.Collections.Queue" /&gt;</ph>.</source>
          <target state="translated">Um objeto que pode ser usado para sincronizar o acesso ao <ph id="ph1">&lt;see cref="T:System.Collections.Queue" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="288" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.Queue.SyncRoot">
          <source>To create a synchronized version of the <ph id="ph1">&lt;xref:System.Collections.Queue&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Collections.Queue.Synchronized%2A&gt;</ph> method.</source>
          <target state="translated">Para criar uma versão sincronizada do <ph id="ph1">&lt;xref:System.Collections.Queue&gt;</ph>, use o <ph id="ph2">&lt;xref:System.Collections.Queue.Synchronized%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="289" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.Queue.SyncRoot">
          <source>However, derived classes can provide their own synchronized version of the <ph id="ph1">&lt;xref:System.Collections.Queue&gt;</ph> using the <ph id="ph2">&lt;xref:System.Collections.Queue.SyncRoot%2A&gt;</ph> property.</source>
          <target state="translated">No entanto, as classes derivadas podem fornecer sua própria versão sincronizada de <ph id="ph1">&lt;xref:System.Collections.Queue&gt;</ph> usando o <ph id="ph2">&lt;xref:System.Collections.Queue.SyncRoot%2A&gt;</ph> propriedade.</target>       </trans-unit>
        <trans-unit id="290" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.Queue.SyncRoot">
          <source>The synchronizing code must perform operations on the <ph id="ph1">&lt;xref:System.Collections.Queue.SyncRoot%2A&gt;</ph> of the <ph id="ph2">&lt;xref:System.Collections.Queue&gt;</ph>, not directly on the <ph id="ph3">&lt;xref:System.Collections.Queue&gt;</ph>.</source>
          <target state="translated">O código de sincronização necessário realizar operações no <ph id="ph1">&lt;xref:System.Collections.Queue.SyncRoot%2A&gt;</ph> do <ph id="ph2">&lt;xref:System.Collections.Queue&gt;</ph>, não diretamente no <ph id="ph3">&lt;xref:System.Collections.Queue&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="291" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.Queue.SyncRoot">
          <source>This ensures proper operation of collections that are derived from other objects.</source>
          <target state="translated">Isso garante a operação apropriada das coleções que são derivadas de outros objetos.</target>       </trans-unit>
        <trans-unit id="292" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.Queue.SyncRoot">
          <source>Specifically, it maintains proper synchronization with other threads that might be simultaneously modifying the <ph id="ph1">&lt;xref:System.Collections.Queue&gt;</ph> object.</source>
          <target state="translated">Especificamente, ele mantém uma sincronização adequada com outros threads que podem ser simultaneamente modificando o <ph id="ph1">&lt;xref:System.Collections.Queue&gt;</ph> objeto.</target>       </trans-unit>
        <trans-unit id="293" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.Queue.SyncRoot">
          <source>Enumerating through a collection is intrinsically not a thread-safe procedure.</source>
          <target state="translated">A enumeração por meio de uma coleção não é um procedimento thread-safe intrínseco.</target>       </trans-unit>
        <trans-unit id="294" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.Queue.SyncRoot">
          <source>Even when a collection is synchronized, other threads can still modify the collection, which causes the enumerator to throw an exception.</source>
          <target state="translated">Mesmo quando uma coleção está sincronizada, outros threads ainda podem modificar a coleção, o que faz o enumerador lançar uma exceção.</target>       </trans-unit>
        <trans-unit id="295" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.Queue.SyncRoot">
          <source>To guarantee thread safety during enumeration, you can either lock the collection during the entire enumeration or catch the exceptions resulting from changes made by other threads.</source>
          <target state="translated">Para garantir thread-safe durante a enumeração, é possível bloquear a coleção durante toda a enumeração ou verificar as exceções resultantes das alterações feitas por outros threads.</target>       </trans-unit>
        <trans-unit id="296" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.Queue.SyncRoot">
          <source>The following code example shows how to lock the collection using the <ph id="ph1">&lt;xref:System.Collections.Queue.SyncRoot%2A&gt;</ph> during the entire enumeration.</source>
          <target state="translated">O exemplo de código a seguir mostra como bloquear a coleção usando o <ph id="ph1">&lt;xref:System.Collections.Queue.SyncRoot%2A&gt;</ph> durante toda a enumeração.</target>       </trans-unit>
        <trans-unit id="297" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.Queue.SyncRoot">
          <source>Retrieving the value of this property is an O(1) operation.</source>
          <target state="translated">A recuperação do valor dessa propriedade é uma operação O(1).</target>       </trans-unit>
        <trans-unit id="298" translate="yes" xml:space="preserve" uid="M:System.Collections.Queue.ToArray">
          <source>Copies the <ph id="ph1">&lt;see cref="T:System.Collections.Queue" /&gt;</ph> elements to a new array.</source>
          
        </trans-unit>
        <trans-unit id="299" translate="yes" xml:space="preserve" uid="M:System.Collections.Queue.ToArray">
          <source>A new array containing elements copied from the <ph id="ph1">&lt;see cref="T:System.Collections.Queue" /&gt;</ph>.</source>
          
        </trans-unit>
        <trans-unit id="300" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Queue.ToArray">
          <source>The <ph id="ph1">&lt;xref:System.Collections.Queue&gt;</ph> is not modified.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Collections.Queue&gt;</ph> não é modificado.</target>       </trans-unit>
        <trans-unit id="301" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Queue.ToArray">
          <source>The order of the elements in the new array is the same as the order of the elements from the beginning of the <ph id="ph1">&lt;xref:System.Collections.Queue&gt;</ph> to its end.</source>
          <target state="translated">A ordem dos elementos na nova matriz é igual à ordem dos elementos do início do <ph id="ph1">&lt;xref:System.Collections.Queue&gt;</ph> até o fim.</target>       </trans-unit>
        <trans-unit id="302" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Queue.ToArray">
          <source>This method is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is <ph id="ph3">&lt;xref:System.Collections.Queue.Count%2A&gt;</ph>.</source>
          <target state="translated">Este método é uma operação O(<ph id="ph1">`n`</ph>), em que <ph id="ph2">`n`</ph> é <ph id="ph3">&lt;xref:System.Collections.Queue.Count%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="303" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Queue.ToArray">
          <source>The following example shows how to copy a <ph id="ph1">&lt;xref:System.Collections.Queue&gt;</ph> into a one-dimensional array.</source>
          <target state="translated">O exemplo a seguir mostra como copiar um <ph id="ph1">&lt;xref:System.Collections.Queue&gt;</ph> em uma matriz unidimensional.</target>       </trans-unit>
        <trans-unit id="304" translate="yes" xml:space="preserve" uid="M:System.Collections.Queue.TrimToSize">
          <source>Sets the capacity to the actual number of elements in the <ph id="ph1">&lt;see cref="T:System.Collections.Queue" /&gt;</ph>.</source>
          
        </trans-unit>
        <trans-unit id="305" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Queue.TrimToSize">
          <source>This method can be used to minimize a queue's memory overhead if no new elements will be added to the queue.</source>
          <target state="translated">Esse método pode ser usado para minimizar a memória de uma fila sobrecarga se nenhum elemento novo será adicionado à fila.</target>       </trans-unit>
        <trans-unit id="306" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Queue.TrimToSize">
          <source>To reset a <ph id="ph1">&lt;xref:System.Collections.Queue&gt;</ph> to its initial state, call the <ph id="ph2">&lt;xref:System.Collections.Queue.Clear%2A&gt;</ph> method before calling <ph id="ph3">&lt;xref:System.Collections.Queue.TrimToSize%2A&gt;</ph>.</source>
          <target state="translated">Para redefinir um <ph id="ph1">&lt;xref:System.Collections.Queue&gt;</ph> para seu estado inicial, chame o <ph id="ph2">&lt;xref:System.Collections.Queue.Clear%2A&gt;</ph> método antes de chamar <ph id="ph3">&lt;xref:System.Collections.Queue.TrimToSize%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="307" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Queue.TrimToSize">
          <source>Trimming an empty <ph id="ph1">&lt;xref:System.Collections.Queue&gt;</ph> sets the capacity of the <ph id="ph2">&lt;xref:System.Collections.Queue&gt;</ph> to the default capacity.</source>
          <target state="translated">Cortar vazio <ph id="ph1">&lt;xref:System.Collections.Queue&gt;</ph> define a capacidade do <ph id="ph2">&lt;xref:System.Collections.Queue&gt;</ph> à capacidade padrão.</target>       </trans-unit>
        <trans-unit id="308" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Queue.TrimToSize">
          <source>This method is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is <ph id="ph3">&lt;xref:System.Collections.Queue.Count%2A&gt;</ph>.</source>
          <target state="translated">Este método é uma operação O(<ph id="ph1">`n`</ph>), em que <ph id="ph2">`n`</ph> é <ph id="ph3">&lt;xref:System.Collections.Queue.Count%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="309" translate="yes" xml:space="preserve" uid="M:System.Collections.Queue.TrimToSize">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.Queue" /&gt;</ph> is read-only.</source>
          
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>