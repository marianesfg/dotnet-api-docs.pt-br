<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="ArrayList.xml" source-language="en-US" target-language="pt-BR">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-15c36f0" tool-company="Microsoft" />
      <xliffext:skl_file_name xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">02cd5861-7ce2-4a82-b358-31f8435a0ac59a105732aa94698f5ea781b6eed29feca20656b5.skl</xliffext:skl_file_name>
      <xliffext:version xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">1.2</xliffext:version>
      <xliffext:ms.openlocfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">9a105732aa94698f5ea781b6eed29feca20656b5</xliffext:ms.openlocfilehash>
      <xliffext:ms.sourcegitcommit xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b</xliffext:ms.sourcegitcommit>
      <xliffext:ms.lasthandoff xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">04/03/2018</xliffext:ms.lasthandoff>
      <xliffext:moniker_ids xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">netcore-1.0,netcore-1.1,netcore-2.0,netcore-2.1,netframework-4.5.1,netframework-4.5.2,netframework-4.5,netframework-4.6.1,netframework-4.6.2,netframework-4.6,netframework-4.7.1,netframework-4.7,netstandard-2.0,xamarinandroid-7.1,xamarinios-10.8,xamarinmac-3.0</xliffext:moniker_ids>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve" uid="T:System.Collections.ArrayList">
          <source>Implements the <ph id="ph1">&lt;see cref="T:System.Collections.IList" /&gt;</ph> interface using an array whose size is dynamically increased as required.</source>
          <target state="translated">Implementa a interface <ph id="ph1">&lt;see cref="T:System.Collections.IList" /&gt;</ph> usando uma matriz cujo tamanho é aumentado dinamicamente conforme necessário.</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.ArrayList">
          <source>The <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph> class is designed to hold heterogeneous collections of objects.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph> classe foi projetada para manter heterogêneas coleções de objetos.</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.ArrayList">
          <source>However, it does not always offer the best performance.</source>
          <target state="translated">No entanto, ele não sempre oferece o melhor desempenho.</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.ArrayList">
          <source>Instead, we recommend the following:</source>
          <target state="translated">Em vez disso, recomendamos o seguinte:</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.ArrayList">
          <source>For a heterogeneous collection of objects, use the <ph id="ph1">`List&lt;Object&gt;`</ph> (in C#) or <ph id="ph2">`List(Of Object)`</ph> (in Visual Basic) type.</source>
          <target state="translated">Para uma coleção heterogênea de objetos, use o <ph id="ph1">`List&lt;Object&gt;`</ph> (em c#) ou <ph id="ph2">`List(Of Object)`</ph> (no Visual Basic), digite.</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.ArrayList">
          <source>For a homogeneous collection of objects, use the <ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph> class.</source>
          <target state="translated">Para uma coleção homogênea de objetos, use o <ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph> classe.</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.ArrayList">
          <source>See the "Performance Considerations" section in the <ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph> reference topic for a discussion of the relative performance of these classes.</source>
          <target state="translated">Consulte a seção "Considerações de desempenho" o <ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph> tópico de referência para uma discussão sobre o desempenho relativo dessas classes.</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.ArrayList">
          <source>The <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph> is not guaranteed to be sorted.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph> não é garantida a ser classificada.</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.ArrayList">
          <source>You must sort the <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph> by calling its <ph id="ph2">&lt;xref:System.Collections.ArrayList.Sort%2A&gt;</ph> method prior to performing operations (such as <ph id="ph3">&lt;xref:System.Collections.ArrayList.BinarySearch%2A&gt;</ph>) that require the <ph id="ph4">&lt;xref:System.Collections.ArrayList&gt;</ph> to be sorted.</source>
          <target state="translated">Você deve classificar o <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph> chamando seu <ph id="ph2">&lt;xref:System.Collections.ArrayList.Sort%2A&gt;</ph> método antes de executar operações (como <ph id="ph3">&lt;xref:System.Collections.ArrayList.BinarySearch%2A&gt;</ph>) que exigem o <ph id="ph4">&lt;xref:System.Collections.ArrayList&gt;</ph> a ser classificada.</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.ArrayList">
          <source>To maintain a collection that is automatically sorted as new elements are added, you can use the <ph id="ph1">&lt;xref:System.Collections.Generic.SortedSet%601&gt;</ph> class.</source>
          <target state="translated">Para manter uma coleção que é classificada automaticamente à medida que novos elementos são adicionados, você pode usar o <ph id="ph1">&lt;xref:System.Collections.Generic.SortedSet%601&gt;</ph> classe.</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.ArrayList">
          <source>The capacity of an <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph> is the number of elements the <ph id="ph2">&lt;xref:System.Collections.ArrayList&gt;</ph> can hold.</source>
          <target state="translated">A capacidade de um <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph> é o número de elementos de <ph id="ph2">&lt;xref:System.Collections.ArrayList&gt;</ph> pode conter.</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.ArrayList">
          <source>As elements are added to an <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph>, the capacity is automatically increased as required through reallocation.</source>
          <target state="translated">Como os elementos são adicionados a um <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph>, a capacidade é aumentada automaticamente conforme necessário por meio de realocação.</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.ArrayList">
          <source>The capacity can be decreased by calling <ph id="ph1">&lt;xref:System.Collections.ArrayList.TrimToSize%2A&gt;</ph> or by setting the <ph id="ph2">&lt;xref:System.Collections.ArrayList.Capacity%2A&gt;</ph> property explicitly.</source>
          <target state="translated">A capacidade pode ser diminuída chamando <ph id="ph1">&lt;xref:System.Collections.ArrayList.TrimToSize%2A&gt;</ph> ou definindo o <ph id="ph2">&lt;xref:System.Collections.ArrayList.Capacity%2A&gt;</ph> propriedade explicitamente.</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.ArrayList">
          <source>For very large <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph> objects, you can increase the maximum capacity to 2 billion elements on a 64-bit system by setting the <ph id="ph2">`enabled`</ph> attribute of the  configuration element to <ph id="ph3">`true`</ph> in the run-time environment.</source>
          <target state="translated">Para grandes <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph> objetos, você pode aumentar a capacidade máxima para 2 bilhões de elementos em um sistema de 64 bits definindo o <ph id="ph2">`enabled`</ph> atributo do elemento de configuração para <ph id="ph3">`true`</ph> no ambiente de tempo de execução.</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.ArrayList">
          <source>Elements in this collection can be accessed using an integer index.</source>
          <target state="translated">Elementos nesta coleção podem ser acessados usando um índice de inteiro.</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.ArrayList">
          <source>Indexes in this collection are zero-based.</source>
          <target state="translated">Índices nesta coleção são baseadas em zero.</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.ArrayList">
          <source>The <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph> collection accepts <ph id="ph2">`null`</ph> as a valid value.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph> coleção aceita <ph id="ph2">`null`</ph> como um valor válido.</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.ArrayList">
          <source>It also allows duplicate elements.</source>
          <target state="translated">Ele também permite elementos duplicados.</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.ArrayList">
          <source>Using multidimensional arrays as elements in an <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph> collection is not supported.</source>
          <target state="translated">Usando matrizes multidimensionais como elementos em um <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph> não há suporte para a coleção.</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.ArrayList">
          <source>The following code example shows how to create and initialize an <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph> and how to display its values.</source>
          <target state="translated">O exemplo de código a seguir mostra como criar e inicializar um <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph> e como exibir seus valores.</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.ArrayList">
          <source>Public static (<ph id="ph1">&lt;see langword="Shared" /&gt;</ph> in Visual Basic) members of this type are thread safe.</source>
          <target state="translated">Os membros estáticos públicos (<ph id="ph1">&lt;see langword="Shared" /&gt;</ph> no Visual Basic) desse são thread-safe.</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.ArrayList">
          <source>Any instance members are not guaranteed to be thread safe.</source>
          <target state="translated">Não há garantia de que qualquer membro de instância seja thread-safe.</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.ArrayList">
          <source>An <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> can support multiple readers concurrently, as long as the collection is not modified.</source>
          <target state="translated">Um <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> pode dar suporte a vários leitores simultaneamente, desde que a coleção não é modificada.</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.ArrayList">
          <source>To guarantee the thread safety of the <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph>, all operations must be done through the wrapper returned by the <ph id="ph2">&lt;see cref="M:System.Collections.ArrayList.Synchronized(System.Collections.IList)" /&gt;</ph> method.</source>
          <target state="translated">Para garantir a segurança de thread do <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph>, todas as operações devem ser feitas por meio do wrapper retornado pelo <ph id="ph2">&lt;see cref="M:System.Collections.ArrayList.Synchronized(System.Collections.IList)" /&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.ArrayList">
          <source>Enumerating through a collection is intrinsically not a thread-safe procedure.</source>
          <target state="translated">A enumeração por meio de uma coleção não é um procedimento thread-safe intrínseco.</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.ArrayList">
          <source>Even when a collection is synchronized, other threads can still modify the collection, which causes the enumerator to throw an exception.</source>
          <target state="translated">Mesmo quando uma coleção está sincronizada, outros threads ainda podem modificar a coleção, o que faz o enumerador lançar uma exceção.</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.ArrayList">
          <source>To guarantee thread safety during enumeration, you can either lock the collection during the entire enumeration or catch the exceptions resulting from changes made by other threads.</source>
          <target state="translated">Para garantir thread-safe durante a enumeração, é possível bloquear a coleção durante toda a enumeração ou verificar as exceções resultantes das alterações feitas por outros threads.</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve" uid="T:System.Collections.ArrayList">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> class.</source>
          <target state="translated">Inicializa uma nova instância da classe <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.#ctor">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> class that is empty and has the default initial capacity.</source>
          <target state="translated">Inicializa uma nova instância da classe <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> que está vazia e tem a capacidade inicial padrão.</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.#ctor">
          <source>The capacity of an <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph> is the number of elements that the <ph id="ph2">&lt;xref:System.Collections.ArrayList&gt;</ph> can hold.</source>
          <target state="translated">A capacidade de um <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph> é o número de elementos que o <ph id="ph2">&lt;xref:System.Collections.ArrayList&gt;</ph> pode conter.</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.#ctor">
          <source>As elements are added to an <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph>, the capacity is automatically increased as required by reallocating the internal array.</source>
          <target state="translated">Como os elementos são adicionados a um <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph>, a capacidade é aumentada automaticamente conforme necessário ao realocar a matriz interna.</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.#ctor">
          <source>If the size of the collection can be estimated, specifying the initial capacity eliminates the need to perform a number of resizing operations while adding elements to the <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph>.</source>
          <target state="translated">Se o tamanho da coleção pode ser estimado, especificando a capacidade inicial elimina a necessidade de executar um número de operações de redimensionamento durante a adição de elementos para o <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.#ctor">
          <source>This constructor is an O(1) operation.</source>
          <target state="translated">Este construtor é uma operação O(1).</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.#ctor(System.Collections.ICollection)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.ICollection" /&gt;</ph> whose elements are copied to the new list.</source>
          <target state="translated">O <ph id="ph1">&lt;see cref="T:System.Collections.ICollection" /&gt;</ph> cujos elementos são copiados para a nova lista.</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.#ctor(System.Collections.ICollection)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> class that contains elements copied from the specified collection and that has the same initial capacity as the number of elements copied.</source>
          <target state="translated">Inicializa uma nova instância da classe <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph>, que contém os elementos copiados da coleção especificada e tem a mesma capacidade inicial que o número de elementos copiados.</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.#ctor(System.Collections.ICollection)">
          <source>The capacity of an <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph> is the number of elements that the <ph id="ph2">&lt;xref:System.Collections.ArrayList&gt;</ph> can hold.</source>
          <target state="translated">A capacidade de um <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph> é o número de elementos que o <ph id="ph2">&lt;xref:System.Collections.ArrayList&gt;</ph> pode conter.</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.#ctor(System.Collections.ICollection)">
          <source>As elements are added to an <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph>, the capacity is automatically increased as required by reallocating the internal array.</source>
          <target state="translated">Como os elementos são adicionados a um <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph>, a capacidade é aumentada automaticamente conforme necessário ao realocar a matriz interna.</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.#ctor(System.Collections.ICollection)">
          <source>If the size of the collection can be estimated, specifying the initial capacity eliminates the need to perform a number of resizing operations while adding elements to the <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph>.</source>
          <target state="translated">Se o tamanho da coleção pode ser estimado, especificando a capacidade inicial elimina a necessidade de executar um número de operações de redimensionamento durante a adição de elementos para o <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.#ctor(System.Collections.ICollection)">
          <source>The elements are copied onto the <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph> in the same order they are read by the <ph id="ph2">&lt;xref:System.Collections.IEnumerator&gt;</ph> of the <ph id="ph3">&lt;xref:System.Collections.ICollection&gt;</ph>.</source>
          <target state="translated">Os elementos são copiados para o <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph> na mesma ordem em que são lidas pelo <ph id="ph2">&lt;xref:System.Collections.IEnumerator&gt;</ph> do <ph id="ph3">&lt;xref:System.Collections.ICollection&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.#ctor(System.Collections.ICollection)">
          <source>This constructor is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is the number of elements in <ph id="ph3">`c`</ph>.</source>
          <target state="translated">Este construtor é um O (<ph id="ph1">`n`</ph>) operação, onde <ph id="ph2">`n`</ph> é o número de elementos em <ph id="ph3">`c`</ph>.</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.#ctor(System.Collections.ICollection)">
          <source><ph id="ph1">&lt;paramref name="c" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="c" /&gt;</ph> é <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.#ctor(System.Int32)">
          <source>The number of elements that the new list can initially store.</source>
          <target state="translated">O número de elementos que a nova lista pode armazenar inicialmente.</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.#ctor(System.Int32)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> class that is empty and has the specified initial capacity.</source>
          <target state="translated">Inicializa uma nova instância da classe <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> que está vazia e tem a capacidade inicial especificada.</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.#ctor(System.Int32)">
          <source>The capacity of an <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph> is the number of elements that the <ph id="ph2">&lt;xref:System.Collections.ArrayList&gt;</ph> can hold.</source>
          <target state="translated">A capacidade de um <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph> é o número de elementos que o <ph id="ph2">&lt;xref:System.Collections.ArrayList&gt;</ph> pode conter.</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.#ctor(System.Int32)">
          <source>As elements are added to an <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph>, the capacity is automatically increased as required by reallocating the internal array.</source>
          <target state="translated">Como os elementos são adicionados a um <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph>, a capacidade é aumentada automaticamente conforme necessário ao realocar a matriz interna.</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.#ctor(System.Int32)">
          <source>If the size of the collection can be estimated, specifying the initial capacity eliminates the need to perform a number of resizing operations while adding elements to the <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph>.</source>
          <target state="translated">Se o tamanho da coleção pode ser estimado, especificando a capacidade inicial elimina a necessidade de executar um número de operações de redimensionamento durante a adição de elementos para o <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.#ctor(System.Int32)">
          <source>This constructor is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is <ph id="ph3">`capacity`</ph>.</source>
          <target state="translated">Este construtor é um O (<ph id="ph1">`n`</ph>) operação, onde <ph id="ph2">`n`</ph> é <ph id="ph3">`capacity`</ph>.</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.#ctor(System.Int32)">
          <source><ph id="ph1">&lt;paramref name="capacity" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="capacity" /&gt;</ph> é menor que zero.</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.Adapter(System.Collections.IList)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.IList" /&gt;</ph> to wrap.</source>
          <target state="translated">O <ph id="ph1">&lt;see cref="T:System.Collections.IList" /&gt;</ph> a ser encapsulado.</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.Adapter(System.Collections.IList)">
          <source>Creates an <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> wrapper for a specific <ph id="ph2">&lt;see cref="T:System.Collections.IList" /&gt;</ph>.</source>
          <target state="translated">Cria um wrapper <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> para um determinado <ph id="ph2">&lt;see cref="T:System.Collections.IList" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.Adapter(System.Collections.IList)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> wrapper around the <ph id="ph2">&lt;see cref="T:System.Collections.IList" /&gt;</ph>.</source>
          <target state="translated">O wrapper <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> ao redor de <ph id="ph2">&lt;see cref="T:System.Collections.IList" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.Adapter(System.Collections.IList)">
          <source><ph id="ph1">&lt;xref:System.Collections.ArrayList.Adapter%2A&gt;</ph> does not copy the contents of <ph id="ph2">&lt;xref:System.Collections.IList&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Collections.ArrayList.Adapter%2A&gt;</ph> não copia o conteúdo de <ph id="ph2">&lt;xref:System.Collections.IList&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.Adapter(System.Collections.IList)">
          <source>Instead, it only creates an <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph> wrapper around <ph id="ph2">&lt;xref:System.Collections.IList&gt;</ph>; therefore, changes to the <ph id="ph3">&lt;xref:System.Collections.IList&gt;</ph> also affect the <ph id="ph4">&lt;xref:System.Collections.ArrayList&gt;</ph>.</source>
          <target state="translated">Em vez disso, ele cria apenas uma <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph> wrapper em torno de <ph id="ph2">&lt;xref:System.Collections.IList&gt;</ph>; portanto, é alterado para o <ph id="ph3">&lt;xref:System.Collections.IList&gt;</ph> também afetam o <ph id="ph4">&lt;xref:System.Collections.ArrayList&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.Adapter(System.Collections.IList)">
          <source>The <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph> class provides generic <ph id="ph2">&lt;xref:System.Collections.ArrayList.Reverse%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.Collections.ArrayList.BinarySearch%2A&gt;</ph> and <ph id="ph4">&lt;xref:System.Collections.ArrayList.Sort%2A&gt;</ph> methods.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph> classe fornece genérico <ph id="ph2">&lt;xref:System.Collections.ArrayList.Reverse%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.Collections.ArrayList.BinarySearch%2A&gt;</ph> e <ph id="ph4">&lt;xref:System.Collections.ArrayList.Sort%2A&gt;</ph> métodos.</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.Adapter(System.Collections.IList)">
          <source>This wrapper can be a means to use those methods on <ph id="ph1">&lt;xref:System.Collections.IList&gt;</ph>; however, performing these generic operations through the wrapper might be less efficient than operations applied directly on the <ph id="ph2">&lt;xref:System.Collections.IList&gt;</ph>.</source>
          <target state="translated">Esse wrapper pode ser um meio para usar esses métodos no <ph id="ph1">&lt;xref:System.Collections.IList&gt;</ph>; no entanto, essas operações genérico por meio de wrapper podem ser menos eficiente do que operações aplicadas diretamente a <ph id="ph2">&lt;xref:System.Collections.IList&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.Adapter(System.Collections.IList)">
          <source>This method is an O(1) operation.</source>
          <target state="translated">Este método é uma operação O(1).</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.Adapter(System.Collections.IList)">
          <source>Version Compatibility</source>
          <target state="translated">Compatibilidade de versões</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.Adapter(System.Collections.IList)">
          <source>In the .NET Framework version 1.0 and 1.1, calling the <ph id="ph1">&lt;xref:System.Collections.ArrayList.GetEnumerator%28System.Int32%2CSystem.Int32%29&gt;</ph> method overload on the <ph id="ph2">&lt;xref:System.Collections.ArrayList&gt;</ph> wrapper returned an enumerator that treated the second argument as an upper bound rather than as a count.</source>
          <target state="translated">No .NET Framework versão 1.0 e 1.1, chamando o <ph id="ph1">&lt;xref:System.Collections.ArrayList.GetEnumerator%28System.Int32%2CSystem.Int32%29&gt;</ph> sobrecarga de método no <ph id="ph2">&lt;xref:System.Collections.ArrayList&gt;</ph> wrapper retornou um enumerador que tratado o segundo argumento como um limite superior em vez de uma contagem.</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.Adapter(System.Collections.IList)">
          <source>In the <ph id="ph1">[!INCLUDE[dnprdnlong](~/includes/dnprdnlong-md.md)]</ph> the second argument is correctly treated as a count.</source>
          <target state="translated">No <ph id="ph1">[!INCLUDE[dnprdnlong](~/includes/dnprdnlong-md.md)]</ph> corretamente, o segundo argumento é tratado como uma contagem.</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.Adapter(System.Collections.IList)">
          <source><ph id="ph1">&lt;paramref name="list" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="list" /&gt;</ph> é <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.Add(System.Object)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Object" /&gt;</ph> to be added to the end of the <ph id="ph2">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph>.</source>
          <target state="translated">O objeto <ph id="ph1">&lt;see cref="T:System.Object" /&gt;</ph> a ser adicionado ao final do <ph id="ph2">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.Add(System.Object)">
          <source>The value can be <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">O valor pode ser <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.Add(System.Object)">
          <source>Adds an object to the end of the <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph>.</source>
          <target state="translated">Adiciona um objeto ao final do <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.Add(System.Object)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> index at which the <ph id="ph2">&lt;paramref name="value" /&gt;</ph> has been added.</source>
          <target state="translated">O índice <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> ao qual o <ph id="ph2">&lt;paramref name="value" /&gt;</ph> foi adicionado.</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.Add(System.Object)">
          <source><ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph> accepts <ph id="ph2">`null`</ph> as a valid value and allows duplicate elements.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph> aceita <ph id="ph2">`null`</ph> como um valor válido e permite elementos duplicados.</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.Add(System.Object)">
          <source>If <ph id="ph1">&lt;xref:System.Collections.ArrayList.Count%2A&gt;</ph> already equals <ph id="ph2">&lt;xref:System.Collections.ArrayList.Capacity%2A&gt;</ph>, the capacity of the <ph id="ph3">&lt;xref:System.Collections.ArrayList&gt;</ph> is increased by automatically reallocating the internal array, and the existing elements are copied to the new array before the new element is added.</source>
          <target state="translated">Se <ph id="ph1">&lt;xref:System.Collections.ArrayList.Count%2A&gt;</ph> já for igual a <ph id="ph2">&lt;xref:System.Collections.ArrayList.Capacity%2A&gt;</ph>, a capacidade do <ph id="ph3">&lt;xref:System.Collections.ArrayList&gt;</ph> é aumentado, automaticamente realocando matriz interna, e os elementos existentes são copiados para a nova matriz antes de adicionar o novo elemento.</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.Add(System.Object)">
          <source>If <ph id="ph1">&lt;xref:System.Collections.ArrayList.Count%2A&gt;</ph> is less than <ph id="ph2">&lt;xref:System.Collections.ArrayList.Capacity%2A&gt;</ph>, this method is an O(1) operation.</source>
          <target state="translated">Se <ph id="ph1">&lt;xref:System.Collections.ArrayList.Count%2A&gt;</ph> é menor que <ph id="ph2">&lt;xref:System.Collections.ArrayList.Capacity%2A&gt;</ph>, esse método é uma operação de (1).</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.Add(System.Object)">
          <source>If the capacity needs to be increased to accommodate the new element, this method becomes an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is <ph id="ph3">&lt;xref:System.Collections.ArrayList.Count%2A&gt;</ph>.</source>
          <target state="translated">Se a capacidade precisa ser aumentado para acomodar o novo elemento, esse método se torna um O (<ph id="ph1">`n`</ph>) operação, onde <ph id="ph2">`n`</ph> é <ph id="ph3">&lt;xref:System.Collections.ArrayList.Count%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.Add(System.Object)">
          <source>The following code example shows how to add elements to the <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph>.</source>
          <target state="translated">O exemplo de código a seguir mostra como adicionar elementos para o <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.Add(System.Object)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> is read-only.</source>
          <target state="translated">O <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> é somente leitura.</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.Add(System.Object)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.Add(System.Object)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> has a fixed size.</source>
          <target state="translated">O <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> tem um tamanho fixo.</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.AddRange(System.Collections.ICollection)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.ICollection" /&gt;</ph> whose elements should be added to the end of the <ph id="ph2">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph>.</source>
          <target state="translated">O <ph id="ph1">&lt;see cref="T:System.Collections.ICollection" /&gt;</ph> cujos elementos devem ser adicionados ao final do <ph id="ph2">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.AddRange(System.Collections.ICollection)">
          <source>The collection itself cannot be <ph id="ph1">&lt;see langword="null" /&gt;</ph>, but it can contain elements that are <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">A coleção em si não pode ser <ph id="ph1">&lt;see langword="null" /&gt;</ph>, mas pode conter elementos que são <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.AddRange(System.Collections.ICollection)">
          <source>Adds the elements of an <ph id="ph1">&lt;see cref="T:System.Collections.ICollection" /&gt;</ph> to the end of the <ph id="ph2">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph>.</source>
          <target state="translated">Adiciona os elementos de um <ph id="ph1">&lt;see cref="T:System.Collections.ICollection" /&gt;</ph> ao final do <ph id="ph2">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.AddRange(System.Collections.ICollection)">
          <source><ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph> accepts <ph id="ph2">`null`</ph> as a valid value and allows duplicate elements.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph> aceita <ph id="ph2">`null`</ph> como um valor válido e permite elementos duplicados.</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.AddRange(System.Collections.ICollection)">
          <source>The order of the elements in the <ph id="ph1">&lt;xref:System.Collections.ICollection&gt;</ph> is preserved in the <ph id="ph2">&lt;xref:System.Collections.ArrayList&gt;</ph>.</source>
          <target state="translated">A ordem dos elementos no <ph id="ph1">&lt;xref:System.Collections.ICollection&gt;</ph> é preservada no <ph id="ph2">&lt;xref:System.Collections.ArrayList&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.AddRange(System.Collections.ICollection)">
          <source>If the new <ph id="ph1">&lt;xref:System.Collections.ArrayList.Count%2A&gt;</ph> (the current <ph id="ph2">&lt;xref:System.Collections.ArrayList.Count%2A&gt;</ph> plus the size of the collection) will be greater than <ph id="ph3">&lt;xref:System.Collections.ArrayList.Capacity%2A&gt;</ph>, the capacity of the <ph id="ph4">&lt;xref:System.Collections.ArrayList&gt;</ph> is increased by automatically reallocating the internal array to accommodate the new elements, and the existing elements are copied to the new array before the new elements are added.</source>
          <target state="translated">Se o novo <ph id="ph1">&lt;xref:System.Collections.ArrayList.Count%2A&gt;</ph> (atual <ph id="ph2">&lt;xref:System.Collections.ArrayList.Count%2A&gt;</ph> mais o tamanho da coleção) será maior <ph id="ph3">&lt;xref:System.Collections.ArrayList.Capacity%2A&gt;</ph>, a capacidade do <ph id="ph4">&lt;xref:System.Collections.ArrayList&gt;</ph> é aumentado, automaticamente realocando a matriz interna para acomodar os novos elementos, e os elementos existentes são copiados para a nova matriz antes que os novos elementos são adicionados.</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.AddRange(System.Collections.ICollection)">
          <source>If the <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph> can accommodate the new elements without increasing the <ph id="ph2">&lt;xref:System.Collections.ArrayList.Capacity%2A&gt;</ph>, this method is an O(<ph id="ph3">`n`</ph>) operation, where <ph id="ph4">`n`</ph> is the number of elements to be added.</source>
          <target state="translated">Se o <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph> pode acomodar os novos elementos sem aumentar o <ph id="ph2">&lt;xref:System.Collections.ArrayList.Capacity%2A&gt;</ph>, esse método é um O (<ph id="ph3">`n`</ph>) operação, onde <ph id="ph4">`n`</ph> é o número de elementos a serem adicionados.</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.AddRange(System.Collections.ICollection)">
          <source>If the capacity needs to be increased to accommodate the new elements, this method becomes an O(<ph id="ph1">`n`</ph><ph id="ph2"> + </ph><ph id="ph3">`m`</ph>) operation, where <ph id="ph4">`n`</ph> is the number of elements to be added and <ph id="ph5">`m`</ph> is <ph id="ph6">&lt;xref:System.Collections.ArrayList.Count%2A&gt;</ph>.</source>
          <target state="translated">Se a capacidade precisa ser aumentado para acomodar os novos elementos, esse método se torna um O (<ph id="ph1">`n`</ph><ph id="ph2"> + </ph><ph id="ph3">`m`</ph>) operação, onde <ph id="ph4">`n`</ph> é o número de elementos a serem adicionados e <ph id="ph5">`m`</ph> é <ph id="ph6">&lt;xref:System.Collections.ArrayList.Count%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.AddRange(System.Collections.ICollection)">
          <source>The following code example shows how to add elements to the <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph>.</source>
          <target state="translated">O exemplo de código a seguir mostra como adicionar elementos para o <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.AddRange(System.Collections.ICollection)">
          <source><ph id="ph1">&lt;paramref name="c" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="c" /&gt;</ph> é <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.AddRange(System.Collections.ICollection)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> is read-only.</source>
          <target state="translated">O <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> é somente leitura.</target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.AddRange(System.Collections.ICollection)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.AddRange(System.Collections.ICollection)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> has a fixed size.</source>
          <target state="translated">O <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> tem um tamanho fixo.</target>       </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve" uid="T:System.Collections.ArrayList">
          <source>Uses a binary search algorithm to locate a specific element in the sorted <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> or a portion of it.</source>
          <target state="translated">Usa um algoritmo de pesquisa binária para localizar um elemento específico no <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> classificado ou parte dele.</target>       </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.BinarySearch(System.Object)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Object" /&gt;</ph> to locate.</source>
          <target state="translated">O <ph id="ph1">&lt;see cref="T:System.Object" /&gt;</ph> a ser localizado.</target>       </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.BinarySearch(System.Object)">
          <source>The value can be <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">O valor pode ser <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.BinarySearch(System.Object)">
          <source>Searches the entire sorted <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> for an element using the default comparer and returns the zero-based index of the element.</source>
          <target state="translated">Pesquisa todo o <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> classificado para um elemento usando o comparador padrão e retorna o índice baseado em zero do elemento.</target>       </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.BinarySearch(System.Object)">
          <source>The zero-based index of <ph id="ph1">&lt;paramref name="value" /&gt;</ph> in the sorted <ph id="ph2">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph>, if <ph id="ph3">&lt;paramref name="value" /&gt;</ph> is found; otherwise, a negative number, which is the bitwise complement of the index of the next element that is larger than <ph id="ph4">&lt;paramref name="value" /&gt;</ph> or, if there is no larger element, the bitwise complement of <ph id="ph5">&lt;see cref="P:System.Collections.ArrayList.Count" /&gt;</ph>.</source>
          <target state="translated">O índice baseado em zero da <ph id="ph1">&lt;paramref name="value" /&gt;</ph> no <ph id="ph2">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> classificado se <ph id="ph3">&lt;paramref name="value" /&gt;</ph> for encontrado; caso contrário, um número negativo, que é o complemento bit a bit do índice do próximo elemento maior que <ph id="ph4">&lt;paramref name="value" /&gt;</ph> ou, se não houver nenhum elemento maior, o complemento bit a bit de <ph id="ph5">&lt;see cref="P:System.Collections.ArrayList.Count" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.BinarySearch(System.Object)">
          <source>The <ph id="ph1">`value`</ph> parameter and each element of the <ph id="ph2">&lt;xref:System.Collections.ArrayList&gt;</ph> must implement the <ph id="ph3">&lt;xref:System.IComparable&gt;</ph> interface, which is used for comparisons.</source>
          <target state="translated">O <ph id="ph1">`value`</ph> parâmetro e cada elemento do <ph id="ph2">&lt;xref:System.Collections.ArrayList&gt;</ph> deve implementar o <ph id="ph3">&lt;xref:System.IComparable&gt;</ph> interface, que é usada para comparações.</target>       </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.BinarySearch(System.Object)">
          <source>The elements of the <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph> must already be sorted in increasing value according to the sort order defined by the <ph id="ph2">&lt;xref:System.IComparable&gt;</ph> implementation; otherwise, the result might be incorrect.</source>
          <target state="translated">Os elementos do <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph> já devem ser classificados em aumentar o valor de acordo com a ordem de classificação definida pelo <ph id="ph2">&lt;xref:System.IComparable&gt;</ph> implementação; caso contrário, o resultado pode estar incorreto.</target>       </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.BinarySearch(System.Object)">
          <source>Comparing <ph id="ph1">`null`</ph> with any type is allowed and does not generate an exception when using <ph id="ph2">&lt;xref:System.IComparable&gt;</ph>.</source>
          <target state="translated">Comparando <ph id="ph1">`null`</ph> com qualquer tipo é permitida e não gerará uma exceção ao usar <ph id="ph2">&lt;xref:System.IComparable&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.BinarySearch(System.Object)">
          <source>When sorting, <ph id="ph1">`null`</ph> is considered to be less than any other object.</source>
          <target state="translated">Durante a classificação, <ph id="ph1">`null`</ph> é considerado menor que qualquer outro objeto.</target>       </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.BinarySearch(System.Object)">
          <source>If the <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph> contains more than one element with the same value, the method returns only one of the occurrences, and it might return any one of the occurrences, not necessarily the first one.</source>
          <target state="translated">Se o <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph> contém mais de um elemento com o mesmo valor, o método retornará somente uma das ocorrências e pode retornar qualquer uma das ocorrências, não necessariamente o primeiro deles.</target>       </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.BinarySearch(System.Object)">
          <source>If the <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph> does not contain the specified value, the method returns a negative integer.</source>
          <target state="translated">Caso o <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph> não contenha o valor especificado, o método retorna um inteiro negativo.</target>       </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.BinarySearch(System.Object)">
          <source>You can apply the bitwise complement operation (~) to this negative integer to get the index of the first element that is larger than the search value.</source>
          <target state="translated">Você pode aplicar a operação de complemento bit a bit (~) para esse número inteiro negativo para obter o índice do primeiro elemento que é maior do que o valor de pesquisa.</target>       </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.BinarySearch(System.Object)">
          <source>When inserting the value into the <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph>, this index should be used as the insertion point to maintain the sort order.</source>
          <target state="translated">Ao inserir o valor para o <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph>, esse índice deve ser usado como o ponto de inserção para manter a ordem de classificação.</target>       </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.BinarySearch(System.Object)">
          <source>This method is an O(log <ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is <ph id="ph3">&lt;xref:System.Collections.ArrayList.Count%2A&gt;</ph>.</source>
          <target state="translated">Este método é uma operação O(log <ph id="ph1">`n`</ph>), em que <ph id="ph2">`n`</ph> é <ph id="ph3">&lt;xref:System.Collections.ArrayList.Count%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.BinarySearch(System.Object)">
          <source>The following code example shows how to use <ph id="ph1">&lt;xref:System.Collections.ArrayList.BinarySearch%2A&gt;</ph> to locate a specific object in the <ph id="ph2">&lt;xref:System.Collections.ArrayList&gt;</ph>.</source>
          <target state="translated">O exemplo de código a seguir mostra como usar <ph id="ph1">&lt;xref:System.Collections.ArrayList.BinarySearch%2A&gt;</ph> para localizar um objeto específico no <ph id="ph2">&lt;xref:System.Collections.ArrayList&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.BinarySearch(System.Object)">
          <source>Neither <ph id="ph1">&lt;paramref name="value" /&gt;</ph> nor the elements of <ph id="ph2">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> implement the <ph id="ph3">&lt;see cref="T:System.IComparable" /&gt;</ph> interface.</source>
          <target state="translated">Nem <ph id="ph1">&lt;paramref name="value" /&gt;</ph> nem os elementos de <ph id="ph2">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> implementam a interface <ph id="ph3">&lt;see cref="T:System.IComparable" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.BinarySearch(System.Object)">
          <source><ph id="ph1">&lt;paramref name="value" /&gt;</ph> is not of the same type as the elements of the <ph id="ph2">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="value" /&gt;</ph> não é do mesmo tipo que os elementos do <ph id="ph2">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.BinarySearch(System.Object,System.Collections.IComparer)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Object" /&gt;</ph> to locate.</source>
          <target state="translated">O <ph id="ph1">&lt;see cref="T:System.Object" /&gt;</ph> a ser localizado.</target>       </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.BinarySearch(System.Object,System.Collections.IComparer)">
          <source>The value can be <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">O valor pode ser <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.BinarySearch(System.Object,System.Collections.IComparer)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.IComparer" /&gt;</ph> implementation to use when comparing elements.</source>
          <target state="translated">A implementação de <ph id="ph1">&lt;see cref="T:System.Collections.IComparer" /&gt;</ph> a ser usada durante a comparação de elementos.</target>       </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.BinarySearch(System.Object,System.Collections.IComparer)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.BinarySearch(System.Object,System.Collections.IComparer)">
          <source><ph id="ph1">&lt;see langword="null" /&gt;</ph> to use the default comparer that is the <ph id="ph2">&lt;see cref="T:System.IComparable" /&gt;</ph> implementation of each element.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="null" /&gt;</ph> para usar o comparador padrão que é a implementação <ph id="ph2">&lt;see cref="T:System.IComparable" /&gt;</ph> de cada elemento.</target>       </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.BinarySearch(System.Object,System.Collections.IComparer)">
          <source>Searches the entire sorted <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> for an element using the specified comparer and returns the zero-based index of the element.</source>
          <target state="translated">Pesquisa um elemento em todo o <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> classificado usando o comparador especificado e retorna o índice baseado em zero do elemento.</target>       </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.BinarySearch(System.Object,System.Collections.IComparer)">
          <source>The zero-based index of <ph id="ph1">&lt;paramref name="value" /&gt;</ph> in the sorted <ph id="ph2">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph>, if <ph id="ph3">&lt;paramref name="value" /&gt;</ph> is found; otherwise, a negative number, which is the bitwise complement of the index of the next element that is larger than <ph id="ph4">&lt;paramref name="value" /&gt;</ph> or, if there is no larger element, the bitwise complement of <ph id="ph5">&lt;see cref="P:System.Collections.ArrayList.Count" /&gt;</ph>.</source>
          <target state="translated">O índice baseado em zero da <ph id="ph1">&lt;paramref name="value" /&gt;</ph> no <ph id="ph2">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> classificado se <ph id="ph3">&lt;paramref name="value" /&gt;</ph> for encontrado; caso contrário, um número negativo, que é o complemento bit a bit do índice do próximo elemento maior que <ph id="ph4">&lt;paramref name="value" /&gt;</ph> ou, se não houver nenhum elemento maior, o complemento bit a bit de <ph id="ph5">&lt;see cref="P:System.Collections.ArrayList.Count" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.BinarySearch(System.Object,System.Collections.IComparer)">
          <source>The comparer customizes how the elements are compared.</source>
          <target state="translated">A comparação personaliza como os elementos são comparados.</target>       </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.BinarySearch(System.Object,System.Collections.IComparer)">
          <source>For example, you can use a <ph id="ph1">&lt;xref:System.Collections.CaseInsensitiveComparer&gt;</ph> instance as the comparer to perform case-insensitive string searches.</source>
          <target state="translated">Por exemplo, você pode usar um <ph id="ph1">&lt;xref:System.Collections.CaseInsensitiveComparer&gt;</ph> instância como o comparador para executar pesquisas de cadeia de caracteres de maiusculas e minúsculas.</target>       </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.BinarySearch(System.Object,System.Collections.IComparer)">
          <source>If <ph id="ph1">`comparer`</ph> is provided, the elements of the <ph id="ph2">&lt;xref:System.Collections.ArrayList&gt;</ph> are compared to the specified value using the specified <ph id="ph3">&lt;xref:System.Collections.IComparer&gt;</ph> implementation.</source>
          <target state="translated">Se <ph id="ph1">`comparer`</ph> for fornecido, os elementos do <ph id="ph2">&lt;xref:System.Collections.ArrayList&gt;</ph> são comparados com o valor especificado usando especificado <ph id="ph3">&lt;xref:System.Collections.IComparer&gt;</ph> implementação.</target>       </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.BinarySearch(System.Object,System.Collections.IComparer)">
          <source>The elements of the <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph> must already be sorted in increasing value according to the sort order defined by <ph id="ph2">`comparer`</ph>; otherwise, the result might be incorrect.</source>
          <target state="translated">Os elementos do <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph> já devem ser classificados em aumentar o valor de acordo com a ordem de classificação definida pelo <ph id="ph2">`comparer`</ph>; caso contrário, o resultado pode estar incorreto.</target>       </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.BinarySearch(System.Object,System.Collections.IComparer)">
          <source>If <ph id="ph1">`comparer`</ph> is <ph id="ph2">`null`</ph>, the comparison is done using the <ph id="ph3">&lt;xref:System.IComparable&gt;</ph> implementation provided by the element itself or by the specified value.</source>
          <target state="translated">Caso <ph id="ph1">`comparer`</ph> seja <ph id="ph2">`null`</ph>, a comparação é feita usando-se a implementação de <ph id="ph3">&lt;xref:System.IComparable&gt;</ph> fornecida pelo próprio elemento ou pelo valor especificado.</target>       </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.BinarySearch(System.Object,System.Collections.IComparer)">
          <source>The elements of the <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph> must already be sorted in increasing value according to the sort order defined by the <ph id="ph2">&lt;xref:System.IComparable&gt;</ph> implementation; otherwise, the result might be incorrect.</source>
          <target state="translated">Os elementos do <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph> já devem ser classificados em aumentar o valor de acordo com a ordem de classificação definida pelo <ph id="ph2">&lt;xref:System.IComparable&gt;</ph> implementação; caso contrário, o resultado pode estar incorreto.</target>       </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.BinarySearch(System.Object,System.Collections.IComparer)">
          <source>Comparing <ph id="ph1">`null`</ph> with any type is allowed and does not generate an exception when using <ph id="ph2">&lt;xref:System.IComparable&gt;</ph>.</source>
          <target state="translated">Comparando <ph id="ph1">`null`</ph> com qualquer tipo é permitida e não gerará uma exceção ao usar <ph id="ph2">&lt;xref:System.IComparable&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.BinarySearch(System.Object,System.Collections.IComparer)">
          <source>When sorting, <ph id="ph1">`null`</ph> is considered to be less than any other object.</source>
          <target state="translated">Durante a classificação, <ph id="ph1">`null`</ph> é considerado menor que qualquer outro objeto.</target>       </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.BinarySearch(System.Object,System.Collections.IComparer)">
          <source>If the <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph> contains more than one element with the same value, the method returns only one of the occurrences, and it might return any one of the occurrences, not necessarily the first one.</source>
          <target state="translated">Se o <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph> contém mais de um elemento com o mesmo valor, o método retornará somente uma das ocorrências e pode retornar qualquer uma das ocorrências, não necessariamente o primeiro deles.</target>       </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.BinarySearch(System.Object,System.Collections.IComparer)">
          <source>If the <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph> does not contain the specified value, the method returns a negative integer.</source>
          <target state="translated">Caso o <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph> não contenha o valor especificado, o método retorna um inteiro negativo.</target>       </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.BinarySearch(System.Object,System.Collections.IComparer)">
          <source>You can apply the bitwise complement operation (~) to this negative integer to get the index of the first element that is larger than the search value.</source>
          <target state="translated">Você pode aplicar a operação de complemento bit a bit (~) para esse número inteiro negativo para obter o índice do primeiro elemento que é maior do que o valor de pesquisa.</target>       </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.BinarySearch(System.Object,System.Collections.IComparer)">
          <source>When inserting the value into the <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph>, this index should be used as the insertion point to maintain the sort order.</source>
          <target state="translated">Ao inserir o valor para o <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph>, esse índice deve ser usado como o ponto de inserção para manter a ordem de classificação.</target>       </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.BinarySearch(System.Object,System.Collections.IComparer)">
          <source>This method is an O(log <ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is <ph id="ph3">&lt;xref:System.Collections.ArrayList.Count%2A&gt;</ph>.</source>
          <target state="translated">Este método é uma operação O(log <ph id="ph1">`n`</ph>), em que <ph id="ph2">`n`</ph> é <ph id="ph3">&lt;xref:System.Collections.ArrayList.Count%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.BinarySearch(System.Object,System.Collections.IComparer)">
          <source>The following example creates an <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph> of colored animals.</source>
          <target state="translated">O exemplo a seguir cria um <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph> de animais coloridas.</target>       </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.BinarySearch(System.Object,System.Collections.IComparer)">
          <source>The provided <ph id="ph1">&lt;xref:System.Collections.IComparer&gt;</ph> performs the string comparison for the binary search.</source>
          <target state="translated">Fornecido <ph id="ph1">&lt;xref:System.Collections.IComparer&gt;</ph> executa a comparação de cadeia de caracteres para a pesquisa binária.</target>       </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.BinarySearch(System.Object,System.Collections.IComparer)">
          <source>The results of both an iterative search and a binary search are displayed.</source>
          <target state="translated">Os resultados de uma pesquisa iterativa e uma pesquisa binária são exibidos.</target>       </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.BinarySearch(System.Object,System.Collections.IComparer)">
          <source><ph id="ph1">&lt;paramref name="comparer" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph> and neither <ph id="ph3">&lt;paramref name="value" /&gt;</ph> nor the elements of <ph id="ph4">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> implement the <ph id="ph5">&lt;see cref="T:System.IComparable" /&gt;</ph> interface.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="comparer" /&gt;</ph> é <ph id="ph2">&lt;see langword="null" /&gt;</ph> e nem <ph id="ph3">&lt;paramref name="value" /&gt;</ph> ou os elementos de <ph id="ph4">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> implementam a interface <ph id="ph5">&lt;see cref="T:System.IComparable" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.BinarySearch(System.Object,System.Collections.IComparer)">
          <source><ph id="ph1">&lt;paramref name="comparer" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph> and <ph id="ph3">&lt;paramref name="value" /&gt;</ph> is not of the same type as the elements of the <ph id="ph4">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="comparer" /&gt;</ph> é <ph id="ph2">&lt;see langword="null" /&gt;</ph> e <ph id="ph3">&lt;paramref name="value" /&gt;</ph> não é do mesmo tipo que os elementos de <ph id="ph4">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.BinarySearch(System.Int32,System.Int32,System.Object,System.Collections.IComparer)">
          <source>The zero-based starting index of the range to search.</source>
          <target state="translated">O índice baseado em zero inicial do intervalo a ser pesquisado.</target>       </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.BinarySearch(System.Int32,System.Int32,System.Object,System.Collections.IComparer)">
          <source>The length of the range to search.</source>
          <target state="translated">O tamanho do intervalo a ser procurado.</target>       </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.BinarySearch(System.Int32,System.Int32,System.Object,System.Collections.IComparer)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Object" /&gt;</ph> to locate.</source>
          <target state="translated">O <ph id="ph1">&lt;see cref="T:System.Object" /&gt;</ph> a ser localizado.</target>       </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.BinarySearch(System.Int32,System.Int32,System.Object,System.Collections.IComparer)">
          <source>The value can be <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">O valor pode ser <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.BinarySearch(System.Int32,System.Int32,System.Object,System.Collections.IComparer)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.IComparer" /&gt;</ph> implementation to use when comparing elements.</source>
          <target state="translated">A implementação de <ph id="ph1">&lt;see cref="T:System.Collections.IComparer" /&gt;</ph> a ser usada durante a comparação de elementos.</target>       </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.BinarySearch(System.Int32,System.Int32,System.Object,System.Collections.IComparer)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.BinarySearch(System.Int32,System.Int32,System.Object,System.Collections.IComparer)">
          <source><ph id="ph1">&lt;see langword="null" /&gt;</ph> to use the default comparer that is the <ph id="ph2">&lt;see cref="T:System.IComparable" /&gt;</ph> implementation of each element.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="null" /&gt;</ph> para usar o comparador padrão que é a implementação <ph id="ph2">&lt;see cref="T:System.IComparable" /&gt;</ph> de cada elemento.</target>       </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.BinarySearch(System.Int32,System.Int32,System.Object,System.Collections.IComparer)">
          <source>Searches a range of elements in the sorted <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> for an element using the specified comparer and returns the zero-based index of the element.</source>
          <target state="translated">Pesquisa um intervalo de elementos no <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> classificado para encontrar um elemento que usa o comparador especificado e retorna o índice baseado em zero do elemento.</target>       </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.BinarySearch(System.Int32,System.Int32,System.Object,System.Collections.IComparer)">
          <source>The zero-based index of <ph id="ph1">&lt;paramref name="value" /&gt;</ph> in the sorted <ph id="ph2">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph>, if <ph id="ph3">&lt;paramref name="value" /&gt;</ph> is found; otherwise, a negative number, which is the bitwise complement of the index of the next element that is larger than <ph id="ph4">&lt;paramref name="value" /&gt;</ph> or, if there is no larger element, the bitwise complement of <ph id="ph5">&lt;see cref="P:System.Collections.ArrayList.Count" /&gt;</ph>.</source>
          <target state="translated">O índice baseado em zero da <ph id="ph1">&lt;paramref name="value" /&gt;</ph> no <ph id="ph2">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> classificado se <ph id="ph3">&lt;paramref name="value" /&gt;</ph> for encontrado; caso contrário, um número negativo, que é o complemento bit a bit do índice do próximo elemento maior que <ph id="ph4">&lt;paramref name="value" /&gt;</ph> ou, se não houver nenhum elemento maior, o complemento bit a bit de <ph id="ph5">&lt;see cref="P:System.Collections.ArrayList.Count" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.BinarySearch(System.Int32,System.Int32,System.Object,System.Collections.IComparer)">
          <source>The comparer customizes how the elements are compared.</source>
          <target state="translated">A comparação personaliza como os elementos são comparados.</target>       </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.BinarySearch(System.Int32,System.Int32,System.Object,System.Collections.IComparer)">
          <source>For example, you can use a <ph id="ph1">&lt;xref:System.Collections.CaseInsensitiveComparer&gt;</ph> instance as the comparer to perform case-insensitive string searches.</source>
          <target state="translated">Por exemplo, você pode usar um <ph id="ph1">&lt;xref:System.Collections.CaseInsensitiveComparer&gt;</ph> instância como o comparador para executar pesquisas de cadeia de caracteres de maiusculas e minúsculas.</target>       </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.BinarySearch(System.Int32,System.Int32,System.Object,System.Collections.IComparer)">
          <source>If <ph id="ph1">`comparer`</ph> is provided, the elements of the <ph id="ph2">&lt;xref:System.Collections.ArrayList&gt;</ph> are compared to the specified value using the specified <ph id="ph3">&lt;xref:System.Collections.IComparer&gt;</ph> implementation.</source>
          <target state="translated">Se <ph id="ph1">`comparer`</ph> for fornecido, os elementos do <ph id="ph2">&lt;xref:System.Collections.ArrayList&gt;</ph> são comparados com o valor especificado usando especificado <ph id="ph3">&lt;xref:System.Collections.IComparer&gt;</ph> implementação.</target>       </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.BinarySearch(System.Int32,System.Int32,System.Object,System.Collections.IComparer)">
          <source>The elements of the <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph> must already be sorted in increasing value according to the sort order defined by <ph id="ph2">`comparer`</ph>; otherwise, the result might be incorrect.</source>
          <target state="translated">Os elementos do <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph> já devem ser classificados em aumentar o valor de acordo com a ordem de classificação definida pelo <ph id="ph2">`comparer`</ph>; caso contrário, o resultado pode estar incorreto.</target>       </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.BinarySearch(System.Int32,System.Int32,System.Object,System.Collections.IComparer)">
          <source>If <ph id="ph1">`comparer`</ph> is <ph id="ph2">`null`</ph>, the comparison is done using the <ph id="ph3">&lt;xref:System.IComparable&gt;</ph> implementation provided by the element itself or by the specified value.</source>
          <target state="translated">Caso <ph id="ph1">`comparer`</ph> seja <ph id="ph2">`null`</ph>, a comparação é feita usando-se a implementação de <ph id="ph3">&lt;xref:System.IComparable&gt;</ph> fornecida pelo próprio elemento ou pelo valor especificado.</target>       </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.BinarySearch(System.Int32,System.Int32,System.Object,System.Collections.IComparer)">
          <source>The elements of the <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph> must already be sorted in increasing value according to the sort order defined by the <ph id="ph2">&lt;xref:System.IComparable&gt;</ph> implementation; otherwise, the result might be incorrect.</source>
          <target state="translated">Os elementos do <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph> já devem ser classificados em aumentar o valor de acordo com a ordem de classificação definida pelo <ph id="ph2">&lt;xref:System.IComparable&gt;</ph> implementação; caso contrário, o resultado pode estar incorreto.</target>       </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.BinarySearch(System.Int32,System.Int32,System.Object,System.Collections.IComparer)">
          <source>Comparing <ph id="ph1">`null`</ph> with any type is allowed and does not generate an exception when using <ph id="ph2">&lt;xref:System.IComparable&gt;</ph>.</source>
          <target state="translated">Comparando <ph id="ph1">`null`</ph> com qualquer tipo é permitida e não gerará uma exceção ao usar <ph id="ph2">&lt;xref:System.IComparable&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.BinarySearch(System.Int32,System.Int32,System.Object,System.Collections.IComparer)">
          <source>When sorting, <ph id="ph1">`null`</ph> is considered to be less than any other object.</source>
          <target state="translated">Durante a classificação, <ph id="ph1">`null`</ph> é considerado menor que qualquer outro objeto.</target>       </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.BinarySearch(System.Int32,System.Int32,System.Object,System.Collections.IComparer)">
          <source>If the <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph> contains more than one element with the same value, the method returns only one of the occurrences, and it might return any one of the occurrences, not necessarily the first one.</source>
          <target state="translated">Se o <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph> contém mais de um elemento com o mesmo valor, o método retornará somente uma das ocorrências e pode retornar qualquer uma das ocorrências, não necessariamente o primeiro deles.</target>       </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.BinarySearch(System.Int32,System.Int32,System.Object,System.Collections.IComparer)">
          <source>If the <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph> does not contain the specified value, the method returns a negative integer.</source>
          <target state="translated">Caso o <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph> não contenha o valor especificado, o método retorna um inteiro negativo.</target>       </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.BinarySearch(System.Int32,System.Int32,System.Object,System.Collections.IComparer)">
          <source>You can apply the bitwise complement operation (~) to this negative integer to get the index of the first element that is larger than the search value.</source>
          <target state="translated">Você pode aplicar a operação de complemento bit a bit (~) para esse número inteiro negativo para obter o índice do primeiro elemento que é maior do que o valor de pesquisa.</target>       </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.BinarySearch(System.Int32,System.Int32,System.Object,System.Collections.IComparer)">
          <source>When inserting the value into the <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph>, this index should be used as the insertion point to maintain the sort order.</source>
          <target state="translated">Ao inserir o valor para o <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph>, esse índice deve ser usado como o ponto de inserção para manter a ordem de classificação.</target>       </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.BinarySearch(System.Int32,System.Int32,System.Object,System.Collections.IComparer)">
          <source>This method is an O(log <ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is <ph id="ph3">`count`</ph>.</source>
          <target state="translated">Este método é uma operação O(log <ph id="ph1">`n`</ph>), em que <ph id="ph2">`n`</ph> é <ph id="ph3">`count`</ph>.</target>       </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.BinarySearch(System.Int32,System.Int32,System.Object,System.Collections.IComparer)">
          <source><ph id="ph1">&lt;paramref name="index" /&gt;</ph> and <ph id="ph2">&lt;paramref name="count" /&gt;</ph> do not denote a valid range in the <ph id="ph3">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="index" /&gt;</ph> e <ph id="ph2">&lt;paramref name="count" /&gt;</ph> não denotam um intervalo válido em <ph id="ph3">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.BinarySearch(System.Int32,System.Int32,System.Object,System.Collections.IComparer)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.BinarySearch(System.Int32,System.Int32,System.Object,System.Collections.IComparer)">
          <source><ph id="ph1">&lt;paramref name="comparer" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph> and neither <ph id="ph3">&lt;paramref name="value" /&gt;</ph> nor the elements of <ph id="ph4">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> implement the <ph id="ph5">&lt;see cref="T:System.IComparable" /&gt;</ph> interface.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="comparer" /&gt;</ph> é <ph id="ph2">&lt;see langword="null" /&gt;</ph> e nem <ph id="ph3">&lt;paramref name="value" /&gt;</ph> ou os elementos de <ph id="ph4">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> implementam a interface <ph id="ph5">&lt;see cref="T:System.IComparable" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.BinarySearch(System.Int32,System.Int32,System.Object,System.Collections.IComparer)">
          <source><ph id="ph1">&lt;paramref name="comparer" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph> and <ph id="ph3">&lt;paramref name="value" /&gt;</ph> is not of the same type as the elements of the <ph id="ph4">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="comparer" /&gt;</ph> é <ph id="ph2">&lt;see langword="null" /&gt;</ph> e <ph id="ph3">&lt;paramref name="value" /&gt;</ph> não é do mesmo tipo que os elementos de <ph id="ph4">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.BinarySearch(System.Int32,System.Int32,System.Object,System.Collections.IComparer)">
          <source><ph id="ph1">&lt;paramref name="index" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="index" /&gt;</ph> é menor que zero.</target>       </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.BinarySearch(System.Int32,System.Int32,System.Object,System.Collections.IComparer)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.BinarySearch(System.Int32,System.Int32,System.Object,System.Collections.IComparer)">
          <source><ph id="ph1">&lt;paramref name="count" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="count" /&gt;</ph> é menor que zero.</target>       </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve" uid="P:System.Collections.ArrayList.Capacity">
          <source>Gets or sets the number of elements that the <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> can contain.</source>
          <target state="translated">Obtém ou define o número de elementos que o <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> pode conter.</target>       </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.ArrayList.Capacity">
          <source>The number of elements that the <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> can contain.</source>
          <target state="translated">O número de elementos que o <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> pode conter.</target>       </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.ArrayList.Capacity">
          <source><ph id="ph1">&lt;xref:System.Collections.ArrayList.Capacity%2A&gt;</ph> is the number of elements that the <ph id="ph2">&lt;xref:System.Collections.ArrayList&gt;</ph> can store.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Collections.ArrayList.Capacity%2A&gt;</ph> é o número de elementos que o <ph id="ph2">&lt;xref:System.Collections.ArrayList&gt;</ph> pode armazenar.</target>       </trans-unit>
        <trans-unit id="260" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.ArrayList.Capacity">
          <source><ph id="ph1">&lt;xref:System.Collections.ArrayList.Count%2A&gt;</ph> is the number of elements that are actually in the <ph id="ph2">&lt;xref:System.Collections.ArrayList&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Collections.ArrayList.Count%2A&gt;</ph> é o número de elementos que estão realmente no <ph id="ph2">&lt;xref:System.Collections.ArrayList&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="261" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.ArrayList.Capacity">
          <source><ph id="ph1">&lt;xref:System.Collections.ArrayList.Capacity%2A&gt;</ph> is always greater than or equal to <ph id="ph2">&lt;xref:System.Collections.ArrayList.Count%2A&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Collections.ArrayList.Capacity%2A&gt;</ph> sempre é maior que ou igual a <ph id="ph2">&lt;xref:System.Collections.ArrayList.Count%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="262" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.ArrayList.Capacity">
          <source>If <ph id="ph1">&lt;xref:System.Collections.ArrayList.Count%2A&gt;</ph> exceeds <ph id="ph2">&lt;xref:System.Collections.ArrayList.Capacity%2A&gt;</ph> while adding elements, the capacity is automatically increased by reallocating the internal array before copying the old elements and adding the new elements.</source>
          <target state="translated">Se <ph id="ph1">&lt;xref:System.Collections.ArrayList.Count%2A&gt;</ph> excede <ph id="ph2">&lt;xref:System.Collections.ArrayList.Capacity%2A&gt;</ph> durante a adição de elementos, a capacidade é aumentada automaticamente realocando a matriz interna antes de copiar os elementos antigos e adição de novos elementos.</target>       </trans-unit>
        <trans-unit id="263" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.ArrayList.Capacity">
          <source>The capacity can be decreased by calling <ph id="ph1">&lt;xref:System.Collections.ArrayList.TrimToSize%2A&gt;</ph> or by setting the <ph id="ph2">&lt;xref:System.Collections.ArrayList.Capacity%2A&gt;</ph> property explicitly.</source>
          <target state="translated">A capacidade pode ser diminuída chamando <ph id="ph1">&lt;xref:System.Collections.ArrayList.TrimToSize%2A&gt;</ph> ou definindo o <ph id="ph2">&lt;xref:System.Collections.ArrayList.Capacity%2A&gt;</ph> propriedade explicitamente.</target>       </trans-unit>
        <trans-unit id="264" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.ArrayList.Capacity">
          <source>When the value of <ph id="ph1">&lt;xref:System.Collections.ArrayList.Capacity%2A&gt;</ph> is set explicitly, the internal array is also reallocated to accommodate the specified capacity.</source>
          <target state="translated">Quando o valor de <ph id="ph1">&lt;xref:System.Collections.ArrayList.Capacity%2A&gt;</ph> é definido explicitamente, a matriz interna também seja realocada para acomodar a capacidade especificada.</target>       </trans-unit>
        <trans-unit id="265" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.ArrayList.Capacity">
          <source>Retrieving the value of this property is an O(1) operation; setting the property is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is the new capacity.</source>
          <target state="translated">Recuperar o valor dessa propriedade é uma operação de (1); configuração da propriedade é um O (<ph id="ph1">`n`</ph>) operação, onde <ph id="ph2">`n`</ph> é a nova capacidade.</target>       </trans-unit>
        <trans-unit id="266" translate="yes" xml:space="preserve" uid="P:System.Collections.ArrayList.Capacity">
          <source><ph id="ph1">&lt;see cref="P:System.Collections.ArrayList.Capacity" /&gt;</ph> is set to a value that is less than <ph id="ph2">&lt;see cref="P:System.Collections.ArrayList.Count" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="P:System.Collections.ArrayList.Capacity" /&gt;</ph> é definido como um valor menor que <ph id="ph2">&lt;see cref="P:System.Collections.ArrayList.Count" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="267" translate="yes" xml:space="preserve" uid="P:System.Collections.ArrayList.Capacity">
          <source>There is not enough memory available on the system.</source>
          <target state="translated">Não há memória suficiente disponível no sistema.</target>       </trans-unit>
        <trans-unit id="268" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.Clear">
          <source>Removes all elements from the <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph>.</source>
          <target state="translated">Remove todos os elementos do <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="269" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.Clear">
          <source><ph id="ph1">&lt;xref:System.Collections.ArrayList.Count%2A&gt;</ph> is set to zero, and references to other objects from elements of the collection are also released.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Collections.ArrayList.Count%2A&gt;</ph> é definido como zero, e referências a outros objetos de elementos da coleção também são liberadas.</target>       </trans-unit>
        <trans-unit id="270" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.Clear">
          <source><ph id="ph1">&lt;xref:System.Collections.ArrayList.Capacity%2A&gt;</ph> remains unchanged.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Collections.ArrayList.Capacity%2A&gt;</ph> permanece inalterado.</target>       </trans-unit>
        <trans-unit id="271" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.Clear">
          <source>To reset the capacity of the <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph>, call <ph id="ph2">&lt;xref:System.Collections.ArrayList.TrimToSize%2A&gt;</ph> or set the <ph id="ph3">&lt;xref:System.Collections.ArrayList.Capacity%2A&gt;</ph> property directly.</source>
          <target state="translated">Para redefinir a capacidade do <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph>, chame <ph id="ph2">&lt;xref:System.Collections.ArrayList.TrimToSize%2A&gt;</ph> ou defina o <ph id="ph3">&lt;xref:System.Collections.ArrayList.Capacity%2A&gt;</ph> propriedade diretamente.</target>       </trans-unit>
        <trans-unit id="272" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.Clear">
          <source>Trimming an empty <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph> sets the capacity of the <ph id="ph2">&lt;xref:System.Collections.ArrayList&gt;</ph> to the default capacity.</source>
          <target state="translated">Cortar vazio <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph> define a capacidade do <ph id="ph2">&lt;xref:System.Collections.ArrayList&gt;</ph> à capacidade padrão.</target>       </trans-unit>
        <trans-unit id="273" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.Clear">
          <source>This method is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is <ph id="ph3">&lt;xref:System.Collections.ArrayList.Count%2A&gt;</ph>.</source>
          <target state="translated">Este método é uma operação O(<ph id="ph1">`n`</ph>), em que <ph id="ph2">`n`</ph> é <ph id="ph3">&lt;xref:System.Collections.ArrayList.Count%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="274" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.Clear">
          <source>The following code example shows how to trim the unused portions of the <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph> and how to clear the values of the <ph id="ph2">&lt;xref:System.Collections.ArrayList&gt;</ph>.</source>
          <target state="translated">O exemplo de código a seguir mostra como cortar as partes não utilizadas do <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph> e como limpar os valores a <ph id="ph2">&lt;xref:System.Collections.ArrayList&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="275" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.Clear">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> is read-only.</source>
          <target state="translated">O <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> é somente leitura.</target>       </trans-unit>
        <trans-unit id="276" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.Clear">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="277" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.Clear">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> has a fixed size.</source>
          <target state="translated">O <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> tem um tamanho fixo.</target>       </trans-unit>
        <trans-unit id="278" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.Clone">
          <source>Creates a shallow copy of the <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph>.</source>
          <target state="translated">Cria uma cópia superficial do <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="279" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.Clone">
          <source>A shallow copy of the <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph>.</source>
          <target state="translated">Uma cópia superficial do <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="280" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.Clone">
          <source>A shallow copy of a collection copies only the elements of the collection, whether they are reference types or value types, but it does not copy the objects that the references refer to.</source>
          <target state="translated">Uma cópia superficial de uma coleção copia apenas os elementos da coleção, se eles são tipos de referência ou tipos de valor, mas não copia os objetos que se referem as referências a.</target>       </trans-unit>
        <trans-unit id="281" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.Clone">
          <source>The references in the new collection point to the same objects that the references in the original collection point to.</source>
          <target state="translated">As referências na nova coleção apontam para os mesmos objetos que as referências na coleção original apontem para.</target>       </trans-unit>
        <trans-unit id="282" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.Clone">
          <source>In contrast, a deep copy of a collection copies the elements and everything directly or indirectly referenced by the elements.</source>
          <target state="translated">Em contraste, uma cópia profunda de uma coleção copia os elementos e tudo direta ou indiretamente referenciado por elementos.</target>       </trans-unit>
        <trans-unit id="283" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.Clone">
          <source>This method is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is <ph id="ph3">&lt;xref:System.Collections.ArrayList.Count%2A&gt;</ph>.</source>
          <target state="translated">Este método é uma operação O(<ph id="ph1">`n`</ph>), em que <ph id="ph2">`n`</ph> é <ph id="ph3">&lt;xref:System.Collections.ArrayList.Count%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="284" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.Contains(System.Object)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Object" /&gt;</ph> to locate in the <ph id="ph2">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph>.</source>
          <target state="translated">O <ph id="ph1">&lt;see cref="T:System.Object" /&gt;</ph> a ser localizado no <ph id="ph2">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="285" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.Contains(System.Object)">
          <source>The value can be <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">O valor pode ser <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="286" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.Contains(System.Object)">
          <source>Determines whether an element is in the <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph>.</source>
          <target state="translated">Determina se um elemento está no <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="287" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.Contains(System.Object)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if <ph id="ph2">&lt;paramref name="item" /&gt;</ph> is found in the <ph id="ph3">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph>; otherwise, <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> se <ph id="ph2">&lt;paramref name="item" /&gt;</ph> for encontrado no <ph id="ph3">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph>; caso contrário, <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="288" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.Contains(System.Object)">
          <source>This method performs a linear search; therefore, this method is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is <ph id="ph3">&lt;xref:System.Collections.ArrayList.Count%2A&gt;</ph>.</source>
          <target state="translated">Este método executa uma pesquisa linear; por isso, esse método é uma operação O(<ph id="ph1">`n`</ph>), em que <ph id="ph2">`n`</ph> é <ph id="ph3">&lt;xref:System.Collections.ArrayList.Count%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="289" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.Contains(System.Object)">
          <source>This method determines equality by calling <ph id="ph1">&lt;xref:System.Object.Equals%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Este método determina a igualdade chamando <ph id="ph1">&lt;xref:System.Object.Equals%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="290" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.Contains(System.Object)">
          <source>Starting with the .NET Framework 2.0, this method uses the collection’s objects’ <ph id="ph1">&lt;xref:System.Object.Equals%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.IComparable.CompareTo%2A&gt;</ph> methods on <ph id="ph3">`item`</ph> to determine whether item exists.</source>
          <target state="translated">Começando pelo .NET Framework 2.0, esse método usa os métodos <ph id="ph1">&lt;xref:System.Object.Equals%2A&gt;</ph> e <ph id="ph2">&lt;xref:System.IComparable.CompareTo%2A&gt;</ph> do objeto da coleção em <ph id="ph3">`item`</ph> para determinar se o item existe.</target>       </trans-unit>
        <trans-unit id="291" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.Contains(System.Object)">
          <source>In the earlier versions of the .NET Framework, this determination was made by using the <ph id="ph1">&lt;xref:System.Object.Equals%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.IComparable.CompareTo%2A&gt;</ph> methods of the <ph id="ph3">`item`</ph> parameter on the objects in the collection.</source>
          <target state="translated">Em versões anteriores do .NET Framework, essa decisão era tomada usando-se os métodos <ph id="ph1">&lt;xref:System.Object.Equals%2A&gt;</ph> e <ph id="ph2">&lt;xref:System.IComparable.CompareTo%2A&gt;</ph> do parâmetro <ph id="ph3">`item`</ph> nos objetos na coleção.</target>       </trans-unit>
        <trans-unit id="292" translate="yes" xml:space="preserve" uid="T:System.Collections.ArrayList">
          <source>Copies the <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> or a portion of it to a one-dimensional array.</source>
          <target state="translated">Copia o <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph>, ou parte dele, para uma matriz unidimensional.</target>       </trans-unit>
        <trans-unit id="293" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.CopyTo(System.Array)">
          <source>The one-dimensional <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> that is the destination of the elements copied from <ph id="ph2">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph>.</source>
          <target state="translated">O <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> unidimensional que é o destino dos elementos copiados de <ph id="ph2">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="294" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.CopyTo(System.Array)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> must have zero-based indexing.</source>
          <target state="translated">O <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> deve ter indexação com base em zero.</target>       </trans-unit>
        <trans-unit id="295" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.CopyTo(System.Array)">
          <source>Copies the entire <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> to a compatible one-dimensional <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph>, starting at the beginning of the target array.</source>
          <target state="translated">Copia todo o <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> para um <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph> unidimensional compatível, a partir do início da matriz de destino.</target>       </trans-unit>
        <trans-unit id="296" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.CopyTo(System.Array)">
          <source>The specified array must be of a compatible type.</source>
          <target state="translated">A matriz especificada deve ser de um tipo compatível.</target>       </trans-unit>
        <trans-unit id="297" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.CopyTo(System.Array)">
          <source>This method uses <ph id="ph1">&lt;xref:System.Array.Copy%2A?displayProperty=nameWithType&gt;</ph> to copy the elements.</source>
          <target state="translated">Este método usa <ph id="ph1">&lt;xref:System.Array.Copy%2A?displayProperty=nameWithType&gt;</ph> para copiar os elementos.</target>       </trans-unit>
        <trans-unit id="298" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.CopyTo(System.Array)">
          <source>The elements are copied to the <ph id="ph1">&lt;xref:System.Array&gt;</ph> in the same order in which the enumerator iterates through the <ph id="ph2">&lt;xref:System.Collections.ArrayList&gt;</ph>.</source>
          <target state="translated">Os elementos são copiados para o <ph id="ph1">&lt;xref:System.Array&gt;</ph> na mesma ordem em que o enumerador que itera por meio de <ph id="ph2">&lt;xref:System.Collections.ArrayList&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="299" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.CopyTo(System.Array)">
          <source>This method is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is <ph id="ph3">&lt;xref:System.Collections.ArrayList.Count%2A&gt;</ph>.</source>
          <target state="translated">Este método é uma operação O(<ph id="ph1">`n`</ph>), em que <ph id="ph2">`n`</ph> é <ph id="ph3">&lt;xref:System.Collections.ArrayList.Count%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="300" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.CopyTo(System.Array)">
          <source>The following code example shows how to copy an <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph> into a one-dimensional <ph id="ph2">&lt;xref:System.Array?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">O exemplo de código a seguir mostra como copiar um <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph> em um unidimensional <ph id="ph2">&lt;xref:System.Array?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="301" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.CopyTo(System.Array)">
          <source><ph id="ph1">&lt;paramref name="array" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="array" /&gt;</ph> é <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="302" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.CopyTo(System.Array)">
          <source><ph id="ph1">&lt;paramref name="array" /&gt;</ph> is multidimensional.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="array" /&gt;</ph> é multidimensional.</target>       </trans-unit>
        <trans-unit id="303" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.CopyTo(System.Array)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="304" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.CopyTo(System.Array)">
          <source>The number of elements in the source <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> is greater than the number of elements that the destination <ph id="ph2">&lt;paramref name="array" /&gt;</ph> can contain.</source>
          <target state="translated">O número de elementos no <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> de origem é maior que o número de elementos que o <ph id="ph2">&lt;paramref name="array" /&gt;</ph> de destino pode conter.</target>       </trans-unit>
        <trans-unit id="305" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.CopyTo(System.Array)">
          <source>The type of the source <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> cannot be cast automatically to the type of the destination <ph id="ph2">&lt;paramref name="array" /&gt;</ph>.</source>
          <target state="translated">O tipo do <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> de origem não pode ser automaticamente convertido para o tipo de <ph id="ph2">&lt;paramref name="array" /&gt;</ph> de destino.</target>       </trans-unit>
        <trans-unit id="306" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.CopyTo(System.Array,System.Int32)">
          <source>The one-dimensional <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> that is the destination of the elements copied from <ph id="ph2">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph>.</source>
          <target state="translated">O <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> unidimensional que é o destino dos elementos copiados de <ph id="ph2">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="307" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.CopyTo(System.Array,System.Int32)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> must have zero-based indexing.</source>
          <target state="translated">O <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> deve ter indexação com base em zero.</target>       </trans-unit>
        <trans-unit id="308" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.CopyTo(System.Array,System.Int32)">
          <source>The zero-based index in <bpt id="p1">&lt;c&gt;</bpt>array<ept id="p1">&lt;/c&gt;</ept> at which copying begins.</source>
          <target state="translated">O índice baseado em zero na <bpt id="p1">&lt;c&gt;</bpt>array<ept id="p1">&lt;/c&gt;</ept> na qual a cópia começa.</target>       </trans-unit>
        <trans-unit id="309" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.CopyTo(System.Array,System.Int32)">
          <source>Copies the entire <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> to a compatible one-dimensional <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph>, starting at the specified index of the target array.</source>
          <target state="translated">Copia todo o <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> em um <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph> unidimensional compatível, começando no índice especificado da matriz de destino.</target>       </trans-unit>
        <trans-unit id="310" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.CopyTo(System.Array,System.Int32)">
          <source>The specified array must be of a compatible type.</source>
          <target state="translated">A matriz especificada deve ser de um tipo compatível.</target>       </trans-unit>
        <trans-unit id="311" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.CopyTo(System.Array,System.Int32)">
          <source>This method uses <ph id="ph1">&lt;xref:System.Array.Copy%2A?displayProperty=nameWithType&gt;</ph> to copy the elements.</source>
          <target state="translated">Este método usa <ph id="ph1">&lt;xref:System.Array.Copy%2A?displayProperty=nameWithType&gt;</ph> para copiar os elementos.</target>       </trans-unit>
        <trans-unit id="312" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.CopyTo(System.Array,System.Int32)">
          <source>The elements are copied to the <ph id="ph1">&lt;xref:System.Array&gt;</ph> in the same order in which the enumerator iterates through the <ph id="ph2">&lt;xref:System.Collections.ArrayList&gt;</ph>.</source>
          <target state="translated">Os elementos são copiados para o <ph id="ph1">&lt;xref:System.Array&gt;</ph> na mesma ordem em que o enumerador que itera por meio de <ph id="ph2">&lt;xref:System.Collections.ArrayList&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="313" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.CopyTo(System.Array,System.Int32)">
          <source>This method is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is <ph id="ph3">&lt;xref:System.Collections.ArrayList.Count%2A&gt;</ph>.</source>
          <target state="translated">Este método é uma operação O(<ph id="ph1">`n`</ph>), em que <ph id="ph2">`n`</ph> é <ph id="ph3">&lt;xref:System.Collections.ArrayList.Count%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="314" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.CopyTo(System.Array,System.Int32)">
          <source>The following code example shows how to copy an <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph> into a one-dimensional <ph id="ph2">&lt;xref:System.Array?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">O exemplo de código a seguir mostra como copiar um <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph> em um unidimensional <ph id="ph2">&lt;xref:System.Array?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="315" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.CopyTo(System.Array,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="array" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="array" /&gt;</ph> é <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="316" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.CopyTo(System.Array,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="arrayIndex" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="arrayIndex" /&gt;</ph> é menor que zero.</target>       </trans-unit>
        <trans-unit id="317" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.CopyTo(System.Array,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="array" /&gt;</ph> is multidimensional.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="array" /&gt;</ph> é multidimensional.</target>       </trans-unit>
        <trans-unit id="318" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.CopyTo(System.Array,System.Int32)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="319" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.CopyTo(System.Array,System.Int32)">
          <source>The number of elements in the source <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> is greater than the available space from <ph id="ph2">&lt;paramref name="arrayIndex" /&gt;</ph> to the end of the destination <ph id="ph3">&lt;paramref name="array" /&gt;</ph>.</source>
          <target state="translated">O número de elementos na origem <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> é maior do que o espaço disponível de <ph id="ph2">&lt;paramref name="arrayIndex" /&gt;</ph> até o final do <ph id="ph3">&lt;paramref name="array" /&gt;</ph> de destino.</target>       </trans-unit>
        <trans-unit id="320" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.CopyTo(System.Array,System.Int32)">
          <source>The type of the source <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> cannot be cast automatically to the type of the destination <ph id="ph2">&lt;paramref name="array" /&gt;</ph>.</source>
          <target state="translated">O tipo do <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> de origem não pode ser automaticamente convertido para o tipo de <ph id="ph2">&lt;paramref name="array" /&gt;</ph> de destino.</target>       </trans-unit>
        <trans-unit id="321" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.CopyTo(System.Int32,System.Array,System.Int32,System.Int32)">
          <source>The zero-based index in the source <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> at which copying begins.</source>
          <target state="translated">O índice baseado em zero no <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> de origem em que a cópia começa.</target>       </trans-unit>
        <trans-unit id="322" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.CopyTo(System.Int32,System.Array,System.Int32,System.Int32)">
          <source>The one-dimensional <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> that is the destination of the elements copied from <ph id="ph2">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph>.</source>
          <target state="translated">O <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> unidimensional que é o destino dos elementos copiados de <ph id="ph2">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="323" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.CopyTo(System.Int32,System.Array,System.Int32,System.Int32)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> must have zero-based indexing.</source>
          <target state="translated">O <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> deve ter indexação com base em zero.</target>       </trans-unit>
        <trans-unit id="324" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.CopyTo(System.Int32,System.Array,System.Int32,System.Int32)">
          <source>The zero-based index in <bpt id="p1">&lt;c&gt;</bpt>array<ept id="p1">&lt;/c&gt;</ept> at which copying begins.</source>
          <target state="translated">O índice baseado em zero na <bpt id="p1">&lt;c&gt;</bpt>array<ept id="p1">&lt;/c&gt;</ept> na qual a cópia começa.</target>       </trans-unit>
        <trans-unit id="325" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.CopyTo(System.Int32,System.Array,System.Int32,System.Int32)">
          <source>The number of elements to copy.</source>
          <target state="translated">O número de elementos a serem copiados.</target>       </trans-unit>
        <trans-unit id="326" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.CopyTo(System.Int32,System.Array,System.Int32,System.Int32)">
          <source>Copies a range of elements from the <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> to a compatible one-dimensional <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph>, starting at the specified index of the target array.</source>
          <target state="translated">Copia um intervalo de elementos do <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> para um <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph> unidimensional compatível, começando pelo índice especificado da matriz de destino.</target>       </trans-unit>
        <trans-unit id="327" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.CopyTo(System.Int32,System.Array,System.Int32,System.Int32)">
          <source>The specified array must be of a compatible type.</source>
          <target state="translated">A matriz especificada deve ser de um tipo compatível.</target>       </trans-unit>
        <trans-unit id="328" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.CopyTo(System.Int32,System.Array,System.Int32,System.Int32)">
          <source>This method uses <ph id="ph1">&lt;xref:System.Array.Copy%2A?displayProperty=nameWithType&gt;</ph> to copy the elements.</source>
          <target state="translated">Este método usa <ph id="ph1">&lt;xref:System.Array.Copy%2A?displayProperty=nameWithType&gt;</ph> para copiar os elementos.</target>       </trans-unit>
        <trans-unit id="329" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.CopyTo(System.Int32,System.Array,System.Int32,System.Int32)">
          <source>The elements are copied to the <ph id="ph1">&lt;xref:System.Array&gt;</ph> in the same order in which the enumerator iterates through the <ph id="ph2">&lt;xref:System.Collections.ArrayList&gt;</ph>.</source>
          <target state="translated">Os elementos são copiados para o <ph id="ph1">&lt;xref:System.Array&gt;</ph> na mesma ordem em que o enumerador que itera por meio de <ph id="ph2">&lt;xref:System.Collections.ArrayList&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="330" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.CopyTo(System.Int32,System.Array,System.Int32,System.Int32)">
          <source>This method is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is <ph id="ph3">`count`</ph>.</source>
          <target state="translated">Este método é uma operação O(<ph id="ph1">`n`</ph>), em que <ph id="ph2">`n`</ph> é <ph id="ph3">`count`</ph>.</target>       </trans-unit>
        <trans-unit id="331" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.CopyTo(System.Int32,System.Array,System.Int32,System.Int32)">
          <source>The following code example shows how to copy an <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph> into a one-dimensional <ph id="ph2">&lt;xref:System.Array?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">O exemplo de código a seguir mostra como copiar um <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph> em um unidimensional <ph id="ph2">&lt;xref:System.Array?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="332" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.CopyTo(System.Int32,System.Array,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="array" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="array" /&gt;</ph> é <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="333" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.CopyTo(System.Int32,System.Array,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="index" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="index" /&gt;</ph> é menor que zero.</target>       </trans-unit>
        <trans-unit id="334" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.CopyTo(System.Int32,System.Array,System.Int32,System.Int32)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="335" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.CopyTo(System.Int32,System.Array,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="arrayIndex" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="arrayIndex" /&gt;</ph> é menor que zero.</target>       </trans-unit>
        <trans-unit id="336" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.CopyTo(System.Int32,System.Array,System.Int32,System.Int32)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="337" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.CopyTo(System.Int32,System.Array,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="count" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="count" /&gt;</ph> é menor que zero.</target>       </trans-unit>
        <trans-unit id="338" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.CopyTo(System.Int32,System.Array,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="array" /&gt;</ph> is multidimensional.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="array" /&gt;</ph> é multidimensional.</target>       </trans-unit>
        <trans-unit id="339" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.CopyTo(System.Int32,System.Array,System.Int32,System.Int32)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="340" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.CopyTo(System.Int32,System.Array,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="index" /&gt;</ph> is equal to or greater than the <ph id="ph2">&lt;see cref="P:System.Collections.ArrayList.Count" /&gt;</ph> of the source <ph id="ph3">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="index" /&gt;</ph> é igual a ou maior que o <ph id="ph2">&lt;see cref="P:System.Collections.ArrayList.Count" /&gt;</ph> do <ph id="ph3">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> de origem.</target>       </trans-unit>
        <trans-unit id="341" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.CopyTo(System.Int32,System.Array,System.Int32,System.Int32)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="342" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.CopyTo(System.Int32,System.Array,System.Int32,System.Int32)">
          <source>The number of elements from <ph id="ph1">&lt;paramref name="index" /&gt;</ph> to the end of the source <ph id="ph2">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> is greater than the available space from <ph id="ph3">&lt;paramref name="arrayIndex" /&gt;</ph> to the end of the destination <ph id="ph4">&lt;paramref name="array" /&gt;</ph>.</source>
          <target state="translated">O número de elementos de <ph id="ph1">&lt;paramref name="index" /&gt;</ph> até o final do <ph id="ph2">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> de origem é maior que o espaço disponível do <ph id="ph3">&lt;paramref name="arrayIndex" /&gt;</ph> até o final do <ph id="ph4">&lt;paramref name="array" /&gt;</ph> de destino.</target>       </trans-unit>
        <trans-unit id="343" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.CopyTo(System.Int32,System.Array,System.Int32,System.Int32)">
          <source>The type of the source <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> cannot be cast automatically to the type of the destination <ph id="ph2">&lt;paramref name="array" /&gt;</ph>.</source>
          <target state="translated">O tipo do <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> de origem não pode ser automaticamente convertido para o tipo de <ph id="ph2">&lt;paramref name="array" /&gt;</ph> de destino.</target>       </trans-unit>
        <trans-unit id="344" translate="yes" xml:space="preserve" uid="P:System.Collections.ArrayList.Count">
          <source>Gets the number of elements actually contained in the <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph>.</source>
          <target state="translated">Obtém o número de elementos realmente contidos no <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="345" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.ArrayList.Count">
          <source>The number of elements actually contained in the <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph>.</source>
          <target state="translated">O número de elementos realmente contidos no <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="346" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.ArrayList.Count">
          <source><ph id="ph1">&lt;xref:System.Collections.ArrayList.Capacity%2A&gt;</ph> is the number of elements that the <ph id="ph2">&lt;xref:System.Collections.ArrayList&gt;</ph> can store.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Collections.ArrayList.Capacity%2A&gt;</ph> é o número de elementos que o <ph id="ph2">&lt;xref:System.Collections.ArrayList&gt;</ph> pode armazenar.</target>       </trans-unit>
        <trans-unit id="347" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.ArrayList.Count">
          <source><ph id="ph1">&lt;xref:System.Collections.ArrayList.Count%2A&gt;</ph> is the number of elements that are actually in the <ph id="ph2">&lt;xref:System.Collections.ArrayList&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Collections.ArrayList.Count%2A&gt;</ph> é o número de elementos que estão realmente no <ph id="ph2">&lt;xref:System.Collections.ArrayList&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="348" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.ArrayList.Count">
          <source><ph id="ph1">&lt;xref:System.Collections.ArrayList.Capacity%2A&gt;</ph> is always greater than or equal to <ph id="ph2">&lt;xref:System.Collections.ArrayList.Count%2A&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Collections.ArrayList.Capacity%2A&gt;</ph> sempre é maior que ou igual a <ph id="ph2">&lt;xref:System.Collections.ArrayList.Count%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="349" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.ArrayList.Count">
          <source>If <ph id="ph1">&lt;xref:System.Collections.ArrayList.Count%2A&gt;</ph> exceeds <ph id="ph2">&lt;xref:System.Collections.ArrayList.Capacity%2A&gt;</ph> while adding elements, the capacity is automatically increased by reallocating the internal array before copying the old elements and adding the new elements.</source>
          <target state="translated">Se <ph id="ph1">&lt;xref:System.Collections.ArrayList.Count%2A&gt;</ph> excede <ph id="ph2">&lt;xref:System.Collections.ArrayList.Capacity%2A&gt;</ph> durante a adição de elementos, a capacidade é aumentada automaticamente realocando a matriz interna antes de copiar os elementos antigos e adição de novos elementos.</target>       </trans-unit>
        <trans-unit id="350" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.ArrayList.Count">
          <source>Retrieving the value of this property is an O(1) operation.</source>
          <target state="translated">A recuperação do valor dessa propriedade é uma operação O(1).</target>       </trans-unit>
        <trans-unit id="351" translate="yes" xml:space="preserve" uid="T:System.Collections.ArrayList">
          <source>Returns a list wrapper with a fixed size, where elements are allowed to be modified, but not added or removed.</source>
          <target state="translated">Retorna um wrapper de lista com um tamanho fixo, em que os elementos podem ser modificados, mas não adicionados nem removidos.</target>       </trans-unit>
        <trans-unit id="352" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.FixedSize(System.Collections.ArrayList)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> to wrap.</source>
          <target state="translated">O <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> a ser encapsulado.</target>       </trans-unit>
        <trans-unit id="353" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.FixedSize(System.Collections.ArrayList)">
          <source>Returns an <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> wrapper with a fixed size.</source>
          <target state="translated">Retorna um wrapper <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> com um tamanho fixo.</target>       </trans-unit>
        <trans-unit id="354" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.FixedSize(System.Collections.ArrayList)">
          <source>An <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> wrapper with a fixed size.</source>
          <target state="translated">Um wrapper <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> com um tamanho fixo.</target>       </trans-unit>
        <trans-unit id="355" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.FixedSize(System.Collections.ArrayList)">
          <source>This wrapper can be used to prevent additions to and deletions from the original <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph>.</source>
          <target state="translated">Esse wrapper pode ser usado para impedir inclusões e exclusões de original <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="356" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.FixedSize(System.Collections.ArrayList)">
          <source>The elements can still be modified or replaced.</source>
          <target state="translated">Os elementos ainda podem ser modificados ou substituídos.</target>       </trans-unit>
        <trans-unit id="357" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.FixedSize(System.Collections.ArrayList)">
          <source>A collection with a fixed size is simply a collection with a wrapper that prevents adding and removing elements; therefore, if changes are made to the underlying collection, including the addition or removal of elements, the fixed-size collection reflects those changes.</source>
          <target state="translated">Uma coleção com um tamanho fixo é simplesmente uma coleção com um wrapper que impede a adição e a remoção de elementos; por isso, caso as alterações sejam feitas na coleção subjacente, inclusive a adição ou a remoção de elementos, a coleção de tamanho fixo reflete essas alterações.</target>       </trans-unit>
        <trans-unit id="358" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.FixedSize(System.Collections.ArrayList)">
          <source>This method is an O(1) operation.</source>
          <target state="translated">Este método é uma operação O(1).</target>       </trans-unit>
        <trans-unit id="359" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.FixedSize(System.Collections.ArrayList)">
          <source>The following code example shows how to create a fixed-size wrapper around an <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph>.</source>
          <target state="translated">O exemplo de código a seguir mostra como criar um wrapper de tamanho fixo para um <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="360" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.FixedSize(System.Collections.ArrayList)">
          <source><ph id="ph1">&lt;paramref name="list" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="list" /&gt;</ph> é <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="361" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.FixedSize(System.Collections.IList)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.IList" /&gt;</ph> to wrap.</source>
          <target state="translated">O <ph id="ph1">&lt;see cref="T:System.Collections.IList" /&gt;</ph> a ser encapsulado.</target>       </trans-unit>
        <trans-unit id="362" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.FixedSize(System.Collections.IList)">
          <source>Returns an <ph id="ph1">&lt;see cref="T:System.Collections.IList" /&gt;</ph> wrapper with a fixed size.</source>
          <target state="translated">Retorna um wrapper <ph id="ph1">&lt;see cref="T:System.Collections.IList" /&gt;</ph> com um tamanho fixo.</target>       </trans-unit>
        <trans-unit id="363" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.FixedSize(System.Collections.IList)">
          <source>An <ph id="ph1">&lt;see cref="T:System.Collections.IList" /&gt;</ph> wrapper with a fixed size.</source>
          <target state="translated">Um wrapper <ph id="ph1">&lt;see cref="T:System.Collections.IList" /&gt;</ph> com um tamanho fixo.</target>       </trans-unit>
        <trans-unit id="364" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.FixedSize(System.Collections.IList)">
          <source>This wrapper can be used to prevent additions to and deletions from the original <ph id="ph1">&lt;xref:System.Collections.IList&gt;</ph>.</source>
          <target state="translated">Esse wrapper pode ser usado para impedir inclusões e exclusões de original <ph id="ph1">&lt;xref:System.Collections.IList&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="365" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.FixedSize(System.Collections.IList)">
          <source>The elements can still be modified or replaced.</source>
          <target state="translated">Os elementos ainda podem ser modificados ou substituídos.</target>       </trans-unit>
        <trans-unit id="366" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.FixedSize(System.Collections.IList)">
          <source>A collection with a fixed size is simply a collection with a wrapper that prevents adding and removing elements; therefore, if changes are made to the underlying collection, including the addition or removal of elements, the fixed-size collection reflects those changes.</source>
          <target state="translated">Uma coleção com um tamanho fixo é simplesmente uma coleção com um wrapper que impede a adição e a remoção de elementos; por isso, caso as alterações sejam feitas na coleção subjacente, inclusive a adição ou a remoção de elementos, a coleção de tamanho fixo reflete essas alterações.</target>       </trans-unit>
        <trans-unit id="367" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.FixedSize(System.Collections.IList)">
          <source>This method is an O(1) operation.</source>
          <target state="translated">Este método é uma operação O(1).</target>       </trans-unit>
        <trans-unit id="368" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.FixedSize(System.Collections.IList)">
          <source><ph id="ph1">&lt;paramref name="list" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="list" /&gt;</ph> é <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="369" translate="yes" xml:space="preserve" uid="T:System.Collections.ArrayList">
          <source>Returns an enumerator that iterates through the <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph>.</source>
          <target state="translated">Retorna um enumerador que itera por meio de <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="370" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.GetEnumerator">
          <source>Returns an enumerator for the entire <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph>.</source>
          <target state="translated">Retorna um enumerador para todo o <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="371" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.GetEnumerator">
          <source>An <ph id="ph1">&lt;see cref="T:System.Collections.IEnumerator" /&gt;</ph> for the entire <ph id="ph2">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph>.</source>
          <target state="translated">Um <ph id="ph1">&lt;see cref="T:System.Collections.IEnumerator" /&gt;</ph> para todo o <ph id="ph2">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="372" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.GetEnumerator">
          <source>The <ph id="ph1">`foreach`</ph> statement of the C# language (<ph id="ph2">`for each`</ph> in Visual Basic) hides the complexity of the enumerators.</source>
          <target state="translated">O <ph id="ph1">`foreach`</ph> instrução de linguagem c# (<ph id="ph2">`for each`</ph> no Visual Basic) oculta a complexidade dos enumeradores.</target>       </trans-unit>
        <trans-unit id="373" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.GetEnumerator">
          <source>Therefore, using <ph id="ph1">`foreach`</ph> is recommended, instead of directly manipulating the enumerator.</source>
          <target state="translated">Portanto, o uso de <ph id="ph1">`foreach`</ph> é recomendado, em vez de manipular diretamente o enumerador.</target>       </trans-unit>
        <trans-unit id="374" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.GetEnumerator">
          <source>Enumerators can be used to read the data in the collection, but they cannot be used to modify the underlying collection.</source>
          <target state="translated">Os enumeradores podem ser usados para ler os dados na coleção, mas não podem ser usados para modificar a coleção subjacente.</target>       </trans-unit>
        <trans-unit id="375" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.GetEnumerator">
          <source>Initially, the enumerator is positioned before the first element in the collection.</source>
          <target state="translated">Inicialmente, o enumerador é posicionado antes do primeiro elemento da coleção.</target>       </trans-unit>
        <trans-unit id="376" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.GetEnumerator">
          <source><ph id="ph1">&lt;xref:System.Collections.IEnumerator.Reset%2A&gt;</ph> also brings the enumerator back to this position.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Collections.IEnumerator.Reset%2A&gt;</ph> também traz o enumerador de volta para essa posição.</target>       </trans-unit>
        <trans-unit id="377" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.GetEnumerator">
          <source>At this position, <ph id="ph1">&lt;xref:System.Collections.IEnumerator.Current%2A&gt;</ph> is undefined.</source>
          <target state="translated">Nesta posição, <ph id="ph1">&lt;xref:System.Collections.IEnumerator.Current%2A&gt;</ph> está indefinido.</target>       </trans-unit>
        <trans-unit id="378" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.GetEnumerator">
          <source>Therefore, you must call <ph id="ph1">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> to advance the enumerator to the first element of the collection before reading the value of <ph id="ph2">&lt;xref:System.Collections.IEnumerator.Current%2A&gt;</ph>.</source>
          <target state="translated">Por isso, você deve chamar <ph id="ph1">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> para avançar o enumerador até o primeiro elemento da coleção antes de ler o valor de <ph id="ph2">&lt;xref:System.Collections.IEnumerator.Current%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="379" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.GetEnumerator">
          <source><ph id="ph1">&lt;xref:System.Collections.IEnumerator.Current%2A&gt;</ph> returns the same object until either <ph id="ph2">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> or <ph id="ph3">&lt;xref:System.Collections.IEnumerator.Reset%2A&gt;</ph> is called.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Collections.IEnumerator.Current%2A&gt;</ph> retorna o mesmo objeto até <ph id="ph2">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> ou <ph id="ph3">&lt;xref:System.Collections.IEnumerator.Reset%2A&gt;</ph> ser chamado.</target>       </trans-unit>
        <trans-unit id="380" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.GetEnumerator">
          <source><ph id="ph1">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> sets <ph id="ph2">&lt;xref:System.Collections.IEnumerator.Current%2A&gt;</ph> to the next element.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> define <ph id="ph2">&lt;xref:System.Collections.IEnumerator.Current%2A&gt;</ph> como o próximo elemento.</target>       </trans-unit>
        <trans-unit id="381" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.GetEnumerator">
          <source>If <ph id="ph1">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> passes the end of the collection, the enumerator is positioned after the last element in the collection and <ph id="ph2">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> returns <ph id="ph3">`false`</ph>.</source>
          <target state="translated">Caso <ph id="ph1">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> passe o final da coleção, o enumerador é posicionado após o último elemento na coleção e <ph id="ph2">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> retorna <ph id="ph3">`false`</ph>.</target>       </trans-unit>
        <trans-unit id="382" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.GetEnumerator">
          <source>When the enumerator is at this position, subsequent calls to <ph id="ph1">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> also return <ph id="ph2">`false`</ph>.</source>
          <target state="translated">Quando o enumerador está nessa posição, as chamadas subsequentes para <ph id="ph1">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> também retornam <ph id="ph2">`false`</ph>.</target>       </trans-unit>
        <trans-unit id="383" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.GetEnumerator">
          <source>If the last call to <ph id="ph1">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> returned <ph id="ph2">`false`</ph>, <ph id="ph3">&lt;xref:System.Collections.IEnumerator.Current%2A&gt;</ph> is undefined.</source>
          <target state="translated">Caso a última chamada para <ph id="ph1">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> tenha retornado <ph id="ph2">`false`</ph>, <ph id="ph3">&lt;xref:System.Collections.IEnumerator.Current%2A&gt;</ph> está indefinido.</target>       </trans-unit>
        <trans-unit id="384" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.GetEnumerator">
          <source>To set <ph id="ph1">&lt;xref:System.Collections.IEnumerator.Current%2A&gt;</ph> to the first element of the collection again, you can call <ph id="ph2">&lt;xref:System.Collections.IEnumerator.Reset%2A&gt;</ph> followed by <ph id="ph3">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph>.</source>
          <target state="translated">Para definir <ph id="ph1">&lt;xref:System.Collections.IEnumerator.Current%2A&gt;</ph> como o primeiro elemento da coleção novamente, é possível chamar <ph id="ph2">&lt;xref:System.Collections.IEnumerator.Reset%2A&gt;</ph> seguido de <ph id="ph3">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="385" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.GetEnumerator">
          <source>An enumerator remains valid as long as the collection remains unchanged.</source>
          <target state="translated">Um enumerador permanece válido desde que a coleção continue inalterada.</target>       </trans-unit>
        <trans-unit id="386" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.GetEnumerator">
          <source>If changes are made to the collection, such as adding, modifying, or deleting elements, the enumerator is irrecoverably invalidated and its behavior is undefined.</source>
          <target state="translated">Se forem feitas alterações na coleção, como adicionar, modificar ou excluir elementos, o enumerador será invalidado de maneira irrevogável e seu comportamento permanecerá indefinido.</target>       </trans-unit>
        <trans-unit id="387" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.GetEnumerator">
          <source>The enumerator does not have exclusive access to the collection; therefore, enumerating through a collection is intrinsically not a thread-safe procedure.</source>
          <target state="translated">O enumerador não tem acesso exclusivo à coleção; por isso, a enumeração por meio de uma coleção não é um procedimento thread-safe intrínseco.</target>       </trans-unit>
        <trans-unit id="388" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.GetEnumerator">
          <source>To guarantee thread safety during enumeration, you can lock the collection during the entire enumeration.</source>
          <target state="translated">Para garantir acesso thread-safe durante a enumeração, é possível bloquear a coleção durante toda a enumeração.</target>       </trans-unit>
        <trans-unit id="389" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.GetEnumerator">
          <source>To allow the collection to be accessed by multiple threads for reading and writing, you must implement your own synchronization.</source>
          <target state="translated">Para permitir que a coleção a ser acessado por vários threads para leitura e gravação, você deve implementar sua sincronização.</target>       </trans-unit>
        <trans-unit id="390" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.GetEnumerator">
          <source>This method is an O(1) operation.</source>
          <target state="translated">Este método é uma operação O(1).</target>       </trans-unit>
        <trans-unit id="391" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.GetEnumerator">
          <source>The following example gets the enumerator for an <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph>, and the enumerator for a range of elements in the <ph id="ph2">&lt;xref:System.Collections.ArrayList&gt;</ph>.</source>
          <target state="translated">O exemplo a seguir obtém o enumerador para um <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph>e o enumerador para um intervalo de elementos de <ph id="ph2">&lt;xref:System.Collections.ArrayList&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="392" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.GetEnumerator(System.Int32,System.Int32)">
          <source>The zero-based starting index of the <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> section that the enumerator should refer to.</source>
          <target state="translated">O índice inicial baseado em zero da seção <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> que o enumerador deve consultar.</target>       </trans-unit>
        <trans-unit id="393" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.GetEnumerator(System.Int32,System.Int32)">
          <source>The number of elements in the <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> section that the enumerator should refer to.</source>
          <target state="translated">O número de elementos na seção <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> que o enumerador deve consultar.</target>       </trans-unit>
        <trans-unit id="394" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.GetEnumerator(System.Int32,System.Int32)">
          <source>Returns an enumerator for a range of elements in the <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph>.</source>
          <target state="translated">Retorna um enumerador para um intervalo de elementos no <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="395" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.GetEnumerator(System.Int32,System.Int32)">
          <source>An <ph id="ph1">&lt;see cref="T:System.Collections.IEnumerator" /&gt;</ph> for the specified range of elements in the <ph id="ph2">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph>.</source>
          <target state="translated">Um <ph id="ph1">&lt;see cref="T:System.Collections.IEnumerator" /&gt;</ph> para o intervalo especificado de elementos no <ph id="ph2">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="396" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.GetEnumerator(System.Int32,System.Int32)">
          <source>The <ph id="ph1">`foreach`</ph> statement of the C# language (<ph id="ph2">`for each`</ph> in Visual C++, <ph id="ph3">`For Each`</ph> Visual Basic) hides the complexity of the enumerators.</source>
          <target state="translated">O <ph id="ph1">`foreach`</ph> instrução de linguagem c# (<ph id="ph2">`for each`</ph> no Visual C++, <ph id="ph3">`For Each`</ph> Visual Basic) oculta a complexidade dos enumeradores.</target>       </trans-unit>
        <trans-unit id="397" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.GetEnumerator(System.Int32,System.Int32)">
          <source>Therefore, using <ph id="ph1">`foreach`</ph> is recommended, instead of directly manipulating the enumerator.</source>
          <target state="translated">Portanto, o uso de <ph id="ph1">`foreach`</ph> é recomendado, em vez de manipular diretamente o enumerador.</target>       </trans-unit>
        <trans-unit id="398" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.GetEnumerator(System.Int32,System.Int32)">
          <source>Enumerators can be used to read the data in the collection, but they cannot be used to modify the underlying collection.</source>
          <target state="translated">Os enumeradores podem ser usados para ler os dados na coleção, mas não podem ser usados para modificar a coleção subjacente.</target>       </trans-unit>
        <trans-unit id="399" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.GetEnumerator(System.Int32,System.Int32)">
          <source>Initially, the enumerator is positioned before the first element in the collection.</source>
          <target state="translated">Inicialmente, o enumerador é posicionado antes do primeiro elemento da coleção.</target>       </trans-unit>
        <trans-unit id="400" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.GetEnumerator(System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;xref:System.Collections.IEnumerator.Reset%2A&gt;</ph> also brings the enumerator back to this position.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Collections.IEnumerator.Reset%2A&gt;</ph> também traz o enumerador de volta para essa posição.</target>       </trans-unit>
        <trans-unit id="401" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.GetEnumerator(System.Int32,System.Int32)">
          <source>At this position, <ph id="ph1">&lt;xref:System.Collections.IEnumerator.Current%2A&gt;</ph> is undefined.</source>
          <target state="translated">Nesta posição, <ph id="ph1">&lt;xref:System.Collections.IEnumerator.Current%2A&gt;</ph> está indefinido.</target>       </trans-unit>
        <trans-unit id="402" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.GetEnumerator(System.Int32,System.Int32)">
          <source>Therefore, you must call <ph id="ph1">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> to advance the enumerator to the first element of the collection before reading the value of <ph id="ph2">&lt;xref:System.Collections.IEnumerator.Current%2A&gt;</ph>.</source>
          <target state="translated">Por isso, você deve chamar <ph id="ph1">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> para avançar o enumerador até o primeiro elemento da coleção antes de ler o valor de <ph id="ph2">&lt;xref:System.Collections.IEnumerator.Current%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="403" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.GetEnumerator(System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;xref:System.Collections.IEnumerator.Current%2A&gt;</ph> returns the same object until either <ph id="ph2">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> or <ph id="ph3">&lt;xref:System.Collections.IEnumerator.Reset%2A&gt;</ph> is called.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Collections.IEnumerator.Current%2A&gt;</ph> retorna o mesmo objeto até <ph id="ph2">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> ou <ph id="ph3">&lt;xref:System.Collections.IEnumerator.Reset%2A&gt;</ph> ser chamado.</target>       </trans-unit>
        <trans-unit id="404" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.GetEnumerator(System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> sets <ph id="ph2">&lt;xref:System.Collections.IEnumerator.Current%2A&gt;</ph> to the next element.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> define <ph id="ph2">&lt;xref:System.Collections.IEnumerator.Current%2A&gt;</ph> como o próximo elemento.</target>       </trans-unit>
        <trans-unit id="405" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.GetEnumerator(System.Int32,System.Int32)">
          <source>If <ph id="ph1">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> passes the end of the collection, the enumerator is positioned after the last element in the collection and <ph id="ph2">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> returns <ph id="ph3">`false`</ph>.</source>
          <target state="translated">Caso <ph id="ph1">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> passe o final da coleção, o enumerador é posicionado após o último elemento na coleção e <ph id="ph2">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> retorna <ph id="ph3">`false`</ph>.</target>       </trans-unit>
        <trans-unit id="406" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.GetEnumerator(System.Int32,System.Int32)">
          <source>When the enumerator is at this position, subsequent calls to <ph id="ph1">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> also return <ph id="ph2">`false`</ph>.</source>
          <target state="translated">Quando o enumerador está nessa posição, as chamadas subsequentes para <ph id="ph1">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> também retornam <ph id="ph2">`false`</ph>.</target>       </trans-unit>
        <trans-unit id="407" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.GetEnumerator(System.Int32,System.Int32)">
          <source>If the last call to <ph id="ph1">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> returned <ph id="ph2">`false`</ph>, <ph id="ph3">&lt;xref:System.Collections.IEnumerator.Current%2A&gt;</ph> is undefined.</source>
          <target state="translated">Caso a última chamada para <ph id="ph1">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> tenha retornado <ph id="ph2">`false`</ph>, <ph id="ph3">&lt;xref:System.Collections.IEnumerator.Current%2A&gt;</ph> está indefinido.</target>       </trans-unit>
        <trans-unit id="408" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.GetEnumerator(System.Int32,System.Int32)">
          <source>To set <ph id="ph1">&lt;xref:System.Collections.IEnumerator.Current%2A&gt;</ph> to the first element of the collection again, you can call <ph id="ph2">&lt;xref:System.Collections.IEnumerator.Reset%2A&gt;</ph> followed by <ph id="ph3">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph>.</source>
          <target state="translated">Para definir <ph id="ph1">&lt;xref:System.Collections.IEnumerator.Current%2A&gt;</ph> como o primeiro elemento da coleção novamente, é possível chamar <ph id="ph2">&lt;xref:System.Collections.IEnumerator.Reset%2A&gt;</ph> seguido de <ph id="ph3">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="409" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.GetEnumerator(System.Int32,System.Int32)">
          <source>An enumerator remains valid as long as the collection remains unchanged.</source>
          <target state="translated">Um enumerador permanece válido desde que a coleção continue inalterada.</target>       </trans-unit>
        <trans-unit id="410" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.GetEnumerator(System.Int32,System.Int32)">
          <source>If changes are made to the collection, such as adding, modifying, or deleting elements, the enumerator is irrecoverably invalidated and its behavior is undefined.</source>
          <target state="translated">Se forem feitas alterações na coleção, como adicionar, modificar ou excluir elementos, o enumerador será invalidado de maneira irrevogável e seu comportamento permanecerá indefinido.</target>       </trans-unit>
        <trans-unit id="411" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.GetEnumerator(System.Int32,System.Int32)">
          <source>The enumerator does not have exclusive access to the collection; therefore, enumerating through a collection is intrinsically not a thread-safe procedure.</source>
          <target state="translated">O enumerador não tem acesso exclusivo à coleção; por isso, a enumeração por meio de uma coleção não é um procedimento thread-safe intrínseco.</target>       </trans-unit>
        <trans-unit id="412" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.GetEnumerator(System.Int32,System.Int32)">
          <source>To guarantee thread safety during enumeration, you can lock the collection during the entire enumeration.</source>
          <target state="translated">Para garantir acesso thread-safe durante a enumeração, é possível bloquear a coleção durante toda a enumeração.</target>       </trans-unit>
        <trans-unit id="413" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.GetEnumerator(System.Int32,System.Int32)">
          <source>To allow the collection to be accessed by multiple threads for reading and writing, you must implement your own synchronization.</source>
          <target state="translated">Para permitir que a coleção a ser acessado por vários threads para leitura e gravação, você deve implementar sua sincronização.</target>       </trans-unit>
        <trans-unit id="414" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.GetEnumerator(System.Int32,System.Int32)">
          <source>This method is an O(1) operation.</source>
          <target state="translated">Este método é uma operação O(1).</target>       </trans-unit>
        <trans-unit id="415" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.GetEnumerator(System.Int32,System.Int32)">
          <source>Version Compatibility</source>
          <target state="translated">Compatibilidade de versões</target>       </trans-unit>
        <trans-unit id="416" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.GetEnumerator(System.Int32,System.Int32)">
          <source>In the .NET Framework versions 1.0 and 1.1, the enumerator for an <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph> wrapper returned by the <ph id="ph2">&lt;xref:System.Collections.ArrayList.Adapter%2A&gt;</ph> method treated the second argument as an upper bound rather than as a count.</source>
          <target state="translated">Nas versões do .NET Framework 1.0 e 1.1, o enumerador para um <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph> wrapper retornado pelo <ph id="ph2">&lt;xref:System.Collections.ArrayList.Adapter%2A&gt;</ph> método tratado o segundo argumento como um limite superior em vez de uma contagem.</target>       </trans-unit>
        <trans-unit id="417" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.GetEnumerator(System.Int32,System.Int32)">
          <source>In the <ph id="ph1">[!INCLUDE[dnprdnlong](~/includes/dnprdnlong-md.md)]</ph> the second argument is correctly treated as a count.</source>
          <target state="translated">No <ph id="ph1">[!INCLUDE[dnprdnlong](~/includes/dnprdnlong-md.md)]</ph> corretamente, o segundo argumento é tratado como uma contagem.</target>       </trans-unit>
        <trans-unit id="418" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.GetEnumerator(System.Int32,System.Int32)">
          <source>The following example gets the enumerator for an <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph>, and the enumerator for a range of elements in the <ph id="ph2">&lt;xref:System.Collections.ArrayList&gt;</ph>.</source>
          <target state="translated">O exemplo a seguir obtém o enumerador para um <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph>e o enumerador para um intervalo de elementos de <ph id="ph2">&lt;xref:System.Collections.ArrayList&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="419" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.GetEnumerator(System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="index" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="index" /&gt;</ph> é menor que zero.</target>       </trans-unit>
        <trans-unit id="420" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.GetEnumerator(System.Int32,System.Int32)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="421" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.GetEnumerator(System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="count" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="count" /&gt;</ph> é menor que zero.</target>       </trans-unit>
        <trans-unit id="422" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.GetEnumerator(System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="index" /&gt;</ph> and <ph id="ph2">&lt;paramref name="count" /&gt;</ph> do not specify a valid range in the <ph id="ph3">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="index" /&gt;</ph> e <ph id="ph2">&lt;paramref name="count" /&gt;</ph> não especificam um intervalo válido no <ph id="ph3">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="423" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.GetRange(System.Int32,System.Int32)">
          <source>The zero-based <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> index at which the range starts.</source>
          <target state="translated">O índice <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> baseado em zero no qual é iniciado o intervalo.</target>       </trans-unit>
        <trans-unit id="424" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.GetRange(System.Int32,System.Int32)">
          <source>The number of elements in the range.</source>
          <target state="translated">O número de elementos no intervalo.</target>       </trans-unit>
        <trans-unit id="425" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.GetRange(System.Int32,System.Int32)">
          <source>Returns an <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> which represents a subset of the elements in the source <ph id="ph2">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph>.</source>
          <target state="translated">Retorna um <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> que representa um subconjunto dos elementos na origem <ph id="ph2">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="426" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.GetRange(System.Int32,System.Int32)">
          <source>An <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> which represents a subset of the elements in the source <ph id="ph2">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph>.</source>
          <target state="translated">Um <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> que representa um subconjunto dos elementos na origem <ph id="ph2">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="427" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.GetRange(System.Int32,System.Int32)">
          <source>This method does not create copies of the elements.</source>
          <target state="translated">Este método não cria cópias dos elementos.</target>       </trans-unit>
        <trans-unit id="428" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.GetRange(System.Int32,System.Int32)">
          <source>The new <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph> is only a view window into the source <ph id="ph2">&lt;xref:System.Collections.ArrayList&gt;</ph>.</source>
          <target state="translated">O novo <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph> é apenas uma janela de exibição na fonte de <ph id="ph2">&lt;xref:System.Collections.ArrayList&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="429" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.GetRange(System.Int32,System.Int32)">
          <source>However, all subsequent changes to the source <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph> must be done through this view window <ph id="ph2">&lt;xref:System.Collections.ArrayList&gt;</ph>.</source>
          <target state="translated">No entanto, todas as alterações subsequentes à fonte de <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph> deve ser feito por meio desta janela de exibição <ph id="ph2">&lt;xref:System.Collections.ArrayList&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="430" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.GetRange(System.Int32,System.Int32)">
          <source>If changes are made directly to the source <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph>, the view window <ph id="ph2">&lt;xref:System.Collections.ArrayList&gt;</ph> is invalidated and any operations on it will return an <ph id="ph3">&lt;xref:System.InvalidOperationException&gt;</ph>.</source>
          <target state="translated">Se forem feitas alterações diretamente à fonte de <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph>, a janela de exibição <ph id="ph2">&lt;xref:System.Collections.ArrayList&gt;</ph> é invalidado e quaisquer operações sobre ela retornará um <ph id="ph3">&lt;xref:System.InvalidOperationException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="431" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.GetRange(System.Int32,System.Int32)">
          <source>This method is an O(1) operation.</source>
          <target state="translated">Este método é uma operação O(1).</target>       </trans-unit>
        <trans-unit id="432" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.GetRange(System.Int32,System.Int32)">
          <source>The following code example shows how to set and get a range of elements in the <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph>.</source>
          <target state="translated">O exemplo de código a seguir mostra como definir e obter um intervalo de elementos de <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="433" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.GetRange(System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="index" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="index" /&gt;</ph> é menor que zero.</target>       </trans-unit>
        <trans-unit id="434" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.GetRange(System.Int32,System.Int32)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="435" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.GetRange(System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="count" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="count" /&gt;</ph> é menor que zero.</target>       </trans-unit>
        <trans-unit id="436" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.GetRange(System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="index" /&gt;</ph> and <ph id="ph2">&lt;paramref name="count" /&gt;</ph> do not denote a valid range of elements in the <ph id="ph3">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="index" /&gt;</ph> e <ph id="ph2">&lt;paramref name="count" /&gt;</ph> não denotam um intervalo válido de elementos no <ph id="ph3">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="437" translate="yes" xml:space="preserve" uid="T:System.Collections.ArrayList">
          <source>Returns the zero-based index of the first occurrence of a value in the <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> or in a portion of it.</source>
          <target state="translated">Retorna o índice baseado em zero da primeira ocorrência de um valor no <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> ou em uma parte dele.</target>       </trans-unit>
        <trans-unit id="438" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.IndexOf(System.Object)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Object" /&gt;</ph> to locate in the <ph id="ph2">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph>.</source>
          <target state="translated">O <ph id="ph1">&lt;see cref="T:System.Object" /&gt;</ph> a ser localizado no <ph id="ph2">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="439" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.IndexOf(System.Object)">
          <source>The value can be <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">O valor pode ser <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="440" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.IndexOf(System.Object)">
          <source>Searches for the specified <ph id="ph1">&lt;see cref="T:System.Object" /&gt;</ph> and returns the zero-based index of the first occurrence within the entire <ph id="ph2">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph>.</source>
          <target state="translated">Pesquisa o <ph id="ph1">&lt;see cref="T:System.Object" /&gt;</ph> especificado e retorna o índice de base zero da primeira ocorrência dentro de todo o <ph id="ph2">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="441" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.IndexOf(System.Object)">
          <source>The zero-based index of the first occurrence of <ph id="ph1">&lt;paramref name="value" /&gt;</ph> within the entire <ph id="ph2">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph>, if found; otherwise, -1.</source>
          <target state="translated">O índice baseado em zero da primeira ocorrência de <ph id="ph1">&lt;paramref name="value" /&gt;</ph> em todo o <ph id="ph2">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph>, se encontrado; caso contrário, -1.</target>       </trans-unit>
        <trans-unit id="442" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.IndexOf(System.Object)">
          <source>The <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph> is searched forward starting at the first element and ending at the last element.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph> é pesquisado forward iniciando no primeiro elemento e terminando no último elemento.</target>       </trans-unit>
        <trans-unit id="443" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.IndexOf(System.Object)">
          <source>This method performs a linear search; therefore, this method is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is <ph id="ph3">&lt;xref:System.Collections.ArrayList.Count%2A&gt;</ph>.</source>
          <target state="translated">Este método executa uma pesquisa linear; por isso, esse método é uma operação O(<ph id="ph1">`n`</ph>), em que <ph id="ph2">`n`</ph> é <ph id="ph3">&lt;xref:System.Collections.ArrayList.Count%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="444" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.IndexOf(System.Object)">
          <source>This method determines equality by calling <ph id="ph1">&lt;xref:System.Object.Equals%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Este método determina a igualdade chamando <ph id="ph1">&lt;xref:System.Object.Equals%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="445" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.IndexOf(System.Object)">
          <source>Starting with the .NET Framework 2.0, this method uses the collection’s objects’ <ph id="ph1">&lt;xref:System.Object.Equals%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.IComparable.CompareTo%2A&gt;</ph> methods on <ph id="ph3">`item`</ph> to determine whether item exists.</source>
          <target state="translated">Começando pelo .NET Framework 2.0, esse método usa os métodos <ph id="ph1">&lt;xref:System.Object.Equals%2A&gt;</ph> e <ph id="ph2">&lt;xref:System.IComparable.CompareTo%2A&gt;</ph> do objeto da coleção em <ph id="ph3">`item`</ph> para determinar se o item existe.</target>       </trans-unit>
        <trans-unit id="446" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.IndexOf(System.Object)">
          <source>In the earlier versions of the .NET Framework, this determination was made by using the <ph id="ph1">&lt;xref:System.Object.Equals%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.IComparable.CompareTo%2A&gt;</ph> methods of the <ph id="ph3">`item`</ph> parameter on the objects in the collection.</source>
          <target state="translated">Em versões anteriores do .NET Framework, essa decisão era tomada usando-se os métodos <ph id="ph1">&lt;xref:System.Object.Equals%2A&gt;</ph> e <ph id="ph2">&lt;xref:System.IComparable.CompareTo%2A&gt;</ph> do parâmetro <ph id="ph3">`item`</ph> nos objetos na coleção.</target>       </trans-unit>
        <trans-unit id="447" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.IndexOf(System.Object)">
          <source>The following code example shows how to determine the index of the first occurrence of a specified element.</source>
          <target state="translated">O exemplo de código a seguir mostra como determinar o índice da primeira ocorrência de um elemento especificado.</target>       </trans-unit>
        <trans-unit id="448" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.IndexOf(System.Object,System.Int32)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Object" /&gt;</ph> to locate in the <ph id="ph2">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph>.</source>
          <target state="translated">O <ph id="ph1">&lt;see cref="T:System.Object" /&gt;</ph> a ser localizado no <ph id="ph2">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="449" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.IndexOf(System.Object,System.Int32)">
          <source>The value can be <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">O valor pode ser <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="450" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.IndexOf(System.Object,System.Int32)">
          <source>The zero-based starting index of the search.</source>
          <target state="translated">O índice inicial com base em zero da pesquisa.</target>       </trans-unit>
        <trans-unit id="451" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.IndexOf(System.Object,System.Int32)">
          <source>0 (zero) is valid in an empty list.</source>
          <target state="translated">0 (zero) é válido em uma lista vazia.</target>       </trans-unit>
        <trans-unit id="452" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.IndexOf(System.Object,System.Int32)">
          <source>Searches for the specified <ph id="ph1">&lt;see cref="T:System.Object" /&gt;</ph> and returns the zero-based index of the first occurrence within the range of elements in the <ph id="ph2">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> that extends from the specified index to the last element.</source>
          <target state="translated">Pesquisa o <ph id="ph1">&lt;see cref="T:System.Object" /&gt;</ph> especificado e retorna o índice baseado em zero da primeira ocorrência dentro do intervalo de elementos no <ph id="ph2">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> que se estende do índice especificado ao último elemento.</target>       </trans-unit>
        <trans-unit id="453" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.IndexOf(System.Object,System.Int32)">
          <source>The zero-based index of the first occurrence of <ph id="ph1">&lt;paramref name="value" /&gt;</ph> within the range of elements in the <ph id="ph2">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> that extends from <ph id="ph3">&lt;paramref name="startIndex" /&gt;</ph> to the last element, if found; otherwise, -1.</source>
          <target state="translated">O índice baseado em zero da primeira ocorrência de <ph id="ph1">&lt;paramref name="value" /&gt;</ph> dentro do intervalo de elementos no <ph id="ph2">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> que se estende do <ph id="ph3">&lt;paramref name="startIndex" /&gt;</ph> ao último elemento, se for encontrado; caso contrário, -1.</target>       </trans-unit>
        <trans-unit id="454" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.IndexOf(System.Object,System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph> is searched forward starting at <ph id="ph2">`startIndex`</ph> and ending at the last element.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph> é pesquisado forward começando em <ph id="ph2">`startIndex`</ph> e terminando no último elemento.</target>       </trans-unit>
        <trans-unit id="455" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.IndexOf(System.Object,System.Int32)">
          <source>This method performs a linear search; therefore, this method is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is the number of elements from <ph id="ph3">`startIndex`</ph> to the end of the <ph id="ph4">&lt;xref:System.Collections.ArrayList&gt;</ph>.</source>
          <target state="translated">Esse método executa uma pesquisa linear; Portanto, esse método é um O (<ph id="ph1">`n`</ph>) operação, onde <ph id="ph2">`n`</ph> é o número de elementos do <ph id="ph3">`startIndex`</ph> ao final do <ph id="ph4">&lt;xref:System.Collections.ArrayList&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="456" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.IndexOf(System.Object,System.Int32)">
          <source>This method determines equality by calling <ph id="ph1">&lt;xref:System.Object.Equals%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Este método determina a igualdade chamando <ph id="ph1">&lt;xref:System.Object.Equals%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="457" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.IndexOf(System.Object,System.Int32)">
          <source>Starting with the .NET Framework 2.0, this method uses the collection’s objects’ <ph id="ph1">&lt;xref:System.Object.Equals%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.IComparable.CompareTo%2A&gt;</ph> methods on <ph id="ph3">`item`</ph> to determine whether item exists.</source>
          <target state="translated">Começando pelo .NET Framework 2.0, esse método usa os métodos <ph id="ph1">&lt;xref:System.Object.Equals%2A&gt;</ph> e <ph id="ph2">&lt;xref:System.IComparable.CompareTo%2A&gt;</ph> do objeto da coleção em <ph id="ph3">`item`</ph> para determinar se o item existe.</target>       </trans-unit>
        <trans-unit id="458" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.IndexOf(System.Object,System.Int32)">
          <source>In the earlier versions of the .NET Framework, this determination was made by using the <ph id="ph1">&lt;xref:System.Object.Equals%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.IComparable.CompareTo%2A&gt;</ph> methods of the <ph id="ph3">`item`</ph> parameter on the objects in the collection.</source>
          <target state="translated">Em versões anteriores do .NET Framework, essa decisão era tomada usando-se os métodos <ph id="ph1">&lt;xref:System.Object.Equals%2A&gt;</ph> e <ph id="ph2">&lt;xref:System.IComparable.CompareTo%2A&gt;</ph> do parâmetro <ph id="ph3">`item`</ph> nos objetos na coleção.</target>       </trans-unit>
        <trans-unit id="459" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.IndexOf(System.Object,System.Int32)">
          <source>The following code example shows how to determine the index of the first occurrence of a specified element.</source>
          <target state="translated">O exemplo de código a seguir mostra como determinar o índice da primeira ocorrência de um elemento especificado.</target>       </trans-unit>
        <trans-unit id="460" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.IndexOf(System.Object,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> is outside the range of valid indexes for the <ph id="ph2">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> está fora do intervalo de índices válidos para o <ph id="ph2">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="461" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.IndexOf(System.Object,System.Int32,System.Int32)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Object" /&gt;</ph> to locate in the <ph id="ph2">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph>.</source>
          <target state="translated">O <ph id="ph1">&lt;see cref="T:System.Object" /&gt;</ph> a ser localizado no <ph id="ph2">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="462" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.IndexOf(System.Object,System.Int32,System.Int32)">
          <source>The value can be <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">O valor pode ser <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="463" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.IndexOf(System.Object,System.Int32,System.Int32)">
          <source>The zero-based starting index of the search.</source>
          <target state="translated">O índice inicial com base em zero da pesquisa.</target>       </trans-unit>
        <trans-unit id="464" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.IndexOf(System.Object,System.Int32,System.Int32)">
          <source>0 (zero) is valid in an empty list.</source>
          <target state="translated">0 (zero) é válido em uma lista vazia.</target>       </trans-unit>
        <trans-unit id="465" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.IndexOf(System.Object,System.Int32,System.Int32)">
          <source>The number of elements in the section to search.</source>
          <target state="translated">O número de elementos na seção a ser pesquisada.</target>       </trans-unit>
        <trans-unit id="466" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.IndexOf(System.Object,System.Int32,System.Int32)">
          <source>Searches for the specified <ph id="ph1">&lt;see cref="T:System.Object" /&gt;</ph> and returns the zero-based index of the first occurrence within the range of elements in the <ph id="ph2">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> that starts at the specified index and contains the specified number of elements.</source>
          <target state="translated">Pesquisa o <ph id="ph1">&lt;see cref="T:System.Object" /&gt;</ph> especificado e retorna o índice baseado em zero da primeira ocorrência dentro de um intervalo de elementos no <ph id="ph2">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> que começa no índice especificado e contém o número de elementos especificado.</target>       </trans-unit>
        <trans-unit id="467" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.IndexOf(System.Object,System.Int32,System.Int32)">
          <source>The zero-based index of the first occurrence of <ph id="ph1">&lt;paramref name="value" /&gt;</ph> within the range of elements in the <ph id="ph2">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> that starts at <ph id="ph3">&lt;paramref name="startIndex" /&gt;</ph> and contains <ph id="ph4">&lt;paramref name="count" /&gt;</ph> number of elements, if found; otherwise, -1.</source>
          <target state="translated">O índice baseado em zero da primeira ocorrência de <ph id="ph1">&lt;paramref name="value" /&gt;</ph> dentro do intervalo de elementos no <ph id="ph2">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> que começa em <ph id="ph3">&lt;paramref name="startIndex" /&gt;</ph> e contém o número de elementos <ph id="ph4">&lt;paramref name="count" /&gt;</ph>, se encontrado; caso contrário, -1.</target>       </trans-unit>
        <trans-unit id="468" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.IndexOf(System.Object,System.Int32,System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph> is searched forward starting at <ph id="ph2">`startIndex`</ph> and ending at <ph id="ph3">`startIndex`</ph> plus <ph id="ph4">`count`</ph> minus 1, if <ph id="ph5">`count`</ph> is greater than 0.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph> é pesquisado forward começando em <ph id="ph2">`startIndex`</ph> e final em <ph id="ph3">`startIndex`</ph> mais <ph id="ph4">`count`</ph> menos 1, se <ph id="ph5">`count`</ph> for maior que 0.</target>       </trans-unit>
        <trans-unit id="469" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.IndexOf(System.Object,System.Int32,System.Int32)">
          <source>This method performs a linear search; therefore, this method is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is <ph id="ph3">`count`</ph>.</source>
          <target state="translated">Este método executa uma pesquisa linear; por isso, esse método é uma operação O(<ph id="ph1">`n`</ph>), em que <ph id="ph2">`n`</ph> é <ph id="ph3">`count`</ph>.</target>       </trans-unit>
        <trans-unit id="470" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.IndexOf(System.Object,System.Int32,System.Int32)">
          <source>This method determines equality by calling <ph id="ph1">&lt;xref:System.Object.Equals%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Este método determina a igualdade chamando <ph id="ph1">&lt;xref:System.Object.Equals%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="471" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.IndexOf(System.Object,System.Int32,System.Int32)">
          <source>Starting with the .NET Framework 2.0, this method uses the collection’s objects’ <ph id="ph1">&lt;xref:System.Object.Equals%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.IComparable.CompareTo%2A&gt;</ph> methods on <ph id="ph3">`item`</ph> to determine whether item exists.</source>
          <target state="translated">Começando pelo .NET Framework 2.0, esse método usa os métodos <ph id="ph1">&lt;xref:System.Object.Equals%2A&gt;</ph> e <ph id="ph2">&lt;xref:System.IComparable.CompareTo%2A&gt;</ph> do objeto da coleção em <ph id="ph3">`item`</ph> para determinar se o item existe.</target>       </trans-unit>
        <trans-unit id="472" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.IndexOf(System.Object,System.Int32,System.Int32)">
          <source>In the earlier versions of the .NET Framework, this determination was made by using the <ph id="ph1">&lt;xref:System.Object.Equals%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.IComparable.CompareTo%2A&gt;</ph> methods of the <ph id="ph3">`item`</ph> parameter on the objects in the collection.</source>
          <target state="translated">Em versões anteriores do .NET Framework, essa decisão era tomada usando-se os métodos <ph id="ph1">&lt;xref:System.Object.Equals%2A&gt;</ph> e <ph id="ph2">&lt;xref:System.IComparable.CompareTo%2A&gt;</ph> do parâmetro <ph id="ph3">`item`</ph> nos objetos na coleção.</target>       </trans-unit>
        <trans-unit id="473" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.IndexOf(System.Object,System.Int32,System.Int32)">
          <source>The following code example shows how to determine the index of the first occurrence of a specified element.</source>
          <target state="translated">O exemplo de código a seguir mostra como determinar o índice da primeira ocorrência de um elemento especificado.</target>       </trans-unit>
        <trans-unit id="474" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.IndexOf(System.Object,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> is outside the range of valid indexes for the <ph id="ph2">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> está fora do intervalo de índices válidos para o <ph id="ph2">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="475" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.IndexOf(System.Object,System.Int32,System.Int32)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="476" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.IndexOf(System.Object,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="count" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="count" /&gt;</ph> é menor que zero.</target>       </trans-unit>
        <trans-unit id="477" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.IndexOf(System.Object,System.Int32,System.Int32)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="478" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.IndexOf(System.Object,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> and <ph id="ph2">&lt;paramref name="count" /&gt;</ph> do not specify a valid section in the <ph id="ph3">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> e <ph id="ph2">&lt;paramref name="count" /&gt;</ph> não especificam uma seção válida no <ph id="ph3">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="479" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.Insert(System.Int32,System.Object)">
          <source>The zero-based index at which <bpt id="p1">&lt;c&gt;</bpt>value<ept id="p1">&lt;/c&gt;</ept> should be inserted.</source>
          <target state="translated">O índice baseado em zero no qual o <bpt id="p1">&lt;c&gt;</bpt>valor<ept id="p1">&lt;/c&gt;</ept> deve ser inserido.</target>       </trans-unit>
        <trans-unit id="480" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.Insert(System.Int32,System.Object)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Object" /&gt;</ph> to insert.</source>
          <target state="translated">O <ph id="ph1">&lt;see cref="T:System.Object" /&gt;</ph> a ser inserido.</target>       </trans-unit>
        <trans-unit id="481" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.Insert(System.Int32,System.Object)">
          <source>The value can be <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">O valor pode ser <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="482" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.Insert(System.Int32,System.Object)">
          <source>Inserts an element into the <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> at the specified index.</source>
          <target state="translated">Insere um elemento no <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph>, no índice especificado.</target>       </trans-unit>
        <trans-unit id="483" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.Insert(System.Int32,System.Object)">
          <source><ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph> accepts <ph id="ph2">`null`</ph> as a valid value and allows duplicate elements.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph> aceita <ph id="ph2">`null`</ph> como um valor válido e permite elementos duplicados.</target>       </trans-unit>
        <trans-unit id="484" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.Insert(System.Int32,System.Object)">
          <source>If <ph id="ph1">&lt;xref:System.Collections.ArrayList.Count%2A&gt;</ph> already equals <ph id="ph2">&lt;xref:System.Collections.ArrayList.Capacity%2A&gt;</ph>, the capacity of the <ph id="ph3">&lt;xref:System.Collections.ArrayList&gt;</ph> is increased by automatically reallocating the internal array, and the existing elements are copied to the new array before the new element is added.</source>
          <target state="translated">Se <ph id="ph1">&lt;xref:System.Collections.ArrayList.Count%2A&gt;</ph> já for igual a <ph id="ph2">&lt;xref:System.Collections.ArrayList.Capacity%2A&gt;</ph>, a capacidade do <ph id="ph3">&lt;xref:System.Collections.ArrayList&gt;</ph> é aumentado, automaticamente realocando matriz interna, e os elementos existentes são copiados para a nova matriz antes de adicionar o novo elemento.</target>       </trans-unit>
        <trans-unit id="485" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.Insert(System.Int32,System.Object)">
          <source>If <ph id="ph1">`index`</ph> is equal to <ph id="ph2">&lt;xref:System.Collections.ArrayList.Count%2A&gt;</ph>, <ph id="ph3">`value`</ph> is added to the end of <ph id="ph4">&lt;xref:System.Collections.ArrayList&gt;</ph>.</source>
          <target state="translated">Se <ph id="ph1">`index`</ph> é igual a <ph id="ph2">&lt;xref:System.Collections.ArrayList.Count%2A&gt;</ph>, <ph id="ph3">`value`</ph> é adicionada ao final da <ph id="ph4">&lt;xref:System.Collections.ArrayList&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="486" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.Insert(System.Int32,System.Object)">
          <source>In collections of contiguous elements, such as lists, the elements that follow the insertion point move down to accommodate the new element.</source>
          <target state="translated">Em coleções de elementos contíguos, como listas, os elementos que seguem o ponto de inserção descem para acomodar o novo elemento.</target>       </trans-unit>
        <trans-unit id="487" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.Insert(System.Int32,System.Object)">
          <source>If the collection is indexed, the indexes of the elements that are moved are also updated.</source>
          <target state="translated">Caso a coleção seja indexada, os índices dos elementos que são movidos também são atualizados.</target>       </trans-unit>
        <trans-unit id="488" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.Insert(System.Int32,System.Object)">
          <source>This behavior does not apply to collections where elements are conceptually grouped into buckets, such as a hash table.</source>
          <target state="translated">Este comportamento não se aplica às coleções em que elementos sejam agrupados conceitualmente em buckets, como uma tabela de hash.</target>       </trans-unit>
        <trans-unit id="489" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.Insert(System.Int32,System.Object)">
          <source>This method is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is <ph id="ph3">&lt;xref:System.Collections.ArrayList.Count%2A&gt;</ph>.</source>
          <target state="translated">Este método é uma operação O(<ph id="ph1">`n`</ph>), em que <ph id="ph2">`n`</ph> é <ph id="ph3">&lt;xref:System.Collections.ArrayList.Count%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="490" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.Insert(System.Int32,System.Object)">
          <source>The following code example shows how to insert elements into the <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph>.</source>
          <target state="translated">O exemplo de código a seguir mostra como inserir elementos no <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="491" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.Insert(System.Int32,System.Object)">
          <source><ph id="ph1">&lt;paramref name="index" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="index" /&gt;</ph> é menor que zero.</target>       </trans-unit>
        <trans-unit id="492" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.Insert(System.Int32,System.Object)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="493" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.Insert(System.Int32,System.Object)">
          <source><ph id="ph1">&lt;paramref name="index" /&gt;</ph> is greater than <ph id="ph2">&lt;see cref="P:System.Collections.ArrayList.Count" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="index" /&gt;</ph> é maior que <ph id="ph2">&lt;see cref="P:System.Collections.ArrayList.Count" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="494" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.Insert(System.Int32,System.Object)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> is read-only.</source>
          <target state="translated">O <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> é somente leitura.</target>       </trans-unit>
        <trans-unit id="495" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.Insert(System.Int32,System.Object)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="496" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.Insert(System.Int32,System.Object)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> has a fixed size.</source>
          <target state="translated">O <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> tem um tamanho fixo.</target>       </trans-unit>
        <trans-unit id="497" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.InsertRange(System.Int32,System.Collections.ICollection)">
          <source>The zero-based index at which the new elements should be inserted.</source>
          <target state="translated">O índice baseado em zero no qual os novos elementos devem ser inseridos.</target>       </trans-unit>
        <trans-unit id="498" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.InsertRange(System.Int32,System.Collections.ICollection)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.ICollection" /&gt;</ph> whose elements should be inserted into the <ph id="ph2">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph>.</source>
          <target state="translated">O <ph id="ph1">&lt;see cref="T:System.Collections.ICollection" /&gt;</ph> cujos elementos devem ser inseridos no <ph id="ph2">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="499" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.InsertRange(System.Int32,System.Collections.ICollection)">
          <source>The collection itself cannot be <ph id="ph1">&lt;see langword="null" /&gt;</ph>, but it can contain elements that are <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">A coleção em si não pode ser <ph id="ph1">&lt;see langword="null" /&gt;</ph>, mas pode conter elementos que são <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="500" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.InsertRange(System.Int32,System.Collections.ICollection)">
          <source>Inserts the elements of a collection into the <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> at the specified index.</source>
          <target state="translated">Insere os elementos de uma coleção no <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> no índice especificado.</target>       </trans-unit>
        <trans-unit id="501" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.InsertRange(System.Int32,System.Collections.ICollection)">
          <source><ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph> accepts <ph id="ph2">`null`</ph> as a valid value and allows duplicate elements.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph> aceita <ph id="ph2">`null`</ph> como um valor válido e permite elementos duplicados.</target>       </trans-unit>
        <trans-unit id="502" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.InsertRange(System.Int32,System.Collections.ICollection)">
          <source>If the new <ph id="ph1">&lt;xref:System.Collections.ArrayList.Count%2A&gt;</ph> (the current <ph id="ph2">&lt;xref:System.Collections.ArrayList.Count%2A&gt;</ph> plus the size of the collection) will be greater than <ph id="ph3">&lt;xref:System.Collections.ArrayList.Capacity%2A&gt;</ph>, the capacity of the <ph id="ph4">&lt;xref:System.Collections.ArrayList&gt;</ph> is increased by automatically reallocating the internal array to accommodate the new elements, and the existing elements are copied to the new array before the new elements are added.</source>
          <target state="translated">Se o novo <ph id="ph1">&lt;xref:System.Collections.ArrayList.Count%2A&gt;</ph> (atual <ph id="ph2">&lt;xref:System.Collections.ArrayList.Count%2A&gt;</ph> mais o tamanho da coleção) será maior <ph id="ph3">&lt;xref:System.Collections.ArrayList.Capacity%2A&gt;</ph>, a capacidade do <ph id="ph4">&lt;xref:System.Collections.ArrayList&gt;</ph> é aumentado, automaticamente realocando a matriz interna para acomodar os novos elementos, e os elementos existentes são copiados para a nova matriz antes que os novos elementos são adicionados.</target>       </trans-unit>
        <trans-unit id="503" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.InsertRange(System.Int32,System.Collections.ICollection)">
          <source>If <ph id="ph1">`index`</ph> is equal to <ph id="ph2">&lt;xref:System.Collections.ArrayList.Count%2A&gt;</ph>, the elements are added to the end of <ph id="ph3">&lt;xref:System.Collections.ArrayList&gt;</ph>.</source>
          <target state="translated">Se <ph id="ph1">`index`</ph> é igual a <ph id="ph2">&lt;xref:System.Collections.ArrayList.Count%2A&gt;</ph>, os elementos são adicionados ao final da <ph id="ph3">&lt;xref:System.Collections.ArrayList&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="504" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.InsertRange(System.Int32,System.Collections.ICollection)">
          <source>The order of the elements in the <ph id="ph1">&lt;xref:System.Collections.ICollection&gt;</ph> is preserved in the <ph id="ph2">&lt;xref:System.Collections.ArrayList&gt;</ph>.</source>
          <target state="translated">A ordem dos elementos no <ph id="ph1">&lt;xref:System.Collections.ICollection&gt;</ph> é preservada no <ph id="ph2">&lt;xref:System.Collections.ArrayList&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="505" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.InsertRange(System.Int32,System.Collections.ICollection)">
          <source>In collections of contiguous elements, such as lists, the elements that follow the insertion point move down to accommodate the new element.</source>
          <target state="translated">Em coleções de elementos contíguos, como listas, os elementos que seguem o ponto de inserção descem para acomodar o novo elemento.</target>       </trans-unit>
        <trans-unit id="506" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.InsertRange(System.Int32,System.Collections.ICollection)">
          <source>If the collection is indexed, the indexes of the elements that are moved are also updated.</source>
          <target state="translated">Caso a coleção seja indexada, os índices dos elementos que são movidos também são atualizados.</target>       </trans-unit>
        <trans-unit id="507" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.InsertRange(System.Int32,System.Collections.ICollection)">
          <source>This behavior does not apply to collections where elements are conceptually grouped into buckets, such as a hash table.</source>
          <target state="translated">Este comportamento não se aplica às coleções em que elementos sejam agrupados conceitualmente em buckets, como uma tabela de hash.</target>       </trans-unit>
        <trans-unit id="508" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.InsertRange(System.Int32,System.Collections.ICollection)">
          <source>This method is an O(<ph id="ph1">`n`</ph><ph id="ph2"> + </ph><ph id="ph3">`m`</ph>) operation, where <ph id="ph4">`n`</ph> is the number of elements to be added and <ph id="ph5">`m`</ph> is <ph id="ph6">&lt;xref:System.Collections.ArrayList.Count%2A&gt;</ph>.</source>
          <target state="translated">Esse método é um O (<ph id="ph1">`n`</ph><ph id="ph2"> + </ph><ph id="ph3">`m`</ph>) operação, onde <ph id="ph4">`n`</ph> é o número de elementos a serem adicionados e <ph id="ph5">`m`</ph> é <ph id="ph6">&lt;xref:System.Collections.ArrayList.Count%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="509" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.InsertRange(System.Int32,System.Collections.ICollection)">
          <source>The following code example shows how to insert elements into the <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph>.</source>
          <target state="translated">O exemplo de código a seguir mostra como inserir elementos no <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="510" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.InsertRange(System.Int32,System.Collections.ICollection)">
          <source><ph id="ph1">&lt;paramref name="c" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="c" /&gt;</ph> é <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="511" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.InsertRange(System.Int32,System.Collections.ICollection)">
          <source><ph id="ph1">&lt;paramref name="index" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="index" /&gt;</ph> é menor que zero.</target>       </trans-unit>
        <trans-unit id="512" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.InsertRange(System.Int32,System.Collections.ICollection)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="513" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.InsertRange(System.Int32,System.Collections.ICollection)">
          <source><ph id="ph1">&lt;paramref name="index" /&gt;</ph> is greater than <ph id="ph2">&lt;see cref="P:System.Collections.ArrayList.Count" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="index" /&gt;</ph> é maior que <ph id="ph2">&lt;see cref="P:System.Collections.ArrayList.Count" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="514" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.InsertRange(System.Int32,System.Collections.ICollection)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> is read-only.</source>
          <target state="translated">O <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> é somente leitura.</target>       </trans-unit>
        <trans-unit id="515" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.InsertRange(System.Int32,System.Collections.ICollection)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="516" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.InsertRange(System.Int32,System.Collections.ICollection)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> has a fixed size.</source>
          <target state="translated">O <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> tem um tamanho fixo.</target>       </trans-unit>
        <trans-unit id="517" translate="yes" xml:space="preserve" uid="P:System.Collections.ArrayList.IsFixedSize">
          <source>Gets a value indicating whether the <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> has a fixed size.</source>
          <target state="translated">Obtém um valor que indica se o <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> tem um tamanho fixo.</target>       </trans-unit>
        <trans-unit id="518" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.ArrayList.IsFixedSize">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the <ph id="ph2">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> has a fixed size; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> se o <ph id="ph2">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> tiver um valor fixo; caso contrário, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="519" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.ArrayList.IsFixedSize">
          <source>The default is <ph id="ph1">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">O padrão é <ph id="ph1">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="520" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.ArrayList.IsFixedSize">
          <source>A collection with a fixed size does not allow the addition or removal of elements after the collection is created, but it allows the modification of existing elements.</source>
          <target state="translated">Uma coleção com um tamanho fixo não permite a adição ou a remoção de elementos após a coleção ser criada, mas permite a modificação de elementos existentes.</target>       </trans-unit>
        <trans-unit id="521" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.ArrayList.IsFixedSize">
          <source>A collection with a fixed size is simply a collection with a wrapper that prevents adding and removing elements; therefore, if changes are made to the underlying collection, including the addition or removal of elements, the fixed-size collection reflects those changes.</source>
          <target state="translated">Uma coleção com um tamanho fixo é simplesmente uma coleção com um wrapper que impede a adição e a remoção de elementos; por isso, caso as alterações sejam feitas na coleção subjacente, inclusive a adição ou a remoção de elementos, a coleção de tamanho fixo reflete essas alterações.</target>       </trans-unit>
        <trans-unit id="522" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.ArrayList.IsFixedSize">
          <source>Retrieving the value of this property is an O(1) operation.</source>
          <target state="translated">A recuperação do valor dessa propriedade é uma operação O(1).</target>       </trans-unit>
        <trans-unit id="523" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.ArrayList.IsFixedSize">
          <source>The following code example shows how to create a fixed-size wrapper around an <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph>.</source>
          <target state="translated">O exemplo de código a seguir mostra como criar um wrapper de tamanho fixo para um <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="524" translate="yes" xml:space="preserve" uid="P:System.Collections.ArrayList.IsReadOnly">
          <source>Gets a value indicating whether the <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> is read-only.</source>
          <target state="translated">Obtém um valor que indica se o <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> é somente leitura.</target>       </trans-unit>
        <trans-unit id="525" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.ArrayList.IsReadOnly">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the <ph id="ph2">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> is read-only; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> se o <ph id="ph2">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> for somente leitura; caso contrário, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="526" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.ArrayList.IsReadOnly">
          <source>The default is <ph id="ph1">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">O padrão é <ph id="ph1">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="527" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.ArrayList.IsReadOnly">
          <source>A collection that is read-only does not allow the addition, removal, or modification of elements after the collection is created.</source>
          <target state="translated">Uma coleção que seja somente leitura não permite a adição, a remoção ou a modificação de elementos após a coleção ser criada.</target>       </trans-unit>
        <trans-unit id="528" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.ArrayList.IsReadOnly">
          <source>A collection that is read-only is simply a collection with a wrapper that prevents modifying the collection; therefore, if changes are made to the underlying collection, the read-only collection reflects those changes.</source>
          <target state="translated">Uma coleção somente leitura é apenas uma coleção com um wrapper que impede a modificação da coleção; por isso, caso as alterações sejam feitas na coleção subjacente, a coleção somente leitura reflete as alterações.</target>       </trans-unit>
        <trans-unit id="529" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.ArrayList.IsReadOnly">
          <source>Retrieving the value of this property is an O(1) operation.</source>
          <target state="translated">A recuperação do valor dessa propriedade é uma operação O(1).</target>       </trans-unit>
        <trans-unit id="530" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.ArrayList.IsReadOnly">
          <source>The following code example shows how to create a read-only wrapper around an <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph> and how to determine if an <ph id="ph2">&lt;xref:System.Collections.ArrayList&gt;</ph> is read-only.</source>
          <target state="translated">O exemplo de código a seguir mostra como criar um wrapper de somente leitura para um <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph> e como determinar se um <ph id="ph2">&lt;xref:System.Collections.ArrayList&gt;</ph> é somente leitura.</target>       </trans-unit>
        <trans-unit id="531" translate="yes" xml:space="preserve" uid="P:System.Collections.ArrayList.IsSynchronized">
          <source>Gets a value indicating whether access to the <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> is synchronized (thread safe).</source>
          <target state="translated">Obtém um valor que indica se o acesso à <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> é sincronizado (thread-safe).</target>       </trans-unit>
        <trans-unit id="532" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.ArrayList.IsSynchronized">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if access to the <ph id="ph2">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> is synchronized (thread safe); otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> caso o acesso ao <ph id="ph2">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> seja sincronizado (thread-safe); do contrário, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="533" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.ArrayList.IsSynchronized">
          <source>The default is <ph id="ph1">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">O padrão é <ph id="ph1">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="534" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.ArrayList.IsSynchronized">
          <source>To guarantee the thread safety of the <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph>, all operations must be done through the wrapper returned by the <ph id="ph2">&lt;xref:System.Collections.ArrayList.Synchronized%2A&gt;</ph> method.</source>
          <target state="translated">Para garantir a segurança de thread do <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph>, todas as operações devem ser feitas por meio do wrapper retornado pelo <ph id="ph2">&lt;xref:System.Collections.ArrayList.Synchronized%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="535" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.ArrayList.IsSynchronized">
          <source>Enumerating through a collection is intrinsically not a thread-safe procedure.</source>
          <target state="translated">A enumeração por meio de uma coleção não é um procedimento thread-safe intrínseco.</target>       </trans-unit>
        <trans-unit id="536" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.ArrayList.IsSynchronized">
          <source>Even when a collection is synchronized, other threads can still modify the collection, which causes the enumerator to throw an exception.</source>
          <target state="translated">Mesmo quando uma coleção está sincronizada, outros threads ainda podem modificar a coleção, o que faz o enumerador lançar uma exceção.</target>       </trans-unit>
        <trans-unit id="537" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.ArrayList.IsSynchronized">
          <source>To guarantee thread safety during enumeration, you can either lock the collection during the entire enumeration or catch the exceptions resulting from changes made by other threads.</source>
          <target state="translated">Para garantir thread-safe durante a enumeração, é possível bloquear a coleção durante toda a enumeração ou verificar as exceções resultantes das alterações feitas por outros threads.</target>       </trans-unit>
        <trans-unit id="538" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.ArrayList.IsSynchronized">
          <source>The following code example shows how to lock the collection using the <ph id="ph1">&lt;xref:System.Collections.ArrayList.SyncRoot%2A&gt;</ph> during the entire enumeration.</source>
          <target state="translated">O exemplo de código a seguir mostra como bloquear a coleção usando o <ph id="ph1">&lt;xref:System.Collections.ArrayList.SyncRoot%2A&gt;</ph> durante toda a enumeração.</target>       </trans-unit>
        <trans-unit id="539" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.ArrayList.IsSynchronized">
          <source>Retrieving the value of this property is an O(1) operation.</source>
          <target state="translated">A recuperação do valor dessa propriedade é uma operação O(1).</target>       </trans-unit>
        <trans-unit id="540" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.ArrayList.IsSynchronized">
          <source>The following code example shows how to synchronize an <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph>, determine if an <ph id="ph2">&lt;xref:System.Collections.ArrayList&gt;</ph> is synchronized and use a synchronized <ph id="ph3">&lt;xref:System.Collections.ArrayList&gt;</ph>.</source>
          <target state="translated">O exemplo de código a seguir mostra como sincronizar um <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph>, determinar se um <ph id="ph2">&lt;xref:System.Collections.ArrayList&gt;</ph> é sincronizado e usar um sincronizado <ph id="ph3">&lt;xref:System.Collections.ArrayList&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="541" translate="yes" xml:space="preserve" uid="P:System.Collections.ArrayList.Item(System.Int32)">
          <source>The zero-based index of the element to get or set.</source>
          <target state="translated">O índice com base em zero do elemento a ser obtido ou definido.</target>       </trans-unit>
        <trans-unit id="542" translate="yes" xml:space="preserve" uid="P:System.Collections.ArrayList.Item(System.Int32)">
          <source>Gets or sets the element at the specified index.</source>
          <target state="translated">Obtém ou define o elemento no índice especificado.</target>       </trans-unit>
        <trans-unit id="543" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.ArrayList.Item(System.Int32)">
          <source>The element at the specified index.</source>
          <target state="translated">O elemento no índice especificado.</target>       </trans-unit>
        <trans-unit id="544" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.ArrayList.Item(System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Collections.ArrayList.Item%2A&gt;</ph> returns an <ph id="ph2">&lt;xref:System.Object&gt;</ph>, so you may need to cast the returned value to the original type in order to manipulate it.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Collections.ArrayList.Item%2A&gt;</ph> retorna um <ph id="ph2">&lt;xref:System.Object&gt;</ph>, portanto, talvez seja necessário converter o valor retornado para o tipo original para manipulá-los.</target>       </trans-unit>
        <trans-unit id="545" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.ArrayList.Item(System.Int32)">
          <source>It is important to note that <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph> is not a strongly-typed collection.</source>
          <target state="translated">É importante observar que <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph> não é uma coleção fortemente tipada.</target>       </trans-unit>
        <trans-unit id="546" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.ArrayList.Item(System.Int32)">
          <source>For a strongly-typed alternative, see <ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph>.</source>
          <target state="translated">Para uma alternativa fortemente tipados, consulte <ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="547" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.ArrayList.Item(System.Int32)">
          <source><ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph> accepts <ph id="ph2">`null`</ph> as a valid value and allows duplicate elements.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph> aceita <ph id="ph2">`null`</ph> como um valor válido e permite elementos duplicados.</target>       </trans-unit>
        <trans-unit id="548" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.ArrayList.Item(System.Int32)">
          <source>This property provides the ability to access a specific element in the collection by using the following syntax: <ph id="ph1">`myCollection[index]`</ph>.</source>
          <target state="translated">Esta propriedade fornece a capacidade de acessar um elemento específico na coleção usando a seguinte sintaxe: <ph id="ph1">`myCollection[index]`</ph>.</target>       </trans-unit>
        <trans-unit id="549" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.ArrayList.Item(System.Int32)">
          <source>The C# language uses the  keyword to define the indexers instead of implementing the <ph id="ph1">&lt;xref:System.Collections.ArrayList.Item%2A&gt;</ph> property.</source>
          <target state="translated">A linguagem c# usa a palavra-chave para definir os indexadores em vez de implementar o <ph id="ph1">&lt;xref:System.Collections.ArrayList.Item%2A&gt;</ph> propriedade.</target>       </trans-unit>
        <trans-unit id="550" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.ArrayList.Item(System.Int32)">
          <source>Visual Basic implements <ph id="ph1">&lt;xref:System.Collections.ArrayList.Item%2A&gt;</ph> as a default property, which provides the same indexing functionality.</source>
          <target state="translated">Visual Basic implementa <ph id="ph1">&lt;xref:System.Collections.ArrayList.Item%2A&gt;</ph> como uma propriedade padrão, que fornece a mesma funcionalidade de indexação.</target>       </trans-unit>
        <trans-unit id="551" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.ArrayList.Item(System.Int32)">
          <source>Retrieving the value of this property is an O(1) operation; setting the property is also an O(1) operation.</source>
          <target state="translated">Recuperar o valor dessa propriedade é uma operação de (1); definindo a propriedade também é uma operação de (1).</target>       </trans-unit>
        <trans-unit id="552" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.ArrayList.Item(System.Int32)">
          <source>The following code example creates an <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph> and adds several items.</source>
          <target state="translated">O exemplo de código a seguir cria um <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph> e adiciona vários itens.</target>       </trans-unit>
        <trans-unit id="553" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.ArrayList.Item(System.Int32)">
          <source>The example demonstrates accessing elements with the <ph id="ph1">&lt;xref:System.Collections.ArrayList.Item%2A&gt;</ph> property (the indexer in C#), and changing an element by assigning a new value to the <ph id="ph2">&lt;xref:System.Collections.ArrayList.Item%2A&gt;</ph> property for a specified index.</source>
          <target state="translated">O exemplo demonstra o acesso aos elementos com o <ph id="ph1">&lt;xref:System.Collections.ArrayList.Item%2A&gt;</ph> propriedade (indexador em c#) e a alteração de um elemento, atribuindo um novo valor para o <ph id="ph2">&lt;xref:System.Collections.ArrayList.Item%2A&gt;</ph> propriedade para um índice especificado.</target>       </trans-unit>
        <trans-unit id="554" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.ArrayList.Item(System.Int32)">
          <source>The example also shows that the <ph id="ph1">&lt;xref:System.Collections.ArrayList.Item%2A&gt;</ph> property cannot be used to access or add elements outside the current size of the list.</source>
          <target state="translated">O exemplo também mostra que o <ph id="ph1">&lt;xref:System.Collections.ArrayList.Item%2A&gt;</ph> propriedade não pode ser usada para acessar ou adicionar elementos fora do tamanho atual da lista.</target>       </trans-unit>
        <trans-unit id="555" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.ArrayList.Item(System.Int32)">
          <source>The following example uses the <ph id="ph1">&lt;xref:System.Collections.ArrayList.Item%2A&gt;</ph> property explicitly to assign values to items in the list.</source>
          <target state="translated">O exemplo a seguir usa o <ph id="ph1">&lt;xref:System.Collections.ArrayList.Item%2A&gt;</ph> propriedade explicitamente para atribuir valores aos itens na lista.</target>       </trans-unit>
        <trans-unit id="556" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.ArrayList.Item(System.Int32)">
          <source>The example defines a class that inherits an <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph> and adds a method to scramble the list items.</source>
          <target state="translated">O exemplo define uma classe que herda um <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph> e adiciona um método para misturar os itens da lista.</target>       </trans-unit>
        <trans-unit id="557" translate="yes" xml:space="preserve" uid="P:System.Collections.ArrayList.Item(System.Int32)">
          <source><ph id="ph1">&lt;paramref name="index" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="index" /&gt;</ph> é menor que zero.</target>       </trans-unit>
        <trans-unit id="558" translate="yes" xml:space="preserve" uid="P:System.Collections.ArrayList.Item(System.Int32)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="559" translate="yes" xml:space="preserve" uid="P:System.Collections.ArrayList.Item(System.Int32)">
          <source><ph id="ph1">&lt;paramref name="index" /&gt;</ph> is equal to or greater than <ph id="ph2">&lt;see cref="P:System.Collections.ArrayList.Count" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="index" /&gt;</ph> é igual a ou maior que <ph id="ph2">&lt;see cref="P:System.Collections.ArrayList.Count" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="560" translate="yes" xml:space="preserve" uid="T:System.Collections.ArrayList">
          <source>Returns the zero-based index of the last occurrence of a value in the <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> or in a portion of it.</source>
          <target state="translated">Retorna o índice baseado em zero da última ocorrência de um valor no <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> ou em uma parte dele.</target>       </trans-unit>
        <trans-unit id="561" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.LastIndexOf(System.Object)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Object" /&gt;</ph> to locate in the <ph id="ph2">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph>.</source>
          <target state="translated">O <ph id="ph1">&lt;see cref="T:System.Object" /&gt;</ph> a ser localizado no <ph id="ph2">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="562" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.LastIndexOf(System.Object)">
          <source>The value can be <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">O valor pode ser <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="563" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.LastIndexOf(System.Object)">
          <source>Searches for the specified <ph id="ph1">&lt;see cref="T:System.Object" /&gt;</ph> and returns the zero-based index of the last occurrence within the entire <ph id="ph2">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph>.</source>
          <target state="translated">Pesquisa o <ph id="ph1">&lt;see cref="T:System.Object" /&gt;</ph> especificado e retorna o índice de base zero da última ocorrência dentro de todo o <ph id="ph2">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="564" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.LastIndexOf(System.Object)">
          <source>The zero-based index of the last occurrence of <ph id="ph1">&lt;paramref name="value" /&gt;</ph> within the entire the <ph id="ph2">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph>, if found; otherwise, -1.</source>
          <target state="translated">O índice de base zero da última ocorrência de <ph id="ph1">&lt;paramref name="value" /&gt;</ph> em todo o <ph id="ph2">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph>, se localizado; caso contrário, -1.</target>       </trans-unit>
        <trans-unit id="565" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.LastIndexOf(System.Object)">
          <source>The <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph> is searched backward starting at the last element and ending at the first element.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph> é pesquisado para trás, começando no último elemento e terminando no primeiro elemento.</target>       </trans-unit>
        <trans-unit id="566" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.LastIndexOf(System.Object)">
          <source>This method performs a linear search; therefore, this method is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is <ph id="ph3">&lt;xref:System.Collections.ArrayList.Count%2A&gt;</ph>.</source>
          <target state="translated">Este método executa uma pesquisa linear; por isso, esse método é uma operação O(<ph id="ph1">`n`</ph>), em que <ph id="ph2">`n`</ph> é <ph id="ph3">&lt;xref:System.Collections.ArrayList.Count%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="567" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.LastIndexOf(System.Object)">
          <source>Starting with the .NET Framework 2.0, this method uses the collection’s objects’ <ph id="ph1">&lt;xref:System.Object.Equals%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.IComparable.CompareTo%2A&gt;</ph> methods on <ph id="ph3">`item`</ph> to determine whether item exists.</source>
          <target state="translated">Começando pelo .NET Framework 2.0, esse método usa os métodos <ph id="ph1">&lt;xref:System.Object.Equals%2A&gt;</ph> e <ph id="ph2">&lt;xref:System.IComparable.CompareTo%2A&gt;</ph> do objeto da coleção em <ph id="ph3">`item`</ph> para determinar se o item existe.</target>       </trans-unit>
        <trans-unit id="568" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.LastIndexOf(System.Object)">
          <source>In the earlier versions of the .NET Framework, this determination was made by using the <ph id="ph1">&lt;xref:System.Object.Equals%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.IComparable.CompareTo%2A&gt;</ph> methods of the <ph id="ph3">`item`</ph> parameter on the objects in the collection.</source>
          <target state="translated">Em versões anteriores do .NET Framework, essa decisão era tomada usando-se os métodos <ph id="ph1">&lt;xref:System.Object.Equals%2A&gt;</ph> e <ph id="ph2">&lt;xref:System.IComparable.CompareTo%2A&gt;</ph> do parâmetro <ph id="ph3">`item`</ph> nos objetos na coleção.</target>       </trans-unit>
        <trans-unit id="569" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.LastIndexOf(System.Object)">
          <source>The following code example shows how to determine the index of the last occurrence of a specified element.</source>
          <target state="translated">O exemplo de código a seguir mostra como determinar o índice da última ocorrência de um elemento especificado.</target>       </trans-unit>
        <trans-unit id="570" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.LastIndexOf(System.Object,System.Int32)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Object" /&gt;</ph> to locate in the <ph id="ph2">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph>.</source>
          <target state="translated">O <ph id="ph1">&lt;see cref="T:System.Object" /&gt;</ph> a ser localizado no <ph id="ph2">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="571" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.LastIndexOf(System.Object,System.Int32)">
          <source>The value can be <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">O valor pode ser <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="572" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.LastIndexOf(System.Object,System.Int32)">
          <source>The zero-based starting index of the backward search.</source>
          <target state="translated">O índice inicial com base em zero da pesquisa inversa.</target>       </trans-unit>
        <trans-unit id="573" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.LastIndexOf(System.Object,System.Int32)">
          <source>Searches for the specified <ph id="ph1">&lt;see cref="T:System.Object" /&gt;</ph> and returns the zero-based index of the last occurrence within the range of elements in the <ph id="ph2">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> that extends from the first element to the specified index.</source>
          <target state="translated">Pesquisa o <ph id="ph1">&lt;see cref="T:System.Object" /&gt;</ph> especificado e retorna o índice baseado em zero da última ocorrência dentro do intervalo de elementos no <ph id="ph2">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> que se estende do primeiro elemento ao índice especificado.</target>       </trans-unit>
        <trans-unit id="574" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.LastIndexOf(System.Object,System.Int32)">
          <source>The zero-based index of the last occurrence of <ph id="ph1">&lt;paramref name="value" /&gt;</ph> within the range of elements in the <ph id="ph2">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> that extends from the first element to <ph id="ph3">&lt;paramref name="startIndex" /&gt;</ph>, if found; otherwise, -1.</source>
          <target state="translated">O índice baseado em zero da última ocorrência de <ph id="ph1">&lt;paramref name="value" /&gt;</ph> dentro do intervalo de elementos em <ph id="ph2">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> que se estende do primeiro elemento a <ph id="ph3">&lt;paramref name="startIndex" /&gt;</ph>, se encontrado; caso contrário, -1.</target>       </trans-unit>
        <trans-unit id="575" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.LastIndexOf(System.Object,System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph> is searched backward starting at <ph id="ph2">`startIndex`</ph> and ending at the first element.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph> é pesquisada começando com versões anteriores em <ph id="ph2">`startIndex`</ph> e terminando no primeiro elemento.</target>       </trans-unit>
        <trans-unit id="576" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.LastIndexOf(System.Object,System.Int32)">
          <source>This method performs a linear search; therefore, this method is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is the number of elements from the beginning of the <ph id="ph3">&lt;xref:System.Collections.ArrayList&gt;</ph> to <ph id="ph4">`startIndex`</ph>.</source>
          <target state="translated">Esse método executa uma pesquisa linear; Portanto, esse método é um O (<ph id="ph1">`n`</ph>) operação, onde <ph id="ph2">`n`</ph> é o número de elementos desde o início do <ph id="ph3">&lt;xref:System.Collections.ArrayList&gt;</ph> para <ph id="ph4">`startIndex`</ph>.</target>       </trans-unit>
        <trans-unit id="577" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.LastIndexOf(System.Object,System.Int32)">
          <source>This method determines equality by calling <ph id="ph1">&lt;xref:System.Object.Equals%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Este método determina a igualdade chamando <ph id="ph1">&lt;xref:System.Object.Equals%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="578" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.LastIndexOf(System.Object,System.Int32)">
          <source>Starting with the .NET Framework 2.0, this method uses the collection’s objects’ <ph id="ph1">&lt;xref:System.Object.Equals%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.IComparable.CompareTo%2A&gt;</ph> methods on <ph id="ph3">`item`</ph> to determine whether item exists.</source>
          <target state="translated">Começando pelo .NET Framework 2.0, esse método usa os métodos <ph id="ph1">&lt;xref:System.Object.Equals%2A&gt;</ph> e <ph id="ph2">&lt;xref:System.IComparable.CompareTo%2A&gt;</ph> do objeto da coleção em <ph id="ph3">`item`</ph> para determinar se o item existe.</target>       </trans-unit>
        <trans-unit id="579" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.LastIndexOf(System.Object,System.Int32)">
          <source>In the earlier versions of the .NET Framework, this determination was made by using the <ph id="ph1">&lt;xref:System.Object.Equals%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.IComparable.CompareTo%2A&gt;</ph> methods of the <ph id="ph3">`item`</ph> parameter on the objects in the collection.</source>
          <target state="translated">Em versões anteriores do .NET Framework, essa decisão era tomada usando-se os métodos <ph id="ph1">&lt;xref:System.Object.Equals%2A&gt;</ph> e <ph id="ph2">&lt;xref:System.IComparable.CompareTo%2A&gt;</ph> do parâmetro <ph id="ph3">`item`</ph> nos objetos na coleção.</target>       </trans-unit>
        <trans-unit id="580" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.LastIndexOf(System.Object,System.Int32)">
          <source>The following code example shows how to determine the index of the last occurrence of a specified element.</source>
          <target state="translated">O exemplo de código a seguir mostra como determinar o índice da última ocorrência de um elemento especificado.</target>       </trans-unit>
        <trans-unit id="581" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.LastIndexOf(System.Object,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> is outside the range of valid indexes for the <ph id="ph2">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> está fora do intervalo de índices válidos para o <ph id="ph2">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="582" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.LastIndexOf(System.Object,System.Int32,System.Int32)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Object" /&gt;</ph> to locate in the <ph id="ph2">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph>.</source>
          <target state="translated">O <ph id="ph1">&lt;see cref="T:System.Object" /&gt;</ph> a ser localizado no <ph id="ph2">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="583" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.LastIndexOf(System.Object,System.Int32,System.Int32)">
          <source>The value can be <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">O valor pode ser <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="584" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.LastIndexOf(System.Object,System.Int32,System.Int32)">
          <source>The zero-based starting index of the backward search.</source>
          <target state="translated">O índice inicial com base em zero da pesquisa inversa.</target>       </trans-unit>
        <trans-unit id="585" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.LastIndexOf(System.Object,System.Int32,System.Int32)">
          <source>The number of elements in the section to search.</source>
          <target state="translated">O número de elementos na seção a ser pesquisada.</target>       </trans-unit>
        <trans-unit id="586" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.LastIndexOf(System.Object,System.Int32,System.Int32)">
          <source>Searches for the specified <ph id="ph1">&lt;see cref="T:System.Object" /&gt;</ph> and returns the zero-based index of the last occurrence within the range of elements in the <ph id="ph2">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> that contains the specified number of elements and ends at the specified index.</source>
          <target state="translated">Pesquisa o <ph id="ph1">&lt;see cref="T:System.Object" /&gt;</ph> especificado e retorna o índice baseado em zero da última ocorrência no intervalo de elementos na <ph id="ph2">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> que contém o número de elementos especificado e termina no índice especificado.</target>       </trans-unit>
        <trans-unit id="587" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.LastIndexOf(System.Object,System.Int32,System.Int32)">
          <source>The zero-based index of the last occurrence of <ph id="ph1">&lt;paramref name="value" /&gt;</ph> within the range of elements in the <ph id="ph2">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> that contains <ph id="ph3">&lt;paramref name="count" /&gt;</ph> number of elements and ends at <ph id="ph4">&lt;paramref name="startIndex" /&gt;</ph>, if found; otherwise, -1.</source>
          <target state="translated">O índice baseado em zero da última ocorrência de <ph id="ph1">&lt;paramref name="value" /&gt;</ph> dentro do intervalo de elementos no <ph id="ph2">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> que contém o número <ph id="ph3">&lt;paramref name="count" /&gt;</ph> de elementos e termina em <ph id="ph4">&lt;paramref name="startIndex" /&gt;</ph>, se encontrado; caso contrário, -1.</target>       </trans-unit>
        <trans-unit id="588" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.LastIndexOf(System.Object,System.Int32,System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph> is searched backward starting at <ph id="ph2">`startIndex`</ph> and ending at <ph id="ph3">`startIndex`</ph> minus <ph id="ph4">`count`</ph> plus 1, if <ph id="ph5">`count`</ph> is greater than 0.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph> é pesquisada começando com versões anteriores em <ph id="ph2">`startIndex`</ph> e final em <ph id="ph3">`startIndex`</ph> menos <ph id="ph4">`count`</ph> mais 1, se <ph id="ph5">`count`</ph> for maior que 0.</target>       </trans-unit>
        <trans-unit id="589" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.LastIndexOf(System.Object,System.Int32,System.Int32)">
          <source>This method performs a linear search; therefore, this method is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is <ph id="ph3">`count`</ph>.</source>
          <target state="translated">Este método executa uma pesquisa linear; por isso, esse método é uma operação O(<ph id="ph1">`n`</ph>), em que <ph id="ph2">`n`</ph> é <ph id="ph3">`count`</ph>.</target>       </trans-unit>
        <trans-unit id="590" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.LastIndexOf(System.Object,System.Int32,System.Int32)">
          <source>This method determines equality by calling <ph id="ph1">&lt;xref:System.Object.Equals%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Este método determina a igualdade chamando <ph id="ph1">&lt;xref:System.Object.Equals%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="591" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.LastIndexOf(System.Object,System.Int32,System.Int32)">
          <source>Starting with the .NET Framework 2.0, this method uses the collection’s objects’ <ph id="ph1">&lt;xref:System.Object.Equals%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.IComparable.CompareTo%2A&gt;</ph> methods on <ph id="ph3">`item`</ph> to determine whether item exists.</source>
          <target state="translated">Começando pelo .NET Framework 2.0, esse método usa os métodos <ph id="ph1">&lt;xref:System.Object.Equals%2A&gt;</ph> e <ph id="ph2">&lt;xref:System.IComparable.CompareTo%2A&gt;</ph> do objeto da coleção em <ph id="ph3">`item`</ph> para determinar se o item existe.</target>       </trans-unit>
        <trans-unit id="592" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.LastIndexOf(System.Object,System.Int32,System.Int32)">
          <source>In the earlier versions of the .NET Framework, this determination was made by using the <ph id="ph1">&lt;xref:System.Object.Equals%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.IComparable.CompareTo%2A&gt;</ph> methods of the <ph id="ph3">`item`</ph> parameter on the objects in the collection.</source>
          <target state="translated">Em versões anteriores do .NET Framework, essa decisão era tomada usando-se os métodos <ph id="ph1">&lt;xref:System.Object.Equals%2A&gt;</ph> e <ph id="ph2">&lt;xref:System.IComparable.CompareTo%2A&gt;</ph> do parâmetro <ph id="ph3">`item`</ph> nos objetos na coleção.</target>       </trans-unit>
        <trans-unit id="593" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.LastIndexOf(System.Object,System.Int32,System.Int32)">
          <source>The following code example shows how to determine the index of the last occurrence of a specified element.</source>
          <target state="translated">O exemplo de código a seguir mostra como determinar o índice da última ocorrência de um elemento especificado.</target>       </trans-unit>
        <trans-unit id="594" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.LastIndexOf(System.Object,System.Int32,System.Int32)">
          <source>Note that <ph id="ph1">`LastIndexOf`</ph> is a backward search; therefore, <ph id="ph2">`count`</ph> must be less than or equal to <ph id="ph3">`startIndex`</ph> + 1.</source>
          <target state="translated">Observe que <ph id="ph1">`LastIndexOf`</ph> é uma pesquisa para trás; portanto, <ph id="ph2">`count`</ph> deve ser menor ou igual a <ph id="ph3">`startIndex`</ph> + 1.</target>       </trans-unit>
        <trans-unit id="595" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.LastIndexOf(System.Object,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> is outside the range of valid indexes for the <ph id="ph2">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> está fora do intervalo de índices válidos para o <ph id="ph2">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="596" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.LastIndexOf(System.Object,System.Int32,System.Int32)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="597" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.LastIndexOf(System.Object,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="count" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="count" /&gt;</ph> é menor que zero.</target>       </trans-unit>
        <trans-unit id="598" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.LastIndexOf(System.Object,System.Int32,System.Int32)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="599" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.LastIndexOf(System.Object,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> and <ph id="ph2">&lt;paramref name="count" /&gt;</ph> do not specify a valid section in the <ph id="ph3">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> e <ph id="ph2">&lt;paramref name="count" /&gt;</ph> não especificam uma seção válida no <ph id="ph3">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="600" translate="yes" xml:space="preserve" uid="T:System.Collections.ArrayList">
          <source>Returns a list wrapper that is read-only.</source>
          <target state="translated">Retorna um wrapper de lista somente leitura.</target>       </trans-unit>
        <trans-unit id="601" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.ReadOnly(System.Collections.ArrayList)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> to wrap.</source>
          <target state="translated">O <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> a ser encapsulado.</target>       </trans-unit>
        <trans-unit id="602" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.ReadOnly(System.Collections.ArrayList)">
          <source>Returns a read-only <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> wrapper.</source>
          <target state="translated">Retorna um wrapper <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> de somente leitura.</target>       </trans-unit>
        <trans-unit id="603" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.ReadOnly(System.Collections.ArrayList)">
          <source>A read-only <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> wrapper around <ph id="ph2">&lt;paramref name="list" /&gt;</ph>.</source>
          <target state="translated">Um wrapper <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> de somente leitura encapsula <ph id="ph2">&lt;paramref name="list" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="604" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.ReadOnly(System.Collections.ArrayList)">
          <source>To prevent any modifications to <ph id="ph1">`list`</ph>, expose <ph id="ph2">`list`</ph> only through this wrapper.</source>
          <target state="translated">Para evitar modificações <ph id="ph1">`list`</ph>, expor <ph id="ph2">`list`</ph> apenas por esse wrapper.</target>       </trans-unit>
        <trans-unit id="605" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.ReadOnly(System.Collections.ArrayList)">
          <source>A collection that is read-only is simply a collection with a wrapper that prevents modifying the collection.</source>
          <target state="translated">Uma coleção que é somente leitura é simplesmente uma coleção com um wrapper que impede a modificação da coleção.</target>       </trans-unit>
        <trans-unit id="606" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.ReadOnly(System.Collections.ArrayList)">
          <source>If changes are made to the underlying collection, the read-only collection reflects those changes.</source>
          <target state="translated">Se forem feitas alterações à coleção subjacente, a coleção somente leitura reflete as alterações.</target>       </trans-unit>
        <trans-unit id="607" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.ReadOnly(System.Collections.ArrayList)">
          <source>This method is an O(1) operation.</source>
          <target state="translated">Este método é uma operação O(1).</target>       </trans-unit>
        <trans-unit id="608" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.ReadOnly(System.Collections.ArrayList)">
          <source>The following code example shows how to create a read-only wrapper around an <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph> and how to determine if an <ph id="ph2">&lt;xref:System.Collections.ArrayList&gt;</ph> is read-only.</source>
          <target state="translated">O exemplo de código a seguir mostra como criar um wrapper de somente leitura para um <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph> e como determinar se um <ph id="ph2">&lt;xref:System.Collections.ArrayList&gt;</ph> é somente leitura.</target>       </trans-unit>
        <trans-unit id="609" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.ReadOnly(System.Collections.ArrayList)">
          <source><ph id="ph1">&lt;paramref name="list" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="list" /&gt;</ph> é <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="610" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.ReadOnly(System.Collections.IList)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.IList" /&gt;</ph> to wrap.</source>
          <target state="translated">O <ph id="ph1">&lt;see cref="T:System.Collections.IList" /&gt;</ph> a ser encapsulado.</target>       </trans-unit>
        <trans-unit id="611" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.ReadOnly(System.Collections.IList)">
          <source>Returns a read-only <ph id="ph1">&lt;see cref="T:System.Collections.IList" /&gt;</ph> wrapper.</source>
          <target state="translated">Retorna um wrapper <ph id="ph1">&lt;see cref="T:System.Collections.IList" /&gt;</ph> de somente leitura.</target>       </trans-unit>
        <trans-unit id="612" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.ReadOnly(System.Collections.IList)">
          <source>A read-only <ph id="ph1">&lt;see cref="T:System.Collections.IList" /&gt;</ph> wrapper around <ph id="ph2">&lt;paramref name="list" /&gt;</ph>.</source>
          <target state="translated">Um wrapper <ph id="ph1">&lt;see cref="T:System.Collections.IList" /&gt;</ph> de somente leitura encapsula <ph id="ph2">&lt;paramref name="list" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="613" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.ReadOnly(System.Collections.IList)">
          <source>To prevent any modifications to <ph id="ph1">`list`</ph>, expose <ph id="ph2">`list`</ph> only through this wrapper.</source>
          <target state="translated">Para evitar modificações <ph id="ph1">`list`</ph>, expor <ph id="ph2">`list`</ph> apenas por esse wrapper.</target>       </trans-unit>
        <trans-unit id="614" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.ReadOnly(System.Collections.IList)">
          <source>A collection that is read-only is simply a collection with a wrapper that prevents modifying the collection.</source>
          <target state="translated">Uma coleção que é somente leitura é simplesmente uma coleção com um wrapper que impede a modificação da coleção.</target>       </trans-unit>
        <trans-unit id="615" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.ReadOnly(System.Collections.IList)">
          <source>If changes are made to the underlying collection, the read-only collection reflects those changes.</source>
          <target state="translated">Se forem feitas alterações à coleção subjacente, a coleção somente leitura reflete as alterações.</target>       </trans-unit>
        <trans-unit id="616" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.ReadOnly(System.Collections.IList)">
          <source>This method is an O(1) operation.</source>
          <target state="translated">Este método é uma operação O(1).</target>       </trans-unit>
        <trans-unit id="617" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.ReadOnly(System.Collections.IList)">
          <source><ph id="ph1">&lt;paramref name="list" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="list" /&gt;</ph> é <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="618" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.Remove(System.Object)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Object" /&gt;</ph> to remove from the <ph id="ph2">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph>.</source>
          <target state="translated">O <ph id="ph1">&lt;see cref="T:System.Object" /&gt;</ph> a ser removido de <ph id="ph2">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="619" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.Remove(System.Object)">
          <source>The value can be <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">O valor pode ser <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="620" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.Remove(System.Object)">
          <source>Removes the first occurrence of a specific object from the <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph>.</source>
          <target state="translated">Remove a primeira ocorrência de um objeto específico do <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="621" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.Remove(System.Object)">
          <source>If the <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph> does not contain the specified object, the <ph id="ph2">&lt;xref:System.Collections.ArrayList&gt;</ph> remains unchanged.</source>
          <target state="translated">Se o <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph> não contém o objeto especificado, o <ph id="ph2">&lt;xref:System.Collections.ArrayList&gt;</ph> permanece inalterado.</target>       </trans-unit>
        <trans-unit id="622" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.Remove(System.Object)">
          <source>No exception is thrown.</source>
          <target state="translated">Nenhuma exceção é lançada.</target>       </trans-unit>
        <trans-unit id="623" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.Remove(System.Object)">
          <source>This method performs a linear search; therefore, this method is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is <ph id="ph3">&lt;xref:System.Collections.ArrayList.Count%2A&gt;</ph>.</source>
          <target state="translated">Este método executa uma pesquisa linear; por isso, esse método é uma operação O(<ph id="ph1">`n`</ph>), em que <ph id="ph2">`n`</ph> é <ph id="ph3">&lt;xref:System.Collections.ArrayList.Count%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="624" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.Remove(System.Object)">
          <source>This method determines equality by calling <ph id="ph1">&lt;xref:System.Object.Equals%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Este método determina a igualdade chamando <ph id="ph1">&lt;xref:System.Object.Equals%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="625" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.Remove(System.Object)">
          <source>In collections of contiguous elements, such as lists, the elements that follow the removed element move up to occupy the vacated spot.</source>
          <target state="translated">Em coleções de elementos contíguos, como listas, os elementos que seguem o elemento removido sobem para ocupar o ponto vazio.</target>       </trans-unit>
        <trans-unit id="626" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.Remove(System.Object)">
          <source>If the collection is indexed, the indexes of the elements that are moved are also updated.</source>
          <target state="translated">Caso a coleção seja indexada, os índices dos elementos que são movidos também são atualizados.</target>       </trans-unit>
        <trans-unit id="627" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.Remove(System.Object)">
          <source>This behavior does not apply to collections where elements are conceptually grouped into buckets, such as a hash table.</source>
          <target state="translated">Este comportamento não se aplica às coleções em que elementos sejam agrupados conceitualmente em buckets, como uma tabela de hash.</target>       </trans-unit>
        <trans-unit id="628" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.Remove(System.Object)">
          <source>The following code example shows how to remove elements from the <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph>.</source>
          <target state="translated">O exemplo de código a seguir mostra como remover elementos do <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="629" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.Remove(System.Object)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> is read-only.</source>
          <target state="translated">O <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> é somente leitura.</target>       </trans-unit>
        <trans-unit id="630" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.Remove(System.Object)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="631" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.Remove(System.Object)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> has a fixed size.</source>
          <target state="translated">O <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> tem um tamanho fixo.</target>       </trans-unit>
        <trans-unit id="632" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.RemoveAt(System.Int32)">
          <source>The zero-based index of the element to remove.</source>
          <target state="translated">O índice de base zero do elemento a ser removido.</target>       </trans-unit>
        <trans-unit id="633" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.RemoveAt(System.Int32)">
          <source>Removes the element at the specified index of the <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph>.</source>
          <target state="translated">Remove o elemento no índice especificado do <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="634" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.RemoveAt(System.Int32)">
          <source>After the element is removed, the size of the collection is adjusted and the value of the <ph id="ph1">&lt;xref:System.Collections.ArrayList.Count%2A&gt;</ph> property is decreased by one.</source>
          <target state="translated">Depois que o elemento seja removido, o tamanho da coleção é ajustado e o valor da <ph id="ph1">&lt;xref:System.Collections.ArrayList.Count%2A&gt;</ph> propriedade é reduzida por um.</target>       </trans-unit>
        <trans-unit id="635" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.RemoveAt(System.Int32)">
          <source>In collections of contiguous elements, such as lists, the elements that follow the removed element move up to occupy the vacated spot.</source>
          <target state="translated">Em coleções de elementos contíguos, como listas, os elementos que seguem o elemento removido sobem para ocupar o ponto vazio.</target>       </trans-unit>
        <trans-unit id="636" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.RemoveAt(System.Int32)">
          <source>If the collection is indexed, the indexes of the elements that are moved are also updated.</source>
          <target state="translated">Caso a coleção seja indexada, os índices dos elementos que são movidos também são atualizados.</target>       </trans-unit>
        <trans-unit id="637" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.RemoveAt(System.Int32)">
          <source>This behavior does not apply to collections where elements are conceptually grouped into buckets, such as a hash table.</source>
          <target state="translated">Este comportamento não se aplica às coleções em que elementos sejam agrupados conceitualmente em buckets, como uma tabela de hash.</target>       </trans-unit>
        <trans-unit id="638" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.RemoveAt(System.Int32)">
          <source>This method is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is <ph id="ph3">&lt;xref:System.Collections.ArrayList.Count%2A&gt;</ph>.</source>
          <target state="translated">Este método é uma operação O(<ph id="ph1">`n`</ph>), em que <ph id="ph2">`n`</ph> é <ph id="ph3">&lt;xref:System.Collections.ArrayList.Count%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="639" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.RemoveAt(System.Int32)">
          <source>The following code example shows how to remove elements from the <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph>.</source>
          <target state="translated">O exemplo de código a seguir mostra como remover elementos do <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="640" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.RemoveAt(System.Int32)">
          <source><ph id="ph1">&lt;paramref name="index" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="index" /&gt;</ph> é menor que zero.</target>       </trans-unit>
        <trans-unit id="641" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.RemoveAt(System.Int32)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="642" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.RemoveAt(System.Int32)">
          <source><ph id="ph1">&lt;paramref name="index" /&gt;</ph> is equal to or greater than <ph id="ph2">&lt;see cref="P:System.Collections.ArrayList.Count" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="index" /&gt;</ph> é igual a ou maior que <ph id="ph2">&lt;see cref="P:System.Collections.ArrayList.Count" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="643" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.RemoveAt(System.Int32)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> is read-only.</source>
          <target state="translated">O <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> é somente leitura.</target>       </trans-unit>
        <trans-unit id="644" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.RemoveAt(System.Int32)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="645" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.RemoveAt(System.Int32)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> has a fixed size.</source>
          <target state="translated">O <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> tem um tamanho fixo.</target>       </trans-unit>
        <trans-unit id="646" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.RemoveRange(System.Int32,System.Int32)">
          <source>The zero-based starting index of the range of elements to remove.</source>
          <target state="translated">O índice inicial baseado em zero do intervalo de elementos a serem removidos.</target>       </trans-unit>
        <trans-unit id="647" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.RemoveRange(System.Int32,System.Int32)">
          <source>The number of elements to remove.</source>
          <target state="translated">O número de elementos a serem removidos.</target>       </trans-unit>
        <trans-unit id="648" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.RemoveRange(System.Int32,System.Int32)">
          <source>Removes a range of elements from the <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph>.</source>
          <target state="translated">Remove um intervalo de elementos do <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="649" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.RemoveRange(System.Int32,System.Int32)">
          <source>In collections of contiguous elements, such as lists, the elements that follow the removed element move up to occupy the vacated spot.</source>
          <target state="translated">Em coleções de elementos contíguos, como listas, os elementos que seguem o elemento removido sobem para ocupar o ponto vazio.</target>       </trans-unit>
        <trans-unit id="650" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.RemoveRange(System.Int32,System.Int32)">
          <source>If the collection is indexed, the indexes of the elements that are moved are also updated.</source>
          <target state="translated">Caso a coleção seja indexada, os índices dos elementos que são movidos também são atualizados.</target>       </trans-unit>
        <trans-unit id="651" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.RemoveRange(System.Int32,System.Int32)">
          <source>This behavior does not apply to collections where elements are conceptually grouped into buckets, such as a hash table.</source>
          <target state="translated">Este comportamento não se aplica às coleções em que elementos sejam agrupados conceitualmente em buckets, como uma tabela de hash.</target>       </trans-unit>
        <trans-unit id="652" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.RemoveRange(System.Int32,System.Int32)">
          <source>This method is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is <ph id="ph3">&lt;xref:System.Collections.ArrayList.Count%2A&gt;</ph>.</source>
          <target state="translated">Este método é uma operação O(<ph id="ph1">`n`</ph>), em que <ph id="ph2">`n`</ph> é <ph id="ph3">&lt;xref:System.Collections.ArrayList.Count%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="653" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.RemoveRange(System.Int32,System.Int32)">
          <source>The following code example shows how to remove elements from the <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph>.</source>
          <target state="translated">O exemplo de código a seguir mostra como remover elementos do <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="654" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.RemoveRange(System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="index" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="index" /&gt;</ph> é menor que zero.</target>       </trans-unit>
        <trans-unit id="655" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.RemoveRange(System.Int32,System.Int32)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="656" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.RemoveRange(System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="count" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="count" /&gt;</ph> é menor que zero.</target>       </trans-unit>
        <trans-unit id="657" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.RemoveRange(System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="index" /&gt;</ph> and <ph id="ph2">&lt;paramref name="count" /&gt;</ph> do not denote a valid range of elements in the <ph id="ph3">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="index" /&gt;</ph> e <ph id="ph2">&lt;paramref name="count" /&gt;</ph> não denotam um intervalo válido de elementos no <ph id="ph3">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="658" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.RemoveRange(System.Int32,System.Int32)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> is read-only.</source>
          <target state="translated">O <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> é somente leitura.</target>       </trans-unit>
        <trans-unit id="659" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.RemoveRange(System.Int32,System.Int32)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="660" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.RemoveRange(System.Int32,System.Int32)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> has a fixed size.</source>
          <target state="translated">O <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> tem um tamanho fixo.</target>       </trans-unit>
        <trans-unit id="661" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.Repeat(System.Object,System.Int32)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Object" /&gt;</ph> to copy multiple times in the new <ph id="ph2">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph>.</source>
          <target state="translated">O <ph id="ph1">&lt;see cref="T:System.Object" /&gt;</ph> para copiar várias vezes no novo <ph id="ph2">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="662" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.Repeat(System.Object,System.Int32)">
          <source>The value can be <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">O valor pode ser <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="663" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.Repeat(System.Object,System.Int32)">
          <source>The number of times <bpt id="p1">&lt;c&gt;</bpt>value<ept id="p1">&lt;/c&gt;</ept> should be copied.</source>
          <target state="translated">O número de vezes que o <bpt id="p1">&lt;c&gt;</bpt>valor<ept id="p1">&lt;/c&gt;</ept> deve ser copiado.</target>       </trans-unit>
        <trans-unit id="664" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.Repeat(System.Object,System.Int32)">
          <source>Returns an <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> whose elements are copies of the specified value.</source>
          <target state="translated">Retorna um <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> cujos elementos são cópias do valor especificado.</target>       </trans-unit>
        <trans-unit id="665" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.Repeat(System.Object,System.Int32)">
          <source>An <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> with <ph id="ph2">&lt;paramref name="count" /&gt;</ph> number of elements, all of which are copies of <ph id="ph3">&lt;paramref name="value" /&gt;</ph>.</source>
          <target state="translated">Um <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> com <ph id="ph2">&lt;paramref name="count" /&gt;</ph> número de elementos, que são cópias de <ph id="ph3">&lt;paramref name="value" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="666" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.Repeat(System.Object,System.Int32)">
          <source><ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph> accepts <ph id="ph2">`null`</ph> as a valid value and allows duplicate elements.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph> aceita <ph id="ph2">`null`</ph> como um valor válido e permite elementos duplicados.</target>       </trans-unit>
        <trans-unit id="667" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.Repeat(System.Object,System.Int32)">
          <source>This method is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is <ph id="ph3">`count`</ph>.</source>
          <target state="translated">Este método é uma operação O(<ph id="ph1">`n`</ph>), em que <ph id="ph2">`n`</ph> é <ph id="ph3">`count`</ph>.</target>       </trans-unit>
        <trans-unit id="668" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.Repeat(System.Object,System.Int32)">
          <source>The following code example shows how to create and initialize a new <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph> with the same value.</source>
          <target state="translated">O exemplo de código a seguir mostra como criar e inicializar uma nova <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph> com o mesmo valor.</target>       </trans-unit>
        <trans-unit id="669" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.Repeat(System.Object,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="count" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="count" /&gt;</ph> é menor que zero.</target>       </trans-unit>
        <trans-unit id="670" translate="yes" xml:space="preserve" uid="T:System.Collections.ArrayList">
          <source>Reverses the order of the elements in the <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> or a portion of it.</source>
          <target state="translated">Inverte a ordem dos elementos no <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> em uma parte dele.</target>       </trans-unit>
        <trans-unit id="671" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.Reverse">
          <source>Reverses the order of the elements in the entire <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph>.</source>
          <target state="translated">Inverte a ordem dos elementos em todo o <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="672" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.Reverse">
          <source>This method uses <ph id="ph1">&lt;xref:System.Array.Reverse%2A?displayProperty=nameWithType&gt;</ph> to reverse the order of the elements, such that the element at <ph id="ph2">&lt;xref:System.Collections.ArrayList&gt;</ph> [i], where i is any index within the range, moves to <ph id="ph3">&lt;xref:System.Collections.ArrayList&gt;</ph> [j], where j equals <ph id="ph4">`index`</ph><ph id="ph5"> + </ph><ph id="ph6">`index`</ph><ph id="ph7"> + </ph><ph id="ph8">`count`</ph> - i - 1.</source>
          <target state="translated">Esse método usa <ph id="ph1">&lt;xref:System.Array.Reverse%2A?displayProperty=nameWithType&gt;</ph> para inverter a ordem dos elementos, de modo que o elemento no <ph id="ph2">&lt;xref:System.Collections.ArrayList&gt;</ph> [i], onde qualquer índice dentro do intervalo, é movido para <ph id="ph3">&lt;xref:System.Collections.ArrayList&gt;</ph> j, onde é igual a j <ph id="ph4">`index`</ph> <ph id="ph5"> + </ph> <ph id="ph6">`index`</ph> <ph id="ph7"> + </ph> <ph id="ph8">`count`</ph> - i - 1.</target>       </trans-unit>
        <trans-unit id="673" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.Reverse">
          <source>This method is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is <ph id="ph3">&lt;xref:System.Collections.ArrayList.Count%2A&gt;</ph>.</source>
          <target state="translated">Este método é uma operação O(<ph id="ph1">`n`</ph>), em que <ph id="ph2">`n`</ph> é <ph id="ph3">&lt;xref:System.Collections.ArrayList.Count%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="674" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.Reverse">
          <source>The following code example shows how to reverse the sort order of the values in an <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph>.</source>
          <target state="translated">O exemplo de código a seguir mostra como inverter a ordem de classificação dos valores em um <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="675" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.Reverse">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> is read-only.</source>
          <target state="translated">O <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> é somente leitura.</target>       </trans-unit>
        <trans-unit id="676" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.Reverse(System.Int32,System.Int32)">
          <source>The zero-based starting index of the range to reverse.</source>
          <target state="translated">O índice inicial baseado em zero do intervalo a ser revertido.</target>       </trans-unit>
        <trans-unit id="677" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.Reverse(System.Int32,System.Int32)">
          <source>The number of elements in the range to reverse.</source>
          <target state="translated">O número de elementos no intervalo a serem revertidos.</target>       </trans-unit>
        <trans-unit id="678" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.Reverse(System.Int32,System.Int32)">
          <source>Reverses the order of the elements in the specified range.</source>
          <target state="translated">Inverte a ordem dos elementos no intervalo especificado.</target>       </trans-unit>
        <trans-unit id="679" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.Reverse(System.Int32,System.Int32)">
          <source>This method uses <ph id="ph1">&lt;xref:System.Array.Reverse%2A?displayProperty=nameWithType&gt;</ph> to reverse the order of the elements, such that the element at <ph id="ph2">&lt;xref:System.Collections.ArrayList&gt;</ph> [i], where i is any index within the range, moves to <ph id="ph3">&lt;xref:System.Collections.ArrayList&gt;</ph> [j], where j equals <ph id="ph4">`index`</ph><ph id="ph5"> + </ph><ph id="ph6">`index`</ph><ph id="ph7"> + </ph><ph id="ph8">`count`</ph> - i - 1.</source>
          <target state="translated">Esse método usa <ph id="ph1">&lt;xref:System.Array.Reverse%2A?displayProperty=nameWithType&gt;</ph> para inverter a ordem dos elementos, de modo que o elemento no <ph id="ph2">&lt;xref:System.Collections.ArrayList&gt;</ph> [i], onde qualquer índice dentro do intervalo, é movido para <ph id="ph3">&lt;xref:System.Collections.ArrayList&gt;</ph> j, onde é igual a j <ph id="ph4">`index`</ph> <ph id="ph5"> + </ph> <ph id="ph6">`index`</ph> <ph id="ph7"> + </ph> <ph id="ph8">`count`</ph> - i - 1.</target>       </trans-unit>
        <trans-unit id="680" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.Reverse(System.Int32,System.Int32)">
          <source>This method is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is <ph id="ph3">`count`</ph>.</source>
          <target state="translated">Este método é uma operação O(<ph id="ph1">`n`</ph>), em que <ph id="ph2">`n`</ph> é <ph id="ph3">`count`</ph>.</target>       </trans-unit>
        <trans-unit id="681" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.Reverse(System.Int32,System.Int32)">
          <source>The following code example shows how to reverse the sort order of the values in a range of elements in an <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph>.</source>
          <target state="translated">O exemplo de código a seguir mostra como inverter a ordem de classificação dos valores em um intervalo de elementos em um <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="682" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.Reverse(System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="index" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="index" /&gt;</ph> é menor que zero.</target>       </trans-unit>
        <trans-unit id="683" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.Reverse(System.Int32,System.Int32)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="684" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.Reverse(System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="count" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="count" /&gt;</ph> é menor que zero.</target>       </trans-unit>
        <trans-unit id="685" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.Reverse(System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="index" /&gt;</ph> and <ph id="ph2">&lt;paramref name="count" /&gt;</ph> do not denote a valid range of elements in the <ph id="ph3">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="index" /&gt;</ph> e <ph id="ph2">&lt;paramref name="count" /&gt;</ph> não denotam um intervalo válido de elementos no <ph id="ph3">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="686" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.Reverse(System.Int32,System.Int32)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> is read-only.</source>
          <target state="translated">O <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> é somente leitura.</target>       </trans-unit>
        <trans-unit id="687" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.SetRange(System.Int32,System.Collections.ICollection)">
          <source>The zero-based <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> index at which to start copying the elements of <bpt id="p1">&lt;c&gt;</bpt>c<ept id="p1">&lt;/c&gt;</ept>.</source>
          <target state="translated">O índice <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> com base em zero no qual começar a copiar os elementos de <bpt id="p1">&lt;c&gt;</bpt>c<ept id="p1">&lt;/c&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="688" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.SetRange(System.Int32,System.Collections.ICollection)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.ICollection" /&gt;</ph> whose elements to copy to the <ph id="ph2">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph>.</source>
          <target state="translated">O <ph id="ph1">&lt;see cref="T:System.Collections.ICollection" /&gt;</ph> cujos elementos copiar para o <ph id="ph2">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="689" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.SetRange(System.Int32,System.Collections.ICollection)">
          <source>The collection itself cannot be <ph id="ph1">&lt;see langword="null" /&gt;</ph>, but it can contain elements that are <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">A coleção em si não pode ser <ph id="ph1">&lt;see langword="null" /&gt;</ph>, mas pode conter elementos que são <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="690" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.SetRange(System.Int32,System.Collections.ICollection)">
          <source>Copies the elements of a collection over a range of elements in the <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph>.</source>
          <target state="translated">Copia os elementos de uma coleção em um intervalo de elementos no <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="691" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.SetRange(System.Int32,System.Collections.ICollection)">
          <source><ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph> accepts <ph id="ph2">`null`</ph> as a valid value and allows duplicate elements.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph> aceita <ph id="ph2">`null`</ph> como um valor válido e permite elementos duplicados.</target>       </trans-unit>
        <trans-unit id="692" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.SetRange(System.Int32,System.Collections.ICollection)">
          <source>The order of the elements in the <ph id="ph1">&lt;xref:System.Collections.ICollection&gt;</ph> is preserved in the <ph id="ph2">&lt;xref:System.Collections.ArrayList&gt;</ph>.</source>
          <target state="translated">A ordem dos elementos no <ph id="ph1">&lt;xref:System.Collections.ICollection&gt;</ph> é preservada no <ph id="ph2">&lt;xref:System.Collections.ArrayList&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="693" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.SetRange(System.Int32,System.Collections.ICollection)">
          <source>This method is an O(<ph id="ph1">`n`</ph> + 1) operation, where <ph id="ph2">`n`</ph> is <ph id="ph3">&lt;xref:System.Collections.ArrayList.Count%2A&gt;</ph>.</source>
          <target state="translated">Esse método é um O (<ph id="ph1">`n`</ph> + 1) a operação, onde <ph id="ph2">`n`</ph> é <ph id="ph3">&lt;xref:System.Collections.ArrayList.Count%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="694" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.SetRange(System.Int32,System.Collections.ICollection)">
          <source>The following code example shows how to set and get a range of elements in the <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph>.</source>
          <target state="translated">O exemplo de código a seguir mostra como definir e obter um intervalo de elementos de <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="695" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.SetRange(System.Int32,System.Collections.ICollection)">
          <source><ph id="ph1">&lt;paramref name="index" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="index" /&gt;</ph> é menor que zero.</target>       </trans-unit>
        <trans-unit id="696" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.SetRange(System.Int32,System.Collections.ICollection)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="697" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.SetRange(System.Int32,System.Collections.ICollection)">
          <source><ph id="ph1">&lt;paramref name="index" /&gt;</ph> plus the number of elements in <ph id="ph2">&lt;paramref name="c" /&gt;</ph> is greater than <ph id="ph3">&lt;see cref="P:System.Collections.ArrayList.Count" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="index" /&gt;</ph> mais o número de elementos em <ph id="ph2">&lt;paramref name="c" /&gt;</ph> é maior que <ph id="ph3">&lt;see cref="P:System.Collections.ArrayList.Count" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="698" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.SetRange(System.Int32,System.Collections.ICollection)">
          <source><ph id="ph1">&lt;paramref name="c" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="c" /&gt;</ph> é <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="699" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.SetRange(System.Int32,System.Collections.ICollection)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> is read-only.</source>
          <target state="translated">O <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> é somente leitura.</target>       </trans-unit>
        <trans-unit id="700" translate="yes" xml:space="preserve" uid="T:System.Collections.ArrayList">
          <source>Sorts the elements in the <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> or a portion of it.</source>
          <target state="translated">Classifica os elementos no <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> ou parte dele.</target>       </trans-unit>
        <trans-unit id="701" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.Sort">
          <source>Sorts the elements in the entire <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph>.</source>
          <target state="translated">Classifica os elementos em todo o <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="702" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.Sort">
          <source>This method uses <ph id="ph1">&lt;xref:System.Array.Sort%2A?displayProperty=nameWithType&gt;</ph>, which uses the QuickSort algorithm.</source>
          <target state="translated">Esse método usa <ph id="ph1">&lt;xref:System.Array.Sort%2A?displayProperty=nameWithType&gt;</ph>, que usa o algoritmo QuickSort.</target>       </trans-unit>
        <trans-unit id="703" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.Sort">
          <source>The QuickSort algorithm is a comparison sort (also called an unstable sort), which means that a "less than or equal to" comparison operation determines which of two elements should occur first in the final sorted list.</source>
          <target state="translated">O algoritmo QuickSort é uma comparação de classificação (também chamada de uma classificação instável), o que significa que um "menor que ou igual a" operação de comparação que determina qual dos dois elementos deve ocorrer primeiro na lista classificada final.</target>       </trans-unit>
        <trans-unit id="704" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.Sort">
          <source>However, if two elements are equal, their original order might not be preserved.</source>
          <target state="translated">No entanto, se dois elementos forem iguais, sua ordem original pode não ser preservada.</target>       </trans-unit>
        <trans-unit id="705" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.Sort">
          <source>In contrast, a stable sort preserves the order of elements that are equal.</source>
          <target state="translated">Por outro lado, uma classificação estável preserva a ordem de elementos iguais.</target>       </trans-unit>
        <trans-unit id="706" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.Sort">
          <source>To perform a stable sort, you must implement a custom <ph id="ph1">&lt;xref:System.Collections.IComparer&gt;</ph> interface to use with the other overloads of this method.</source>
          <target state="translated">Para executar uma classificação estável, você deve implementar um personalizado <ph id="ph1">&lt;xref:System.Collections.IComparer&gt;</ph> interface a ser usada com outras sobrecargas do método.</target>       </trans-unit>
        <trans-unit id="707" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.Sort">
          <source>On average, this method is an O(<ph id="ph1">`n`</ph> log <ph id="ph2">`n`</ph>) operation, where <ph id="ph3">`n`</ph> is <ph id="ph4">&lt;xref:System.Collections.ArrayList.Count%2A&gt;</ph>; in the worst case it is an O(<ph id="ph5">`n`</ph>^2) operation.</source>
          <target state="translated">Em média, esse método é um O (<ph id="ph1">`n`</ph> log <ph id="ph2">`n`</ph>) operação, onde <ph id="ph3">`n`</ph> é <ph id="ph4">&lt;xref:System.Collections.ArrayList.Count%2A&gt;</ph>; no pior caso é um O (<ph id="ph5">`n`</ph>^ 2) operação.</target>       </trans-unit>
        <trans-unit id="708" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.Sort">
          <source>The following code example shows how to sort the values in an <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph>.</source>
          <target state="translated">O exemplo de código a seguir mostra como classificar os valores em um <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="709" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.Sort">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> is read-only.</source>
          <target state="translated">O <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> é somente leitura.</target>       </trans-unit>
        <trans-unit id="710" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.Sort(System.Collections.IComparer)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.IComparer" /&gt;</ph> implementation to use when comparing elements.</source>
          <target state="translated">A implementação de <ph id="ph1">&lt;see cref="T:System.Collections.IComparer" /&gt;</ph> a ser usada durante a comparação de elementos.</target>       </trans-unit>
        <trans-unit id="711" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.Sort(System.Collections.IComparer)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="712" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.Sort(System.Collections.IComparer)">
          <source>A null reference (<ph id="ph1">&lt;see langword="Nothing" /&gt;</ph> in Visual Basic) to use the <ph id="ph2">&lt;see cref="T:System.IComparable" /&gt;</ph> implementation of each element.</source>
          <target state="translated">Uma referência nula (<ph id="ph1">&lt;see langword="Nothing" /&gt;</ph> no Visual Basic) para usar a implementação de <ph id="ph2">&lt;see cref="T:System.IComparable" /&gt;</ph> de cada elemento.</target>       </trans-unit>
        <trans-unit id="713" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.Sort(System.Collections.IComparer)">
          <source>Sorts the elements in the entire <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> using the specified comparer.</source>
          <target state="translated">Classifica os elementos em todo o <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> usando o comparador especificado.</target>       </trans-unit>
        <trans-unit id="714" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.Sort(System.Collections.IComparer)">
          <source>Use the <ph id="ph1">&lt;xref:System.Collections.ArrayList.Sort%2A&gt;</ph> method to  sort a list of objects with a custom comparer that implements the <ph id="ph2">&lt;xref:System.Collections.IComparer&gt;</ph> interface.</source>
          <target state="translated">Use o <ph id="ph1">&lt;xref:System.Collections.ArrayList.Sort%2A&gt;</ph> método para classificar uma lista de objetos com um comparador personalizado que implementa o <ph id="ph2">&lt;xref:System.Collections.IComparer&gt;</ph> interface.</target>       </trans-unit>
        <trans-unit id="715" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.Sort(System.Collections.IComparer)">
          <source>If you pass <ph id="ph1">`null`</ph> for <ph id="ph2">`comparer`</ph>, this method uses the <ph id="ph3">&lt;xref:System.IComparable&gt;</ph> implementation of each element.</source>
          <target state="translated">Se você passar <ph id="ph1">`null`</ph> para <ph id="ph2">`comparer`</ph>, esse método usa o <ph id="ph3">&lt;xref:System.IComparable&gt;</ph> implementação de cada elemento.</target>       </trans-unit>
        <trans-unit id="716" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.Sort(System.Collections.IComparer)">
          <source>In this case, you must make sure that the objects contained in the list implement the <ph id="ph1">&lt;xref:System.Collections.IComparer&gt;</ph> interface or an exception will occur.</source>
          <target state="translated">Nesse caso, você deve garantir que os objetos contidos na lista de implementam o <ph id="ph1">&lt;xref:System.Collections.IComparer&gt;</ph> interface ou uma exceção ocorrerá.</target>       </trans-unit>
        <trans-unit id="717" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.Sort(System.Collections.IComparer)">
          <source>In addition, using the <ph id="ph1">&lt;xref:System.IComparable&gt;</ph> implementation means the list performs a comparison sort (also called an unstable sort); that is, if two elements are equal, their order might not be preserved.</source>
          <target state="translated">Além disso, usando o <ph id="ph1">&lt;xref:System.IComparable&gt;</ph> implementação significa que a lista executa uma classificação de comparação (também chamada de uma classificação instável); ou seja, se dois elementos forem iguais, a ordem pode não ser preservada.</target>       </trans-unit>
        <trans-unit id="718" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.Sort(System.Collections.IComparer)">
          <source>In contrast, a stable sort preserves the order of elements that are equal.</source>
          <target state="translated">Por outro lado, uma classificação estável preserva a ordem de elementos iguais.</target>       </trans-unit>
        <trans-unit id="719" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.Sort(System.Collections.IComparer)">
          <source>To perform a stable sort, you must implement a custom <ph id="ph1">&lt;xref:System.Collections.IComparer&gt;</ph> interface.</source>
          <target state="translated">Para executar uma classificação estável, você deve implementar um personalizado <ph id="ph1">&lt;xref:System.Collections.IComparer&gt;</ph> interface.</target>       </trans-unit>
        <trans-unit id="720" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.Sort(System.Collections.IComparer)">
          <source>On average, this method is an O(<ph id="ph1">`n`</ph> log <ph id="ph2">`n`</ph>) operation, where <ph id="ph3">`n`</ph> is <ph id="ph4">&lt;xref:System.Collections.ArrayList.Count%2A&gt;</ph>; in the worst case it is an O(<ph id="ph5">`n`</ph>^2) operation.</source>
          <target state="translated">Em média, esse método é um O (<ph id="ph1">`n`</ph> log <ph id="ph2">`n`</ph>) operação, onde <ph id="ph3">`n`</ph> é <ph id="ph4">&lt;xref:System.Collections.ArrayList.Count%2A&gt;</ph>; no pior caso é um O (<ph id="ph5">`n`</ph>^ 2) operação.</target>       </trans-unit>
        <trans-unit id="721" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.Sort(System.Collections.IComparer)">
          <source>The following code example shows how to sort the values in an <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph> using the default comparer and a custom comparer that reverses the sort order.</source>
          <target state="translated">O exemplo de código a seguir mostra como classificar os valores em um <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph> usando a comparação padrão e uma comparação personalizada que inverte a ordem de classificação.</target>       </trans-unit>
        <trans-unit id="722" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.Sort(System.Collections.IComparer)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> is read-only.</source>
          <target state="translated">O <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> é somente leitura.</target>       </trans-unit>
        <trans-unit id="723" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.Sort(System.Collections.IComparer)">
          <source>An error occurred while comparing two elements.</source>
          <target state="translated">Erro ao comparar dois elementos.</target>       </trans-unit>
        <trans-unit id="724" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.Sort(System.Collections.IComparer)">
          <source><ph id="ph1">&lt;see langword="null" /&gt;</ph> is passed for <ph id="ph2">&lt;paramref name="comparer" /&gt;</ph>, and the elements in the list do not implement <ph id="ph3">&lt;see cref="T:System.IComparable" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="null" /&gt;</ph> é passado para <ph id="ph2">&lt;paramref name="comparer" /&gt;</ph>, e os elementos na lista não implementam <ph id="ph3">&lt;see cref="T:System.IComparable" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="725" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.Sort(System.Int32,System.Int32,System.Collections.IComparer)">
          <source>The zero-based starting index of the range to sort.</source>
          <target state="translated">O índice inicial baseado em zero do intervalo a ser classificado.</target>       </trans-unit>
        <trans-unit id="726" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.Sort(System.Int32,System.Int32,System.Collections.IComparer)">
          <source>The length of the range to sort.</source>
          <target state="translated">O tamanho do intervalo a ser classificado.</target>       </trans-unit>
        <trans-unit id="727" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.Sort(System.Int32,System.Int32,System.Collections.IComparer)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.IComparer" /&gt;</ph> implementation to use when comparing elements.</source>
          <target state="translated">A implementação de <ph id="ph1">&lt;see cref="T:System.Collections.IComparer" /&gt;</ph> a ser usada durante a comparação de elementos.</target>       </trans-unit>
        <trans-unit id="728" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.Sort(System.Int32,System.Int32,System.Collections.IComparer)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="729" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.Sort(System.Int32,System.Int32,System.Collections.IComparer)">
          <source>A null reference (<ph id="ph1">&lt;see langword="Nothing" /&gt;</ph> in Visual Basic) to use the <ph id="ph2">&lt;see cref="T:System.IComparable" /&gt;</ph> implementation of each element.</source>
          <target state="translated">Uma referência nula (<ph id="ph1">&lt;see langword="Nothing" /&gt;</ph> no Visual Basic) para usar a implementação de <ph id="ph2">&lt;see cref="T:System.IComparable" /&gt;</ph> de cada elemento.</target>       </trans-unit>
        <trans-unit id="730" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.Sort(System.Int32,System.Int32,System.Collections.IComparer)">
          <source>Sorts the elements in a range of elements in <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> using the specified comparer.</source>
          <target state="translated">Classifica os elementos em um intervalo de elementos em <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> usando o comparador especificado.</target>       </trans-unit>
        <trans-unit id="731" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.Sort(System.Int32,System.Int32,System.Collections.IComparer)">
          <source>If <ph id="ph1">`comparer`</ph> is set to <ph id="ph2">`null`</ph>, this method performs a comparison sort (also called an unstable sort); that is, if two elements are equal, their order might not be preserved.</source>
          <target state="translated">Se <ph id="ph1">`comparer`</ph> é definido como <ph id="ph2">`null`</ph>, esse método executa uma classificação de comparação (também chamada de uma classificação instável); ou seja, se dois elementos forem iguais, a ordem pode não ser preservada.</target>       </trans-unit>
        <trans-unit id="732" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.Sort(System.Int32,System.Int32,System.Collections.IComparer)">
          <source>In contrast, a stable sort preserves the order of elements that are equal.</source>
          <target state="translated">Por outro lado, uma classificação estável preserva a ordem de elementos iguais.</target>       </trans-unit>
        <trans-unit id="733" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.Sort(System.Int32,System.Int32,System.Collections.IComparer)">
          <source>To perform a stable sort, you must implement a custom <ph id="ph1">&lt;xref:System.Collections.IComparer&gt;</ph> interface.</source>
          <target state="translated">Para executar uma classificação estável, você deve implementar um personalizado <ph id="ph1">&lt;xref:System.Collections.IComparer&gt;</ph> interface.</target>       </trans-unit>
        <trans-unit id="734" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.Sort(System.Int32,System.Int32,System.Collections.IComparer)">
          <source>On average, this method is an O(<ph id="ph1">`n`</ph> log <ph id="ph2">`n`</ph>) operation, where <ph id="ph3">`n`</ph> is <ph id="ph4">`count`</ph>; in the worst case it is an O(n^2) operation.</source>
          <target state="translated">Em média, esse método é um O (<ph id="ph1">`n`</ph> log <ph id="ph2">`n`</ph>) operação, onde <ph id="ph3">`n`</ph> é <ph id="ph4">`count`</ph>; no pior caso é uma operação de O(n^2).</target>       </trans-unit>
        <trans-unit id="735" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.Sort(System.Int32,System.Int32,System.Collections.IComparer)">
          <source>The following code example shows how to sort the values in a range of elements in an <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph> using the default comparer and a custom comparer that reverses the sort order.</source>
          <target state="translated">O exemplo de código a seguir mostra como classificar os valores em um intervalo de elementos em um <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph> usando o comparador padrão e um comparador personalizado que inverte a ordem de classificação.</target>       </trans-unit>
        <trans-unit id="736" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.Sort(System.Int32,System.Int32,System.Collections.IComparer)">
          <source><ph id="ph1">&lt;paramref name="index" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="index" /&gt;</ph> é menor que zero.</target>       </trans-unit>
        <trans-unit id="737" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.Sort(System.Int32,System.Int32,System.Collections.IComparer)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="738" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.Sort(System.Int32,System.Int32,System.Collections.IComparer)">
          <source><ph id="ph1">&lt;paramref name="count" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="count" /&gt;</ph> é menor que zero.</target>       </trans-unit>
        <trans-unit id="739" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.Sort(System.Int32,System.Int32,System.Collections.IComparer)">
          <source><ph id="ph1">&lt;paramref name="index" /&gt;</ph> and <ph id="ph2">&lt;paramref name="count" /&gt;</ph> do not specify a valid range in the <ph id="ph3">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="index" /&gt;</ph> e <ph id="ph2">&lt;paramref name="count" /&gt;</ph> não especificam um intervalo válido no <ph id="ph3">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="740" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.Sort(System.Int32,System.Int32,System.Collections.IComparer)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> is read-only.</source>
          <target state="translated">O <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> é somente leitura.</target>       </trans-unit>
        <trans-unit id="741" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.Sort(System.Int32,System.Int32,System.Collections.IComparer)">
          <source>An error occurred while comparing two elements.</source>
          <target state="translated">Erro ao comparar dois elementos.</target>       </trans-unit>
        <trans-unit id="742" translate="yes" xml:space="preserve" uid="T:System.Collections.ArrayList">
          <source>Returns a list wrapper that is synchronized (thread safe).</source>
          <target state="translated">Retorna um wrapper de lista sincronizado (thread-safe).</target>       </trans-unit>
        <trans-unit id="743" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.Synchronized(System.Collections.ArrayList)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> to synchronize.</source>
          <target state="translated">O <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> a ser sincronizado.</target>       </trans-unit>
        <trans-unit id="744" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.Synchronized(System.Collections.ArrayList)">
          <source>Returns an <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> wrapper that is synchronized (thread safe).</source>
          <target state="translated">Retorna um wrapper <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> sincronizado (thread-safe).</target>       </trans-unit>
        <trans-unit id="745" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.Synchronized(System.Collections.ArrayList)">
          <source>An <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> wrapper that is synchronized (thread safe).</source>
          <target state="translated">Um wrapper <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> sincronizado (thread-safe).</target>       </trans-unit>
        <trans-unit id="746" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.Synchronized(System.Collections.ArrayList)">
          <source>To guarantee the thread safety of the <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph>, all operations must be done through this wrapper.</source>
          <target state="translated">Para garantir a segurança de thread do <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph>, todas as operações devem ser feitas por meio desse wrapper.</target>       </trans-unit>
        <trans-unit id="747" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.Synchronized(System.Collections.ArrayList)">
          <source>Enumerating through a collection is intrinsically not a thread-safe procedure.</source>
          <target state="translated">A enumeração por meio de uma coleção não é um procedimento thread-safe intrínseco.</target>       </trans-unit>
        <trans-unit id="748" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.Synchronized(System.Collections.ArrayList)">
          <source>Even when a collection is synchronized, other threads can still modify the collection, which causes the enumerator to throw an exception.</source>
          <target state="translated">Mesmo quando uma coleção está sincronizada, outros threads ainda podem modificar a coleção, o que faz o enumerador lançar uma exceção.</target>       </trans-unit>
        <trans-unit id="749" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.Synchronized(System.Collections.ArrayList)">
          <source>To guarantee thread safety during enumeration, you can either lock the collection during the entire enumeration or catch the exceptions resulting from changes made by other threads.</source>
          <target state="translated">Para garantir thread-safe durante a enumeração, é possível bloquear a coleção durante toda a enumeração ou verificar as exceções resultantes das alterações feitas por outros threads.</target>       </trans-unit>
        <trans-unit id="750" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.Synchronized(System.Collections.ArrayList)">
          <source>The following code example shows how to lock the collection using the <ph id="ph1">&lt;xref:System.Collections.ArrayList.SyncRoot%2A&gt;</ph> during the entire enumeration.</source>
          <target state="translated">O exemplo de código a seguir mostra como bloquear a coleção usando o <ph id="ph1">&lt;xref:System.Collections.ArrayList.SyncRoot%2A&gt;</ph> durante toda a enumeração.</target>       </trans-unit>
        <trans-unit id="751" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.Synchronized(System.Collections.ArrayList)">
          <source>This method is an O(1) operation.</source>
          <target state="translated">Este método é uma operação O(1).</target>       </trans-unit>
        <trans-unit id="752" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.Synchronized(System.Collections.ArrayList)">
          <source>The following code example shows how to synchronize an <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph>, determine if an <ph id="ph2">&lt;xref:System.Collections.ArrayList&gt;</ph> is synchronized and use a synchronized <ph id="ph3">&lt;xref:System.Collections.ArrayList&gt;</ph>.</source>
          <target state="translated">O exemplo de código a seguir mostra como sincronizar um <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph>, determinar se um <ph id="ph2">&lt;xref:System.Collections.ArrayList&gt;</ph> é sincronizado e usar um sincronizado <ph id="ph3">&lt;xref:System.Collections.ArrayList&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="753" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.Synchronized(System.Collections.ArrayList)">
          <source><ph id="ph1">&lt;paramref name="list" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="list" /&gt;</ph> é <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="754" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.Synchronized(System.Collections.IList)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.IList" /&gt;</ph> to synchronize.</source>
          <target state="translated">O <ph id="ph1">&lt;see cref="T:System.Collections.IList" /&gt;</ph> a ser sincronizado.</target>       </trans-unit>
        <trans-unit id="755" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.Synchronized(System.Collections.IList)">
          <source>Returns an <ph id="ph1">&lt;see cref="T:System.Collections.IList" /&gt;</ph> wrapper that is synchronized (thread safe).</source>
          <target state="translated">Retorna um wrapper <ph id="ph1">&lt;see cref="T:System.Collections.IList" /&gt;</ph> sincronizado (thread-safe).</target>       </trans-unit>
        <trans-unit id="756" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.Synchronized(System.Collections.IList)">
          <source>An <ph id="ph1">&lt;see cref="T:System.Collections.IList" /&gt;</ph> wrapper that is synchronized (thread safe).</source>
          <target state="translated">Um wrapper <ph id="ph1">&lt;see cref="T:System.Collections.IList" /&gt;</ph> sincronizado (thread-safe).</target>       </trans-unit>
        <trans-unit id="757" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.Synchronized(System.Collections.IList)">
          <source>To guarantee the thread safety of the <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph>, all operations must be done through this wrapper.</source>
          <target state="translated">Para garantir a segurança de thread do <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph>, todas as operações devem ser feitas por meio desse wrapper.</target>       </trans-unit>
        <trans-unit id="758" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.Synchronized(System.Collections.IList)">
          <source>Enumerating through a collection is intrinsically not a thread-safe procedure.</source>
          <target state="translated">A enumeração por meio de uma coleção não é um procedimento thread-safe intrínseco.</target>       </trans-unit>
        <trans-unit id="759" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.Synchronized(System.Collections.IList)">
          <source>Even when a collection is synchronized, other threads can still modify the collection, which causes the enumerator to throw an exception.</source>
          <target state="translated">Mesmo quando uma coleção está sincronizada, outros threads ainda podem modificar a coleção, o que faz o enumerador lançar uma exceção.</target>       </trans-unit>
        <trans-unit id="760" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.Synchronized(System.Collections.IList)">
          <source>To guarantee thread safety during enumeration, you can either lock the collection during the entire enumeration or catch the exceptions resulting from changes made by other threads.</source>
          <target state="translated">Para garantir thread-safe durante a enumeração, é possível bloquear a coleção durante toda a enumeração ou verificar as exceções resultantes das alterações feitas por outros threads.</target>       </trans-unit>
        <trans-unit id="761" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.Synchronized(System.Collections.IList)">
          <source>The following code example shows how to lock the collection using the <ph id="ph1">&lt;xref:System.Collections.ArrayList.SyncRoot%2A&gt;</ph> during the entire enumeration.</source>
          <target state="translated">O exemplo de código a seguir mostra como bloquear a coleção usando o <ph id="ph1">&lt;xref:System.Collections.ArrayList.SyncRoot%2A&gt;</ph> durante toda a enumeração.</target>       </trans-unit>
        <trans-unit id="762" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.Synchronized(System.Collections.IList)">
          <source>This method is an O(1) operation.</source>
          <target state="translated">Este método é uma operação O(1).</target>       </trans-unit>
        <trans-unit id="763" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.Synchronized(System.Collections.IList)">
          <source><ph id="ph1">&lt;paramref name="list" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="list" /&gt;</ph> é <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="764" translate="yes" xml:space="preserve" uid="P:System.Collections.ArrayList.SyncRoot">
          <source>Gets an object that can be used to synchronize access to the <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph>.</source>
          <target state="translated">Obtém um objeto que pode ser usado para sincronizar o acesso ao <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="765" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.ArrayList.SyncRoot">
          <source>An object that can be used to synchronize access to the <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph>.</source>
          <target state="translated">Um objeto que pode ser usado para sincronizar o acesso ao <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="766" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.ArrayList.SyncRoot">
          <source>To create a synchronized version of the <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Collections.ArrayList.Synchronized%2A&gt;</ph> method.</source>
          <target state="translated">Para criar uma versão sincronizada do <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph>, use o <ph id="ph2">&lt;xref:System.Collections.ArrayList.Synchronized%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="767" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.ArrayList.SyncRoot">
          <source>However, derived classes can provide their own synchronized version of the <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph> using the <ph id="ph2">&lt;xref:System.Collections.ArrayList.SyncRoot%2A&gt;</ph> property.</source>
          <target state="translated">No entanto, as classes derivadas podem fornecer sua própria versão sincronizada de <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph> usando o <ph id="ph2">&lt;xref:System.Collections.ArrayList.SyncRoot%2A&gt;</ph> propriedade.</target>       </trans-unit>
        <trans-unit id="768" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.ArrayList.SyncRoot">
          <source>The synchronizing code must perform operations on the <ph id="ph1">&lt;xref:System.Collections.ArrayList.SyncRoot%2A&gt;</ph> of the <ph id="ph2">&lt;xref:System.Collections.ArrayList&gt;</ph>, not directly on the <ph id="ph3">&lt;xref:System.Collections.ArrayList&gt;</ph>.</source>
          <target state="translated">O código de sincronização necessário realizar operações no <ph id="ph1">&lt;xref:System.Collections.ArrayList.SyncRoot%2A&gt;</ph> do <ph id="ph2">&lt;xref:System.Collections.ArrayList&gt;</ph>, não diretamente no <ph id="ph3">&lt;xref:System.Collections.ArrayList&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="769" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.ArrayList.SyncRoot">
          <source>This ensures proper operation of collections that are derived from other objects.</source>
          <target state="translated">Isso garante a operação apropriada das coleções que são derivadas de outros objetos.</target>       </trans-unit>
        <trans-unit id="770" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.ArrayList.SyncRoot">
          <source>Specifically, it maintains proper synchronization with other threads that might be simultaneously modifying the <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph> object.</source>
          <target state="translated">Especificamente, ele mantém uma sincronização adequada com outros threads que podem ser simultaneamente modificando o <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph> objeto.</target>       </trans-unit>
        <trans-unit id="771" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.ArrayList.SyncRoot">
          <source>Enumerating through a collection is intrinsically not a thread-safe procedure.</source>
          <target state="translated">A enumeração por meio de uma coleção não é um procedimento thread-safe intrínseco.</target>       </trans-unit>
        <trans-unit id="772" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.ArrayList.SyncRoot">
          <source>Even when a collection is synchronized, other threads can still modify the collection, which causes the enumerator to throw an exception.</source>
          <target state="translated">Mesmo quando uma coleção está sincronizada, outros threads ainda podem modificar a coleção, o que faz o enumerador lançar uma exceção.</target>       </trans-unit>
        <trans-unit id="773" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.ArrayList.SyncRoot">
          <source>To guarantee thread safety during enumeration, you can either lock the collection during the entire enumeration or catch the exceptions resulting from changes made by other threads.</source>
          <target state="translated">Para garantir thread-safe durante a enumeração, é possível bloquear a coleção durante toda a enumeração ou verificar as exceções resultantes das alterações feitas por outros threads.</target>       </trans-unit>
        <trans-unit id="774" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.ArrayList.SyncRoot">
          <source>The following code example shows how to lock the collection using the <ph id="ph1">&lt;xref:System.Collections.ArrayList.SyncRoot%2A&gt;</ph> during the entire enumeration.</source>
          <target state="translated">O exemplo de código a seguir mostra como bloquear a coleção usando o <ph id="ph1">&lt;xref:System.Collections.ArrayList.SyncRoot%2A&gt;</ph> durante toda a enumeração.</target>       </trans-unit>
        <trans-unit id="775" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.ArrayList.SyncRoot">
          <source>Retrieving the value of this property is an O(1) operation.</source>
          <target state="translated">A recuperação do valor dessa propriedade é uma operação O(1).</target>       </trans-unit>
        <trans-unit id="776" translate="yes" xml:space="preserve" uid="T:System.Collections.ArrayList">
          <source>Copies the elements of the <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> to a new array.</source>
          <target state="translated">Copia os elementos do <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> em uma nova matriz.</target>       </trans-unit>
        <trans-unit id="777" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.ToArray">
          <source>Copies the elements of the <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> to a new <ph id="ph2">&lt;see cref="T:System.Object" /&gt;</ph> array.</source>
          <target state="translated">Copia os elementos do <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> em uma nova matriz <ph id="ph2">&lt;see cref="T:System.Object" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="778" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.ToArray">
          <source>An <ph id="ph1">&lt;see cref="T:System.Object" /&gt;</ph> array containing copies of the elements of the <ph id="ph2">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph>.</source>
          <target state="translated">Uma matriz <ph id="ph1">&lt;see cref="T:System.Object" /&gt;</ph> que contém cópias dos elementos do <ph id="ph2">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="779" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.ToArray">
          <source>The elements are copied using <ph id="ph1">&lt;xref:System.Array.Copy%2A?displayProperty=nameWithType&gt;</ph>, which is an O(<ph id="ph2">`n`</ph>) operation, where <ph id="ph3">`n`</ph> is <ph id="ph4">&lt;xref:System.Collections.ArrayList.Count%2A&gt;</ph>.</source>
          <target state="translated">Os elementos são copiados usando <ph id="ph1">&lt;xref:System.Array.Copy%2A?displayProperty=nameWithType&gt;</ph>, que é um O (<ph id="ph2">`n`</ph>) operação, onde <ph id="ph3">`n`</ph> é <ph id="ph4">&lt;xref:System.Collections.ArrayList.Count%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="780" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.ToArray(System.Type)">
          <source>The element <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> of the destination array to create and copy elements to.</source>
          <target state="translated">O elemento <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> da matriz de destino para criação e cópia dos elementos.</target>       </trans-unit>
        <trans-unit id="781" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.ToArray(System.Type)">
          <source>Copies the elements of the <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> to a new array of the specified element type.</source>
          <target state="translated">Copia os elementos do <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> em uma nova matriz do tipo de elemento especificado.</target>       </trans-unit>
        <trans-unit id="782" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.ToArray(System.Type)">
          <source>An array of the specified element type containing copies of the elements of the <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph>.</source>
          <target state="translated">Uma matriz do tipo de elemento especificado que contém cópias dos elementos do <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="783" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.ToArray(System.Type)">
          <source>All of the objects in the <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph> object will be cast to the <ph id="ph2">&lt;xref:System.Type&gt;</ph> specified in the <ph id="ph3">`type`</ph> parameter.</source>
          <target state="translated">Todos os objetos no <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph> objeto será convertido para o <ph id="ph2">&lt;xref:System.Type&gt;</ph> especificado no <ph id="ph3">`type`</ph> parâmetro.</target>       </trans-unit>
        <trans-unit id="784" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.ToArray(System.Type)">
          <source>The elements are copied using <ph id="ph1">&lt;xref:System.Array.Copy%2A?displayProperty=nameWithType&gt;</ph>, which is an O(<ph id="ph2">`n`</ph>) operation, where <ph id="ph3">`n`</ph> is <ph id="ph4">&lt;xref:System.Collections.ArrayList.Count%2A&gt;</ph>.</source>
          <target state="translated">Os elementos são copiados usando <ph id="ph1">&lt;xref:System.Array.Copy%2A?displayProperty=nameWithType&gt;</ph>, que é um O (<ph id="ph2">`n`</ph>) operação, onde <ph id="ph3">`n`</ph> é <ph id="ph4">&lt;xref:System.Collections.ArrayList.Count%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="785" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.ToArray(System.Type)">
          <source>The following copy example shows how to copy the elements of an <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph> to a string array.</source>
          <target state="translated">O exemplo de cópia a seguir mostra como copiar os elementos de um <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph> para uma matriz de cadeia de caracteres.</target>       </trans-unit>
        <trans-unit id="786" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.ToArray(System.Type)">
          <source><ph id="ph1">&lt;paramref name="type" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="type" /&gt;</ph> é <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="787" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.ToArray(System.Type)">
          <source>The type of the source <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> cannot be cast automatically to the specified type.</source>
          <target state="translated">O tipo do <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> de origem não pode ser convertido automaticamente no tipo especificado.</target>       </trans-unit>
        <trans-unit id="788" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.TrimToSize">
          <source>Sets the capacity to the actual number of elements in the <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph>.</source>
          <target state="translated">Define a capacidade para o número real de elementos em <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="789" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.TrimToSize">
          <source>This method can be used to minimize a collection's memory overhead if no new elements will be added to the collection.</source>
          <target state="translated">Esse método pode ser usado para minimizar a memória da coleção sobrecarga se nenhum elemento novo será adicionado à coleção.</target>       </trans-unit>
        <trans-unit id="790" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.TrimToSize">
          <source>To reset a <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph> to its initial state, call the <ph id="ph2">&lt;xref:System.Collections.ArrayList.Clear%2A&gt;</ph> method before calling <ph id="ph3">&lt;xref:System.Collections.ArrayList.TrimToSize%2A&gt;</ph>.</source>
          <target state="translated">Para redefinir um <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph> para seu estado inicial, chame o <ph id="ph2">&lt;xref:System.Collections.ArrayList.Clear%2A&gt;</ph> método antes de chamar <ph id="ph3">&lt;xref:System.Collections.ArrayList.TrimToSize%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="791" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.TrimToSize">
          <source>Trimming an empty <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph> sets the capacity of the <ph id="ph2">&lt;xref:System.Collections.ArrayList&gt;</ph> to the default capacity.</source>
          <target state="translated">Cortar vazio <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph> define a capacidade do <ph id="ph2">&lt;xref:System.Collections.ArrayList&gt;</ph> à capacidade padrão.</target>       </trans-unit>
        <trans-unit id="792" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.TrimToSize">
          <source>This method is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is <ph id="ph3">&lt;xref:System.Collections.ArrayList.Count%2A&gt;</ph>.</source>
          <target state="translated">Este método é uma operação O(<ph id="ph1">`n`</ph>), em que <ph id="ph2">`n`</ph> é <ph id="ph3">&lt;xref:System.Collections.ArrayList.Count%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="793" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.TrimToSize">
          <source>The following code example shows how to trim the unused portions of the <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph> and how to clear the values of the <ph id="ph2">&lt;xref:System.Collections.ArrayList&gt;</ph>.</source>
          <target state="translated">O exemplo de código a seguir mostra como cortar as partes não utilizadas do <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph> e como limpar os valores a <ph id="ph2">&lt;xref:System.Collections.ArrayList&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="794" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.TrimToSize">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> is read-only.</source>
          <target state="translated">O <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> é somente leitura.</target>       </trans-unit>
        <trans-unit id="795" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.TrimToSize">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="796" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.TrimToSize">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> has a fixed size.</source>
          <target state="translated">O <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> tem um tamanho fixo.</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>