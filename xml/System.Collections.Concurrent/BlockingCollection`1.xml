<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="BlockingCollection`1.xml" source-language="en-US" target-language="pt-BR">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-15c36f0" tool-company="Microsoft" />
      <xliffext:skl_file_name xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">02cd5861-7ce2-4a82-b358-31f8435a0ac50df771ecf34f5bb842d4f014e7a03bea934d6866.skl</xliffext:skl_file_name>
      <xliffext:version xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">1.2</xliffext:version>
      <xliffext:ms.openlocfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">0df771ecf34f5bb842d4f014e7a03bea934d6866</xliffext:ms.openlocfilehash>
      <xliffext:ms.sourcegitcommit xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b</xliffext:ms.sourcegitcommit>
      <xliffext:ms.lasthandoff xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">04/03/2018</xliffext:ms.lasthandoff>
      <xliffext:moniker_ids xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">netcore-1.0,netcore-1.1,netcore-2.0,netcore-2.1,netframework-4.5.1,netframework-4.5.2,netframework-4.5,netframework-4.6.1,netframework-4.6.2,netframework-4.6,netframework-4.7.1,netframework-4.7,netstandard-1.1,netstandard-1.2,netstandard-1.3,netstandard-1.4,netstandard-1.6,netstandard-2.0,xamarinandroid-7.1,xamarinios-10.8,xamarinmac-3.0</xliffext:moniker_ids>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Concurrent.BlockingCollection`1">
          <source>The type of elements in the collection.</source>
          <target state="translated">O tipo dos elementos na coleção.</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve" uid="T:System.Collections.Concurrent.BlockingCollection`1">
          <source>Provides blocking and bounding capabilities for thread-safe collections that implement <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.IProducerConsumerCollection`1" /&gt;</ph>.</source>
          <target state="translated">Fornece funcionalidades de bloqueio e delimitação para coleções thread-safe que implementam <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.IProducerConsumerCollection`1" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Concurrent.BlockingCollection`1">
          <source><ph id="ph1">&lt;xref:System.Collections.Concurrent.BlockingCollection%601&gt;</ph> is a thread-safe collection class that provides the following:</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Collections.Concurrent.BlockingCollection%601&gt;</ph> é uma classe de coleção thread-safe que fornece o seguinte:</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Concurrent.BlockingCollection`1">
          <source>An implementation of the producer/consumer pattern; <ph id="ph1">&lt;xref:System.Collections.Concurrent.BlockingCollection%601&gt;</ph> is a wrapper for the <ph id="ph2">&lt;xref:System.Collections.Concurrent.IProducerConsumerCollection%601&gt;</ph> interface.</source>
          <target state="translated">Uma implementação do padrão de produtor/consumidor; <ph id="ph1">&lt;xref:System.Collections.Concurrent.BlockingCollection%601&gt;</ph> é um wrapper para o <ph id="ph2">&lt;xref:System.Collections.Concurrent.IProducerConsumerCollection%601&gt;</ph> interface.</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Concurrent.BlockingCollection`1">
          <source>Concurrent addition and removal of items from multiple threads with the <ph id="ph1">&lt;xref:System.Collections.Concurrent.BlockingCollection%601.Add%2A&gt;</ph> and  <ph id="ph2">&lt;xref:System.Collections.Concurrent.BlockingCollection%601.Take%2A&gt;</ph> methods.</source>
          <target state="translated">Simultânea adição e remoção de itens de vários threads com a <ph id="ph1">&lt;xref:System.Collections.Concurrent.BlockingCollection%601.Add%2A&gt;</ph> e <ph id="ph2">&lt;xref:System.Collections.Concurrent.BlockingCollection%601.Take%2A&gt;</ph> métodos.</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Concurrent.BlockingCollection`1">
          <source>A bounded collection that blocks <ph id="ph1">&lt;xref:System.Collections.Concurrent.BlockingCollection%601.Add%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Collections.Concurrent.BlockingCollection%601.Take%2A&gt;</ph> operations when the collection is full or empty.</source>
          <target state="translated">Uma coleção associada que bloqueia <ph id="ph1">&lt;xref:System.Collections.Concurrent.BlockingCollection%601.Add%2A&gt;</ph> e <ph id="ph2">&lt;xref:System.Collections.Concurrent.BlockingCollection%601.Take%2A&gt;</ph> operações quando a coleção é full ou empty.</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Concurrent.BlockingCollection`1">
          <source>Cancellation of <ph id="ph1">&lt;xref:System.Collections.Concurrent.BlockingCollection%601.Add%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.Collections.Concurrent.BlockingCollection%601.Take%2A&gt;</ph> operations by using a <ph id="ph3">&lt;xref:System.Threading.CancellationToken&gt;</ph> object in the  <ph id="ph4">&lt;xref:System.Collections.Concurrent.BlockingCollection%601.TryAdd%2A&gt;</ph> or <ph id="ph5">&lt;xref:System.Collections.Concurrent.BlockingCollection%601.TryTake%2A&gt;</ph> method.</source>
          <target state="translated">O cancelamento da <ph id="ph1">&lt;xref:System.Collections.Concurrent.BlockingCollection%601.Add%2A&gt;</ph> ou <ph id="ph2">&lt;xref:System.Collections.Concurrent.BlockingCollection%601.Take%2A&gt;</ph> operações usando uma <ph id="ph3">&lt;xref:System.Threading.CancellationToken&gt;</ph> objeto o <ph id="ph4">&lt;xref:System.Collections.Concurrent.BlockingCollection%601.TryAdd%2A&gt;</ph> ou <ph id="ph5">&lt;xref:System.Collections.Concurrent.BlockingCollection%601.TryTake%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Concurrent.BlockingCollection`1">
          <source>This type implements the <ph id="ph1">&lt;xref:System.IDisposable&gt;</ph> interface.</source>
          <target state="translated">Este tipo implementa o <ph id="ph1">&lt;xref:System.IDisposable&gt;</ph> interface.</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Concurrent.BlockingCollection`1">
          <source>When you have finished using the type, you should dispose of it either directly or indirectly.</source>
          <target state="translated">Quando você terminar de usar o tipo, descarte-direta ou indiretamente.</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Concurrent.BlockingCollection`1">
          <source>To dispose of the type directly, call its <ph id="ph1">&lt;xref:System.IDisposable.Dispose%2A&gt;</ph> method in a <ph id="ph2">`try`</ph><ph id="ph3">/</ph><ph id="ph4">`catch`</ph> block.</source>
          <target state="translated">Para descartar o tipo diretamente, chame seu <ph id="ph1">&lt;xref:System.IDisposable.Dispose%2A&gt;</ph> método em um <ph id="ph2">`try`</ph> <ph id="ph3">/</ph> <ph id="ph4">`catch`</ph> bloco.</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Concurrent.BlockingCollection`1">
          <source>To dispose of it indirectly, use a language construct such as <ph id="ph1">`using`</ph> (in C#) or <ph id="ph2">`Using`</ph> (in Visual Basic).</source>
          <target state="translated">Para descartar indiretamente dele, use uma construção de linguagem, como <ph id="ph1">`using`</ph> (em c#) ou <ph id="ph2">`Using`</ph> (no Visual Basic).</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Concurrent.BlockingCollection`1">
          <source>For more information, see the "Using an Object that Implements IDisposable" section in the <ph id="ph1">&lt;xref:System.IDisposable&gt;</ph> interface topic.</source>
          <target state="translated">Para obter mais informações, consulte a seção "Usando um objeto que implementa IDisposable" o <ph id="ph1">&lt;xref:System.IDisposable&gt;</ph> tópico de interface.</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Concurrent.BlockingCollection`1">
          <source>Also, note that the <ph id="ph1">&lt;xref:System.Collections.Concurrent.BlockingCollection%601.Dispose&gt;</ph> method is not thread-safe.</source>
          <target state="translated">Além disso, observe que o <ph id="ph1">&lt;xref:System.Collections.Concurrent.BlockingCollection%601.Dispose&gt;</ph> método não é thread-safe.</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Concurrent.BlockingCollection`1">
          <source>All other public and protected members of <ph id="ph1">&lt;xref:System.Collections.Concurrent.BlockingCollection%601&gt;</ph> are thread-safe and may be used concurrently from multiple threads.</source>
          <target state="translated">Todos os outros membros protegidos e públicos da <ph id="ph1">&lt;xref:System.Collections.Concurrent.BlockingCollection%601&gt;</ph> são thread-safe e podem ser usados simultaneamente em vários threads.</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Concurrent.BlockingCollection`1">
          <source><ph id="ph1">&lt;xref:System.Collections.Concurrent.IProducerConsumerCollection%601&gt;</ph> represents a collection that allows for thread-safe adding and removal of data.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Collections.Concurrent.IProducerConsumerCollection%601&gt;</ph> representa uma coleção que permite thread-safe adição e remoção de dados.</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Concurrent.BlockingCollection`1">
          <source><ph id="ph1">&lt;xref:System.Collections.Concurrent.BlockingCollection%601&gt;</ph> is used as a wrapper for an <ph id="ph2">&lt;xref:System.Collections.Concurrent.IProducerConsumerCollection%601&gt;</ph> instance, and allows removal attempts from the collection to block until data is available to be removed.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Collections.Concurrent.BlockingCollection%601&gt;</ph> é usado como um wrapper para um <ph id="ph2">&lt;xref:System.Collections.Concurrent.IProducerConsumerCollection%601&gt;</ph> de instância e permite que as tentativas de remoção da coleção bloquear até que os dados estão disponíveis a ser removido.</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Concurrent.BlockingCollection`1">
          <source>Similarly, you can create a <ph id="ph1">&lt;xref:System.Collections.Concurrent.BlockingCollection%601&gt;</ph> to enforce an upper bound on the number of data elements allowed in the <ph id="ph2">&lt;xref:System.Collections.Concurrent.IProducerConsumerCollection%601&gt;</ph>; addition attempts to the collection may then block until space is available to store the added items.</source>
          <target state="translated">Da mesma forma, você pode criar um <ph id="ph1">&lt;xref:System.Collections.Concurrent.BlockingCollection%601&gt;</ph> para impor um limite superior no número de elementos de dados permitidos no <ph id="ph2">&lt;xref:System.Collections.Concurrent.IProducerConsumerCollection%601&gt;</ph>; tentativas de adição à coleção, em seguida, podem ser bloqueadas até que haja espaço disponível para armazenar os itens adicionados.</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Concurrent.BlockingCollection`1">
          <source>In this manner, <ph id="ph1">&lt;xref:System.Collections.Concurrent.BlockingCollection%601&gt;</ph> is similar to a traditional blocking queue data structure, except that the underlying data storage mechanism is abstracted away as an <ph id="ph2">&lt;xref:System.Collections.Concurrent.IProducerConsumerCollection%601&gt;</ph>.</source>
          <target state="translated">Dessa maneira, <ph id="ph1">&lt;xref:System.Collections.Concurrent.BlockingCollection%601&gt;</ph> é semelhante a uma estrutura de dados fila bloqueio tradicional, exceto que o mecanismo de armazenamento de dados subjacente é abstraído como um <ph id="ph2">&lt;xref:System.Collections.Concurrent.IProducerConsumerCollection%601&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Concurrent.BlockingCollection`1">
          <source><ph id="ph1">&lt;xref:System.Collections.Concurrent.BlockingCollection%601&gt;</ph> supports bounding and blocking.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Collections.Concurrent.BlockingCollection%601&gt;</ph> dá suporte à delimitação e ao bloqueio.</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Concurrent.BlockingCollection`1">
          <source>Bounding means that you can set the maximum capacity of the collection.</source>
          <target state="translated">Limite significa que você pode definir a capacidade máxima da coleção.</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Concurrent.BlockingCollection`1">
          <source>Bounding is important in certain scenarios because it enables you to control the maximum size of the collection in memory, and it prevents the producing threads from moving too far ahead of the consuming threads.Multiple threads or tasks can add items to the collection concurrently, and if the collection reaches its specified maximum capacity, the producing threads will block until an item is removed.</source>
          <target state="translated">Delimitador é importante em determinados cenários, porque ele permite que você controle o tamanho máximo da coleção na memória e impede que os threads de produção movendo muito antes que os threads de consumo. Vários threads ou tarefas podem adicionar itens à coleção simultaneamente, e se a coleção atingir sua capacidade máxima especificada, os threads de produção serão bloqueado até que um item é removido.</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Concurrent.BlockingCollection`1">
          <source>Multiple consumers can remove items concurrently, and if the collection becomes empty, the consuming threads will block until a producer adds an item.</source>
          <target state="translated">Vários consumidores podem remover itens simultaneamente e, se a coleção ficar vazia, os threads de consumo serão bloqueados até que um produtor adicione um item.</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Concurrent.BlockingCollection`1">
          <source>A producing thread can call the <ph id="ph1">&lt;xref:System.Collections.Concurrent.BlockingCollection%601.CompleteAdding%2A&gt;</ph> method to indicate that no more items will be added.</source>
          <target state="translated">Um thread de produção pode chamar o <ph id="ph1">&lt;xref:System.Collections.Concurrent.BlockingCollection%601.CompleteAdding%2A&gt;</ph> método para indicar que não há mais itens serão adicionados.</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Concurrent.BlockingCollection`1">
          <source>Consumers monitor the <ph id="ph1">&lt;xref:System.Collections.Concurrent.BlockingCollection%601.IsCompleted%2A&gt;</ph> property to know when the collection is empty and no more items will be added.</source>
          <target state="translated">Os consumidores monitoram a propriedade <ph id="ph1">&lt;xref:System.Collections.Concurrent.BlockingCollection%601.IsCompleted%2A&gt;</ph> para saber quando a coleção está vazia e não serão adicionados mais itens.</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Concurrent.BlockingCollection`1">
          <source><ph id="ph1">&lt;xref:System.Collections.Concurrent.BlockingCollection%601.Add%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Collections.Concurrent.BlockingCollection%601.Take%2A&gt;</ph> operations are typically performed in a loop.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Collections.Concurrent.BlockingCollection%601.Add%2A&gt;</ph> e <ph id="ph2">&lt;xref:System.Collections.Concurrent.BlockingCollection%601.Take%2A&gt;</ph> operações normalmente é executada em um loop.</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Concurrent.BlockingCollection`1">
          <source>You can cancel a loop by passing in a <ph id="ph1">&lt;xref:System.Threading.CancellationToken&gt;</ph> object to the <ph id="ph2">&lt;xref:System.Collections.Concurrent.BlockingCollection%601.TryAdd%2A&gt;</ph> or <ph id="ph3">&lt;xref:System.Collections.Concurrent.BlockingCollection%601.TryTake%2A&gt;</ph> method, and then checking the value of the token's <ph id="ph4">&lt;xref:System.Threading.CancellationToken.IsCancellationRequested%2A&gt;</ph> property on each iteration.</source>
          <target state="translated">Você pode cancelar um loop, passando um <ph id="ph1">&lt;xref:System.Threading.CancellationToken&gt;</ph> o objeto para o <ph id="ph2">&lt;xref:System.Collections.Concurrent.BlockingCollection%601.TryAdd%2A&gt;</ph> ou <ph id="ph3">&lt;xref:System.Collections.Concurrent.BlockingCollection%601.TryTake%2A&gt;</ph> método e, em seguida, verificar o valor do token <ph id="ph4">&lt;xref:System.Threading.CancellationToken.IsCancellationRequested%2A&gt;</ph> propriedade em cada iteração.</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Concurrent.BlockingCollection`1">
          <source>If the value is <ph id="ph1">`true`</ph>, it is up to you to respond the cancellation request by cleaning up any resources and exiting the loop.</source>
          <target state="translated">Se o valor for <ph id="ph1">`true`</ph>, cabe a você responder a solicitação de cancelamento, limpar todos os recursos e sair do loop.</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Concurrent.BlockingCollection`1">
          <source>When you create a <ph id="ph1">&lt;xref:System.Collections.Concurrent.BlockingCollection%601&gt;</ph> object, you can specify not only the bounded capacity but also the type of collection to use.</source>
          <target state="translated">Quando você cria um <ph id="ph1">&lt;xref:System.Collections.Concurrent.BlockingCollection%601&gt;</ph> objeto, você pode especificar não apenas a capacidade limitada, mas também o tipo de coleção para usar.</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Concurrent.BlockingCollection`1">
          <source>For example, you could specify a <ph id="ph1">&lt;xref:System.Collections.Concurrent.ConcurrentQueue%601&gt;</ph> object for first in, first out (FIFO) behavior, or a <ph id="ph2">&lt;xref:System.Collections.Concurrent.ConcurrentStack%601&gt;</ph> object for last in, first out (LIFO) behavior.</source>
          <target state="translated">Por exemplo, seria possível especificar um objeto <ph id="ph1">&lt;xref:System.Collections.Concurrent.ConcurrentQueue%601&gt;</ph> para o comportamento primeiro a entrar, primeiro a sair (PEPS) ou um objeto <ph id="ph2">&lt;xref:System.Collections.Concurrent.ConcurrentStack%601&gt;</ph> para último a entrar, primeiro a sair (UEPS).</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Concurrent.BlockingCollection`1">
          <source>You can use any collection class that implements the <ph id="ph1">&lt;xref:System.Collections.Concurrent.IProducerConsumerCollection%601&gt;</ph> interface.</source>
          <target state="translated">Você pode usar qualquer classe de coleção que implemente a interface <ph id="ph1">&lt;xref:System.Collections.Concurrent.IProducerConsumerCollection%601&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Concurrent.BlockingCollection`1">
          <source>The default collection type for <ph id="ph1">&lt;xref:System.Collections.Concurrent.BlockingCollection%601&gt;</ph> is <ph id="ph2">&lt;xref:System.Collections.Concurrent.ConcurrentQueue%601&gt;</ph>.</source>
          <target state="translated">O tipo de coleção padrão para <ph id="ph1">&lt;xref:System.Collections.Concurrent.BlockingCollection%601&gt;</ph> é <ph id="ph2">&lt;xref:System.Collections.Concurrent.ConcurrentQueue%601&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Concurrent.BlockingCollection`1">
          <source>Do not modify the underlying collection directly.</source>
          <target state="translated">Não modifique diretamente a coleção subjacente.</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Concurrent.BlockingCollection`1">
          <source>Use <ph id="ph1">&lt;xref:System.Collections.Concurrent.BlockingCollection%601&gt;</ph> methods to add or remove elements.</source>
          <target state="translated">Use <ph id="ph1">&lt;xref:System.Collections.Concurrent.BlockingCollection%601&gt;</ph> métodos para adicionar ou remover elementos.</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Concurrent.BlockingCollection`1">
          <source>The <ph id="ph1">&lt;xref:System.Collections.Concurrent.BlockingCollection%601&gt;</ph> object can become corrupted if you change the underlying collection directly.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Collections.Concurrent.BlockingCollection%601&gt;</ph> objeto pode ser corrompido se você alterar a coleção subjacente diretamente.</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Concurrent.BlockingCollection`1">
          <source>The following example shows how to add and take items concurrently from a blocking collection:</source>
          <target state="translated">O exemplo a seguir mostra como adicionar e tirar itens simultaneamente de uma coleção de bloqueio:</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Concurrent.BlockingCollection`1">
          <source>The Dispose method is not thread-safe.</source>
          <target state="translated">O método Dispose não é thread-safe.</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Concurrent.BlockingCollection`1">
          <source>All other public and protected members of <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> are thread-safe and may be used concurrently from multiple threads.</source>
          <target state="translated">Todos os outros membros protegidos e públicos da <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> são thread-safe e podem ser usados simultaneamente em vários threads.</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve" uid="T:System.Collections.Concurrent.BlockingCollection`1">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> class without an upper-bound.</source>
          <target state="translated">Inicializa uma nova instância da classe <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> sem um limite superior.</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.#ctor">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> class without an upper-bound.</source>
          <target state="translated">Inicializa uma nova instância da classe <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> sem um limite superior.</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Concurrent.BlockingCollection`1.#ctor">
          <source>The default underlying collection is a <ph id="ph1">&lt;xref:System.Collections.Concurrent.ConcurrentQueue%601&gt;</ph> object, which provides first in, first out (FIFO) behavior.</source>
          <target state="translated">O padrão de coleção de base é um <ph id="ph1">&lt;xref:System.Collections.Concurrent.ConcurrentQueue%601&gt;</ph> object, que fornece primeiro no comportamento primeiro a sair (PEPS).</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.#ctor(System.Collections.Concurrent.IProducerConsumerCollection{`0})">
          <source>The collection to use as the underlying data store.</source>
          <target state="translated">A coleção a ser usada como armazenamento de dados subjacente.</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.#ctor(System.Collections.Concurrent.IProducerConsumerCollection{`0})">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> class without an upper-bound and using the provided <ph id="ph2">&lt;see cref="T:System.Collections.Concurrent.IProducerConsumerCollection`1" /&gt;</ph> as its underlying data store.</source>
          <target state="translated">Inicializa uma nova instância da classe <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> sem um limite superior e usando a <ph id="ph2">&lt;see cref="T:System.Collections.Concurrent.IProducerConsumerCollection`1" /&gt;</ph> fornecida como seu armazenamento de dados subjacente.</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.#ctor(System.Collections.Concurrent.IProducerConsumerCollection{`0})">
          <source>The <ph id="ph1">&lt;paramref name="collection" /&gt;</ph> argument is null.</source>
          <target state="translated">O argumento <ph id="ph1">&lt;paramref name="collection" /&gt;</ph> é nulo.</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.#ctor(System.Int32)">
          <source>The bounded size of the collection.</source>
          <target state="translated">O tamanho limitado da coleção.</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.#ctor(System.Int32)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> class with the specified upper-bound.</source>
          <target state="translated">Inicializa uma nova instância da classe <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> com o limite superior especificado.</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Concurrent.BlockingCollection`1.#ctor(System.Int32)">
          <source>The default underlying collection is a <ph id="ph1">&lt;xref:System.Collections.Concurrent.ConcurrentQueue%601&gt;</ph>.</source>
          <target state="translated">O padrão de coleção de base é um <ph id="ph1">&lt;xref:System.Collections.Concurrent.ConcurrentQueue%601&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.#ctor(System.Int32)">
          <source>The <ph id="ph1">&lt;paramref name="boundedCapacity" /&gt;</ph> is not a positive value.</source>
          <target state="translated">O <ph id="ph1">&lt;paramref name="boundedCapacity" /&gt;</ph> não é um valor positivo.</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.#ctor(System.Collections.Concurrent.IProducerConsumerCollection{`0},System.Int32)">
          <source>The collection to use as the underlying data store.</source>
          <target state="translated">A coleção a ser usada como armazenamento de dados subjacente.</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.#ctor(System.Collections.Concurrent.IProducerConsumerCollection{`0},System.Int32)">
          <source>The bounded size of the collection.</source>
          <target state="translated">O tamanho limitado da coleção.</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.#ctor(System.Collections.Concurrent.IProducerConsumerCollection{`0},System.Int32)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> class with the specified upper-bound and using the provided <ph id="ph2">&lt;see cref="T:System.Collections.Concurrent.IProducerConsumerCollection`1" /&gt;</ph> as its underlying data store.</source>
          <target state="translated">Inicializa uma nova instância da classe <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> com o limite superior especificado e usando a <ph id="ph2">&lt;see cref="T:System.Collections.Concurrent.IProducerConsumerCollection`1" /&gt;</ph> fornecida como seu repositório de dados subjacente.</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.#ctor(System.Collections.Concurrent.IProducerConsumerCollection{`0},System.Int32)">
          <source>The <ph id="ph1">&lt;paramref name="collection" /&gt;</ph> argument is null.</source>
          <target state="translated">O argumento <ph id="ph1">&lt;paramref name="collection" /&gt;</ph> é nulo.</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.#ctor(System.Collections.Concurrent.IProducerConsumerCollection{`0},System.Int32)">
          <source>The <ph id="ph1">&lt;paramref name="boundedCapacity" /&gt;</ph> is not a positive value.</source>
          <target state="translated">O <ph id="ph1">&lt;paramref name="boundedCapacity" /&gt;</ph> não é um valor positivo.</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.#ctor(System.Collections.Concurrent.IProducerConsumerCollection{`0},System.Int32)">
          <source>The supplied <ph id="ph1">&lt;paramref name="collection" /&gt;</ph> contains more values than is permitted by <ph id="ph2">&lt;paramref name="boundedCapacity" /&gt;</ph>.</source>
          <target state="translated">A <ph id="ph1">&lt;paramref name="collection" /&gt;</ph> fornecida contém mais valores que o permitido pela <ph id="ph2">&lt;paramref name="boundedCapacity" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve" uid="T:System.Collections.Concurrent.BlockingCollection`1">
          <source>Adds the item to the <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph>.</source>
          <target state="translated">Adiciona o item ao <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.Add(`0)">
          <source>The item to be added to the collection.</source>
          <target state="translated">O item a ser adicionado à coleção.</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.Add(`0)">
          <source>The value can be a null reference.</source>
          <target state="translated">O valor pode ser uma referência nula.</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.Add(`0)">
          <source>Adds the item to the <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph>.</source>
          <target state="translated">Adiciona o item ao <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Concurrent.BlockingCollection`1.Add(`0)">
          <source>If a bounded capacity was specified when this instance of <ph id="ph1">&lt;xref:System.Collections.Concurrent.BlockingCollection%601&gt;</ph> was initialized, a call to Add may block until space is available to store the provided item.</source>
          <target state="translated">Se uma capacidade limitada foi especificada quando esta instância do <ph id="ph1">&lt;xref:System.Collections.Concurrent.BlockingCollection%601&gt;</ph> foi inicializado, uma chamada para adicionar pode ser bloqueadas até que haja espaço disponível para armazenar o item fornecido.</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.Add(`0)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> has been disposed.</source>
          <target state="translated">O <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> foi descartado.</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.Add(`0)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> has been marked as complete with regards to additions.</source>
          <target state="translated">O <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> foi marcado como concluído com relação a adições.</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.Add(`0)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.Add(`0)">
          <source>The underlying collection didn't accept the item.</source>
          <target state="translated">A coleção subjacente não aceitou o item.</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.Add(`0,System.Threading.CancellationToken)">
          <source>The item to be added to the collection.</source>
          <target state="translated">O item a ser adicionado à coleção.</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.Add(`0,System.Threading.CancellationToken)">
          <source>The value can be a null reference.</source>
          <target state="translated">O valor pode ser uma referência nula.</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.Add(`0,System.Threading.CancellationToken)">
          <source>A cancellation token to observe.</source>
          <target state="translated">Um token de cancelamento a ser observado.</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.Add(`0,System.Threading.CancellationToken)">
          <source>Adds the item to the <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph>.</source>
          <target state="translated">Adiciona o item ao <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Concurrent.BlockingCollection`1.Add(`0,System.Threading.CancellationToken)">
          <source>If a bounded capacity was specified when this instance of <ph id="ph1">&lt;xref:System.Collections.Concurrent.BlockingCollection%601&gt;</ph> was initialized, a call to <ph id="ph2">&lt;xref:System.Collections.Concurrent.BlockingCollection%601.Add%2A&gt;</ph> may block until space is available to store the provided item.</source>
          <target state="translated">Se uma capacidade limitada foi especificada quando esta instância do <ph id="ph1">&lt;xref:System.Collections.Concurrent.BlockingCollection%601&gt;</ph> foi inicializado, uma chamada para <ph id="ph2">&lt;xref:System.Collections.Concurrent.BlockingCollection%601.Add%2A&gt;</ph> podem ser bloqueadas até que haja espaço disponível para armazenar o item fornecido.</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Concurrent.BlockingCollection`1.Add(`0,System.Threading.CancellationToken)">
          <source>This method can return early with an <ph id="ph1">&lt;xref:System.OperationCanceledException&gt;</ph> if the <ph id="ph2">`cancellationToken`</ph> is canceled.</source>
          <target state="translated">Esse método pode retornar antecipadamente com um <ph id="ph1">&lt;xref:System.OperationCanceledException&gt;</ph> se o <ph id="ph2">`cancellationToken`</ph> será cancelada.</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.Add(`0,System.Threading.CancellationToken)">
          <source>If the <ph id="ph1">&lt;see cref="T:System.Threading.CancellationToken" /&gt;</ph> is canceled.</source>
          <target state="translated">Se o padrão <ph id="ph1">&lt;see cref="T:System.Threading.CancellationToken" /&gt;</ph> for cancelado.</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.Add(`0,System.Threading.CancellationToken)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> has been disposed or the <ph id="ph2">&lt;see cref="T:System.Threading.CancellationTokenSource" /&gt;</ph> that owns <ph id="ph3">&lt;paramref name="cancellationToken" /&gt;</ph> has been disposed.</source>
          <target state="translated">O <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> foi descartado ou o <ph id="ph2">&lt;see cref="T:System.Threading.CancellationTokenSource" /&gt;</ph> que possui o <ph id="ph3">&lt;paramref name="cancellationToken" /&gt;</ph> foi descartado.</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.Add(`0,System.Threading.CancellationToken)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> has been marked as complete with regards to additions.</source>
          <target state="translated">O <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> foi marcado como concluído com relação a adições.</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.Add(`0,System.Threading.CancellationToken)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.Add(`0,System.Threading.CancellationToken)">
          <source>The underlying collection didn't accept the item.</source>
          <target state="translated">A coleção subjacente não aceitou o item.</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve" uid="T:System.Collections.Concurrent.BlockingCollection`1">
          <source>Adds the specified item to any one of the specified <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> instances.</source>
          <target state="translated">Adiciona o item especificado a qualquer uma das instâncias de <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> especificadas.</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.AddToAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0)">
          <source>The array of collections.</source>
          <target state="translated">A matriz de coleções.</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.AddToAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0)">
          <source>The item to be added to one of the collections.</source>
          <target state="translated">O item a ser adicionado a uma das coleções.</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.AddToAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0)">
          <source>Adds the specified item to any one of the specified <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> instances.</source>
          <target state="translated">Adiciona o item especificado a qualquer uma das instâncias de <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> especificadas.</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.AddToAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0)">
          <source>The index of the collection in the <ph id="ph1">&lt;paramref name="collections" /&gt;</ph> array to which the item was added.</source>
          <target state="translated">O índice da coleção na matriz <ph id="ph1">&lt;paramref name="collections" /&gt;</ph> na qual o item foi adicionado.</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Concurrent.BlockingCollection`1.AddToAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0)">
          <source>If a bounded capacity was specified when all of the <ph id="ph1">&lt;xref:System.Collections.Concurrent.BlockingCollection%601&gt;</ph> instances were initialized, a call to AddToAny may block until space is available in one of the collections to store the provided item.</source>
          <target state="translated">Se uma capacidade limitada foi especificada quando todos os <ph id="ph1">&lt;xref:System.Collections.Concurrent.BlockingCollection%601&gt;</ph> instâncias foram inicializadas, uma chamada para AddToAny pode ser bloqueadas até que haja espaço disponível em uma das coleções para armazenar o item fornecido.</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.AddToAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0)">
          <source>At least one of the <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> instances has been disposed.</source>
          <target state="translated">Pelo menos uma das instâncias de <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> foi descartada.</target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.AddToAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0)">
          <source>The <ph id="ph1">&lt;paramref name="collections" /&gt;</ph> argument is null.</source>
          <target state="translated">O argumento <ph id="ph1">&lt;paramref name="collections" /&gt;</ph> é nulo.</target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.AddToAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0)">
          <source>The count of <ph id="ph1">&lt;paramref name="collections" /&gt;</ph> is greater than the maximum size of 62 for STA and 63 for MTA.</source>
          <target state="translated">A contagem de <ph id="ph1">&lt;paramref name="collections" /&gt;</ph> é maior que o tamanho máximo de 62 para STA e 63 para MTA.</target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.AddToAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0)">
          <source>The <ph id="ph1">&lt;paramref name="collections" /&gt;</ph> argument is a 0-length array or contains a null element, or at least one of collections has been marked as complete for adding.</source>
          <target state="translated">O argumento <ph id="ph1">&lt;paramref name="collections" /&gt;</ph> é uma matriz de tamanho 0 ou contém um elemento nulo, ou pelo menos uma das coleções foi marcada como completa para adição.</target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.AddToAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0)">
          <source>At least one underlying collection didn't accept the item.</source>
          <target state="translated">Pelo menos uma coleção subjacente não aceitou o item.</target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.AddToAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0,System.Threading.CancellationToken)">
          <source>The array of collections.</source>
          <target state="translated">A matriz de coleções.</target>       </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.AddToAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0,System.Threading.CancellationToken)">
          <source>The item to be added to one of the collections.</source>
          <target state="translated">O item a ser adicionado a uma das coleções.</target>       </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.AddToAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0,System.Threading.CancellationToken)">
          <source>A cancellation token to observe.</source>
          <target state="translated">Um token de cancelamento a ser observado.</target>       </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.AddToAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0,System.Threading.CancellationToken)">
          <source>Adds the specified item to any one of the specified <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> instances.</source>
          <target state="translated">Adiciona o item especificado a qualquer uma das instâncias de <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> especificadas.</target>       </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.AddToAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0,System.Threading.CancellationToken)">
          <source>The index of the collection in the <ph id="ph1">&lt;paramref name="collections" /&gt;</ph> array to which the item was added.</source>
          <target state="translated">O índice da coleção na matriz <ph id="ph1">&lt;paramref name="collections" /&gt;</ph> na qual o item foi adicionado.</target>       </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Concurrent.BlockingCollection`1.AddToAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0,System.Threading.CancellationToken)">
          <source>If a bounded capacity was specified when all of the <ph id="ph1">&lt;xref:System.Collections.Concurrent.BlockingCollection%601&gt;</ph> instances were initialized, a call to AddToAny may block until space is available in one of the collections to store the provided item.</source>
          <target state="translated">Se uma capacidade limitada foi especificada quando todos os <ph id="ph1">&lt;xref:System.Collections.Concurrent.BlockingCollection%601&gt;</ph> instâncias foram inicializadas, uma chamada para AddToAny pode ser bloqueadas até que haja espaço disponível em uma das coleções para armazenar o item fornecido.</target>       </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Concurrent.BlockingCollection`1.AddToAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0,System.Threading.CancellationToken)">
          <source>This method may return before the item is added to any collection if the <ph id="ph1">`cancellationToken`</ph> is canceled before space is available.</source>
          <target state="translated">Esse método pode ser retornado antes que o item é adicionado a qualquer coleção se o <ph id="ph1">`cancellationToken`</ph> é cancelado antes de espaço está disponível.</target>       </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.AddToAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0,System.Threading.CancellationToken)">
          <source>If the <ph id="ph1">&lt;see cref="T:System.Threading.CancellationToken" /&gt;</ph> is canceled.</source>
          <target state="translated">Se o padrão <ph id="ph1">&lt;see cref="T:System.Threading.CancellationToken" /&gt;</ph> for cancelado.</target>       </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.AddToAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0,System.Threading.CancellationToken)">
          <source>At least one underlying collection didn't accept the item.</source>
          <target state="translated">Pelo menos uma coleção subjacente não aceitou o item.</target>       </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.AddToAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0,System.Threading.CancellationToken)">
          <source>The <ph id="ph1">&lt;paramref name="collections" /&gt;</ph> argument is null.</source>
          <target state="translated">O argumento <ph id="ph1">&lt;paramref name="collections" /&gt;</ph> é nulo.</target>       </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.AddToAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0,System.Threading.CancellationToken)">
          <source>The count of <ph id="ph1">&lt;paramref name="collections" /&gt;</ph> is greater than the maximum size of 62 for STA and 63 for MTA.</source>
          <target state="translated">A contagem de <ph id="ph1">&lt;paramref name="collections" /&gt;</ph> é maior que o tamanho máximo de 62 para STA e 63 para MTA.</target>       </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.AddToAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0,System.Threading.CancellationToken)">
          <source>The <ph id="ph1">&lt;paramref name="collections" /&gt;</ph> argument is a 0-length array or contains a null element, or at least one of collections has been marked as complete for adding.</source>
          <target state="translated">O argumento <ph id="ph1">&lt;paramref name="collections" /&gt;</ph> é uma matriz de tamanho 0 ou contém um elemento nulo, ou pelo menos uma das coleções foi marcada como completa para adição.</target>       </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.AddToAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0,System.Threading.CancellationToken)">
          <source>At least one of the <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> instances has been disposed, or the <ph id="ph2">&lt;see cref="T:System.Threading.CancellationTokenSource" /&gt;</ph> that created <ph id="ph3">&lt;paramref name="cancellationToken" /&gt;</ph> has been disposed.</source>
          <target state="translated">Pelo menos uma das instâncias de <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> foi descartada ou o <ph id="ph2">&lt;see cref="T:System.Threading.CancellationTokenSource" /&gt;</ph> que criou <ph id="ph3">&lt;paramref name="cancellationToken" /&gt;</ph> foi descartado.</target>       </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve" uid="P:System.Collections.Concurrent.BlockingCollection`1.BoundedCapacity">
          <source>Gets the bounded capacity of this <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> instance.</source>
          <target state="translated">Obtém a capacidade limitada dessa instância <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.Concurrent.BlockingCollection`1.BoundedCapacity">
          <source>The bounded capacity of this collection, or int.MaxValue if no bound was supplied.</source>
          <target state="translated">A capacidade limitada dessa coleção ou int.MaxValue, se nenhum limite tiver sido fornecido.</target>       </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve" uid="P:System.Collections.Concurrent.BlockingCollection`1.BoundedCapacity">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> has been disposed.</source>
          <target state="translated">O <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> foi descartado.</target>       </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.CompleteAdding">
          <source>Marks the <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> instances as not accepting any more additions.</source>
          <target state="translated">Marca que as instâncias de <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> não estão mais aceitando nenhuma adição.</target>       </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Concurrent.BlockingCollection`1.CompleteAdding">
          <source>After a collection has been marked as complete for adding, adding to the collection is not permitted and attempts to remove from the collection will not wait when the collection is empty.</source>
          <target state="translated">Depois que uma coleção foi marcada como concluída para a adição, não é permitido adicionar à coleção e tenta remover da coleção não aguardará quando a coleção está vazia.</target>       </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.CompleteAdding">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> has been disposed.</source>
          <target state="translated">O <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> foi descartado.</target>       </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.CopyTo(`0[],System.Int32)">
          <source>The one-dimensional array that is the destination of the elements copied from the <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> instance.</source>
          <target state="translated">A matriz unidimensional que é o destino dos elementos copiados da instância <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.CopyTo(`0[],System.Int32)">
          <source>The array must have zero-based indexing.</source>
          <target state="translated">A matriz deve ter indexação com base em zero.</target>       </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.CopyTo(`0[],System.Int32)">
          <source>The zero-based index in <bpt id="p1">&lt;c&gt;</bpt>array<ept id="p1">&lt;/c&gt;</ept> at which copying begins.</source>
          <target state="translated">O índice baseado em zero na <bpt id="p1">&lt;c&gt;</bpt>array<ept id="p1">&lt;/c&gt;</ept> na qual a cópia começa.</target>       </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.CopyTo(`0[],System.Int32)">
          <source>Copies all of the items in the <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> instance to a compatible one-dimensional array, starting at the specified index of the target array.</source>
          <target state="translated">Copia todos os itens da instância <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> para uma matriz unidimensional compatível, iniciando no índice especificado da matriz de destino.</target>       </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Concurrent.BlockingCollection`1.CopyTo(`0[],System.Int32)">
          <source>CopyTo represents a snapshot of the collection at a precise point in time.</source>
          <target state="translated">CopyTo representa um instantâneo da coleção em um ponto preciso no tempo.</target>       </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Concurrent.BlockingCollection`1.CopyTo(`0[],System.Int32)">
          <source>If other threads are adding or removing items while CopyTo is executing, then the elements returned by CopyTo might not represent the state of the collection.</source>
          <target state="translated">Se outros threads estiver adicionando ou removendo itens durante a execução de CopyTo, os elementos retornados por CopyTo não podem representar o estado da coleção.</target>       </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.CopyTo(`0[],System.Int32)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> has been disposed.</source>
          <target state="translated">O <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> foi descartado.</target>       </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.CopyTo(`0[],System.Int32)">
          <source>The <ph id="ph1">&lt;paramref name="array" /&gt;</ph> argument is null.</source>
          <target state="translated">O argumento <ph id="ph1">&lt;paramref name="array" /&gt;</ph> é nulo.</target>       </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.CopyTo(`0[],System.Int32)">
          <source>The <ph id="ph1">&lt;paramref name="index" /&gt;</ph> argument is less than zero.</source>
          <target state="translated">O argumento <ph id="ph1">&lt;paramref name="index" /&gt;</ph> é menor que zero.</target>       </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.CopyTo(`0[],System.Int32)">
          <source>The <ph id="ph1">&lt;paramref name="index" /&gt;</ph> argument is equal to or greater than the length of the <ph id="ph2">&lt;paramref name="array" /&gt;</ph>.</source>
          <target state="translated">O argumento <ph id="ph1">&lt;paramref name="index" /&gt;</ph> é igual ou maior que o comprimento da <ph id="ph2">&lt;paramref name="array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.CopyTo(`0[],System.Int32)">
          <source>The destination array is too small to hold all of the BlockingCcollection elements.</source>
          <target state="translated">A matriz de destino é muito pequena para conter todos os elementos de BlockingCcollection.</target>       </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.CopyTo(`0[],System.Int32)">
          <source>The array rank doesn't match.</source>
          <target state="translated">A classificação da matriz não corresponde.</target>       </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.CopyTo(`0[],System.Int32)">
          <source>The array type is incompatible with the type of the BlockingCollection elements.</source>
          <target state="translated">O tipo de matriz é incompatível com o tipo dos elementos de BlockingCollection.</target>       </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve" uid="P:System.Collections.Concurrent.BlockingCollection`1.Count">
          <source>Gets the number of items contained in the <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph>.</source>
          <target state="translated">Obtém o número de itens contidos no <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.Concurrent.BlockingCollection`1.Count">
          <source>The number of items contained in the <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph>.</source>
          <target state="translated">O número de itens contidos no <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.Concurrent.BlockingCollection`1.Count">
          <source>If any method in BlockingCollection is executing while the Count property is being accessd, the return value is approximate.</source>
          <target state="translated">Se qualquer método de BlockingCollection está em execução enquanto a propriedade Count está sendo accessd, o valor de retorno é aproximado.</target>       </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.Concurrent.BlockingCollection`1.Count">
          <source>Count may reflect a number that is either greater than or less than the actual number of items in the BlockingCollection.</source>
          <target state="translated">Contagem pode refletir um número que seja maior ou menor que o número real de itens de BlockingCollection.</target>       </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve" uid="P:System.Collections.Concurrent.BlockingCollection`1.Count">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> has been disposed.</source>
          <target state="translated">O <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> foi descartado.</target>       </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve" uid="T:System.Collections.Concurrent.BlockingCollection`1">
          <source>Releases all resources used by the current instance of the <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> class.</source>
          <target state="translated">Libera todos os recursos usados pela instância atual da classe <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.Dispose">
          <source>Releases all resources used by the current instance of the <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> class.</source>
          <target state="translated">Libera todos os recursos usados pela instância atual da classe <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Concurrent.BlockingCollection`1.Dispose">
          <source>The <ph id="ph1">`Dispose`</ph> method is not thread-safe.</source>
          <target state="translated">O <ph id="ph1">`Dispose`</ph> método não é thread-safe.</target>       </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Concurrent.BlockingCollection`1.Dispose">
          <source>Call <ph id="ph1">`Dispose`</ph> when you are finished using the <ph id="ph2">&lt;xref:System.Collections.Concurrent.BlockingCollection%601&gt;</ph>.</source>
          <target state="translated">Chamar <ph id="ph1">`Dispose`</ph> quando tiver terminado de usar o <ph id="ph2">&lt;xref:System.Collections.Concurrent.BlockingCollection%601&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Concurrent.BlockingCollection`1.Dispose">
          <source>The <ph id="ph1">`Dispose`</ph> method leaves the <ph id="ph2">&lt;xref:System.Collections.Concurrent.BlockingCollection%601&gt;</ph> in an unusable state.</source>
          <target state="translated">O <ph id="ph1">`Dispose`</ph> método deixa o <ph id="ph2">&lt;xref:System.Collections.Concurrent.BlockingCollection%601&gt;</ph> em um estado inutilizável.</target>       </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Concurrent.BlockingCollection`1.Dispose">
          <source>After calling <ph id="ph1">`Dispose`</ph>, you must release all references to the <ph id="ph2">&lt;xref:System.Collections.Concurrent.BlockingCollection%601&gt;</ph> so the garbage collector can reclaim the memory that the <ph id="ph3">&lt;xref:System.Collections.Concurrent.BlockingCollection%601&gt;</ph> was occupying.</source>
          <target state="translated">Depois de chamar <ph id="ph1">`Dispose`</ph>, você deve liberar todas as referências para o <ph id="ph2">&lt;xref:System.Collections.Concurrent.BlockingCollection%601&gt;</ph> para o coletor de lixo possa recuperar a memória que o <ph id="ph3">&lt;xref:System.Collections.Concurrent.BlockingCollection%601&gt;</ph> estava ocupando.</target>       </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Concurrent.BlockingCollection`1.Dispose">
          <source>For more information, see <bpt id="p1">[</bpt>Cleaning Up Unmanaged Resources<ept id="p1">](~/docs/standard/garbage-collection/unmanaged.md)</ept> and <bpt id="p2">[</bpt>Implementing a Dispose Method<ept id="p2">](~/docs/standard/garbage-collection/implementing-dispose.md)</ept>.</source>
          <target state="translated">Para obter mais informações, consulte <bpt id="p1">[</bpt>limpeza de recursos não gerenciados<ept id="p1">](~/docs/standard/garbage-collection/unmanaged.md)</ept> e <bpt id="p2">[</bpt>implementar um método Dispose<ept id="p2">](~/docs/standard/garbage-collection/implementing-dispose.md)</ept>.</target>       </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Concurrent.BlockingCollection`1.Dispose">
          <source>Always call <ph id="ph1">`Dispose`</ph> before you release your last reference to the <ph id="ph2">&lt;xref:System.Collections.Concurrent.BlockingCollection%601&gt;</ph>.</source>
          <target state="translated">Sempre chamar <ph id="ph1">`Dispose`</ph> antes de liberar sua última referência para o <ph id="ph2">&lt;xref:System.Collections.Concurrent.BlockingCollection%601&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Concurrent.BlockingCollection`1.Dispose">
          <source>Otherwise, the resources it is using will not be freed until the garbage collector calls the <ph id="ph1">&lt;xref:System.Collections.Concurrent.BlockingCollection%601&gt;</ph> object's <ph id="ph2">`Finalize`</ph> method.</source>
          <target state="translated">Caso contrário, os recursos que está usando não serão liberados até que o coletor de lixo chame o <ph id="ph1">&lt;xref:System.Collections.Concurrent.BlockingCollection%601&gt;</ph> do objeto <ph id="ph2">`Finalize`</ph> método.</target>       </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.Dispose(System.Boolean)">
          <source>Whether being disposed explicitly (true) or due to a finalizer (false).</source>
          <target state="translated">Se está sendo descartado explicitamente (true) ou devido a um finalizador (false).</target>       </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.Dispose(System.Boolean)">
          <source>Releases resources used by the <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> instance.</source>
          <target state="translated">Libera os recursos usados pela instância <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve" uid="T:System.Collections.Concurrent.BlockingCollection`1">
          <source>Provides a consuming <ph id="ph1">&lt;see cref="T:System.Collections.Generic.IEnumerator`1" /&gt;</ph> for items in the collection.</source>
          <target state="translated">Fornece um consumindo <ph id="ph1">&lt;see cref="T:System.Collections.Generic.IEnumerator`1" /&gt;</ph> para itens na coleção.</target>       </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.GetConsumingEnumerable">
          <source>Provides a consuming <ph id="ph1">&lt;see cref="T:System.Collections.Generic.IEnumerator`1" /&gt;</ph> for items in the collection.</source>
          <target state="translated">Fornece um consumindo <ph id="ph1">&lt;see cref="T:System.Collections.Generic.IEnumerator`1" /&gt;</ph> para itens na coleção.</target>       </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.GetConsumingEnumerable">
          <source>An <ph id="ph1">&lt;see cref="T:System.Collections.Generic.IEnumerable`1" /&gt;</ph> that removes and returns items from the collection.</source>
          <target state="translated">Um <ph id="ph1">&lt;see cref="T:System.Collections.Generic.IEnumerable`1" /&gt;</ph> que remove e retorna os itens da coleção.</target>       </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Concurrent.BlockingCollection`1.GetConsumingEnumerable">
          <source>The following example shows how to use the <ph id="ph1">&lt;xref:System.Collections.Concurrent.BlockingCollection%601.GetConsumingEnumerable%2A&gt;</ph> method:</source>
          <target state="translated">O exemplo a seguir mostra como usar o <ph id="ph1">&lt;xref:System.Collections.Concurrent.BlockingCollection%601.GetConsumingEnumerable%2A&gt;</ph> método:</target>       </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.GetConsumingEnumerable">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> has been disposed.</source>
          <target state="translated">O <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> foi descartado.</target>       </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.GetConsumingEnumerable(System.Threading.CancellationToken)">
          <source>A cancellation token to observe.</source>
          <target state="translated">Um token de cancelamento a ser observado.</target>       </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.GetConsumingEnumerable(System.Threading.CancellationToken)">
          <source>Provides a consuming <ph id="ph1">&lt;see cref="T:System.Collections.Generic.IEnumerable`1" /&gt;</ph> for items in the collection.</source>
          <target state="translated">Fornece um consumindo <ph id="ph1">&lt;see cref="T:System.Collections.Generic.IEnumerable`1" /&gt;</ph> para itens na coleção.</target>       </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.GetConsumingEnumerable(System.Threading.CancellationToken)">
          <source>An <ph id="ph1">&lt;see cref="T:System.Collections.Generic.IEnumerable`1" /&gt;</ph> that removes and returns items from the collection.</source>
          <target state="translated">Um <ph id="ph1">&lt;see cref="T:System.Collections.Generic.IEnumerable`1" /&gt;</ph> que remove e retorna os itens da coleção.</target>       </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Concurrent.BlockingCollection`1.GetConsumingEnumerable(System.Threading.CancellationToken)">
          <source>This method enables client code to remove items from the collection by using a foreach loop (For Each in Visual Basic), or <ph id="ph1">&lt;xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType&gt;</ph> or a PLINQ query.</source>
          <target state="translated">Esse método permite que o código de cliente remover itens da coleção usando um loop foreach (para cada no Visual Basic), ou <ph id="ph1">&lt;xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType&gt;</ph> ou uma consulta PLINQ.</target>       </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Concurrent.BlockingCollection`1.GetConsumingEnumerable(System.Threading.CancellationToken)">
          <source>The enumerator will continue to provide items (if any exist) until <ph id="ph1">&lt;xref:System.Collections.Concurrent.BlockingCollection%601.IsCompleted%2A&gt;</ph> returns true, and if <ph id="ph2">&lt;xref:System.Collections.Concurrent.BlockingCollection%601.IsCompleted%2A&gt;</ph> is false the loop blocks until an item becomes available or until the <ph id="ph3">&lt;xref:System.Threading.CancellationToken&gt;</ph> is cancelled.</source>
          <target state="translated">O enumerador continuará a fornecer itens (se houver) até <ph id="ph1">&lt;xref:System.Collections.Concurrent.BlockingCollection%601.IsCompleted%2A&gt;</ph> retorna true e se <ph id="ph2">&lt;xref:System.Collections.Concurrent.BlockingCollection%601.IsCompleted%2A&gt;</ph> é false os blocos de loop até que um item se torna disponível ou até que o <ph id="ph3">&lt;xref:System.Threading.CancellationToken&gt;</ph> foi cancelada.</target>       </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.GetConsumingEnumerable(System.Threading.CancellationToken)">
          <source>If the <ph id="ph1">&lt;see cref="T:System.Threading.CancellationToken" /&gt;</ph> is canceled.</source>
          <target state="translated">Se o padrão <ph id="ph1">&lt;see cref="T:System.Threading.CancellationToken" /&gt;</ph> for cancelado.</target>       </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.GetConsumingEnumerable(System.Threading.CancellationToken)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> has been disposed or the <ph id="ph2">&lt;see cref="T:System.Threading.CancellationTokenSource" /&gt;</ph> that created <ph id="ph3">&lt;paramref name="cancellationToken" /&gt;</ph> has been disposed</source>
          <target state="translated">O <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> foi descartado ou o <ph id="ph2">&lt;see cref="T:System.Threading.CancellationTokenSource" /&gt;</ph> que criou o <ph id="ph3">&lt;paramref name="cancellationToken" /&gt;</ph> foi descartado</target>       </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve" uid="P:System.Collections.Concurrent.BlockingCollection`1.IsAddingCompleted">
          <source>Gets whether this <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> has been marked as complete for adding.</source>
          <target state="translated">Obtém se esta <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> foi marcada como completa para adição.</target>       </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.Concurrent.BlockingCollection`1.IsAddingCompleted">
          <source>Whether this collection has been marked as complete for adding.</source>
          <target state="translated">Se esta coleção foi marcada como completa para adição.</target>       </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve" uid="P:System.Collections.Concurrent.BlockingCollection`1.IsAddingCompleted">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> has been disposed.</source>
          <target state="translated">O <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> foi descartado.</target>       </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve" uid="P:System.Collections.Concurrent.BlockingCollection`1.IsCompleted">
          <source>Gets whether this <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> has been marked as complete for adding and is empty.</source>
          <target state="translated">Obtém se esta <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> foi marcada como completa para a adição e está vazia.</target>       </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.Concurrent.BlockingCollection`1.IsCompleted">
          <source>Whether this collection has been marked as complete for adding and is empty.</source>
          <target state="translated">Se esta coleção foi marcada como completa para a adição e está vazia.</target>       </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve" uid="P:System.Collections.Concurrent.BlockingCollection`1.IsCompleted">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> has been disposed.</source>
          <target state="translated">O <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> foi descartado.</target>       </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.System#Collections#Generic#IEnumerable&amp;lt;T&amp;gt;#GetEnumerator">
          <source>Provides an <ph id="ph1">&lt;see cref="T:System.Collections.Generic.IEnumerator`1" /&gt;</ph> for items in the collection.</source>
          <target state="translated">Fornece um <ph id="ph1">&lt;see cref="T:System.Collections.Generic.IEnumerator`1" /&gt;</ph> para itens na coleção.</target>       </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.System#Collections#Generic#IEnumerable&amp;lt;T&amp;gt;#GetEnumerator">
          <source>An <ph id="ph1">&lt;see cref="T:System.Collections.Generic.IEnumerator`1" /&gt;</ph> for the items in the collection.</source>
          <target state="translated">Um <ph id="ph1">&lt;see cref="T:System.Collections.Generic.IEnumerator`1" /&gt;</ph> para os itens na coleção.</target>       </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Concurrent.BlockingCollection`1.System#Collections#Generic#IEnumerable&amp;lt;T&amp;gt;#GetEnumerator">
          <source>Unlike <ph id="ph1">&lt;xref:System.Collections.Concurrent.BlockingCollection%601.GetConsumingEnumerable%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Collections.Concurrent.BlockingCollection%601.System%23Collections%23Generic%23IEnumerable%7BT%7D%23GetEnumerator%2A?displayProperty=nameWithType&gt;</ph> returns a standard enumerator that does not modify the underlying collection.</source>
          <target state="translated">Ao contrário de <ph id="ph1">&lt;xref:System.Collections.Concurrent.BlockingCollection%601.GetConsumingEnumerable%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Collections.Concurrent.BlockingCollection%601.System%23Collections%23Generic%23IEnumerable%7BT%7D%23GetEnumerator%2A?displayProperty=nameWithType&gt;</ph> retorna um enumerador padrão que não modificam a coleção subjacente.</target>       </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Concurrent.BlockingCollection`1.System#Collections#Generic#IEnumerable&amp;lt;T&amp;gt;#GetEnumerator">
          <source>If other threads are adding or removing elements concurrently when GetEnumerator is called, then the elements returned by the enumerator might not represent the current state of the collection.</source>
          <target state="translated">Se outro thread está adicionando ou removendo elementos simultaneamente quando GetEnumerator é chamado, os elementos retornados pelo enumerador podem não representar o estado atual da coleção.</target>       </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.System#Collections#Generic#IEnumerable&amp;lt;T&amp;gt;#GetEnumerator">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> has been disposed.</source>
          <target state="translated">O <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> foi descartado.</target>       </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.System#Collections#ICollection#CopyTo(System.Array,System.Int32)">
          <source>The one-dimensional array that is the destination of the elements copied from the <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> instance.</source>
          <target state="translated">A matriz unidimensional que é o destino dos elementos copiados da instância <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.System#Collections#ICollection#CopyTo(System.Array,System.Int32)">
          <source>The array must have zero-based indexing.</source>
          <target state="translated">A matriz deve ter indexação com base em zero.</target>       </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.System#Collections#ICollection#CopyTo(System.Array,System.Int32)">
          <source>The zero-based index in <bpt id="p1">&lt;c&gt;</bpt>array<ept id="p1">&lt;/c&gt;</ept> at which copying begins.</source>
          <target state="translated">O índice baseado em zero na <bpt id="p1">&lt;c&gt;</bpt>array<ept id="p1">&lt;/c&gt;</ept> na qual a cópia começa.</target>       </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.System#Collections#ICollection#CopyTo(System.Array,System.Int32)">
          <source>Copies all of the items in the <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> instance to a compatible one-dimensional array, starting at the specified index of the target array.</source>
          <target state="translated">Copia todos os itens da instância <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> para uma matriz unidimensional compatível, iniciando no índice especificado da matriz de destino.</target>       </trans-unit>
        <trans-unit id="260" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.System#Collections#ICollection#CopyTo(System.Array,System.Int32)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> has been disposed.</source>
          <target state="translated">O <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> foi descartado.</target>       </trans-unit>
        <trans-unit id="261" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.System#Collections#ICollection#CopyTo(System.Array,System.Int32)">
          <source>The <ph id="ph1">&lt;paramref name="array" /&gt;</ph> argument is null.</source>
          <target state="translated">O argumento <ph id="ph1">&lt;paramref name="array" /&gt;</ph> é nulo.</target>       </trans-unit>
        <trans-unit id="262" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.System#Collections#ICollection#CopyTo(System.Array,System.Int32)">
          <source>The <ph id="ph1">&lt;paramref name="index" /&gt;</ph> argument is less than zero.</source>
          <target state="translated">O argumento <ph id="ph1">&lt;paramref name="index" /&gt;</ph> é menor que zero.</target>       </trans-unit>
        <trans-unit id="263" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.System#Collections#ICollection#CopyTo(System.Array,System.Int32)">
          <source>The <ph id="ph1">&lt;paramref name="index" /&gt;</ph> argument is equal to or greater than the length of the <ph id="ph2">&lt;paramref name="array" /&gt;</ph>, the array is multidimensional, or the type parameter for the collection cannot be cast automatically to the type of the destination array.</source>
          <target state="translated">O argumento <ph id="ph1">&lt;paramref name="index" /&gt;</ph> é igual ou maior que o comprimento da <ph id="ph2">&lt;paramref name="array" /&gt;</ph>, a matriz é multidimensional ou o parâmetro de tipo para a coleção não pode ser convertido automaticamente no tipo da matriz de destino.</target>       </trans-unit>
        <trans-unit id="264" translate="yes" xml:space="preserve" uid="P:System.Collections.Concurrent.BlockingCollection`1.System#Collections#ICollection#IsSynchronized">
          <source>Gets a value indicating whether access to the <ph id="ph1">&lt;see cref="T:System.Collections.ICollection" /&gt;</ph> is synchronized.</source>
          <target state="translated">Obtém um valor que indica se o acesso à <ph id="ph1">&lt;see cref="T:System.Collections.ICollection" /&gt;</ph> é sincronizado.</target>       </trans-unit>
        <trans-unit id="265" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.Concurrent.BlockingCollection`1.System#Collections#ICollection#IsSynchronized">
          <source>always returns false.</source>
          <target state="translated">sempre retorna false.</target>       </trans-unit>
        <trans-unit id="266" translate="yes" xml:space="preserve" uid="P:System.Collections.Concurrent.BlockingCollection`1.System#Collections#ICollection#IsSynchronized">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> has been disposed.</source>
          <target state="translated">O <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> foi descartado.</target>       </trans-unit>
        <trans-unit id="267" translate="yes" xml:space="preserve" uid="P:System.Collections.Concurrent.BlockingCollection`1.System#Collections#ICollection#SyncRoot">
          <source>Gets an object that can be used to synchronize access to the <ph id="ph1">&lt;see cref="T:System.Collections.ICollection" /&gt;</ph>.</source>
          <target state="translated">Obtém um objeto que pode ser usado para sincronizar o acesso ao <ph id="ph1">&lt;see cref="T:System.Collections.ICollection" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="268" translate="yes" xml:space="preserve" uid="P:System.Collections.Concurrent.BlockingCollection`1.System#Collections#ICollection#SyncRoot">
          <source>This property is not supported.</source>
          <target state="translated">Não há suporte a esta propriedade.</target>       </trans-unit>
        <trans-unit id="269" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.Concurrent.BlockingCollection`1.System#Collections#ICollection#SyncRoot">
          <source>returns null.</source>
          <target state="translated">retorna null.</target>       </trans-unit>
        <trans-unit id="270" translate="yes" xml:space="preserve" uid="P:System.Collections.Concurrent.BlockingCollection`1.System#Collections#ICollection#SyncRoot">
          <source>The SyncRoot property is not supported.</source>
          <target state="translated">Não há suporte para a propriedade SyncRoot.</target>       </trans-unit>
        <trans-unit id="271" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.System#Collections#IEnumerable#GetEnumerator">
          <source>Provides an <ph id="ph1">&lt;see cref="T:System.Collections.IEnumerator" /&gt;</ph> for items in the collection.</source>
          <target state="translated">Fornece um <ph id="ph1">&lt;see cref="T:System.Collections.IEnumerator" /&gt;</ph> para itens na coleção.</target>       </trans-unit>
        <trans-unit id="272" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.System#Collections#IEnumerable#GetEnumerator">
          <source>An <ph id="ph1">&lt;see cref="T:System.Collections.IEnumerator" /&gt;</ph> for the items in the collection.</source>
          <target state="translated">Um <ph id="ph1">&lt;see cref="T:System.Collections.IEnumerator" /&gt;</ph> para os itens na coleção.</target>       </trans-unit>
        <trans-unit id="273" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.System#Collections#IEnumerable#GetEnumerator">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> has been disposed.</source>
          <target state="translated">O <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> foi descartado.</target>       </trans-unit>
        <trans-unit id="274" translate="yes" xml:space="preserve" uid="T:System.Collections.Concurrent.BlockingCollection`1">
          <source>Removes an item from the <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph>.</source>
          <target state="translated">Remove um item do <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="275" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.Take">
          <source>Removes  an item from the <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph>.</source>
          <target state="translated">Remove um item do <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="276" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.Take">
          <source>The item removed from the collection.</source>
          <target state="translated">O item removido da coleção.</target>       </trans-unit>
        <trans-unit id="277" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Concurrent.BlockingCollection`1.Take">
          <source>A call to <ph id="ph1">&lt;xref:System.Collections.Concurrent.BlockingCollection%601.Take%2A&gt;</ph> may block until an item is available to be removed.</source>
          <target state="translated">Uma chamada para <ph id="ph1">&lt;xref:System.Collections.Concurrent.BlockingCollection%601.Take%2A&gt;</ph> podem ser bloqueadas até que um item está disponível para ser removido.</target>       </trans-unit>
        <trans-unit id="278" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Concurrent.BlockingCollection`1.Take">
          <source>The order in which an item is removed depends on the type of collection used to create the <ph id="ph1">&lt;xref:System.Collections.Concurrent.BlockingCollection%601&gt;</ph> instance.</source>
          <target state="translated">A ordem na qual um item é removido depende do tipo de coleção usado para criar a instância <ph id="ph1">&lt;xref:System.Collections.Concurrent.BlockingCollection%601&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="279" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Concurrent.BlockingCollection`1.Take">
          <source>When you create a <ph id="ph1">&lt;xref:System.Collections.Concurrent.BlockingCollection%601&gt;</ph> object, you can specify the type of collection to use.</source>
          <target state="translated">Ao criar um objeto <ph id="ph1">&lt;xref:System.Collections.Concurrent.BlockingCollection%601&gt;</ph>, você pode especificar o tipo de coleção a ser usado.</target>       </trans-unit>
        <trans-unit id="280" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Concurrent.BlockingCollection`1.Take">
          <source>For example, you could specify a <ph id="ph1">&lt;xref:System.Collections.Concurrent.ConcurrentQueue%601&gt;</ph> object for first in, first out (FIFO) behavior, or a <ph id="ph2">&lt;xref:System.Collections.Concurrent.ConcurrentStack%601&gt;</ph> object for last in, first out (LIFO) behavior.</source>
          <target state="translated">Por exemplo, seria possível especificar um objeto <ph id="ph1">&lt;xref:System.Collections.Concurrent.ConcurrentQueue%601&gt;</ph> para o comportamento primeiro a entrar, primeiro a sair (PEPS) ou um objeto <ph id="ph2">&lt;xref:System.Collections.Concurrent.ConcurrentStack%601&gt;</ph> para último a entrar, primeiro a sair (UEPS).</target>       </trans-unit>
        <trans-unit id="281" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Concurrent.BlockingCollection`1.Take">
          <source>You can use any collection class that implements the <ph id="ph1">&lt;xref:System.Collections.Concurrent.IProducerConsumerCollection%601&gt;</ph> interface.</source>
          <target state="translated">Você pode usar qualquer classe de coleção que implemente a interface <ph id="ph1">&lt;xref:System.Collections.Concurrent.IProducerConsumerCollection%601&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="282" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Concurrent.BlockingCollection`1.Take">
          <source>The default collection type for <ph id="ph1">&lt;xref:System.Collections.Concurrent.BlockingCollection%601&gt;</ph> is <ph id="ph2">&lt;xref:System.Collections.Concurrent.ConcurrentQueue%601&gt;</ph>.</source>
          <target state="translated">O tipo de coleção padrão para <ph id="ph1">&lt;xref:System.Collections.Concurrent.BlockingCollection%601&gt;</ph> é <ph id="ph2">&lt;xref:System.Collections.Concurrent.ConcurrentQueue%601&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="283" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.Take">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> has been disposed.</source>
          <target state="translated">O <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> foi descartado.</target>       </trans-unit>
        <trans-unit id="284" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.Take">
          <source>The underlying collection was modified outside of this <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> instance, or the <ph id="ph2">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> is empty and the collection has been marked as complete for adding.</source>
          <target state="translated">A coleção subjacente foi modificada fora desta instância de <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> ou o <ph id="ph2">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> está vazio e a coleção foi marcada como concluída para adição.</target>       </trans-unit>
        <trans-unit id="285" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.Take(System.Threading.CancellationToken)">
          <source>Object that can be used to cancel the take operation.</source>
          <target state="translated">Objeto que pode ser usado para cancelar a operação take.</target>       </trans-unit>
        <trans-unit id="286" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.Take(System.Threading.CancellationToken)">
          <source>Removes an item from the <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph>.</source>
          <target state="translated">Remove um item do <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="287" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.Take(System.Threading.CancellationToken)">
          <source>The item removed from the collection.</source>
          <target state="translated">O item removido da coleção.</target>       </trans-unit>
        <trans-unit id="288" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Concurrent.BlockingCollection`1.Take(System.Threading.CancellationToken)">
          <source>A call to <ph id="ph1">&lt;xref:System.Collections.Concurrent.BlockingCollection%601.Take%2A&gt;</ph> may block until an item is available to be removed or the token is canceled.</source>
          <target state="translated">Uma chamada para <ph id="ph1">&lt;xref:System.Collections.Concurrent.BlockingCollection%601.Take%2A&gt;</ph> podem ser bloqueadas até que um item está disponível para ser removido ou o token é cancelado.</target>       </trans-unit>
        <trans-unit id="289" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Concurrent.BlockingCollection`1.Take(System.Threading.CancellationToken)">
          <source>The order in which an item is removed depends on the type of collection used to create the <ph id="ph1">&lt;xref:System.Collections.Concurrent.BlockingCollection%601&gt;</ph> instance.</source>
          <target state="translated">A ordem na qual um item é removido depende do tipo de coleção usado para criar a instância <ph id="ph1">&lt;xref:System.Collections.Concurrent.BlockingCollection%601&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="290" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Concurrent.BlockingCollection`1.Take(System.Threading.CancellationToken)">
          <source>When you create a <ph id="ph1">&lt;xref:System.Collections.Concurrent.BlockingCollection%601&gt;</ph> object, you can specify the type of collection to use.</source>
          <target state="translated">Ao criar um objeto <ph id="ph1">&lt;xref:System.Collections.Concurrent.BlockingCollection%601&gt;</ph>, você pode especificar o tipo de coleção a ser usado.</target>       </trans-unit>
        <trans-unit id="291" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Concurrent.BlockingCollection`1.Take(System.Threading.CancellationToken)">
          <source>For example, you could specify a <ph id="ph1">&lt;xref:System.Collections.Concurrent.ConcurrentQueue%601&gt;</ph> object for first in, first out (FIFO) behavior, or a <ph id="ph2">&lt;xref:System.Collections.Concurrent.ConcurrentStack%601&gt;</ph> object for last in, first out (LIFO) behavior.</source>
          <target state="translated">Por exemplo, seria possível especificar um objeto <ph id="ph1">&lt;xref:System.Collections.Concurrent.ConcurrentQueue%601&gt;</ph> para o comportamento primeiro a entrar, primeiro a sair (PEPS) ou um objeto <ph id="ph2">&lt;xref:System.Collections.Concurrent.ConcurrentStack%601&gt;</ph> para último a entrar, primeiro a sair (UEPS).</target>       </trans-unit>
        <trans-unit id="292" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Concurrent.BlockingCollection`1.Take(System.Threading.CancellationToken)">
          <source>You can use any collection class that implements the <ph id="ph1">&lt;xref:System.Collections.Concurrent.IProducerConsumerCollection%601&gt;</ph> interface.</source>
          <target state="translated">Você pode usar qualquer classe de coleção que implemente a interface <ph id="ph1">&lt;xref:System.Collections.Concurrent.IProducerConsumerCollection%601&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="293" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Concurrent.BlockingCollection`1.Take(System.Threading.CancellationToken)">
          <source>The default collection type for <ph id="ph1">&lt;xref:System.Collections.Concurrent.BlockingCollection%601&gt;</ph> is <ph id="ph2">&lt;xref:System.Collections.Concurrent.ConcurrentQueue%601&gt;</ph>.</source>
          <target state="translated">O tipo de coleção padrão para <ph id="ph1">&lt;xref:System.Collections.Concurrent.BlockingCollection%601&gt;</ph> é <ph id="ph2">&lt;xref:System.Collections.Concurrent.ConcurrentQueue%601&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="294" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.Take(System.Threading.CancellationToken)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Threading.CancellationToken" /&gt;</ph> is canceled.</source>
          <target state="translated">O <ph id="ph1">&lt;see cref="T:System.Threading.CancellationToken" /&gt;</ph> está cancelado.</target>       </trans-unit>
        <trans-unit id="295" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.Take(System.Threading.CancellationToken)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> has been disposed or the <ph id="ph2">&lt;see cref="T:System.Threading.CancellationTokenSource" /&gt;</ph> that created the token was canceled.</source>
          <target state="translated">A <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> foi descartada ou a <ph id="ph2">&lt;see cref="T:System.Threading.CancellationTokenSource" /&gt;</ph> que criou o token foi cancelada.</target>       </trans-unit>
        <trans-unit id="296" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.Take(System.Threading.CancellationToken)">
          <source>The underlying collection was modified outside of this <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> instance or the BlockingCollection is marked as complete for adding, or the <ph id="ph2">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> is empty.</source>
          <target state="translated">A coleção subjacente foi modificada fora desta instância de <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> ou a BlockingCollection está marcada como concluída para adicionar ou a <ph id="ph2">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> está vazia.</target>       </trans-unit>
        <trans-unit id="297" translate="yes" xml:space="preserve" uid="T:System.Collections.Concurrent.BlockingCollection`1">
          <source>Takes an item from any one of the specified <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> instances.</source>
          <target state="translated">Toma um item de qualquer uma das instâncias <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> especificadas.</target>       </trans-unit>
        <trans-unit id="298" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TakeFromAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0@)">
          <source>The array of collections.</source>
          <target state="translated">A matriz de coleções.</target>       </trans-unit>
        <trans-unit id="299" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TakeFromAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0@)">
          <source>The item removed from one of the collections.</source>
          <target state="translated">O item removido de uma das coleções.</target>       </trans-unit>
        <trans-unit id="300" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TakeFromAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0@)">
          <source>Takes an item from any one of the specified <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> instances.</source>
          <target state="translated">Toma um item de qualquer uma das instâncias <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> especificadas.</target>       </trans-unit>
        <trans-unit id="301" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TakeFromAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0@)">
          <source>The index of the collection in the <ph id="ph1">&lt;paramref name="collections" /&gt;</ph> array from which the item was removed.</source>
          <target state="translated">O índice da coleção na matriz <ph id="ph1">&lt;paramref name="collections" /&gt;</ph> da qual o item foi removido.</target>       </trans-unit>
        <trans-unit id="302" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Concurrent.BlockingCollection`1.TakeFromAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0@)">
          <source>A call to TakeFromAny may block until an item is available to be removed.</source>
          <target state="translated">Uma chamada para TakeFromAny pode ser bloqueadas até que um item está disponível para ser removido.</target>       </trans-unit>
        <trans-unit id="303" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TakeFromAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0@)">
          <source>At least one of the <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> instances has been disposed.</source>
          <target state="translated">Pelo menos uma das instâncias de <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> foi descartada.</target>       </trans-unit>
        <trans-unit id="304" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TakeFromAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0@)">
          <source>The <ph id="ph1">&lt;paramref name="collections" /&gt;</ph> argument is null.</source>
          <target state="translated">O argumento <ph id="ph1">&lt;paramref name="collections" /&gt;</ph> é nulo.</target>       </trans-unit>
        <trans-unit id="305" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TakeFromAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0@)">
          <source>The count of <ph id="ph1">&lt;paramref name="collections" /&gt;</ph> is greater than the maximum size of 62 for STA and 63 for MTA.</source>
          <target state="translated">A contagem de <ph id="ph1">&lt;paramref name="collections" /&gt;</ph> é maior que o tamanho máximo de 62 para STA e 63 para MTA.</target>       </trans-unit>
        <trans-unit id="306" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TakeFromAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0@)">
          <source>The <ph id="ph1">&lt;paramref name="collections" /&gt;</ph> argument is a 0-length array or contains a null element or <ph id="ph2">&lt;see cref="M:System.Collections.Concurrent.BlockingCollection`1.CompleteAdding" /&gt;</ph> has been called on the collection.</source>
          <target state="translated">O argumento <ph id="ph1">&lt;paramref name="collections" /&gt;</ph> é uma matriz de tamanho 0 ou contém um elemento nulo ou <ph id="ph2">&lt;see cref="M:System.Collections.Concurrent.BlockingCollection`1.CompleteAdding" /&gt;</ph> foi chamado na coleção.</target>       </trans-unit>
        <trans-unit id="307" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TakeFromAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0@)">
          <source>At least one of the underlying collections was modified outside of its <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> instance.</source>
          <target state="translated">Pelo menos uma das coleções subjacentes foi alterada fora da instância de <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="308" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TakeFromAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0@,System.Threading.CancellationToken)">
          <source>The array of collections.</source>
          <target state="translated">A matriz de coleções.</target>       </trans-unit>
        <trans-unit id="309" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TakeFromAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0@,System.Threading.CancellationToken)">
          <source>The item removed from one of the collections.</source>
          <target state="translated">O item removido de uma das coleções.</target>       </trans-unit>
        <trans-unit id="310" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TakeFromAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0@,System.Threading.CancellationToken)">
          <source>A cancellation token to observe.</source>
          <target state="translated">Um token de cancelamento a ser observado.</target>       </trans-unit>
        <trans-unit id="311" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TakeFromAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0@,System.Threading.CancellationToken)">
          <source>Takes an item from any one of the specified <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> instances while observing the specified cancellation token.</source>
          <target state="translated">Recebe um item de qualquer uma das instâncias <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> especificadas, observando ao mesmo tempo o token de cancelamento especificado.</target>       </trans-unit>
        <trans-unit id="312" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TakeFromAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0@,System.Threading.CancellationToken)">
          <source>The index of the collection in the <ph id="ph1">&lt;paramref name="collections" /&gt;</ph> array from which the item was removed.</source>
          <target state="translated">O índice da coleção na matriz <ph id="ph1">&lt;paramref name="collections" /&gt;</ph> da qual o item foi removido.</target>       </trans-unit>
        <trans-unit id="313" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Concurrent.BlockingCollection`1.TakeFromAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0@,System.Threading.CancellationToken)">
          <source>A call to TakeFromAny may block until an item is available to be removed.</source>
          <target state="translated">Uma chamada para TakeFromAny pode ser bloqueadas até que um item está disponível para ser removido.</target>       </trans-unit>
        <trans-unit id="314" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Concurrent.BlockingCollection`1.TakeFromAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0@,System.Threading.CancellationToken)">
          <source>The method will return early with an OperationCanceledException if the token is canceled.</source>
          <target state="translated">O método retornará antecipadamente com um OperationCanceledException se o token é cancelado.</target>       </trans-unit>
        <trans-unit id="315" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TakeFromAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0@,System.Threading.CancellationToken)">
          <source>If the <ph id="ph1">&lt;see cref="T:System.Threading.CancellationToken" /&gt;</ph> is canceled.</source>
          <target state="translated">Se o padrão <ph id="ph1">&lt;see cref="T:System.Threading.CancellationToken" /&gt;</ph> for cancelado.</target>       </trans-unit>
        <trans-unit id="316" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TakeFromAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0@,System.Threading.CancellationToken)">
          <source>At least one of the underlying collections was modified outside of its <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> instance.</source>
          <target state="translated">Pelo menos uma das coleções subjacentes foi alterada fora da instância de <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="317" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TakeFromAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0@,System.Threading.CancellationToken)">
          <source>The <ph id="ph1">&lt;paramref name="collections" /&gt;</ph> argument is null.</source>
          <target state="translated">O argumento <ph id="ph1">&lt;paramref name="collections" /&gt;</ph> é nulo.</target>       </trans-unit>
        <trans-unit id="318" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TakeFromAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0@,System.Threading.CancellationToken)">
          <source>The count of <ph id="ph1">&lt;paramref name="collections" /&gt;</ph> is greater than the maximum size of 62 for STA and 63 for MTA.</source>
          <target state="translated">A contagem de <ph id="ph1">&lt;paramref name="collections" /&gt;</ph> é maior que o tamanho máximo de 62 para STA e 63 para MTA.</target>       </trans-unit>
        <trans-unit id="319" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TakeFromAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0@,System.Threading.CancellationToken)">
          <source>The <ph id="ph1">&lt;paramref name="collections" /&gt;</ph> argument is a 0-length array or contains a null element, or <ph id="ph2">&lt;see cref="M:System.Collections.Concurrent.BlockingCollection`1.CompleteAdding" /&gt;</ph> has been called on the collection.</source>
          <target state="translated">O argumento <ph id="ph1">&lt;paramref name="collections" /&gt;</ph> é uma matriz de comprimento zero ou contém um elemento nulo, ou <ph id="ph2">&lt;see cref="M:System.Collections.Concurrent.BlockingCollection`1.CompleteAdding" /&gt;</ph> foi chamado na coleção.</target>       </trans-unit>
        <trans-unit id="320" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TakeFromAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0@,System.Threading.CancellationToken)">
          <source>At least one of the <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> instances has been disposed.</source>
          <target state="translated">Pelo menos uma das instâncias de <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> foi descartada.</target>       </trans-unit>
        <trans-unit id="321" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.ToArray">
          <source>Copies the items from the <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> instance into a new array.</source>
          <target state="translated">Copia os itens da instância <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> em uma nova matriz.</target>       </trans-unit>
        <trans-unit id="322" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.ToArray">
          <source>An array containing copies of the elements of the collection.</source>
          <target state="translated">Uma matriz que contém cópias dos elementos da coleção.</target>       </trans-unit>
        <trans-unit id="323" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Concurrent.BlockingCollection`1.ToArray">
          <source>The copied elements are not removed from the collection.</source>
          <target state="translated">Os elementos copiados não são removidos da coleção.</target>       </trans-unit>
        <trans-unit id="324" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Concurrent.BlockingCollection`1.ToArray">
          <source>If any method in BlockingCollection is executing while the ToArray method executes, the return value is approximate.</source>
          <target state="translated">Se qualquer método de BlockingCollection está em execução enquanto o método ToArray é executado, o valor de retorno é aproximado.</target>       </trans-unit>
        <trans-unit id="325" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Concurrent.BlockingCollection`1.ToArray">
          <source>ToArray  may include items that have already been removed, or exclude items that have already been inserted.</source>
          <target state="translated">ToArray pode incluir itens que já tem sido removidos ou excluir itens que já foram inseridos.</target>       </trans-unit>
        <trans-unit id="326" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.ToArray">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> has been disposed.</source>
          <target state="translated">O <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> foi descartado.</target>       </trans-unit>
        <trans-unit id="327" translate="yes" xml:space="preserve" uid="T:System.Collections.Concurrent.BlockingCollection`1">
          <source>Tries to add the specified item to the <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph>.</source>
          <target state="translated">Tenta adicionar o item especificado ao <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="328" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryAdd(`0)">
          <source>The item to be added to the collection.</source>
          <target state="translated">O item a ser adicionado à coleção.</target>       </trans-unit>
        <trans-unit id="329" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryAdd(`0)">
          <source>Tries to add the specified item to the <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph>.</source>
          <target state="translated">Tenta adicionar o item especificado ao <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="330" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryAdd(`0)">
          <source>true if <ph id="ph1">&lt;paramref name="item" /&gt;</ph> could be added; otherwise false.</source>
          <target state="translated">true se <ph id="ph1">&lt;paramref name="item" /&gt;</ph> pôde ser adicionado, caso contrário, false.</target>       </trans-unit>
        <trans-unit id="331" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryAdd(`0)">
          <source>If the item is a duplicate, and the underlying collection does not accept duplicate items, then an <ph id="ph1">&lt;see cref="T:System.InvalidOperationException" /&gt;</ph> is thrown.</source>
          <target state="translated">Se o item for duplicado e a coleção subjacente não aceitar itens duplicados, será gerada uma <ph id="ph1">&lt;see cref="T:System.InvalidOperationException" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="332" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryAdd(`0)">
          <source>If the collection is a bounded collection, and is full, this method immediately returns false without adding the item.</source>
          <target state="translated">Se a coleção é uma coleção associada e completa, esse método retornará imediatamente false sem adicionar o item.</target>       </trans-unit>
        <trans-unit id="333" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryAdd(`0)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> has been disposed.</source>
          <target state="translated">O <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> foi descartado.</target>       </trans-unit>
        <trans-unit id="334" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryAdd(`0)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> has been marked as complete with regards to additions.</source>
          <target state="translated">O <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> foi marcado como concluído com relação a adições.</target>       </trans-unit>
        <trans-unit id="335" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryAdd(`0)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="336" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryAdd(`0)">
          <source>The underlying collection didn't accept the item.</source>
          <target state="translated">A coleção subjacente não aceitou o item.</target>       </trans-unit>
        <trans-unit id="337" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryAdd(`0,System.Int32)">
          <source>The item to be added to the collection.</source>
          <target state="translated">O item a ser adicionado à coleção.</target>       </trans-unit>
        <trans-unit id="338" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryAdd(`0,System.Int32)">
          <source>The number of milliseconds to wait, or <ph id="ph1">&lt;see cref="F:System.Threading.Timeout.Infinite" /&gt;</ph> (-1) to wait indefinitely.</source>
          <target state="translated">O número de milissegundos para aguardar ou <ph id="ph1">&lt;see cref="F:System.Threading.Timeout.Infinite" /&gt;</ph> (- 1) para aguardar indefinidamente.</target>       </trans-unit>
        <trans-unit id="339" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryAdd(`0,System.Int32)">
          <source>Tries to add the specified item to the <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> within the specified time period.</source>
          <target state="translated">Tenta adicionar o item especificado à <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> dentro do período de tempo especificado.</target>       </trans-unit>
        <trans-unit id="340" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryAdd(`0,System.Int32)">
          <source>true if the <ph id="ph1">&lt;paramref name="item" /&gt;</ph> could be added to the collection within the specified time; otherwise, false.</source>
          <target state="translated">true se o <ph id="ph1">&lt;paramref name="item" /&gt;</ph> puder ser adicionado à coleção dentro do tempo especificado, caso contrário, false.</target>       </trans-unit>
        <trans-unit id="341" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryAdd(`0,System.Int32)">
          <source>If the item is a duplicate, and the underlying collection does not accept duplicate items, then an <ph id="ph1">&lt;see cref="T:System.InvalidOperationException" /&gt;</ph> is thrown.</source>
          <target state="translated">Se o item for duplicado e a coleção subjacente não aceitar itens duplicados, será gerada uma <ph id="ph1">&lt;see cref="T:System.InvalidOperationException" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="342" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryAdd(`0,System.Int32)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> has been disposed.</source>
          <target state="translated">O <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> foi descartado.</target>       </trans-unit>
        <trans-unit id="343" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryAdd(`0,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="millisecondsTimeout" /&gt;</ph> is a negative number other than -1, which represents an infinite time-out.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="millisecondsTimeout" /&gt;</ph> é um número negativo diferente de -1, que representa um tempo limite infinito.</target>       </trans-unit>
        <trans-unit id="344" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryAdd(`0,System.Int32)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> has been marked as complete with regards to additions.</source>
          <target state="translated">O <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> foi marcado como concluído com relação a adições.</target>       </trans-unit>
        <trans-unit id="345" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryAdd(`0,System.Int32)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="346" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryAdd(`0,System.Int32)">
          <source>The underlying collection didn't accept the item.</source>
          <target state="translated">A coleção subjacente não aceitou o item.</target>       </trans-unit>
        <trans-unit id="347" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryAdd(`0,System.TimeSpan)">
          <source>The item to be added to the collection.</source>
          <target state="translated">O item a ser adicionado à coleção.</target>       </trans-unit>
        <trans-unit id="348" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryAdd(`0,System.TimeSpan)">
          <source>A <ph id="ph1">&lt;see cref="T:System.TimeSpan" /&gt;</ph> that represents the number of milliseconds to wait, or a <ph id="ph2">&lt;see cref="T:System.TimeSpan" /&gt;</ph> that represents -1 milliseconds to wait indefinitely.</source>
          <target state="translated">Um <ph id="ph1">&lt;see cref="T:System.TimeSpan" /&gt;</ph> que representa o número de milissegundos para aguardar ou um <ph id="ph2">&lt;see cref="T:System.TimeSpan" /&gt;</ph> que representa -1 milissegundos para aguardar indefinidamente.</target>       </trans-unit>
        <trans-unit id="349" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryAdd(`0,System.TimeSpan)">
          <source>Tries to add the specified item to the <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph>.</source>
          <target state="translated">Tenta adicionar o item especificado ao <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="350" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryAdd(`0,System.TimeSpan)">
          <source>true if the <ph id="ph1">&lt;paramref name="item" /&gt;</ph> could be added to the collection within the specified time span; otherwise, false.</source>
          <target state="translated">True se o <ph id="ph1">&lt;paramref name="item" /&gt;</ph> puder ser adicionado à coleção dentro do período de tempo especificado, caso contrário, false.</target>       </trans-unit>
        <trans-unit id="351" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryAdd(`0,System.TimeSpan)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> has been disposed.</source>
          <target state="translated">O <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> foi descartado.</target>       </trans-unit>
        <trans-unit id="352" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryAdd(`0,System.TimeSpan)">
          <source><ph id="ph1">&lt;paramref name="timeout" /&gt;</ph> is a negative number other than -1 milliseconds, which represents an infinite time-out -or- timeout is greater than <ph id="ph2">&lt;see cref="F:System.Int32.MaxValue" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="timeout" /&gt;</ph> é um número negativo diferente de -1 milissegundos, que representa um tempo limite infinito ou o tempo limite é maior que <ph id="ph2">&lt;see cref="F:System.Int32.MaxValue" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="353" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryAdd(`0,System.TimeSpan)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> has been marked as complete with regards to additions.</source>
          <target state="translated">O <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> foi marcado como concluído com relação a adições.</target>       </trans-unit>
        <trans-unit id="354" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryAdd(`0,System.TimeSpan)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="355" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryAdd(`0,System.TimeSpan)">
          <source>The underlying collection didn't accept the item.</source>
          <target state="translated">A coleção subjacente não aceitou o item.</target>       </trans-unit>
        <trans-unit id="356" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryAdd(`0,System.Int32,System.Threading.CancellationToken)">
          <source>The item to be added to the collection.</source>
          <target state="translated">O item a ser adicionado à coleção.</target>       </trans-unit>
        <trans-unit id="357" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryAdd(`0,System.Int32,System.Threading.CancellationToken)">
          <source>The number of milliseconds to wait, or <ph id="ph1">&lt;see cref="F:System.Threading.Timeout.Infinite" /&gt;</ph> (-1) to wait indefinitely.</source>
          <target state="translated">O número de milissegundos para aguardar ou <ph id="ph1">&lt;see cref="F:System.Threading.Timeout.Infinite" /&gt;</ph> (- 1) para aguardar indefinidamente.</target>       </trans-unit>
        <trans-unit id="358" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryAdd(`0,System.Int32,System.Threading.CancellationToken)">
          <source>A cancellation token to observe.</source>
          <target state="translated">Um token de cancelamento a ser observado.</target>       </trans-unit>
        <trans-unit id="359" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryAdd(`0,System.Int32,System.Threading.CancellationToken)">
          <source>Tries to add the specified item to the <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> within the specified time period, while observing a cancellation token.</source>
          <target state="translated">Tenta adicionar o item especificado ao <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> no período especificado, enquanto observa um token de cancelamento.</target>       </trans-unit>
        <trans-unit id="360" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryAdd(`0,System.Int32,System.Threading.CancellationToken)">
          <source>true if the <ph id="ph1">&lt;paramref name="item" /&gt;</ph> could be added to the collection within the specified time; otherwise, false.</source>
          <target state="translated">true se o <ph id="ph1">&lt;paramref name="item" /&gt;</ph> puder ser adicionado à coleção dentro do tempo especificado, caso contrário, false.</target>       </trans-unit>
        <trans-unit id="361" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryAdd(`0,System.Int32,System.Threading.CancellationToken)">
          <source>If the item is a duplicate, and the underlying collection does not accept duplicate items, then an <ph id="ph1">&lt;see cref="T:System.InvalidOperationException" /&gt;</ph> is thrown.</source>
          <target state="translated">Se o item for duplicado e a coleção subjacente não aceitar itens duplicados, será gerada uma <ph id="ph1">&lt;see cref="T:System.InvalidOperationException" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="362" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryAdd(`0,System.Int32,System.Threading.CancellationToken)">
          <source>If the <ph id="ph1">&lt;see cref="T:System.Threading.CancellationToken" /&gt;</ph> is canceled.</source>
          <target state="translated">Se o padrão <ph id="ph1">&lt;see cref="T:System.Threading.CancellationToken" /&gt;</ph> for cancelado.</target>       </trans-unit>
        <trans-unit id="363" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryAdd(`0,System.Int32,System.Threading.CancellationToken)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> has been disposed or the underlying <ph id="ph2">&lt;see cref="T:System.Threading.CancellationTokenSource" /&gt;</ph> has been disposed.</source>
          <target state="translated">O <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> foi descartado ou o <ph id="ph2">&lt;see cref="T:System.Threading.CancellationTokenSource" /&gt;</ph> subjacente foi descartado.</target>       </trans-unit>
        <trans-unit id="364" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryAdd(`0,System.Int32,System.Threading.CancellationToken)">
          <source><ph id="ph1">&lt;paramref name="millisecondsTimeout" /&gt;</ph> is a negative number other than -1, which represents an infinite time-out.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="millisecondsTimeout" /&gt;</ph> é um número negativo diferente de -1, que representa um tempo limite infinito.</target>       </trans-unit>
        <trans-unit id="365" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryAdd(`0,System.Int32,System.Threading.CancellationToken)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> has been marked as complete with regards to additions.</source>
          <target state="translated">O <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> foi marcado como concluído com relação a adições.</target>       </trans-unit>
        <trans-unit id="366" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryAdd(`0,System.Int32,System.Threading.CancellationToken)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="367" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryAdd(`0,System.Int32,System.Threading.CancellationToken)">
          <source>The underlying collection didn't accept the item.</source>
          <target state="translated">A coleção subjacente não aceitou o item.</target>       </trans-unit>
        <trans-unit id="368" translate="yes" xml:space="preserve" uid="T:System.Collections.Concurrent.BlockingCollection`1">
          <source>Tries to add the specified item to any one of the specified <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> instances.</source>
          <target state="translated">Tenta adicionar o item especificado a qualquer uma das instâncias <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> especificadas.</target>       </trans-unit>
        <trans-unit id="369" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryAddToAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0)">
          <source>The array of collections.</source>
          <target state="translated">A matriz de coleções.</target>       </trans-unit>
        <trans-unit id="370" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryAddToAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0)">
          <source>The item to be added to one of the collections.</source>
          <target state="translated">O item a ser adicionado a uma das coleções.</target>       </trans-unit>
        <trans-unit id="371" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryAddToAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0)">
          <source>Tries to add the specified item to any one of the specified <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> instances.</source>
          <target state="translated">Tenta adicionar o item especificado a qualquer uma das instâncias <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> especificadas.</target>       </trans-unit>
        <trans-unit id="372" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryAddToAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0)">
          <source>The index of the collection in the <ph id="ph1">&lt;paramref name="collections" /&gt;</ph> array to which the item was added, or -1 if the item could not be added.</source>
          <target state="translated">O índice da coleção na matriz <ph id="ph1">&lt;paramref name="collections" /&gt;</ph> ao qual o item foi adicionado ou -1 caso o item não possa ser adicionado.</target>       </trans-unit>
        <trans-unit id="373" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryAddToAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0)">
          <source>At least one of the <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> instances has been disposed.</source>
          <target state="translated">Pelo menos uma das instâncias de <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> foi descartada.</target>       </trans-unit>
        <trans-unit id="374" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryAddToAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0)">
          <source>The <ph id="ph1">&lt;paramref name="collections" /&gt;</ph> argument is null.</source>
          <target state="translated">O argumento <ph id="ph1">&lt;paramref name="collections" /&gt;</ph> é nulo.</target>       </trans-unit>
        <trans-unit id="375" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryAddToAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0)">
          <source>The count of <ph id="ph1">&lt;paramref name="collections" /&gt;</ph> is greater than the maximum size of 62 for STA and 63 for MTA.</source>
          <target state="translated">A contagem de <ph id="ph1">&lt;paramref name="collections" /&gt;</ph> é maior que o tamanho máximo de 62 para STA e 63 para MTA.</target>       </trans-unit>
        <trans-unit id="376" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryAddToAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0)">
          <source>The <ph id="ph1">&lt;paramref name="collections" /&gt;</ph> argument is a 0-length array or contains a null element, or at least one of collections has been marked as complete for adding.</source>
          <target state="translated">O argumento <ph id="ph1">&lt;paramref name="collections" /&gt;</ph> é uma matriz de tamanho 0 ou contém um elemento nulo, ou pelo menos uma das coleções foi marcada como completa para adição.</target>       </trans-unit>
        <trans-unit id="377" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryAddToAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0)">
          <source>At least one underlying collection didn't accept the item.</source>
          <target state="translated">Pelo menos uma coleção subjacente não aceitou o item.</target>       </trans-unit>
        <trans-unit id="378" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryAddToAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0,System.Int32)">
          <source>The array of collections.</source>
          <target state="translated">A matriz de coleções.</target>       </trans-unit>
        <trans-unit id="379" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryAddToAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0,System.Int32)">
          <source>The item to be added to one of the collections.</source>
          <target state="translated">O item a ser adicionado a uma das coleções.</target>       </trans-unit>
        <trans-unit id="380" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryAddToAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0,System.Int32)">
          <source>The number of milliseconds to wait, or <ph id="ph1">&lt;see cref="F:System.Threading.Timeout.Infinite" /&gt;</ph> (-1) to wait indefinitely.</source>
          <target state="translated">O número de milissegundos para aguardar ou <ph id="ph1">&lt;see cref="F:System.Threading.Timeout.Infinite" /&gt;</ph> (- 1) para aguardar indefinidamente.</target>       </trans-unit>
        <trans-unit id="381" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryAddToAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0,System.Int32)">
          <source>Tries to add the specified item to any one of the specified <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> instances.</source>
          <target state="translated">Tenta adicionar o item especificado a qualquer uma das instâncias <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> especificadas.</target>       </trans-unit>
        <trans-unit id="382" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryAddToAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0,System.Int32)">
          <source>The index of the collection in the <ph id="ph1">&lt;paramref name="collections" /&gt;</ph> array to which the item was added, or -1 if the item could not be added.</source>
          <target state="translated">O índice da coleção na matriz <ph id="ph1">&lt;paramref name="collections" /&gt;</ph> ao qual o item foi adicionado ou -1 caso o item não possa ser adicionado.</target>       </trans-unit>
        <trans-unit id="383" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryAddToAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0,System.Int32)">
          <source>At least one of the <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> instances has been disposed.</source>
          <target state="translated">Pelo menos uma das instâncias de <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> foi descartada.</target>       </trans-unit>
        <trans-unit id="384" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryAddToAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0,System.Int32)">
          <source>The <ph id="ph1">&lt;paramref name="collections" /&gt;</ph> argument is null.</source>
          <target state="translated">O argumento <ph id="ph1">&lt;paramref name="collections" /&gt;</ph> é nulo.</target>       </trans-unit>
        <trans-unit id="385" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryAddToAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="millisecondsTimeout" /&gt;</ph> is a negative number other than -1, which represents an infinite time-out.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="millisecondsTimeout" /&gt;</ph> é um número negativo diferente de -1, que representa um tempo limite infinito.</target>       </trans-unit>
        <trans-unit id="386" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryAddToAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0,System.Int32)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="387" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryAddToAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0,System.Int32)">
          <source>The count of <ph id="ph1">&lt;paramref name="collections" /&gt;</ph> is greater than the maximum size of 62 for STA and 63 for MTA.</source>
          <target state="translated">A contagem de <ph id="ph1">&lt;paramref name="collections" /&gt;</ph> é maior que o tamanho máximo de 62 para STA e 63 para MTA.</target>       </trans-unit>
        <trans-unit id="388" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryAddToAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0,System.Int32)">
          <source>The <ph id="ph1">&lt;paramref name="collections" /&gt;</ph> argument is a 0-length array or contains a null element, or at least one of collections has been marked as complete for adding.</source>
          <target state="translated">O argumento <ph id="ph1">&lt;paramref name="collections" /&gt;</ph> é uma matriz de tamanho 0 ou contém um elemento nulo, ou pelo menos uma das coleções foi marcada como completa para adição.</target>       </trans-unit>
        <trans-unit id="389" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryAddToAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0,System.Int32)">
          <source>At least one underlying collection didn't accept the item.</source>
          <target state="translated">Pelo menos uma coleção subjacente não aceitou o item.</target>       </trans-unit>
        <trans-unit id="390" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryAddToAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0,System.TimeSpan)">
          <source>The array of collections.</source>
          <target state="translated">A matriz de coleções.</target>       </trans-unit>
        <trans-unit id="391" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryAddToAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0,System.TimeSpan)">
          <source>The item to be added to one of the collections.</source>
          <target state="translated">O item a ser adicionado a uma das coleções.</target>       </trans-unit>
        <trans-unit id="392" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryAddToAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0,System.TimeSpan)">
          <source>A <ph id="ph1">&lt;see cref="T:System.TimeSpan" /&gt;</ph> that represents the number of milliseconds to wait, or a <ph id="ph2">&lt;see cref="T:System.TimeSpan" /&gt;</ph> that represents -1 milliseconds to wait indefinitely.</source>
          <target state="translated">Um <ph id="ph1">&lt;see cref="T:System.TimeSpan" /&gt;</ph> que representa o número de milissegundos para aguardar ou um <ph id="ph2">&lt;see cref="T:System.TimeSpan" /&gt;</ph> que representa -1 milissegundos para aguardar indefinidamente.</target>       </trans-unit>
        <trans-unit id="393" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryAddToAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0,System.TimeSpan)">
          <source>Tries to add the specified item to any one of the specified <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> instances while observing the specified cancellation token.</source>
          <target state="translated">Tenta adicionar o item especificado a qualquer uma das instâncias <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> especificadas, observando ao mesmo tempo o token de cancelamento especificado.</target>       </trans-unit>
        <trans-unit id="394" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryAddToAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0,System.TimeSpan)">
          <source>The index of the collection in the <ph id="ph1">&lt;paramref name="collections" /&gt;</ph> array to which the item was added, or -1 if the item could not be added.</source>
          <target state="translated">O índice da coleção na matriz <ph id="ph1">&lt;paramref name="collections" /&gt;</ph> ao qual o item foi adicionado ou -1 caso o item não possa ser adicionado.</target>       </trans-unit>
        <trans-unit id="395" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryAddToAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0,System.TimeSpan)">
          <source>This method can return early if the cancellationToken is cancelled before space was available for the Add operation.</source>
          <target state="translated">Esse método pode retornar logo se o cancellationToken for cancelado antes de que havia espaço disponível para a operação de adição.</target>       </trans-unit>
        <trans-unit id="396" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryAddToAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0,System.TimeSpan)">
          <source>At least one of the <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> instances or the <ph id="ph2">&lt;see cref="T:System.Threading.CancellationTokenSource" /&gt;</ph> that created <ph id="ph3">&lt;paramref name="cancellationToken" /&gt;</ph> has been disposed.</source>
          <target state="translated">Pelo menos uma das instâncias <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> ou o <ph id="ph2">&lt;see cref="T:System.Threading.CancellationTokenSource" /&gt;</ph> que criou <ph id="ph3">&lt;paramref name="cancellationToken" /&gt;</ph> foi descartado.</target>       </trans-unit>
        <trans-unit id="397" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryAddToAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0,System.TimeSpan)">
          <source>The <ph id="ph1">&lt;paramref name="collections" /&gt;</ph> argument is null.</source>
          <target state="translated">O argumento <ph id="ph1">&lt;paramref name="collections" /&gt;</ph> é nulo.</target>       </trans-unit>
        <trans-unit id="398" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryAddToAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0,System.TimeSpan)">
          <source><ph id="ph1">&lt;paramref name="timeout" /&gt;</ph> is a negative number other than -1 milliseconds, which represents an infinite time-out -or- timeout is greater than <ph id="ph2">&lt;see cref="F:System.Int32.MaxValue" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="timeout" /&gt;</ph> é um número negativo diferente de -1 milissegundos, que representa um tempo limite infinito ou o tempo limite é maior que <ph id="ph2">&lt;see cref="F:System.Int32.MaxValue" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="399" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryAddToAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0,System.TimeSpan)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="400" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryAddToAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0,System.TimeSpan)">
          <source>The count of <ph id="ph1">&lt;paramref name="collections" /&gt;</ph> is greater than the maximum size of 62 for STA and 63 for MTA.</source>
          <target state="translated">A contagem de <ph id="ph1">&lt;paramref name="collections" /&gt;</ph> é maior que o tamanho máximo de 62 para STA e 63 para MTA.</target>       </trans-unit>
        <trans-unit id="401" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryAddToAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0,System.TimeSpan)">
          <source>The <ph id="ph1">&lt;paramref name="collections" /&gt;</ph> argument is a 0-length array or contains a null element, or at least one of collections has been marked as complete for adding.</source>
          <target state="translated">O argumento <ph id="ph1">&lt;paramref name="collections" /&gt;</ph> é uma matriz de tamanho 0 ou contém um elemento nulo, ou pelo menos uma das coleções foi marcada como completa para adição.</target>       </trans-unit>
        <trans-unit id="402" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryAddToAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0,System.TimeSpan)">
          <source>At least one underlying collection didn't accept the item.</source>
          <target state="translated">Pelo menos uma coleção subjacente não aceitou o item.</target>       </trans-unit>
        <trans-unit id="403" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryAddToAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0,System.Int32,System.Threading.CancellationToken)">
          <source>The array of collections.</source>
          <target state="translated">A matriz de coleções.</target>       </trans-unit>
        <trans-unit id="404" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryAddToAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0,System.Int32,System.Threading.CancellationToken)">
          <source>The item to be added to one of the collections.</source>
          <target state="translated">O item a ser adicionado a uma das coleções.</target>       </trans-unit>
        <trans-unit id="405" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryAddToAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0,System.Int32,System.Threading.CancellationToken)">
          <source>The number of milliseconds to wait, or <ph id="ph1">&lt;see cref="F:System.Threading.Timeout.Infinite" /&gt;</ph> (-1) to wait indefinitely.</source>
          <target state="translated">O número de milissegundos para aguardar ou <ph id="ph1">&lt;see cref="F:System.Threading.Timeout.Infinite" /&gt;</ph> (- 1) para aguardar indefinidamente.</target>       </trans-unit>
        <trans-unit id="406" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryAddToAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0,System.Int32,System.Threading.CancellationToken)">
          <source>A cancellation token to observe.</source>
          <target state="translated">Um token de cancelamento a ser observado.</target>       </trans-unit>
        <trans-unit id="407" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryAddToAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0,System.Int32,System.Threading.CancellationToken)">
          <source>Tries to add the specified item to any one of the specified <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> instances.</source>
          <target state="translated">Tenta adicionar o item especificado a qualquer uma das instâncias <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> especificadas.</target>       </trans-unit>
        <trans-unit id="408" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryAddToAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0,System.Int32,System.Threading.CancellationToken)">
          <source>The index of the collection in the <ph id="ph1">&lt;paramref name="collections" /&gt;</ph> array to which the item was added, or -1 if the item could not be added.</source>
          <target state="translated">O índice da coleção na matriz <ph id="ph1">&lt;paramref name="collections" /&gt;</ph> ao qual o item foi adicionado ou -1 caso o item não possa ser adicionado.</target>       </trans-unit>
        <trans-unit id="409" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryAddToAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0,System.Int32,System.Threading.CancellationToken)">
          <source>If the <ph id="ph1">&lt;see cref="T:System.Threading.CancellationToken" /&gt;</ph> is canceled.</source>
          <target state="translated">Se o padrão <ph id="ph1">&lt;see cref="T:System.Threading.CancellationToken" /&gt;</ph> for cancelado.</target>       </trans-unit>
        <trans-unit id="410" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryAddToAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0,System.Int32,System.Threading.CancellationToken)">
          <source>At least one underlying collection didn't accept the item.</source>
          <target state="translated">Pelo menos uma coleção subjacente não aceitou o item.</target>       </trans-unit>
        <trans-unit id="411" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryAddToAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0,System.Int32,System.Threading.CancellationToken)">
          <source>The <ph id="ph1">&lt;paramref name="collections" /&gt;</ph> argument is null.</source>
          <target state="translated">O argumento <ph id="ph1">&lt;paramref name="collections" /&gt;</ph> é nulo.</target>       </trans-unit>
        <trans-unit id="412" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryAddToAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0,System.Int32,System.Threading.CancellationToken)">
          <source><ph id="ph1">&lt;paramref name="millisecondsTimeout" /&gt;</ph> is a negative number other than -1, which represents an infinite time-out.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="millisecondsTimeout" /&gt;</ph> é um número negativo diferente de -1, que representa um tempo limite infinito.</target>       </trans-unit>
        <trans-unit id="413" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryAddToAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0,System.Int32,System.Threading.CancellationToken)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="414" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryAddToAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0,System.Int32,System.Threading.CancellationToken)">
          <source>The count of <ph id="ph1">&lt;paramref name="collections" /&gt;</ph> is greater than the maximum size of 62 for STA and 63 for MTA.</source>
          <target state="translated">A contagem de <ph id="ph1">&lt;paramref name="collections" /&gt;</ph> é maior que o tamanho máximo de 62 para STA e 63 para MTA.</target>       </trans-unit>
        <trans-unit id="415" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryAddToAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0,System.Int32,System.Threading.CancellationToken)">
          <source>The <ph id="ph1">&lt;paramref name="collections" /&gt;</ph> argument is a 0-length array or contains a null element, or at least one of collections has been marked as complete for adding.</source>
          <target state="translated">O argumento <ph id="ph1">&lt;paramref name="collections" /&gt;</ph> é uma matriz de tamanho 0 ou contém um elemento nulo, ou pelo menos uma das coleções foi marcada como completa para adição.</target>       </trans-unit>
        <trans-unit id="416" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryAddToAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0,System.Int32,System.Threading.CancellationToken)">
          <source>At least one of the <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> instances has been disposed.</source>
          <target state="translated">Pelo menos uma das instâncias de <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> foi descartada.</target>       </trans-unit>
        <trans-unit id="417" translate="yes" xml:space="preserve" uid="T:System.Collections.Concurrent.BlockingCollection`1">
          <source>Tries to remove an item from the <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph>.</source>
          <target state="translated">Tenta remover um item no <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="418" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Concurrent.BlockingCollection`1">
          <source>The following example shows how to use the <ph id="ph1">&lt;xref:System.Collections.Concurrent.BlockingCollection%601.TryTake%2A&gt;</ph> method.</source>
          <target state="translated">O exemplo a seguir mostra como usar o método <ph id="ph1">&lt;xref:System.Collections.Concurrent.BlockingCollection%601.TryTake%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="419" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryTake(`0@)">
          <source>The item to be removed from the collection.</source>
          <target state="translated">O item a ser removido da coleção.</target>       </trans-unit>
        <trans-unit id="420" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryTake(`0@)">
          <source>Tries to remove an item from the <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph>.</source>
          <target state="translated">Tenta remover um item no <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="421" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryTake(`0@)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if an item could be removed; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> se um item pode ser removido; Caso contrário, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="422" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryTake(`0@)">
          <source>If the collection is empty, this method immediately returns false.</source>
          <target state="translated">Se a coleção estiver vazia, esse método imediatamente retorna false.</target>       </trans-unit>
        <trans-unit id="423" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryTake(`0@)">
          <source>The order in which an item is removed depends on the type of collection used to create the <ph id="ph1">&lt;xref:System.Collections.Concurrent.BlockingCollection%601&gt;</ph> instance.</source>
          <target state="translated">A ordem na qual um item é removido depende do tipo de coleção usado para criar a instância <ph id="ph1">&lt;xref:System.Collections.Concurrent.BlockingCollection%601&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="424" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryTake(`0@)">
          <source>When you create a <ph id="ph1">&lt;xref:System.Collections.Concurrent.BlockingCollection%601&gt;</ph> object, you can specify the type of collection to use.</source>
          <target state="translated">Ao criar um objeto <ph id="ph1">&lt;xref:System.Collections.Concurrent.BlockingCollection%601&gt;</ph>, você pode especificar o tipo de coleção a ser usado.</target>       </trans-unit>
        <trans-unit id="425" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryTake(`0@)">
          <source>For example, you could specify a <ph id="ph1">&lt;xref:System.Collections.Concurrent.ConcurrentQueue%601&gt;</ph> object for first in, first out (FIFO) behavior, or a <ph id="ph2">&lt;xref:System.Collections.Concurrent.ConcurrentStack%601&gt;</ph> object for last in, first out (LIFO) behavior.</source>
          <target state="translated">Por exemplo, seria possível especificar um objeto <ph id="ph1">&lt;xref:System.Collections.Concurrent.ConcurrentQueue%601&gt;</ph> para o comportamento primeiro a entrar, primeiro a sair (PEPS) ou um objeto <ph id="ph2">&lt;xref:System.Collections.Concurrent.ConcurrentStack%601&gt;</ph> para último a entrar, primeiro a sair (UEPS).</target>       </trans-unit>
        <trans-unit id="426" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryTake(`0@)">
          <source>You can use any collection class that implements the <ph id="ph1">&lt;xref:System.Collections.Concurrent.IProducerConsumerCollection%601&gt;</ph> interface.</source>
          <target state="translated">Você pode usar qualquer classe de coleção que implemente a interface <ph id="ph1">&lt;xref:System.Collections.Concurrent.IProducerConsumerCollection%601&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="427" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryTake(`0@)">
          <source>The default collection type for <ph id="ph1">&lt;xref:System.Collections.Concurrent.BlockingCollection%601&gt;</ph> is <ph id="ph2">&lt;xref:System.Collections.Concurrent.ConcurrentQueue%601&gt;</ph>.</source>
          <target state="translated">O tipo de coleção padrão para <ph id="ph1">&lt;xref:System.Collections.Concurrent.BlockingCollection%601&gt;</ph> é <ph id="ph2">&lt;xref:System.Collections.Concurrent.ConcurrentQueue%601&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="428" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryTake(`0@)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> has been disposed.</source>
          <target state="translated">O <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> foi descartado.</target>       </trans-unit>
        <trans-unit id="429" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryTake(`0@)">
          <source>The underlying collection was modified outside of this <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> instance.</source>
          <target state="translated">A coleção subjacente foi alterada fora da instância de <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="430" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryTake(`0@,System.Int32)">
          <source>The item to be removed from the collection.</source>
          <target state="translated">O item a ser removido da coleção.</target>       </trans-unit>
        <trans-unit id="431" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryTake(`0@,System.Int32)">
          <source>The number of milliseconds to wait, or <ph id="ph1">&lt;see cref="F:System.Threading.Timeout.Infinite" /&gt;</ph> (-1) to wait indefinitely.</source>
          <target state="translated">O número de milissegundos para aguardar ou <ph id="ph1">&lt;see cref="F:System.Threading.Timeout.Infinite" /&gt;</ph> (- 1) para aguardar indefinidamente.</target>       </trans-unit>
        <trans-unit id="432" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryTake(`0@,System.Int32)">
          <source>Tries to remove an item from the <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> in the specified time period.</source>
          <target state="translated">Tenta remover um item do <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> no período de tempo especificado.</target>       </trans-unit>
        <trans-unit id="433" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryTake(`0@,System.Int32)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if an item could be removed from the collection within the specified  time; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> se um item puder ser removido da coleção dentro do tempo especificado; caso contrário, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="434" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryTake(`0@,System.Int32)">
          <source>The order in which an item is removed depends on the type of collection used to create the <ph id="ph1">&lt;xref:System.Collections.Concurrent.BlockingCollection%601&gt;</ph> instance.</source>
          <target state="translated">A ordem na qual um item é removido depende do tipo de coleção usado para criar a instância <ph id="ph1">&lt;xref:System.Collections.Concurrent.BlockingCollection%601&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="435" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryTake(`0@,System.Int32)">
          <source>When you create a <ph id="ph1">&lt;xref:System.Collections.Concurrent.BlockingCollection%601&gt;</ph>, you can specify the type of collection to use.</source>
          <target state="translated">Quando você cria um <ph id="ph1">&lt;xref:System.Collections.Concurrent.BlockingCollection%601&gt;</ph>, você pode especificar o tipo de coleção para usar.</target>       </trans-unit>
        <trans-unit id="436" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryTake(`0@,System.Int32)">
          <source>For example, you could specify a <ph id="ph1">&lt;xref:System.Collections.Concurrent.ConcurrentQueue%601&gt;</ph> object for first in, first out (FIFO) behavior, or a <ph id="ph2">&lt;xref:System.Collections.Concurrent.ConcurrentStack%601&gt;</ph> object for last in, first out (LIFO) behavior.</source>
          <target state="translated">Por exemplo, seria possível especificar um objeto <ph id="ph1">&lt;xref:System.Collections.Concurrent.ConcurrentQueue%601&gt;</ph> para o comportamento primeiro a entrar, primeiro a sair (PEPS) ou um objeto <ph id="ph2">&lt;xref:System.Collections.Concurrent.ConcurrentStack%601&gt;</ph> para último a entrar, primeiro a sair (UEPS).</target>       </trans-unit>
        <trans-unit id="437" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryTake(`0@,System.Int32)">
          <source>You can use any collection class that implements the <ph id="ph1">&lt;xref:System.Collections.Concurrent.IProducerConsumerCollection%601&gt;</ph> interface.</source>
          <target state="translated">Você pode usar qualquer classe de coleção que implemente a interface <ph id="ph1">&lt;xref:System.Collections.Concurrent.IProducerConsumerCollection%601&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="438" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryTake(`0@,System.Int32)">
          <source>The default collection type for <ph id="ph1">&lt;xref:System.Collections.Concurrent.BlockingCollection%601&gt;</ph> is <ph id="ph2">&lt;xref:System.Collections.Concurrent.ConcurrentQueue%601&gt;</ph>.</source>
          <target state="translated">O tipo de coleção padrão para <ph id="ph1">&lt;xref:System.Collections.Concurrent.BlockingCollection%601&gt;</ph> é <ph id="ph2">&lt;xref:System.Collections.Concurrent.ConcurrentQueue%601&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="439" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryTake(`0@,System.Int32)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> has been disposed.</source>
          <target state="translated">O <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> foi descartado.</target>       </trans-unit>
        <trans-unit id="440" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryTake(`0@,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="millisecondsTimeout" /&gt;</ph> is a negative number other than -1, which represents an infinite time-out.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="millisecondsTimeout" /&gt;</ph> é um número negativo diferente de -1, que representa um tempo limite infinito.</target>       </trans-unit>
        <trans-unit id="441" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryTake(`0@,System.Int32)">
          <source>The underlying collection was modified outside of this <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> instance.</source>
          <target state="translated">A coleção subjacente foi alterada fora da instância de <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="442" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryTake(`0@,System.TimeSpan)">
          <source>The item to be removed from the collection.</source>
          <target state="translated">O item a ser removido da coleção.</target>       </trans-unit>
        <trans-unit id="443" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryTake(`0@,System.TimeSpan)">
          <source>An object that represents the number of milliseconds to wait, or an object that represents -1 milliseconds to wait indefinitely.</source>
          <target state="translated">Um objeto que representa o número de milissegundos de espera ou um objeto que representa -1 milissegundos para esperar por tempo indeterminado.</target>       </trans-unit>
        <trans-unit id="444" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryTake(`0@,System.TimeSpan)">
          <source>Tries to remove an item from the <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> in the specified time period.</source>
          <target state="translated">Tenta remover um item do <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> no período de tempo especificado.</target>       </trans-unit>
        <trans-unit id="445" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryTake(`0@,System.TimeSpan)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if an item could be removed from the collection within the specified  time; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> se um item puder ser removido da coleção dentro do tempo especificado; caso contrário, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="446" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryTake(`0@,System.TimeSpan)">
          <source>The order in which an item is removed depends on the type of collection used to create the <ph id="ph1">&lt;xref:System.Collections.Concurrent.BlockingCollection%601&gt;</ph> instance.</source>
          <target state="translated">A ordem na qual um item é removido depende do tipo de coleção usado para criar a instância <ph id="ph1">&lt;xref:System.Collections.Concurrent.BlockingCollection%601&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="447" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryTake(`0@,System.TimeSpan)">
          <source>When you create a <ph id="ph1">&lt;xref:System.Collections.Concurrent.BlockingCollection%601&gt;</ph> object, you can specify the type of collection to use.</source>
          <target state="translated">Ao criar um objeto <ph id="ph1">&lt;xref:System.Collections.Concurrent.BlockingCollection%601&gt;</ph>, você pode especificar o tipo de coleção a ser usado.</target>       </trans-unit>
        <trans-unit id="448" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryTake(`0@,System.TimeSpan)">
          <source>For example, you could specify a <ph id="ph1">&lt;xref:System.Collections.Concurrent.ConcurrentQueue%601&gt;</ph> object for first in, first out (FIFO) behavior, or a <ph id="ph2">&lt;xref:System.Collections.Concurrent.ConcurrentStack%601&gt;</ph> object for last in, first out (LIFO) behavior.</source>
          <target state="translated">Por exemplo, seria possível especificar um objeto <ph id="ph1">&lt;xref:System.Collections.Concurrent.ConcurrentQueue%601&gt;</ph> para o comportamento primeiro a entrar, primeiro a sair (PEPS) ou um objeto <ph id="ph2">&lt;xref:System.Collections.Concurrent.ConcurrentStack%601&gt;</ph> para último a entrar, primeiro a sair (UEPS).</target>       </trans-unit>
        <trans-unit id="449" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryTake(`0@,System.TimeSpan)">
          <source>You can use any collection class that implements the <ph id="ph1">&lt;xref:System.Collections.Concurrent.IProducerConsumerCollection%601&gt;</ph> interface.</source>
          <target state="translated">Você pode usar qualquer classe de coleção que implemente a interface <ph id="ph1">&lt;xref:System.Collections.Concurrent.IProducerConsumerCollection%601&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="450" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryTake(`0@,System.TimeSpan)">
          <source>The default collection type for <ph id="ph1">&lt;xref:System.Collections.Concurrent.BlockingCollection%601&gt;</ph> is <ph id="ph2">&lt;xref:System.Collections.Concurrent.ConcurrentQueue%601&gt;</ph>.</source>
          <target state="translated">O tipo de coleção padrão para <ph id="ph1">&lt;xref:System.Collections.Concurrent.BlockingCollection%601&gt;</ph> é <ph id="ph2">&lt;xref:System.Collections.Concurrent.ConcurrentQueue%601&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="451" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryTake(`0@,System.TimeSpan)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> has been disposed.</source>
          <target state="translated">O <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> foi descartado.</target>       </trans-unit>
        <trans-unit id="452" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryTake(`0@,System.TimeSpan)">
          <source><ph id="ph1">&lt;paramref name="timeout" /&gt;</ph> is a negative number other than -1 milliseconds, which represents an infinite time-out.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="timeout" /&gt;</ph> é um número negativo diferente de -1 milissegundo, que representa um tempo limite infinito.</target>       </trans-unit>
        <trans-unit id="453" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryTake(`0@,System.TimeSpan)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="454" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryTake(`0@,System.TimeSpan)">
          <source><ph id="ph1">&lt;paramref name="timeout" /&gt;</ph> is greater than <ph id="ph2">&lt;see cref="F:System.Int32.MaxValue" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="timeout" /&gt;</ph> é maior que <ph id="ph2">&lt;see cref="F:System.Int32.MaxValue" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="455" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryTake(`0@,System.TimeSpan)">
          <source>The underlying collection was modified outside of this <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> instance.</source>
          <target state="translated">A coleção subjacente foi alterada fora da instância de <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="456" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryTake(`0@,System.Int32,System.Threading.CancellationToken)">
          <source>The item to be removed from the collection.</source>
          <target state="translated">O item a ser removido da coleção.</target>       </trans-unit>
        <trans-unit id="457" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryTake(`0@,System.Int32,System.Threading.CancellationToken)">
          <source>The number of milliseconds to wait, or <ph id="ph1">&lt;see cref="F:System.Threading.Timeout.Infinite" /&gt;</ph> (-1) to wait indefinitely.</source>
          <target state="translated">O número de milissegundos para aguardar ou <ph id="ph1">&lt;see cref="F:System.Threading.Timeout.Infinite" /&gt;</ph> (- 1) para aguardar indefinidamente.</target>       </trans-unit>
        <trans-unit id="458" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryTake(`0@,System.Int32,System.Threading.CancellationToken)">
          <source>A cancellation token to observe.</source>
          <target state="translated">Um token de cancelamento a ser observado.</target>       </trans-unit>
        <trans-unit id="459" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryTake(`0@,System.Int32,System.Threading.CancellationToken)">
          <source>Tries to remove an item from the <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> in the specified time period while observing a cancellation token.</source>
          <target state="translated">Tenta remover um item do <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> no período especificado, enquanto observa um token de cancelamento.</target>       </trans-unit>
        <trans-unit id="460" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryTake(`0@,System.Int32,System.Threading.CancellationToken)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if an item could be removed from the collection within the specified  time; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> se um item puder ser removido da coleção dentro do tempo especificado; caso contrário, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="461" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryTake(`0@,System.Int32,System.Threading.CancellationToken)">
          <source>The order in which an item is removed depends on the type of collection used to create the <ph id="ph1">&lt;xref:System.Collections.Concurrent.BlockingCollection%601&gt;</ph> instance.</source>
          <target state="translated">A ordem na qual um item é removido depende do tipo de coleção usado para criar a instância <ph id="ph1">&lt;xref:System.Collections.Concurrent.BlockingCollection%601&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="462" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryTake(`0@,System.Int32,System.Threading.CancellationToken)">
          <source>When you create a <ph id="ph1">&lt;xref:System.Collections.Concurrent.BlockingCollection%601&gt;</ph> object, you can specify the type of collection to use.</source>
          <target state="translated">Ao criar um objeto <ph id="ph1">&lt;xref:System.Collections.Concurrent.BlockingCollection%601&gt;</ph>, você pode especificar o tipo de coleção a ser usado.</target>       </trans-unit>
        <trans-unit id="463" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryTake(`0@,System.Int32,System.Threading.CancellationToken)">
          <source>For example, you could specify a <ph id="ph1">&lt;xref:System.Collections.Concurrent.ConcurrentQueue%601&gt;</ph> object for first in, first out (FIFO) behavior, or a <ph id="ph2">&lt;xref:System.Collections.Concurrent.ConcurrentStack%601&gt;</ph> object for last in, first out (LIFO) behavior.</source>
          <target state="translated">Por exemplo, seria possível especificar um objeto <ph id="ph1">&lt;xref:System.Collections.Concurrent.ConcurrentQueue%601&gt;</ph> para o comportamento primeiro a entrar, primeiro a sair (PEPS) ou um objeto <ph id="ph2">&lt;xref:System.Collections.Concurrent.ConcurrentStack%601&gt;</ph> para último a entrar, primeiro a sair (UEPS).</target>       </trans-unit>
        <trans-unit id="464" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryTake(`0@,System.Int32,System.Threading.CancellationToken)">
          <source>You can use any collection class that implements the <ph id="ph1">&lt;xref:System.Collections.Concurrent.IProducerConsumerCollection%601&gt;</ph> interface.</source>
          <target state="translated">Você pode usar qualquer classe de coleção que implemente a interface <ph id="ph1">&lt;xref:System.Collections.Concurrent.IProducerConsumerCollection%601&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="465" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryTake(`0@,System.Int32,System.Threading.CancellationToken)">
          <source>The default collection type for <ph id="ph1">&lt;xref:System.Collections.Concurrent.BlockingCollection%601&gt;</ph> is <ph id="ph2">&lt;xref:System.Collections.Concurrent.ConcurrentQueue%601&gt;</ph>.</source>
          <target state="translated">O tipo de coleção padrão para <ph id="ph1">&lt;xref:System.Collections.Concurrent.BlockingCollection%601&gt;</ph> é <ph id="ph2">&lt;xref:System.Collections.Concurrent.ConcurrentQueue%601&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="466" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryTake(`0@,System.Int32,System.Threading.CancellationToken)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Threading.CancellationToken" /&gt;</ph> has been canceled.</source>
          <target state="translated">O <ph id="ph1">&lt;see cref="T:System.Threading.CancellationToken" /&gt;</ph> foi cancelado.</target>       </trans-unit>
        <trans-unit id="467" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryTake(`0@,System.Int32,System.Threading.CancellationToken)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> has been disposed or the underlying <ph id="ph2">&lt;see cref="T:System.Threading.CancellationTokenSource" /&gt;</ph> has been disposed.</source>
          <target state="translated">O <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> foi descartado ou o <ph id="ph2">&lt;see cref="T:System.Threading.CancellationTokenSource" /&gt;</ph> subjacente foi descartado.</target>       </trans-unit>
        <trans-unit id="468" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryTake(`0@,System.Int32,System.Threading.CancellationToken)">
          <source><ph id="ph1">&lt;paramref name="millisecondsTimeout" /&gt;</ph> is a negative number other than -1, which represents an infinite time-out.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="millisecondsTimeout" /&gt;</ph> é um número negativo diferente de -1, que representa um tempo limite infinito.</target>       </trans-unit>
        <trans-unit id="469" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryTake(`0@,System.Int32,System.Threading.CancellationToken)">
          <source>The underlying collection was modified outside this <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> instance.</source>
          <target state="translated">A coleção subjacente foi alterada fora da dessa instância de <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="470" translate="yes" xml:space="preserve" uid="T:System.Collections.Concurrent.BlockingCollection`1">
          <source>Tries to remove an item from any one of the specified <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> instances.</source>
          <target state="translated">Tenta remover um item de qualquer uma das instâncias <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> especificadas.</target>       </trans-unit>
        <trans-unit id="471" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryTakeFromAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0@)">
          <source>The array of collections.</source>
          <target state="translated">A matriz de coleções.</target>       </trans-unit>
        <trans-unit id="472" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryTakeFromAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0@)">
          <source>The item removed from one of the collections.</source>
          <target state="translated">O item removido de uma das coleções.</target>       </trans-unit>
        <trans-unit id="473" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryTakeFromAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0@)">
          <source>Tries to remove an item from any one of the specified <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> instances.</source>
          <target state="translated">Tenta remover um item de qualquer uma das instâncias <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> especificadas.</target>       </trans-unit>
        <trans-unit id="474" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryTakeFromAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0@)">
          <source>The index of the collection in the <ph id="ph1">&lt;paramref name="collections" /&gt;</ph> array from which the item was removed, or -1 if an item could not be removed.</source>
          <target state="translated">O índice da coleção na matriz <ph id="ph1">&lt;paramref name="collections" /&gt;</ph> da qual o item foi removido ou -1 caso um item não possa ser removido.</target>       </trans-unit>
        <trans-unit id="475" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryTakeFromAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0@)">
          <source>A call to TryTakeFromAny may block until an item is available to be removed.</source>
          <target state="translated">Uma chamada para TryTakeFromAny pode ser bloqueada até que um item esteja disponível para ser removido.</target>       </trans-unit>
        <trans-unit id="476" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryTakeFromAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0@)">
          <source>The following example shows how to use the <ph id="ph1">&lt;xref:System.Collections.Concurrent.BlockingCollection%601.TryTakeFromAny%2A?displayProperty=nameWithType&gt;</ph> method:</source>
          <target state="translated">O exemplo a seguir mostra como usar o <ph id="ph1">&lt;xref:System.Collections.Concurrent.BlockingCollection%601.TryTakeFromAny%2A?displayProperty=nameWithType&gt;</ph> método:</target>       </trans-unit>
        <trans-unit id="477" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryTakeFromAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0@)">
          <source>At least one of the <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> instances has been disposed.</source>
          <target state="translated">Pelo menos uma das instâncias de <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> foi descartada.</target>       </trans-unit>
        <trans-unit id="478" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryTakeFromAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0@)">
          <source>The <ph id="ph1">&lt;paramref name="collections" /&gt;</ph> argument is null.</source>
          <target state="translated">O argumento <ph id="ph1">&lt;paramref name="collections" /&gt;</ph> é nulo.</target>       </trans-unit>
        <trans-unit id="479" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryTakeFromAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0@)">
          <source>The count of <ph id="ph1">&lt;paramref name="collections" /&gt;</ph> is greater than the maximum size of 62 for STA and 63 for MTA.</source>
          <target state="translated">A contagem de <ph id="ph1">&lt;paramref name="collections" /&gt;</ph> é maior que o tamanho máximo de 62 para STA e 63 para MTA.</target>       </trans-unit>
        <trans-unit id="480" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryTakeFromAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0@)">
          <source>The <ph id="ph1">&lt;paramref name="collections" /&gt;</ph> argument is a 0-length array or contains a null element.</source>
          <target state="translated">O argumento <ph id="ph1">&lt;paramref name="collections" /&gt;</ph> é uma matriz de tamanho 0 ou contém um elemento nulo.</target>       </trans-unit>
        <trans-unit id="481" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryTakeFromAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0@)">
          <source>At least one of the underlying collections was modified outside of its <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> instance.</source>
          <target state="translated">Pelo menos uma das coleções subjacentes foi alterada fora da instância de <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="482" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryTakeFromAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0@,System.Int32)">
          <source>The array of collections.</source>
          <target state="translated">A matriz de coleções.</target>       </trans-unit>
        <trans-unit id="483" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryTakeFromAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0@,System.Int32)">
          <source>The item removed from one of the collections.</source>
          <target state="translated">O item removido de uma das coleções.</target>       </trans-unit>
        <trans-unit id="484" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryTakeFromAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0@,System.Int32)">
          <source>The number of milliseconds to wait, or <ph id="ph1">&lt;see cref="F:System.Threading.Timeout.Infinite" /&gt;</ph> (-1) to wait indefinitely.</source>
          <target state="translated">O número de milissegundos para aguardar ou <ph id="ph1">&lt;see cref="F:System.Threading.Timeout.Infinite" /&gt;</ph> (- 1) para aguardar indefinidamente.</target>       </trans-unit>
        <trans-unit id="485" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryTakeFromAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0@,System.Int32)">
          <source>Tries to remove an item from any one of the specified <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> instances.</source>
          <target state="translated">Tenta remover um item de qualquer uma das instâncias <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> especificadas.</target>       </trans-unit>
        <trans-unit id="486" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryTakeFromAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0@,System.Int32)">
          <source>The index of the collection in the <ph id="ph1">&lt;paramref name="collections" /&gt;</ph> array from which the item was removed, or -1 if an item could not be removed.</source>
          <target state="translated">O índice da coleção na matriz <ph id="ph1">&lt;paramref name="collections" /&gt;</ph> da qual o item foi removido ou -1 caso um item não possa ser removido.</target>       </trans-unit>
        <trans-unit id="487" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryTakeFromAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0@,System.Int32)">
          <source>A call to TryTakeFromAny may block until an item is available to be removed.</source>
          <target state="translated">Uma chamada para TryTakeFromAny pode ser bloqueada até que um item esteja disponível para ser removido.</target>       </trans-unit>
        <trans-unit id="488" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryTakeFromAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0@,System.Int32)">
          <source>At least one of the <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> instances has been disposed.</source>
          <target state="translated">Pelo menos uma das instâncias de <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> foi descartada.</target>       </trans-unit>
        <trans-unit id="489" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryTakeFromAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0@,System.Int32)">
          <source>The <ph id="ph1">&lt;paramref name="collections" /&gt;</ph> argument is null.</source>
          <target state="translated">O argumento <ph id="ph1">&lt;paramref name="collections" /&gt;</ph> é nulo.</target>       </trans-unit>
        <trans-unit id="490" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryTakeFromAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0@,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="millisecondsTimeout" /&gt;</ph> is a negative number other than -1, which represents an infinite time-out.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="millisecondsTimeout" /&gt;</ph> é um número negativo diferente de -1, que representa um tempo limite infinito.</target>       </trans-unit>
        <trans-unit id="491" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryTakeFromAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0@,System.Int32)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="492" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryTakeFromAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0@,System.Int32)">
          <source>The count of <ph id="ph1">&lt;paramref name="collections" /&gt;</ph> is greater than the maximum size of 62 for STA and 63 for MTA.</source>
          <target state="translated">A contagem de <ph id="ph1">&lt;paramref name="collections" /&gt;</ph> é maior que o tamanho máximo de 62 para STA e 63 para MTA.</target>       </trans-unit>
        <trans-unit id="493" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryTakeFromAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0@,System.Int32)">
          <source>The <ph id="ph1">&lt;paramref name="collections" /&gt;</ph> argument is a 0-length array or contains a null element.</source>
          <target state="translated">O argumento <ph id="ph1">&lt;paramref name="collections" /&gt;</ph> é uma matriz de tamanho 0 ou contém um elemento nulo.</target>       </trans-unit>
        <trans-unit id="494" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryTakeFromAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0@,System.Int32)">
          <source>At least one of the underlying collections was modified outside of its <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> instance.</source>
          <target state="translated">Pelo menos uma das coleções subjacentes foi alterada fora da instância de <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="495" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryTakeFromAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0@,System.TimeSpan)">
          <source>The array of collections.</source>
          <target state="translated">A matriz de coleções.</target>       </trans-unit>
        <trans-unit id="496" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryTakeFromAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0@,System.TimeSpan)">
          <source>The item removed from one of the collections.</source>
          <target state="translated">O item removido de uma das coleções.</target>       </trans-unit>
        <trans-unit id="497" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryTakeFromAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0@,System.TimeSpan)">
          <source>A <ph id="ph1">&lt;see cref="T:System.TimeSpan" /&gt;</ph> that represents the number of milliseconds to wait, or a <ph id="ph2">&lt;see cref="T:System.TimeSpan" /&gt;</ph> that represents -1 milliseconds to wait indefinitely.</source>
          <target state="translated">Um <ph id="ph1">&lt;see cref="T:System.TimeSpan" /&gt;</ph> que representa o número de milissegundos para aguardar ou um <ph id="ph2">&lt;see cref="T:System.TimeSpan" /&gt;</ph> que representa -1 milissegundos para aguardar indefinidamente.</target>       </trans-unit>
        <trans-unit id="498" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryTakeFromAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0@,System.TimeSpan)">
          <source>Tries to remove an item from any one of the specified <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> instances.</source>
          <target state="translated">Tenta remover um item de qualquer uma das instâncias <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> especificadas.</target>       </trans-unit>
        <trans-unit id="499" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryTakeFromAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0@,System.TimeSpan)">
          <source>The index of the collection in the <ph id="ph1">&lt;paramref name="collections" /&gt;</ph> array from which the item was removed, or -1 if an item could not be removed.</source>
          <target state="translated">O índice da coleção na matriz <ph id="ph1">&lt;paramref name="collections" /&gt;</ph> da qual o item foi removido ou -1 caso um item não possa ser removido.</target>       </trans-unit>
        <trans-unit id="500" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryTakeFromAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0@,System.TimeSpan)">
          <source>A call to TryTakeFromAny may block until an item is available to be removed.</source>
          <target state="translated">Uma chamada para TryTakeFromAny pode ser bloqueada até que um item esteja disponível para ser removido.</target>       </trans-unit>
        <trans-unit id="501" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryTakeFromAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0@,System.TimeSpan)">
          <source>At least one of the <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> instances has been disposed.</source>
          <target state="translated">Pelo menos uma das instâncias de <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> foi descartada.</target>       </trans-unit>
        <trans-unit id="502" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryTakeFromAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0@,System.TimeSpan)">
          <source>The <ph id="ph1">&lt;paramref name="collections" /&gt;</ph> argument is null.</source>
          <target state="translated">O argumento <ph id="ph1">&lt;paramref name="collections" /&gt;</ph> é nulo.</target>       </trans-unit>
        <trans-unit id="503" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryTakeFromAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0@,System.TimeSpan)">
          <source><ph id="ph1">&lt;paramref name="timeout" /&gt;</ph> is a negative number other than -1 milliseconds, which represents an infinite time-out -or- timeout is greater than <ph id="ph2">&lt;see cref="F:System.Int32.MaxValue" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="timeout" /&gt;</ph> é um número negativo diferente de -1 milissegundos, que representa um tempo limite infinito ou o tempo limite é maior que <ph id="ph2">&lt;see cref="F:System.Int32.MaxValue" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="504" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryTakeFromAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0@,System.TimeSpan)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="505" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryTakeFromAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0@,System.TimeSpan)">
          <source>The count of <ph id="ph1">&lt;paramref name="collections" /&gt;</ph> is greater than the maximum size of 62 for STA and 63 for MTA.</source>
          <target state="translated">A contagem de <ph id="ph1">&lt;paramref name="collections" /&gt;</ph> é maior que o tamanho máximo de 62 para STA e 63 para MTA.</target>       </trans-unit>
        <trans-unit id="506" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryTakeFromAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0@,System.TimeSpan)">
          <source>The <ph id="ph1">&lt;paramref name="collections" /&gt;</ph> argument is a 0-length array or contains a null element.</source>
          <target state="translated">O argumento <ph id="ph1">&lt;paramref name="collections" /&gt;</ph> é uma matriz de tamanho 0 ou contém um elemento nulo.</target>       </trans-unit>
        <trans-unit id="507" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryTakeFromAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0@,System.TimeSpan)">
          <source>At least one of the underlying collections was modified outside of its <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> instance.</source>
          <target state="translated">Pelo menos uma das coleções subjacentes foi alterada fora da instância de <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="508" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryTakeFromAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0@,System.Int32,System.Threading.CancellationToken)">
          <source>The array of collections.</source>
          <target state="translated">A matriz de coleções.</target>       </trans-unit>
        <trans-unit id="509" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryTakeFromAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0@,System.Int32,System.Threading.CancellationToken)">
          <source>The item removed from one of the collections.</source>
          <target state="translated">O item removido de uma das coleções.</target>       </trans-unit>
        <trans-unit id="510" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryTakeFromAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0@,System.Int32,System.Threading.CancellationToken)">
          <source>The number of milliseconds to wait, or <ph id="ph1">&lt;see cref="F:System.Threading.Timeout.Infinite" /&gt;</ph> (-1) to wait indefinitely.</source>
          <target state="translated">O número de milissegundos para aguardar ou <ph id="ph1">&lt;see cref="F:System.Threading.Timeout.Infinite" /&gt;</ph> (- 1) para aguardar indefinidamente.</target>       </trans-unit>
        <trans-unit id="511" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryTakeFromAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0@,System.Int32,System.Threading.CancellationToken)">
          <source>A cancellation token to observe.</source>
          <target state="translated">Um token de cancelamento a ser observado.</target>       </trans-unit>
        <trans-unit id="512" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryTakeFromAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0@,System.Int32,System.Threading.CancellationToken)">
          <source>Tries to remove an item from any one of the specified <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> instances.</source>
          <target state="translated">Tenta remover um item de qualquer uma das instâncias <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> especificadas.</target>       </trans-unit>
        <trans-unit id="513" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryTakeFromAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0@,System.Int32,System.Threading.CancellationToken)">
          <source>The index of the collection in the <ph id="ph1">&lt;paramref name="collections" /&gt;</ph> array from which the item was removed, or -1 if an item could not be removed.</source>
          <target state="translated">O índice da coleção na matriz <ph id="ph1">&lt;paramref name="collections" /&gt;</ph> da qual o item foi removido ou -1 caso um item não possa ser removido.</target>       </trans-unit>
        <trans-unit id="514" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryTakeFromAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0@,System.Int32,System.Threading.CancellationToken)">
          <source>A call to TryTakeFromAny may block until an item is available to be removed.</source>
          <target state="translated">Uma chamada para TryTakeFromAny pode ser bloqueada até que um item esteja disponível para ser removido.</target>       </trans-unit>
        <trans-unit id="515" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryTakeFromAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0@,System.Int32,System.Threading.CancellationToken)">
          <source>If the <ph id="ph1">&lt;see cref="T:System.Threading.CancellationToken" /&gt;</ph> is canceled.</source>
          <target state="translated">Se o padrão <ph id="ph1">&lt;see cref="T:System.Threading.CancellationToken" /&gt;</ph> for cancelado.</target>       </trans-unit>
        <trans-unit id="516" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryTakeFromAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0@,System.Int32,System.Threading.CancellationToken)">
          <source>At least one of the underlying collections was modified outside of its <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> instance.</source>
          <target state="translated">Pelo menos uma das coleções subjacentes foi alterada fora da instância de <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="517" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryTakeFromAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0@,System.Int32,System.Threading.CancellationToken)">
          <source>The <ph id="ph1">&lt;paramref name="collections" /&gt;</ph> argument is null.</source>
          <target state="translated">O argumento <ph id="ph1">&lt;paramref name="collections" /&gt;</ph> é nulo.</target>       </trans-unit>
        <trans-unit id="518" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryTakeFromAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0@,System.Int32,System.Threading.CancellationToken)">
          <source><ph id="ph1">&lt;paramref name="millisecondsTimeout" /&gt;</ph> is a negative number other than -1, which represents an infinite time-out.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="millisecondsTimeout" /&gt;</ph> é um número negativo diferente de -1, que representa um tempo limite infinito.</target>       </trans-unit>
        <trans-unit id="519" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryTakeFromAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0@,System.Int32,System.Threading.CancellationToken)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="520" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryTakeFromAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0@,System.Int32,System.Threading.CancellationToken)">
          <source>The count of <ph id="ph1">&lt;paramref name="collections" /&gt;</ph> is greater than the maximum size of 62 for STA and 63 for MTA.</source>
          <target state="translated">A contagem de <ph id="ph1">&lt;paramref name="collections" /&gt;</ph> é maior que o tamanho máximo de 62 para STA e 63 para MTA.</target>       </trans-unit>
        <trans-unit id="521" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryTakeFromAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0@,System.Int32,System.Threading.CancellationToken)">
          <source>The <ph id="ph1">&lt;paramref name="collections" /&gt;</ph> argument is a 0-length array or contains a null element.</source>
          <target state="translated">O argumento <ph id="ph1">&lt;paramref name="collections" /&gt;</ph> é uma matriz de tamanho 0 ou contém um elemento nulo.</target>       </trans-unit>
        <trans-unit id="522" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryTakeFromAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0@,System.Int32,System.Threading.CancellationToken)">
          <source>At least one of the <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> instances has been disposed.</source>
          <target state="translated">Pelo menos uma das instâncias de <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> foi descartada.</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>