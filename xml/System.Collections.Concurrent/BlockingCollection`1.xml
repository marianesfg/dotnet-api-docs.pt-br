<Type Name="BlockingCollection&lt;T&gt;" FullName="System.Collections.Concurrent.BlockingCollection&lt;T&gt;">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="f6c936056ed99a71dfdd7760349d29df25a72390" />
    <Meta Name="ms.sourcegitcommit" Value="9e06b87bcfa4347dbbaaa4b3cc36b43b93b5badb" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="pt-BR" />
    <Meta Name="ms.lasthandoff" Value="11/20/2018" />
    <Meta Name="ms.locfileid" Value="52229904" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class BlockingCollection&lt;T&gt; : IDisposable, System.Collections.Generic.IEnumerable&lt;T&gt;, System.Collections.Generic.IReadOnlyCollection&lt;T&gt;, System.Collections.ICollection" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit BlockingCollection`1&lt;T&gt; extends System.Object implements class System.Collections.Generic.IEnumerable`1&lt;!T&gt;, class System.Collections.Generic.IReadOnlyCollection`1&lt;!T&gt;, class System.Collections.ICollection, class System.Collections.IEnumerable, class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.Collections.Concurrent.BlockingCollection`1" />
  <TypeSignature Language="VB.NET" Value="Public Class BlockingCollection(Of T)&#xA;Implements ICollection, IDisposable, IEnumerable(Of T), IReadOnlyCollection(Of T)" />
  <TypeSignature Language="C++ CLI" Value="generic &lt;typename T&gt;&#xA;public ref class BlockingCollection : IDisposable, System::Collections::Generic::IEnumerable&lt;T&gt;, System::Collections::Generic::IReadOnlyCollection&lt;T&gt;, System::Collections::ICollection" />
  <TypeSignature Language="F#" Value="type BlockingCollection&lt;'T&gt; = class&#xA;    interface seq&lt;'T&gt;&#xA;    interface ICollection&#xA;    interface IDisposable&#xA;    interface IReadOnlyCollection&lt;'T&gt;&#xA;    interface IEnumerable" />
  <AssemblyInfo>
    <AssemblyName>System.Collections.Concurrent</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.14.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <TypeParameters>
    <TypeParameter Name="T" />
  </TypeParameters>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Collections.Generic.IEnumerable&lt;T&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.Generic.IReadOnlyCollection&lt;T&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.ICollection</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.IEnumerable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Diagnostics.DebuggerDisplay("Count = {Count}, Type = {m_collection}")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Diagnostics.DebuggerTypeProxy(typeof(System.Collections.Concurrent.SystemThreadingCollections_BlockingCollectionDebugView`1))</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <typeparam name="T">O tipo dos elementos na coleção.</typeparam>
    <summary>Fornece funcionalidades de bloqueio e delimitação para coleções thread-safe que implementam <see cref="T:System.Collections.Concurrent.IProducerConsumerCollection`1" />.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.Concurrent.BlockingCollection%601> é uma classe de coleção thread-safe que fornece o seguinte:  
  
-   Uma implementação do padrão de produtor/consumidor; <xref:System.Collections.Concurrent.BlockingCollection%601> é um wrapper para o <xref:System.Collections.Concurrent.IProducerConsumerCollection%601> interface.  
  
-   Simultânea adição e remoção de itens de vários threads com o <xref:System.Collections.Concurrent.BlockingCollection%601.Add%2A> e <xref:System.Collections.Concurrent.BlockingCollection%601.Take%2A> métodos.  
  
-   Uma coleção associada que bloqueia <xref:System.Collections.Concurrent.BlockingCollection%601.Add%2A> e <xref:System.Collections.Concurrent.BlockingCollection%601.Take%2A> operações quando a coleção é full ou empty.  
  
-   Cancelamento da <xref:System.Collections.Concurrent.BlockingCollection%601.Add%2A> ou <xref:System.Collections.Concurrent.BlockingCollection%601.Take%2A> operações usando uma <xref:System.Threading.CancellationToken> objeto o <xref:System.Collections.Concurrent.BlockingCollection%601.TryAdd%2A> ou <xref:System.Collections.Concurrent.BlockingCollection%601.TryTake%2A> método.  
  
> [!IMPORTANT]
>  Esse tipo implementa o <xref:System.IDisposable> interface. Quando você terminar de usar o tipo, você deve descartá-lo diretamente ou indiretamente. Para descartar o tipo diretamente, chame seu <xref:System.IDisposable.Dispose%2A> método em um `try` / `catch` bloco. Para descartá-los indiretamente, usar uma construção de linguagem, como `using` (em c#) ou `Using` (no Visual Basic). Para obter mais informações, consulte a seção "Usando um objeto que implementa IDisposable" o <xref:System.IDisposable> tópico da interface. Além disso, observe que o <xref:System.Collections.Concurrent.BlockingCollection%601.Dispose> método não é thread-safe. Todos os outros membros públicos e protegidos de <xref:System.Collections.Concurrent.BlockingCollection%601> são thread-safe e podem ser usados simultaneamente de vários threads.  
  
 <xref:System.Collections.Concurrent.IProducerConsumerCollection%601> representa uma coleção que permite a adição de thread-safe e remoção de dados. <xref:System.Collections.Concurrent.BlockingCollection%601> é usado como um wrapper para um <xref:System.Collections.Concurrent.IProducerConsumerCollection%601> da instância e permite que as tentativas de remoção da coleção bloquear até que os dados estão disponíveis a ser removido. Da mesma forma, você pode criar uma <xref:System.Collections.Concurrent.BlockingCollection%601> para impor um limite superior no número de elementos de dados permitidos no <xref:System.Collections.Concurrent.IProducerConsumerCollection%601>; tentativas de adição à coleção, em seguida, podem bloquear até que haja espaço disponível para armazenar os itens adicionados. Dessa maneira <xref:System.Collections.Concurrent.BlockingCollection%601> é semelhante a uma estrutura de dados fila bloqueio tradicionais, exceto pelo fato do mecanismo de armazenamento de dados subjacente é abstraído como um <xref:System.Collections.Concurrent.IProducerConsumerCollection%601>.  
  
 <xref:System.Collections.Concurrent.BlockingCollection%601> dá suporte à delimitação e ao bloqueio. Delimitação significa que você pode definir a capacidade máxima da coleção. Delimitação é importante em determinados cenários, porque ele permite que você controle o tamanho máximo da coleção na memória e impede que os threads de produção se distanciem muito à frente dos threads de consumo. Várias tarefas ou threads podem adicionar itens à coleção simultaneamente, e se a coleção atingir sua capacidade máxima especificada, os threads de produção serão bloqueados até que um item é removido. Vários consumidores podem remover itens simultaneamente e, se a coleção ficar vazia, os threads de consumo serão bloqueados até que um produtor adicione um item. Um thread de produção pode chamar o <xref:System.Collections.Concurrent.BlockingCollection%601.CompleteAdding%2A> método para indicar que nenhum outro item será adicionado. Os consumidores monitoram a propriedade <xref:System.Collections.Concurrent.BlockingCollection%601.IsCompleted%2A> para saber quando a coleção está vazia e não serão adicionados mais itens.  
  
 <xref:System.Collections.Concurrent.BlockingCollection%601.Add%2A> e <xref:System.Collections.Concurrent.BlockingCollection%601.Take%2A> operações normalmente são executadas em um loop. Você pode cancelar um loop, passando um <xref:System.Threading.CancellationToken> do objeto para o <xref:System.Collections.Concurrent.BlockingCollection%601.TryAdd%2A> ou <xref:System.Collections.Concurrent.BlockingCollection%601.TryTake%2A> método e, em seguida, verificando o valor do token <xref:System.Threading.CancellationToken.IsCancellationRequested%2A> propriedade em cada iteração. Se o valor for `true`, cabe a você responder à solicitação de cancelamento limpando quaisquer recursos e saindo do loop.  
  
 Quando você cria um <xref:System.Collections.Concurrent.BlockingCollection%601> objeto, você pode especificar não apenas a capacidade limitada, mas também o tipo de coleção para usar. Por exemplo, seria possível especificar um objeto <xref:System.Collections.Concurrent.ConcurrentQueue%601> para o comportamento primeiro a entrar, primeiro a sair (PEPS) ou um objeto <xref:System.Collections.Concurrent.ConcurrentStack%601> para último a entrar, primeiro a sair (UEPS). Você pode usar qualquer classe de coleção que implemente a interface <xref:System.Collections.Concurrent.IProducerConsumerCollection%601>. O tipo de coleção padrão para <xref:System.Collections.Concurrent.BlockingCollection%601> é <xref:System.Collections.Concurrent.ConcurrentQueue%601>.  
  
 Não modifique diretamente a coleção subjacente. Use <xref:System.Collections.Concurrent.BlockingCollection%601> métodos para adicionar ou remover elementos. O <xref:System.Collections.Concurrent.BlockingCollection%601> objeto pode ser corrompido se você alterar a coleção subjacente diretamente.  
  
   
  
## Examples  
 O exemplo a seguir mostra como adicionar e remover itens simultaneamente de uma coleta de bloqueio:  
  
 [!code-csharp[System.Collections.Concurrent.BlockingCollection#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.collections.concurrent.blockingcollection/cs/blockingcoll.cs#1)]
 [!code-vb[System.Collections.Concurrent.BlockingCollection#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.collections.concurrent.blockingcollection/vb/blockingcoll.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe>O método Dispose não é thread-safe. Todos os outros membros públicos e protegidos de <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> são thread-safe e podem ser usados simultaneamente de vários threads.</threadsafe>
    <related type="Article" href="https://msdn.microsoft.com/library/2e7ca21f-786c-4367-96be-0cf3f3dcc6bd">Coleções thread-safe</related>
    <related type="Article" href="https://msdn.microsoft.com/library/987ea3d7-0ad5-4238-8b64-331ce4eb3f0b">Visão geral de BlockingCollection</related>
    <related type="Article" href="https://msdn.microsoft.com/library/4c2492de-3876-4873-b5a1-000bb404d770">Como: Adicionar delimitação e bloqueio a funcionalidade de uma classe de coleção</related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicializa uma nova instância da classe <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> sem um limite superior.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public BlockingCollection ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Concurrent.BlockingCollection`1.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; BlockingCollection();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inicializa uma nova instância da classe <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> sem um limite superior.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O padrão subjacente de coleção é um <xref:System.Collections.Concurrent.ConcurrentQueue%601> objeto, que fornece pela primeira vez no comportamento primeiro a sair (PEPS).  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/2e7ca21f-786c-4367-96be-0cf3f3dcc6bd">Coleções thread-safe</related>
        <related type="Article" href="https://msdn.microsoft.com/library/987ea3d7-0ad5-4238-8b64-331ce4eb3f0b">Visão geral de BlockingCollection</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public BlockingCollection (System.Collections.Concurrent.IProducerConsumerCollection&lt;T&gt; collection);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Collections.Concurrent.IProducerConsumerCollection`1&lt;!T&gt; collection) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Concurrent.BlockingCollection`1.#ctor(System.Collections.Concurrent.IProducerConsumerCollection{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (collection As IProducerConsumerCollection(Of T))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; BlockingCollection(System::Collections::Concurrent::IProducerConsumerCollection&lt;T&gt; ^ collection);" />
      <MemberSignature Language="F#" Value="new System.Collections.Concurrent.BlockingCollection&lt;'T&gt; : System.Collections.Concurrent.IProducerConsumerCollection&lt;'T&gt; -&gt; System.Collections.Concurrent.BlockingCollection&lt;'T&gt;" Usage="new System.Collections.Concurrent.BlockingCollection&lt;'T&gt; collection" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="collection" Type="System.Collections.Concurrent.IProducerConsumerCollection&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="collection">A coleção a ser usada como armazenamento de dados subjacente.</param>
        <summary>Inicializa uma nova instância da classe <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> sem um limite superior e usando a <see cref="T:System.Collections.Concurrent.IProducerConsumerCollection`1" /> fornecida como seu armazenamento de dados subjacente.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">O argumento <paramref name="collection" /> é nulo.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/2e7ca21f-786c-4367-96be-0cf3f3dcc6bd">Coleções thread-safe</related>
        <related type="Article" href="https://msdn.microsoft.com/library/987ea3d7-0ad5-4238-8b64-331ce4eb3f0b">Visão geral de BlockingCollection</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public BlockingCollection (int boundedCapacity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 boundedCapacity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Concurrent.BlockingCollection`1.#ctor(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (boundedCapacity As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; BlockingCollection(int boundedCapacity);" />
      <MemberSignature Language="F#" Value="new System.Collections.Concurrent.BlockingCollection&lt;'T&gt; : int -&gt; System.Collections.Concurrent.BlockingCollection&lt;'T&gt;" Usage="new System.Collections.Concurrent.BlockingCollection&lt;'T&gt; boundedCapacity" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="boundedCapacity" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="boundedCapacity">O tamanho limitado da coleção.</param>
        <summary>Inicializa uma nova instância da classe <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> com o limite superior especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O padrão subjacente de coleção é um <xref:System.Collections.Concurrent.ConcurrentQueue%601>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">O <paramref name="boundedCapacity" /> não é um valor positivo.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/2e7ca21f-786c-4367-96be-0cf3f3dcc6bd">Coleções thread-safe</related>
        <related type="Article" href="https://msdn.microsoft.com/library/987ea3d7-0ad5-4238-8b64-331ce4eb3f0b">Visão geral de BlockingCollection</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public BlockingCollection (System.Collections.Concurrent.IProducerConsumerCollection&lt;T&gt; collection, int boundedCapacity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Collections.Concurrent.IProducerConsumerCollection`1&lt;!T&gt; collection, int32 boundedCapacity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Concurrent.BlockingCollection`1.#ctor(System.Collections.Concurrent.IProducerConsumerCollection{`0},System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (collection As IProducerConsumerCollection(Of T), boundedCapacity As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; BlockingCollection(System::Collections::Concurrent::IProducerConsumerCollection&lt;T&gt; ^ collection, int boundedCapacity);" />
      <MemberSignature Language="F#" Value="new System.Collections.Concurrent.BlockingCollection&lt;'T&gt; : System.Collections.Concurrent.IProducerConsumerCollection&lt;'T&gt; * int -&gt; System.Collections.Concurrent.BlockingCollection&lt;'T&gt;" Usage="new System.Collections.Concurrent.BlockingCollection&lt;'T&gt; (collection, boundedCapacity)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="collection" Type="System.Collections.Concurrent.IProducerConsumerCollection&lt;T&gt;" />
        <Parameter Name="boundedCapacity" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="collection">A coleção a ser usada como armazenamento de dados subjacente.</param>
        <param name="boundedCapacity">O tamanho limitado da coleção.</param>
        <summary>Inicializa uma nova instância da classe <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> com o limite superior especificado e usando a <see cref="T:System.Collections.Concurrent.IProducerConsumerCollection`1" /> fornecida como seu repositório de dados subjacente.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">O argumento <paramref name="collection" /> é nulo.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">O <paramref name="boundedCapacity" /> não é um valor positivo.</exception>
        <exception cref="T:System.ArgumentException">A <paramref name="collection" /> fornecida contém mais valores que o permitido pela <paramref name="boundedCapacity" />.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/2e7ca21f-786c-4367-96be-0cf3f3dcc6bd">Coleções thread-safe</related>
        <related type="Article" href="https://msdn.microsoft.com/library/987ea3d7-0ad5-4238-8b64-331ce4eb3f0b">Visão geral de BlockingCollection</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Add">
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Adiciona o item ao <see cref="T:System.Collections.Concurrent.BlockingCollection`1" />.</summary>
        <related type="Article" href="https://msdn.microsoft.com/library/2e7ca21f-786c-4367-96be-0cf3f3dcc6bd">Coleções thread-safe</related>
        <related type="Article" href="https://msdn.microsoft.com/library/987ea3d7-0ad5-4238-8b64-331ce4eb3f0b">Visão geral de BlockingCollection</related>
      </Docs>
    </MemberGroup>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public void Add (T item);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Add(!T item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Concurrent.BlockingCollection`1.Add(`0)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Add (item As T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Add(T item);" />
      <MemberSignature Language="F#" Value="member this.Add : 'T -&gt; unit" Usage="blockingCollection.Add item" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="T" />
      </Parameters>
      <Docs>
        <param name="item">O item a ser adicionado à coleção. O valor pode ser uma referência nula.</param>
        <summary>Adiciona o item ao <see cref="T:System.Collections.Concurrent.BlockingCollection`1" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se uma capacidade limitada foi especificada quando esta instância de <xref:System.Collections.Concurrent.BlockingCollection%601> foi inicializado, uma chamada para adicionar pode bloquear até que haja espaço disponível para armazenar o item fornecido.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">O <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> foi descartado.</exception>
        <exception cref="T:System.InvalidOperationException">O <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> foi marcado como concluído com relação a adições.  
  
- ou - 
A coleção subjacente não aceitou o item.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/2e7ca21f-786c-4367-96be-0cf3f3dcc6bd">Coleções thread-safe</related>
        <related type="Article" href="https://msdn.microsoft.com/library/987ea3d7-0ad5-4238-8b64-331ce4eb3f0b">Visão geral de BlockingCollection</related>
      </Docs>
    </Member>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public void Add (T item, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Add(!T item, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Concurrent.BlockingCollection`1.Add(`0,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Add(T item, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="member this.Add : 'T * System.Threading.CancellationToken -&gt; unit" Usage="blockingCollection.Add (item, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="T" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="item">O item a ser adicionado à coleção. O valor pode ser uma referência nula.</param>
        <param name="cancellationToken">Um token de cancelamento a ser observado.</param>
        <summary>Adiciona o item ao <see cref="T:System.Collections.Concurrent.BlockingCollection`1" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se uma capacidade limitada foi especificada quando esta instância do <xref:System.Collections.Concurrent.BlockingCollection%601> foi inicializado, uma chamada para <xref:System.Collections.Concurrent.BlockingCollection%601.Add%2A> podem bloquear até que haja espaço disponível para armazenar o item fornecido.  
  
 Esse método pode retornar no início com um <xref:System.OperationCanceledException> se o `cancellationToken` é cancelada.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OperationCanceledException">Se o padrão <see cref="T:System.Threading.CancellationToken" /> for cancelado.</exception>
        <exception cref="T:System.ObjectDisposedException">O <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> foi descartado ou o <see cref="T:System.Threading.CancellationTokenSource" /> que possui o <paramref name="cancellationToken" /> foi descartado.</exception>
        <exception cref="T:System.InvalidOperationException">O <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> foi marcado como concluído com relação a adições.  
  
- ou - 
A coleção subjacente não aceitou o item.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/2e7ca21f-786c-4367-96be-0cf3f3dcc6bd">Coleções thread-safe</related>
        <related type="Article" href="https://msdn.microsoft.com/library/987ea3d7-0ad5-4238-8b64-331ce4eb3f0b">Visão geral de BlockingCollection</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="AddToAny">
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Adiciona o item especificado a qualquer uma das instâncias de <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> especificadas.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AddToAny">
      <MemberSignature Language="C#" Value="public static int AddToAny (System.Collections.Concurrent.BlockingCollection&lt;T&gt;[] collections, T item);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 AddToAny(class System.Collections.Concurrent.BlockingCollection`1&lt;!T&gt;[] collections, !T item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Concurrent.BlockingCollection`1.AddToAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function AddToAny (collections As BlockingCollection(Of T)(), item As T) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int AddToAny(cli::array &lt;System::Collections::Concurrent::BlockingCollection&lt;T&gt; ^&gt; ^ collections, T item);" />
      <MemberSignature Language="F#" Value="static member AddToAny : System.Collections.Concurrent.BlockingCollection&lt;'T&gt;[] * 'T -&gt; int" Usage="System.Collections.Concurrent.BlockingCollection&lt;'T&gt;.AddToAny (collections, item)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="collections" Type="System.Collections.Concurrent.BlockingCollection&lt;T&gt;[]" />
        <Parameter Name="item" Type="T" />
      </Parameters>
      <Docs>
        <param name="collections">A matriz de coleções.</param>
        <param name="item">O item a ser adicionado a uma das coleções.</param>
        <summary>Adiciona o item especificado a qualquer uma das instâncias de <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> especificadas.</summary>
        <returns>O índice da coleção na matriz <paramref name="collections" /> na qual o item foi adicionado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se uma capacidade limitada foi especificada quando todas as <xref:System.Collections.Concurrent.BlockingCollection%601> instâncias foram inicializadas, uma chamada para AddToAny pode bloquear até que haja espaço disponível em uma das coleções para armazenar o item fornecido.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Pelo menos uma das instâncias de <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> foi descartada.</exception>
        <exception cref="T:System.ArgumentNullException">O argumento <paramref name="collections" /> é nulo.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">A contagem de <paramref name="collections" /> é maior que o tamanho máximo de 62 para STA e 63 para MTA.</exception>
        <exception cref="T:System.ArgumentException">O argumento <paramref name="collections" /> é uma matriz de tamanho 0 ou contém um elemento nulo, ou pelo menos uma das coleções foi marcada como completa para adição.</exception>
        <exception cref="T:System.InvalidOperationException">Pelo menos uma coleção subjacente não aceitou o item.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/2e7ca21f-786c-4367-96be-0cf3f3dcc6bd">Coleções thread-safe</related>
        <related type="Article" href="https://msdn.microsoft.com/library/987ea3d7-0ad5-4238-8b64-331ce4eb3f0b">Visão geral de BlockingCollection</related>
      </Docs>
    </Member>
    <Member MemberName="AddToAny">
      <MemberSignature Language="C#" Value="public static int AddToAny (System.Collections.Concurrent.BlockingCollection&lt;T&gt;[] collections, T item, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 AddToAny(class System.Collections.Concurrent.BlockingCollection`1&lt;!T&gt;[] collections, !T item, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Concurrent.BlockingCollection`1.AddToAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int AddToAny(cli::array &lt;System::Collections::Concurrent::BlockingCollection&lt;T&gt; ^&gt; ^ collections, T item, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="static member AddToAny : System.Collections.Concurrent.BlockingCollection&lt;'T&gt;[] * 'T * System.Threading.CancellationToken -&gt; int" Usage="System.Collections.Concurrent.BlockingCollection&lt;'T&gt;.AddToAny (collections, item, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="collections" Type="System.Collections.Concurrent.BlockingCollection&lt;T&gt;[]" />
        <Parameter Name="item" Type="T" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="collections">A matriz de coleções.</param>
        <param name="item">O item a ser adicionado a uma das coleções.</param>
        <param name="cancellationToken">Um token de cancelamento a ser observado.</param>
        <summary>Adiciona o item especificado a qualquer uma das instâncias de <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> especificadas.</summary>
        <returns>O índice da coleção na matriz <paramref name="collections" /> na qual o item foi adicionado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se uma capacidade limitada foi especificada quando todas as <xref:System.Collections.Concurrent.BlockingCollection%601> instâncias foram inicializadas, uma chamada para AddToAny pode bloquear até que haja espaço disponível em uma das coleções para armazenar o item fornecido. Esse método pode retornar antes do item é adicionado a qualquer coleção se o `cancellationToken` for cancelado antes que o espaço está disponível.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OperationCanceledException">Se o padrão <see cref="T:System.Threading.CancellationToken" /> for cancelado.</exception>
        <exception cref="T:System.InvalidOperationException">Pelo menos uma coleção subjacente não aceitou o item.</exception>
        <exception cref="T:System.ArgumentNullException">O argumento <paramref name="collections" /> é nulo.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">A contagem de <paramref name="collections" /> é maior que o tamanho máximo de 62 para STA e 63 para MTA.</exception>
        <exception cref="T:System.ArgumentException">O argumento <paramref name="collections" /> é uma matriz de tamanho 0 ou contém um elemento nulo, ou pelo menos uma das coleções foi marcada como completa para adição.</exception>
        <exception cref="T:System.ObjectDisposedException">Pelo menos uma das instâncias de <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> foi descartada ou o <see cref="T:System.Threading.CancellationTokenSource" /> que criou <paramref name="cancellationToken" /> foi descartado.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/2e7ca21f-786c-4367-96be-0cf3f3dcc6bd">Coleções thread-safe</related>
        <related type="Article" href="https://msdn.microsoft.com/library/987ea3d7-0ad5-4238-8b64-331ce4eb3f0b">Visão geral de BlockingCollection</related>
      </Docs>
    </Member>
    <Member MemberName="BoundedCapacity">
      <MemberSignature Language="C#" Value="public int BoundedCapacity { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 BoundedCapacity" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Concurrent.BlockingCollection`1.BoundedCapacity" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property BoundedCapacity As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int BoundedCapacity { int get(); };" />
      <MemberSignature Language="F#" Value="member this.BoundedCapacity : int" Usage="System.Collections.Concurrent.BlockingCollection&lt;'T&gt;.BoundedCapacity" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém a capacidade limitada dessa instância <see cref="T:System.Collections.Concurrent.BlockingCollection`1" />.</summary>
        <value>A capacidade limitada dessa coleção ou int.MaxValue, se nenhum limite tiver sido fornecido.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException">O <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> foi descartado.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/2e7ca21f-786c-4367-96be-0cf3f3dcc6bd">Coleções thread-safe</related>
        <related type="Article" href="https://msdn.microsoft.com/library/987ea3d7-0ad5-4238-8b64-331ce4eb3f0b">Visão geral de BlockingCollection</related>
      </Docs>
    </Member>
    <Member MemberName="CompleteAdding">
      <MemberSignature Language="C#" Value="public void CompleteAdding ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CompleteAdding() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Concurrent.BlockingCollection`1.CompleteAdding" />
      <MemberSignature Language="VB.NET" Value="Public Sub CompleteAdding ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CompleteAdding();" />
      <MemberSignature Language="F#" Value="member this.CompleteAdding : unit -&gt; unit" Usage="blockingCollection.CompleteAdding " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Marca que as instâncias de <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> não estão mais aceitando nenhuma adição.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Depois que uma coleção foi marcada como completa para adição, não é permitido adicionar à coleção e tenta remover da coleção não aguardará quando a coleção está vazia.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">O <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> foi descartado.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/2e7ca21f-786c-4367-96be-0cf3f3dcc6bd">Coleções thread-safe</related>
        <related type="Article" href="https://msdn.microsoft.com/library/987ea3d7-0ad5-4238-8b64-331ce4eb3f0b">Visão geral de BlockingCollection</related>
      </Docs>
    </Member>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public void CopyTo (T[] array, int index);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CopyTo(!T[] array, int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Concurrent.BlockingCollection`1.CopyTo(`0[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub CopyTo (array As T(), index As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CopyTo(cli::array &lt;T&gt; ^ array, int index);" />
      <MemberSignature Language="F#" Value="member this.CopyTo : 'T[] * int -&gt; unit" Usage="blockingCollection.CopyTo (array, index)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">A matriz unidimensional que é o destino dos elementos copiados da instância <see cref="T:System.Collections.Concurrent.BlockingCollection`1" />. A matriz deve ter indexação com base em zero.</param>
        <param name="index">O índice com base em zero em <paramref name="array" /> no qual a cópia começa.</param>
        <summary>Copia todos os itens da instância <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> para uma matriz unidimensional compatível, iniciando no índice especificado da matriz de destino.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 CopyTo representa um instantâneo da coleção em um ponto preciso no tempo. Se outros threads são adicionando ou removendo itens durante a execução de CopyTo, os elementos retornados por CopyTo podem não representar o estado da coleção.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">O <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> foi descartado.</exception>
        <exception cref="T:System.ArgumentNullException">O argumento <paramref name="array" /> é nulo.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">O argumento <paramref name="index" /> é menor que zero.</exception>
        <exception cref="T:System.ArgumentException">O argumento <paramref name="index" /> é igual ou maior que o comprimento da <paramref name="array" />.  
  
A matriz de destino é muito pequena para conter todos os elementos de BlockingCcollection.  
  
A classificação da matriz não corresponde.  
  
O tipo de matriz é incompatível com o tipo dos elementos de BlockingCollection.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/2e7ca21f-786c-4367-96be-0cf3f3dcc6bd">Coleções thread-safe</related>
        <related type="Article" href="https://msdn.microsoft.com/library/987ea3d7-0ad5-4238-8b64-331ce4eb3f0b">Visão geral de BlockingCollection</related>
      </Docs>
    </Member>
    <Member MemberName="Count">
      <MemberSignature Language="C#" Value="public int Count { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Count" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Concurrent.BlockingCollection`1.Count" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Count As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Count { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Count : int" Usage="System.Collections.Concurrent.BlockingCollection&lt;'T&gt;.Count" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.Count</InterfaceMember>
        <InterfaceMember>P:System.Collections.Generic.IReadOnlyCollection`1.Count</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém o número de itens contidos no <see cref="T:System.Collections.Concurrent.BlockingCollection`1" />.</summary>
        <value>O número de itens contidos no <see cref="T:System.Collections.Concurrent.BlockingCollection`1" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se qualquer método de BlockingCollection está em execução enquanto a propriedade Count está sendo accessd, o valor de retorno é aproximado. Contagem pode refletir um número que seja maior ou menor que o número real de itens da BlockingCollection.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">O <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> foi descartado.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/2e7ca21f-786c-4367-96be-0cf3f3dcc6bd">Coleções thread-safe</related>
        <related type="Article" href="https://msdn.microsoft.com/library/987ea3d7-0ad5-4238-8b64-331ce4eb3f0b">Visão geral de BlockingCollection</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Dispose">
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Libera todos os recursos usados pela instância atual da classe <see cref="T:System.Collections.Concurrent.BlockingCollection`1" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Concurrent.BlockingCollection`1.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberSignature Language="F#" Value="abstract member Dispose : unit -&gt; unit&#xA;override this.Dispose : unit -&gt; unit" Usage="blockingCollection.Dispose " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Libera todos os recursos usados pela instância atual da classe <see cref="T:System.Collections.Concurrent.BlockingCollection`1" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O `Dispose` método não é thread-safe.  
  
 Chame `Dispose` quando tiver terminado de usar o <xref:System.Collections.Concurrent.BlockingCollection%601>. O `Dispose` método deixa o <xref:System.Collections.Concurrent.BlockingCollection%601> em um estado inutilizável. Depois de chamar `Dispose`, você deve liberar todas as referências para o <xref:System.Collections.Concurrent.BlockingCollection%601> para que o coletor de lixo possa recuperar a memória que o <xref:System.Collections.Concurrent.BlockingCollection%601> estava ocupando.  
  
 Para obter mais informações, consulte [limpeza de recursos não gerenciados](~/docs/standard/garbage-collection/unmanaged.md) e [implementando um método Dispose](~/docs/standard/garbage-collection/implementing-dispose.md).  
  
> [!NOTE]
>  Sempre chamar `Dispose` antes de liberar sua última referência para o <xref:System.Collections.Concurrent.BlockingCollection%601>. Caso contrário, os recursos que ele está usando não serão liberados até que o coletor de lixo chame o <xref:System.Collections.Concurrent.BlockingCollection%601> do objeto `Finalize` método.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/2e7ca21f-786c-4367-96be-0cf3f3dcc6bd">Coleções thread-safe</related>
        <related type="Article" href="https://msdn.microsoft.com/library/987ea3d7-0ad5-4238-8b64-331ce4eb3f0b">Visão geral de BlockingCollection</related>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected virtual void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Concurrent.BlockingCollection`1.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void Dispose(bool disposing);" />
      <MemberSignature Language="F#" Value="abstract member Dispose : bool -&gt; unit&#xA;override this.Dispose : bool -&gt; unit" Usage="blockingCollection.Dispose disposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">Se está sendo descartado explicitamente (true) ou devido a um finalizador (false).</param>
        <summary>Libera os recursos usados pela instância <see cref="T:System.Collections.Concurrent.BlockingCollection`1" />.</summary>
        <remarks>To be added.</remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/2e7ca21f-786c-4367-96be-0cf3f3dcc6bd">Coleções thread-safe</related>
        <related type="Article" href="https://msdn.microsoft.com/library/987ea3d7-0ad5-4238-8b64-331ce4eb3f0b">Visão geral de BlockingCollection</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetConsumingEnumerable">
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Fornece um consumindo <see cref="T:System.Collections.Generic.IEnumerator`1" /> para itens na coleção.</summary>
        <related type="Article" href="https://msdn.microsoft.com/library/2e7ca21f-786c-4367-96be-0cf3f3dcc6bd">Coleções thread-safe</related>
        <related type="Article" href="https://msdn.microsoft.com/library/987ea3d7-0ad5-4238-8b64-331ce4eb3f0b">Visão geral de BlockingCollection</related>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetConsumingEnumerable">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;T&gt; GetConsumingEnumerable ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.IEnumerable`1&lt;!T&gt; GetConsumingEnumerable() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Concurrent.BlockingCollection`1.GetConsumingEnumerable" />
      <MemberSignature Language="VB.NET" Value="Public Function GetConsumingEnumerable () As IEnumerable(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::IEnumerable&lt;T&gt; ^ GetConsumingEnumerable();" />
      <MemberSignature Language="F#" Value="member this.GetConsumingEnumerable : unit -&gt; seq&lt;'T&gt;" Usage="blockingCollection.GetConsumingEnumerable " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;T&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Fornece um consumindo <see cref="T:System.Collections.Generic.IEnumerator`1" /> para itens na coleção.</summary>
        <returns>Um <see cref="T:System.Collections.Generic.IEnumerable`1" /> que remove e retorna os itens da coleção.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O exemplo a seguir mostra como usar o <xref:System.Collections.Concurrent.BlockingCollection%601.GetConsumingEnumerable%2A> método:  
  
 [!code-csharp[System.Collections.Concurrent.BlockingCollection#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.collections.concurrent.blockingcollection/cs/blockingcoll.cs#4)]
 [!code-vb[System.Collections.Concurrent.BlockingCollection#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.collections.concurrent.blockingcollection/vb/blockingcoll.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">O <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> foi descartado.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/2e7ca21f-786c-4367-96be-0cf3f3dcc6bd">Coleções thread-safe</related>
        <related type="Article" href="https://msdn.microsoft.com/library/987ea3d7-0ad5-4238-8b64-331ce4eb3f0b">Visão geral de BlockingCollection</related>
      </Docs>
    </Member>
    <Member MemberName="GetConsumingEnumerable">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;T&gt; GetConsumingEnumerable (System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.IEnumerable`1&lt;!T&gt; GetConsumingEnumerable(valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Concurrent.BlockingCollection`1.GetConsumingEnumerable(System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::IEnumerable&lt;T&gt; ^ GetConsumingEnumerable(System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="member this.GetConsumingEnumerable : System.Threading.CancellationToken -&gt; seq&lt;'T&gt;" Usage="blockingCollection.GetConsumingEnumerable cancellationToken" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.6">
          <AttributeName>System.Runtime.CompilerServices.IteratorStateMachine(typeof(System.Collections.Concurrent.BlockingCollection`1/&lt;GetConsumingEnumerable&gt;d__2))</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Runtime.CompilerServices.IteratorStateMachine(typeof(System.Collections.Concurrent.BlockingCollection`1/&lt;GetConsumingEnumerable&gt;d__68))</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;T&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="cancellationToken">Um token de cancelamento a ser observado.</param>
        <summary>Fornece um consumindo <see cref="T:System.Collections.Generic.IEnumerable`1" /> para itens na coleção.</summary>
        <returns>Um <see cref="T:System.Collections.Generic.IEnumerable`1" /> que remove e retorna os itens da coleção.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método permite que o código de cliente remover itens da coleção, usando um loop foreach (cada em Visual Basic), ou <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> ou uma consulta PLINQ. O enumerador continuará a fornecer itens (se houver) até <xref:System.Collections.Concurrent.BlockingCollection%601.IsCompleted%2A> retorna true e se <xref:System.Collections.Concurrent.BlockingCollection%601.IsCompleted%2A> é false bloqueia o loop até que um item se torna disponível ou até o <xref:System.Threading.CancellationToken> é cancelada.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OperationCanceledException">Se o padrão <see cref="T:System.Threading.CancellationToken" /> for cancelado.</exception>
        <exception cref="T:System.ObjectDisposedException">O <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> foi descartado ou o <see cref="T:System.Threading.CancellationTokenSource" /> que criou o <paramref name="cancellationToken" /> foi descartado</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/2e7ca21f-786c-4367-96be-0cf3f3dcc6bd">Coleções thread-safe</related>
        <related type="Article" href="https://msdn.microsoft.com/library/987ea3d7-0ad5-4238-8b64-331ce4eb3f0b">Visão geral de BlockingCollection</related>
      </Docs>
    </Member>
    <Member MemberName="IsAddingCompleted">
      <MemberSignature Language="C#" Value="public bool IsAddingCompleted { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsAddingCompleted" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Concurrent.BlockingCollection`1.IsAddingCompleted" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsAddingCompleted As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsAddingCompleted { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsAddingCompleted : bool" Usage="System.Collections.Concurrent.BlockingCollection&lt;'T&gt;.IsAddingCompleted" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém se esta <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> foi marcada como completa para adição.</summary>
        <value>Se esta coleção foi marcada como completa para adição.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException">O <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> foi descartado.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/2e7ca21f-786c-4367-96be-0cf3f3dcc6bd">Coleções thread-safe</related>
        <related type="Article" href="https://msdn.microsoft.com/library/987ea3d7-0ad5-4238-8b64-331ce4eb3f0b">Visão geral de BlockingCollection</related>
      </Docs>
    </Member>
    <Member MemberName="IsCompleted">
      <MemberSignature Language="C#" Value="public bool IsCompleted { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsCompleted" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Concurrent.BlockingCollection`1.IsCompleted" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsCompleted As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsCompleted { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsCompleted : bool" Usage="System.Collections.Concurrent.BlockingCollection&lt;'T&gt;.IsCompleted" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém se esta <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> foi marcada como completa para a adição e está vazia.</summary>
        <value>Se esta coleção foi marcada como completa para a adição e está vazia.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException">O <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> foi descartado.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/2e7ca21f-786c-4367-96be-0cf3f3dcc6bd">Coleções thread-safe</related>
        <related type="Article" href="https://msdn.microsoft.com/library/987ea3d7-0ad5-4238-8b64-331ce4eb3f0b">Visão geral de BlockingCollection</related>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.IEnumerable&lt;T&gt;.GetEnumerator">
      <MemberSignature Language="C#" Value="System.Collections.Generic.IEnumerator&lt;T&gt; IEnumerable&lt;T&gt;.GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.Generic.IEnumerator`1&lt;!T&gt; System.Collections.Generic.IEnumerable&lt;T&gt;.GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Concurrent.BlockingCollection`1.System#Collections#Generic#IEnumerable&lt;T&gt;#GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Function GetEnumerator () As IEnumerator(Of T) Implements IEnumerable(Of T).GetEnumerator" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::Generic::IEnumerator&lt;T&gt; ^ System.Collections.Generic.IEnumerable&lt;T&gt;.GetEnumerator() = System::Collections::Generic::IEnumerable&lt;T&gt;::GetEnumerator;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.IEnumerable`1.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerator&lt;T&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Fornece um <see cref="T:System.Collections.Generic.IEnumerator`1" /> para itens na coleção.</summary>
        <returns>Um <see cref="T:System.Collections.Generic.IEnumerator`1" /> para os itens na coleção.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diferentemente <xref:System.Collections.Concurrent.BlockingCollection%601.GetConsumingEnumerable%2A>, <xref:System.Collections.Concurrent.BlockingCollection%601.System%23Collections%23Generic%23IEnumerable%7BT%7D%23GetEnumerator%2A?displayProperty=nameWithType> retorna um enumerador padrão que não modifica a coleção subjacente. Se outros threads são adicionando ou removendo elementos simultaneamente quando GetEnumerator é chamado, os elementos retornados pelo enumerador poderá não representar o estado atual da coleção.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">O <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> foi descartado.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/2e7ca21f-786c-4367-96be-0cf3f3dcc6bd">Coleções thread-safe</related>
        <related type="Article" href="https://msdn.microsoft.com/library/987ea3d7-0ad5-4238-8b64-331ce4eb3f0b">Visão geral de BlockingCollection</related>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.ICollection.CopyTo">
      <MemberSignature Language="C#" Value="void ICollection.CopyTo (Array array, int index);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Collections.ICollection.CopyTo(class System.Array array, int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Concurrent.BlockingCollection`1.System#Collections#ICollection#CopyTo(System.Array,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Collections.ICollection.CopyTo(Array ^ array, int index) = System::Collections::ICollection::CopyTo;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.ICollection.CopyTo(System.Array,System.Int32)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">A matriz unidimensional que é o destino dos elementos copiados da instância <see cref="T:System.Collections.Concurrent.BlockingCollection`1" />. A matriz deve ter indexação com base em zero.</param>
        <param name="index">O índice com base em zero em <paramref name="array" /> no qual a cópia começa.</param>
        <summary>Copia todos os itens da instância <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> para uma matriz unidimensional compatível, iniciando no índice especificado da matriz de destino.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException">O <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> foi descartado.</exception>
        <exception cref="T:System.ArgumentNullException">O argumento <paramref name="array" /> é nulo.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">O argumento <paramref name="index" /> é menor que zero.</exception>
        <exception cref="T:System.ArgumentException">O argumento <paramref name="index" /> é igual ou maior que o comprimento da <paramref name="array" />, a matriz é multidimensional ou o parâmetro de tipo para a coleção não pode ser convertido automaticamente no tipo da matriz de destino.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/2e7ca21f-786c-4367-96be-0cf3f3dcc6bd">Coleções thread-safe</related>
        <related type="Article" href="https://msdn.microsoft.com/library/987ea3d7-0ad5-4238-8b64-331ce4eb3f0b">Visão geral de BlockingCollection</related>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.ICollection.IsSynchronized">
      <MemberSignature Language="C#" Value="bool System.Collections.ICollection.IsSynchronized { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Collections.ICollection.IsSynchronized" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Concurrent.BlockingCollection`1.System#Collections#ICollection#IsSynchronized" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsSynchronized As Boolean Implements ICollection.IsSynchronized" />
      <MemberSignature Language="C++ CLI" Value="property bool System::Collections::ICollection::IsSynchronized { bool get(); };" />
      <MemberSignature Language="F#" Usage="System.Collections.ICollection.IsSynchronized" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.IsSynchronized</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém um valor que indica se o acesso à <see cref="T:System.Collections.ICollection" /> é sincronizado.</summary>
        <value>sempre retorna false.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException">O <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> foi descartado.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/2e7ca21f-786c-4367-96be-0cf3f3dcc6bd">Coleções thread-safe</related>
        <related type="Article" href="https://msdn.microsoft.com/library/987ea3d7-0ad5-4238-8b64-331ce4eb3f0b">Visão geral de BlockingCollection</related>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.ICollection.SyncRoot">
      <MemberSignature Language="C#" Value="object System.Collections.ICollection.SyncRoot { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object System.Collections.ICollection.SyncRoot" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Concurrent.BlockingCollection`1.System#Collections#ICollection#SyncRoot" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property SyncRoot As Object Implements ICollection.SyncRoot" />
      <MemberSignature Language="C++ CLI" Value="property System::Object ^ System::Collections::ICollection::SyncRoot { System::Object ^ get(); };" />
      <MemberSignature Language="F#" Usage="System.Collections.ICollection.SyncRoot" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.SyncRoot</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém um objeto que pode ser usado para sincronizar o acesso ao <see cref="T:System.Collections.ICollection" />. Não há suporte a esta propriedade.</summary>
        <value>Retorna null.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NotSupportedException">Não há suporte para a propriedade SyncRoot.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/2e7ca21f-786c-4367-96be-0cf3f3dcc6bd">Coleções thread-safe</related>
        <related type="Article" href="https://msdn.microsoft.com/library/987ea3d7-0ad5-4238-8b64-331ce4eb3f0b">Visão geral de BlockingCollection</related>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IEnumerable.GetEnumerator">
      <MemberSignature Language="C#" Value="System.Collections.IEnumerator IEnumerable.GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Concurrent.BlockingCollection`1.System#Collections#IEnumerable#GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Function GetEnumerator () As IEnumerator Implements IEnumerable.GetEnumerator" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::IEnumerator ^ System.Collections.IEnumerable.GetEnumerator() = System::Collections::IEnumerable::GetEnumerator;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IEnumerable.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Fornece um <see cref="T:System.Collections.IEnumerator" /> para itens na coleção.</summary>
        <returns>Um <see cref="T:System.Collections.IEnumerator" /> para os itens na coleção.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException">O <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> foi descartado.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/2e7ca21f-786c-4367-96be-0cf3f3dcc6bd">Coleções thread-safe</related>
        <related type="Article" href="https://msdn.microsoft.com/library/987ea3d7-0ad5-4238-8b64-331ce4eb3f0b">Visão geral de BlockingCollection</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Take">
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Remove um item do <see cref="T:System.Collections.Concurrent.BlockingCollection`1" />.</summary>
        <related type="Article" href="https://msdn.microsoft.com/library/2e7ca21f-786c-4367-96be-0cf3f3dcc6bd">Coleções thread-safe</related>
        <related type="Article" href="https://msdn.microsoft.com/library/987ea3d7-0ad5-4238-8b64-331ce4eb3f0b">Visão geral de BlockingCollection</related>
      </Docs>
    </MemberGroup>
    <Member MemberName="Take">
      <MemberSignature Language="C#" Value="public T Take ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance !T Take() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Concurrent.BlockingCollection`1.Take" />
      <MemberSignature Language="VB.NET" Value="Public Function Take () As T" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; T Take();" />
      <MemberSignature Language="F#" Value="member this.Take : unit -&gt; 'T" Usage="blockingCollection.Take " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Remove um item do <see cref="T:System.Collections.Concurrent.BlockingCollection`1" />.</summary>
        <returns>O item removido da coleção.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Uma chamada para <xref:System.Collections.Concurrent.BlockingCollection%601.Take%2A> podem bloquear até que um item está disponível para ser removido.  
  
 A ordem na qual um item é removido depende do tipo de coleção usado para criar a instância <xref:System.Collections.Concurrent.BlockingCollection%601>. Ao criar um objeto <xref:System.Collections.Concurrent.BlockingCollection%601>, você pode especificar o tipo de coleção a ser usado. Por exemplo, seria possível especificar um objeto <xref:System.Collections.Concurrent.ConcurrentQueue%601> para o comportamento primeiro a entrar, primeiro a sair (PEPS) ou um objeto <xref:System.Collections.Concurrent.ConcurrentStack%601> para último a entrar, primeiro a sair (UEPS). Você pode usar qualquer classe de coleção que implemente a interface <xref:System.Collections.Concurrent.IProducerConsumerCollection%601>. O tipo de coleção padrão para <xref:System.Collections.Concurrent.BlockingCollection%601> é <xref:System.Collections.Concurrent.ConcurrentQueue%601>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">O <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> foi descartado.</exception>
        <exception cref="T:System.InvalidOperationException">A coleção subjacente foi modificada fora desta instância de <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> ou o <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> está vazio e a coleção foi marcada como concluída para adição.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/2e7ca21f-786c-4367-96be-0cf3f3dcc6bd">Coleções thread-safe</related>
        <related type="Article" href="https://msdn.microsoft.com/library/987ea3d7-0ad5-4238-8b64-331ce4eb3f0b">Visão geral de BlockingCollection</related>
      </Docs>
    </Member>
    <Member MemberName="Take">
      <MemberSignature Language="C#" Value="public T Take (System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance !T Take(valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Concurrent.BlockingCollection`1.Take(System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; T Take(System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="member this.Take : System.Threading.CancellationToken -&gt; 'T" Usage="blockingCollection.Take cancellationToken" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="cancellationToken">Objeto que pode ser usado para cancelar a operação take.</param>
        <summary>Remove um item do <see cref="T:System.Collections.Concurrent.BlockingCollection`1" />.</summary>
        <returns>O item removido da coleção.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Uma chamada para <xref:System.Collections.Concurrent.BlockingCollection%601.Take%2A> podem bloquear até que um item está disponível para ser removido ou o token é cancelado.  
  
 A ordem na qual um item é removido depende do tipo de coleção usado para criar a instância <xref:System.Collections.Concurrent.BlockingCollection%601>. Ao criar um objeto <xref:System.Collections.Concurrent.BlockingCollection%601>, você pode especificar o tipo de coleção a ser usado. Por exemplo, seria possível especificar um objeto <xref:System.Collections.Concurrent.ConcurrentQueue%601> para o comportamento primeiro a entrar, primeiro a sair (PEPS) ou um objeto <xref:System.Collections.Concurrent.ConcurrentStack%601> para último a entrar, primeiro a sair (UEPS). Você pode usar qualquer classe de coleção que implemente a interface <xref:System.Collections.Concurrent.IProducerConsumerCollection%601>. O tipo de coleção padrão para <xref:System.Collections.Concurrent.BlockingCollection%601> é <xref:System.Collections.Concurrent.ConcurrentQueue%601>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OperationCanceledException">O <see cref="T:System.Threading.CancellationToken" /> está cancelado.</exception>
        <exception cref="T:System.ObjectDisposedException">A <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> foi descartada ou a <see cref="T:System.Threading.CancellationTokenSource" /> que criou o token foi cancelada.</exception>
        <exception cref="T:System.InvalidOperationException">A coleção subjacente foi modificada fora desta instância de <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> ou a BlockingCollection está marcada como concluída para adicionar ou a <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> está vazia.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/2e7ca21f-786c-4367-96be-0cf3f3dcc6bd">Coleções thread-safe</related>
        <related type="Article" href="https://msdn.microsoft.com/library/987ea3d7-0ad5-4238-8b64-331ce4eb3f0b">Visão geral de BlockingCollection</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="TakeFromAny">
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Toma um item de qualquer uma das instâncias <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> especificadas.</summary>
        <related type="Article" href="https://msdn.microsoft.com/library/2e7ca21f-786c-4367-96be-0cf3f3dcc6bd">Coleções thread-safe</related>
        <related type="Article" href="https://msdn.microsoft.com/library/987ea3d7-0ad5-4238-8b64-331ce4eb3f0b">Visão geral de BlockingCollection</related>
      </Docs>
    </MemberGroup>
    <Member MemberName="TakeFromAny">
      <MemberSignature Language="C#" Value="public static int TakeFromAny (System.Collections.Concurrent.BlockingCollection&lt;T&gt;[] collections, out T item);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 TakeFromAny(class System.Collections.Concurrent.BlockingCollection`1&lt;!T&gt;[] collections, [out] !T&amp; item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Concurrent.BlockingCollection`1.TakeFromAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TakeFromAny (collections As BlockingCollection(Of T)(), ByRef item As T) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int TakeFromAny(cli::array &lt;System::Collections::Concurrent::BlockingCollection&lt;T&gt; ^&gt; ^ collections, [Runtime::InteropServices::Out] T % item);" />
      <MemberSignature Language="F#" Value="static member TakeFromAny : System.Collections.Concurrent.BlockingCollection&lt;'T&gt;[] *  -&gt; int" Usage="System.Collections.Concurrent.BlockingCollection&lt;'T&gt;.TakeFromAny (collections, item)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="collections" Type="System.Collections.Concurrent.BlockingCollection&lt;T&gt;[]" />
        <Parameter Name="item" Type="T" RefType="out" />
      </Parameters>
      <Docs>
        <param name="collections">A matriz de coleções.</param>
        <param name="item">O item removido de uma das coleções.</param>
        <summary>Toma um item de qualquer uma das instâncias <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> especificadas.</summary>
        <returns>O índice da coleção na matriz <paramref name="collections" /> da qual o item foi removido.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Uma chamada para TakeFromAny pode bloquear até que um item está disponível para ser removido.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Pelo menos uma das instâncias de <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> foi descartada.</exception>
        <exception cref="T:System.ArgumentNullException">O argumento <paramref name="collections" /> é nulo.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">A contagem de <paramref name="collections" /> é maior que o tamanho máximo de 62 para STA e 63 para MTA.</exception>
        <exception cref="T:System.ArgumentException">O argumento <paramref name="collections" /> é uma matriz de tamanho 0 ou contém um elemento nulo ou <see cref="M:System.Collections.Concurrent.BlockingCollection`1.CompleteAdding" /> foi chamado na coleção.</exception>
        <exception cref="T:System.InvalidOperationException">Pelo menos uma das coleções subjacentes foi alterada fora da instância de <see cref="T:System.Collections.Concurrent.BlockingCollection`1" />.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/2e7ca21f-786c-4367-96be-0cf3f3dcc6bd">Coleções thread-safe</related>
        <related type="Article" href="https://msdn.microsoft.com/library/987ea3d7-0ad5-4238-8b64-331ce4eb3f0b">Visão geral de BlockingCollection</related>
      </Docs>
    </Member>
    <Member MemberName="TakeFromAny">
      <MemberSignature Language="C#" Value="public static int TakeFromAny (System.Collections.Concurrent.BlockingCollection&lt;T&gt;[] collections, out T item, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 TakeFromAny(class System.Collections.Concurrent.BlockingCollection`1&lt;!T&gt;[] collections, [out] !T&amp; item, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Concurrent.BlockingCollection`1.TakeFromAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0@,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int TakeFromAny(cli::array &lt;System::Collections::Concurrent::BlockingCollection&lt;T&gt; ^&gt; ^ collections, [Runtime::InteropServices::Out] T % item, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="static member TakeFromAny : System.Collections.Concurrent.BlockingCollection&lt;'T&gt;[] *  * System.Threading.CancellationToken -&gt; int" Usage="System.Collections.Concurrent.BlockingCollection&lt;'T&gt;.TakeFromAny (collections, item, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="collections" Type="System.Collections.Concurrent.BlockingCollection&lt;T&gt;[]" />
        <Parameter Name="item" Type="T" RefType="out" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="collections">A matriz de coleções.</param>
        <param name="item">O item removido de uma das coleções.</param>
        <param name="cancellationToken">Um token de cancelamento a ser observado.</param>
        <summary>Recebe um item de qualquer uma das instâncias <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> especificadas, observando ao mesmo tempo o token de cancelamento especificado.</summary>
        <returns>O índice da coleção na matriz <paramref name="collections" /> da qual o item foi removido.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Uma chamada para TakeFromAny pode bloquear até que um item está disponível para ser removido. O método retornará antecipadamente com um OperationCanceledException se o token é cancelado.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OperationCanceledException">Se o padrão <see cref="T:System.Threading.CancellationToken" /> for cancelado.</exception>
        <exception cref="T:System.InvalidOperationException">Pelo menos uma das coleções subjacentes foi alterada fora da instância de <see cref="T:System.Collections.Concurrent.BlockingCollection`1" />.</exception>
        <exception cref="T:System.ArgumentNullException">O argumento <paramref name="collections" /> é nulo.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">A contagem de <paramref name="collections" /> é maior que o tamanho máximo de 62 para STA e 63 para MTA.</exception>
        <exception cref="T:System.ArgumentException">O argumento <paramref name="collections" /> é uma matriz de comprimento zero ou contém um elemento nulo, ou <see cref="M:System.Collections.Concurrent.BlockingCollection`1.CompleteAdding" /> foi chamado na coleção.</exception>
        <exception cref="T:System.ObjectDisposedException">Pelo menos uma das instâncias de <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> foi descartada.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/2e7ca21f-786c-4367-96be-0cf3f3dcc6bd">Coleções thread-safe</related>
        <related type="Article" href="https://msdn.microsoft.com/library/987ea3d7-0ad5-4238-8b64-331ce4eb3f0b">Visão geral de BlockingCollection</related>
      </Docs>
    </Member>
    <Member MemberName="ToArray">
      <MemberSignature Language="C#" Value="public T[] ToArray ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance !T[] ToArray() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Concurrent.BlockingCollection`1.ToArray" />
      <MemberSignature Language="VB.NET" Value="Public Function ToArray () As T()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;T&gt; ^ ToArray();" />
      <MemberSignature Language="F#" Value="member this.ToArray : unit -&gt; 'T[]" Usage="blockingCollection.ToArray " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Copia os itens da instância <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> em uma nova matriz.</summary>
        <returns>Uma matriz que contém cópias dos elementos da coleção.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Os elementos copiados não são removidos da coleção.  
  
 Se qualquer método de BlockingCollection está em execução enquanto o método ToArray é executado, o valor de retorno é aproximado. ToArray pode incluir itens que já foram removidos ou excluir itens que já foram inseridos.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">O <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> foi descartado.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/2e7ca21f-786c-4367-96be-0cf3f3dcc6bd">Coleções thread-safe</related>
        <related type="Article" href="https://msdn.microsoft.com/library/987ea3d7-0ad5-4238-8b64-331ce4eb3f0b">Visão geral de BlockingCollection</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="TryAdd">
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tenta adicionar o item especificado ao <see cref="T:System.Collections.Concurrent.BlockingCollection`1" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="TryAdd">
      <MemberSignature Language="C#" Value="public bool TryAdd (T item);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryAdd(!T item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Concurrent.BlockingCollection`1.TryAdd(`0)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryAdd (item As T) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryAdd(T item);" />
      <MemberSignature Language="F#" Value="member this.TryAdd : 'T -&gt; bool" Usage="blockingCollection.TryAdd item" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="T" />
      </Parameters>
      <Docs>
        <param name="item">O item a ser adicionado à coleção.</param>
        <summary>Tenta adicionar o item especificado ao <see cref="T:System.Collections.Concurrent.BlockingCollection`1" />.</summary>
        <returns>true se <paramref name="item" /> pôde ser adicionado, caso contrário, false. Se o item for duplicado e a coleção subjacente não aceitar itens duplicados, será gerada uma <see cref="T:System.InvalidOperationException" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se a coleção é uma coleção associada e está cheio, esse método imediatamente retorna false sem adicionar o item.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">O <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> foi descartado.</exception>
        <exception cref="T:System.InvalidOperationException">O <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> foi marcado como concluído com relação a adições.  
  
- ou - 
A coleção subjacente não aceitou o item.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/2e7ca21f-786c-4367-96be-0cf3f3dcc6bd">Coleções thread-safe</related>
        <related type="Article" href="https://msdn.microsoft.com/library/987ea3d7-0ad5-4238-8b64-331ce4eb3f0b">Visão geral de BlockingCollection</related>
      </Docs>
    </Member>
    <Member MemberName="TryAdd">
      <MemberSignature Language="C#" Value="public bool TryAdd (T item, int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryAdd(!T item, int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Concurrent.BlockingCollection`1.TryAdd(`0,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryAdd (item As T, millisecondsTimeout As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryAdd(T item, int millisecondsTimeout);" />
      <MemberSignature Language="F#" Value="member this.TryAdd : 'T * int -&gt; bool" Usage="blockingCollection.TryAdd (item, millisecondsTimeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="T" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="item">O item a ser adicionado à coleção.</param>
        <param name="millisecondsTimeout">O número de milissegundos para aguardar ou <see cref="F:System.Threading.Timeout.Infinite" /> (- 1) para aguardar indefinidamente.</param>
        <summary>Tenta adicionar o item especificado à <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> dentro do período de tempo especificado.</summary>
        <returns>true se o <paramref name="item" /> puder ser adicionado à coleção dentro do tempo especificado, caso contrário, false. Se o item for duplicado e a coleção subjacente não aceitar itens duplicados, será gerada uma <see cref="T:System.InvalidOperationException" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException">O <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> foi descartado.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="millisecondsTimeout" /> é um número negativo diferente de -1, que representa um tempo limite infinito.</exception>
        <exception cref="T:System.InvalidOperationException">O <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> foi marcado como concluído com relação a adições.  
  
- ou - 
A coleção subjacente não aceitou o item.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/2e7ca21f-786c-4367-96be-0cf3f3dcc6bd">Coleções thread-safe</related>
        <related type="Article" href="https://msdn.microsoft.com/library/987ea3d7-0ad5-4238-8b64-331ce4eb3f0b">Visão geral de BlockingCollection</related>
      </Docs>
    </Member>
    <Member MemberName="TryAdd">
      <MemberSignature Language="C#" Value="public bool TryAdd (T item, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryAdd(!T item, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Concurrent.BlockingCollection`1.TryAdd(`0,System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryAdd (item As T, timeout As TimeSpan) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryAdd(T item, TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="member this.TryAdd : 'T * TimeSpan -&gt; bool" Usage="blockingCollection.TryAdd (item, timeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="T" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="item">O item a ser adicionado à coleção.</param>
        <param name="timeout">Um <see cref="T:System.TimeSpan" /> que representa o número de milissegundos para aguardar ou um <see cref="T:System.TimeSpan" /> que representa -1 milissegundos para aguardar indefinidamente.</param>
        <summary>Tenta adicionar o item especificado ao <see cref="T:System.Collections.Concurrent.BlockingCollection`1" />.</summary>
        <returns>True se o <paramref name="item" /> puder ser adicionado à coleção dentro do período de tempo especificado, caso contrário, false.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException">O <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> foi descartado.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="timeout" /> é um número negativo diferente de -1 milissegundos, que representa um tempo limite infinito ou o tempo limite é maior que <see cref="F:System.Int32.MaxValue" />.</exception>
        <exception cref="T:System.InvalidOperationException">O <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> foi marcado como concluído com relação a adições.  
  
- ou - 
A coleção subjacente não aceitou o item.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/2e7ca21f-786c-4367-96be-0cf3f3dcc6bd">Coleções thread-safe</related>
        <related type="Article" href="https://msdn.microsoft.com/library/987ea3d7-0ad5-4238-8b64-331ce4eb3f0b">Visão geral de BlockingCollection</related>
      </Docs>
    </Member>
    <Member MemberName="TryAdd">
      <MemberSignature Language="C#" Value="public bool TryAdd (T item, int millisecondsTimeout, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryAdd(!T item, int32 millisecondsTimeout, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Concurrent.BlockingCollection`1.TryAdd(`0,System.Int32,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryAdd(T item, int millisecondsTimeout, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="member this.TryAdd : 'T * int * System.Threading.CancellationToken -&gt; bool" Usage="blockingCollection.TryAdd (item, millisecondsTimeout, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="T" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="item">O item a ser adicionado à coleção.</param>
        <param name="millisecondsTimeout">O número de milissegundos para aguardar ou <see cref="F:System.Threading.Timeout.Infinite" /> (- 1) para aguardar indefinidamente.</param>
        <param name="cancellationToken">Um token de cancelamento a ser observado.</param>
        <summary>Tenta adicionar o item especificado ao <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> no período especificado, enquanto observa um token de cancelamento.</summary>
        <returns>true se o <paramref name="item" /> puder ser adicionado à coleção dentro do tempo especificado, caso contrário, false. Se o item for duplicado e a coleção subjacente não aceitar itens duplicados, será gerada uma <see cref="T:System.InvalidOperationException" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">Se o padrão <see cref="T:System.Threading.CancellationToken" /> for cancelado.</exception>
        <exception cref="T:System.ObjectDisposedException">O <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> foi descartado ou o <see cref="T:System.Threading.CancellationTokenSource" /> subjacente foi descartado.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="millisecondsTimeout" /> é um número negativo diferente de -1, que representa um tempo limite infinito.</exception>
        <exception cref="T:System.InvalidOperationException">O <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> foi marcado como concluído com relação a adições.  
  
- ou - 
A coleção subjacente não aceitou o item.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/2e7ca21f-786c-4367-96be-0cf3f3dcc6bd">Coleções thread-safe</related>
        <related type="Article" href="https://msdn.microsoft.com/library/987ea3d7-0ad5-4238-8b64-331ce4eb3f0b">Visão geral de BlockingCollection</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="TryAddToAny">
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tenta adicionar o item especificado a qualquer uma das instâncias <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> especificadas.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="TryAddToAny">
      <MemberSignature Language="C#" Value="public static int TryAddToAny (System.Collections.Concurrent.BlockingCollection&lt;T&gt;[] collections, T item);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 TryAddToAny(class System.Collections.Concurrent.BlockingCollection`1&lt;!T&gt;[] collections, !T item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Concurrent.BlockingCollection`1.TryAddToAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryAddToAny (collections As BlockingCollection(Of T)(), item As T) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int TryAddToAny(cli::array &lt;System::Collections::Concurrent::BlockingCollection&lt;T&gt; ^&gt; ^ collections, T item);" />
      <MemberSignature Language="F#" Value="static member TryAddToAny : System.Collections.Concurrent.BlockingCollection&lt;'T&gt;[] * 'T -&gt; int" Usage="System.Collections.Concurrent.BlockingCollection&lt;'T&gt;.TryAddToAny (collections, item)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="collections" Type="System.Collections.Concurrent.BlockingCollection&lt;T&gt;[]" />
        <Parameter Name="item" Type="T" />
      </Parameters>
      <Docs>
        <param name="collections">A matriz de coleções.</param>
        <param name="item">O item a ser adicionado a uma das coleções.</param>
        <summary>Tenta adicionar o item especificado a qualquer uma das instâncias <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> especificadas.</summary>
        <returns>O índice da coleção na matriz <paramref name="collections" /> ao qual o item foi adicionado ou -1 caso o item não possa ser adicionado.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException">Pelo menos uma das instâncias de <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> foi descartada.</exception>
        <exception cref="T:System.ArgumentNullException">O argumento <paramref name="collections" /> é nulo.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">A contagem de <paramref name="collections" /> é maior que o tamanho máximo de 62 para STA e 63 para MTA.</exception>
        <exception cref="T:System.ArgumentException">O argumento <paramref name="collections" /> é uma matriz de tamanho 0 ou contém um elemento nulo, ou pelo menos uma das coleções foi marcada como completa para adição.</exception>
        <exception cref="T:System.InvalidOperationException">Pelo menos uma coleção subjacente não aceitou o item.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/2e7ca21f-786c-4367-96be-0cf3f3dcc6bd">Coleções thread-safe</related>
        <related type="Article" href="https://msdn.microsoft.com/library/987ea3d7-0ad5-4238-8b64-331ce4eb3f0b">Visão geral de BlockingCollection</related>
      </Docs>
    </Member>
    <Member MemberName="TryAddToAny">
      <MemberSignature Language="C#" Value="public static int TryAddToAny (System.Collections.Concurrent.BlockingCollection&lt;T&gt;[] collections, T item, int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 TryAddToAny(class System.Collections.Concurrent.BlockingCollection`1&lt;!T&gt;[] collections, !T item, int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Concurrent.BlockingCollection`1.TryAddToAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryAddToAny (collections As BlockingCollection(Of T)(), item As T, millisecondsTimeout As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int TryAddToAny(cli::array &lt;System::Collections::Concurrent::BlockingCollection&lt;T&gt; ^&gt; ^ collections, T item, int millisecondsTimeout);" />
      <MemberSignature Language="F#" Value="static member TryAddToAny : System.Collections.Concurrent.BlockingCollection&lt;'T&gt;[] * 'T * int -&gt; int" Usage="System.Collections.Concurrent.BlockingCollection&lt;'T&gt;.TryAddToAny (collections, item, millisecondsTimeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="collections" Type="System.Collections.Concurrent.BlockingCollection&lt;T&gt;[]" />
        <Parameter Name="item" Type="T" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="collections">A matriz de coleções.</param>
        <param name="item">O item a ser adicionado a uma das coleções.</param>
        <param name="millisecondsTimeout">O número de milissegundos para aguardar ou <see cref="F:System.Threading.Timeout.Infinite" /> (- 1) para aguardar indefinidamente.</param>
        <summary>Tenta adicionar o item especificado a qualquer uma das instâncias <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> especificadas.</summary>
        <returns>O índice da coleção na matriz <paramref name="collections" /> ao qual o item foi adicionado ou -1 caso o item não possa ser adicionado.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException">Pelo menos uma das instâncias de <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> foi descartada.</exception>
        <exception cref="T:System.ArgumentNullException">O argumento <paramref name="collections" /> é nulo.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="millisecondsTimeout" /> é um número negativo diferente de -1, que representa um tempo limite infinito. 
- ou - 
A contagem de <paramref name="collections" /> é maior que o tamanho máximo de 62 para STA e 63 para MTA.</exception>
        <exception cref="T:System.ArgumentException">O argumento <paramref name="collections" /> é uma matriz de tamanho 0 ou contém um elemento nulo, ou pelo menos uma das coleções foi marcada como completa para adição.</exception>
        <exception cref="T:System.InvalidOperationException">Pelo menos uma coleção subjacente não aceitou o item.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/2e7ca21f-786c-4367-96be-0cf3f3dcc6bd">Coleções thread-safe</related>
        <related type="Article" href="https://msdn.microsoft.com/library/987ea3d7-0ad5-4238-8b64-331ce4eb3f0b">Visão geral de BlockingCollection</related>
      </Docs>
    </Member>
    <Member MemberName="TryAddToAny">
      <MemberSignature Language="C#" Value="public static int TryAddToAny (System.Collections.Concurrent.BlockingCollection&lt;T&gt;[] collections, T item, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 TryAddToAny(class System.Collections.Concurrent.BlockingCollection`1&lt;!T&gt;[] collections, !T item, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Concurrent.BlockingCollection`1.TryAddToAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0,System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryAddToAny (collections As BlockingCollection(Of T)(), item As T, timeout As TimeSpan) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int TryAddToAny(cli::array &lt;System::Collections::Concurrent::BlockingCollection&lt;T&gt; ^&gt; ^ collections, T item, TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="static member TryAddToAny : System.Collections.Concurrent.BlockingCollection&lt;'T&gt;[] * 'T * TimeSpan -&gt; int" Usage="System.Collections.Concurrent.BlockingCollection&lt;'T&gt;.TryAddToAny (collections, item, timeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="collections" Type="System.Collections.Concurrent.BlockingCollection&lt;T&gt;[]" />
        <Parameter Name="item" Type="T" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="collections">A matriz de coleções.</param>
        <param name="item">O item a ser adicionado a uma das coleções.</param>
        <param name="timeout">Um <see cref="T:System.TimeSpan" /> que representa o número de milissegundos para aguardar ou um <see cref="T:System.TimeSpan" /> que representa -1 milissegundos para aguardar indefinidamente.</param>
        <summary>Tenta adicionar o item especificado a qualquer uma das instâncias <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> especificadas, observando ao mesmo tempo o token de cancelamento especificado.</summary>
        <returns>O índice da coleção na matriz <paramref name="collections" /> ao qual o item foi adicionado ou -1 caso o item não possa ser adicionado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método pode retornar no início, se o cancellationToken for cancelado antes de que havia espaço disponível para a operação de adição.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Pelo menos uma das instâncias <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> ou o <see cref="T:System.Threading.CancellationTokenSource" /> que criou <paramref name="cancellationToken" /> foi descartado.</exception>
        <exception cref="T:System.ArgumentNullException">O argumento <paramref name="collections" /> é nulo.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="timeout" /> é um número negativo diferente de -1 milissegundos, que representa um tempo limite infinito ou o tempo limite é maior que <see cref="F:System.Int32.MaxValue" />.  
  
- ou - 
A contagem de <paramref name="collections" /> é maior que o tamanho máximo de 62 para STA e 63 para MTA.</exception>
        <exception cref="T:System.ArgumentException">O argumento <paramref name="collections" /> é uma matriz de tamanho 0 ou contém um elemento nulo, ou pelo menos uma das coleções foi marcada como completa para adição.</exception>
        <exception cref="T:System.InvalidOperationException">Pelo menos uma coleção subjacente não aceitou o item.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/2e7ca21f-786c-4367-96be-0cf3f3dcc6bd">Coleções thread-safe</related>
        <related type="Article" href="https://msdn.microsoft.com/library/987ea3d7-0ad5-4238-8b64-331ce4eb3f0b">Visão geral de BlockingCollection</related>
      </Docs>
    </Member>
    <Member MemberName="TryAddToAny">
      <MemberSignature Language="C#" Value="public static int TryAddToAny (System.Collections.Concurrent.BlockingCollection&lt;T&gt;[] collections, T item, int millisecondsTimeout, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 TryAddToAny(class System.Collections.Concurrent.BlockingCollection`1&lt;!T&gt;[] collections, !T item, int32 millisecondsTimeout, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Concurrent.BlockingCollection`1.TryAddToAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0,System.Int32,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int TryAddToAny(cli::array &lt;System::Collections::Concurrent::BlockingCollection&lt;T&gt; ^&gt; ^ collections, T item, int millisecondsTimeout, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="static member TryAddToAny : System.Collections.Concurrent.BlockingCollection&lt;'T&gt;[] * 'T * int * System.Threading.CancellationToken -&gt; int" Usage="System.Collections.Concurrent.BlockingCollection&lt;'T&gt;.TryAddToAny (collections, item, millisecondsTimeout, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="collections" Type="System.Collections.Concurrent.BlockingCollection&lt;T&gt;[]" />
        <Parameter Name="item" Type="T" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="collections">A matriz de coleções.</param>
        <param name="item">O item a ser adicionado a uma das coleções.</param>
        <param name="millisecondsTimeout">O número de milissegundos para aguardar ou <see cref="F:System.Threading.Timeout.Infinite" /> (- 1) para aguardar indefinidamente.</param>
        <param name="cancellationToken">Um token de cancelamento a ser observado.</param>
        <summary>Tenta adicionar o item especificado a qualquer uma das instâncias <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> especificadas.</summary>
        <returns>O índice da coleção na matriz <paramref name="collections" /> ao qual o item foi adicionado ou -1 caso o item não possa ser adicionado.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">Se o padrão <see cref="T:System.Threading.CancellationToken" /> for cancelado.</exception>
        <exception cref="T:System.InvalidOperationException">Pelo menos uma coleção subjacente não aceitou o item.</exception>
        <exception cref="T:System.ArgumentNullException">O argumento <paramref name="collections" /> é nulo.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="millisecondsTimeout" /> é um número negativo diferente de -1, que representa um tempo limite infinito. 
- ou - 
A contagem de <paramref name="collections" /> é maior que o tamanho máximo de 62 para STA e 63 para MTA.</exception>
        <exception cref="T:System.ArgumentException">O argumento <paramref name="collections" /> é uma matriz de tamanho 0 ou contém um elemento nulo, ou pelo menos uma das coleções foi marcada como completa para adição.</exception>
        <exception cref="T:System.ObjectDisposedException">Pelo menos uma das instâncias de <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> foi descartada.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/2e7ca21f-786c-4367-96be-0cf3f3dcc6bd">Coleções thread-safe</related>
        <related type="Article" href="https://msdn.microsoft.com/library/987ea3d7-0ad5-4238-8b64-331ce4eb3f0b">Visão geral de BlockingCollection</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="TryTake">
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tenta remover um item no <see cref="T:System.Collections.Concurrent.BlockingCollection`1" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O exemplo a seguir mostra como usar o método <xref:System.Collections.Concurrent.BlockingCollection%601.TryTake%2A>.  
  
 [!code-csharp[System.Collections.Concurrent.BlockingCollection#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.collections.concurrent.blockingcollection/cs/blockingcoll.cs#2)]
 [!code-vb[System.Collections.Concurrent.BlockingCollection#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.collections.concurrent.blockingcollection/vb/blockingcoll.vb#2)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/2e7ca21f-786c-4367-96be-0cf3f3dcc6bd">Coleções thread-safe</related>
        <related type="Article" href="https://msdn.microsoft.com/library/987ea3d7-0ad5-4238-8b64-331ce4eb3f0b">Visão geral de BlockingCollection</related>
      </Docs>
    </MemberGroup>
    <Member MemberName="TryTake">
      <MemberSignature Language="C#" Value="public bool TryTake (out T item);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryTake([out] !T&amp; item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Concurrent.BlockingCollection`1.TryTake(`0@)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryTake (ByRef item As T) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryTake([Runtime::InteropServices::Out] T % item);" />
      <MemberSignature Language="F#" Value="member this.TryTake :  -&gt; bool" Usage="blockingCollection.TryTake item" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="T" RefType="out" />
      </Parameters>
      <Docs>
        <param name="item">O item a ser removido da coleção.</param>
        <summary>Tenta remover um item no <see cref="T:System.Collections.Concurrent.BlockingCollection`1" />.</summary>
        <returns>
          <see langword="true" /> se um item pode ser removido; Caso contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se a coleção estiver vazia, este método imediatamente retorna false.  
  
 A ordem na qual um item é removido depende do tipo de coleção usado para criar a instância <xref:System.Collections.Concurrent.BlockingCollection%601>. Ao criar um objeto <xref:System.Collections.Concurrent.BlockingCollection%601>, você pode especificar o tipo de coleção a ser usado. Por exemplo, seria possível especificar um objeto <xref:System.Collections.Concurrent.ConcurrentQueue%601> para o comportamento primeiro a entrar, primeiro a sair (PEPS) ou um objeto <xref:System.Collections.Concurrent.ConcurrentStack%601> para último a entrar, primeiro a sair (UEPS). Você pode usar qualquer classe de coleção que implemente a interface <xref:System.Collections.Concurrent.IProducerConsumerCollection%601>. O tipo de coleção padrão para <xref:System.Collections.Concurrent.BlockingCollection%601> é <xref:System.Collections.Concurrent.ConcurrentQueue%601>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">O <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> foi descartado.</exception>
        <exception cref="T:System.InvalidOperationException">A coleção subjacente foi alterada fora da instância de <see cref="T:System.Collections.Concurrent.BlockingCollection`1" />.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/2e7ca21f-786c-4367-96be-0cf3f3dcc6bd">Coleções thread-safe</related>
        <related type="Article" href="https://msdn.microsoft.com/library/987ea3d7-0ad5-4238-8b64-331ce4eb3f0b">Visão geral de BlockingCollection</related>
      </Docs>
    </Member>
    <Member MemberName="TryTake">
      <MemberSignature Language="C#" Value="public bool TryTake (out T item, int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryTake([out] !T&amp; item, int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Concurrent.BlockingCollection`1.TryTake(`0@,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryTake (ByRef item As T, millisecondsTimeout As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryTake([Runtime::InteropServices::Out] T % item, int millisecondsTimeout);" />
      <MemberSignature Language="F#" Value="member this.TryTake :  * int -&gt; bool" Usage="blockingCollection.TryTake (item, millisecondsTimeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="T" RefType="out" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="item">O item a ser removido da coleção.</param>
        <param name="millisecondsTimeout">O número de milissegundos para aguardar ou <see cref="F:System.Threading.Timeout.Infinite" /> (- 1) para aguardar indefinidamente.</param>
        <summary>Tenta remover um item do <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> no período de tempo especificado.</summary>
        <returns>
          <see langword="true" /> se um item puder ser removido da coleção dentro do tempo especificado; caso contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A ordem na qual um item é removido depende do tipo de coleção usado para criar a instância <xref:System.Collections.Concurrent.BlockingCollection%601>. Quando você cria um <xref:System.Collections.Concurrent.BlockingCollection%601>, você pode especificar o tipo de coleção a ser usada. Por exemplo, seria possível especificar um objeto <xref:System.Collections.Concurrent.ConcurrentQueue%601> para o comportamento primeiro a entrar, primeiro a sair (PEPS) ou um objeto <xref:System.Collections.Concurrent.ConcurrentStack%601> para último a entrar, primeiro a sair (UEPS). Você pode usar qualquer classe de coleção que implemente a interface <xref:System.Collections.Concurrent.IProducerConsumerCollection%601>. O tipo de coleção padrão para <xref:System.Collections.Concurrent.BlockingCollection%601> é <xref:System.Collections.Concurrent.ConcurrentQueue%601>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">O <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> foi descartado.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="millisecondsTimeout" /> é um número negativo diferente de -1, que representa um tempo limite infinito.</exception>
        <exception cref="T:System.InvalidOperationException">A coleção subjacente foi alterada fora da instância de <see cref="T:System.Collections.Concurrent.BlockingCollection`1" />.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/2e7ca21f-786c-4367-96be-0cf3f3dcc6bd">Coleções thread-safe</related>
        <related type="Article" href="https://msdn.microsoft.com/library/987ea3d7-0ad5-4238-8b64-331ce4eb3f0b">Visão geral de BlockingCollection</related>
      </Docs>
    </Member>
    <Member MemberName="TryTake">
      <MemberSignature Language="C#" Value="public bool TryTake (out T item, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryTake([out] !T&amp; item, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Concurrent.BlockingCollection`1.TryTake(`0@,System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryTake (ByRef item As T, timeout As TimeSpan) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryTake([Runtime::InteropServices::Out] T % item, TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="member this.TryTake :  * TimeSpan -&gt; bool" Usage="blockingCollection.TryTake (item, timeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="T" RefType="out" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="item">O item a ser removido da coleção.</param>
        <param name="timeout">Um objeto que representa o número de milissegundos de espera ou um objeto que representa -1 milissegundos para esperar por tempo indeterminado.</param>
        <summary>Tenta remover um item do <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> no período de tempo especificado.</summary>
        <returns>
          <see langword="true" /> se um item puder ser removido da coleção dentro do tempo especificado; caso contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A ordem na qual um item é removido depende do tipo de coleção usado para criar a instância <xref:System.Collections.Concurrent.BlockingCollection%601>. Ao criar um objeto <xref:System.Collections.Concurrent.BlockingCollection%601>, você pode especificar o tipo de coleção a ser usado. Por exemplo, seria possível especificar um objeto <xref:System.Collections.Concurrent.ConcurrentQueue%601> para o comportamento primeiro a entrar, primeiro a sair (PEPS) ou um objeto <xref:System.Collections.Concurrent.ConcurrentStack%601> para último a entrar, primeiro a sair (UEPS). Você pode usar qualquer classe de coleção que implemente a interface <xref:System.Collections.Concurrent.IProducerConsumerCollection%601>. O tipo de coleção padrão para <xref:System.Collections.Concurrent.BlockingCollection%601> é <xref:System.Collections.Concurrent.ConcurrentQueue%601>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">O <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> foi descartado.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="timeout" /> é um número negativo diferente de -1 milissegundo, que representa um tempo limite infinito. 
- ou - 
 <paramref name="timeout" /> é maior que <see cref="F:System.Int32.MaxValue" />.</exception>
        <exception cref="T:System.InvalidOperationException">A coleção subjacente foi alterada fora da instância de <see cref="T:System.Collections.Concurrent.BlockingCollection`1" />.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/2e7ca21f-786c-4367-96be-0cf3f3dcc6bd">Coleções thread-safe</related>
        <related type="Article" href="https://msdn.microsoft.com/library/987ea3d7-0ad5-4238-8b64-331ce4eb3f0b">Visão geral de BlockingCollection</related>
      </Docs>
    </Member>
    <Member MemberName="TryTake">
      <MemberSignature Language="C#" Value="public bool TryTake (out T item, int millisecondsTimeout, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryTake([out] !T&amp; item, int32 millisecondsTimeout, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Concurrent.BlockingCollection`1.TryTake(`0@,System.Int32,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryTake([Runtime::InteropServices::Out] T % item, int millisecondsTimeout, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="member this.TryTake :  * int * System.Threading.CancellationToken -&gt; bool" Usage="blockingCollection.TryTake (item, millisecondsTimeout, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="T" RefType="out" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="item">O item a ser removido da coleção.</param>
        <param name="millisecondsTimeout">O número de milissegundos para aguardar ou <see cref="F:System.Threading.Timeout.Infinite" /> (- 1) para aguardar indefinidamente.</param>
        <param name="cancellationToken">Um token de cancelamento a ser observado.</param>
        <summary>Tenta remover um item do <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> no período especificado, enquanto observa um token de cancelamento.</summary>
        <returns>
          <see langword="true" /> se um item puder ser removido da coleção dentro do tempo especificado; caso contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A ordem na qual um item é removido depende do tipo de coleção usado para criar a instância <xref:System.Collections.Concurrent.BlockingCollection%601>. Ao criar um objeto <xref:System.Collections.Concurrent.BlockingCollection%601>, você pode especificar o tipo de coleção a ser usado. Por exemplo, seria possível especificar um objeto <xref:System.Collections.Concurrent.ConcurrentQueue%601> para o comportamento primeiro a entrar, primeiro a sair (PEPS) ou um objeto <xref:System.Collections.Concurrent.ConcurrentStack%601> para último a entrar, primeiro a sair (UEPS). Você pode usar qualquer classe de coleção que implemente a interface <xref:System.Collections.Concurrent.IProducerConsumerCollection%601>. O tipo de coleção padrão para <xref:System.Collections.Concurrent.BlockingCollection%601> é <xref:System.Collections.Concurrent.ConcurrentQueue%601>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OperationCanceledException">O <see cref="T:System.Threading.CancellationToken" /> foi cancelado.</exception>
        <exception cref="T:System.ObjectDisposedException">O <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> foi descartado ou o <see cref="T:System.Threading.CancellationTokenSource" /> subjacente foi descartado.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="millisecondsTimeout" /> é um número negativo diferente de -1, que representa um tempo limite infinito.</exception>
        <exception cref="T:System.InvalidOperationException">A coleção subjacente foi alterada fora da dessa instância de <see cref="T:System.Collections.Concurrent.BlockingCollection`1" />.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/2e7ca21f-786c-4367-96be-0cf3f3dcc6bd">Coleções thread-safe</related>
        <related type="Article" href="https://msdn.microsoft.com/library/987ea3d7-0ad5-4238-8b64-331ce4eb3f0b">Visão geral de BlockingCollection</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="TryTakeFromAny">
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tenta remover um item de qualquer uma das instâncias <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> especificadas.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="TryTakeFromAny">
      <MemberSignature Language="C#" Value="public static int TryTakeFromAny (System.Collections.Concurrent.BlockingCollection&lt;T&gt;[] collections, out T item);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 TryTakeFromAny(class System.Collections.Concurrent.BlockingCollection`1&lt;!T&gt;[] collections, [out] !T&amp; item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Concurrent.BlockingCollection`1.TryTakeFromAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryTakeFromAny (collections As BlockingCollection(Of T)(), ByRef item As T) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int TryTakeFromAny(cli::array &lt;System::Collections::Concurrent::BlockingCollection&lt;T&gt; ^&gt; ^ collections, [Runtime::InteropServices::Out] T % item);" />
      <MemberSignature Language="F#" Value="static member TryTakeFromAny : System.Collections.Concurrent.BlockingCollection&lt;'T&gt;[] *  -&gt; int" Usage="System.Collections.Concurrent.BlockingCollection&lt;'T&gt;.TryTakeFromAny (collections, item)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="collections" Type="System.Collections.Concurrent.BlockingCollection&lt;T&gt;[]" />
        <Parameter Name="item" Type="T" RefType="out" />
      </Parameters>
      <Docs>
        <param name="collections">A matriz de coleções.</param>
        <param name="item">O item removido de uma das coleções.</param>
        <summary>Tenta remover um item de qualquer uma das instâncias <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> especificadas.</summary>
        <returns>O índice da coleção na matriz <paramref name="collections" /> da qual o item foi removido ou -1 caso um item não possa ser removido.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Uma chamada para TryTakeFromAny pode ser bloqueada até que um item esteja disponível para ser removido.  
  
   
  
## Examples  
 O exemplo a seguir mostra como usar o <xref:System.Collections.Concurrent.BlockingCollection%601.TryTakeFromAny%2A?displayProperty=nameWithType> método:  
  
 [!code-csharp[System.Collections.Concurrent.BlockingCollection#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.collections.concurrent.blockingcollection/cs/blockingcoll.cs#3)]
 [!code-vb[System.Collections.Concurrent.BlockingCollection#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.collections.concurrent.blockingcollection/vb/blockingcoll.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Pelo menos uma das instâncias de <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> foi descartada.</exception>
        <exception cref="T:System.ArgumentNullException">O argumento <paramref name="collections" /> é nulo.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">A contagem de <paramref name="collections" /> é maior que o tamanho máximo de 62 para STA e 63 para MTA.</exception>
        <exception cref="T:System.ArgumentException">O argumento <paramref name="collections" /> é uma matriz de tamanho 0 ou contém um elemento nulo.</exception>
        <exception cref="T:System.InvalidOperationException">Pelo menos uma das coleções subjacentes foi alterada fora da instância de <see cref="T:System.Collections.Concurrent.BlockingCollection`1" />.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/2e7ca21f-786c-4367-96be-0cf3f3dcc6bd">Coleções thread-safe</related>
        <related type="Article" href="https://msdn.microsoft.com/library/987ea3d7-0ad5-4238-8b64-331ce4eb3f0b">Visão geral de BlockingCollection</related>
      </Docs>
    </Member>
    <Member MemberName="TryTakeFromAny">
      <MemberSignature Language="C#" Value="public static int TryTakeFromAny (System.Collections.Concurrent.BlockingCollection&lt;T&gt;[] collections, out T item, int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 TryTakeFromAny(class System.Collections.Concurrent.BlockingCollection`1&lt;!T&gt;[] collections, [out] !T&amp; item, int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Concurrent.BlockingCollection`1.TryTakeFromAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0@,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryTakeFromAny (collections As BlockingCollection(Of T)(), ByRef item As T, millisecondsTimeout As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int TryTakeFromAny(cli::array &lt;System::Collections::Concurrent::BlockingCollection&lt;T&gt; ^&gt; ^ collections, [Runtime::InteropServices::Out] T % item, int millisecondsTimeout);" />
      <MemberSignature Language="F#" Value="static member TryTakeFromAny : System.Collections.Concurrent.BlockingCollection&lt;'T&gt;[] *  * int -&gt; int" Usage="System.Collections.Concurrent.BlockingCollection&lt;'T&gt;.TryTakeFromAny (collections, item, millisecondsTimeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="collections" Type="System.Collections.Concurrent.BlockingCollection&lt;T&gt;[]" />
        <Parameter Name="item" Type="T" RefType="out" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="collections">A matriz de coleções.</param>
        <param name="item">O item removido de uma das coleções.</param>
        <param name="millisecondsTimeout">O número de milissegundos para aguardar ou <see cref="F:System.Threading.Timeout.Infinite" /> (- 1) para aguardar indefinidamente.</param>
        <summary>Tenta remover um item de qualquer uma das instâncias <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> especificadas.</summary>
        <returns>O índice da coleção na matriz <paramref name="collections" /> da qual o item foi removido ou -1 caso um item não possa ser removido.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Uma chamada para TryTakeFromAny pode ser bloqueada até que um item esteja disponível para ser removido.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Pelo menos uma das instâncias de <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> foi descartada.</exception>
        <exception cref="T:System.ArgumentNullException">O argumento <paramref name="collections" /> é nulo.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="millisecondsTimeout" /> é um número negativo diferente de -1, que representa um tempo limite infinito. 
- ou - 
A contagem de <paramref name="collections" /> é maior que o tamanho máximo de 62 para STA e 63 para MTA.</exception>
        <exception cref="T:System.ArgumentException">O argumento <paramref name="collections" /> é uma matriz de tamanho 0 ou contém um elemento nulo.</exception>
        <exception cref="T:System.InvalidOperationException">Pelo menos uma das coleções subjacentes foi alterada fora da instância de <see cref="T:System.Collections.Concurrent.BlockingCollection`1" />.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/2e7ca21f-786c-4367-96be-0cf3f3dcc6bd">Coleções thread-safe</related>
        <related type="Article" href="https://msdn.microsoft.com/library/987ea3d7-0ad5-4238-8b64-331ce4eb3f0b">Visão geral de BlockingCollection</related>
      </Docs>
    </Member>
    <Member MemberName="TryTakeFromAny">
      <MemberSignature Language="C#" Value="public static int TryTakeFromAny (System.Collections.Concurrent.BlockingCollection&lt;T&gt;[] collections, out T item, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 TryTakeFromAny(class System.Collections.Concurrent.BlockingCollection`1&lt;!T&gt;[] collections, [out] !T&amp; item, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Concurrent.BlockingCollection`1.TryTakeFromAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0@,System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryTakeFromAny (collections As BlockingCollection(Of T)(), ByRef item As T, timeout As TimeSpan) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int TryTakeFromAny(cli::array &lt;System::Collections::Concurrent::BlockingCollection&lt;T&gt; ^&gt; ^ collections, [Runtime::InteropServices::Out] T % item, TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="static member TryTakeFromAny : System.Collections.Concurrent.BlockingCollection&lt;'T&gt;[] *  * TimeSpan -&gt; int" Usage="System.Collections.Concurrent.BlockingCollection&lt;'T&gt;.TryTakeFromAny (collections, item, timeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="collections" Type="System.Collections.Concurrent.BlockingCollection&lt;T&gt;[]" />
        <Parameter Name="item" Type="T" RefType="out" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="collections">A matriz de coleções.</param>
        <param name="item">O item removido de uma das coleções.</param>
        <param name="timeout">Um <see cref="T:System.TimeSpan" /> que representa o número de milissegundos para aguardar ou um <see cref="T:System.TimeSpan" /> que representa -1 milissegundos para aguardar indefinidamente.</param>
        <summary>Tenta remover um item de qualquer uma das instâncias <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> especificadas.</summary>
        <returns>O índice da coleção na matriz <paramref name="collections" /> da qual o item foi removido ou -1 caso um item não possa ser removido.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Uma chamada para TryTakeFromAny pode ser bloqueada até que um item esteja disponível para ser removido.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Pelo menos uma das instâncias de <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> foi descartada.</exception>
        <exception cref="T:System.ArgumentNullException">O argumento <paramref name="collections" /> é nulo.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="timeout" /> é um número negativo diferente de -1 milissegundos, que representa um tempo limite infinito ou o tempo limite é maior que <see cref="F:System.Int32.MaxValue" />.  
  
- ou - 
A contagem de <paramref name="collections" /> é maior que o tamanho máximo de 62 para STA e 63 para MTA.</exception>
        <exception cref="T:System.ArgumentException">O argumento <paramref name="collections" /> é uma matriz de tamanho 0 ou contém um elemento nulo.</exception>
        <exception cref="T:System.InvalidOperationException">Pelo menos uma das coleções subjacentes foi alterada fora da instância de <see cref="T:System.Collections.Concurrent.BlockingCollection`1" />.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/2e7ca21f-786c-4367-96be-0cf3f3dcc6bd">Coleções thread-safe</related>
        <related type="Article" href="https://msdn.microsoft.com/library/987ea3d7-0ad5-4238-8b64-331ce4eb3f0b">Visão geral de BlockingCollection</related>
      </Docs>
    </Member>
    <Member MemberName="TryTakeFromAny">
      <MemberSignature Language="C#" Value="public static int TryTakeFromAny (System.Collections.Concurrent.BlockingCollection&lt;T&gt;[] collections, out T item, int millisecondsTimeout, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 TryTakeFromAny(class System.Collections.Concurrent.BlockingCollection`1&lt;!T&gt;[] collections, [out] !T&amp; item, int32 millisecondsTimeout, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Concurrent.BlockingCollection`1.TryTakeFromAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0@,System.Int32,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int TryTakeFromAny(cli::array &lt;System::Collections::Concurrent::BlockingCollection&lt;T&gt; ^&gt; ^ collections, [Runtime::InteropServices::Out] T % item, int millisecondsTimeout, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="static member TryTakeFromAny : System.Collections.Concurrent.BlockingCollection&lt;'T&gt;[] *  * int * System.Threading.CancellationToken -&gt; int" Usage="System.Collections.Concurrent.BlockingCollection&lt;'T&gt;.TryTakeFromAny (collections, item, millisecondsTimeout, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="collections" Type="System.Collections.Concurrent.BlockingCollection&lt;T&gt;[]" />
        <Parameter Name="item" Type="T" RefType="out" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="collections">A matriz de coleções.</param>
        <param name="item">O item removido de uma das coleções.</param>
        <param name="millisecondsTimeout">O número de milissegundos para aguardar ou <see cref="F:System.Threading.Timeout.Infinite" /> (- 1) para aguardar indefinidamente.</param>
        <param name="cancellationToken">Um token de cancelamento a ser observado.</param>
        <summary>Tenta remover um item de qualquer uma das instâncias <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> especificadas.</summary>
        <returns>O índice da coleção na matriz <paramref name="collections" /> da qual o item foi removido ou -1 caso um item não possa ser removido.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Uma chamada para TryTakeFromAny pode ser bloqueada até que um item esteja disponível para ser removido.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OperationCanceledException">Se o padrão <see cref="T:System.Threading.CancellationToken" /> for cancelado.</exception>
        <exception cref="T:System.InvalidOperationException">Pelo menos uma das coleções subjacentes foi alterada fora da instância de <see cref="T:System.Collections.Concurrent.BlockingCollection`1" />.</exception>
        <exception cref="T:System.ArgumentNullException">O argumento <paramref name="collections" /> é nulo.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="millisecondsTimeout" /> é um número negativo diferente de -1, que representa um tempo limite infinito. 
- ou - 
A contagem de <paramref name="collections" /> é maior que o tamanho máximo de 62 para STA e 63 para MTA.</exception>
        <exception cref="T:System.ArgumentException">O argumento <paramref name="collections" /> é uma matriz de tamanho 0 ou contém um elemento nulo.</exception>
        <exception cref="T:System.ObjectDisposedException">Pelo menos uma das instâncias de <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> foi descartada.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/2e7ca21f-786c-4367-96be-0cf3f3dcc6bd">Coleções thread-safe</related>
        <related type="Article" href="https://msdn.microsoft.com/library/987ea3d7-0ad5-4238-8b64-331ce4eb3f0b">Visão geral de BlockingCollection</related>
      </Docs>
    </Member>
  </Members>
</Type>