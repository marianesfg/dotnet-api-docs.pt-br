<Type Name="ConcurrentDictionary&lt;TKey,TValue&gt;" FullName="System.Collections.Concurrent.ConcurrentDictionary&lt;TKey,TValue&gt;">
  <Metadata><Meta Name="ms.openlocfilehash" Value="44d82d0e0d60f0a0bad84e94daa72d27a4b4b18f" /><Meta Name="ms.sourcegitcommit" Value="adc8598fd19d91438cacaa8fa7ce613e28c8218e" /><Meta Name="ms.translationtype" Value="HT" /><Meta Name="ms.contentlocale" Value="pt-BR" /><Meta Name="ms.lasthandoff" Value="12/11/2018" /><Meta Name="ms.locfileid" Value="53226549" /></Metadata><TypeSignature Language="C#" Value="public class ConcurrentDictionary&lt;TKey,TValue&gt; : System.Collections.Generic.ICollection&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;, System.Collections.Generic.IDictionary&lt;TKey,TValue&gt;, System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;, System.Collections.Generic.IReadOnlyCollection&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;, System.Collections.Generic.IReadOnlyDictionary&lt;TKey,TValue&gt;, System.Collections.IDictionary" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit ConcurrentDictionary`2&lt;TKey, TValue&gt; extends System.Object implements class System.Collections.Generic.ICollection`1&lt;valuetype System.Collections.Generic.KeyValuePair`2&lt;!TKey, !TValue&gt;&gt;, class System.Collections.Generic.IDictionary`2&lt;!TKey, !TValue&gt;, class System.Collections.Generic.IEnumerable`1&lt;valuetype System.Collections.Generic.KeyValuePair`2&lt;!TKey, !TValue&gt;&gt;, class System.Collections.Generic.IReadOnlyCollection`1&lt;valuetype System.Collections.Generic.KeyValuePair`2&lt;!TKey, !TValue&gt;&gt;, class System.Collections.Generic.IReadOnlyDictionary`2&lt;!TKey, !TValue&gt;, class System.Collections.ICollection, class System.Collections.IDictionary, class System.Collections.IEnumerable" />
  <TypeSignature Language="DocId" Value="T:System.Collections.Concurrent.ConcurrentDictionary`2" />
  <TypeSignature Language="VB.NET" Value="Public Class ConcurrentDictionary(Of TKey, TValue)&#xA;Implements ICollection(Of KeyValuePair(Of TKey, TValue)), IDictionary, IDictionary(Of TKey, TValue), IEnumerable(Of KeyValuePair(Of TKey, TValue)), IReadOnlyCollection(Of KeyValuePair(Of TKey, TValue)), IReadOnlyDictionary(Of TKey, TValue)" />
  <TypeSignature Language="C++ CLI" Value="generic &lt;typename TKey, typename TValue&gt;&#xA;public ref class ConcurrentDictionary : System::Collections::Generic::ICollection&lt;System::Collections::Generic::KeyValuePair&lt;TKey, TValue&gt;&gt;, System::Collections::Generic::IDictionary&lt;TKey, TValue&gt;, System::Collections::Generic::IEnumerable&lt;System::Collections::Generic::KeyValuePair&lt;TKey, TValue&gt;&gt;, System::Collections::Generic::IReadOnlyCollection&lt;System::Collections::Generic::KeyValuePair&lt;TKey, TValue&gt;&gt;, System::Collections::Generic::IReadOnlyDictionary&lt;TKey, TValue&gt;, System::Collections::IDictionary" />
  <TypeSignature Language="F#" Value="type ConcurrentDictionary&lt;'Key, 'Value&gt; = class&#xA;    interface IDictionary&lt;'Key, 'Value&gt;&#xA;    interface IDictionary&#xA;    interface IReadOnlyDictionary&lt;'Key, 'Value&gt;&#xA;    interface ICollection&lt;KeyValuePair&lt;'Key, 'Value&gt;&gt;&#xA;    interface seq&lt;KeyValuePair&lt;'Key, 'Value&gt;&gt;&#xA;    interface IEnumerable&#xA;    interface ICollection&#xA;    interface IReadOnlyCollection&lt;KeyValuePair&lt;'Key, 'Value&gt;&gt;" />
  <AssemblyInfo>
    <AssemblyName>System.Collections.Concurrent</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.14.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <TypeParameters>
    <TypeParameter Name="TKey" />
    <TypeParameter Name="TValue" />
  </TypeParameters>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Collections.Generic.ICollection&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.Generic.IDictionary&lt;TKey,TValue&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.Generic.IEnumerable&lt;T&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.Generic.IReadOnlyCollection&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.Generic.IReadOnlyDictionary&lt;TKey,TValue&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.ICollection</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.IDictionary</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.IEnumerable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Diagnostics.DebuggerDisplay("Count = {Count}")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Diagnostics.DebuggerTypeProxy(typeof(System.Collections.Generic.Mscorlib_DictionaryDebugView`2))</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <typeparam name="TKey"><span data-ttu-id="35415-101">O tipo das chaves no dicionário.</span><span class="sxs-lookup"><span data-stu-id="35415-101">The type of the keys in the dictionary.</span></span></typeparam>
    <typeparam name="TValue"><span data-ttu-id="35415-102">O tipo dos valores no dicionário.</span><span class="sxs-lookup"><span data-stu-id="35415-102">The type of the values in the dictionary.</span></span></typeparam>
    <summary><span data-ttu-id="35415-103">Representa uma coleção thread-safe de pares chave-valor que podem ser acessados por vários threads ao mesmo tempo.</span><span class="sxs-lookup"><span data-stu-id="35415-103">Represents a thread-safe collection of key/value pairs that can be accessed by multiple threads concurrently.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="35415-104">Para grandes <xref:System.Collections.Concurrent.ConcurrentDictionary%602> objetos, você pode aumentar o tamanho máximo da matriz a 2 gigabytes (GB) em um sistema de 64 bits, definindo o elemento de configuração como `true` no ambiente de tempo de execução.</span><span class="sxs-lookup"><span data-stu-id="35415-104">For very large <xref:System.Collections.Concurrent.ConcurrentDictionary%602> objects, you can increase the maximum array size to 2 gigabytes (GB) on a 64-bit system by setting the  configuration element to `true` in the run-time environment.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="35415-105"><xref:System.Collections.Concurrent.ConcurrentDictionary%602> implementa o <xref:System.Collections.Generic.IReadOnlyCollection%601> e <xref:System.Collections.Generic.IReadOnlyDictionary%602> interfaces começando com o [!INCLUDE[net_v46](~/includes/net-v46-md.md)]; em versões anteriores do .NET Framework, o <xref:System.Collections.Concurrent.ConcurrentDictionary%602> classe não implementou essas interfaces.</span><span class="sxs-lookup"><span data-stu-id="35415-105"><xref:System.Collections.Concurrent.ConcurrentDictionary%602> implements the <xref:System.Collections.Generic.IReadOnlyCollection%601> and <xref:System.Collections.Generic.IReadOnlyDictionary%602> interfaces starting with the [!INCLUDE[net_v46](~/includes/net-v46-md.md)]; in previous versions of the .NET Framework, the <xref:System.Collections.Concurrent.ConcurrentDictionary%602> class did not implement these interfaces.</span></span>  
  
 <span data-ttu-id="35415-106">Como o <xref:System.Collections.Generic.Dictionary%602?displayProperty=nameWithType> classe, <xref:System.Collections.Concurrent.ConcurrentDictionary%602> implementa o <xref:System.Collections.Generic.IDictionary%602> interface.</span><span class="sxs-lookup"><span data-stu-id="35415-106">Like the <xref:System.Collections.Generic.Dictionary%602?displayProperty=nameWithType> class, <xref:System.Collections.Concurrent.ConcurrentDictionary%602> implements the <xref:System.Collections.Generic.IDictionary%602> interface.</span></span> <span data-ttu-id="35415-107">Além disso, <xref:System.Collections.Concurrent.ConcurrentDictionary%602> fornece vários métodos para adicionar ou atualizar os pares chave/valor no dicionário, conforme descrito na tabela a seguir.</span><span class="sxs-lookup"><span data-stu-id="35415-107">In addition, <xref:System.Collections.Concurrent.ConcurrentDictionary%602> provides several methods for adding or updating key/value pairs in the dictionary, as described in the following table.</span></span>  
  
|<span data-ttu-id="35415-108">Para fazer isso</span><span class="sxs-lookup"><span data-stu-id="35415-108">To do this</span></span>|<span data-ttu-id="35415-109">Use esse método</span><span class="sxs-lookup"><span data-stu-id="35415-109">Use this method</span></span>|<span data-ttu-id="35415-110">Notas de uso</span><span class="sxs-lookup"><span data-stu-id="35415-110">Usage notes</span></span>|  
|----------------|---------------------|-----------------|  
|<span data-ttu-id="35415-111">Adicione uma nova chave no dicionário, se ele ainda não existir no dicionário</span><span class="sxs-lookup"><span data-stu-id="35415-111">Add a new key to the dictionary, if it doesn't already exist in the dictionary</span></span>|<xref:System.Collections.Concurrent.ConcurrentDictionary%602.TryAdd%2A>|<span data-ttu-id="35415-112">Esse método adiciona o par chave/valor especificado, se a chave no momento, não existe no dicionário.</span><span class="sxs-lookup"><span data-stu-id="35415-112">This method adds the specified key/value pair, if the key doesn't currently exist in the dictionary.</span></span> <span data-ttu-id="35415-113">O método retornará `true` ou `false` dependendo se o novo par foi adicionado.</span><span class="sxs-lookup"><span data-stu-id="35415-113">The method returns `true` or `false` depending on whether the new pair was added.</span></span>|  
|<span data-ttu-id="35415-114">Atualize o valor de uma chave existente no dicionário, se essa chave tem um valor específico</span><span class="sxs-lookup"><span data-stu-id="35415-114">Update the value for an existing key in the dictionary, if that key has a specific value</span></span>|<xref:System.Collections.Concurrent.ConcurrentDictionary%602.TryUpdate%2A>|<span data-ttu-id="35415-115">Esse método verifica se a chave tem um valor especificado e, se ele, atualiza a chave com um novo valor.</span><span class="sxs-lookup"><span data-stu-id="35415-115">This method checks whether the key has a specified value, and if it does, updates the key with a new value.</span></span> <span data-ttu-id="35415-116">Ele é semelhante ao <xref:System.Threading.Interlocked.CompareExchange%2A> método, exceto que ele usado para elementos do dicionário.</span><span class="sxs-lookup"><span data-stu-id="35415-116">It's similar to the <xref:System.Threading.Interlocked.CompareExchange%2A> method, except that it's used for dictionary elements.</span></span>|  
|<span data-ttu-id="35415-117">Store um par chave/valor no dicionário incondicionalmente e substituir o valor de uma chave que já existe</span><span class="sxs-lookup"><span data-stu-id="35415-117">Store a key/value pair in the dictionary unconditionally, and overwrite the value of a key that already exists</span></span>|<span data-ttu-id="35415-118">Setter do indexador: `dictionary[key] = newValue`</span><span class="sxs-lookup"><span data-stu-id="35415-118">The indexer's setter: `dictionary[key] = newValue`</span></span>||  
|<span data-ttu-id="35415-119">Adicionar um par chave/valor ao dicionário, ou se a chave já existir, atualize o valor da chave com base no valor existente da chave</span><span class="sxs-lookup"><span data-stu-id="35415-119">Add a key/value pair to the dictionary, or if the key already exists, update the value for the key based on the key's existing value</span></span>|<xref:System.Collections.Concurrent.ConcurrentDictionary%602.AddOrUpdate%28%600%2CSystem.Func%7B%600%2C%601%7D%2CSystem.Func%7B%600%2C%601%2C%601%7D%29><br /><br /> <span data-ttu-id="35415-120">- ou -</span><span class="sxs-lookup"><span data-stu-id="35415-120">-or-</span></span><br /><br /> <xref:System.Collections.Concurrent.ConcurrentDictionary%602.AddOrUpdate%28%600%2C%601%2CSystem.Func%7B%600%2C%601%2C%601%7D%29>|<span data-ttu-id="35415-121"><xref:System.Collections.Concurrent.ConcurrentDictionary%602.AddOrUpdate%28%600%2CSystem.Func%7B%600%2C%601%7D%2CSystem.Func%7B%600%2C%601%2C%601%7D%29> aceita a chave e dois delegados.</span><span class="sxs-lookup"><span data-stu-id="35415-121"><xref:System.Collections.Concurrent.ConcurrentDictionary%602.AddOrUpdate%28%600%2CSystem.Func%7B%600%2C%601%7D%2CSystem.Func%7B%600%2C%601%2C%601%7D%29> accepts the key and two delegates.</span></span> <span data-ttu-id="35415-122">Ele usa o primeiro delegado se a chave não existir no dicionário. ele aceita a tecla e retorna o valor que deve ser adicionado para a chave.</span><span class="sxs-lookup"><span data-stu-id="35415-122">It uses the first delegate if the key doesn't exist in the dictionary; it accepts the key and returns the value that should be added for the key.</span></span> <span data-ttu-id="35415-123">Ele usa o segundo delegado se a chave existir; ele aceita a chave e seu valor atual e retorna o novo valor deve ser definido para a chave.</span><span class="sxs-lookup"><span data-stu-id="35415-123">It uses the second delegate if the key does exist; it accepts the key and its current value, and it returns the new value that should be set for the key.</span></span><br /><br /> <span data-ttu-id="35415-124"><xref:System.Collections.Concurrent.ConcurrentDictionary%602.AddOrUpdate%28%600%2C%601%2CSystem.Func%7B%600%2C%601%2C%601%7D%29> aceita a chave, um valor a ser adicionado e o delegado de atualização.</span><span class="sxs-lookup"><span data-stu-id="35415-124"><xref:System.Collections.Concurrent.ConcurrentDictionary%602.AddOrUpdate%28%600%2C%601%2CSystem.Func%7B%600%2C%601%2C%601%7D%29> accepts the key, a value to add, and the update delegate.</span></span> <span data-ttu-id="35415-125">Isso é o mesmo que a sobrecarga anterior, exceto que ele não usa um delegado para adicionar uma chave.</span><span class="sxs-lookup"><span data-stu-id="35415-125">This is the same as the previous overload, except that it doesn't use a delegate to add a key.</span></span>|  
|<span data-ttu-id="35415-126">Obter o valor para uma chave no dicionário, adicionando o valor ao dicionário e retorná-lo se a chave não existir</span><span class="sxs-lookup"><span data-stu-id="35415-126">Get the value for a key in the dictionary, adding the value to the dictionary and returning it if the key doesn't exist</span></span>|<xref:System.Collections.Concurrent.ConcurrentDictionary%602.GetOrAdd%28%600%2C%601%29><br /><br /> <span data-ttu-id="35415-127">- ou -</span><span class="sxs-lookup"><span data-stu-id="35415-127">-or-</span></span><br /><br /> <xref:System.Collections.Concurrent.ConcurrentDictionary%602.GetOrAdd%28%600%2CSystem.Func%7B%600%2C%601%7D%29>|<span data-ttu-id="35415-128">Essas sobrecargas fornecem a inicialização lenta para um par chave/valor no dicionário, adicionando o valor somente se ele não estiver lá.</span><span class="sxs-lookup"><span data-stu-id="35415-128">These overloads provide lazy initialization for a key/value pair in the dictionary, adding the value only if it's not there.</span></span><br /><br /> <span data-ttu-id="35415-129"><xref:System.Collections.Concurrent.ConcurrentDictionary%602.GetOrAdd%28%600%2C%601%29> Obtém o valor a ser adicionado se a chave não existir.</span><span class="sxs-lookup"><span data-stu-id="35415-129"><xref:System.Collections.Concurrent.ConcurrentDictionary%602.GetOrAdd%28%600%2C%601%29> takes the value to be added if the key doesn't exist.</span></span><br /><br /> <span data-ttu-id="35415-130"><xref:System.Collections.Concurrent.ConcurrentDictionary%602.GetOrAdd%28%600%2CSystem.Func%7B%600%2C%601%7D%29> leva um delegado que irá gerar o valor se a chave não existir.</span><span class="sxs-lookup"><span data-stu-id="35415-130"><xref:System.Collections.Concurrent.ConcurrentDictionary%602.GetOrAdd%28%600%2CSystem.Func%7B%600%2C%601%7D%29> takes a delegate that will generate the value if the key doesn't exist.</span></span>|  
  
 <span data-ttu-id="35415-131">Todas essas operações são atômicas e são thread-safe com relação a todas as outras operações no <xref:System.Collections.Concurrent.ConcurrentDictionary%602> classe.</span><span class="sxs-lookup"><span data-stu-id="35415-131">All these operations are atomic and are thread-safe with regards to all other operations on the <xref:System.Collections.Concurrent.ConcurrentDictionary%602> class.</span></span> <span data-ttu-id="35415-132">As únicas exceções são os métodos que aceitam um delegado, ou seja, <xref:System.Collections.Concurrent.ConcurrentDictionary%602.AddOrUpdate%2A> e <xref:System.Collections.Concurrent.ConcurrentDictionary%602.GetOrAdd%2A>.</span><span class="sxs-lookup"><span data-stu-id="35415-132">The only exceptions are the methods that accept a delegate, that is, <xref:System.Collections.Concurrent.ConcurrentDictionary%602.AddOrUpdate%2A> and <xref:System.Collections.Concurrent.ConcurrentDictionary%602.GetOrAdd%2A>.</span></span> <span data-ttu-id="35415-133">Para operações de gravação ao dicionário e modificações <xref:System.Collections.Concurrent.ConcurrentDictionary%602> usa bloqueio refinado para garantir acesso thread-safe.</span><span class="sxs-lookup"><span data-stu-id="35415-133">For modifications and write operations to the dictionary, <xref:System.Collections.Concurrent.ConcurrentDictionary%602> uses fine-grained locking to ensure thread safety.</span></span> <span data-ttu-id="35415-134">(As operações de leitura no dicionário são executadas de forma livre de bloqueios). No entanto, os delegados para esses métodos são chamados fora os bloqueios para evitar os problemas que possam surgir na execução de um código desconhecido em um bloqueio.</span><span class="sxs-lookup"><span data-stu-id="35415-134">(Read operations on the dictionary are performed in a lock-free manner.) However, delegates for these methods are called outside the locks to avoid the problems that can arise from executing unknown code under a lock.</span></span> <span data-ttu-id="35415-135">Portanto, o código executado por esses delegados não é sujeito à atomicidade da operação.</span><span class="sxs-lookup"><span data-stu-id="35415-135">Therefore, the code executed by these delegates is not subject to the atomicity of the operation.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="35415-136">O exemplo a seguir mostra como construir um <xref:System.Collections.Concurrent.ConcurrentDictionary%602> objeto.</span><span class="sxs-lookup"><span data-stu-id="35415-136">The following example shows how to construct a <xref:System.Collections.Concurrent.ConcurrentDictionary%602> object.</span></span>  
  
 [!code-csharp[System.Collections.Concurrent.ConcurrentDictionary#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.collections.concurrent.concurrentdictionary/cs/concdictionary.cs#1)]
 [!code-vb[System.Collections.Concurrent.ConcurrentDictionary#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.collections.concurrent.concurrentdictionary/vb/concdictionary.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe><span data-ttu-id="35415-137">Todos os membros públicos e protegidos da <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" /> são thread-safe e podem ser usados simultaneamente de vários threads.</span><span class="sxs-lookup"><span data-stu-id="35415-137">All public and protected members of <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" /> are thread-safe and may be used concurrently from multiple threads.</span></span> <span data-ttu-id="35415-138">No entanto, os membros são acessados por meio de uma das interfaces a <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" /> implementa, incluindo métodos de extensão, não há garantia de ser thread-safe e talvez precise ser sincronizada pelo chamador.</span><span class="sxs-lookup"><span data-stu-id="35415-138">However, members accessed through one of the interfaces the <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" /> implements, including extension methods, are not guaranteed to be thread safe and may need to be synchronized by the caller.</span></span></threadsafe>
    <related type="Article" href="https://msdn.microsoft.com/library/2e7ca21f-786c-4367-96be-0cf3f3dcc6bd"><span data-ttu-id="35415-139">Coleções thread-safe</span><span class="sxs-lookup"><span data-stu-id="35415-139">Thread-Safe Collections</span></span></related>
    <related type="Article" href="https://msdn.microsoft.com/library/81b64b95-13f7-4532-9249-ab532f629598"><span data-ttu-id="35415-140">Como adicionar e remover itens de um ConcurrentDictionary</span><span class="sxs-lookup"><span data-stu-id="35415-140">How to: Add and Remove Items from a ConcurrentDictionary</span></span></related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="35415-141">Inicializa uma nova instância da classe <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" />.</span><span class="sxs-lookup"><span data-stu-id="35415-141">Initializes a new instance of the <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" /> class.</span></span></summary>
        <related type="Article" href="https://msdn.microsoft.com/library/2e7ca21f-786c-4367-96be-0cf3f3dcc6bd"><span data-ttu-id="35415-142">Coleções thread-safe</span><span class="sxs-lookup"><span data-stu-id="35415-142">Thread-Safe Collections</span></span></related>
        <related type="Article" href="https://msdn.microsoft.com/library/81b64b95-13f7-4532-9249-ab532f629598"><span data-ttu-id="35415-143">Como adicionar e remover itens de um ConcurrentDictionary</span><span class="sxs-lookup"><span data-stu-id="35415-143">How to: Add and Remove Items from a ConcurrentDictionary</span></span></related>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ConcurrentDictionary ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Concurrent.ConcurrentDictionary`2.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; ConcurrentDictionary();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="35415-144">Inicializa uma nova instância da classe <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" /> que está vazia, tem o nível de simultaneidade padrão, tem a capacidade inicial padrão e usa o comparador padrão para o tipo de chave.</span><span class="sxs-lookup"><span data-stu-id="35415-144">Initializes a new instance of the <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" /> class that is empty, has the default concurrency level, has the default initial capacity, and uses the default comparer for the key type.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="35415-145">O nível de simultaneidade padrão é igual ao número de CPUs.</span><span class="sxs-lookup"><span data-stu-id="35415-145">The default concurrency level is equal to the number of CPUs.</span></span> <span data-ttu-id="35415-146">Quanto maior o nível de simultaneidade é, as operações de gravação mais simultâneas podem ocorrer sem interferência e bloquear.</span><span class="sxs-lookup"><span data-stu-id="35415-146">The higher the concurrency level is, the more concurrent write operations can take place without interference and blocking.</span></span> <span data-ttu-id="35415-147">Valores mais altos de nível de simultaneidade também fazer com que as operações que exigem a todos os bloqueios (por exemplo, o redimensionamento, a tabela `ToArray` e `Count`) para se tornar mais caros.</span><span class="sxs-lookup"><span data-stu-id="35415-147">Higher concurrency level values also cause operations that require all locks (for example, table resizing, `ToArray` and `Count`) to become more expensive.</span></span> <span data-ttu-id="35415-148">A capacidade padrão (DEFAULT_CAPACITY), que representa o número inicial de buckets, é uma compensação entre o tamanho de um dicionário muito pequeno e o número de redimensionamentos ao construir um dicionário grande.</span><span class="sxs-lookup"><span data-stu-id="35415-148">The default capacity (DEFAULT_CAPACITY), which represents the initial number of buckets, is a trade-off between the size of a very small dictionary and the number of resizes when constructing a large dictionary.</span></span> <span data-ttu-id="35415-149">Além disso, a capacidade não deve ser divisível por um pequeno número primo.</span><span class="sxs-lookup"><span data-stu-id="35415-149">Also, the capacity should not be divisible by a small prime number.</span></span> <span data-ttu-id="35415-150">A capacidade padrão é 31.</span><span class="sxs-lookup"><span data-stu-id="35415-150">The default capacity is 31.</span></span>  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/2e7ca21f-786c-4367-96be-0cf3f3dcc6bd"><span data-ttu-id="35415-151">Coleções thread-safe</span><span class="sxs-lookup"><span data-stu-id="35415-151">Thread-Safe Collections</span></span></related>
        <related type="Article" href="https://msdn.microsoft.com/library/81b64b95-13f7-4532-9249-ab532f629598"><span data-ttu-id="35415-152">Como adicionar e remover itens de um ConcurrentDictionary</span><span class="sxs-lookup"><span data-stu-id="35415-152">How to: Add and Remove Items from a ConcurrentDictionary</span></span></related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ConcurrentDictionary (System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt; collection);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Collections.Generic.IEnumerable`1&lt;valuetype System.Collections.Generic.KeyValuePair`2&lt;!TKey, !TValue&gt;&gt; collection) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Concurrent.ConcurrentDictionary`2.#ctor(System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{`0,`1}})" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (collection As IEnumerable(Of KeyValuePair(Of TKey, TValue)))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; ConcurrentDictionary(System::Collections::Generic::IEnumerable&lt;System::Collections::Generic::KeyValuePair&lt;TKey, TValue&gt;&gt; ^ collection);" />
      <MemberSignature Language="F#" Value="new System.Collections.Concurrent.ConcurrentDictionary&lt;'Key, 'Value&gt; : seq&lt;System.Collections.Generic.KeyValuePair&lt;'Key, 'Value&gt;&gt; -&gt; System.Collections.Concurrent.ConcurrentDictionary&lt;'Key, 'Value&gt;" Usage="new System.Collections.Concurrent.ConcurrentDictionary&lt;'Key, 'Value&gt; collection" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="collection" Type="System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;" />
      </Parameters>
      <Docs>
        <param name="collection"><span data-ttu-id="35415-153">O <see cref="T:System.Collections.Generic.IEnumerable`1" /> cujos elementos são copiados para o novo <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" />.</span><span class="sxs-lookup"><span data-stu-id="35415-153">The <see cref="T:System.Collections.Generic.IEnumerable`1" /> whose elements are copied to the new <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" />.</span></span></param>
        <summary><span data-ttu-id="35415-154">Inicializa uma nova instância da classe <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" /> que contém elementos copiados do <see cref="T:System.Collections.Generic.IEnumerable`1" /> especificado, tem o nível de simultaneidade padrão, tem a capacidade inicial padrão e usa o comparador padrão para o tipo de chave.</span><span class="sxs-lookup"><span data-stu-id="35415-154">Initializes a new instance of the <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" /> class that contains elements copied from the specified <see cref="T:System.Collections.Generic.IEnumerable`1" />, has the default concurrency level, has the default initial capacity, and uses the default comparer for the key type.</span></span></summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="35415-155"><paramref name="collection" /> ou qualquer uma de suas chaves é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="35415-155"><paramref name="collection" /> or any of its keys is  <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="35415-156"><paramref name="collection" /> contém uma ou mais chaves duplicadas.</span><span class="sxs-lookup"><span data-stu-id="35415-156"><paramref name="collection" /> contains one or more duplicate keys.</span></span></exception>
        <related type="Article" href="https://msdn.microsoft.com/library/2e7ca21f-786c-4367-96be-0cf3f3dcc6bd"><span data-ttu-id="35415-157">Coleções thread-safe</span><span class="sxs-lookup"><span data-stu-id="35415-157">Thread-Safe Collections</span></span></related>
        <related type="Article" href="https://msdn.microsoft.com/library/81b64b95-13f7-4532-9249-ab532f629598"><span data-ttu-id="35415-158">Como adicionar e remover itens de um ConcurrentDictionary</span><span class="sxs-lookup"><span data-stu-id="35415-158">How to: Add and Remove Items from a ConcurrentDictionary</span></span></related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ConcurrentDictionary (System.Collections.Generic.IEqualityComparer&lt;TKey&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Collections.Generic.IEqualityComparer`1&lt;!TKey&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Concurrent.ConcurrentDictionary`2.#ctor(System.Collections.Generic.IEqualityComparer{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (comparer As IEqualityComparer(Of TKey))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; ConcurrentDictionary(System::Collections::Generic::IEqualityComparer&lt;TKey&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="new System.Collections.Concurrent.ConcurrentDictionary&lt;'Key, 'Value&gt; : System.Collections.Generic.IEqualityComparer&lt;'Key&gt; -&gt; System.Collections.Concurrent.ConcurrentDictionary&lt;'Key, 'Value&gt;" Usage="new System.Collections.Concurrent.ConcurrentDictionary&lt;'Key, 'Value&gt; comparer" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="comparer" Type="System.Collections.Generic.IEqualityComparer&lt;TKey&gt;" />
      </Parameters>
      <Docs>
        <param name="comparer"><span data-ttu-id="35415-159">A implementação de comparação de igualdade a ser usada ao comparar chaves.</span><span class="sxs-lookup"><span data-stu-id="35415-159">The equality comparison implementation to use when comparing keys.</span></span></param>
        <summary><span data-ttu-id="35415-160">Inicializa uma nova instância da classe <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" /> que está vazia, tem a capacidade e o nível de simultaneidade padrão e usa o <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> especificado.</span><span class="sxs-lookup"><span data-stu-id="35415-160">Initializes a new instance of the <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" /> class that is empty, has the default concurrency level and capacity, and uses the specified <see cref="T:System.Collections.Generic.IEqualityComparer`1" />.</span></span></summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="35415-161"><paramref name="comparer" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="35415-161"><paramref name="comparer" /> is <see langword="null" />.</span></span></exception>
        <related type="Article" href="https://msdn.microsoft.com/library/2e7ca21f-786c-4367-96be-0cf3f3dcc6bd"><span data-ttu-id="35415-162">Coleções thread-safe</span><span class="sxs-lookup"><span data-stu-id="35415-162">Thread-Safe Collections</span></span></related>
        <related type="Article" href="https://msdn.microsoft.com/library/81b64b95-13f7-4532-9249-ab532f629598"><span data-ttu-id="35415-163">Como adicionar e remover itens de um ConcurrentDictionary</span><span class="sxs-lookup"><span data-stu-id="35415-163">How to: Add and Remove Items from a ConcurrentDictionary</span></span></related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ConcurrentDictionary (System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt; collection, System.Collections.Generic.IEqualityComparer&lt;TKey&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Collections.Generic.IEnumerable`1&lt;valuetype System.Collections.Generic.KeyValuePair`2&lt;!TKey, !TValue&gt;&gt; collection, class System.Collections.Generic.IEqualityComparer`1&lt;!TKey&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Concurrent.ConcurrentDictionary`2.#ctor(System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{`0,`1}},System.Collections.Generic.IEqualityComparer{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (collection As IEnumerable(Of KeyValuePair(Of TKey, TValue)), comparer As IEqualityComparer(Of TKey))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; ConcurrentDictionary(System::Collections::Generic::IEnumerable&lt;System::Collections::Generic::KeyValuePair&lt;TKey, TValue&gt;&gt; ^ collection, System::Collections::Generic::IEqualityComparer&lt;TKey&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="new System.Collections.Concurrent.ConcurrentDictionary&lt;'Key, 'Value&gt; : seq&lt;System.Collections.Generic.KeyValuePair&lt;'Key, 'Value&gt;&gt; * System.Collections.Generic.IEqualityComparer&lt;'Key&gt; -&gt; System.Collections.Concurrent.ConcurrentDictionary&lt;'Key, 'Value&gt;" Usage="new System.Collections.Concurrent.ConcurrentDictionary&lt;'Key, 'Value&gt; (collection, comparer)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="collection" Type="System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IEqualityComparer&lt;TKey&gt;" />
      </Parameters>
      <Docs>
        <param name="collection"><span data-ttu-id="35415-164">O <see cref="T:System.Collections.Generic.IEnumerable`1" /> cujos elementos são copiados para o novo <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" />.</span><span class="sxs-lookup"><span data-stu-id="35415-164">The <see cref="T:System.Collections.Generic.IEnumerable`1" /> whose elements are copied to the new <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" />.</span></span></param>
        <param name="comparer"><span data-ttu-id="35415-165">A implementação de <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> a ser usada ao comparar chaves.</span><span class="sxs-lookup"><span data-stu-id="35415-165">The <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> implementation to use when comparing keys.</span></span></param>
        <summary><span data-ttu-id="35415-166">Inicializa uma nova instância da classe <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" /> que contém elementos copiados do <see cref="T:System.Collections.IEnumerable" /> especificado, tem o nível de simultaneidade padrão, tem a capacidade inicial padrão e usa o <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> especificado.</span><span class="sxs-lookup"><span data-stu-id="35415-166">Initializes a new instance of the <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" /> class that contains elements copied from the specified <see cref="T:System.Collections.IEnumerable" /> has the default concurrency level, has the default initial capacity, and uses the specified  <see cref="T:System.Collections.Generic.IEqualityComparer`1" />.</span></span></summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="35415-167"><paramref name="collection" /> ou <paramref name="comparer" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="35415-167"><paramref name="collection" /> or <paramref name="comparer" /> is <see langword="null" />.</span></span></exception>
        <related type="Article" href="https://msdn.microsoft.com/library/2e7ca21f-786c-4367-96be-0cf3f3dcc6bd"><span data-ttu-id="35415-168">Coleções thread-safe</span><span class="sxs-lookup"><span data-stu-id="35415-168">Thread-Safe Collections</span></span></related>
        <related type="Article" href="https://msdn.microsoft.com/library/81b64b95-13f7-4532-9249-ab532f629598"><span data-ttu-id="35415-169">Como adicionar e remover itens de um ConcurrentDictionary</span><span class="sxs-lookup"><span data-stu-id="35415-169">How to: Add and Remove Items from a ConcurrentDictionary</span></span></related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ConcurrentDictionary (int concurrencyLevel, int capacity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 concurrencyLevel, int32 capacity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Concurrent.ConcurrentDictionary`2.#ctor(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (concurrencyLevel As Integer, capacity As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; ConcurrentDictionary(int concurrencyLevel, int capacity);" />
      <MemberSignature Language="F#" Value="new System.Collections.Concurrent.ConcurrentDictionary&lt;'Key, 'Value&gt; : int * int -&gt; System.Collections.Concurrent.ConcurrentDictionary&lt;'Key, 'Value&gt;" Usage="new System.Collections.Concurrent.ConcurrentDictionary&lt;'Key, 'Value&gt; (concurrencyLevel, capacity)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="concurrencyLevel" Type="System.Int32" />
        <Parameter Name="capacity" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="concurrencyLevel"><span data-ttu-id="35415-170">O número estimado de threads que atualizará o <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" /> simultaneamente.</span><span class="sxs-lookup"><span data-stu-id="35415-170">The estimated number of threads that will update the <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" /> concurrently.</span></span></param>
        <param name="capacity"><span data-ttu-id="35415-171">O número inicial de elementos que o <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" /> pode conter.</span><span class="sxs-lookup"><span data-stu-id="35415-171">The initial number of elements that the <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" /> can contain.</span></span></param>
        <summary><span data-ttu-id="35415-172">Inicializa uma nova instância da classe <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" /> que está vazia, tem a capacidade e o nível de simultaneidade especificados e usa o comparador padrão para o tipo de chave.</span><span class="sxs-lookup"><span data-stu-id="35415-172">Initializes a new instance of the <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" /> class that is empty, has the specified concurrency level and capacity, and uses the default comparer for the key type.</span></span></summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="35415-173"><paramref name="concurrencyLevel" /> é menor que 1.</span><span class="sxs-lookup"><span data-stu-id="35415-173"><paramref name="concurrencyLevel" /> is less than 1.</span></span>  
  
<span data-ttu-id="35415-174">- ou -</span><span class="sxs-lookup"><span data-stu-id="35415-174">-or-</span></span> 
 <span data-ttu-id="35415-175"><paramref name="capacity" /> é menor que 0.</span><span class="sxs-lookup"><span data-stu-id="35415-175"><paramref name="capacity" /> is less than 0.</span></span></exception>
        <related type="Article" href="https://msdn.microsoft.com/library/2e7ca21f-786c-4367-96be-0cf3f3dcc6bd"><span data-ttu-id="35415-176">Coleções thread-safe</span><span class="sxs-lookup"><span data-stu-id="35415-176">Thread-Safe Collections</span></span></related>
        <related type="Article" href="https://msdn.microsoft.com/library/81b64b95-13f7-4532-9249-ab532f629598"><span data-ttu-id="35415-177">Como adicionar e remover itens de um ConcurrentDictionary</span><span class="sxs-lookup"><span data-stu-id="35415-177">How to: Add and Remove Items from a ConcurrentDictionary</span></span></related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ConcurrentDictionary (int concurrencyLevel, System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt; collection, System.Collections.Generic.IEqualityComparer&lt;TKey&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 concurrencyLevel, class System.Collections.Generic.IEnumerable`1&lt;valuetype System.Collections.Generic.KeyValuePair`2&lt;!TKey, !TValue&gt;&gt; collection, class System.Collections.Generic.IEqualityComparer`1&lt;!TKey&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Concurrent.ConcurrentDictionary`2.#ctor(System.Int32,System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{`0,`1}},System.Collections.Generic.IEqualityComparer{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (concurrencyLevel As Integer, collection As IEnumerable(Of KeyValuePair(Of TKey, TValue)), comparer As IEqualityComparer(Of TKey))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; ConcurrentDictionary(int concurrencyLevel, System::Collections::Generic::IEnumerable&lt;System::Collections::Generic::KeyValuePair&lt;TKey, TValue&gt;&gt; ^ collection, System::Collections::Generic::IEqualityComparer&lt;TKey&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="new System.Collections.Concurrent.ConcurrentDictionary&lt;'Key, 'Value&gt; : int * seq&lt;System.Collections.Generic.KeyValuePair&lt;'Key, 'Value&gt;&gt; * System.Collections.Generic.IEqualityComparer&lt;'Key&gt; -&gt; System.Collections.Concurrent.ConcurrentDictionary&lt;'Key, 'Value&gt;" Usage="new System.Collections.Concurrent.ConcurrentDictionary&lt;'Key, 'Value&gt; (concurrencyLevel, collection, comparer)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="concurrencyLevel" Type="System.Int32" />
        <Parameter Name="collection" Type="System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IEqualityComparer&lt;TKey&gt;" />
      </Parameters>
      <Docs>
        <param name="concurrencyLevel"><span data-ttu-id="35415-178">O número estimado de threads que atualizará o <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" /> simultaneamente.</span><span class="sxs-lookup"><span data-stu-id="35415-178">The estimated number of threads that will update the <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" /> concurrently.</span></span></param>
        <param name="collection"><span data-ttu-id="35415-179">O <see cref="T:System.Collections.Generic.IEnumerable`1" /> cujos elementos são copiados para o novo <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" />.</span><span class="sxs-lookup"><span data-stu-id="35415-179">The <see cref="T:System.Collections.Generic.IEnumerable`1" /> whose elements are copied to the new <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" />.</span></span></param>
        <param name="comparer"><span data-ttu-id="35415-180">A implementação de <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> a ser usada ao comparar chaves.</span><span class="sxs-lookup"><span data-stu-id="35415-180">The <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> implementation to use when comparing keys.</span></span></param>
        <summary><span data-ttu-id="35415-181">Inicializa uma nova instância da classe <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" /> que contém elementos copiados da <see cref="T:System.Collections.IEnumerable" /> especificada e usa o <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> especificado.</span><span class="sxs-lookup"><span data-stu-id="35415-181">Initializes a new instance of the <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" /> class that contains elements copied from the specified <see cref="T:System.Collections.IEnumerable" />, and uses the specified <see cref="T:System.Collections.Generic.IEqualityComparer`1" />.</span></span></summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="35415-182"><paramref name="collection" /> ou <paramref name="comparer" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="35415-182"><paramref name="collection" /> or <paramref name="comparer" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="35415-183"><paramref name="concurrencyLevel" /> é menor que 1.</span><span class="sxs-lookup"><span data-stu-id="35415-183"><paramref name="concurrencyLevel" /> is less than 1.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="35415-184"><paramref name="collection" /> contém uma ou mais chaves duplicadas.</span><span class="sxs-lookup"><span data-stu-id="35415-184"><paramref name="collection" /> contains one or more duplicate keys.</span></span></exception>
        <related type="Article" href="https://msdn.microsoft.com/library/2e7ca21f-786c-4367-96be-0cf3f3dcc6bd"><span data-ttu-id="35415-185">Coleções thread-safe</span><span class="sxs-lookup"><span data-stu-id="35415-185">Thread-Safe Collections</span></span></related>
        <related type="Article" href="https://msdn.microsoft.com/library/81b64b95-13f7-4532-9249-ab532f629598"><span data-ttu-id="35415-186">Como adicionar e remover itens de um ConcurrentDictionary</span><span class="sxs-lookup"><span data-stu-id="35415-186">How to: Add and Remove Items from a ConcurrentDictionary</span></span></related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ConcurrentDictionary (int concurrencyLevel, int capacity, System.Collections.Generic.IEqualityComparer&lt;TKey&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 concurrencyLevel, int32 capacity, class System.Collections.Generic.IEqualityComparer`1&lt;!TKey&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Concurrent.ConcurrentDictionary`2.#ctor(System.Int32,System.Int32,System.Collections.Generic.IEqualityComparer{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (concurrencyLevel As Integer, capacity As Integer, comparer As IEqualityComparer(Of TKey))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; ConcurrentDictionary(int concurrencyLevel, int capacity, System::Collections::Generic::IEqualityComparer&lt;TKey&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="new System.Collections.Concurrent.ConcurrentDictionary&lt;'Key, 'Value&gt; : int * int * System.Collections.Generic.IEqualityComparer&lt;'Key&gt; -&gt; System.Collections.Concurrent.ConcurrentDictionary&lt;'Key, 'Value&gt;" Usage="new System.Collections.Concurrent.ConcurrentDictionary&lt;'Key, 'Value&gt; (concurrencyLevel, capacity, comparer)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="concurrencyLevel" Type="System.Int32" />
        <Parameter Name="capacity" Type="System.Int32" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IEqualityComparer&lt;TKey&gt;" />
      </Parameters>
      <Docs>
        <param name="concurrencyLevel"><span data-ttu-id="35415-187">O número estimado de threads que atualizará o <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" /> simultaneamente.</span><span class="sxs-lookup"><span data-stu-id="35415-187">The estimated number of threads that will update the <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" /> concurrently.</span></span></param>
        <param name="capacity"><span data-ttu-id="35415-188">O número inicial de elementos que o <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" /> pode conter.</span><span class="sxs-lookup"><span data-stu-id="35415-188">The initial number of elements that the <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" /> can contain.</span></span></param>
        <param name="comparer"><span data-ttu-id="35415-189">A implementação de <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> a ser usada ao comparar chaves.</span><span class="sxs-lookup"><span data-stu-id="35415-189">The <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> implementation to use when comparing keys.</span></span></param>
        <summary><span data-ttu-id="35415-190">Inicializa uma nova instância da classe <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" /> que está vazia, tem o nível se simultaneidade especificado, tem a capacidade inicial especificada e usa o <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> especificado.</span><span class="sxs-lookup"><span data-stu-id="35415-190">Initializes a new instance of the <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" /> class that is empty, has the specified concurrency level, has the specified initial capacity, and uses the specified <see cref="T:System.Collections.Generic.IEqualityComparer`1" />.</span></span></summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="35415-191"><paramref name="comparer" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="35415-191"><paramref name="comparer" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="35415-192"><paramref name="concurrencyLevel" /> ou <paramref name="capacity" /> é menor que 1.</span><span class="sxs-lookup"><span data-stu-id="35415-192"><paramref name="concurrencyLevel" /> or <paramref name="capacity" /> is less than 1.</span></span></exception>
        <related type="Article" href="https://msdn.microsoft.com/library/2e7ca21f-786c-4367-96be-0cf3f3dcc6bd"><span data-ttu-id="35415-193">Coleções thread-safe</span><span class="sxs-lookup"><span data-stu-id="35415-193">Thread-Safe Collections</span></span></related>
        <related type="Article" href="https://msdn.microsoft.com/library/81b64b95-13f7-4532-9249-ab532f629598"><span data-ttu-id="35415-194">Como adicionar e remover itens de um ConcurrentDictionary</span><span class="sxs-lookup"><span data-stu-id="35415-194">How to: Add and Remove Items from a ConcurrentDictionary</span></span></related>
      </Docs>
    </Member>
    <MemberGroup MemberName="AddOrUpdate">
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="35415-195">Adiciona um par chave/valor ao <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" /> se a chave ainda não existir ou atualiza um par chave/valor no <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" /> se a chave já existir.</span><span class="sxs-lookup"><span data-stu-id="35415-195">Adds a key/value pair to the <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" /> if the key does not already exist, or updates a key/value pair in the <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" /> if the key already exists.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="35415-196">O exemplo a seguir mostra como chamar o <xref:System.Collections.Concurrent.ConcurrentDictionary%602.AddOrUpdate%2A> método:</span><span class="sxs-lookup"><span data-stu-id="35415-196">The following example shows how to call the <xref:System.Collections.Concurrent.ConcurrentDictionary%602.AddOrUpdate%2A> method:</span></span>  
  
 [!code-csharp[System.Collections.Concurrent.ConcurrentDictionary#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.collections.concurrent.concurrentdictionary/cs/concdictionary.cs#3)]
 [!code-vb[System.Collections.Concurrent.ConcurrentDictionary#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.collections.concurrent.concurrentdictionary/vb/concdictionary.vb#3)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/2e7ca21f-786c-4367-96be-0cf3f3dcc6bd"><span data-ttu-id="35415-197">Coleções thread-safe</span><span class="sxs-lookup"><span data-stu-id="35415-197">Thread-Safe Collections</span></span></related>
        <related type="Article" href="https://msdn.microsoft.com/library/81b64b95-13f7-4532-9249-ab532f629598"><span data-ttu-id="35415-198">Como adicionar e remover itens de um ConcurrentDictionary</span><span class="sxs-lookup"><span data-stu-id="35415-198">How to: Add and Remove Items from a ConcurrentDictionary</span></span></related>
      </Docs>
    </MemberGroup>
    <Member MemberName="AddOrUpdate">
      <MemberSignature Language="C#" Value="public TValue AddOrUpdate (TKey key, Func&lt;TKey,TValue&gt; addValueFactory, Func&lt;TKey,TValue,TValue&gt; updateValueFactory);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance !TValue AddOrUpdate(!TKey key, class System.Func`2&lt;!TKey, !TValue&gt; addValueFactory, class System.Func`3&lt;!TKey, !TValue, !TValue&gt; updateValueFactory) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Concurrent.ConcurrentDictionary`2.AddOrUpdate(`0,System.Func{`0,`1},System.Func{`0,`1,`1})" />
      <MemberSignature Language="VB.NET" Value="Public Function AddOrUpdate (key As TKey, addValueFactory As Func(Of TKey, TValue), updateValueFactory As Func(Of TKey, TValue, TValue)) As TValue" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; TValue AddOrUpdate(TKey key, Func&lt;TKey, TValue&gt; ^ addValueFactory, Func&lt;TKey, TValue, TValue&gt; ^ updateValueFactory);" />
      <MemberSignature Language="F#" Value="member this.AddOrUpdate : 'Key * Func&lt;'Key, 'Value&gt; * Func&lt;'Key, 'Value, 'Value&gt; -&gt; 'Value" Usage="concurrentDictionary.AddOrUpdate (key, addValueFactory, updateValueFactory)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TValue</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="TKey" />
        <Parameter Name="addValueFactory" Type="System.Func&lt;TKey,TValue&gt;" />
        <Parameter Name="updateValueFactory" Type="System.Func&lt;TKey,TValue,TValue&gt;" />
      </Parameters>
      <Docs>
        <param name="key"><span data-ttu-id="35415-199">A chave a ser adicionada ou cujo valor deve ser atualizado</span><span class="sxs-lookup"><span data-stu-id="35415-199">The key to be added or whose value should be updated</span></span></param>
        <param name="addValueFactory"><span data-ttu-id="35415-200">A função usada para gerar um valor para uma chave ausente</span><span class="sxs-lookup"><span data-stu-id="35415-200">The function used to generate a value for an absent key</span></span></param>
        <param name="updateValueFactory"><span data-ttu-id="35415-201">A função usada para gerar um novo valor para uma chave existente com base no valor existente da chave</span><span class="sxs-lookup"><span data-stu-id="35415-201">The function used to generate a new value for an existing key based on the key's existing value</span></span></param>
        <summary><span data-ttu-id="35415-202">Usará as funções especificadas para adicionar um par chave-valor ao <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" /> se a chave ainda não existir ou para atualizar um par chave-valor no <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" /> se a chave já existir.</span><span class="sxs-lookup"><span data-stu-id="35415-202">Uses the specified functions to add a key/value pair to the <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" /> if the key does not already exist, or to update a key/value pair in the <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" /> if the key already exists.</span></span></summary>
        <returns><span data-ttu-id="35415-203">O novo valor da chave.</span><span class="sxs-lookup"><span data-stu-id="35415-203">The new value for the key.</span></span> <span data-ttu-id="35415-204">Esse será o resultado de <paramref name="addValueFactory" /> (se a chave estava ausente) ou o resultado de <paramref name="updateValueFactory" /> (se a chave estava presente).</span><span class="sxs-lookup"><span data-stu-id="35415-204">This will be either be the result of <paramref name="addValueFactory" /> (if the key was absent) or the result of <paramref name="updateValueFactory" /> (if the key was present).</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="35415-205">Se você chamar <xref:System.Collections.Concurrent.ConcurrentDictionary%602.AddOrUpdate%2A> simultaneamente em threads diferentes, `addValueFactory` pode ser chamado várias vezes, mas seu par chave/valor não pode ser adicionado ao dicionário para cada chamada.</span><span class="sxs-lookup"><span data-stu-id="35415-205">If you call <xref:System.Collections.Concurrent.ConcurrentDictionary%602.AddOrUpdate%2A> simultaneously on different threads, `addValueFactory` may be called multiple times, but its key/value pair might not be added to the dictionary for every call.</span></span>  

 <span data-ttu-id="35415-206">Para operações de gravação ao dicionário e modificações <xref:System.Collections.Concurrent.ConcurrentDictionary%602> usa bloqueio refinado para garantir acesso thread-safe.</span><span class="sxs-lookup"><span data-stu-id="35415-206">For modifications and write operations to the dictionary, <xref:System.Collections.Concurrent.ConcurrentDictionary%602> uses fine-grained locking to ensure thread safety.</span></span> <span data-ttu-id="35415-207">(As operações de leitura no dicionário são executadas de forma livre de bloqueios). No entanto, o `addValueFactory` e `updateValueFactory` delegados são chamados de fora de bloqueios para evitar os problemas que possam surgir na execução de um código desconhecido em um bloqueio.</span><span class="sxs-lookup"><span data-stu-id="35415-207">(Read operations on the dictionary are performed in a lock-free manner.) However, the `addValueFactory` and `updateValueFactory` delegates are called outside the locks to avoid the problems that can arise from executing unknown code under a lock.</span></span> <span data-ttu-id="35415-208">Portanto, <xref:System.Collections.Concurrent.ConcurrentDictionary%602.AddOrUpdate%2A> não é atômica em relação a todas as outras operações no <xref:System.Collections.Concurrent.ConcurrentDictionary%602> classe.</span><span class="sxs-lookup"><span data-stu-id="35415-208">Therefore, <xref:System.Collections.Concurrent.ConcurrentDictionary%602.AddOrUpdate%2A> is not atomic with regards to all other operations on the <xref:System.Collections.Concurrent.ConcurrentDictionary%602> class.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="35415-209"><paramref name="key" />, <paramref name="addValueFactory" /> ou <paramref name="updateValueFactory" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="35415-209"><paramref name="key" />, <paramref name="addValueFactory" />, or <paramref name="updateValueFactory" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.OverflowException"><span data-ttu-id="35415-210">O dicionário já contém o número máximo de elementos (<see cref="F:System.Int32.MaxValue" />).</span><span class="sxs-lookup"><span data-stu-id="35415-210">The dictionary already contains the maximum number of elements (<see cref="F:System.Int32.MaxValue" />).</span></span></exception>
        <related type="Article" href="https://msdn.microsoft.com/library/2e7ca21f-786c-4367-96be-0cf3f3dcc6bd"><span data-ttu-id="35415-211">Coleções thread-safe</span><span class="sxs-lookup"><span data-stu-id="35415-211">Thread-Safe Collections</span></span></related>
        <related type="Article" href="https://msdn.microsoft.com/library/81b64b95-13f7-4532-9249-ab532f629598"><span data-ttu-id="35415-212">Como adicionar e remover itens de um ConcurrentDictionary</span><span class="sxs-lookup"><span data-stu-id="35415-212">How to: Add and Remove Items from a ConcurrentDictionary</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="AddOrUpdate">
      <MemberSignature Language="C#" Value="public TValue AddOrUpdate (TKey key, TValue addValue, Func&lt;TKey,TValue,TValue&gt; updateValueFactory);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance !TValue AddOrUpdate(!TKey key, !TValue addValue, class System.Func`3&lt;!TKey, !TValue, !TValue&gt; updateValueFactory) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Concurrent.ConcurrentDictionary`2.AddOrUpdate(`0,`1,System.Func{`0,`1,`1})" />
      <MemberSignature Language="VB.NET" Value="Public Function AddOrUpdate (key As TKey, addValue As TValue, updateValueFactory As Func(Of TKey, TValue, TValue)) As TValue" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; TValue AddOrUpdate(TKey key, TValue addValue, Func&lt;TKey, TValue, TValue&gt; ^ updateValueFactory);" />
      <MemberSignature Language="F#" Value="member this.AddOrUpdate : 'Key * 'Value * Func&lt;'Key, 'Value, 'Value&gt; -&gt; 'Value" Usage="concurrentDictionary.AddOrUpdate (key, addValue, updateValueFactory)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TValue</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="TKey" />
        <Parameter Name="addValue" Type="TValue" />
        <Parameter Name="updateValueFactory" Type="System.Func&lt;TKey,TValue,TValue&gt;" />
      </Parameters>
      <Docs>
        <param name="key"><span data-ttu-id="35415-213">A chave a ser adicionada ou cujo valor deve ser atualizado</span><span class="sxs-lookup"><span data-stu-id="35415-213">The key to be added or whose value should be updated</span></span></param>
        <param name="addValue"><span data-ttu-id="35415-214">O valor a ser adicionado para uma chave ausente</span><span class="sxs-lookup"><span data-stu-id="35415-214">The value to be added for an absent key</span></span></param>
        <param name="updateValueFactory"><span data-ttu-id="35415-215">A função usada para gerar um novo valor para uma chave existente com base no valor existente da chave</span><span class="sxs-lookup"><span data-stu-id="35415-215">The function used to generate a new value for an existing key based on the key's existing value</span></span></param>
        <summary><span data-ttu-id="35415-216">Adiciona um par chave-valor ao <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" /> se a chave ainda não existir ou atualiza um par chave-valor no <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" /> usando a função especificada se a chave já existir.</span><span class="sxs-lookup"><span data-stu-id="35415-216">Adds a key/value pair to the <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" /> if the key does not already exist, or updates a key/value pair in the <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" /> by using the specified function if the key already exists.</span></span></summary>
        <returns><span data-ttu-id="35415-217">O novo valor da chave.</span><span class="sxs-lookup"><span data-stu-id="35415-217">The new value for the key.</span></span> <span data-ttu-id="35415-218">Será <paramref name="addValue" /> (se a chave estava ausente) ou o resultado de <paramref name="updateValueFactory" /> (se a chave estava presente).</span><span class="sxs-lookup"><span data-stu-id="35415-218">This will be either be <paramref name="addValue" /> (if the key was absent) or the result of <paramref name="updateValueFactory" /> (if the key was present).</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="35415-219">O exemplo de código a seguir mostra como inicializar um <xref:System.Collections.Concurrent.ConcurrentDictionary%602> e como usar o método AddOrUpdate para adicionar um item adicional à coleção e atualizar os itens existentes.</span><span class="sxs-lookup"><span data-stu-id="35415-219">The following code example shows how to initialize an <xref:System.Collections.Concurrent.ConcurrentDictionary%602> and how to use the AddOrUpdate method to add an additional item to the collection, and update the existing items.</span></span>  
  
 [!code-csharp[System.Collections.ConcurrentColAddUpdate#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.collections.concurrentcoladdupdate/cs/program.cs#1)]
 [!code-vb[System.Collections.ConcurrentColAddUpdate#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.collections.concurrentcoladdupdate/vb/module1.vb#1)]  

## Remarks  
 <span data-ttu-id="35415-220">Para operações de gravação ao dicionário e modificações <xref:System.Collections.Concurrent.ConcurrentDictionary%602> usa bloqueio refinado para garantir acesso thread-safe.</span><span class="sxs-lookup"><span data-stu-id="35415-220">For modifications and write operations to the dictionary, <xref:System.Collections.Concurrent.ConcurrentDictionary%602> uses fine-grained locking to ensure thread safety.</span></span> <span data-ttu-id="35415-221">(As operações de leitura no dicionário são executadas de forma livre de bloqueios). No entanto, o `updateValueFactory` delegado é chamado fora de bloqueios para evitar os problemas que possam surgir na execução de um código desconhecido em um bloqueio.</span><span class="sxs-lookup"><span data-stu-id="35415-221">(Read operations on the dictionary are performed in a lock-free manner.) However, the `updateValueFactory` delegate is called outside the locks to avoid the problems that can arise from executing unknown code under a lock.</span></span> <span data-ttu-id="35415-222">Portanto, <xref:System.Collections.Concurrent.ConcurrentDictionary%602.AddOrUpdate%2A> não é atômica em relação a todas as outras operações no <xref:System.Collections.Concurrent.ConcurrentDictionary%602> classe.</span><span class="sxs-lookup"><span data-stu-id="35415-222">Therefore, <xref:System.Collections.Concurrent.ConcurrentDictionary%602.AddOrUpdate%2A> is not atomic with regards to all other operations on the <xref:System.Collections.Concurrent.ConcurrentDictionary%602> class.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="35415-223"><paramref name="key" /> ou <paramref name="updateValueFactory" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="35415-223"><paramref name="key" /> or <paramref name="updateValueFactory" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.OverflowException"><span data-ttu-id="35415-224">O dicionário já contém o número máximo de elementos (<see cref="F:System.Int32.MaxValue" />).</span><span class="sxs-lookup"><span data-stu-id="35415-224">The dictionary already contains the maximum number of elements (<see cref="F:System.Int32.MaxValue" />).</span></span></exception>
        <related type="Article" href="https://msdn.microsoft.com/library/2e7ca21f-786c-4367-96be-0cf3f3dcc6bd"><span data-ttu-id="35415-225">Coleções thread-safe</span><span class="sxs-lookup"><span data-stu-id="35415-225">Thread-Safe Collections</span></span></related>
        <related type="Article" href="https://msdn.microsoft.com/library/81b64b95-13f7-4532-9249-ab532f629598"><span data-ttu-id="35415-226">Como adicionar e remover itens de um ConcurrentDictionary</span><span class="sxs-lookup"><span data-stu-id="35415-226">How to: Add and Remove Items from a ConcurrentDictionary</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="AddOrUpdate&lt;TArg&gt;">
      <MemberSignature Language="C#" Value="public TValue AddOrUpdate&lt;TArg&gt; (TKey key, Func&lt;TKey,TArg,TValue&gt; addValueFactory, Func&lt;TKey,TValue,TArg,TValue&gt; updateValueFactory, TArg factoryArgument);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance !TValue AddOrUpdate&lt;TArg&gt;(!TKey key, class System.Func`3&lt;!TKey, !!TArg, !TValue&gt; addValueFactory, class System.Func`4&lt;!TKey, !TValue, !!TArg, !TValue&gt; updateValueFactory, !!TArg factoryArgument) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Concurrent.ConcurrentDictionary`2.AddOrUpdate``1(`0,System.Func{`0,``0,`1},System.Func{`0,`1,``0,`1},``0)" />
      <MemberSignature Language="VB.NET" Value="Public Function AddOrUpdate(Of TArg) (key As TKey, addValueFactory As Func(Of TKey, TArg, TValue), updateValueFactory As Func(Of TKey, TValue, TArg, TValue), factoryArgument As TArg) As TValue" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TArg&gt;&#xA; TValue AddOrUpdate(TKey key, Func&lt;TKey, TArg, TValue&gt; ^ addValueFactory, Func&lt;TKey, TValue, TArg, TValue&gt; ^ updateValueFactory, TArg factoryArgument);" />
      <MemberSignature Language="F#" Value="member this.AddOrUpdate : 'Key * Func&lt;'Key, 'Arg, 'Value&gt; * Func&lt;'Key, 'Value, 'Arg, 'Value&gt; * 'Arg -&gt; 'Value" Usage="concurrentDictionary.AddOrUpdate (key, addValueFactory, updateValueFactory, factoryArgument)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TValue</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TArg" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="key" Type="TKey" />
        <Parameter Name="addValueFactory" Type="System.Func&lt;TKey,TArg,TValue&gt;" />
        <Parameter Name="updateValueFactory" Type="System.Func&lt;TKey,TValue,TArg,TValue&gt;" />
        <Parameter Name="factoryArgument" Type="TArg" />
      </Parameters>
      <Docs>
        <typeparam name="TArg"><span data-ttu-id="35415-227">O tipo de um argumento para passar para <paramref name="addValueFactory" /> e <paramref name="updateValueFactory" />.</span><span class="sxs-lookup"><span data-stu-id="35415-227">The type of an argument to pass into <paramref name="addValueFactory" /> and <paramref name="updateValueFactory" />.</span></span></typeparam>
        <param name="key"><span data-ttu-id="35415-228">A chave a ser adicionada ou cujo valor deve ser atualizado.</span><span class="sxs-lookup"><span data-stu-id="35415-228">The key to be added or whose value should be updated.</span></span></param>
        <param name="addValueFactory"><span data-ttu-id="35415-229">A função usada para gerar um valor para uma chave ausente.</span><span class="sxs-lookup"><span data-stu-id="35415-229">The function used to generate a value for an absent key.</span></span></param>
        <param name="updateValueFactory"><span data-ttu-id="35415-230">A função usada para gerar um novo valor para uma chave existente com base no valor existente da chave.</span><span class="sxs-lookup"><span data-stu-id="35415-230">The function used to generate a new value for an existing key based on the key's existing value.</span></span></param>
        <param name="factoryArgument"><span data-ttu-id="35415-231">Um argumento a passar para <paramref name="addValueFactory" /> e <paramref name="updateValueFactory" />.</span><span class="sxs-lookup"><span data-stu-id="35415-231">An argument to pass into <paramref name="addValueFactory" /> and <paramref name="updateValueFactory" />.</span></span></param>
        <summary><span data-ttu-id="35415-232">Usará o argumento e as funções especificadas para adicionar um par chave-valor ao <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" /> se a chave ainda não existir ou para atualizar um par chave-valor no <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" /> se a chave já existir.</span><span class="sxs-lookup"><span data-stu-id="35415-232">Uses the specified functions and argument to add a key/value pair to the <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" /> if the key does not already exist, or to update a key/value pair in the <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" /> if the key already exists.</span></span></summary>
        <returns><span data-ttu-id="35415-233">O novo valor da chave.</span><span class="sxs-lookup"><span data-stu-id="35415-233">The new value for the key.</span></span> <span data-ttu-id="35415-234">Esse será o resultado de <paramref name="addValueFactory" /> (se a chave estava ausente) ou o resultado de <paramref name="updateValueFactory" /> (se a chave estava presente).</span><span class="sxs-lookup"><span data-stu-id="35415-234">This will be either be the result of <paramref name="addValueFactory" /> (if the key was absent) or the result of <paramref name="updateValueFactory" /> (if the key was present).</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="35415-235">Se você chamar <xref:System.Collections.Concurrent.ConcurrentDictionary%602.AddOrUpdate%2A> simultaneamente em threads diferentes, `addValueFactory` pode ser chamado várias vezes, mas seu par chave/valor não pode ser adicionado ao dicionário para cada chamada.</span><span class="sxs-lookup"><span data-stu-id="35415-235">If you call <xref:System.Collections.Concurrent.ConcurrentDictionary%602.AddOrUpdate%2A> simultaneously on different threads, `addValueFactory` may be called multiple times, but its key/value pair might not be added to the dictionary for every call.</span></span>  

 <span data-ttu-id="35415-236">Para operações de gravação ao dicionário e modificações <xref:System.Collections.Concurrent.ConcurrentDictionary%602> usa bloqueio refinado para garantir acesso thread-safe.</span><span class="sxs-lookup"><span data-stu-id="35415-236">For modifications and write operations to the dictionary, <xref:System.Collections.Concurrent.ConcurrentDictionary%602> uses fine-grained locking to ensure thread safety.</span></span> <span data-ttu-id="35415-237">(As operações de leitura no dicionário são executadas de forma livre de bloqueios). No entanto, o `addValueFactory` e `updateValueFactory` delegados são chamados de fora de bloqueios para evitar os problemas que possam surgir na execução de um código desconhecido em um bloqueio.</span><span class="sxs-lookup"><span data-stu-id="35415-237">(Read operations on the dictionary are performed in a lock-free manner.) However, the `addValueFactory` and `updateValueFactory` delegates are called outside the locks to avoid the problems that can arise from executing unknown code under a lock.</span></span> <span data-ttu-id="35415-238">Portanto, <xref:System.Collections.Concurrent.ConcurrentDictionary%602.AddOrUpdate%2A> não é atômica em relação a todas as outras operações no <xref:System.Collections.Concurrent.ConcurrentDictionary%602> classe.</span><span class="sxs-lookup"><span data-stu-id="35415-238">Therefore, <xref:System.Collections.Concurrent.ConcurrentDictionary%602.AddOrUpdate%2A> is not atomic with regards to all other operations on the <xref:System.Collections.Concurrent.ConcurrentDictionary%602> class.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="35415-239"><paramref name="key" />, <paramref name="addValueFactory" /> ou <paramref name="updateValueFactory" /> é uma referência nula (Nothing no Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="35415-239"><paramref name="key" />, <paramref name="addValueFactory" />, or <paramref name="updateValueFactory" /> is a null reference (Nothing in Visual Basic).</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Clear">
      <MemberSignature Language="C#" Value="public void Clear ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Clear() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Concurrent.ConcurrentDictionary`2.Clear" />
      <MemberSignature Language="VB.NET" Value="Public Sub Clear ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Clear();" />
      <MemberSignature Language="F#" Value="abstract member Clear : unit -&gt; unit&#xA;override this.Clear : unit -&gt; unit" Usage="concurrentDictionary.Clear " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IDictionary.Clear</InterfaceMember>
        <InterfaceMember>M:System.Collections.Generic.ICollection`1.Clear</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="35415-240">Remove todas as chaves e valores do <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" />.</span><span class="sxs-lookup"><span data-stu-id="35415-240">Removes all keys and values from the <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" />.</span></span></summary>
        <remarks>To be added.</remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/2e7ca21f-786c-4367-96be-0cf3f3dcc6bd"><span data-ttu-id="35415-241">Coleções thread-safe</span><span class="sxs-lookup"><span data-stu-id="35415-241">Thread-Safe Collections</span></span></related>
        <related type="Article" href="https://msdn.microsoft.com/library/81b64b95-13f7-4532-9249-ab532f629598"><span data-ttu-id="35415-242">Como adicionar e remover itens de um ConcurrentDictionary</span><span class="sxs-lookup"><span data-stu-id="35415-242">How to: Add and Remove Items from a ConcurrentDictionary</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="ContainsKey">
      <MemberSignature Language="C#" Value="public bool ContainsKey (TKey key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool ContainsKey(!TKey key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Concurrent.ConcurrentDictionary`2.ContainsKey(`0)" />
      <MemberSignature Language="VB.NET" Value="Public Function ContainsKey (key As TKey) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool ContainsKey(TKey key);" />
      <MemberSignature Language="F#" Value="abstract member ContainsKey : 'Key -&gt; bool&#xA;override this.ContainsKey : 'Key -&gt; bool" Usage="concurrentDictionary.ContainsKey key" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.IDictionary`2.ContainsKey(`0)</InterfaceMember>
        <InterfaceMember>M:System.Collections.Generic.IReadOnlyDictionary`2.ContainsKey(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="TKey" />
      </Parameters>
      <Docs>
        <param name="key"><span data-ttu-id="35415-243">A chave a ser localizada no <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" />.</span><span class="sxs-lookup"><span data-stu-id="35415-243">The key to locate in the <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" />.</span></span></param>
        <summary><span data-ttu-id="35415-244">Determina se o <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" /> atual contém a chave especificada.</span><span class="sxs-lookup"><span data-stu-id="35415-244">Determines whether the <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" /> contains the specified key.</span></span></summary>
        <returns><span data-ttu-id="35415-245"><see langword="true" /> se o <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" /> contiver um elemento com a chave especificada; caso contrário, <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="35415-245"><see langword="true" /> if the <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" /> contains an element with the specified key; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="35415-246"><paramref name="key" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="35415-246"><paramref name="key" /> is <see langword="null" />.</span></span></exception>
        <related type="Article" href="https://msdn.microsoft.com/library/2e7ca21f-786c-4367-96be-0cf3f3dcc6bd"><span data-ttu-id="35415-247">Coleções thread-safe</span><span class="sxs-lookup"><span data-stu-id="35415-247">Thread-Safe Collections</span></span></related>
        <related type="Article" href="https://msdn.microsoft.com/library/81b64b95-13f7-4532-9249-ab532f629598"><span data-ttu-id="35415-248">Como adicionar e remover itens de um ConcurrentDictionary</span><span class="sxs-lookup"><span data-stu-id="35415-248">How to: Add and Remove Items from a ConcurrentDictionary</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Count">
      <MemberSignature Language="C#" Value="public int Count { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Count" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Concurrent.ConcurrentDictionary`2.Count" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Count As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Count { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Count : int" Usage="System.Collections.Concurrent.ConcurrentDictionary&lt;'Key, 'Value&gt;.Count" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.Generic.ICollection`1.Count</InterfaceMember>
        <InterfaceMember>P:System.Collections.Generic.IReadOnlyCollection`1.Count</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="35415-249">Obtém o número de pares chave-valor contidos no <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" />.</span><span class="sxs-lookup"><span data-stu-id="35415-249">Gets the number of key/value pairs contained in the <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" />.</span></span></summary>
        <value><span data-ttu-id="35415-250">O número de pares chave-valor contidos no <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" />.</span><span class="sxs-lookup"><span data-stu-id="35415-250">The number of key/value pairs contained in the <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="35415-251">Essa propriedade tem semântica de instantâneo e representa o número de itens a <xref:System.Collections.Concurrent.ConcurrentDictionary%602?displayProperty=nameWithType> no momento em que a propriedade foi acessada.</span><span class="sxs-lookup"><span data-stu-id="35415-251">This property has snapshot semantics and represents the number of items in the <xref:System.Collections.Concurrent.ConcurrentDictionary%602?displayProperty=nameWithType> at the moment when the property was accessed.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException"><span data-ttu-id="35415-252">O dicionário já contém o número máximo de elementos (<see cref="F:System.Int32.MaxValue" />).</span><span class="sxs-lookup"><span data-stu-id="35415-252">The dictionary already contains the maximum number of elements (<see cref="F:System.Int32.MaxValue" />).</span></span></exception>
        <related type="Article" href="https://msdn.microsoft.com/library/2e7ca21f-786c-4367-96be-0cf3f3dcc6bd"><span data-ttu-id="35415-253">Coleções thread-safe</span><span class="sxs-lookup"><span data-stu-id="35415-253">Thread-Safe Collections</span></span></related>
        <related type="Article" href="https://msdn.microsoft.com/library/81b64b95-13f7-4532-9249-ab532f629598"><span data-ttu-id="35415-254">Como adicionar e remover itens de um ConcurrentDictionary</span><span class="sxs-lookup"><span data-stu-id="35415-254">How to: Add and Remove Items from a ConcurrentDictionary</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="GetEnumerator">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerator&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt; GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Generic.IEnumerator`1&lt;valuetype System.Collections.Generic.KeyValuePair`2&lt;!TKey, !TValue&gt;&gt; GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Concurrent.ConcurrentDictionary`2.GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Public Function GetEnumerator () As IEnumerator(Of KeyValuePair(Of TKey, TValue))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Collections::Generic::IEnumerator&lt;System::Collections::Generic::KeyValuePair&lt;TKey, TValue&gt;&gt; ^ GetEnumerator();" />
      <MemberSignature Language="F#" Value="abstract member GetEnumerator : unit -&gt; System.Collections.Generic.IEnumerator&lt;System.Collections.Generic.KeyValuePair&lt;'Key, 'Value&gt;&gt;&#xA;override this.GetEnumerator : unit -&gt; System.Collections.Generic.IEnumerator&lt;System.Collections.Generic.KeyValuePair&lt;'Key, 'Value&gt;&gt;" Usage="concurrentDictionary.GetEnumerator " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.IEnumerable`1.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.6">
          <AttributeName>System.Runtime.CompilerServices.IteratorStateMachine(typeof(System.Collections.Concurrent.ConcurrentDictionary`2/&lt;GetEnumerator&gt;d__1))</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1">
          <AttributeName>System.Runtime.CompilerServices.IteratorStateMachine(typeof(System.Collections.Concurrent.ConcurrentDictionary`2/&lt;GetEnumerator&gt;d__35))</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Runtime.CompilerServices.IteratorStateMachine(typeof(System.Collections.Concurrent.ConcurrentDictionary`2/&lt;GetEnumerator&gt;d__34))</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerator&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="35415-255">Retorna um enumerador que itera por meio de <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" />.</span><span class="sxs-lookup"><span data-stu-id="35415-255">Returns an enumerator that iterates through the <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" />.</span></span></summary>
        <returns><span data-ttu-id="35415-256">Um enumerador para o <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" />.</span><span class="sxs-lookup"><span data-stu-id="35415-256">An enumerator for the <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="35415-257">Enumerador retornado do dicionário é seguro usar simultaneamente com leituras e gravações ao dicionário, no entanto, ele não representa um instantâneo do momento em que-in-time do dicionário.</span><span class="sxs-lookup"><span data-stu-id="35415-257">The enumerator returned from the dictionary is safe to use concurrently with reads and writes to the dictionary, however it does not represent a moment-in-time snapshot of the dictionary.</span></span> <span data-ttu-id="35415-258">O conteúdo exposto por meio do enumerador pode conter modificações feitas no dicionário após <xref:System.Collections.Concurrent.ConcurrentDictionary%602.GetEnumerator%2A> foi chamado.</span><span class="sxs-lookup"><span data-stu-id="35415-258">The contents exposed through the enumerator may contain modifications made to the dictionary after <xref:System.Collections.Concurrent.ConcurrentDictionary%602.GetEnumerator%2A> was called.</span></span>  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/2e7ca21f-786c-4367-96be-0cf3f3dcc6bd"><span data-ttu-id="35415-259">Coleções thread-safe</span><span class="sxs-lookup"><span data-stu-id="35415-259">Thread-Safe Collections</span></span></related>
        <related type="Article" href="https://msdn.microsoft.com/library/81b64b95-13f7-4532-9249-ab532f629598"><span data-ttu-id="35415-260">Como adicionar e remover itens de um ConcurrentDictionary</span><span class="sxs-lookup"><span data-stu-id="35415-260">How to: Add and Remove Items from a ConcurrentDictionary</span></span></related>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetOrAdd">
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="35415-261">Adiciona um par chave-valor ao <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" /> se a chave ainda não existe.</span><span class="sxs-lookup"><span data-stu-id="35415-261">Adds a key/value pair to the <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" /> if the key does not already exist.</span></span> <span data-ttu-id="35415-262">Retorna o novo valor ou o valor existente se a chave já existir.</span><span class="sxs-lookup"><span data-stu-id="35415-262">Returns the new value, or the existing value if the key already exists.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="35415-263">O exemplo a seguir mostra como chamar o <xref:System.Collections.Concurrent.ConcurrentDictionary%602.GetOrAdd%2A> método:</span><span class="sxs-lookup"><span data-stu-id="35415-263">The following example shows how to call the <xref:System.Collections.Concurrent.ConcurrentDictionary%602.GetOrAdd%2A> method:</span></span>  
  
 [!code-csharp[System.Collections.Concurrent.ConcurrentDictionary#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.collections.concurrent.concurrentdictionary/cs/concdictionary.cs#3)]
 [!code-vb[System.Collections.Concurrent.ConcurrentDictionary#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.collections.concurrent.concurrentdictionary/vb/concdictionary.vb#3)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/2e7ca21f-786c-4367-96be-0cf3f3dcc6bd"><span data-ttu-id="35415-264">Coleções thread-safe</span><span class="sxs-lookup"><span data-stu-id="35415-264">Thread-Safe Collections</span></span></related>
        <related type="Article" href="https://msdn.microsoft.com/library/81b64b95-13f7-4532-9249-ab532f629598"><span data-ttu-id="35415-265">Como adicionar e remover itens de um ConcurrentDictionary</span><span class="sxs-lookup"><span data-stu-id="35415-265">How to: Add and Remove Items from a ConcurrentDictionary</span></span></related>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetOrAdd">
      <MemberSignature Language="C#" Value="public TValue GetOrAdd (TKey key, Func&lt;TKey,TValue&gt; valueFactory);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance !TValue GetOrAdd(!TKey key, class System.Func`2&lt;!TKey, !TValue&gt; valueFactory) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Concurrent.ConcurrentDictionary`2.GetOrAdd(`0,System.Func{`0,`1})" />
      <MemberSignature Language="VB.NET" Value="Public Function GetOrAdd (key As TKey, valueFactory As Func(Of TKey, TValue)) As TValue" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; TValue GetOrAdd(TKey key, Func&lt;TKey, TValue&gt; ^ valueFactory);" />
      <MemberSignature Language="F#" Value="member this.GetOrAdd : 'Key * Func&lt;'Key, 'Value&gt; -&gt; 'Value" Usage="concurrentDictionary.GetOrAdd (key, valueFactory)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TValue</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="TKey" />
        <Parameter Name="valueFactory" Type="System.Func&lt;TKey,TValue&gt;" />
      </Parameters>
      <Docs>
        <param name="key"><span data-ttu-id="35415-266">A chave do elemento a ser adicionada.</span><span class="sxs-lookup"><span data-stu-id="35415-266">The key of the element to add.</span></span></param>
        <param name="valueFactory"><span data-ttu-id="35415-267">A função usada para gerar um valor para a chave.</span><span class="sxs-lookup"><span data-stu-id="35415-267">The function used to generate a value for the key.</span></span></param>
        <summary><span data-ttu-id="35415-268">Adiciona um par chave/valor para o <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" /> usando a função especificada, se a chave ainda não existir.</span><span class="sxs-lookup"><span data-stu-id="35415-268">Adds a key/value pair to the <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" /> by using the specified function if the key does not already exist.</span></span> <span data-ttu-id="35415-269">Retorna o novo valor ou o valor existente se a chave existir.</span><span class="sxs-lookup"><span data-stu-id="35415-269">Returns the new value, or the existing value if the key exists.</span></span></summary>
        <returns><span data-ttu-id="35415-270">O valor da chave.</span><span class="sxs-lookup"><span data-stu-id="35415-270">The value for the key.</span></span> <span data-ttu-id="35415-271">Esse será o valor existente da chave se ela já estiver no dicionário ou o novo valor se ela não estiver no dicionário.</span><span class="sxs-lookup"><span data-stu-id="35415-271">This will be either the existing value for the key if the key is already in the dictionary, or the new value if the key was not in the dictionary.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks   
 <span data-ttu-id="35415-272">Para operações de gravação ao dicionário e modificações <xref:System.Collections.Concurrent.ConcurrentDictionary%602> usa bloqueio refinado para garantir acesso thread-safe.</span><span class="sxs-lookup"><span data-stu-id="35415-272">For modifications and write operations to the dictionary, <xref:System.Collections.Concurrent.ConcurrentDictionary%602> uses fine-grained locking to ensure thread safety.</span></span> <span data-ttu-id="35415-273">(As operações de leitura no dicionário são executadas de forma livre de bloqueios). No entanto, o `valueFactory` delegado é chamado fora de bloqueios para evitar os problemas que possam surgir na execução de um código desconhecido em um bloqueio.</span><span class="sxs-lookup"><span data-stu-id="35415-273">(Read operations on the dictionary are performed in a lock-free manner.) However, the `valueFactory` delegate is called outside the locks to avoid the problems that can arise from executing unknown code under a lock.</span></span> <span data-ttu-id="35415-274">Portanto, <xref:System.Collections.Concurrent.ConcurrentDictionary%602.GetOrAdd%2A> não é atômica em relação a todas as outras operações no <xref:System.Collections.Concurrent.ConcurrentDictionary%602> classe.</span><span class="sxs-lookup"><span data-stu-id="35415-274">Therefore, <xref:System.Collections.Concurrent.ConcurrentDictionary%602.GetOrAdd%2A> is not atomic with regards to all other operations on the <xref:System.Collections.Concurrent.ConcurrentDictionary%602> class.</span></span>  

 <span data-ttu-id="35415-275">Uma vez que um valor de chave/valor podem ser inserido por outro thread enquanto `valueFactory` é gerar um valor, você não pode confiar que só porque `valueFactory` executada, seu valor gerado será inserido no dicionário e retornada.</span><span class="sxs-lookup"><span data-stu-id="35415-275">Since a key/value can be inserted by another thread while `valueFactory` is generating a value, you cannot trust that just because `valueFactory` executed, its produced value will be inserted into the dictionary and returned.</span></span> <span data-ttu-id="35415-276">Se você chamar <xref:System.Collections.Concurrent.ConcurrentDictionary%602.GetOrAdd%2A> simultaneamente em threads diferentes, `valueFactory` pode ser chamado várias vezes, mas o par chave/valor de apenas um será adicionado ao dicionário.</span><span class="sxs-lookup"><span data-stu-id="35415-276">If you call <xref:System.Collections.Concurrent.ConcurrentDictionary%602.GetOrAdd%2A> simultaneously on different threads, `valueFactory` may be called multiple times, but only one key/value pair will be added to the dictionary.</span></span> 
 
 <span data-ttu-id="35415-277">O valor de retorno depende da presença da chave no dicionário e se uma chave/valor é inserida por outro thread após <xref:System.Collections.Concurrent.ConcurrentDictionary%602.GetOrAdd%2A> é chamado, mas antes `valueFactory` gera um valor:</span><span class="sxs-lookup"><span data-stu-id="35415-277">The return value depends on the presence of the key in the dictionary and whether a key/value is inserted by another thread after <xref:System.Collections.Concurrent.ConcurrentDictionary%602.GetOrAdd%2A> is called but before `valueFactory` generates a value:</span></span>

 | <span data-ttu-id="35415-278">Cenário</span><span class="sxs-lookup"><span data-stu-id="35415-278">Scenario</span></span> | <span data-ttu-id="35415-279">Valor retornado</span><span class="sxs-lookup"><span data-stu-id="35415-279">Return value</span></span> |
 | -------- | ------------ |
 | <span data-ttu-id="35415-280">A chave já estiver no dicionário.</span><span class="sxs-lookup"><span data-stu-id="35415-280">The key is already in the dictionary.</span></span> | <span data-ttu-id="35415-281">O valor existente será retornado.</span><span class="sxs-lookup"><span data-stu-id="35415-281">The existing value is returned.</span></span> |
 | <span data-ttu-id="35415-282">A chave não estiver no dicionário.</span><span class="sxs-lookup"><span data-stu-id="35415-282">The key is not in the dictionary.</span></span> <span data-ttu-id="35415-283">`valueFactory` gera um valor.</span><span class="sxs-lookup"><span data-stu-id="35415-283">`valueFactory` generates a value.</span></span> <span data-ttu-id="35415-284">Em verificando novamente para a chave, nenhuma chave for encontrada.</span><span class="sxs-lookup"><span data-stu-id="35415-284">On rechecking for the key, no key is found.</span></span> | <span data-ttu-id="35415-285">A chave/valor é inserido no dicionário e o valor será retornado.</span><span class="sxs-lookup"><span data-stu-id="35415-285">The key/value is inserted into the dictionary, and the value is returned.</span></span> |
 | <span data-ttu-id="35415-286">A chave não estiver no dicionário.</span><span class="sxs-lookup"><span data-stu-id="35415-286">The key is not in the dictionary.</span></span> <span data-ttu-id="35415-287">`valueFactory` gera um valor.</span><span class="sxs-lookup"><span data-stu-id="35415-287">`valueFactory` generates a value.</span></span> <span data-ttu-id="35415-288">Enquanto `valueFactory` é gerar o valor, um thread diferente insere um valor para a chave.</span><span class="sxs-lookup"><span data-stu-id="35415-288">While `valueFactory` is generating the value, a different thread inserts a value for the key.</span></span> <span data-ttu-id="35415-289">Depois de `valueFactory` executa e após a verificá-la novamente para a chave, a chave inserida pelo outro thread é encontrada.</span><span class="sxs-lookup"><span data-stu-id="35415-289">After `valueFactory` executes and upon rechecking for the key, the key inserted by the other thread is found.</span></span> | <span data-ttu-id="35415-290">O valor inserido pelo outro thread é retornado.</span><span class="sxs-lookup"><span data-stu-id="35415-290">The value inserted by the other thread is returned.</span></span> |
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="35415-291"><paramref name="key" /> ou <paramref name="valueFactory" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="35415-291"><paramref name="key" /> or <paramref name="valueFactory" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.OverflowException"><span data-ttu-id="35415-292">O dicionário já contém o número máximo de elementos (<see cref="F:System.Int32.MaxValue" />).</span><span class="sxs-lookup"><span data-stu-id="35415-292">The dictionary already contains the maximum number of elements (<see cref="F:System.Int32.MaxValue" />).</span></span></exception>
        <related type="Article" href="https://msdn.microsoft.com/library/2e7ca21f-786c-4367-96be-0cf3f3dcc6bd"><span data-ttu-id="35415-293">Coleções thread-safe</span><span class="sxs-lookup"><span data-stu-id="35415-293">Thread-Safe Collections</span></span></related>
        <related type="Article" href="https://msdn.microsoft.com/library/81b64b95-13f7-4532-9249-ab532f629598"><span data-ttu-id="35415-294">Como adicionar e remover itens de um ConcurrentDictionary</span><span class="sxs-lookup"><span data-stu-id="35415-294">How to: Add and Remove Items from a ConcurrentDictionary</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="GetOrAdd">
      <MemberSignature Language="C#" Value="public TValue GetOrAdd (TKey key, TValue value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance !TValue GetOrAdd(!TKey key, !TValue value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Concurrent.ConcurrentDictionary`2.GetOrAdd(`0,`1)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetOrAdd (key As TKey, value As TValue) As TValue" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; TValue GetOrAdd(TKey key, TValue value);" />
      <MemberSignature Language="F#" Value="member this.GetOrAdd : 'Key * 'Value -&gt; 'Value" Usage="concurrentDictionary.GetOrAdd (key, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TValue</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="TKey" />
        <Parameter Name="value" Type="TValue" />
      </Parameters>
      <Docs>
        <param name="key"><span data-ttu-id="35415-295">A chave do elemento a ser adicionada.</span><span class="sxs-lookup"><span data-stu-id="35415-295">The key of the element to add.</span></span></param>
        <param name="value"><span data-ttu-id="35415-296">O valor a ser adicionado se a chave ainda não existir.</span><span class="sxs-lookup"><span data-stu-id="35415-296">The value to be added, if the key does not already exist.</span></span></param>
        <summary><span data-ttu-id="35415-297">Adiciona um par chave-valor ao <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" /> se a chave ainda não existe.</span><span class="sxs-lookup"><span data-stu-id="35415-297">Adds a key/value pair to the <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" /> if the key does not already exist.</span></span> <span data-ttu-id="35415-298">Retorna o novo valor ou o valor existente se a chave existir.</span><span class="sxs-lookup"><span data-stu-id="35415-298">Returns the new value, or the existing value if the key exists.</span></span></summary>
        <returns><span data-ttu-id="35415-299">O valor da chave.</span><span class="sxs-lookup"><span data-stu-id="35415-299">The value for the key.</span></span> <span data-ttu-id="35415-300">Esse será o valor existente da chave se ela já estiver no dicionário ou o novo valor se ela não estiver no dicionário.</span><span class="sxs-lookup"><span data-stu-id="35415-300">This will be either the existing value for the key if the key is already in the dictionary, or the new value if the key was not in the dictionary.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="35415-301"><paramref name="key" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="35415-301"><paramref name="key" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.OverflowException"><span data-ttu-id="35415-302">O dicionário já contém o número máximo de elementos (<see cref="F:System.Int32.MaxValue" />).</span><span class="sxs-lookup"><span data-stu-id="35415-302">The dictionary already contains the maximum number of elements (<see cref="F:System.Int32.MaxValue" />).</span></span></exception>
        <related type="Article" href="https://msdn.microsoft.com/library/2e7ca21f-786c-4367-96be-0cf3f3dcc6bd"><span data-ttu-id="35415-303">Coleções thread-safe</span><span class="sxs-lookup"><span data-stu-id="35415-303">Thread-Safe Collections</span></span></related>
        <related type="Article" href="https://msdn.microsoft.com/library/81b64b95-13f7-4532-9249-ab532f629598"><span data-ttu-id="35415-304">Como adicionar e remover itens de um ConcurrentDictionary</span><span class="sxs-lookup"><span data-stu-id="35415-304">How to: Add and Remove Items from a ConcurrentDictionary</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="GetOrAdd&lt;TArg&gt;">
      <MemberSignature Language="C#" Value="public TValue GetOrAdd&lt;TArg&gt; (TKey key, Func&lt;TKey,TArg,TValue&gt; valueFactory, TArg factoryArgument);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance !TValue GetOrAdd&lt;TArg&gt;(!TKey key, class System.Func`3&lt;!TKey, !!TArg, !TValue&gt; valueFactory, !!TArg factoryArgument) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Concurrent.ConcurrentDictionary`2.GetOrAdd``1(`0,System.Func{`0,``0,`1},``0)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetOrAdd(Of TArg) (key As TKey, valueFactory As Func(Of TKey, TArg, TValue), factoryArgument As TArg) As TValue" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TArg&gt;&#xA; TValue GetOrAdd(TKey key, Func&lt;TKey, TArg, TValue&gt; ^ valueFactory, TArg factoryArgument);" />
      <MemberSignature Language="F#" Value="member this.GetOrAdd : 'Key * Func&lt;'Key, 'Arg, 'Value&gt; * 'Arg -&gt; 'Value" Usage="concurrentDictionary.GetOrAdd (key, valueFactory, factoryArgument)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TValue</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TArg" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="key" Type="TKey" />
        <Parameter Name="valueFactory" Type="System.Func&lt;TKey,TArg,TValue&gt;" />
        <Parameter Name="factoryArgument" Type="TArg" />
      </Parameters>
      <Docs>
        <typeparam name="TArg"><span data-ttu-id="35415-305">O tipo de um argumento para passar para <paramref name="valueFactory" />.</span><span class="sxs-lookup"><span data-stu-id="35415-305">The type of an argument to pass into <paramref name="valueFactory" />.</span></span></typeparam>
        <param name="key"><span data-ttu-id="35415-306">A chave do elemento a ser adicionada.</span><span class="sxs-lookup"><span data-stu-id="35415-306">The key of the element to add.</span></span></param>
        <param name="valueFactory"><span data-ttu-id="35415-307">A função usada para gerar um valor para a chave.</span><span class="sxs-lookup"><span data-stu-id="35415-307">The function used to generate a value for the key.</span></span></param>
        <param name="factoryArgument"><span data-ttu-id="35415-308">Um valor de argumento para passar para <paramref name="valueFactory" />.</span><span class="sxs-lookup"><span data-stu-id="35415-308">An argument value to pass into <paramref name="valueFactory" />.</span></span></param>
        <summary><span data-ttu-id="35415-309">Adiciona um par chave/valor ao <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" /> usando o argumento e a função especificada se a chave ainda não existir ou retorna o valor existente se a chave já existir.</span><span class="sxs-lookup"><span data-stu-id="35415-309">Adds a key/value pair to the <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" /> by using the specified function and an argument if the key does not already exist, or returns the existing value if the key exists.</span></span></summary>
        <returns><span data-ttu-id="35415-310">O valor da chave.</span><span class="sxs-lookup"><span data-stu-id="35415-310">The value for the key.</span></span> <span data-ttu-id="35415-311">Esse será o valor existente da chave se ela já estiver no dicionário ou o novo valor se ela não estiver no dicionário.</span><span class="sxs-lookup"><span data-stu-id="35415-311">This will be either the existing value for the key if the key is already in the dictionary, or the new value if the key was not in the dictionary.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks   
 <span data-ttu-id="35415-312">Para operações de gravação ao dicionário e modificações <xref:System.Collections.Concurrent.ConcurrentDictionary%602> usa bloqueio refinado para garantir acesso thread-safe.</span><span class="sxs-lookup"><span data-stu-id="35415-312">For modifications and write operations to the dictionary, <xref:System.Collections.Concurrent.ConcurrentDictionary%602> uses fine-grained locking to ensure thread safety.</span></span> <span data-ttu-id="35415-313">(As operações de leitura no dicionário são executadas de forma livre de bloqueios). No entanto, o `valueFactory` delegado é chamado fora de bloqueios para evitar os problemas que possam surgir na execução de um código desconhecido em um bloqueio.</span><span class="sxs-lookup"><span data-stu-id="35415-313">(Read operations on the dictionary are performed in a lock-free manner.) However, the `valueFactory` delegate is called outside the locks to avoid the problems that can arise from executing unknown code under a lock.</span></span> <span data-ttu-id="35415-314">Portanto, <xref:System.Collections.Concurrent.ConcurrentDictionary%602.GetOrAdd%2A> não é atômica em relação a todas as outras operações no <xref:System.Collections.Concurrent.ConcurrentDictionary%602> classe.</span><span class="sxs-lookup"><span data-stu-id="35415-314">Therefore, <xref:System.Collections.Concurrent.ConcurrentDictionary%602.GetOrAdd%2A> is not atomic with regards to all other operations on the <xref:System.Collections.Concurrent.ConcurrentDictionary%602> class.</span></span>  

 <span data-ttu-id="35415-315">Uma vez que um valor de chave/valor podem ser inserido por outro thread enquanto `valueFactory` é gerar um valor, você não pode confiar que só porque `valueFactory` executada, seu valor gerado será inserido no dicionário e retornada.</span><span class="sxs-lookup"><span data-stu-id="35415-315">Since a key/value can be inserted by another thread while `valueFactory` is generating a value, you cannot trust that just because `valueFactory` executed, its produced value will be inserted into the dictionary and returned.</span></span> <span data-ttu-id="35415-316">Se você chamar <xref:System.Collections.Concurrent.ConcurrentDictionary%602.GetOrAdd%2A> simultaneamente em threads diferentes, `valueFactory` pode ser chamado várias vezes, mas o par chave/valor de apenas um será adicionado ao dicionário.</span><span class="sxs-lookup"><span data-stu-id="35415-316">If you call <xref:System.Collections.Concurrent.ConcurrentDictionary%602.GetOrAdd%2A> simultaneously on different threads, `valueFactory` may be called multiple times, but only one key/value pair will be added to the dictionary.</span></span> 
 
 <span data-ttu-id="35415-317">O valor de retorno depende da presença da chave no dicionário e se uma chave/valor é inserida por outro thread após <xref:System.Collections.Concurrent.ConcurrentDictionary%602.GetOrAdd%2A> é chamado, mas antes `valueFactory` gera um valor:</span><span class="sxs-lookup"><span data-stu-id="35415-317">The return value depends on the presence of the key in the dictionary and whether a key/value is inserted by another thread after <xref:System.Collections.Concurrent.ConcurrentDictionary%602.GetOrAdd%2A> is called but before `valueFactory` generates a value:</span></span>

 | <span data-ttu-id="35415-318">Cenário</span><span class="sxs-lookup"><span data-stu-id="35415-318">Scenario</span></span> | <span data-ttu-id="35415-319">Valor retornado</span><span class="sxs-lookup"><span data-stu-id="35415-319">Return value</span></span> |
 | -------- | ------------ |
 | <span data-ttu-id="35415-320">A chave já estiver no dicionário.</span><span class="sxs-lookup"><span data-stu-id="35415-320">The key is already in the dictionary.</span></span> | <span data-ttu-id="35415-321">O valor existente será retornado.</span><span class="sxs-lookup"><span data-stu-id="35415-321">The existing value is returned.</span></span> |
 | <span data-ttu-id="35415-322">A chave não estiver no dicionário.</span><span class="sxs-lookup"><span data-stu-id="35415-322">The key is not in the dictionary.</span></span> <span data-ttu-id="35415-323">`valueFactory` gera um valor.</span><span class="sxs-lookup"><span data-stu-id="35415-323">`valueFactory` generates a value.</span></span> <span data-ttu-id="35415-324">Em verificando novamente para a chave, nenhuma chave for encontrada.</span><span class="sxs-lookup"><span data-stu-id="35415-324">On rechecking for the key, no key is found.</span></span> | <span data-ttu-id="35415-325">A chave/valor é inserido no dicionário e o valor será retornado.</span><span class="sxs-lookup"><span data-stu-id="35415-325">The key/value is inserted into the dictionary, and the value is returned.</span></span> |
 | <span data-ttu-id="35415-326">A chave não estiver no dicionário.</span><span class="sxs-lookup"><span data-stu-id="35415-326">The key is not in the dictionary.</span></span> <span data-ttu-id="35415-327">`valueFactory` gera um valor.</span><span class="sxs-lookup"><span data-stu-id="35415-327">`valueFactory` generates a value.</span></span> <span data-ttu-id="35415-328">Enquanto `valueFactory` é gerar o valor, um thread diferente insere um valor para a chave.</span><span class="sxs-lookup"><span data-stu-id="35415-328">While `valueFactory` is generating the value, a different thread inserts a value for the key.</span></span> <span data-ttu-id="35415-329">Depois de `valueFactory` executa e após a verificá-la novamente para a chave, a chave inserida pelo outro thread é encontrada.</span><span class="sxs-lookup"><span data-stu-id="35415-329">After `valueFactory` executes and upon rechecking for the key, the key inserted by the other thread is found.</span></span> | <span data-ttu-id="35415-330">O valor inserido pelo outro thread é retornado.</span><span class="sxs-lookup"><span data-stu-id="35415-330">The value inserted by the other thread is returned.</span></span> |
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsEmpty">
      <MemberSignature Language="C#" Value="public bool IsEmpty { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsEmpty" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Concurrent.ConcurrentDictionary`2.IsEmpty" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsEmpty As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsEmpty { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsEmpty : bool" Usage="System.Collections.Concurrent.ConcurrentDictionary&lt;'Key, 'Value&gt;.IsEmpty" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="35415-331">Obtém um valor que indica se a <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" /> está vazia.</span><span class="sxs-lookup"><span data-stu-id="35415-331">Gets a value that indicates whether the <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" /> is empty.</span></span></summary>
        <value><span data-ttu-id="35415-332"><see langword="true" /> se o <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" /> estiver vazio; caso contrário, <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="35415-332"><see langword="true" /> if the <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" /> is empty; otherwise, <see langword="false" />.</span></span></value>
        <remarks>To be added.</remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/2e7ca21f-786c-4367-96be-0cf3f3dcc6bd"><span data-ttu-id="35415-333">Coleções thread-safe</span><span class="sxs-lookup"><span data-stu-id="35415-333">Thread-Safe Collections</span></span></related>
        <related type="Article" href="https://msdn.microsoft.com/library/81b64b95-13f7-4532-9249-ab532f629598"><span data-ttu-id="35415-334">Como adicionar e remover itens de um ConcurrentDictionary</span><span class="sxs-lookup"><span data-stu-id="35415-334">How to: Add and Remove Items from a ConcurrentDictionary</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Item">
      <MemberSignature Language="C#" Value="public TValue this[TKey key] { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance !TValue Item(!TKey)" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Concurrent.ConcurrentDictionary`2.Item(`0)" />
      <MemberSignature Language="VB.NET" Value="Default Public Property Item(key As TKey) As TValue" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property TValue default[TKey] { TValue get(TKey key); void set(TKey key, TValue value); };" />
      <MemberSignature Language="F#" Value="member this.Item('Key) : 'Value with get, set" Usage="System.Collections.Concurrent.ConcurrentDictionary&lt;'Key, 'Value&gt;.Item" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.Generic.IDictionary`2.Item(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TValue</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="TKey" />
      </Parameters>
      <Docs>
        <param name="key"><span data-ttu-id="35415-335">A chave do valor a ser obtido ou definido.</span><span class="sxs-lookup"><span data-stu-id="35415-335">The key of the value to get or set.</span></span></param>
        <summary><span data-ttu-id="35415-336">Obtém ou define o valor associado à chave especificada.</span><span class="sxs-lookup"><span data-stu-id="35415-336">Gets or sets the value associated with the specified key.</span></span></summary>
        <value><span data-ttu-id="35415-337">O valor do par chave-valor no índice especificado.</span><span class="sxs-lookup"><span data-stu-id="35415-337">The value of the key/value pair at the specified index.</span></span></value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="35415-338"><paramref name="key" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="35415-338"><paramref name="key" /> is  <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Collections.Generic.KeyNotFoundException"><span data-ttu-id="35415-339">A propriedade é recuperada e <paramref name="key" /> não existe na coleção.</span><span class="sxs-lookup"><span data-stu-id="35415-339">The property is retrieved and <paramref name="key" /> does not exist in the collection.</span></span></exception>
        <related type="Article" href="https://msdn.microsoft.com/library/2e7ca21f-786c-4367-96be-0cf3f3dcc6bd"><span data-ttu-id="35415-340">Coleções thread-safe</span><span class="sxs-lookup"><span data-stu-id="35415-340">Thread-Safe Collections</span></span></related>
        <related type="Article" href="https://msdn.microsoft.com/library/81b64b95-13f7-4532-9249-ab532f629598"><span data-ttu-id="35415-341">Como adicionar e remover itens de um ConcurrentDictionary</span><span class="sxs-lookup"><span data-stu-id="35415-341">How to: Add and Remove Items from a ConcurrentDictionary</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Keys">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.ICollection&lt;TKey&gt; Keys { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.ICollection`1&lt;!TKey&gt; Keys" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Concurrent.ConcurrentDictionary`2.Keys" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Keys As ICollection(Of TKey)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Generic::ICollection&lt;TKey&gt; ^ Keys { System::Collections::Generic::ICollection&lt;TKey&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Keys : System.Collections.Generic.ICollection&lt;'Key&gt;" Usage="System.Collections.Concurrent.ConcurrentDictionary&lt;'Key, 'Value&gt;.Keys" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.Generic.IDictionary`2.Keys</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.ICollection&lt;TKey&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="35415-342">Obtém uma coleção que contém as chaves do <see cref="T:System.Collections.Generic.Dictionary`2" />.</span><span class="sxs-lookup"><span data-stu-id="35415-342">Gets a collection containing the keys in the <see cref="T:System.Collections.Generic.Dictionary`2" />.</span></span></summary>
        <value><span data-ttu-id="35415-343">Uma coleção de chaves no <see cref="T:System.Collections.Generic.Dictionary`2" />.</span><span class="sxs-lookup"><span data-stu-id="35415-343">A collection of keys in the <see cref="T:System.Collections.Generic.Dictionary`2" />.</span></span></value>
        <remarks>To be added.</remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/2e7ca21f-786c-4367-96be-0cf3f3dcc6bd"><span data-ttu-id="35415-344">Coleções thread-safe</span><span class="sxs-lookup"><span data-stu-id="35415-344">Thread-Safe Collections</span></span></related>
        <related type="Article" href="https://msdn.microsoft.com/library/81b64b95-13f7-4532-9249-ab532f629598"><span data-ttu-id="35415-345">Como adicionar e remover itens de um ConcurrentDictionary</span><span class="sxs-lookup"><span data-stu-id="35415-345">How to: Add and Remove Items from a ConcurrentDictionary</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.ICollection&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;.Add">
      <MemberSignature Language="C#" Value="void ICollection&lt;KeyValuePair&lt;TKey,TValue&gt;&gt;.Add (System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt; keyValuePair);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Collections.Generic.ICollection&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;.Add(valuetype System.Collections.Generic.KeyValuePair`2&lt;!TKey, !TValue&gt; keyValuePair) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Concurrent.ConcurrentDictionary`2.System#Collections#Generic#ICollection&lt;System#Collections#Generic#KeyValuePair&lt;TKey,TValue&gt;&gt;#Add(System.Collections.Generic.KeyValuePair{`0,`1})" />
      <MemberSignature Language="VB.NET" Value="Sub Add (keyValuePair As KeyValuePair(Of TKey, TValue)) Implements ICollection(Of KeyValuePair(Of TKey, TValue)).Add" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Collections.Generic.ICollection&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;.Add(System::Collections::Generic::KeyValuePair&lt;TKey, TValue&gt; keyValuePair) = System::Collections::Generic::ICollection&lt;System::Collections::Generic::KeyValuePair&lt;TKey, TValue&gt;&gt;::Add;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ICollection`1.Add(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="keyValuePair" Type="System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;" />
      </Parameters>
      <Docs>
        <param name="keyValuePair">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/2e7ca21f-786c-4367-96be-0cf3f3dcc6bd"><span data-ttu-id="35415-346">Coleções thread-safe</span><span class="sxs-lookup"><span data-stu-id="35415-346">Thread-Safe Collections</span></span></related>
        <related type="Article" href="https://msdn.microsoft.com/library/81b64b95-13f7-4532-9249-ab532f629598"><span data-ttu-id="35415-347">Como adicionar e remover itens de um ConcurrentDictionary</span><span class="sxs-lookup"><span data-stu-id="35415-347">How to: Add and Remove Items from a ConcurrentDictionary</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.ICollection&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;.Contains">
      <MemberSignature Language="C#" Value="bool ICollection&lt;KeyValuePair&lt;TKey,TValue&gt;&gt;.Contains (System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt; keyValuePair);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.Collections.Generic.ICollection&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;.Contains(valuetype System.Collections.Generic.KeyValuePair`2&lt;!TKey, !TValue&gt; keyValuePair) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Concurrent.ConcurrentDictionary`2.System#Collections#Generic#ICollection&lt;System#Collections#Generic#KeyValuePair&lt;TKey,TValue&gt;&gt;#Contains(System.Collections.Generic.KeyValuePair{`0,`1})" />
      <MemberSignature Language="VB.NET" Value="Function Contains (keyValuePair As KeyValuePair(Of TKey, TValue)) As Boolean Implements ICollection(Of KeyValuePair(Of TKey, TValue)).Contains" />
      <MemberSignature Language="C++ CLI" Value=" virtual bool System.Collections.Generic.ICollection&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;.Contains(System::Collections::Generic::KeyValuePair&lt;TKey, TValue&gt; keyValuePair) = System::Collections::Generic::ICollection&lt;System::Collections::Generic::KeyValuePair&lt;TKey, TValue&gt;&gt;::Contains;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ICollection`1.Contains(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="keyValuePair" Type="System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;" />
      </Parameters>
      <Docs>
        <param name="keyValuePair">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/2e7ca21f-786c-4367-96be-0cf3f3dcc6bd"><span data-ttu-id="35415-348">Coleções thread-safe</span><span class="sxs-lookup"><span data-stu-id="35415-348">Thread-Safe Collections</span></span></related>
        <related type="Article" href="https://msdn.microsoft.com/library/81b64b95-13f7-4532-9249-ab532f629598"><span data-ttu-id="35415-349">Como adicionar e remover itens de um ConcurrentDictionary</span><span class="sxs-lookup"><span data-stu-id="35415-349">How to: Add and Remove Items from a ConcurrentDictionary</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.ICollection&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;.CopyTo">
      <MemberSignature Language="C#" Value="void ICollection&lt;KeyValuePair&lt;TKey,TValue&gt;&gt;.CopyTo (System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;[] array, int index);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Collections.Generic.ICollection&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;.CopyTo(valuetype System.Collections.Generic.KeyValuePair`2&lt;!TKey, !TValue&gt;[] array, int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Concurrent.ConcurrentDictionary`2.System#Collections#Generic#ICollection&lt;System#Collections#Generic#KeyValuePair&lt;TKey,TValue&gt;&gt;#CopyTo(System.Collections.Generic.KeyValuePair{`0,`1}[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Sub CopyTo (array As KeyValuePair(Of TKey, TValue)(), index As Integer) Implements ICollection(Of KeyValuePair(Of TKey, TValue)).CopyTo" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Collections.Generic.ICollection&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;.CopyTo(cli::array &lt;System::Collections::Generic::KeyValuePair&lt;TKey, TValue&gt;&gt; ^ array, int index) = System::Collections::Generic::ICollection&lt;System::Collections::Generic::KeyValuePair&lt;TKey, TValue&gt;&gt;::CopyTo;" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;[]" />
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">To be added.</param>
        <param name="index">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/2e7ca21f-786c-4367-96be-0cf3f3dcc6bd"><span data-ttu-id="35415-350">Coleções thread-safe</span><span class="sxs-lookup"><span data-stu-id="35415-350">Thread-Safe Collections</span></span></related>
        <related type="Article" href="https://msdn.microsoft.com/library/81b64b95-13f7-4532-9249-ab532f629598"><span data-ttu-id="35415-351">Como adicionar e remover itens de um ConcurrentDictionary</span><span class="sxs-lookup"><span data-stu-id="35415-351">How to: Add and Remove Items from a ConcurrentDictionary</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.ICollection&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;.IsReadOnly">
      <MemberSignature Language="C#" Value="bool System.Collections.Generic.ICollection&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;.IsReadOnly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Collections.Generic.ICollection&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;.IsReadOnly" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Concurrent.ConcurrentDictionary`2.System#Collections#Generic#ICollection&lt;System#Collections#Generic#KeyValuePair&lt;TKey,TValue&gt;&gt;#IsReadOnly" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsReadOnly As Boolean Implements ICollection(Of KeyValuePair(Of TKey, TValue)).IsReadOnly" />
      <MemberSignature Language="C++ CLI" Value="property bool System::Collections::Generic::ICollection&lt;System::Collections::Generic::KeyValuePair&lt;TKey,TValue&gt;&gt;::IsReadOnly { bool get(); };" />
      <MemberSignature Language="F#" Usage="System.Collections.Generic.ICollection&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;.IsReadOnly" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.Generic.ICollection`1.IsReadOnly</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/2e7ca21f-786c-4367-96be-0cf3f3dcc6bd"><span data-ttu-id="35415-352">Coleções thread-safe</span><span class="sxs-lookup"><span data-stu-id="35415-352">Thread-Safe Collections</span></span></related>
        <related type="Article" href="https://msdn.microsoft.com/library/81b64b95-13f7-4532-9249-ab532f629598"><span data-ttu-id="35415-353">Como adicionar e remover itens de um ConcurrentDictionary</span><span class="sxs-lookup"><span data-stu-id="35415-353">How to: Add and Remove Items from a ConcurrentDictionary</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.ICollection&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;.Remove">
      <MemberSignature Language="C#" Value="bool ICollection&lt;KeyValuePair&lt;TKey,TValue&gt;&gt;.Remove (System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt; keyValuePair);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.Collections.Generic.ICollection&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;.Remove(valuetype System.Collections.Generic.KeyValuePair`2&lt;!TKey, !TValue&gt; keyValuePair) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Concurrent.ConcurrentDictionary`2.System#Collections#Generic#ICollection&lt;System#Collections#Generic#KeyValuePair&lt;TKey,TValue&gt;&gt;#Remove(System.Collections.Generic.KeyValuePair{`0,`1})" />
      <MemberSignature Language="VB.NET" Value="Function Remove (keyValuePair As KeyValuePair(Of TKey, TValue)) As Boolean Implements ICollection(Of KeyValuePair(Of TKey, TValue)).Remove" />
      <MemberSignature Language="C++ CLI" Value=" virtual bool System.Collections.Generic.ICollection&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;.Remove(System::Collections::Generic::KeyValuePair&lt;TKey, TValue&gt; keyValuePair) = System::Collections::Generic::ICollection&lt;System::Collections::Generic::KeyValuePair&lt;TKey, TValue&gt;&gt;::Remove;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ICollection`1.Remove(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="keyValuePair" Type="System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;" />
      </Parameters>
      <Docs>
        <param name="keyValuePair">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/2e7ca21f-786c-4367-96be-0cf3f3dcc6bd"><span data-ttu-id="35415-354">Coleções thread-safe</span><span class="sxs-lookup"><span data-stu-id="35415-354">Thread-Safe Collections</span></span></related>
        <related type="Article" href="https://msdn.microsoft.com/library/81b64b95-13f7-4532-9249-ab532f629598"><span data-ttu-id="35415-355">Como adicionar e remover itens de um ConcurrentDictionary</span><span class="sxs-lookup"><span data-stu-id="35415-355">How to: Add and Remove Items from a ConcurrentDictionary</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.IDictionary&lt;TKey,TValue&gt;.Add">
      <MemberSignature Language="C#" Value="void IDictionary&lt;TKey,TValue&gt;.Add (TKey key, TValue value);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Collections.Generic.IDictionary&lt;TKey,TValue&gt;.Add(!TKey key, !TValue value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Concurrent.ConcurrentDictionary`2.System#Collections#Generic#IDictionary&lt;TKey,TValue&gt;#Add(`0,`1)" />
      <MemberSignature Language="VB.NET" Value="Sub Add (key As TKey, value As TValue) Implements IDictionary(Of TKey, TValue).Add" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Collections.Generic.IDictionary&lt;TKey,TValue&gt;.Add(TKey key, TValue value) = System::Collections::Generic::IDictionary&lt;TKey, TValue&gt;::Add;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.IDictionary`2.Add(`0,`1)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="TKey" />
        <Parameter Name="value" Type="TValue" />
      </Parameters>
      <Docs>
        <param name="key">To be added.</param>
        <param name="value">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/2e7ca21f-786c-4367-96be-0cf3f3dcc6bd"><span data-ttu-id="35415-356">Coleções thread-safe</span><span class="sxs-lookup"><span data-stu-id="35415-356">Thread-Safe Collections</span></span></related>
        <related type="Article" href="https://msdn.microsoft.com/library/81b64b95-13f7-4532-9249-ab532f629598"><span data-ttu-id="35415-357">Como adicionar e remover itens de um ConcurrentDictionary</span><span class="sxs-lookup"><span data-stu-id="35415-357">How to: Add and Remove Items from a ConcurrentDictionary</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.IDictionary&lt;TKey,TValue&gt;.Remove">
      <MemberSignature Language="C#" Value="bool IDictionary&lt;TKey,TValue&gt;.Remove (TKey key);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.Collections.Generic.IDictionary&lt;TKey,TValue&gt;.Remove(!TKey key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Concurrent.ConcurrentDictionary`2.System#Collections#Generic#IDictionary&lt;TKey,TValue&gt;#Remove(`0)" />
      <MemberSignature Language="VB.NET" Value="Function Remove (key As TKey) As Boolean Implements IDictionary(Of TKey, TValue).Remove" />
      <MemberSignature Language="C++ CLI" Value=" virtual bool System.Collections.Generic.IDictionary&lt;TKey,TValue&gt;.Remove(TKey key) = System::Collections::Generic::IDictionary&lt;TKey, TValue&gt;::Remove;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.IDictionary`2.Remove(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="TKey" />
      </Parameters>
      <Docs>
        <param name="key">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/2e7ca21f-786c-4367-96be-0cf3f3dcc6bd"><span data-ttu-id="35415-358">Coleções thread-safe</span><span class="sxs-lookup"><span data-stu-id="35415-358">Thread-Safe Collections</span></span></related>
        <related type="Article" href="https://msdn.microsoft.com/library/81b64b95-13f7-4532-9249-ab532f629598"><span data-ttu-id="35415-359">Como adicionar e remover itens de um ConcurrentDictionary</span><span class="sxs-lookup"><span data-stu-id="35415-359">How to: Add and Remove Items from a ConcurrentDictionary</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.IReadOnlyDictionary&lt;TKey,TValue&gt;.Keys">
      <MemberSignature Language="C#" Value="System.Collections.Generic.IEnumerable&lt;TKey&gt; System.Collections.Generic.IReadOnlyDictionary&lt;TKey,TValue&gt;.Keys { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IEnumerable`1&lt;!TKey&gt; System.Collections.Generic.IReadOnlyDictionary&lt;TKey,TValue&gt;.Keys" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Concurrent.ConcurrentDictionary`2.System#Collections#Generic#IReadOnlyDictionary&lt;TKey,TValue&gt;#Keys" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property Keys As IEnumerable(Of TKey) Implements IReadOnlyDictionary(Of TKey, TValue).Keys" />
      <MemberSignature Language="C++ CLI" Value="property System::Collections::Generic::IEnumerable&lt;TKey&gt; ^ System::Collections::Generic::IReadOnlyDictionary&lt;TKey,TValue&gt;::Keys { System::Collections::Generic::IEnumerable&lt;TKey&gt; ^ get(); };" />
      <MemberSignature Language="F#" Usage="System.Collections.Generic.IReadOnlyDictionary&lt;TKey,TValue&gt;.Keys" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.Generic.IReadOnlyDictionary`2.Keys</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TKey&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="35415-360">Obtém uma coleção que contém as chaves do <see cref="T:System.Collections.Generic.Dictionary`2" />.</span><span class="sxs-lookup"><span data-stu-id="35415-360">Gets a collection containing the keys in the <see cref="T:System.Collections.Generic.Dictionary`2" />.</span></span></summary>
        <value><span data-ttu-id="35415-361">Uma coleção que contém as chaves no <see cref="T:System.Collections.Generic.Dictionary`2" />.</span><span class="sxs-lookup"><span data-stu-id="35415-361">A collection containing the keys in the <see cref="T:System.Collections.Generic.Dictionary`2" />.</span></span></value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.IReadOnlyDictionary&lt;TKey,TValue&gt;.Values">
      <MemberSignature Language="C#" Value="System.Collections.Generic.IEnumerable&lt;TValue&gt; System.Collections.Generic.IReadOnlyDictionary&lt;TKey,TValue&gt;.Values { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IEnumerable`1&lt;!TValue&gt; System.Collections.Generic.IReadOnlyDictionary&lt;TKey,TValue&gt;.Values" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Concurrent.ConcurrentDictionary`2.System#Collections#Generic#IReadOnlyDictionary&lt;TKey,TValue&gt;#Values" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property Values As IEnumerable(Of TValue) Implements IReadOnlyDictionary(Of TKey, TValue).Values" />
      <MemberSignature Language="C++ CLI" Value="property System::Collections::Generic::IEnumerable&lt;TValue&gt; ^ System::Collections::Generic::IReadOnlyDictionary&lt;TKey,TValue&gt;::Values { System::Collections::Generic::IEnumerable&lt;TValue&gt; ^ get(); };" />
      <MemberSignature Language="F#" Usage="System.Collections.Generic.IReadOnlyDictionary&lt;TKey,TValue&gt;.Values" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.Generic.IReadOnlyDictionary`2.Values</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TValue&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="35415-362">Obtém uma coleção que contém os valores no <see cref="T:System.Collections.Generic.Dictionary`2" />.</span><span class="sxs-lookup"><span data-stu-id="35415-362">Gets a collection that contains the values in the <see cref="T:System.Collections.Generic.Dictionary`2" />.</span></span></summary>
        <value><span data-ttu-id="35415-363">Uma coleção que contém os valores no <see cref="T:System.Collections.Generic.Dictionary`2" />.</span><span class="sxs-lookup"><span data-stu-id="35415-363">A collection that contains the values in the <see cref="T:System.Collections.Generic.Dictionary`2" />.</span></span></value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.ICollection.CopyTo">
      <MemberSignature Language="C#" Value="void ICollection.CopyTo (Array array, int index);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Collections.ICollection.CopyTo(class System.Array array, int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Concurrent.ConcurrentDictionary`2.System#Collections#ICollection#CopyTo(System.Array,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Collections.ICollection.CopyTo(Array ^ array, int index) = System::Collections::ICollection::CopyTo;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.ICollection.CopyTo(System.Array,System.Int32)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array"><span data-ttu-id="35415-364">A matriz unidimensional que é o destino dos elementos copiados do <see cref="T:System.Collections.ICollection" />.</span><span class="sxs-lookup"><span data-stu-id="35415-364">The one-dimensional array that is the destination of the elements copied from the <see cref="T:System.Collections.ICollection" />.</span></span> <span data-ttu-id="35415-365">A matriz deve ter indexação com base em zero.</span><span class="sxs-lookup"><span data-stu-id="35415-365">The array must have zero-based indexing.</span></span></param>
        <param name="index"><span data-ttu-id="35415-366">O índice com base em zero em <paramref name="array" /> no qual a cópia começa.</span><span class="sxs-lookup"><span data-stu-id="35415-366">The zero-based index in <paramref name="array" /> at which copying begins.</span></span></param>
        <summary><span data-ttu-id="35415-367">Copia os elementos do <see cref="T:System.Collections.ICollection" /> para uma matriz, começando no índice da matriz especificada.</span><span class="sxs-lookup"><span data-stu-id="35415-367">Copies the elements of the <see cref="T:System.Collections.ICollection" /> to an array, starting at the specified array index.</span></span></summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="35415-368"><paramref name="array" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="35415-368"><paramref name="array" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="35415-369"><paramref name="index" /> é menor que 0.</span><span class="sxs-lookup"><span data-stu-id="35415-369"><paramref name="index" /> is less than 0.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="35415-370"><paramref name="index" /> é igual ou maior que o comprimento da <paramref name="array" />.</span><span class="sxs-lookup"><span data-stu-id="35415-370"><paramref name="index" /> is equal to or greater than the length of the <paramref name="array" />.</span></span>  
  
<span data-ttu-id="35415-371">- ou -</span><span class="sxs-lookup"><span data-stu-id="35415-371">-or-</span></span> 
<span data-ttu-id="35415-372">O número de elementos na origem <see cref="T:System.Collections.ICollection" /> é maior do que o espaço disponível de <paramref name="index" /> até o final do <paramref name="array" /> de destino.</span><span class="sxs-lookup"><span data-stu-id="35415-372">The number of elements in the source <see cref="T:System.Collections.ICollection" /> is greater than the available space from <paramref name="index" /> to the end of the destination <paramref name="array" />.</span></span></exception>
        <related type="Article" href="https://msdn.microsoft.com/library/2e7ca21f-786c-4367-96be-0cf3f3dcc6bd"><span data-ttu-id="35415-373">Coleções thread-safe</span><span class="sxs-lookup"><span data-stu-id="35415-373">Thread-Safe Collections</span></span></related>
        <related type="Article" href="https://msdn.microsoft.com/library/81b64b95-13f7-4532-9249-ab532f629598"><span data-ttu-id="35415-374">Como adicionar e remover itens de um ConcurrentDictionary</span><span class="sxs-lookup"><span data-stu-id="35415-374">How to: Add and Remove Items from a ConcurrentDictionary</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.ICollection.IsSynchronized">
      <MemberSignature Language="C#" Value="bool System.Collections.ICollection.IsSynchronized { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Collections.ICollection.IsSynchronized" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Concurrent.ConcurrentDictionary`2.System#Collections#ICollection#IsSynchronized" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsSynchronized As Boolean Implements ICollection.IsSynchronized" />
      <MemberSignature Language="C++ CLI" Value="property bool System::Collections::ICollection::IsSynchronized { bool get(); };" />
      <MemberSignature Language="F#" Usage="System.Collections.ICollection.IsSynchronized" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.IsSynchronized</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="35415-375">Obtém um valor indicando se o acesso ao <see cref="T:System.Collections.ICollection" /> está sincronizado com o SyncRoot.</span><span class="sxs-lookup"><span data-stu-id="35415-375">Gets a value indicating whether access to the <see cref="T:System.Collections.ICollection" /> is synchronized with the SyncRoot.</span></span></summary>
        <value><span data-ttu-id="35415-376"><see langword="true" /> caso o acesso ao <see cref="T:System.Collections.ICollection" /> seja sincronizado (thread-safe); do contrário, <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="35415-376"><see langword="true" /> if access to the <see cref="T:System.Collections.ICollection" /> is synchronized (thread safe); otherwise, <see langword="false" />.</span></span> <span data-ttu-id="35415-377">Para <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" /> essa propriedade sempre retorna <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="35415-377">For <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" /> this property always returns <see langword="false" />.</span></span></value>
        <remarks>To be added.</remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/2e7ca21f-786c-4367-96be-0cf3f3dcc6bd"><span data-ttu-id="35415-378">Coleções thread-safe</span><span class="sxs-lookup"><span data-stu-id="35415-378">Thread-Safe Collections</span></span></related>
        <related type="Article" href="https://msdn.microsoft.com/library/81b64b95-13f7-4532-9249-ab532f629598"><span data-ttu-id="35415-379">Como adicionar e remover itens de um ConcurrentDictionary</span><span class="sxs-lookup"><span data-stu-id="35415-379">How to: Add and Remove Items from a ConcurrentDictionary</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.ICollection.SyncRoot">
      <MemberSignature Language="C#" Value="object System.Collections.ICollection.SyncRoot { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object System.Collections.ICollection.SyncRoot" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Concurrent.ConcurrentDictionary`2.System#Collections#ICollection#SyncRoot" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property SyncRoot As Object Implements ICollection.SyncRoot" />
      <MemberSignature Language="C++ CLI" Value="property System::Object ^ System::Collections::ICollection::SyncRoot { System::Object ^ get(); };" />
      <MemberSignature Language="F#" Usage="System.Collections.ICollection.SyncRoot" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.SyncRoot</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="35415-380">Obtém um objeto que pode ser usado para sincronizar o acesso ao <see cref="T:System.Collections.ICollection" />.</span><span class="sxs-lookup"><span data-stu-id="35415-380">Gets an object that can be used to synchronize access to the <see cref="T:System.Collections.ICollection" />.</span></span> <span data-ttu-id="35415-381">Não há suporte a esta propriedade.</span><span class="sxs-lookup"><span data-stu-id="35415-381">This property is not supported.</span></span></summary>
        <value><span data-ttu-id="35415-382">Sempre retorna um valor nulo.</span><span class="sxs-lookup"><span data-stu-id="35415-382">Always returns null.</span></span></value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="35415-383">Não há suporte a esta propriedade.</span><span class="sxs-lookup"><span data-stu-id="35415-383">This property is not supported.</span></span></exception>
        <related type="Article" href="https://msdn.microsoft.com/library/2e7ca21f-786c-4367-96be-0cf3f3dcc6bd"><span data-ttu-id="35415-384">Coleções thread-safe</span><span class="sxs-lookup"><span data-stu-id="35415-384">Thread-Safe Collections</span></span></related>
        <related type="Article" href="https://msdn.microsoft.com/library/81b64b95-13f7-4532-9249-ab532f629598"><span data-ttu-id="35415-385">Como adicionar e remover itens de um ConcurrentDictionary</span><span class="sxs-lookup"><span data-stu-id="35415-385">How to: Add and Remove Items from a ConcurrentDictionary</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IDictionary.Add">
      <MemberSignature Language="C#" Value="void IDictionary.Add (object key, object value);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Collections.IDictionary.Add(object key, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Concurrent.ConcurrentDictionary`2.System#Collections#IDictionary#Add(System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Sub Add (key As Object, value As Object) Implements IDictionary.Add" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Collections.IDictionary.Add(System::Object ^ key, System::Object ^ value) = System::Collections::IDictionary::Add;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IDictionary.Add(System.Object,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.Object" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="key"><span data-ttu-id="35415-386">O objeto a ser usado como a chave.</span><span class="sxs-lookup"><span data-stu-id="35415-386">The object to use as the key.</span></span></param>
        <param name="value"><span data-ttu-id="35415-387">O objeto a ser usado como o valor.</span><span class="sxs-lookup"><span data-stu-id="35415-387">The object to use as the value.</span></span></param>
        <summary><span data-ttu-id="35415-388">Adiciona a chave e o valor especificados ao dicionário.</span><span class="sxs-lookup"><span data-stu-id="35415-388">Adds the specified key and value to the dictionary.</span></span></summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="35415-389"><paramref name="key" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="35415-389"><paramref name="key" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="35415-390">O <paramref name="key" /> é de um tipo que não é atribuível ao tipo de chave do <see cref="T:System.Collections.Generic.Dictionary`2" />.</span><span class="sxs-lookup"><span data-stu-id="35415-390"><paramref name="key" /> is of a type that is not assignable to the key type  of the <see cref="T:System.Collections.Generic.Dictionary`2" />.</span></span>  
  
<span data-ttu-id="35415-391">- ou -</span><span class="sxs-lookup"><span data-stu-id="35415-391">-or-</span></span> 
 <span data-ttu-id="35415-392">O <paramref name="value" /> é de um tipo que não é atribuível ao tipo de valores no <see cref="T:System.Collections.Generic.Dictionary`2" />.</span><span class="sxs-lookup"><span data-stu-id="35415-392"><paramref name="value" /> is of a type that is not assignable to the type of values in the <see cref="T:System.Collections.Generic.Dictionary`2" />.</span></span>  
  
<span data-ttu-id="35415-393">- ou -</span><span class="sxs-lookup"><span data-stu-id="35415-393">-or-</span></span> 
<span data-ttu-id="35415-394">Já existe um valor com a mesma chave no <see cref="T:System.Collections.Generic.Dictionary`2" />.</span><span class="sxs-lookup"><span data-stu-id="35415-394">A value with the same key already exists in the <see cref="T:System.Collections.Generic.Dictionary`2" />.</span></span></exception>
        <exception cref="T:System.OverflowException"><span data-ttu-id="35415-395">O dicionário já contém o número máximo de elementos (<see cref="F:System.Int32.MaxValue" />).</span><span class="sxs-lookup"><span data-stu-id="35415-395">The dictionary already contains the maximum number of elements (<see cref="F:System.Int32.MaxValue" />).</span></span></exception>
        <related type="Article" href="https://msdn.microsoft.com/library/2e7ca21f-786c-4367-96be-0cf3f3dcc6bd"><span data-ttu-id="35415-396">Coleções thread-safe</span><span class="sxs-lookup"><span data-stu-id="35415-396">Thread-Safe Collections</span></span></related>
        <related type="Article" href="https://msdn.microsoft.com/library/81b64b95-13f7-4532-9249-ab532f629598"><span data-ttu-id="35415-397">Como adicionar e remover itens de um ConcurrentDictionary</span><span class="sxs-lookup"><span data-stu-id="35415-397">How to: Add and Remove Items from a ConcurrentDictionary</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IDictionary.Contains">
      <MemberSignature Language="C#" Value="bool IDictionary.Contains (object key);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.Collections.IDictionary.Contains(object key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Concurrent.ConcurrentDictionary`2.System#Collections#IDictionary#Contains(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Function Contains (key As Object) As Boolean Implements IDictionary.Contains" />
      <MemberSignature Language="C++ CLI" Value=" virtual bool System.Collections.IDictionary.Contains(System::Object ^ key) = System::Collections::IDictionary::Contains;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IDictionary.Contains(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="key"><span data-ttu-id="35415-398">A chave a ser localizada no <see cref="T:System.Collections.Generic.IDictionary`2" />.</span><span class="sxs-lookup"><span data-stu-id="35415-398">The key to locate in the <see cref="T:System.Collections.Generic.IDictionary`2" />.</span></span></param>
        <summary><span data-ttu-id="35415-399">Determina se o <see cref="T:System.Collections.Generic.IDictionary`2" /> contém um elemento com a chave especificada.</span><span class="sxs-lookup"><span data-stu-id="35415-399">Gets whether the <see cref="T:System.Collections.Generic.IDictionary`2" /> contains an element with the specified key.</span></span></summary>
        <returns><span data-ttu-id="35415-400"><see langword="true" /> se o <see cref="T:System.Collections.Generic.IDictionary`2" /> contiver um elemento com a chave especificada; caso contrário, <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="35415-400"><see langword="true" /> if the <see cref="T:System.Collections.Generic.IDictionary`2" /> contains an element with the specified key; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="35415-401"><paramref name="key" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="35415-401"><paramref name="key" /> is <see langword="null" />.</span></span></exception>
        <related type="Article" href="https://msdn.microsoft.com/library/2e7ca21f-786c-4367-96be-0cf3f3dcc6bd"><span data-ttu-id="35415-402">Coleções thread-safe</span><span class="sxs-lookup"><span data-stu-id="35415-402">Thread-Safe Collections</span></span></related>
        <related type="Article" href="https://msdn.microsoft.com/library/81b64b95-13f7-4532-9249-ab532f629598"><span data-ttu-id="35415-403">Como adicionar e remover itens de um ConcurrentDictionary</span><span class="sxs-lookup"><span data-stu-id="35415-403">How to: Add and Remove Items from a ConcurrentDictionary</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IDictionary.GetEnumerator">
      <MemberSignature Language="C#" Value="System.Collections.IDictionaryEnumerator IDictionary.GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.IDictionaryEnumerator System.Collections.IDictionary.GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Concurrent.ConcurrentDictionary`2.System#Collections#IDictionary#GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Function GetEnumerator () As IDictionaryEnumerator Implements IDictionary.GetEnumerator" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::IDictionaryEnumerator ^ System.Collections.IDictionary.GetEnumerator() = System::Collections::IDictionary::GetEnumerator;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IDictionary.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IDictionaryEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="35415-404">Fornece um <see cref="T:System.Collections.IDictionaryEnumerator" /> para o <see cref="T:System.Collections.Generic.IDictionary`2" />.</span><span class="sxs-lookup"><span data-stu-id="35415-404">Provides a <see cref="T:System.Collections.IDictionaryEnumerator" /> for the <see cref="T:System.Collections.Generic.IDictionary`2" />.</span></span></summary>
        <returns><span data-ttu-id="35415-405">Um <see cref="T:System.Collections.IDictionaryEnumerator" /> para o <see cref="T:System.Collections.Generic.IDictionary`2" />.</span><span class="sxs-lookup"><span data-stu-id="35415-405">A <see cref="T:System.Collections.IDictionaryEnumerator" /> for the <see cref="T:System.Collections.Generic.IDictionary`2" />.</span></span></returns>
        <remarks>To be added.</remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/2e7ca21f-786c-4367-96be-0cf3f3dcc6bd"><span data-ttu-id="35415-406">Coleções thread-safe</span><span class="sxs-lookup"><span data-stu-id="35415-406">Thread-Safe Collections</span></span></related>
        <related type="Article" href="https://msdn.microsoft.com/library/81b64b95-13f7-4532-9249-ab532f629598"><span data-ttu-id="35415-407">Como adicionar e remover itens de um ConcurrentDictionary</span><span class="sxs-lookup"><span data-stu-id="35415-407">How to: Add and Remove Items from a ConcurrentDictionary</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IDictionary.IsFixedSize">
      <MemberSignature Language="C#" Value="bool System.Collections.IDictionary.IsFixedSize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Collections.IDictionary.IsFixedSize" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Concurrent.ConcurrentDictionary`2.System#Collections#IDictionary#IsFixedSize" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsFixedSize As Boolean Implements IDictionary.IsFixedSize" />
      <MemberSignature Language="C++ CLI" Value="property bool System::Collections::IDictionary::IsFixedSize { bool get(); };" />
      <MemberSignature Language="F#" Usage="System.Collections.IDictionary.IsFixedSize" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IDictionary.IsFixedSize</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="35415-408">Obtém um valor que indica se o <see cref="T:System.Collections.Generic.IDictionary`2" /> tem um tamanho fixo.</span><span class="sxs-lookup"><span data-stu-id="35415-408">Gets a value indicating whether the <see cref="T:System.Collections.Generic.IDictionary`2" /> has a fixed size.</span></span></summary>
        <value><span data-ttu-id="35415-409"><see langword="true" /> se o <see cref="T:System.Collections.Generic.IDictionary`2" /> tiver um valor fixo; caso contrário, <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="35415-409"><see langword="true" /> if the <see cref="T:System.Collections.Generic.IDictionary`2" /> has a fixed size; otherwise, <see langword="false" />.</span></span> <span data-ttu-id="35415-410">Para <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" />, essa propriedade sempre retorna <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="35415-410">For <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" />, this property always returns <see langword="false" />.</span></span></value>
        <remarks>To be added.</remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/2e7ca21f-786c-4367-96be-0cf3f3dcc6bd"><span data-ttu-id="35415-411">Coleções thread-safe</span><span class="sxs-lookup"><span data-stu-id="35415-411">Thread-Safe Collections</span></span></related>
        <related type="Article" href="https://msdn.microsoft.com/library/81b64b95-13f7-4532-9249-ab532f629598"><span data-ttu-id="35415-412">Como adicionar e remover itens de um ConcurrentDictionary</span><span class="sxs-lookup"><span data-stu-id="35415-412">How to: Add and Remove Items from a ConcurrentDictionary</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IDictionary.IsReadOnly">
      <MemberSignature Language="C#" Value="bool System.Collections.IDictionary.IsReadOnly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Collections.IDictionary.IsReadOnly" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Concurrent.ConcurrentDictionary`2.System#Collections#IDictionary#IsReadOnly" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsReadOnly As Boolean Implements IDictionary.IsReadOnly" />
      <MemberSignature Language="C++ CLI" Value="property bool System::Collections::IDictionary::IsReadOnly { bool get(); };" />
      <MemberSignature Language="F#" Usage="System.Collections.IDictionary.IsReadOnly" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IDictionary.IsReadOnly</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="35415-413">Obtém um valor que indica se o <see cref="T:System.Collections.Generic.IDictionary`2" /> é somente leitura.</span><span class="sxs-lookup"><span data-stu-id="35415-413">Gets a value indicating whether the <see cref="T:System.Collections.Generic.IDictionary`2" /> is read-only.</span></span></summary>
        <value><span data-ttu-id="35415-414"><see langword="true" /> se o <see cref="T:System.Collections.Generic.IDictionary`2" /> for somente leitura; caso contrário, <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="35415-414"><see langword="true" /> if the <see cref="T:System.Collections.Generic.IDictionary`2" /> is read-only; otherwise, <see langword="false" />.</span></span> <span data-ttu-id="35415-415">Para <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" />, essa propriedade sempre retorna <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="35415-415">For <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" />, this property always returns <see langword="false" />.</span></span></value>
        <remarks>To be added.</remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/2e7ca21f-786c-4367-96be-0cf3f3dcc6bd"><span data-ttu-id="35415-416">Coleções thread-safe</span><span class="sxs-lookup"><span data-stu-id="35415-416">Thread-Safe Collections</span></span></related>
        <related type="Article" href="https://msdn.microsoft.com/library/81b64b95-13f7-4532-9249-ab532f629598"><span data-ttu-id="35415-417">Como adicionar e remover itens de um ConcurrentDictionary</span><span class="sxs-lookup"><span data-stu-id="35415-417">How to: Add and Remove Items from a ConcurrentDictionary</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IDictionary.Item">
      <MemberSignature Language="C#" Value="object System.Collections.IDictionary.Item[object key] { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object System.Collections.IDictionary.Item(object)" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Concurrent.ConcurrentDictionary`2.System#Collections#IDictionary#Item(System.Object)" />
      <MemberSignature Language="VB.NET" Value=" Property Item(key As Object) As Object Implements IDictionary.Item" />
      <MemberSignature Language="C++ CLI" Value="property System::Object ^ System::Collections::IDictionary::Item[System::Object ^] { System::Object ^ get(System::Object ^ key); void set(System::Object ^ key, System::Object ^ value); };" />
      <MemberSignature Language="F#" Usage="System.Collections.IDictionary.Item" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IDictionary.Item(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="key"><span data-ttu-id="35415-418">A chave do valor a ser obtido ou definido.</span><span class="sxs-lookup"><span data-stu-id="35415-418">The key of the value to get or set.</span></span></param>
        <summary><span data-ttu-id="35415-419">Obtém ou define o valor associado à chave especificada.</span><span class="sxs-lookup"><span data-stu-id="35415-419">Gets or sets the value associated with the specified key.</span></span></summary>
        <value><span data-ttu-id="35415-420">O valor associado à chave especificada ou <see langword="null" /> se <paramref name="key" /> não estiver no dicionário ou <paramref name="key" /> for de um tipo que não é atribuível ao tipo de chave de <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" />.</span><span class="sxs-lookup"><span data-stu-id="35415-420">The value associated with the specified key, or  <see langword="null" /> if <paramref name="key" /> is not in the dictionary or <paramref name="key" /> is of a type that is not assignable to the key type of the <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" />.</span></span></value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="35415-421"><paramref name="key" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="35415-421"><paramref name="key" /> is  <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="35415-422">Um valor está sendo atribuído e <paramref name="key" /> é de um tipo que não é atribuível ao tipo de chave ou ao tipo de valor do <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" />.</span><span class="sxs-lookup"><span data-stu-id="35415-422">A value is being assigned, and <paramref name="key" /> is of a type that is not assignable to the key type or the value type of the <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" />.</span></span></exception>
        <related type="Article" href="https://msdn.microsoft.com/library/2e7ca21f-786c-4367-96be-0cf3f3dcc6bd"><span data-ttu-id="35415-423">Coleções thread-safe</span><span class="sxs-lookup"><span data-stu-id="35415-423">Thread-Safe Collections</span></span></related>
        <related type="Article" href="https://msdn.microsoft.com/library/81b64b95-13f7-4532-9249-ab532f629598"><span data-ttu-id="35415-424">Como adicionar e remover itens de um ConcurrentDictionary</span><span class="sxs-lookup"><span data-stu-id="35415-424">How to: Add and Remove Items from a ConcurrentDictionary</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IDictionary.Keys">
      <MemberSignature Language="C#" Value="System.Collections.ICollection System.Collections.IDictionary.Keys { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.ICollection System.Collections.IDictionary.Keys" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Concurrent.ConcurrentDictionary`2.System#Collections#IDictionary#Keys" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property Keys As ICollection Implements IDictionary.Keys" />
      <MemberSignature Language="C++ CLI" Value="property System::Collections::ICollection ^ System::Collections::IDictionary::Keys { System::Collections::ICollection ^ get(); };" />
      <MemberSignature Language="F#" Usage="System.Collections.IDictionary.Keys" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IDictionary.Keys</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ICollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="35415-425">Obtém um <see cref="T:System.Collections.ICollection" /> que contém as chaves do <see cref="T:System.Collections.Generic.IDictionary`2" />.</span><span class="sxs-lookup"><span data-stu-id="35415-425">Gets an <see cref="T:System.Collections.ICollection" /> that contains the keys of the  <see cref="T:System.Collections.Generic.IDictionary`2" />.</span></span></summary>
        <value><span data-ttu-id="35415-426">Uma interface que contém as chaves do <see cref="T:System.Collections.Generic.IDictionary`2" />.</span><span class="sxs-lookup"><span data-stu-id="35415-426">An interface that contains the keys of the <see cref="T:System.Collections.Generic.IDictionary`2" />.</span></span></value>
        <remarks>To be added.</remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/2e7ca21f-786c-4367-96be-0cf3f3dcc6bd"><span data-ttu-id="35415-427">Coleções thread-safe</span><span class="sxs-lookup"><span data-stu-id="35415-427">Thread-Safe Collections</span></span></related>
        <related type="Article" href="https://msdn.microsoft.com/library/81b64b95-13f7-4532-9249-ab532f629598"><span data-ttu-id="35415-428">Como adicionar e remover itens de um ConcurrentDictionary</span><span class="sxs-lookup"><span data-stu-id="35415-428">How to: Add and Remove Items from a ConcurrentDictionary</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IDictionary.Remove">
      <MemberSignature Language="C#" Value="void IDictionary.Remove (object key);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Collections.IDictionary.Remove(object key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Concurrent.ConcurrentDictionary`2.System#Collections#IDictionary#Remove(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Sub Remove (key As Object) Implements IDictionary.Remove" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Collections.IDictionary.Remove(System::Object ^ key) = System::Collections::IDictionary::Remove;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IDictionary.Remove(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="key"><span data-ttu-id="35415-429">A chave do elemento a ser removido.</span><span class="sxs-lookup"><span data-stu-id="35415-429">The key of the element to remove.</span></span></param>
        <summary><span data-ttu-id="35415-430">Remove o elemento com a chave especificada do <see cref="T:System.Collections.IDictionary" />.</span><span class="sxs-lookup"><span data-stu-id="35415-430">Removes the element with the specified key from the <see cref="T:System.Collections.IDictionary" />.</span></span></summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="35415-431"><paramref name="key" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="35415-431"><paramref name="key" /> is <see langword="null" />.</span></span></exception>
        <related type="Article" href="https://msdn.microsoft.com/library/2e7ca21f-786c-4367-96be-0cf3f3dcc6bd"><span data-ttu-id="35415-432">Coleções thread-safe</span><span class="sxs-lookup"><span data-stu-id="35415-432">Thread-Safe Collections</span></span></related>
        <related type="Article" href="https://msdn.microsoft.com/library/81b64b95-13f7-4532-9249-ab532f629598"><span data-ttu-id="35415-433">Como adicionar e remover itens de um ConcurrentDictionary</span><span class="sxs-lookup"><span data-stu-id="35415-433">How to: Add and Remove Items from a ConcurrentDictionary</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IDictionary.Values">
      <MemberSignature Language="C#" Value="System.Collections.ICollection System.Collections.IDictionary.Values { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.ICollection System.Collections.IDictionary.Values" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Concurrent.ConcurrentDictionary`2.System#Collections#IDictionary#Values" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property Values As ICollection Implements IDictionary.Values" />
      <MemberSignature Language="C++ CLI" Value="property System::Collections::ICollection ^ System::Collections::IDictionary::Values { System::Collections::ICollection ^ get(); };" />
      <MemberSignature Language="F#" Usage="System.Collections.IDictionary.Values" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IDictionary.Values</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ICollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="35415-434">Obtém um <see cref="T:System.Collections.ICollection" /> que contém os valores no <see cref="T:System.Collections.IDictionary" />.</span><span class="sxs-lookup"><span data-stu-id="35415-434">Gets an <see cref="T:System.Collections.ICollection" /> that contains the values in the <see cref="T:System.Collections.IDictionary" />.</span></span></summary>
        <value><span data-ttu-id="35415-435">Uma interface que contém os valores de <see cref="T:System.Collections.IDictionary" />.</span><span class="sxs-lookup"><span data-stu-id="35415-435">An interface that contains the values in the <see cref="T:System.Collections.IDictionary" />.</span></span></value>
        <remarks>To be added.</remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/2e7ca21f-786c-4367-96be-0cf3f3dcc6bd"><span data-ttu-id="35415-436">Coleções thread-safe</span><span class="sxs-lookup"><span data-stu-id="35415-436">Thread-Safe Collections</span></span></related>
        <related type="Article" href="https://msdn.microsoft.com/library/81b64b95-13f7-4532-9249-ab532f629598"><span data-ttu-id="35415-437">Como adicionar e remover itens de um ConcurrentDictionary</span><span class="sxs-lookup"><span data-stu-id="35415-437">How to: Add and Remove Items from a ConcurrentDictionary</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IEnumerable.GetEnumerator">
      <MemberSignature Language="C#" Value="System.Collections.IEnumerator IEnumerable.GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Concurrent.ConcurrentDictionary`2.System#Collections#IEnumerable#GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Function GetEnumerator () As IEnumerator Implements IEnumerable.GetEnumerator" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::IEnumerator ^ System.Collections.IEnumerable.GetEnumerator() = System::Collections::IEnumerable::GetEnumerator;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IEnumerable.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="35415-438">Retorna um enumerador que itera por meio de <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" />.</span><span class="sxs-lookup"><span data-stu-id="35415-438">Returns an enumerator that iterates through the <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" />.</span></span></summary>
        <returns><span data-ttu-id="35415-439">Um enumerador para o <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" />.</span><span class="sxs-lookup"><span data-stu-id="35415-439">An enumerator for the <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="35415-440">Enumerador retornado do dicionário é seguro usar simultaneamente com leituras e gravações ao dicionário, no entanto, ele não representa um instantâneo do momento em que-in-time do dicionário.</span><span class="sxs-lookup"><span data-stu-id="35415-440">The enumerator returned from the dictionary is safe to use concurrently with reads and writes to the dictionary, however it does not represent a moment-in-time snapshot of the dictionary.</span></span> <span data-ttu-id="35415-441">O conteúdo exposto por meio do enumerador pode conter modificações feitas no dicionário após <xref:System.Collections.Concurrent.ConcurrentDictionary%602.GetEnumerator%2A> foi chamado.</span><span class="sxs-lookup"><span data-stu-id="35415-441">The contents exposed through the enumerator may contain modifications made to the dictionary after <xref:System.Collections.Concurrent.ConcurrentDictionary%602.GetEnumerator%2A> was called.</span></span>  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/2e7ca21f-786c-4367-96be-0cf3f3dcc6bd"><span data-ttu-id="35415-442">Coleções thread-safe</span><span class="sxs-lookup"><span data-stu-id="35415-442">Thread-Safe Collections</span></span></related>
        <related type="Article" href="https://msdn.microsoft.com/library/81b64b95-13f7-4532-9249-ab532f629598"><span data-ttu-id="35415-443">Como adicionar e remover itens de um ConcurrentDictionary</span><span class="sxs-lookup"><span data-stu-id="35415-443">How to: Add and Remove Items from a ConcurrentDictionary</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="ToArray">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;[] ToArray ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Collections.Generic.KeyValuePair`2&lt;!TKey, !TValue&gt;[] ToArray() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Concurrent.ConcurrentDictionary`2.ToArray" />
      <MemberSignature Language="VB.NET" Value="Public Function ToArray () As KeyValuePair(Of TKey, TValue)()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Collections::Generic::KeyValuePair&lt;TKey, TValue&gt;&gt; ^ ToArray();" />
      <MemberSignature Language="F#" Value="member this.ToArray : unit -&gt; System.Collections.Generic.KeyValuePair&lt;'Key, 'Value&gt;[]" Usage="concurrentDictionary.ToArray " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="35415-444">Copia os pares de chave e valor armazenados em <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" /> para uma nova matriz.</span><span class="sxs-lookup"><span data-stu-id="35415-444">Copies the key and value pairs stored in the <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" /> to a new array.</span></span></summary>
        <returns><span data-ttu-id="35415-445">Uma nova matriz que contém um instantâneo de pares de chave e valor copiados de <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" />.</span><span class="sxs-lookup"><span data-stu-id="35415-445">A new array containing a snapshot of key and value pairs copied from the <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" />.</span></span></returns>
        <remarks>To be added.</remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/2e7ca21f-786c-4367-96be-0cf3f3dcc6bd"><span data-ttu-id="35415-446">Coleções thread-safe</span><span class="sxs-lookup"><span data-stu-id="35415-446">Thread-Safe Collections</span></span></related>
        <related type="Article" href="https://msdn.microsoft.com/library/81b64b95-13f7-4532-9249-ab532f629598"><span data-ttu-id="35415-447">Como adicionar e remover itens de um ConcurrentDictionary</span><span class="sxs-lookup"><span data-stu-id="35415-447">How to: Add and Remove Items from a ConcurrentDictionary</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="TryAdd">
      <MemberSignature Language="C#" Value="public bool TryAdd (TKey key, TValue value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryAdd(!TKey key, !TValue value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Concurrent.ConcurrentDictionary`2.TryAdd(`0,`1)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryAdd (key As TKey, value As TValue) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryAdd(TKey key, TValue value);" />
      <MemberSignature Language="F#" Value="member this.TryAdd : 'Key * 'Value -&gt; bool" Usage="concurrentDictionary.TryAdd (key, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="TKey" />
        <Parameter Name="value" Type="TValue" />
      </Parameters>
      <Docs>
        <param name="key"><span data-ttu-id="35415-448">A chave do elemento a ser adicionada.</span><span class="sxs-lookup"><span data-stu-id="35415-448">The key of the element to add.</span></span></param>
        <param name="value"><span data-ttu-id="35415-449">O valor do elemento a ser adicionado.</span><span class="sxs-lookup"><span data-stu-id="35415-449">The value of the element to add.</span></span> <span data-ttu-id="35415-450">O valor pode ser <see langword="null" /> para tipos de referência.</span><span class="sxs-lookup"><span data-stu-id="35415-450">The value can be  <see langword="null" /> for reference types.</span></span></param>
        <summary><span data-ttu-id="35415-451">Tenta adicionar a chave e o valor especificados ao <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" />.</span><span class="sxs-lookup"><span data-stu-id="35415-451">Attempts to add the specified key and value to the <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" />.</span></span></summary>
        <returns><span data-ttu-id="35415-452"><see langword="true" /> se o par chave/valor foi adicionado ao <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" /> com êxito; <see langword="false" /> se a chave já existir.</span><span class="sxs-lookup"><span data-stu-id="35415-452"><see langword="true" /> if the key/value pair was added to the <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" /> successfully; <see langword="false" /> if the key already exists.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="35415-453">Esse método retorna `false` se a chave já existe.</span><span class="sxs-lookup"><span data-stu-id="35415-453">This method returns `false` if the key already exists.</span></span> <span data-ttu-id="35415-454">Use o <xref:System.Collections.Concurrent.ConcurrentDictionary%602.TryUpdate%2A> ou <xref:System.Collections.Concurrent.ConcurrentDictionary%602.AddOrUpdate%2A> método para atualizar o valor no caso de uma chave já existe.</span><span class="sxs-lookup"><span data-stu-id="35415-454">Use the <xref:System.Collections.Concurrent.ConcurrentDictionary%602.TryUpdate%2A> or <xref:System.Collections.Concurrent.ConcurrentDictionary%602.AddOrUpdate%2A> method to update the value in case a key already exists.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="35415-455">O exemplo a seguir mostra como chamar o <xref:System.Collections.Concurrent.ConcurrentDictionary%602.TryAdd%2A?displayProperty=nameWithType> método:</span><span class="sxs-lookup"><span data-stu-id="35415-455">The following example shows how to call the <xref:System.Collections.Concurrent.ConcurrentDictionary%602.TryAdd%2A?displayProperty=nameWithType> method:</span></span>  
  
 [!code-csharp[System.Collections.Concurrent.ConcurrentDictionary#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.collections.concurrent.concurrentdictionary/cs/concdictionary.cs#2)]
 [!code-vb[System.Collections.Concurrent.ConcurrentDictionary#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.collections.concurrent.concurrentdictionary/vb/concdictionary.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="35415-456"><paramref name="key" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="35415-456"><paramref name="key" /> is  <see langword="null" />.</span></span></exception>
        <exception cref="T:System.OverflowException"><span data-ttu-id="35415-457">O dicionário já contém o número máximo de elementos (<see cref="F:System.Int32.MaxValue" />).</span><span class="sxs-lookup"><span data-stu-id="35415-457">The dictionary already contains the maximum number of elements (<see cref="F:System.Int32.MaxValue" />).</span></span></exception>
        <related type="Article" href="https://msdn.microsoft.com/library/2e7ca21f-786c-4367-96be-0cf3f3dcc6bd"><span data-ttu-id="35415-458">Coleções thread-safe</span><span class="sxs-lookup"><span data-stu-id="35415-458">Thread-Safe Collections</span></span></related>
        <related type="Article" href="https://msdn.microsoft.com/library/81b64b95-13f7-4532-9249-ab532f629598"><span data-ttu-id="35415-459">Como adicionar e remover itens de um ConcurrentDictionary</span><span class="sxs-lookup"><span data-stu-id="35415-459">How to: Add and Remove Items from a ConcurrentDictionary</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="TryGetValue">
      <MemberSignature Language="C#" Value="public bool TryGetValue (TKey key, out TValue value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool TryGetValue(!TKey key, [out] !TValue&amp; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Concurrent.ConcurrentDictionary`2.TryGetValue(`0,`1@)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryGetValue (key As TKey, ByRef value As TValue) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool TryGetValue(TKey key, [Runtime::InteropServices::Out] TValue % value);" />
      <MemberSignature Language="F#" Value="abstract member TryGetValue : 'Key *  -&gt; bool&#xA;override this.TryGetValue : 'Key *  -&gt; bool" Usage="concurrentDictionary.TryGetValue (key, value)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.IDictionary`2.TryGetValue(`0,`1@)</InterfaceMember>
        <InterfaceMember>M:System.Collections.Generic.IReadOnlyDictionary`2.TryGetValue(`0,`1@)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="TKey" />
        <Parameter Name="value" Type="TValue" RefType="out" />
      </Parameters>
      <Docs>
        <param name="key"><span data-ttu-id="35415-460">A chave do valor a ser obtido.</span><span class="sxs-lookup"><span data-stu-id="35415-460">The key of the value to get.</span></span></param>
        <param name="value"><span data-ttu-id="35415-461">Quando esse método for retornado, ele conterá o objeto do <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" /> que tem a chave especificada ou o valor padrão do tipo se a operação tiver falhado.</span><span class="sxs-lookup"><span data-stu-id="35415-461">When this method returns, contains the object from the <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" /> that has the specified key, or the default value of the type if the operation failed.</span></span></param>
        <summary><span data-ttu-id="35415-462">Tenta obter o valor associado à chave especificada do <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" />.</span><span class="sxs-lookup"><span data-stu-id="35415-462">Attempts to get the value associated with the specified key from the <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" />.</span></span></summary>
        <returns><span data-ttu-id="35415-463"><see langword="true" /> se a chave foi encontrada no <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" />; caso contrário, <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="35415-463"><see langword="true" /> if the key was found in the <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" />; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="35415-464"><paramref name="key" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="35415-464"><paramref name="key" /> is  <see langword="null" />.</span></span></exception>
        <related type="Article" href="https://msdn.microsoft.com/library/2e7ca21f-786c-4367-96be-0cf3f3dcc6bd"><span data-ttu-id="35415-465">Coleções thread-safe</span><span class="sxs-lookup"><span data-stu-id="35415-465">Thread-Safe Collections</span></span></related>
        <related type="Article" href="https://msdn.microsoft.com/library/81b64b95-13f7-4532-9249-ab532f629598"><span data-ttu-id="35415-466">Como adicionar e remover itens de um ConcurrentDictionary</span><span class="sxs-lookup"><span data-stu-id="35415-466">How to: Add and Remove Items from a ConcurrentDictionary</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="TryRemove">
      <MemberSignature Language="C#" Value="public bool TryRemove (TKey key, out TValue value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryRemove(!TKey key, [out] !TValue&amp; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Concurrent.ConcurrentDictionary`2.TryRemove(`0,`1@)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryRemove (key As TKey, ByRef value As TValue) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryRemove(TKey key, [Runtime::InteropServices::Out] TValue % value);" />
      <MemberSignature Language="F#" Value="member this.TryRemove : 'Key *  -&gt; bool" Usage="concurrentDictionary.TryRemove (key, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="TKey" />
        <Parameter Name="value" Type="TValue" RefType="out" />
      </Parameters>
      <Docs>
        <param name="key"><span data-ttu-id="35415-467">A chave do elemento a ser removido e retornado.</span><span class="sxs-lookup"><span data-stu-id="35415-467">The key of the element to remove and return.</span></span></param>
        <param name="value"><span data-ttu-id="35415-468">Quando for retornado, esse método conterá o objeto removido do <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" /> ou o valor padrão do tipo <see langword="TValue" /> se <paramref name="key" /> não existir.</span><span class="sxs-lookup"><span data-stu-id="35415-468">When this method returns, contains the object removed from the <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" />, or the default value of  the <see langword="TValue" /> type if <paramref name="key" /> does not exist.</span></span></param>
        <summary><span data-ttu-id="35415-469">Tenta remover e retornar o valor com a chave especificada do <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" />.</span><span class="sxs-lookup"><span data-stu-id="35415-469">Attempts to remove and return the value that has the specified key from the <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" />.</span></span></summary>
        <returns><span data-ttu-id="35415-470"><see langword="true" /> se um objeto tiver sido removido com êxito; caso contrário, <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="35415-470"><see langword="true" /> if the object was removed successfully; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="35415-471">O exemplo a seguir mostra como chamar o <xref:System.Collections.Concurrent.ConcurrentDictionary%602.TryRemove%2A?displayProperty=nameWithType> método:</span><span class="sxs-lookup"><span data-stu-id="35415-471">The following example shows how to call the <xref:System.Collections.Concurrent.ConcurrentDictionary%602.TryRemove%2A?displayProperty=nameWithType> method:</span></span>  
  
 [!code-csharp[System.Collections.Concurrent.ConcurrentDictionary#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.collections.concurrent.concurrentdictionary/cs/concdictionary.cs#2)]
 [!code-vb[System.Collections.Concurrent.ConcurrentDictionary#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.collections.concurrent.concurrentdictionary/vb/concdictionary.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="35415-472"><paramref name="key" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="35415-472"><paramref name="key" /> is  <see langword="null" />.</span></span></exception>
        <related type="Article" href="https://msdn.microsoft.com/library/2e7ca21f-786c-4367-96be-0cf3f3dcc6bd"><span data-ttu-id="35415-473">Coleções thread-safe</span><span class="sxs-lookup"><span data-stu-id="35415-473">Thread-Safe Collections</span></span></related>
        <related type="Article" href="https://msdn.microsoft.com/library/81b64b95-13f7-4532-9249-ab532f629598"><span data-ttu-id="35415-474">Como adicionar e remover itens de um ConcurrentDictionary</span><span class="sxs-lookup"><span data-stu-id="35415-474">How to: Add and Remove Items from a ConcurrentDictionary</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="TryUpdate">
      <MemberSignature Language="C#" Value="public bool TryUpdate (TKey key, TValue newValue, TValue comparisonValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryUpdate(!TKey key, !TValue newValue, !TValue comparisonValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Concurrent.ConcurrentDictionary`2.TryUpdate(`0,`1,`1)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryUpdate (key As TKey, newValue As TValue, comparisonValue As TValue) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryUpdate(TKey key, TValue newValue, TValue comparisonValue);" />
      <MemberSignature Language="F#" Value="member this.TryUpdate : 'Key * 'Value * 'Value -&gt; bool" Usage="concurrentDictionary.TryUpdate (key, newValue, comparisonValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="TKey" />
        <Parameter Name="newValue" Type="TValue" />
        <Parameter Name="comparisonValue" Type="TValue" />
      </Parameters>
      <Docs>
        <param name="key"><span data-ttu-id="35415-475">A chave do valor que é comparada com <paramref name="comparisonValue" /> e possivelmente substituída.</span><span class="sxs-lookup"><span data-stu-id="35415-475">The key of the value that is compared with <paramref name="comparisonValue" /> and possibly replaced.</span></span></param>
        <param name="newValue"><span data-ttu-id="35415-476">O valor que substitui o valor do elemento que foi especificado <paramref name="key" /> se a comparação resulta em igualdade.</span><span class="sxs-lookup"><span data-stu-id="35415-476">The value that replaces the value of the element that has the specified <paramref name="key" /> if the comparison results in equality.</span></span></param>
        <param name="comparisonValue"><span data-ttu-id="35415-477">O valor é comparado com o valor do elemento que tem o valor de <paramref name="key" /> especificado.</span><span class="sxs-lookup"><span data-stu-id="35415-477">The value that is compared with the value of the element that has the specified <paramref name="key" />.</span></span></param>
        <summary><span data-ttu-id="35415-478">Atualizará o valor associado a <paramref name="key" /> para <paramref name="newValue" /> se o valor existente com <paramref name="key" /> for igual a <paramref name="comparisonValue" />.</span><span class="sxs-lookup"><span data-stu-id="35415-478">Updates the value associated with <paramref name="key" /> to <paramref name="newValue" /> if the existing value with <paramref name="key" /> is equal to <paramref name="comparisonValue" />.</span></span></summary>
        <returns><span data-ttu-id="35415-479"><see langword="true" /> se o valor com <paramref name="key" /> era igual a <paramref name="comparisonValue" /> e foi substituído pelo <paramref name="newValue" />; caso contrário, <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="35415-479"><see langword="true" /> if the value with <paramref name="key" /> was equal to <paramref name="comparisonValue" /> and was replaced with <paramref name="newValue" />; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="35415-480">O exemplo a seguir mostra como chamar o <xref:System.Collections.Concurrent.ConcurrentDictionary%602.TryUpdate%2A> método:</span><span class="sxs-lookup"><span data-stu-id="35415-480">The following example shows how to call the <xref:System.Collections.Concurrent.ConcurrentDictionary%602.TryUpdate%2A> method:</span></span>  
  
 [!code-csharp[System.Collections.Concurrent.ConcurrentDictionary#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.collections.concurrent.concurrentdictionary/cs/concdictionary.cs#2)]
 [!code-vb[System.Collections.Concurrent.ConcurrentDictionary#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.collections.concurrent.concurrentdictionary/vb/concdictionary.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="35415-481"><paramref name="key" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="35415-481"><paramref name="key" /> is <see langword="null" />.</span></span></exception>
        <related type="Article" href="https://msdn.microsoft.com/library/2e7ca21f-786c-4367-96be-0cf3f3dcc6bd"><span data-ttu-id="35415-482">Coleções thread-safe</span><span class="sxs-lookup"><span data-stu-id="35415-482">Thread-Safe Collections</span></span></related>
        <related type="Article" href="https://msdn.microsoft.com/library/81b64b95-13f7-4532-9249-ab532f629598"><span data-ttu-id="35415-483">Como adicionar e remover itens de um ConcurrentDictionary</span><span class="sxs-lookup"><span data-stu-id="35415-483">How to: Add and Remove Items from a ConcurrentDictionary</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Values">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.ICollection&lt;TValue&gt; Values { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.ICollection`1&lt;!TValue&gt; Values" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Concurrent.ConcurrentDictionary`2.Values" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Values As ICollection(Of TValue)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Generic::ICollection&lt;TValue&gt; ^ Values { System::Collections::Generic::ICollection&lt;TValue&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Values : System.Collections.Generic.ICollection&lt;'Value&gt;" Usage="System.Collections.Concurrent.ConcurrentDictionary&lt;'Key, 'Value&gt;.Values" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.Generic.IDictionary`2.Values</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.ICollection&lt;TValue&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="35415-484">Obtém uma coleção que contém os valores no <see cref="T:System.Collections.Generic.Dictionary`2" />.</span><span class="sxs-lookup"><span data-stu-id="35415-484">Gets a collection that contains the values in the <see cref="T:System.Collections.Generic.Dictionary`2" />.</span></span></summary>
        <value><span data-ttu-id="35415-485">Uma coleção que contém os valores no <see cref="T:System.Collections.Generic.Dictionary`2" />.</span><span class="sxs-lookup"><span data-stu-id="35415-485">A collection that contains the values in the <see cref="T:System.Collections.Generic.Dictionary`2" />.</span></span></value>
        <remarks>To be added.</remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/2e7ca21f-786c-4367-96be-0cf3f3dcc6bd"><span data-ttu-id="35415-486">Coleções thread-safe</span><span class="sxs-lookup"><span data-stu-id="35415-486">Thread-Safe Collections</span></span></related>
        <related type="Article" href="https://msdn.microsoft.com/library/81b64b95-13f7-4532-9249-ab532f629598"><span data-ttu-id="35415-487">Como adicionar e remover itens de um ConcurrentDictionary</span><span class="sxs-lookup"><span data-stu-id="35415-487">How to: Add and Remove Items from a ConcurrentDictionary</span></span></related>
      </Docs>
    </Member>
  </Members>
</Type>