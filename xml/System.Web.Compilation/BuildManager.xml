<Type Name="BuildManager" FullName="System.Web.Compilation.BuildManager">
  <Metadata><Meta Name="ms.openlocfilehash" Value="a82244528eac6e037120c521525c7c211c363f52" /><Meta Name="ms.sourcegitcommit" Value="c5fd6b431a16f0412349201a0e93a9eacddf4b35" /><Meta Name="ms.translationtype" Value="HT" /><Meta Name="ms.contentlocale" Value="pt-BR" /><Meta Name="ms.lasthandoff" Value="12/14/2018" /><Meta Name="ms.locfileid" Value="53394311" /></Metadata><TypeSignature Language="C#" Value="public sealed class BuildManager" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit BuildManager extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Web.Compilation.BuildManager" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class BuildManager" />
  <TypeSignature Language="C++ CLI" Value="public ref class BuildManager sealed" />
  <TypeSignature Language="F#" Value="type BuildManager = class" />
  <AssemblyInfo>
    <AssemblyName>System.Web</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Fornece um conjunto de métodos para ajudar a gerenciar a compilação de um aplicativo ASP.NET.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Web.Compilation.BuildManager> classe gerencia o processo de compilação de assemblies e páginas para um aplicativo. É uma classe selada e não pode ser herdada.  
  
 <xref:System.Web.Compilation.BuildManager> contém membros estáticos que fornecem informações sobre assemblies compilados.  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Web.Compilation.ClientBuildManager" />
    <altmember cref="T:System.Web.Compilation.BuildProvider" />
    <altmember cref="T:System.Web.Compilation.AssemblyBuilder" />
  </Docs>
  <Members>
    <Member MemberName="AddCompilationDependency">
      <MemberSignature Language="C#" Value="public static void AddCompilationDependency (string dependency);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void AddCompilationDependency(string dependency) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Compilation.BuildManager.AddCompilationDependency(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub AddCompilationDependency (dependency As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void AddCompilationDependency(System::String ^ dependency);" />
      <MemberSignature Language="F#" Value="static member AddCompilationDependency : string -&gt; unit" Usage="System.Web.Compilation.BuildManager.AddCompilationDependency dependency" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dependency" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="dependency">Uma cadeia de caracteres que representa uma dependência.</param>
        <summary>Especifica uma cadeia de caracteres que representa uma dependência que o gerenciador de build usa para ajudar a determinar se um build limpo é necessário.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O método deve ser chamado durante a `Application_PreStartInit` estágio do aplicativo.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">O parâmetro <paramref name="dependency" /> é <see langword="null" /> ou uma cadeia de caracteres vazia.</exception>
        <exception cref="T:System.InvalidOperationException">O método foi chamado após o estágio <see langword="Application_PreStartInit" /> do aplicativo.</exception>
      </Docs>
    </Member>
    <Member MemberName="AddReferencedAssembly">
      <MemberSignature Language="C#" Value="public static void AddReferencedAssembly (System.Reflection.Assembly assembly);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void AddReferencedAssembly(class System.Reflection.Assembly assembly) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Compilation.BuildManager.AddReferencedAssembly(System.Reflection.Assembly)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void AddReferencedAssembly(System::Reflection::Assembly ^ assembly);" />
      <MemberSignature Language="F#" Value="static member AddReferencedAssembly : System.Reflection.Assembly -&gt; unit" Usage="System.Web.Compilation.BuildManager.AddReferencedAssembly assembly" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assembly" Type="System.Reflection.Assembly" />
      </Parameters>
      <Docs>
        <param name="assembly">O assembly a ser adicionado.</param>
        <summary>Adiciona um assembly ao conjunto de assemblies referenciados do aplicativo.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Chamar esse método é equivalente a adicionar o assembly para o arquivo Web. config de nível de aplicativo. O método deve ser chamado durante a `Application_PreStartInit` estágio do aplicativo.  
  
 O <xref:System.Web.Compilation.BuildManager.GetReferencedAssemblies%2A> método retornará o conjunto de assemblies que são determinados dos arquivos de configuração e todos os assemblies que foram adicionados usando esse método.  
  
 Se for feita uma tentativa para adicionar um assembly que já foi adicionado, a entrada duplicada será ignorada.  
  
 Esse método deve ser chamado antes do `Application_Start` ocorre o evento no arquivo global. asax.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">O parâmetro <paramref name="assembly" /> é <see langword="null" /> ou está vazio.</exception>
        <exception cref="T:System.InvalidOperationException">O método não foi chamado antes da ocorrência do evento <see langword="Application_Start" /> no arquivo Global.asax.</exception>
      </Docs>
    </Member>
    <Member MemberName="BatchCompilationEnabled">
      <MemberSignature Language="C#" Value="public static Nullable&lt;bool&gt; BatchCompilationEnabled { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property valuetype System.Nullable`1&lt;bool&gt; BatchCompilationEnabled" />
      <MemberSignature Language="DocId" Value="P:System.Web.Compilation.BuildManager.BatchCompilationEnabled" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property BatchCompilationEnabled As Nullable(Of Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property Nullable&lt;bool&gt; BatchCompilationEnabled { Nullable&lt;bool&gt; get(); void set(Nullable&lt;bool&gt; value); };" />
      <MemberSignature Language="F#" Value="member this.BatchCompilationEnabled : Nullable&lt;bool&gt; with get, set" Usage="System.Web.Compilation.BuildManager.BatchCompilationEnabled" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Boolean&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define um valor que indica se a compilação de lote está habilitada.</summary>
        <value><see langword="true" /> Se a compilação em lotes está sempre habilitada, <see langword="false" /> se a compilação em lotes nunca é habilitada, ou <see langword="null" /> se for determinada que a configuração de compilação do arquivo de configuração. O valor padrão é <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esta propriedade permite ativar ou desativar a compilação em lote por meio de programação. Ele corresponde a `batch` atributo do `compilation` elemento no arquivo Web. config. Para obter mais informações, consulte [compilação Element (ASP.NET Settings Schema)](https://msdn.microsoft.com/library/7c319582-074a-4d2a-a787-03b9d4541c12).  
  
 A propriedade pode ser definida apenas no `PreApplicationStart` método. Para obter mais informações sobre o método `PreApplicationStart`, consulte <xref:System.Web.PreApplicationStartMethodAttribute>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">A propriedade não foi definida no método <see langword="PreApplicationStart" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="CodeAssemblies">
      <MemberSignature Language="C#" Value="public static System.Collections.IList CodeAssemblies { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Collections.IList CodeAssemblies" />
      <MemberSignature Language="DocId" Value="P:System.Web.Compilation.BuildManager.CodeAssemblies" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property CodeAssemblies As IList" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Collections::IList ^ CodeAssemblies { System::Collections::IList ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.CodeAssemblies : System.Collections.IList" Usage="System.Web.Compilation.BuildManager.CodeAssemblies" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IList</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém uma lista de assemblies criados no diretório App_Code.</summary>
        <value>Um <see cref="T:System.Collections.IList" /> coleção que contém os assemblies compilados no diretório App_Code.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateCachedFile">
      <MemberSignature Language="C#" Value="public static System.IO.Stream CreateCachedFile (string fileName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.Stream CreateCachedFile(string fileName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Compilation.BuildManager.CreateCachedFile(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateCachedFile (fileName As String) As Stream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::Stream ^ CreateCachedFile(System::String ^ fileName);" />
      <MemberSignature Language="F#" Value="static member CreateCachedFile : string -&gt; System.IO.Stream" Usage="System.Web.Compilation.BuildManager.CreateCachedFile fileName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="fileName">O nome do arquivo a ser criado.</param>
        <summary>Cria um arquivo armazenado em cache.</summary>
        <returns>O objeto de <see cref="T:System.IO.Stream" /> do novo link.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método e o <xref:System.Web.Compilation.BuildManager.ReadCachedFile%2A> método permitem que você execute o caching que persiste entre as reinicializações de domínio de aplicativo em ambientes de confiança parcial. Ele é usado pela estrutura MVC para cache os resultados da pesquisa de controlador.  
  
 Os dados em cache, você escreve para o <xref:System.IO.Stream> objeto que é retornado por esse método.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateInstanceFromVirtualPath">
      <MemberSignature Language="C#" Value="public static object CreateInstanceFromVirtualPath (string virtualPath, Type requiredBaseType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object CreateInstanceFromVirtualPath(string virtualPath, class System.Type requiredBaseType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Compilation.BuildManager.CreateInstanceFromVirtualPath(System.String,System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateInstanceFromVirtualPath (virtualPath As String, requiredBaseType As Type) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ CreateInstanceFromVirtualPath(System::String ^ virtualPath, Type ^ requiredBaseType);" />
      <MemberSignature Language="F#" Value="static member CreateInstanceFromVirtualPath : string * Type -&gt; obj" Usage="System.Web.Compilation.BuildManager.CreateInstanceFromVirtualPath (virtualPath, requiredBaseType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="virtualPath" Type="System.String" />
        <Parameter Name="requiredBaseType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="virtualPath">O caminho virtual do arquivo do qual criar uma instância.</param>
        <param name="requiredBaseType">O tipo base que define o objeto a ser criado.</param>
        <summary>Processa um arquivo com base em seu caminho virtual fornecido e cria uma instância do resultado.</summary>
        <returns>O <see cref="T:System.Object" /> que representa a instância do arquivo processado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Web.Compilation.BuildManager.CreateInstanceFromVirtualPath%2A> método funciona para páginas compiladas e não-compilação.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetCachedBuildDependencySet">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Retorna um conjunto de dependências de build do cache do ASP.NET.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetCachedBuildDependencySet">
      <MemberSignature Language="C#" Value="public static System.Web.Compilation.BuildDependencySet GetCachedBuildDependencySet (System.Web.HttpContext context, string virtualPath);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Web.Compilation.BuildDependencySet GetCachedBuildDependencySet(class System.Web.HttpContext context, string virtualPath) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Compilation.BuildManager.GetCachedBuildDependencySet(System.Web.HttpContext,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetCachedBuildDependencySet (context As HttpContext, virtualPath As String) As BuildDependencySet" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Web::Compilation::BuildDependencySet ^ GetCachedBuildDependencySet(System::Web::HttpContext ^ context, System::String ^ virtualPath);" />
      <MemberSignature Language="F#" Value="static member GetCachedBuildDependencySet : System.Web.HttpContext * string -&gt; System.Web.Compilation.BuildDependencySet" Usage="System.Web.Compilation.BuildManager.GetCachedBuildDependencySet (context, virtualPath)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.Compilation.BuildDependencySet</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="context" Type="System.Web.HttpContext" />
        <Parameter Name="virtualPath" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="context">O contexto da solicitação.</param>
        <param name="virtualPath">O caminho virtual do qual determinar o conjunto de dependência de build.</param>
        <summary>Retorna um conjunto de dependências de build para um caminho virtual se o caminho estiver localizado no cache do ASP.NET.</summary>
        <returns>Um objeto do <see cref="T:System.Web.Compilation.BuildDependencySet" /> que está armazenado no cache ou <see langword="null" />, se o objeto de <see cref="T:System.Web.Compilation.BuildDependencySet" /> não puder ser recuperado do cache.</returns>
        <remarks>To be added.</remarks>
        <altmember cref="T:System.Web.Compilation.BuildDependencySet" />
        <altmember cref="P:System.Web.Compilation.BuildProvider.VirtualPathDependencies" />
      </Docs>
    </Member>
    <Member MemberName="GetCachedBuildDependencySet">
      <MemberSignature Language="C#" Value="public static System.Web.Compilation.BuildDependencySet GetCachedBuildDependencySet (System.Web.HttpContext context, string virtualPath, bool ensureIsUpToDate);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Web.Compilation.BuildDependencySet GetCachedBuildDependencySet(class System.Web.HttpContext context, string virtualPath, bool ensureIsUpToDate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Compilation.BuildManager.GetCachedBuildDependencySet(System.Web.HttpContext,System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetCachedBuildDependencySet (context As HttpContext, virtualPath As String, ensureIsUpToDate As Boolean) As BuildDependencySet" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Web::Compilation::BuildDependencySet ^ GetCachedBuildDependencySet(System::Web::HttpContext ^ context, System::String ^ virtualPath, bool ensureIsUpToDate);" />
      <MemberSignature Language="F#" Value="static member GetCachedBuildDependencySet : System.Web.HttpContext * string * bool -&gt; System.Web.Compilation.BuildDependencySet" Usage="System.Web.Compilation.BuildManager.GetCachedBuildDependencySet (context, virtualPath, ensureIsUpToDate)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.Compilation.BuildDependencySet</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="context" Type="System.Web.HttpContext" />
        <Parameter Name="virtualPath" Type="System.String" />
        <Parameter Name="ensureIsUpToDate" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="context">O contexto da solicitação.</param>
        <param name="virtualPath">O caminho virtual do qual determinar o conjunto de dependência de build.</param>
        <param name="ensureIsUpToDate"><see langword="true" /> para especificar que apenas um conjunto de dependência de build atual deve ser retornado ou <see langword="false" /> para indicar que qualquer conjunto de dependência de build disponível deverá ser retornado, mesmo se não for atual. O padrão é <see langword="true" />.</param>
        <summary>Retorna um conjunto de dependência de build para um caminho virtual se o caminho estiver localizado no cache do ASP.NET, mesmo se o conteúdo não for atual.</summary>
        <returns>Um objeto do <see cref="T:System.Web.Compilation.BuildDependencySet" /> que está armazenado no cache ou <see langword="null" />, se o objeto de <see cref="T:System.Web.Compilation.BuildDependencySet" /> não puder ser recuperado do cache.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se o `ensureIsUpToDate` valor de parâmetro é definido como `true`, o <xref:System.Web.Compilation.BuildManager.GetCachedBuildDependencySet%2A?displayProperty=nameWithType> sobrecarga de método se comporta como o <xref:System.Web.Compilation.BuildManager.GetCachedBuildDependencySet%2A?displayProperty=nameWithType> sobrecarga de método. Ambas as sobrecargas retornam uma dependência de build atual definida se houver um, caso contrário, retornam `null`.  
  
 No entanto, o <xref:System.Web.Compilation.BuildManager.GetCachedBuildDependencySet%2A?displayProperty=nameWithType> sobrecarga do método inclui a opção de retornar qualquer conjunto de dependência de compilação que esteja disponível, até mesmo um desatualizados. Se o `ensureIsUpToDate` valor de parâmetro é definido como `false`, o método retornará qualquer conjunto de dependência de compilação disponíveis.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetCompiledAssembly">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly GetCompiledAssembly (string virtualPath);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly GetCompiledAssembly(string virtualPath) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Compilation.BuildManager.GetCompiledAssembly(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetCompiledAssembly (virtualPath As String) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ GetCompiledAssembly(System::String ^ virtualPath);" />
      <MemberSignature Language="F#" Value="static member GetCompiledAssembly : string -&gt; System.Reflection.Assembly" Usage="System.Web.Compilation.BuildManager.GetCompiledAssembly virtualPath" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="virtualPath" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="virtualPath">O caminho virtual para criar em um assembly.</param>
        <summary>Compila um arquivo em um assembly usando o caminho virtual especificado.</summary>
        <returns>Um objeto de <see cref="T:System.Reflection.Assembly" /> que é compilado no caminho virtual especificado, que é armazenado em cache na memória ou no disco.</returns>
        <remarks>To be added.</remarks>
        <altmember cref="T:System.Web.Compilation.BuildProvider" />
        <altmember cref="T:System.Web.Compilation.AssemblyBuilder" />
      </Docs>
    </Member>
    <Member MemberName="GetCompiledCustomString">
      <MemberSignature Language="C#" Value="public static string GetCompiledCustomString (string virtualPath);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetCompiledCustomString(string virtualPath) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Compilation.BuildManager.GetCompiledCustomString(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetCompiledCustomString (virtualPath As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetCompiledCustomString(System::String ^ virtualPath);" />
      <MemberSignature Language="F#" Value="static member GetCompiledCustomString : string -&gt; string" Usage="System.Web.Compilation.BuildManager.GetCompiledCustomString virtualPath" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="virtualPath" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="virtualPath">O caminho virtual do arquivo a ser compilado.</param>
        <summary>Compila um arquivo, dado seu caminho virtual e retorna uma cadeia de caracteres personalizada que o provedor de build persiste no cache.</summary>
        <returns>Uma cadeia de caracteres, como retornada pelo método <see cref="M:System.Web.Compilation.BuildProvider.GetCustomString(System.CodeDom.Compiler.CompilerResults)" />, que é armazenada em cache no disco ou na memória.</returns>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Web.Compilation.BuildProvider.GetCustomString(System.CodeDom.Compiler.CompilerResults)" />
      </Docs>
    </Member>
    <Member MemberName="GetCompiledType">
      <MemberSignature Language="C#" Value="public static Type GetCompiledType (string virtualPath);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetCompiledType(string virtualPath) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Compilation.BuildManager.GetCompiledType(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetCompiledType (virtualPath As String) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetCompiledType(System::String ^ virtualPath);" />
      <MemberSignature Language="F#" Value="static member GetCompiledType : string -&gt; Type" Usage="System.Web.Compilation.BuildManager.GetCompiledType virtualPath" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="virtualPath" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="virtualPath">O caminho virtual para ser compilado em um tipo.</param>
        <summary>Compila um arquivo, dado seu caminho virtual e retorna o tipo compilado.</summary>
        <returns>Um objeto de <see cref="T:System.Type" /> que representa o tipo gerado da compilação do caminho virtual.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.Web.HttpException">Ocorreu um erro ao compilar o caminho virtual.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="virtualPath" /> é <see langword="null" />.</exception>
        <altmember cref="M:System.Web.Compilation.BuildProvider.GetGeneratedType(System.CodeDom.Compiler.CompilerResults)" />
      </Docs>
    </Member>
    <Member MemberName="GetGlobalAsaxType">
      <MemberSignature Language="C#" Value="public static Type GetGlobalAsaxType ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetGlobalAsaxType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Compilation.BuildManager.GetGlobalAsaxType" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetGlobalAsaxType () As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetGlobalAsaxType();" />
      <MemberSignature Language="F#" Value="static member GetGlobalAsaxType : unit -&gt; Type" Usage="System.Web.Compilation.BuildManager.GetGlobalAsaxType " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Obtém um objeto que representa o tipo compilado para o arquivo Global.asax.</summary>
        <returns>Um objeto que representa o tipo compilado para o arquivo Global.asax.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Uma exceção é lançada se esse método é chamado antes do arquivo global asax foi compilado.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Foi feita uma tentativa para chamar esse método antes de a página Global.asax ter sido compilada.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetObjectFactory">
      <MemberSignature Language="C#" Value="public static System.Web.Util.IWebObjectFactory GetObjectFactory (string virtualPath, bool throwIfNotFound);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Web.Util.IWebObjectFactory GetObjectFactory(string virtualPath, bool throwIfNotFound) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Compilation.BuildManager.GetObjectFactory(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetObjectFactory (virtualPath As String, throwIfNotFound As Boolean) As IWebObjectFactory" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Web::Util::IWebObjectFactory ^ GetObjectFactory(System::String ^ virtualPath, bool throwIfNotFound);" />
      <MemberSignature Language="F#" Value="static member GetObjectFactory : string * bool -&gt; System.Web.Util.IWebObjectFactory" Usage="System.Web.Compilation.BuildManager.GetObjectFactory (virtualPath, throwIfNotFound)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.Util.IWebObjectFactory</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="virtualPath" Type="System.String" />
        <Parameter Name="throwIfNotFound" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="virtualPath">O caminho virtual.</param>
        <param name="throwIfNotFound"><see langword="true" /> para gerar um erro se o caminho virtual não existir; caso contrário, <see langword="false" />. Se o caminho virtual não existir e <paramref name="throwIfNotFound" /> for <see langword="false" />, esse método retornará <see langword="null" />.</param>
        <summary>Obtém um alocador de objeto para o caminho virtual especificado.</summary>
        <returns>O alocador do objeto.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método retorna um objeto que permite gerar um tipo ao compilar o caminho virtual. Ele retorna um objeto, independentemente se o site da Web é pré-compilado.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">O caminho virtual não existe.  
  
- ou - 
Uma exceção de nível superior já existia quando este método foi chamado.  
  
- ou - 
Esse método foi chamado enquanto o processo de build estava compilando arquivos de nível superior.  
  
- ou - 
Este é um aplicativo pré-compilado e o caminho virtual não foi encontrado no cache.  
  
- ou - 
Uma referência circular foi detectada.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetReferencedAssemblies">
      <MemberSignature Language="C#" Value="public static System.Collections.ICollection GetReferencedAssemblies ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.ICollection GetReferencedAssemblies() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Compilation.BuildManager.GetReferencedAssemblies" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetReferencedAssemblies () As ICollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Collections::ICollection ^ GetReferencedAssemblies();" />
      <MemberSignature Language="F#" Value="static member GetReferencedAssemblies : unit -&gt; System.Collections.ICollection" Usage="System.Web.Compilation.BuildManager.GetReferencedAssemblies " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ICollection</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retorna uma lista de referências de assembly à qual todas as compilações de página devem referenciar.</summary>
        <returns>Uma coleção <see cref="T:System.Collections.ICollection" /> de referências de assembly.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A coleção de assemblies que é retornado o <xref:System.Web.Compilation.BuildManager.GetReferencedAssemblies%2A> método inclui assemblies especificados no elemento do arquivo Web. config, assemblies compilados do código personalizado no diretório App_Code e assemblies em outras pastas de nível superior.  
  
 <xref:System.Web.Compilation.BuildManager.GetReferencedAssemblies%2A> é introduzido no .NET Framework versão 3.5.  Para obter mais informações, confira [Versões e dependências do .NET Framework](~/docs/framework/migration-guide/versions-and-dependencies.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetType">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Localiza um tipo nos assemblies de nível superior ou em assemblies que são definidos na configuração.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Refere-se um assembly de nível superior para o arquivo global. asax ou em um arquivo que está no diretório App_GlobalResources, App_WebReferences, App_Code ou App_Browsers.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public static Type GetType (string typeName, bool throwOnError);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetType(string typeName, bool throwOnError) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Compilation.BuildManager.GetType(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetType (typeName As String, throwOnError As Boolean) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetType(System::String ^ typeName, bool throwOnError);" />
      <MemberSignature Language="F#" Value="static member GetType : string * bool -&gt; Type" Usage="System.Web.Compilation.BuildManager.GetType (typeName, throwOnError)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="throwOnError" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="typeName">O nome do tipo.</param>
        <param name="throwOnError"><see langword="true" /> para lançar uma exceção se um objeto de <see cref="T:System.Type" /> não puder ser gerado para o nome do tipo; caso contrário, <see langword="false" />.</param>
        <summary>Localiza um tipo nos assemblies de nível superior ou em assemblies que são definidos na configuração e, como opção, lança uma exceção na falha.</summary>
        <returns>Um objeto de <see cref="T:System.Type" /> que representa o parâmetro <paramref name="typeName" /> solicitado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Refere-se um assembly de nível superior para o arquivo global. asax ou em um arquivo que está no diretório App_GlobalResources, App_WebReferences, App_Code ou App_Browsers.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException"><paramref name="typeName" /> é inválido.  
  
- ou - 
 <paramref name="typeName" /> é ambíguo.  
  
- ou - 
 <paramref name="typeName" /> não pode ser encontrado e o <paramref name="throwOnError" /> é <see langword="true" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public static Type GetType (string typeName, bool throwOnError, bool ignoreCase);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetType(string typeName, bool throwOnError, bool ignoreCase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Compilation.BuildManager.GetType(System.String,System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetType (typeName As String, throwOnError As Boolean, ignoreCase As Boolean) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetType(System::String ^ typeName, bool throwOnError, bool ignoreCase);" />
      <MemberSignature Language="F#" Value="static member GetType : string * bool * bool -&gt; Type" Usage="System.Web.Compilation.BuildManager.GetType (typeName, throwOnError, ignoreCase)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="throwOnError" Type="System.Boolean" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="typeName">O nome do tipo.</param>
        <param name="throwOnError"><see langword="true" /> para lançar uma exceção se um <see cref="T:System.Type" /> não puder ser gerado para o nome do tipo; caso contrário, <see langword="false" />.</param>
        <param name="ignoreCase"><see langword="true" /> se <paramref name="typeName" /> diferenciar maiúsculas de minúsculas; caso contrário, <see langword="false" />.</param>
        <summary>Localiza um tipo nos assemblies de nível superior ou em assemblies que são definidos na configuração usando uma pesquisa que não diferencia maiúsculas de minúsculas e, como opção, lançando uma exceção na falha.</summary>
        <returns>Um objeto de <see cref="T:System.Type" /> que representa o parâmetro <paramref name="typeName" /> solicitado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Refere-se um assembly de nível superior para o arquivo global. asax ou em um arquivo que está no diretório App_GlobalResources, App_WebReferences, App_Code ou App_Browsers.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException"><paramref name="typeName" /> é inválido.  
  
- ou - 
 <paramref name="typeName" /> é ambíguo.  
  
- ou - 
 <paramref name="typeName" /> não pode ser encontrado e o <paramref name="throwOnError" /> é <see langword="true" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetVirtualPathDependencies">
      <MemberSignature Language="C#" Value="public static System.Collections.ICollection GetVirtualPathDependencies (string virtualPath);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.ICollection GetVirtualPathDependencies(string virtualPath) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Compilation.BuildManager.GetVirtualPathDependencies(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetVirtualPathDependencies (virtualPath As String) As ICollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Collections::ICollection ^ GetVirtualPathDependencies(System::String ^ virtualPath);" />
      <MemberSignature Language="F#" Value="static member GetVirtualPathDependencies : string -&gt; System.Collections.ICollection" Usage="System.Web.Compilation.BuildManager.GetVirtualPathDependencies virtualPath" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ICollection</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="virtualPath" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="virtualPath">O caminho virtual usado para determinar as dependências.</param>
        <summary>Fornece uma coleção de dependências do caminho virtual para um caminho virtual especificado.</summary>
        <returns>Uma coleção de arquivos de <see cref="T:System.Collections.ICollection" /> representada por caminhos virtuais que estão armazenando em cache as dependências para o caminho virtual.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsPrecompiledApp">
      <MemberSignature Language="C#" Value="public static bool IsPrecompiledApp { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool IsPrecompiledApp" />
      <MemberSignature Language="DocId" Value="P:System.Web.Compilation.BuildManager.IsPrecompiledApp" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property IsPrecompiledApp As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool IsPrecompiledApp { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsPrecompiledApp : bool" Usage="System.Web.Compilation.BuildManager.IsPrecompiledApp" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém um valor que especifica se o aplicativo é pré-compilado.</summary>
        <value><see langword="true" /> Se o aplicativo é pré-compilado; Caso contrário, <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsUpdatablePrecompiledApp">
      <MemberSignature Language="C#" Value="public static bool IsUpdatablePrecompiledApp { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool IsUpdatablePrecompiledApp" />
      <MemberSignature Language="DocId" Value="P:System.Web.Compilation.BuildManager.IsUpdatablePrecompiledApp" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property IsUpdatablePrecompiledApp As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool IsUpdatablePrecompiledApp { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsUpdatablePrecompiledApp : bool" Usage="System.Web.Compilation.BuildManager.IsUpdatablePrecompiledApp" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém um valor que especifica se o aplicativo é pré-compilado como atualizável.</summary>
        <value><see langword="true" /> Se o aplicativo é pré-compilado como atualizável; Caso contrário, <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ReadCachedFile">
      <MemberSignature Language="C#" Value="public static System.IO.Stream ReadCachedFile (string fileName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.Stream ReadCachedFile(string fileName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Compilation.BuildManager.ReadCachedFile(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReadCachedFile (fileName As String) As Stream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::Stream ^ ReadCachedFile(System::String ^ fileName);" />
      <MemberSignature Language="F#" Value="static member ReadCachedFile : string -&gt; System.IO.Stream" Usage="System.Web.Compilation.BuildManager.ReadCachedFile fileName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="fileName">O nome do arquivo a ser lido.</param>
        <summary>Lê um arquivo armazenado em cache.</summary>
        <returns>O objeto de <see cref="T:System.IO.Stream" /> para o arquivo ou <see langword="null" />, se o arquivo não existir.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método e o <xref:System.Web.Compilation.BuildManager.CreateCachedFile%2A> método permitem que você execute o caching que persiste entre as reinicializações de domínio de aplicativo em ambientes de confiança parcial. Ele é usado pela estrutura MVC para cache os resultados da pesquisa de controlador.  
  
 Para recuperar os dados armazenados em cache, você ler a partir de <xref:System.IO.Stream> objeto que é retornado por esse método.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TargetFramework">
      <MemberSignature Language="C#" Value="public static System.Runtime.Versioning.FrameworkName TargetFramework { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Runtime.Versioning.FrameworkName TargetFramework" />
      <MemberSignature Language="DocId" Value="P:System.Web.Compilation.BuildManager.TargetFramework" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property TargetFramework As FrameworkName" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Runtime::Versioning::FrameworkName ^ TargetFramework { System::Runtime::Versioning::FrameworkName ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.TargetFramework : System.Runtime.Versioning.FrameworkName" Usage="System.Web.Compilation.BuildManager.TargetFramework" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.Versioning.FrameworkName</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém a versão de destino do .NET Framework para o site atual.</summary>
        <value>A versão de destino do .NET Framework para o site atual.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Essa propriedade oferece suporte para o recurso de multiplataforma do ASP.NET, que permite que você use a versão mais recente do Visual Studio para desenvolver aplicativos que serão executados com versões anteriores do .NET Framework. Um provedor de build pode usar essa propriedade para certificar-se de que o provedor gera código que é apropriado para a versão de destino do .NET Framework. Por exemplo, você talvez queira gerar um código diferente, dependendo se um site é destinado a [!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)] ou o [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]. Para obter mais informações sobre vários destinos, consulte [.NET Framework Multi-Targeting para projetos Web ASP.NET](https://msdn.microsoft.com/library/8b8145a9-62f6-4fc4-8a83-47b0487cbe76).  
  
 Se o site da Web não tiver um arquivo Web. config, o ASP.NET pressupõe que a versão do framework de destino é a versão que está associada com o pool de aplicativos do IIS que o site está em execução em. Para um site da Web no sistema de arquivos que está em execução no Visual Studio, a versão do framework padrão é a versão atual do .NET Framework.  
  
 Se o site tiver um arquivo Web. config, o ASP.NET determina a estrutura de destino ao examinar o arquivo Web. config.  
  
## <a name="web-sites-that-target-the-net-framework-20"></a>Sites da Web que direcionam o .NET Framework 2.0  
 Aplicativos da Web que se destinam a [!INCLUDE[dnprdnlong](~/includes/dnprdnlong-md.md)] são compilados como se fosse o destino a [!INCLUDE[net_v30_short](~/includes/net-v30-short-md.md)]. O processo de compilação não diferenciar entre os [!INCLUDE[dnprdnlong](~/includes/dnprdnlong-md.md)] e o [!INCLUDE[net_v30_short](~/includes/net-v30-short-md.md)] porque o arquivo Web. config não indica o framework de destino ou de versão do compilador quando uma dessas versões é afetada. (Para o [!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)], o arquivo Web. config Especifica a versão do compilador e para o [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)], o arquivo Web. config Especifica a estrutura de destino.) Portanto, para aplicativos Web que se destinam a [!INCLUDE[dnprdnlong](~/includes/dnprdnlong-md.md)], essa propriedade retorna um moniker de estrutura de destino que indica o [!INCLUDE[net_v30_short](~/includes/net-v30-short-md.md)].  
  
 Isso normalmente não causará problemas. Visual Studio impede a criação de referências aos [!INCLUDE[net_v30_short](~/includes/net-v30-short-md.md)] recursos em um projeto que se destina a [!INCLUDE[dnprdnlong](~/includes/dnprdnlong-md.md)]. Por exemplo, o Visual Studio não fornece modelos de item para os serviços WCF em um projeto que se destina a [!INCLUDE[dnprdnlong](~/includes/dnprdnlong-md.md)], porque o WCF foi introduzido com o [!INCLUDE[net_v30_short](~/includes/net-v30-short-md.md)] e não é compatível com o [!INCLUDE[dnprdnlong](~/includes/dnprdnlong-md.md)].  
  
 Se você planeja implantar um site da Web em um [!INCLUDE[dnprdnlong](~/includes/dnprdnlong-md.md)] ambiente de tempo de execução e você usar uma ferramenta diferente do Visual Studio para recursos de referência que são compatíveis apenas com [!INCLUDE[net_v30_short](~/includes/net-v30-short-md.md)], o projeto pode ser compilado sem gerar erros ou avisos. No entanto, o aplicativo pode gerar erros quando o site da Web é executado no [!INCLUDE[dnprdnlong](~/includes/dnprdnlong-md.md)].  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>