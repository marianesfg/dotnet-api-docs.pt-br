<Type Name="DataTable" FullName="System.Data.DataTable">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="2b4c6d4eea254ee4906c2c3917cdebe98c32d7df" />
    <Meta Name="ms.sourcegitcommit" Value="434f60616a9793fa8436744549fc856e94f7a648" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="pt-BR" />
    <Meta Name="ms.lasthandoff" Value="08/25/2018" />
    <Meta Name="ms.locfileid" Value="40449460" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class DataTable : System.ComponentModel.MarshalByValueComponent, System.ComponentModel.IListSource, System.ComponentModel.ISupportInitialize, System.ComponentModel.ISupportInitializeNotification, System.Runtime.Serialization.ISerializable, System.Xml.Serialization.IXmlSerializable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit DataTable extends System.ComponentModel.MarshalByValueComponent implements class System.ComponentModel.IListSource, class System.ComponentModel.ISupportInitialize, class System.ComponentModel.ISupportInitializeNotification, class System.Runtime.Serialization.ISerializable, class System.Xml.Serialization.IXmlSerializable" />
  <TypeSignature Language="DocId" Value="T:System.Data.DataTable" />
  <TypeSignature Language="VB.NET" Value="Public Class DataTable&#xA;Inherits MarshalByValueComponent&#xA;Implements IListSource, ISerializable, ISupportInitialize, ISupportInitializeNotification, IXmlSerializable" />
  <TypeSignature Language="C++ CLI" Value="public ref class DataTable : System::ComponentModel::MarshalByValueComponent, System::ComponentModel::IListSource, System::ComponentModel::ISupportInitialize, System::ComponentModel::ISupportInitializeNotification, System::Runtime::Serialization::ISerializable, System::Xml::Serialization::IXmlSerializable" />
  <TypeSignature Language="F#" Value="type DataTable = class&#xA;    inherit MarshalByValueComponent&#xA;    interface IListSource&#xA;    interface ISupportInitializeNotification&#xA;    interface ISerializable&#xA;    interface IXmlSerializable&#xA;    interface ISupportInitialize" />
  <AssemblyInfo>
    <AssemblyName>System.Data.Common</AssemblyName>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Data</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
    <BaseTypeName FrameworkAlternate="netframework-4.5">System.ComponentModel.MarshalByValueComponent</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.ComponentModel.IListSource</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.ComponentModel.ISupportInitialize</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.ComponentModel.ISupportInitializeNotification</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Runtime.Serialization.ISerializable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Xml.Serialization.IXmlSerializable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.ComponentModel.DefaultEvent("RowChanging")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.ComponentModel.DefaultProperty("TableName")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.ComponentModel.DesignTimeVisible(false)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="xamarinmac-3.0">
      <AttributeName>System.ComponentModel.Editor("Microsoft.VSDesigner.Data.Design.DataTableEditor, Microsoft.VSDesigner, Version=0.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "System.Drawing.Design.UITypeEditor, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.ComponentModel.ToolboxItem(false)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Xml.Serialization.XmlSchemaProvider("GetDataTableSchema")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1">
      <AttributeName>System.ComponentModel.Editor("Microsoft.VSDesigner.Data.Design.DataTableEditor, Microsoft.VSDesigner, Version=7.0.5000.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", typeof(System.Drawing.Design.UITypeEditor))</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
      <AttributeName>System.ComponentModel.Editor("Microsoft.VSDesigner.Data.Design.DataTableEditor, Microsoft.VSDesigner, Version=8.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "System.Drawing.Design.UITypeEditor, System.Drawing, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
      <AttributeName>System.ComponentModel.Editor("Microsoft.VSDesigner.Data.Design.DataTableEditor, Microsoft.VSDesigner, Version=10.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "System.Drawing.Design.UITypeEditor, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8">
      <AttributeName>System.ComponentModel.Editor("Microsoft.VSDesigner.Data.Design.DataTableEditor, Microsoft.VSDesigner, Version=9.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "System.Drawing.Design.UITypeEditor, System.Drawing, Version=2.0.5.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Representa uma tabela de dados na memória.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Data.DataTable> é um objeto central na biblioteca do ADO.NET. Outros objetos que usam o <xref:System.Data.DataTable> incluem o <xref:System.Data.DataSet> e o <xref:System.Data.DataView>.  
  
 Ao acessar <xref:System.Data.DataTable> objetos, observe que eles são condicionalmente diferencia maiusculas de minúsculas. Por exemplo, se houver um <xref:System.Data.DataTable> é denominado "mydatatable" e o outro é denominado "Mydatatable", uma cadeia de caracteres usada para pesquisar uma das tabelas é considerada como diferencia maiusculas de minúsculas. No entanto, se existe "mydatatable" e "Mydatatable" não, a cadeia de caracteres de pesquisa é considerada como diferencia maiusculas de minúsculas. Um <xref:System.Data.DataSet> pode conter dois <xref:System.Data.DataTable> objetos que têm o mesmo <xref:System.Data.DataTable.TableName%2A> o valor da propriedade, mas diferentes <xref:System.Data.DataTable.Namespace%2A> valores de propriedade. Para obter mais informações sobre como trabalhar com <xref:System.Data.DataTable> objetos, consulte [criando um DataTable](~/docs/framework/data/adonet/dataset-datatable-dataview/creating-a-datatable.md).  
  
 Se você estiver criando um <xref:System.Data.DataTable> programaticamente, você deve primeiro definir seu esquema adicionando <xref:System.Data.DataColumn> objetos para o <xref:System.Data.DataColumnCollection> (acessados por meio de <xref:System.Data.DataTable.Columns%2A> propriedade). Para obter mais informações sobre como adicionar <xref:System.Data.DataColumn> objetos, consulte [adicionando colunas a uma DataTable](~/docs/framework/data/adonet/dataset-datatable-dataview/adding-columns-to-a-datatable.md).  
  
 Para adicionar linhas a um <xref:System.Data.DataTable>, primeiro você deve usar o <xref:System.Data.DataTable.NewRow%2A> método para retornar um novo <xref:System.Data.DataRow> objeto. O <xref:System.Data.DataTable.NewRow%2A> método retorna uma linha com o esquema de <xref:System.Data.DataTable>, conforme definido pela tabela de <xref:System.Data.DataColumnCollection>. O número máximo de linhas que um <xref:System.Data.DataTable> pode repositório é 16,777,216. Para obter mais informações, consulte [adicionando dados a uma DataTable](~/docs/framework/data/adonet/dataset-datatable-dataview/adding-data-to-a-datatable.md).  
  
 O <xref:System.Data.DataTable> também contém uma coleção de <xref:System.Data.Constraint> objetos que podem ser usados para garantir a integridade dos dados. Para obter mais informações, consulte [restrições de DataTable](~/docs/framework/data/adonet/dataset-datatable-dataview/datatable-constraints.md).  
  
 Existem várias <xref:System.Data.DataTable> eventos que podem ser usados para determinar quando as alterações são feitas em uma tabela. Eles incluem <xref:System.Data.DataTable.RowChanged>, <xref:System.Data.DataTable.RowChanging>, <xref:System.Data.DataTable.RowDeleting>, e <xref:System.Data.DataTable.RowDeleted>. Para obter mais informações sobre os eventos que podem ser usados com um <xref:System.Data.DataTable>, consulte [manipulação de eventos de DataTable](~/docs/framework/data/adonet/dataset-datatable-dataview/handling-datatable-events.md).  
  
 Quando uma instância do <xref:System.Data.DataTable> é criado, alguns de leitura/gravação são definidas com valores iniciais. Para obter uma lista desses valores, consulte o <xref:System.Data.DataTable.%23ctor%2A?displayProperty=nameWithType> tópico de construtor.  
  
> [!NOTE]
>  O <xref:System.Data.DataSet> e <xref:System.Data.DataTable> objetos herdam <xref:System.ComponentModel.MarshalByValueComponent>e dão suporte a <xref:System.Runtime.Serialization.ISerializable> interface para comunicação remota do .NET Framework. Esses são os únicos objetos ADO.NET que você pode usar para comunicação remota do .NET Framework.  
  
   
  
## Examples  
 O exemplo a seguir cria dois <xref:System.Data.DataTable> objetos e um <xref:System.Data.DataRelation> do objeto e adiciona os novos objetos para um <xref:System.Data.DataSet>. As tabelas são exibidas em um <xref:System.Windows.Forms.DataGridView> controle.  
  
 [!code-csharp[Classic WebData DataTable Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable Example/VB/source.vb#1)]  
  
 Este exemplo demonstra como criar uma DataTable manualmente com definições de esquema específico:  
  
-   Criar várias tabelas de dados e definir as colunas iniciais.  
  
-   Crie as restrições de tabela.  
  
-   Insira os valores e exibir as tabelas.  
  
-   Criar as colunas de expressão e exibir as tabelas.  
  
 Projetos c# e Visual Basic com este exemplo de código podem ser encontrados no [exemplos de código do desenvolvedor](https://code.msdn.microsoft.com/How-to-create-DataTable-7abb4914).  
  
 [!code-csharp[Classic WebData DataTable Example2#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/classic webdata datatable example2/cs/source.cs#1)]
 [!code-vb[Classic WebData DataTable Example2#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/classic webdata datatable example2/vb/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe>Este tipo é seguro para operações de leitura e multithread. Você deve sincronizar todas as operações de gravação.</threadsafe>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicializa uma nova instância da classe <see cref="T:System.Data.DataTable" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DataTable ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DataTable();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inicializa uma nova instância da classe <see cref="T:System.Data.DataTable" /> sem argumentos.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O construtor define valores iniciais para todas as propriedades do <xref:System.Data.DataTable> objeto. A tabela a seguir mostra as propriedades e seus valores padrão. Quando uma instância do <xref:System.Data.DataTable> é criado, as seguintes propriedades são definidas como valores iniciais de leitura/gravação.  
  
|Propriedade|Valor padrão|  
|--------------|-------------------|  
|**CaseSensitive**|Mesmo que o pai <xref:System.Data.DataSet>, se ele pertence a uma. Caso contrário, `false`.|  
|**DisplayExpression**|cadeia de caracteres vazia ("")|  
|**Localidade**|Mesmo que o pai <xref:System.Data.DataSet> do objeto <xref:System.Globalization.CultureInfo> (retornado pela <xref:System.Data.DataSet.Locale%2A> propriedade); não se existir nenhum pai, o padrão é o atual sistema <xref:System.Globalization.CultureInfo>.|  
|**MinimumCapacity**|50 linhas.|  
  
 Você pode alterar o valor para qualquer uma dessas propriedades por meio de uma chamada separada para a propriedade.  
  
   
  
## Examples  
 O exemplo a seguir cria um novo <xref:System.Data.DataTable> com <xref:System.Data.DataColumn> e <xref:System.Data.DataRow>e o exibe em um <xref:System.Windows.Forms.DataGridView> controle.  
  
 [!code-csharp[Classic WebData DataTable.DataTable Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.DataTable Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.DataTable Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.DataTable Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DataTable (string tableName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string tableName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.#ctor(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (tableName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DataTable(System::String ^ tableName);" />
      <MemberSignature Language="F#" Value="new System.Data.DataTable : string -&gt; System.Data.DataTable" Usage="new System.Data.DataTable tableName" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="tableName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="tableName">O nome a ser dado à tabela. Se <c>tableName</c> for <see langword="null" /> ou uma cadeia de caracteres vazia, um nome padrão será fornecido quando ele for adicionado na <see cref="T:System.Data.DataTableCollection" />.</param>
        <summary>Inicializa uma nova instância da classe <see cref="T:System.Data.DataTable" /> com o nome da tabela especificada.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O exemplo a seguir cria uma <xref:System.Data.DataTable> e o exibe em um <xref:System.Windows.Forms.DataGridView> controle.  
  
 [!code-csharp[Classic WebData DataTable.DataTable1 Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.DataTable1 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.DataTable1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.DataTable1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected DataTable (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(class System.Runtime.Serialization.SerializationInfo info, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New (info As SerializationInfo, context As StreamingContext)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; DataTable(System::Runtime::Serialization::SerializationInfo ^ info, System::Runtime::Serialization::StreamingContext context);" />
      <MemberSignature Language="F#" Value="new System.Data.DataTable : System.Runtime.Serialization.SerializationInfo * System.Runtime.Serialization.StreamingContext -&gt; System.Data.DataTable" Usage="new System.Data.DataTable (info, context)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="info" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="info">Os dados necessários para serializar ou desserializar um objeto.</param>
        <param name="context">A origem e o destino de um determinado fluxo serializado.</param>
        <summary>Inicializa uma nova instância da classe <see cref="T:System.Data.DataTable" /> com o <see cref="T:System.Runtime.Serialization.SerializationInfo" /> e o <see cref="T:System.Runtime.Serialization.StreamingContext" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Essa implementação do <xref:System.Data.DataTable> construtor é necessário para <xref:System.Runtime.Serialization.ISerializable>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DataTable (string tableName, string tableNamespace);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string tableName, string tableNamespace) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.#ctor(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (tableName As String, tableNamespace As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DataTable(System::String ^ tableName, System::String ^ tableNamespace);" />
      <MemberSignature Language="F#" Value="new System.Data.DataTable : string * string -&gt; System.Data.DataTable" Usage="new System.Data.DataTable (tableName, tableNamespace)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="tableName" Type="System.String" />
        <Parameter Name="tableNamespace" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="tableName">O nome a ser dado à tabela. Se <c>tableName</c> for <see langword="null" /> ou uma cadeia de caracteres vazia, um nome padrão será fornecido quando ele for adicionado na <see cref="T:System.Data.DataTableCollection" />.</param>
        <param name="tableNamespace">Obtém o namespace para a representação XML dos dados armazenados no <see langword="DataTable" />.</param>
        <summary>Inicializa uma nova instância da classe <see cref="T:System.Data.DataTable" /> usando o nome de tabela e o namespace especificados.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AcceptChanges">
      <MemberSignature Language="C#" Value="public void AcceptChanges ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AcceptChanges() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.AcceptChanges" />
      <MemberSignature Language="VB.NET" Value="Public Sub AcceptChanges ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AcceptChanges();" />
      <MemberSignature Language="F#" Value="member this.AcceptChanges : unit -&gt; unit" Usage="dataTable.AcceptChanges " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Confirma todas as alterações feitas à tabela desde a última vez em que <see cref="M:System.Data.DataTable.AcceptChanges" /> foi chamado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando <xref:System.Data.DataTable.AcceptChanges%2A> for chamado, qualquer <xref:System.Data.DataRow> objeto ainda está no modo de edição termina com êxito suas edições. O <xref:System.Data.DataRowState> também muda: todos os `Added` e `Modified` linhas se tornam `Unchanged`, e `Deleted` linhas são removidas.  
  
 O <xref:System.Data.DataTable.AcceptChanges%2A> método geralmente é chamado em um <xref:System.Data.DataTable> após uma tentativa de atualizar o <xref:System.Data.DataSet> usando o <xref:System.Data.Common.DbDataAdapter.Update%2A?displayProperty=nameWithType> método.  
  
   
  
## Examples  
 O exemplo a seguir testa cada tabela de erros. Se os erros da tabela podem ser reconciliados (passando-a para uma função não definida), <xref:System.Data.DataTable.AcceptChanges%2A> for chamado; caso contrário, <xref:System.Data.DataTable.RejectChanges%2A> é chamado.  
  
 [!code-csharp[Classic WebData DataTable.AcceptChanges Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.AcceptChanges Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.AcceptChanges Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.AcceptChanges Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginInit">
      <MemberSignature Language="C#" Value="public virtual void BeginInit ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void BeginInit() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.BeginInit" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub BeginInit ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void BeginInit();" />
      <MemberSignature Language="F#" Value="abstract member BeginInit : unit -&gt; unit&#xA;override this.BeginInit : unit -&gt; unit" Usage="dataTable.BeginInit " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Começa a inicialização de um <see cref="T:System.Data.DataTable" /> usado em um formulário ou por outro componente. A inicialização ocorre no tempo de execução.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O ambiente de design do Visual Studio .NET usa esse método para iniciar a inicialização de um componente que é usado em um formulário ou por outro componente. O <xref:System.Data.DataTable.EndInit%2A> método encerra a inicialização. Usando o <xref:System.Data.DataTable.BeginInit%2A> e <xref:System.Data.DataTable.EndInit%2A> métodos impede que o controle seja usado antes de ser totalmente inicializado.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginLoadData">
      <MemberSignature Language="C#" Value="public void BeginLoadData ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void BeginLoadData() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.BeginLoadData" />
      <MemberSignature Language="VB.NET" Value="Public Sub BeginLoadData ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void BeginLoadData();" />
      <MemberSignature Language="F#" Value="member this.BeginLoadData : unit -&gt; unit" Usage="dataTable.BeginLoadData " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Desativa as notificações, a manutenção de índice e as restrições durante o carregamento de dados.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use <xref:System.Data.DataTable.BeginLoadData%2A> em conjunto com <xref:System.Data.DataTable.LoadDataRow%2A> e <xref:System.Data.DataTable.EndLoadData%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CaseSensitive">
      <MemberSignature Language="C#" Value="public bool CaseSensitive { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CaseSensitive" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataTable.CaseSensitive" />
      <MemberSignature Language="VB.NET" Value="Public Property CaseSensitive As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool CaseSensitive { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.CaseSensitive : bool with get, set" Usage="System.Data.DataTable.CaseSensitive" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.Data.DataSysDescription("DataTableCaseSensitiveDescr")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Indica se a comparação de cadeias de caracteres dentro da tabela diferencia maiúsculas de minúsculas.</summary>
        <value>
          <see langword="true" /> se a comparação diferencia maiúsculas de minúsculas; caso contrário <see langword="false" />. O padrão é definido como o pai <see cref="T:System.Data.DataSet" /> da propriedade do <see cref="P:System.Data.DataSet.CaseSensitive" /> objeto ou <see langword="false" /> se o <see cref="T:System.Data.DataTable" /> foi criado independentemente de um <see cref="T:System.Data.DataSet" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Data.DataTable.CaseSensitive%2A> propriedade afeta as comparações de cadeia de caracteres na classificação, pesquisa e filtragem.  
  
   
  
## Examples  
 A exemplo a seguir chama o <xref:System.Data.DataTable.Select%2A> método duas vezes em um <xref:System.Data.DataTable>. Na primeira vez, o <xref:System.Data.DataTable.CaseSensitive%2A> estiver definida como `false`, o segundo, para `true`.  
  
 [!code-csharp[Classic WebData DataTable.CaseSensitive Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.CaseSensitive Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.CaseSensitive Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.CaseSensitive Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Data.DataTable.Select" />
      </Docs>
    </Member>
    <Member MemberName="ChildRelations">
      <MemberSignature Language="C#" Value="public System.Data.DataRelationCollection ChildRelations { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Data.DataRelationCollection ChildRelations" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataTable.ChildRelations" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ChildRelations As DataRelationCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Data::DataRelationCollection ^ ChildRelations { System::Data::DataRelationCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ChildRelations : System.Data.DataRelationCollection" Usage="System.Data.DataTable.ChildRelations" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.Data.DataSysDescription("DataTableChildRelationsDescr")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Data.DataRelationCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém a coleção das relações filho desta <see cref="T:System.Data.DataTable" />.</summary>
        <value>Um <see cref="T:System.Data.DataRelationCollection" /> que contém as relações filho da tabela. Será retornada uma coleção vazia se não houver nenhum objeto <see cref="T:System.Data.DataRelation" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Um <xref:System.Data.DataRelation> define a relação entre duas tabelas. Normalmente, duas tabelas são vinculadas por meio de um único campo que contém os mesmos dados. Por exemplo, uma tabela que contém dados de endereço pode ter um único campo que contém códigos que representam os países/regiões. Uma segunda tabela que contém os dados do país/região terá um único campo que contém o código que identifica o país/região, e é esse código que é inserido no campo correspondente na primeira tabela. Um <xref:System.Data.DataRelation>, em seguida, contém pelo menos quatro tipos de informações: (1) o nome da primeira tabela, (2) o nome da coluna na primeira tabela, (3) o nome da segunda tabela e (4) o nome da coluna na segunda tabela.  
  
   
  
## Examples  
 O exemplo a seguir usa o <xref:System.Data.DataTable.ChildRelations%2A> propriedade para retornar cada filho <xref:System.Data.DataRelation> em um <xref:System.Data.DataTable>. Cada relação, em seguida, é usada como um argumento na <xref:System.Data.DataRow.GetChildRows%2A> método da <xref:System.Data.DataRow> para retornar uma matriz de linhas. Em seguida, o valor de cada coluna na linha é impresso.  
  
 [!code-csharp[Classic WebData DataTable.ChildRelations Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.ChildRelations Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.ChildRelations Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.ChildRelations Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Data.DataTable.ParentRelations" />
        <altmember cref="M:System.Data.DataRow.GetParentRows(System.String)" />
        <altmember cref="M:System.Data.DataRow.GetChildRows(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="Clear">
      <MemberSignature Language="C#" Value="public void Clear ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Clear() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.Clear" />
      <MemberSignature Language="VB.NET" Value="Public Sub Clear ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Clear();" />
      <MemberSignature Language="F#" Value="member this.Clear : unit -&gt; unit" Usage="dataTable.Clear " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Limpa o <see cref="T:System.Data.DataTable" /> de todos os dados.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Todas as linhas em todas as tabelas são removidas. Uma exceção será gerada se a tabela tem todas as relações filho imposto que faria com que linhas filho se tornem órfãos.  
  
 Se o <xref:System.Data.DataSet> está associado a um <xref:System.Xml.XmlDataDocument>, chamar <xref:System.Data.DataSet.Clear%2A?displayProperty=nameWithType> ou <xref:System.Data.DataTable.Clear%2A?displayProperty=nameWithType> aciona o <xref:System.NotSupportedException>. Para evitar essa situação, percorre cada tabela, removendo a cada linha, um por vez. Quando você usa <xref:System.Data.DataTable.NewRow%2A> para criar novas linhas, as linhas devem ser processadas antes de chamar <xref:System.Data.DataTable.Clear%2A>.  
  
   
  
## Examples  
 O exemplo a seguir limpa a tabela de todos os dados.  
  
 [!code-csharp[Classic WebData DataTable.Clear Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.Clear Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.Clear Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.Clear Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Clone">
      <MemberSignature Language="C#" Value="public virtual System.Data.DataTable Clone ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Data.DataTable Clone() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.Clone" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Clone () As DataTable" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Data::DataTable ^ Clone();" />
      <MemberSignature Language="F#" Value="abstract member Clone : unit -&gt; System.Data.DataTable&#xA;override this.Clone : unit -&gt; System.Data.DataTable" Usage="dataTable.Clone " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataTable</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Clona a estrutura do <see cref="T:System.Data.DataTable" />, incluindo todos os esquemas e restrições de <see cref="T:System.Data.DataTable" />.</summary>
        <returns>Um novo <see cref="T:System.Data.DataTable" /> com o mesmo esquema que o <see cref="T:System.Data.DataTable" /> atual.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se essas classes tiverem sido derivadas, o clone também será das mesmas classes derivadas.  
  
 Clone cria um novo <xref:System.Data.DataTable> com a mesma estrutura original <xref:System.Data.DataTable>, mas não copia todos os dados (o novo <xref:System.Data.DataTable> não conterá nenhuma `DataRows`). Para copiar a estrutura e os dados em uma nova <xref:System.Data.DataTable>, use <xref:System.Data.DataTable.Copy%2A>.  
  
   
  
## Examples  
 O exemplo a seguir demonstra como atualizar a estrutura e as restrições da tabela de destino depois de executar DataTable.Clone. A classe ClonedDataTable retornará uma tabela de destino e inclui todos os eventos de atualização. Após o clone, alterações de estrutura da tabela de origem não serão refletidas na tabela de destino. Especificamente, este exemplo será:  
  
-   Atualize as alterações das colunas na tabela de origem.  
  
-   Atualize as alterações de UniqueConstraint a tabela de origem.  
  
-   Atualize as alterações de ForeignKeyConstraint a tabela de origem.  
  
 Projetos c# e Visual Basic com este exemplo de código podem ser encontrados no [exemplos de código do desenvolvedor](https://code.msdn.microsoft.com/site/search?f%5B0%5D.Type=SearchText&f%5B0%5D.Value=How%20to%20automically%20update%20the%20structure%20of%20a%20cloned%20DataTable).  
  
```csharp  
using System;  
using System.Linq;  
using System.Data;  
using System.ComponentModel;  
  
class Program {  
   static void Main(string[] args) {  
      DataTable courses = NewCourseDataTable();  
      Console.WriteLine("This is the source table:");  
      WriteDataTable(courses);  
  
      ClonedDataTable clonedResult = new ClonedDataTable(courses);  
      DataTable clonedCourses = clonedResult.DestinationTable;  
      Console.WriteLine("This is the destination table:");  
      WriteDataTable(clonedCourses);  
  
      // Add the events of updating column collection into the source table.  
      clonedResult.UpdateAddedColumn();  
      clonedResult.UpdateDeletedColumn();  
      // Add a DataColumn in source table.  
      DataColumn columnCreidts = new DataColumn("Credits", typeof(Int32));  
      courses.Columns.Add(columnCreidts);  
      Console.WriteLine("After add a column in source table, it's the result in the destination:");  
      WriteDataTable(clonedCourses);  
  
      // Add the event of updating UniqueConstraint into the source table.  
      clonedResult.UpdateUniqueConstraint();  
  
      // Add the unique constraint in source table.  
      UniqueConstraint uniqueConstraint = new UniqueConstraint(courses.Columns["CourseId"]);  
      courses.Constraints.Add(uniqueConstraint);  
  
      Console.WriteLine(@"If we add the unique constraint in source table and then insert the duplicate   
rows into the destination table, we will get the following error:");  
      InsertDuplicateData(clonedCourses);  
      Console.WriteLine();  
  
      // Add the event of updating ForeignKeyConstraint into the source table.  
      clonedResult.UpdateForeignKeyConstraint();  
  
      // Add the ForeignKeyConstraint into the source table.  
      DataTable deparments = NewDeparmentDataTable();  
      DataSet dataset = new DataSet();  
  
      dataset.Tables.Add(courses);  
      dataset.Tables.Add(clonedCourses);  
      dataset.Tables.Add(deparments);  
  
      ForeignKeyConstraint foreignKey = new ForeignKeyConstraint(deparments.Columns["DepartmentId"], courses.Columns["DepartmentId"]);  
      courses.Constraints.Add(foreignKey);  
  
      Console.WriteLine(@"If we add the foreign key constraint in source table and then insert a row   
without the parent  into the destination table, we will get the following error:");  
      InsertNoParentRow(clonedCourses);  
      Console.WriteLine();  
  
      Console.WriteLine("Please press any key to exit...");  
      Console.ReadKey();  
   }  
  
   static private DataTable NewCourseDataTable() {  
      DataTable newTable = new DataTable();  
  
      DataColumn[] columns ={   
                                      new DataColumn("CourseId", typeof(String)),  
                                      new DataColumn("CourseName",typeof(String)),                                        
                                      new DataColumn("DepartmentId", typeof(Int32))  
                                  };  
  
      newTable.Columns.AddRange(columns);  
  
      newTable.Rows.Add("C1045", "Calculus", 7);  
      newTable.Rows.Add("C1061", "Physics", 1);  
      newTable.Rows.Add("C2021", "Composition", 2);  
      newTable.Rows.Add("C2042", "Literature", 2);  
  
      return newTable;  
   }  
  
   static private DataTable NewDeparmentDataTable() {  
      DataTable newTable = new DataTable();  
  
      DataColumn[] columns ={   
                                      new DataColumn("DepartmentId", typeof(Int32)),  
                                      new DataColumn("Name",typeof(String)),  
                                  };  
  
      newTable.Columns.AddRange(columns);  
  
      newTable.Rows.Add(1, "Engineering");  
      newTable.Rows.Add(2, "English");  
      newTable.Rows.Add(4, "Economics");  
      newTable.Rows.Add(7, "Mathematics");  
  
      return newTable;  
   }  
  
   static private void WriteDataTable(DataTable table) {  
      if (table == null)  
         return;  
  
      foreach (DataColumn column in table.Columns) {  
         Console.Write("{0,-15}", column.ColumnName);  
      }  
      Console.WriteLine();  
  
      foreach (DataRow row in table.Rows) {  
         for (int i = 0; i < table.Columns.Count; i++)  
            Console.Write("{0,-15}", row[i].ToString());  
         Console.WriteLine();  
      }  
  
      Console.WriteLine();  
   }  
  
   static private void InsertDuplicateData(DataTable table) {  
      try {  
         table.Rows.Add("C1045", "Calculus", 7);  
         table.Rows.Add("C1045", "Calculus", 7);  
      } catch (Exception e) {  
         Console.WriteLine("\"" + e.Message + "\"");  
      }  
   }  
  
   private static void InsertNoParentRow(DataTable table) {  
      try {  
         table.Rows.Add("C1061", "Physics", 11);  
      } catch (Exception e) {  
         Console.WriteLine("\"" + e.Message + "\"");  
      }  
   }  
}  
  
public class ClonedDataTable {  
   private DataTable sourceTable;  
   private DataTable destinationTable;  
  
   public ClonedDataTable(DataTable source) {  
      sourceTable = source;  
      // set the cloned result  
      destinationTable = sourceTable.Clone();  
   }  
  
   public void UpdateAddedColumn() {  
      sourceTable.Columns.CollectionChanged += new CollectionChangeEventHandler(ColumnAdded);  
   }  
  
   public void UpdateDeletedColumn() {  
      sourceTable.Columns.CollectionChanged += new CollectionChangeEventHandler(ColumnDeleted);  
   }  
  
   public void UpdateUniqueConstraint() {  
      sourceTable.Constraints.CollectionChanged += new CollectionChangeEventHandler(UniqueConstraint_Changed);  
   }  
  
   public void UpdateForeignKeyConstraint() {  
      sourceTable.Constraints.CollectionChanged += new CollectionChangeEventHandler(ForeignKeyConstraint_Changed);  
   }  
  
   // After the source table adds a column, the method will add the same column in the destination table.  
   void ColumnAdded(object sender, System.ComponentModel.CollectionChangeEventArgs e) {  
      if (e.Action == CollectionChangeAction.Add) {  
         DataColumn column = e.Element as DataColumn;  
  
         if (column != null) {  
            DataColumn newColumn = new DataColumn(column.ColumnName, column.DataType, column.Expression, column.ColumnMapping);  
  
            if (!destinationTable.Columns.Contains(newColumn.ColumnName))  
               destinationTable.Columns.Add(newColumn);  
         }  
      }  
   }  
  
   // After the source table deletes a column, the method will delete the same column in the destination table.  
   void ColumnDeleted(object sender, CollectionChangeEventArgs e) {  
      if (e.Action == CollectionChangeAction.Remove) {  
         DataColumn column = e.Element as DataColumn;  
  
         if (column != null)  
            if (destinationTable.Columns.Contains(column.ColumnName))  
               destinationTable.Columns.Remove(column.ColumnName);  
      }  
   }  
  
   // After the source table changes the UniqueConstraint, this method changes the same UniqueConstraint in destination table.        
   void UniqueConstraint_Changed(object sender, CollectionChangeEventArgs e) {  
      UniqueConstraint constraint = e.Element as UniqueConstraint;  
  
      if (constraint == null)  
         return;  
  
      String constraintName = constraint.ConstraintName;  
  
      if (e.Action == CollectionChangeAction.Add) {  
         DataColumn[] columns = new DataColumn[constraint.Columns.Count()];  
         Boolean isPrimaryKey = constraint.IsPrimaryKey;  
  
         // Get the columns used in new constraint from the destiantion table.  
         for (Int32 i = 0; i < constraint.Columns.Count(); i++) {  
            String columnName = constraint.Columns[i].ColumnName;  
  
            if (destinationTable.Columns.Contains(columnName))  
               columns[i] = destinationTable.Columns[columnName];  
            else  
               return;  
         }  
  
         UniqueConstraint newConstraint = new UniqueConstraint(constraintName, columns, isPrimaryKey);  
  
         if (!destinationTable.Constraints.Contains(constraintName))  
            destinationTable.Constraints.Add(newConstraint);  
  
      } else if (e.Action == CollectionChangeAction.Remove)  
         if (destinationTable.Constraints.Contains(constraintName))  
            destinationTable.Constraints.Remove(constraintName);  
   }  
  
   // After the source table changes the ForeignKeyConstraint, this method changes    
   // the same ForeignKeyConstraint in the destination table.  
   void ForeignKeyConstraint_Changed(object sender, CollectionChangeEventArgs e) {  
      ForeignKeyConstraint constraint = e.Element as ForeignKeyConstraint;  
  
      if (constraint == null)  
         return;  
  
      // If the source and destination are not in the same DataSet, don't change the ForeignKeyConstraint.  
      if (sourceTable.DataSet != destinationTable.DataSet)  
         return;  
  
      String constraintName = constraint.ConstraintName;  
  
      if (e.Action == CollectionChangeAction.Add) {  
         DataColumn[] columns = new DataColumn[constraint.Columns.Count()];  
         DataColumn[] parentColumns = constraint.RelatedColumns;  
  
         // Get the columns used in new constraint from the destination table.  
         for (int i = 0; i < constraint.Columns.Count(); i++) {  
            String columnName = constraint.Columns[i].ColumnName;  
  
            if (destinationTable.Columns.Contains(columnName))  
               columns[i] = destinationTable.Columns[columnName];  
            else  
               return;  
         }  
  
         ForeignKeyConstraint newConstraint = new ForeignKeyConstraint(constraintName, parentColumns, columns);  
         newConstraint.AcceptRejectRule = constraint.AcceptRejectRule;  
         newConstraint.DeleteRule = constraint.DeleteRule;  
         newConstraint.UpdateRule = constraint.UpdateRule;  
  
         if (!destinationTable.Constraints.Contains(constraintName))  
            destinationTable.Constraints.Add(newConstraint);  
      } else if (e.Action == CollectionChangeAction.Remove)  
         if (destinationTable.Constraints.Contains(constraintName))  
            destinationTable.Constraints.Remove(constraintName);  
   }  
  
   // return the destination table.  
   public DataTable DestinationTable {  
      get { return destinationTable; }  
   }  
}  
```  
  
 Este exemplo mostra como modificar dados em uma DataTable e atualizar a fonte de dados.  
  
 Primeiro, crie um banco de dados:  
  
```  
USE [master]  
GO  
  
CREATE DATABASE [MySchool]   
  
GO  
  
USE [MySchool]  
GO  
  
SET ANSI_NULLS ON  
GO  
SET QUOTED_IDENTIFIER ON  
GO  
CREATE TABLE [dbo].[Course]([CourseID] [nvarchar](10) NOT NULL,  
[Year] [smallint] NOT NULL,  
[Title] [nvarchar](100) NOT NULL,  
[Credits] [int] NOT NULL,  
[DepartmentID] [int] NOT NULL,  
 CONSTRAINT [PK_Course] PRIMARY KEY CLUSTERED   
(  
[CourseID] ASC,  
[Year] ASC  
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON [PRIMARY]) ON [PRIMARY]  
  
GO  
  
SET ANSI_NULLS ON  
GO  
SET QUOTED_IDENTIFIER ON  
GO  
CREATE TABLE [dbo].[Department]([DepartmentID] [int] IDENTITY(1,1) NOT NULL,  
[Name] [nvarchar](50) NOT NULL,  
[Budget] [money] NOT NULL,  
[StartDate] [datetime] NOT NULL,  
[Administrator] [int] NULL,  
 CONSTRAINT [PK_Department] PRIMARY KEY CLUSTERED   
(  
[DepartmentID] ASC  
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON [PRIMARY]) ON [PRIMARY]  
  
GO  
  
INSERT [dbo].[Course] ([CourseID], [Year], [Title], [Credits], [DepartmentID]) VALUES (N'C1045', 2012, N'Calculus', 4, 7)  
INSERT [dbo].[Course] ([CourseID], [Year], [Title], [Credits], [DepartmentID]) VALUES (N'C1061', 2012, N'Physics', 4, 1)  
INSERT [dbo].[Course] ([CourseID], [Year], [Title], [Credits], [DepartmentID]) VALUES (N'C2021', 2012, N'Composition', 3, 2)  
INSERT [dbo].[Course] ([CourseID], [Year], [Title], [Credits], [DepartmentID]) VALUES (N'C2042', 2012, N'Literature', 4, 2)  
  
SET IDENTITY_INSERT [dbo].[Department] ON   
  
INSERT [dbo].[Department] ([DepartmentID], [Name], [Budget], [StartDate], [Administrator]) VALUES (1, N'Engineering', 350000.0000, CAST(0x0000999C00000000 AS DateTime), 2)  
INSERT [dbo].[Department] ([DepartmentID], [Name], [Budget], [StartDate], [Administrator]) VALUES (2, N'English', 120000.0000, CAST(0x0000999C00000000 AS DateTime), 6)  
INSERT [dbo].[Department] ([DepartmentID], [Name], [Budget], [StartDate], [Administrator]) VALUES (4, N'Economics', 200000.0000, CAST(0x0000999C00000000 AS DateTime), 4)  
INSERT [dbo].[Department] ([DepartmentID], [Name], [Budget], [StartDate], [Administrator]) VALUES (7, N'Mathematics', 250024.0000, CAST(0x0000999C00000000 AS DateTime), 3)  
SET IDENTITY_INSERT [dbo].[Department] OFF  
  
ALTER TABLE [dbo].[Course]  WITH CHECK ADD  CONSTRAINT [FK_Course_Department] FOREIGN KEY([DepartmentID])  
REFERENCES [dbo].[Department] ([DepartmentID])  
GO  
ALTER TABLE [dbo].[Course] CHECK CONSTRAINT [FK_Course_Department]  
GO  
```  
  
 Agora você pode compilar e executar o exemplo. [Como modificar dados em DataTable e a atualização da fonte de dados](https://code.msdn.microsoft.com/How-to-modify-data-in-c68d35f4) tem projetos Visual Basic e c# deste exemplo.  
  
```csharp  
using System;  
using System.Data;  
using System.Data.SqlClient;  
  
class Program {  
   static void Main(string[] args) {  
  
   string MySchoolConnectionString = "Data Source=(local);Initial Catalog=MySchool;Integrated Security=True";  
  
      // Get Data  
      String selectString =  
       @"Select [CourseID],[Year],[Title],[Credits],[DepartmentID] From [dbo].[Course];  
               Select [DepartmentID],[Name],[Budget],[StartDate],[Administrator] From [dbo].[Department] ";  
  
      DataSet dataSet = new DataSet();  
      DataTable course = dataSet.Tables.Add("Course");  
      DataTable department = dataSet.Tables.Add("Department");  
  
      Console.WriteLine("Get data from database:");  
      GetDataTables(MySchoolConnectionString, selectString, dataSet, course, department);  
      Console.WriteLine();  
  
      // Use DataTable Edits to edit the data  
      String updateString =  
              @"Update [dbo].[Course] Set [Credits]=@Credits Where [CourseID]=@CourseID;";  
  
      course.ColumnChanged += OnColumnChanged;  
  
      // Set the Credits of first row is negative value, and set the Credits of second row is plus.  
      ChangeCredits(course, course.Rows[0], -1);  
      ChangeCredits(course, course.Rows[1], 11);  
  
      UpdateDataTables(MySchoolConnectionString, updateString, dataSet, "Course",  
          new SqlParameter("@CourseID", SqlDbType.NVarChar, 10, "CourseID"),  
          new SqlParameter("@Credits", SqlDbType.Int, 4, "Credits"));  
      Console.WriteLine("Only the Credits of second row is changed.");  
      ShowDataTable(course);  
      Console.WriteLine();  
  
      // Delete and Remove from DataTable  
      // Create the foreign key constraint, and set the DeleteRule with Cascade.  
      ForeignKeyConstraint courseDepartFK = new ForeignKeyConstraint("CourseDepartFK", department.Columns["DepartmentID"], course.Columns["DepartmentID"]);  
      courseDepartFK.DeleteRule = Rule.Cascade;  
      courseDepartFK.UpdateRule = Rule.Cascade;  
      courseDepartFK.AcceptRejectRule = AcceptRejectRule.None;  
      course.Constraints.Add(courseDepartFK);  
  
      String deleteString = @"Delete From [dbo].[Course] Where [CourseID]=@CourseID;";  
  
      department.Rows[0].Delete();  
      Console.WriteLine("If One row in Department table is deleted, the related rows in Course table will also be deleted.");  
      Console.WriteLine("Department DataTable:");  
      ShowDataTable(department);  
      Console.WriteLine();  
      Console.WriteLine("Course DataTable:");  
      ShowDataTable(course);  
      Console.WriteLine();  
      // Update the delete operation  
      DeleteDataTables(MySchoolConnectionString, deleteString, dataSet, "Course",  
          new SqlParameter("@CourseID", SqlDbType.NVarChar, 10, "CourseID"));  
      Console.WriteLine("After delete operation:");  
      Console.WriteLine("Course DataTable:");  
      ShowDataTable(course);  
      Console.WriteLine();  
  
      course.Rows.RemoveAt(0);  
      Console.WriteLine("Now we remove one row from Course:");  
      ShowDataTable(course);  
      DeleteDataTables(MySchoolConnectionString, deleteString, dataSet, "Course",  
          new SqlParameter("@CourseID", SqlDbType.NVarChar, 10, "CourseID"));  
   }  
  
   // Use SqlDataAdapter to get data.  
   private static void GetDataTables(String connectionString, String selectString,  
       DataSet dataSet, params DataTable[] tables) {  
      using (SqlDataAdapter adapter = new SqlDataAdapter()) {  
         adapter.SelectCommand = new SqlCommand(selectString);  
         adapter.SelectCommand.Connection = new SqlConnection(connectionString);  
  
         adapter.Fill(0, 0, tables);  
  
         foreach (DataTable table in dataSet.Tables) {  
            Console.WriteLine("Data in {0}:", table.TableName);  
            ShowDataTable(table);  
            Console.WriteLine();  
         }  
      }  
   }  
  
   // Use SqlDataAdapter to update the updata operation.  
   private static void UpdateDataTables(String connectionString, String updateString,  
       DataSet dataSet, String tableName, params SqlParameter[] parameters) {  
      using (SqlDataAdapter adapter = new SqlDataAdapter()) {  
         adapter.UpdateCommand = new SqlCommand(updateString);  
         adapter.UpdateCommand.Parameters.AddRange(parameters);  
         adapter.UpdateCommand.Connection = new SqlConnection(connectionString);  
  
         adapter.Update(dataSet, tableName);  
      }  
   }  
  
   // Use SqlDataAdapter to update delete operation.  
   private static void DeleteDataTables(String connectionString, String deleteString,  
       DataSet dataSet, String tableName, params SqlParameter[] parameters) {  
      using (SqlDataAdapter adapter = new SqlDataAdapter()) {  
         adapter.DeleteCommand = new SqlCommand(deleteString);  
         adapter.DeleteCommand.Parameters.AddRange(parameters);  
         adapter.DeleteCommand.Connection = new SqlConnection(connectionString);  
  
         adapter.Update(dataSet, tableName);  
      }  
   }  
  
   // Use DataTable Edits to modify the data.  
   private static void ChangeCredits(DataTable table, DataRow row, Int32 credits) {  
      row.BeginEdit();  
      Console.WriteLine("We change row {0}", table.Rows.IndexOf(row));  
      row["Credits"] = credits;  
      row.EndEdit();  
   }  
  
   // The method will be invoked when the value in DataTable is changed.  
   private static void OnColumnChanged(Object sender, DataColumnChangeEventArgs args) {  
      Int32 credits = 0;  
      // If Credits is changed and the value is negative, we'll cancel the edit.  
      if ((args.Column.ColumnName == "Credits") &&  
          (!Int32.TryParse(args.ProposedValue.ToString(), out credits) || credits < 0)) {  
         Console.WriteLine("The value of Credits is invalid. Edit canceled.");  
         args.Row.CancelEdit();  
      }  
   }  
  
   // Display the column and value of DataTable.  
   private static void ShowDataTable(DataTable table) {  
      foreach (DataColumn col in table.Columns) {  
         Console.Write("{0,-14}", col.ColumnName);  
      }  
      Console.WriteLine("{0,-14}", "RowState");  
  
      foreach (DataRow row in table.Rows) {  
         if (row.RowState == DataRowState.Deleted) {  
            foreach (DataColumn col in table.Columns) {  
               if (col.DataType.Equals(typeof(DateTime)))  
                  Console.Write("{0,-14:d}", row[col, DataRowVersion.Original]);  
               else if (col.DataType.Equals(typeof(Decimal)))  
                  Console.Write("{0,-14:C}", row[col, DataRowVersion.Original]);  
               else  
                  Console.Write("{0,-14}", row[col, DataRowVersion.Original]);  
            }  
         }  
         else {  
            foreach (DataColumn col in table.Columns) {  
               if (col.DataType.Equals(typeof(DateTime)))  
                  Console.Write("{0,-14:d}", row[col]);  
               else if (col.DataType.Equals(typeof(Decimal)))  
                  Console.Write("{0,-14:C}", row[col]);  
               else  
                  Console.Write("{0,-14}", row[col]);  
            }  
         }  
         Console.WriteLine("{0,-14}", row.RowState);  
      }  
   }  
}  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Data.DataTable.Copy" />
      </Docs>
    </Member>
    <Member MemberName="ColumnChanged">
      <MemberSignature Language="C#" Value="public event System.Data.DataColumnChangeEventHandler ColumnChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Data.DataColumnChangeEventHandler ColumnChanged" />
      <MemberSignature Language="DocId" Value="E:System.Data.DataTable.ColumnChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ColumnChanged As DataColumnChangeEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Data::DataColumnChangeEventHandler ^ ColumnChanged;" />
      <MemberSignature Language="F#" Value="member this.ColumnChanged : System.Data.DataColumnChangeEventHandler " Usage="member this.ColumnChanged : System.Data.DataColumnChangeEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.Data.DataSysDescription("DataTableColumnChangedDescr")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Data.DataColumnChangeEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ocorre depois que um valor foi alterado para o <see cref="T:System.Data.DataColumn" /> especificado em um <see cref="T:System.Data.DataRow" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para obter mais informações, consulte [manipulação de eventos de DataTable](~/docs/framework/data/adonet/dataset-datatable-dataview/handling-datatable-events.md).  
  
   
  
## Examples  
 [!code-csharp[Classic WebData DataTable.ColumnChanged Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.ColumnChanged Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.ColumnChanged Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.ColumnChanged Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Data.DataColumnChangeEventHandler" />
      </Docs>
    </Member>
    <Member MemberName="ColumnChanging">
      <MemberSignature Language="C#" Value="public event System.Data.DataColumnChangeEventHandler ColumnChanging;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Data.DataColumnChangeEventHandler ColumnChanging" />
      <MemberSignature Language="DocId" Value="E:System.Data.DataTable.ColumnChanging" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ColumnChanging As DataColumnChangeEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Data::DataColumnChangeEventHandler ^ ColumnChanging;" />
      <MemberSignature Language="F#" Value="member this.ColumnChanging : System.Data.DataColumnChangeEventHandler " Usage="member this.ColumnChanging : System.Data.DataColumnChangeEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.Data.DataSysDescription("DataTableColumnChangingDescr")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Data.DataColumnChangeEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ocorre quando um valor está sendo alterado para o <see cref="T:System.Data.DataColumn" /> especificado em um <see cref="T:System.Data.DataRow" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para obter mais informações, consulte [manipulação de eventos de DataTable](~/docs/framework/data/adonet/dataset-datatable-dataview/handling-datatable-events.md).  
  
   
  
## Examples  
 [!code-csharp[Classic WebData DataTable.ColumnChanging Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.ColumnChanging Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.ColumnChanging Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.ColumnChanging Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Columns">
      <MemberSignature Language="C#" Value="public System.Data.DataColumnCollection Columns { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Data.DataColumnCollection Columns" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataTable.Columns" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Columns As DataColumnCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Data::DataColumnCollection ^ Columns { System::Data::DataColumnCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Columns : System.Data.DataColumnCollection" Usage="System.Data.DataTable.Columns" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Content)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.Data.DataSysDescription("DataTableColumnsDescr")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Data.DataColumnCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém a coleção de colunas que pertencem a essa tabela.</summary>
        <value>Um <see cref="T:System.Data.DataColumnCollection" /> que contém a coleção de objetos <see cref="T:System.Data.DataColumn" /> para a tabela. Será retornada uma coleção vazia se não houver nenhum objeto <see cref="T:System.Data.DataColumn" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Data.DataColumnCollection> determina o esquema de uma tabela definindo o tipo de dados de cada coluna.  
  
   
  
## Examples  
 O exemplo a seguir imprime cada valor de cada linha em uma tabela usando o <xref:System.Data.DataTable.Columns%2A> propriedade.  
  
 [!code-csharp[Classic WebData DataTable.Columns Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.Columns Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.Columns Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.Columns Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Compute">
      <MemberSignature Language="C#" Value="public object Compute (string expression, string filter);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object Compute(string expression, string filter) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.Compute(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Compute (expression As String, filter As String) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ Compute(System::String ^ expression, System::String ^ filter);" />
      <MemberSignature Language="F#" Value="member this.Compute : string * string -&gt; obj" Usage="dataTable.Compute (expression, filter)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.String" />
        <Parameter Name="filter" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="expression">A expressão a computar.</param>
        <param name="filter">O filtro para limitar as linhas que são avaliadas na expressão.</param>
        <summary>Calcula a expressão especificada nas linhas atuais que passam os critérios de filtro.</summary>
        <returns>Um <see cref="T:System.Object" />, definido como o resultado do cálculo. Se a expressão for avaliada como nula, o valor retornado será <see cref="F:System.DBNull.Value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O `expression` parâmetro requer uma função de agregação. Por exemplo, o seguinte é uma expressão legal:  
  
 `Count(Quantity)`  
  
 Mas essa expressão não é:  
  
 `Sum (Quantity * UnitPrice)`  
  
 Se for necessário executar uma operação em duas ou mais colunas, você deve criar uma <xref:System.Data.DataColumn>, defina seu <xref:System.Data.DataColumn.Expression%2A> propriedade para uma expressão apropriada e use uma expressão de agregação a coluna resultante. Nesse caso, considerando um <xref:System.Data.DataColumn> com o nome "total" e o <xref:System.Data.DataColumn.Expression%2A> propriedade definida como este:  
  
 `"Quantity * UnitPrice"`  
  
 O argumento de expressão para o <xref:System.Data.DataTable.Compute%2A> método seria este:  
  
 `Sum(total)`  
  
 O segundo parâmetro, `filter`, determina quais linhas são usadas na expressão. Por exemplo, se a tabela contiver uma coluna de data denominada "colDate", você pode limitar as linhas com a seguinte expressão:  
  
 `colDate > 1/1/99 AND colDate < 17/1/99`  
  
 Para obter regras sobre como criar expressões para ambos os parâmetros, consulte o <xref:System.Data.DataColumn.Expression%2A?displayProperty=nameWithType> propriedade.  
  
   
  
## Examples  
 O exemplo a seguir soma os valores de uma coluna chamada "Total", para o vendedor cujo número de identificação é cinco.  
  
 [!code-csharp[Classic WebData DataTable.Compute Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.Compute Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.Compute Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.Compute Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Constraints">
      <MemberSignature Language="C#" Value="public System.Data.ConstraintCollection Constraints { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Data.ConstraintCollection Constraints" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataTable.Constraints" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Constraints As ConstraintCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Data::ConstraintCollection ^ Constraints { System::Data::ConstraintCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Constraints : System.Data.ConstraintCollection" Usage="System.Data.DataTable.Constraints" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Content)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.Data.DataSysDescription("DataTableConstraintsDescr")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Data.ConstraintCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém a coleção de restrições mantidas por essa tabela.</summary>
        <value>Um <see cref="T:System.Data.ConstraintCollection" /> que contém a coleção de objetos <see cref="T:System.Data.Constraint" /> para a tabela. Será retornada uma coleção vazia se não houver nenhum objeto <see cref="T:System.Data.Constraint" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Um <xref:System.Data.ForeignKeyConstraint> restringe a ação executada quando um valor em uma coluna (ou colunas) é excluído ou atualizado. Tal restrição se destina a ser usado com colunas de chave primária. Em uma relação pai/filho entre duas tabelas, a exclusão de um valor da tabela pai pode afetar as linhas filho em uma das seguintes maneiras.  
  
-   O filho linhas também podem ser excluído (uma ação em cascata).  
  
-   Os valores na coluna filho (ou colunas) podem ser definidos com valores nulos.  
  
-   Os valores na coluna filho (ou colunas) podem ser definidos com valores padrão.  
  
-   Uma exceção pode ser gerada.  
  
 Um <xref:System.Data.UniqueConstraint> se torna ativa durante a tentativa de definir um valor em uma chave primária para um valor não exclusivo.  
  
   
  
## Examples  
 O exemplo a seguir adiciona um <xref:System.Data.ForeignKeyConstraint> para a coleção de restrições.  
  
 [!code-csharp[Classic WebData DataTable.Constraints Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.Constraints Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.Constraints Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.Constraints Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Copy">
      <MemberSignature Language="C#" Value="public System.Data.DataTable Copy ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.DataTable Copy() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.Copy" />
      <MemberSignature Language="VB.NET" Value="Public Function Copy () As DataTable" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::DataTable ^ Copy();" />
      <MemberSignature Language="F#" Value="member this.Copy : unit -&gt; System.Data.DataTable" Usage="dataTable.Copy " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataTable</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Copia a estrutura e os dados para este <see cref="T:System.Data.DataTable" />.</summary>
        <returns>Um novo <see cref="T:System.Data.DataTable" /> com a mesma estrutura (esquemas de tabela e restrições) e dados que esse <see cref="T:System.Data.DataTable" />.  
  
Se essas classes tiverem sido derivadas, a cópia também será das mesmas classes derivadas.  
  
 <see cref="M:System.Data.DataTable.Copy" /> cria um novo <see cref="T:System.Data.DataTable" /> com a mesma estrutura e dados que o <see cref="T:System.Data.DataTable" /> original. Para copiar a estrutura para um novo <see cref="T:System.Data.DataTable" />, mas não os dados, use <see cref="M:System.Data.DataTable.Clone" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O exemplo a seguir usa o <xref:System.Data.DataTable.Copy%2A> método para criar uma cópia do original <xref:System.Data.DataTable>. O nome do namespace não é mantido se ela é herdada de um pai <xref:System.Data.DataTable> ou <xref:System.Data.DataSet>.  
  
 [!code-csharp[Classic WebData DataTable.Copy Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.Copy Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.Copy Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.Copy Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Data.DataView.ToTable" />
        <altmember cref="M:System.Data.DataTable.Clone" />
      </Docs>
    </Member>
    <Member MemberName="CreateDataReader">
      <MemberSignature Language="C#" Value="public System.Data.DataTableReader CreateDataReader ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.DataTableReader CreateDataReader() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.CreateDataReader" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateDataReader () As DataTableReader" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::DataTableReader ^ CreateDataReader();" />
      <MemberSignature Language="F#" Value="member this.CreateDataReader : unit -&gt; System.Data.DataTableReader" Usage="dataTable.CreateDataReader " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataTableReader</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retorna um <see cref="T:System.Data.DataTableReader" /> correspondente aos dados nessa <see cref="T:System.Data.DataTable" />.</summary>
        <returns>Um <see cref="T:System.Data.DataTableReader" /> que contém um conjunto de resultados, correspondente à instância <see cref="T:System.Data.DataTable" /> da origem.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O aplicativo de console a seguir cria um <xref:System.Data.DataTable> instância. O exemplo, em seguida, passa o preenchido <xref:System.Data.DataTable> para um procedimento que chama o <xref:System.Data.DataTable.CreateDataReader%2A> método, que itera pelos resultados da contidos o <xref:System.Data.DataTableReader>.  
  
 [!code-csharp[DataWorks DataTable.CreateDataReader#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTable.CreateDataReader/CS/source.cs#1)]
 [!code-vb[DataWorks DataTable.CreateDataReader#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTable.CreateDataReader/VB/source.vb#1)]  
  
 O exemplo exibe a seguinte saída na janela do console:  
  
 `1 Mary`  
  
 `2 Andy`  
  
 `3 Peter`  
  
 `4 Russ`  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Data.DataSet.CreateDataReader" />
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="protected virtual System.Data.DataTable CreateInstance ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Data.DataTable CreateInstance() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.CreateInstance" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function CreateInstance () As DataTable" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Data::DataTable ^ CreateInstance();" />
      <MemberSignature Language="F#" Value="abstract member CreateInstance : unit -&gt; System.Data.DataTable&#xA;override this.CreateInstance : unit -&gt; System.Data.DataTable" Usage="dataTable.CreateInstance " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataTable</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Cria uma nova instância de <see cref="T:System.Data.DataTable" />.</summary>
        <returns>A nova expressão.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DataSet">
      <MemberSignature Language="C#" Value="public System.Data.DataSet DataSet { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Data.DataSet DataSet" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataTable.DataSet" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DataSet As DataSet" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Data::DataSet ^ DataSet { System::Data::DataSet ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DataSet : System.Data.DataSet" Usage="System.Data.DataTable.DataSet" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.Data.DataSysDescription("DataTableDataSetDescr")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Data.DataSet</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém o <see cref="T:System.Data.DataSet" /> ao qual essa tabela pertence.</summary>
        <value>O <see cref="T:System.Data.DataSet" /> ao qual essa tabela pertence.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se um controle é dados associados a um <xref:System.Data.DataTable>, e a tabela pertence a um <xref:System.Data.DataSet>, você pode obter o <xref:System.Data.DataSet> através desta propriedade.  
  
   
  
## Examples  
 O exemplo a seguir retorna o pai <xref:System.Data.DataSet> de uma determinada tabela por meio de <xref:System.Data.DataTable.DataSet%2A> propriedade.  
  
 [!code-csharp[Classic WebData DataTable.DataSet Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.DataSet Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.DataSet Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.DataSet Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DefaultView">
      <MemberSignature Language="C#" Value="public System.Data.DataView DefaultView { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Data.DataView DefaultView" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataTable.DefaultView" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DefaultView As DataView" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Data::DataView ^ DefaultView { System::Data::DataView ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DefaultView : System.Data.DataView" Usage="System.Data.DataTable.DefaultView" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.Data.DataSysDescription("DataTableDefaultViewDescr")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Data.DataView</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém uma exibição personalizada da tabela que pode incluir uma exibição filtrada ou uma posição do cursor.</summary>
        <value>O <see cref="T:System.Data.DataView" /> associado ao <see cref="T:System.Data.DataTable" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Data.DataTable.DefaultView%2A> propriedade retorna um <xref:System.Data.DataView> você pode usar para classificar, filtrar e pesquisar um <xref:System.Data.DataTable>.  
  
   
  
## Examples  
 O exemplo a seguir define uma propriedade do <xref:System.Data.DataTable> do objeto <xref:System.Data.DataView> por meio de <xref:System.Data.DataTable.DefaultView%2A> propriedade. O exemplo também mostra a associação de um <xref:System.Windows.Forms.DataGridView> o controle para um <xref:System.Data.DataTable> denominado "Fornecedores" que inclui uma coluna chamada "CompanyName".  
  
 [!code-csharp[Classic WebData DataTable.DefaultView Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.DefaultView Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.DefaultView Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.DefaultView Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DisplayExpression">
      <MemberSignature Language="C#" Value="public string DisplayExpression { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string DisplayExpression" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataTable.DisplayExpression" />
      <MemberSignature Language="VB.NET" Value="Public Property DisplayExpression As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ DisplayExpression { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.DisplayExpression : string with get, set" Usage="System.Data.DataTable.DisplayExpression" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.ComponentModel.DefaultValue("")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.Data.DataSysDescription("DataTableDisplayExpressionDescr")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define a expressão que retorna um valor usado para representar essa tabela na interface do usuário. A propriedade <see langword="DisplayExpression" /> permite exibir o nome da tabela em uma interface do usuário.</summary>
        <value>Uma cadeia de caracteres de exibição.</value>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Data.DataColumn.Expression" />
      </Docs>
    </Member>
    <Member MemberName="EndInit">
      <MemberSignature Language="C#" Value="public virtual void EndInit ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void EndInit() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.EndInit" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub EndInit ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void EndInit();" />
      <MemberSignature Language="F#" Value="abstract member EndInit : unit -&gt; unit&#xA;override this.EndInit : unit -&gt; unit" Usage="dataTable.EndInit " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Encerra a inicialização de um <see cref="T:System.Data.DataTable" /> que é usado em um formulário ou por outro componente. A inicialização ocorre no tempo de execução.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O ambiente de design do Visual Studio .NET usa esse método para encerrar a inicialização de um componente que é usado em um formulário ou por outro componente. O <xref:System.Data.DataTable.BeginInit%2A> método começa a inicialização. Usando o <xref:System.Data.DataTable.BeginInit%2A> e <xref:System.Data.DataTable.EndInit%2A> métodos impede que o controle seja usado antes de ser totalmente inicializado.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EndLoadData">
      <MemberSignature Language="C#" Value="public void EndLoadData ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EndLoadData() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.EndLoadData" />
      <MemberSignature Language="VB.NET" Value="Public Sub EndLoadData ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EndLoadData();" />
      <MemberSignature Language="F#" Value="member this.EndLoadData : unit -&gt; unit" Usage="dataTable.EndLoadData " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Desativa as notificações, a manutenção de índice e as restrições após o carregamento de dados.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use <xref:System.Data.DataTable.EndLoadData%2A> em conjunto com <xref:System.Data.DataTable.LoadDataRow%2A> e <xref:System.Data.DataTable.BeginLoadData%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ExtendedProperties">
      <MemberSignature Language="C#" Value="public System.Data.PropertyCollection ExtendedProperties { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Data.PropertyCollection ExtendedProperties" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataTable.ExtendedProperties" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ExtendedProperties As PropertyCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Data::PropertyCollection ^ ExtendedProperties { System::Data::PropertyCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ExtendedProperties : System.Data.PropertyCollection" Usage="System.Data.DataTable.ExtendedProperties" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.Data.DataSysDescription("ExtendedPropertiesDescr")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Data.PropertyCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém a coleção de informações de usuário personalizadas.</summary>
        <value>Um <see cref="T:System.Data.PropertyCollection" /> que contém informações de usuário personalizadas.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use o <xref:System.Data.DataTable.ExtendedProperties%2A> para adicionar informações personalizadas a um <xref:System.Data.DataTable>. Adicionar informações com o `Add` método. Recuperar as informações com o `Item` método.  
  
 As propriedades estendidas devem ser do tipo <xref:System.String>. As propriedades que não são do tipo cadeia de caracteres não são persistidas quando o <xref:System.Data.DataTable> é gravado como XML.  
  
   
  
## Examples  
 O exemplo a seguir adiciona um valor de carimbo de hora para o <xref:System.Data.DataTable> por meio de <xref:System.Data.DataTable.ExtendedProperties%2A> propriedade.  
  
 [!code-csharp[Classic WebData DataTable.ExtendedProperties Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.ExtendedProperties Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.ExtendedProperties Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.ExtendedProperties Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="fInitInProgress">
      <MemberSignature Language="C#" Value="protected internal bool fInitInProgress;" />
      <MemberSignature Language="ILAsm" Value=".field familyorassembly bool fInitInProgress" />
      <MemberSignature Language="DocId" Value="F:System.Data.DataTable.fInitInProgress" />
      <MemberSignature Language="VB.NET" Value="Protected Friend fInitInProgress As Boolean " />
      <MemberSignature Language="C++ CLI" Value="protected public: bool fInitInProgress;" />
      <MemberSignature Language="F#" Value="val mutable fInitInProgress : bool" Usage="System.Data.DataTable.fInitInProgress" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Verifica se a inicialização está em andamento. A inicialização ocorre no tempo de execução.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetChanges">
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Obtém uma cópia do <see cref="T:System.Data.DataTable" /> que contém todas as alterações feitas nele desde que foi carregado pela última vez ou desde que <see cref="M:System.Data.DataTable.AcceptChanges" /> foi chamado.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetChanges">
      <MemberSignature Language="C#" Value="public System.Data.DataTable GetChanges ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.DataTable GetChanges() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.GetChanges" />
      <MemberSignature Language="VB.NET" Value="Public Function GetChanges () As DataTable" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::DataTable ^ GetChanges();" />
      <MemberSignature Language="F#" Value="member this.GetChanges : unit -&gt; System.Data.DataTable" Usage="dataTable.GetChanges " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataTable</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Obtém uma cópia do <see cref="T:System.Data.DataTable" /> que contém todas as alterações feitas nele desde que ele foi carregado ou que o <see cref="M:System.Data.DataTable.AcceptChanges" /> foi chamado pela última vez.</summary>
        <returns>Uma cópia das alterações neste <see cref="T:System.Data.DataTable" /> ou <see langword="null" /> se nenhuma alteração foi encontrada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cria um novo <xref:System.Data.DataSet> que contém uma cópia de todas as linhas no original <xref:System.Data.DataSet> que possuem alterações pendentes. Restrições de relação podem fazer com que linhas inalteradas adicionais a serem adicionados ao novo <xref:System.Data.DataSet> se linhas inalteradas contêm chaves primárias correspondentes a chaves estrangeiras em linhas alteradas. O método retornará `null` (`Nothing` no Visual Basic) se não houver nenhuma linha no original <xref:System.Data.DataSet> com alterações pendentes.  
  
   
  
## Examples  
 [!code-csharp[Classic WebData DataTable.GetChanges Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.GetChanges Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.GetChanges Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.GetChanges Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetChanges">
      <MemberSignature Language="C#" Value="public System.Data.DataTable GetChanges (System.Data.DataRowState rowStates);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.DataTable GetChanges(valuetype System.Data.DataRowState rowStates) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.GetChanges(System.Data.DataRowState)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetChanges (rowStates As DataRowState) As DataTable" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::DataTable ^ GetChanges(System::Data::DataRowState rowStates);" />
      <MemberSignature Language="F#" Value="member this.GetChanges : System.Data.DataRowState -&gt; System.Data.DataTable" Usage="dataTable.GetChanges rowStates" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataTable</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rowStates" Type="System.Data.DataRowState" />
      </Parameters>
      <Docs>
        <param name="rowStates">Um dos valores de <see cref="T:System.Data.DataRowState" />.</param>
        <summary>Obtém uma cópia do <see cref="T:System.Data.DataTable" /> que contém todas as alterações feitas desde o último carregamento ou desde que <see cref="M:System.Data.DataTable.AcceptChanges" /> foi chamado, filtrado por <see cref="T:System.Data.DataRowState" />.</summary>
        <returns>Uma cópia filtrada do <see cref="T:System.Data.DataTable" /> que pode ter ações executadas nela e, mais tarde, ser mesclada novamente ao <see cref="T:System.Data.DataTable" /> usando <see cref="M:System.Data.DataSet.Merge(System.Data.DataSet)" />. Se nenhuma linha do <see cref="T:System.Data.DataRowState" /> desejado for encontrada, o método retornará <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Data.DataTable.GetChanges%2A> método é usado para produzir um segundo <xref:System.Data.DataTable> objeto que contém apenas as alterações introduzidas ao original. Use o `rowStates` argumento para especificar o tipo de alterações para o novo objeto deve incluir.  
  
 Restrições de relação podem causar linhas inalteradas pai a ser incluído.  
  
   
  
## Examples  
 [!code-csharp[Classic WebData DataTable.GetChanges1 Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.GetChanges1 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.GetChanges1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.GetChanges1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetDataTableSchema">
      <MemberSignature Language="C#" Value="public static System.Xml.Schema.XmlSchemaComplexType GetDataTableSchema (System.Xml.Schema.XmlSchemaSet schemaSet);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Xml.Schema.XmlSchemaComplexType GetDataTableSchema(class System.Xml.Schema.XmlSchemaSet schemaSet) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.GetDataTableSchema(System.Xml.Schema.XmlSchemaSet)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetDataTableSchema (schemaSet As XmlSchemaSet) As XmlSchemaComplexType" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Xml::Schema::XmlSchemaComplexType ^ GetDataTableSchema(System::Xml::Schema::XmlSchemaSet ^ schemaSet);" />
      <MemberSignature Language="F#" Value="static member GetDataTableSchema : System.Xml.Schema.XmlSchemaSet -&gt; System.Xml.Schema.XmlSchemaComplexType" Usage="System.Data.DataTable.GetDataTableSchema schemaSet" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.Schema.XmlSchemaComplexType</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="schemaSet" Type="System.Xml.Schema.XmlSchemaSet" />
      </Parameters>
      <Docs>
        <param name="schemaSet">Uma instância <see cref="T:System.Xml.Schema.XmlSchemaSet" />.</param>
        <summary>Esse método retorna uma instância <see cref="T:System.Xml.Schema.XmlSchemaSet" /> que contém a linguagem WSDL que descreve o <see cref="T:System.Data.DataTable" /> para os Serviços Web.</summary>
        <returns>A instância <see cref="T:System.Xml.Schema.XmlSchemaSet" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetErrors">
      <MemberSignature Language="C#" Value="public System.Data.DataRow[] GetErrors ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.DataRow[] GetErrors() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.GetErrors" />
      <MemberSignature Language="VB.NET" Value="Public Function GetErrors () As DataRow()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Data::DataRow ^&gt; ^ GetErrors();" />
      <MemberSignature Language="F#" Value="member this.GetErrors : unit -&gt; System.Data.DataRow[]" Usage="dataTable.GetErrors " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataRow[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Obtém uma matriz de objetos <see cref="T:System.Data.DataRow" /> que contêm erros.</summary>
        <returns>Uma matriz de objetos <see cref="T:System.Data.DataRow" /> que têm erros.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Retorna a lista de <xref:System.Data.DataRow> objetos que têm <xref:System.Data.DataRow.RowError%2A> definido. Por exemplo, erros podem ocorrer ao chamar <xref:System.Data.Common.DataAdapter.Update%2A> com <xref:System.Data.Common.DataAdapter.ContinueUpdateOnError%2A> definido como **verdadeiro**. Não invoque <xref:System.Data.DataTable.AcceptChanges%2A> sobre o <xref:System.Data.DataTable> até que você resolva todos os erros e envie novamente o <xref:System.Data.DataSet> para a atualização.  
  
   
  
## Examples  
 O exemplo a seguir usa o <xref:System.Data.DataTable.GetErrors%2A> método para retornar uma matriz de <xref:System.Data.DataRow> objetos que possuem erros.  
  
 [!code-csharp[Classic WebData DataTable.GetErrors Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.GetErrors Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.GetErrors Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.GetErrors Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Data.DataTable.HasErrors" />
        <altmember cref="P:System.Data.DataRow.RowError" />
        <altmember cref="M:System.Data.DataRow.SetColumnError(System.Int32,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="GetObjectData">
      <MemberSignature Language="C#" Value="public virtual void GetObjectData (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void GetObjectData(class System.Runtime.Serialization.SerializationInfo info, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub GetObjectData (info As SerializationInfo, context As StreamingContext)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void GetObjectData(System::Runtime::Serialization::SerializationInfo ^ info, System::Runtime::Serialization::StreamingContext context);" />
      <MemberSignature Language="F#" Value="abstract member GetObjectData : System.Runtime.Serialization.SerializationInfo * System.Runtime.Serialization.StreamingContext -&gt; unit&#xA;override this.GetObjectData : System.Runtime.Serialization.SerializationInfo * System.Runtime.Serialization.StreamingContext -&gt; unit" Usage="dataTable.GetObjectData (info, context)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="info" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="info">Um objeto <see cref="T:System.Runtime.Serialization.SerializationInfo" /> que contém os dados serializados associados a <see cref="T:System.Data.DataTable" />.</param>
        <param name="context">Um objeto <see cref="T:System.Runtime.Serialization.StreamingContext" /> que contém a origem e o destino do fluxo serializado associado a <see cref="T:System.Data.DataTable" />.</param>
        <summary>Popula um objeto de informações de serialização com os dados necessários para serializar o <see cref="T:System.Data.DataTable" />.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">O parâmetro <see langword="Nothing" /> é uma referência nula (<paramref name="info" /> no Visual Basic).</exception>
      </Docs>
    </Member>
    <Member MemberName="GetRowType">
      <MemberSignature Language="C#" Value="protected virtual Type GetRowType ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Type GetRowType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.GetRowType" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function GetRowType () As Type" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual Type ^ GetRowType();" />
      <MemberSignature Language="F#" Value="abstract member GetRowType : unit -&gt; Type&#xA;override this.GetRowType : unit -&gt; Type" Usage="dataTable.GetRowType " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Obtém o tipo de linha.</summary>
        <returns>Retorna o tipo do <see cref="T:System.Data.DataRow" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetSchema">
      <MemberSignature Language="C#" Value="protected virtual System.Xml.Schema.XmlSchema GetSchema ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Xml.Schema.XmlSchema GetSchema() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.GetSchema" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function GetSchema () As XmlSchema" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Xml::Schema::XmlSchema ^ GetSchema();" />
      <MemberSignature Language="F#" Value="abstract member GetSchema : unit -&gt; System.Xml.Schema.XmlSchema&#xA;override this.GetSchema : unit -&gt; System.Xml.Schema.XmlSchema" Usage="dataTable.GetSchema " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Xml.Serialization.IXmlSerializable.GetSchema</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.Schema.XmlSchema</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Para obter uma descrição desse membro, consulte <see cref="M:System.Xml.Serialization.IXmlSerializable.GetSchema" />.</summary>
        <returns>Um <see cref="T:System.Xml.Schema.XmlSchema" /> que descreve a representação XML do objeto produzido pelo método <see cref="M:System.Xml.Serialization.IXmlSerializable.WriteXml(System.Xml.XmlWriter)" /> e consumido pelo método <see cref="M:System.Xml.Serialization.IXmlSerializable.ReadXml(System.Xml.XmlReader)" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="HasErrors">
      <MemberSignature Language="C#" Value="public bool HasErrors { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool HasErrors" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataTable.HasErrors" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property HasErrors As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool HasErrors { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.HasErrors : bool" Usage="System.Data.DataTable.HasErrors" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.Data.DataSysDescription("DataTableHasErrorsDescr")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém um valor que indica se há erros em alguma das linhas em uma das tabelas de <see cref="T:System.Data.DataSet" /> a que a tabela pertence.</summary>
        <value>
          <see langword="true" /> se houver erros; caso contrário, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Conforme os usuários trabalham em um conjunto de dados contidos em um <xref:System.Data.DataTable>, você pode marcar cada alteração com um erro se a alteração causar alguma falha de validação. Você pode marcar toda uma <xref:System.Data.DataRow> com uma mensagem de erro usando o <xref:System.Data.DataRow.RowError%2A> propriedade. Você também pode definir os erros em cada coluna da linha com o <xref:System.Data.DataRow.SetColumnError%2A> método.  
  
 Antes de atualizar uma fonte de dados com um <xref:System.Data.DataSet>, é recomendável que você primeiro chama o <xref:System.Data.DataSet.GetChanges%2A> método no destino <xref:System.Data.DataSet>. O método resulta em um <xref:System.Data.DataSet> que contém apenas as alterações feitas no original. Antes de enviar o <xref:System.Data.DataSet> à fonte de dados para a atualização, verifique o <xref:System.Data.DataTable.HasErrors%2A> propriedade de cada tabela para ver se os erros foram anexados às linhas ou colunas nas linhas.  
  
 Depois de reconciliar cada erro, limpar os erros com o <xref:System.Data.DataRow.ClearErrors%2A> método da `DataRow`.  
  
   
  
## Examples  
 O exemplo a seguir usa o <xref:System.Data.DataTable.HasErrors%2A> propriedade para verificar se uma tabela contém erros.  
  
 [!code-csharp[Classic WebData DataTable.HasErrors Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.HasErrors Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.HasErrors Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.HasErrors Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Data.DataTable.GetErrors" />
      </Docs>
    </Member>
    <Member MemberName="ImportRow">
      <MemberSignature Language="C#" Value="public void ImportRow (System.Data.DataRow row);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ImportRow(class System.Data.DataRow row) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.ImportRow(System.Data.DataRow)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ImportRow (row As DataRow)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ImportRow(System::Data::DataRow ^ row);" />
      <MemberSignature Language="F#" Value="member this.ImportRow : System.Data.DataRow -&gt; unit" Usage="dataTable.ImportRow row" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="row" Type="System.Data.DataRow" />
      </Parameters>
      <Docs>
        <param name="row">O <see cref="T:System.Data.DataRow" /> a ser importado.</param>
        <summary>Copia um <see cref="T:System.Data.DataRow" /> em um <see cref="T:System.Data.DataTable" />, preservando quaisquer configurações de propriedade, bem como os valores originais e atuais.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Chamando <xref:System.Data.DataTable.NewRow%2A> adiciona uma linha à tabela usando o esquema de tabela existente, mas com valores padrão para a linha e define o <xref:System.Data.DataRowState> para `Detached`. Chamando <xref:System.Data.DataTable.ImportRow%2A> preserva existente <xref:System.Data.DataRowState> juntamente com outros valores na linha. Se o `DataRow` que é passado como um parâmetro está em um estado desconectado, ele será ignorado e nenhuma exceção é lançada.  
  
 A nova linha será adicionada ao final da tabela de dados.  
  
 Se a nova linha violar uma restrição não será adicionado à tabela de dados.  
  
 Você pode obter o índice da nova linha com como DataTable.Rows.Find e DataTable.Rows.IndexOf. Consulte <xref:System.Data.DataRowCollection> e <xref:System.Data.DataTable.Rows%2A> para obter mais informações.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Initialized">
      <MemberSignature Language="C#" Value="public event EventHandler Initialized;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Initialized" />
      <MemberSignature Language="DocId" Value="E:System.Data.DataTable.Initialized" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Initialized As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event EventHandler ^ Initialized;" />
      <MemberSignature Language="F#" Value="member this.Initialized : EventHandler " Usage="member this.Initialized : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ocorre após o <see cref="T:System.Data.DataTable" /> ser inicializado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para obter mais informações, consulte <xref:System.Data.DataTable.IsInitialized%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsInitialized">
      <MemberSignature Language="C#" Value="public bool IsInitialized { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsInitialized" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataTable.IsInitialized" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsInitialized As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsInitialized { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsInitialized : bool" Usage="System.Data.DataTable.IsInitialized" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém um valor que indica se o <see cref="T:System.Data.DataTable" /> é inicializado.</summary>
        <value>
          <see langword="true" /> para indicar que o componente concluiu a inicialização; caso contrário, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Retorna o status do <xref:System.Data.DataTable> enquanto ele está sendo construído, por exemplo, o Visual Studio. O <xref:System.Data.DataTable.BeginInit%2A> método define-a como `false` e <xref:System.Data.DataTable.EndInit%2A> método define como `true`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Load">
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Preenche um <see cref="T:System.Data.DataTable" /> com valores de uma fonte de dados usando o <see cref="T:System.Data.IDataReader" />fornecido. Se o <see langword="DataTable" /> já contiver linhas, os dados de entrada da fonte de dados serão mesclados com as linhas existentes.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O `Load` método pode ser usado em vários cenários comuns, tudo centralizados em torno de obtenção de dados de uma fonte de dados especificado e adicioná-lo para o contêiner de dados atual (nesse caso, um `DataTable`). Esses cenários descrevem o uso padrão para um `DataTable`, que descreve sua atualização e o comportamento de mesclagem.  
  
 Um `DataTable` sincroniza ou atualiza com uma fonte de dados primário. O `DataTable` rastreia as alterações, permitindo que a sincronização com fonte de dados principal. Além disso, um `DataTable` pode aceitar dados incrementais de um ou mais fontes de dados secundários. O `DataTable` não se responsabiliza por controle de alterações para permitir que a sincronização com a fonte de dados secundário.  
  
 Dadas essas duas fontes de dados hipotéticas, um usuário deve exigir um dos seguintes comportamentos:  
  
-   Inicializar `DataTable` de uma fonte de dados primário. Nesse cenário, o usuário deseja inicializar vazio `DataTable` com valores da fonte de dados primário. Posteriormente, o usuário deseja propagar alterações de volta para a fonte de dados primária.  
  
-   Preservar alterações e ressincronizar a partir da fonte de dados primária. Nesse cenário, o usuário deseja levar a `DataTable` preenchido no cenário anterior e execute uma sincronização incremental com a fonte de dados primário, preservando as modificações feitas na `DataTable`.  
  
-   Feed de dados incremental das fontes de dados secundárias. Nesse cenário, o usuário deseja mesclar alterações de uma ou mais fontes de dados secundárias e propaga essas alterações de volta para a fonte de dados primária.  
  
 O `Load` método possibilita todos esses cenários. Apenas uma das sobrecargas para esse método permite que você especificar um parâmetro de opção de carga, que indica como as linhas já em um <xref:System.Data.DataTable> combinar com linhas que está sendo carregadas. (A sobrecarga que não permite que você especifique o comportamento usa a opção de carregamento padrão). A tabela a seguir descreve as três opções de carregamento fornecidas pela enumeração <xref:System.Data.LoadOption>. Em cada caso, a descrição indica o comportamento quando a chave primária de uma linha nos dados de entrada corresponde à chave primária de uma linha existente.  
  
|Carregar Opção|Descrição|  
|-----------------|-----------------|  
|`PreserveChanges` (padrão)|Atualiza a versão original da linha com o valor da linha de entrada.|  
|`OverwriteChanges`|Atualiza as versões atual e original da linha com o valor da linha de entrada.|  
|`Upsert`|Atualiza a versão atual da linha com o valor da linha de entrada.|  
  
 Em geral, as opções `PreserveChanges` e `OverwriteChanges` se destinam a cenários nos quais o usuário precisa sincronizar o `DataSet` e suas alterações com a fonte de dados primária. A opção `Upsert` facilita a agregação de alterações de uma ou mais fontes de dados secundárias.  
  
   
  
## Examples  
 O exemplo a seguir demonstra vários dos problemas envolvidos na chamada a <xref:System.Data.DataTable.Load%2A> método. Primeiro, o exemplo se concentra em problemas de esquema, inclusive inferindo um esquema a partir do <xref:System.Data.IDataReader>carregado e, em seguida, tratando esquemas incompatíveis e esquemas com colunas ausentes ou adicionais. O exemplo, em seguida, se concentra em problemas de dados, incluindo a manipulação de várias opções de carregamento.  
  
> [!NOTE]
>  Este exemplo mostra como usar uma das versões sobrecarregadas do `Load`. Para obter outros exemplos que possam estar disponíveis, consulte os tópicos de sobrecarga individuais.  
  
 [!code-csharp[DataWorks DataTableLoad#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTableLoad/CS/source.cs#1)]
 [!code-vb[DataWorks DataTableLoad#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTableLoad/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Data.DataSet.Load" />
      </Docs>
    </MemberGroup>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public void Load (System.Data.IDataReader reader);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Load(class System.Data.IDataReader reader) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.Load(System.Data.IDataReader)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Load (reader As IDataReader)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Load(System::Data::IDataReader ^ reader);" />
      <MemberSignature Language="F#" Value="member this.Load : System.Data.IDataReader -&gt; unit" Usage="dataTable.Load reader" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Data.IDataReader" />
      </Parameters>
      <Docs>
        <param name="reader">Um <see cref="T:System.Data.IDataReader" /> que fornece um conjunto de resultados.</param>
        <summary>Preenche um <see cref="T:System.Data.DataTable" /> com valores de uma fonte de dados usando o <see cref="T:System.Data.IDataReader" />fornecido. Se o <see cref="T:System.Data.DataTable" /> já contiver linhas, os dados de entrada da fonte de dados serão mesclados com as linhas existentes.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Data.DataTable.Load%2A> método consome o primeiro conjunto de resultados de carregado <xref:System.Data.IDataReader>e após a conclusão bem-sucedida, define a posição do leitor para o próximo conjunto de resultados, se houver. Durante a conversão de dados, o `Load` método usa as mesmas regras de conversão que o <xref:System.Data.Common.DbDataAdapter.Fill%2A?displayProperty=nameWithType> método.  
  
 O <xref:System.Data.DataTable.Load%2A> método deve levar em conta três problemas específicos ao carregar os dados de um <xref:System.Data.IDataReader> instância: operações de esquema, dados e eventos. Ao trabalhar com o esquema, o <xref:System.Data.DataTable.Load%2A> método poderá encontrar as condições conforme descrito na tabela a seguir. As operações de esquema ocorrem para todos os conjuntos de resultados importados, mesmo aqueles que contêm nenhum dado.  
  
|Condição|Comportamento|  
|---------------|--------------|  
|O <xref:System.Data.DataTable> não tiver nenhum esquema.|O <xref:System.Data.DataTable.Load%2A> método infere o esquema com base em que o conjunto de resultados de importado <xref:System.Data.IDataReader>.|  
|O <xref:System.Data.DataTable> tem um esquema, mas ele não é compatível com o esquema carregado.|O <xref:System.Data.DataTable.Load%2A> método gera uma exceção correspondente para o erro específico que ocorre durante a tentativa de carregar dados no esquema incompatível.|  
|Os esquemas são compatíveis, mas o esquema de conjunto de resultados carregado contém colunas que não existem no <xref:System.Data.DataTable>.|O <xref:System.Data.DataTable.Load%2A> método adiciona as colunas extras para `DataTable`do esquema. O método gera uma exceção se correspondente colunas no <xref:System.Data.DataTable> e o conjunto de resultados carregados não são compatíveis de valor. O método também recupera informações de restrição de conjunto de resultados de todas as colunas adicionadas. Exceto para o caso da restrição Primary Key, essas informações de restrição são usadas somente se o atual <xref:System.Data.DataTable> não contém nenhuma coluna no início da operação de carregamento.|  
|Os esquemas são compatíveis, mas o esquema de conjunto de resultados carregado contém menos colunas do que faz o `DataTable`.|Se uma coluna ausente tem um valor padrão definido ou tipo de dados da coluna é anulável, o <xref:System.Data.DataTable.Load%2A> método permite que as linhas a serem adicionados, substituindo o padrão ou `null` valor da coluna ausente. Se nenhum valor padrão ou `null` pode ser usado, em seguida, a `Load` método lançará uma exceção. Se nenhum valor padrão específico tiver sido fornecido, o `Load` usa o `null` valor como o valor padrão implícito.|  
  
 Antes de considerar o comportamento do `Load` método em termos de operações de dados, considere a possibilidade de que cada linha dentro de um <xref:System.Data.DataTable> mantém o valor atual e o valor original para cada coluna. Esses valores podem ser equivalentes, ou pode ser diferentes se os dados na linha tem sido alterados desde o preenchimento de `DataTable`.  Para obter mais informações, consulte [estados de linha e versões de linha](~/docs/framework/data/adonet/dataset-datatable-dataview/row-states-and-row-versions.md).  
  
 Esta versão do `Load` método tentará preservar os valores atuais em cada linha, deixando intactos o valor original. (Se você quiser ter maior controle sobre o comportamento de dados de entrada, consulte <xref:System.Data.DataTable.Load%2A?displayProperty=nameWithType>.) Se a linha existente e a linha de entrada contêm valores de chave primária correspondentes, a linha é processada usando seu valor de estado de linha atual, caso contrário, ele será tratado como uma nova linha.  
  
 Em termos de operações de evento, o <xref:System.Data.DataTable.RowChanging> evento ocorre antes de cada linha é alterada e o <xref:System.Data.DataTable.RowChanged> evento ocorre depois que cada linha foi alterada. Em cada caso, o <xref:System.Data.DataRowChangeEventArgs.Action%2A> propriedade do <xref:System.Data.DataRowChangeEventArgs> instância passada para o manipulador de eventos contém informações sobre a ação específica associada ao evento. Esse valor de ação depende do estado da linha antes da operação de carregamento. Em cada caso, ambos os eventos ocorrem e a ação é a mesma para cada. A ação pode ser aplicada para a versão atual ou original de cada linha, ou ambos, dependendo do estado atual da linha.  
  
 A tabela a seguir exibe o comportamento para o `Load` método. A linha final (rotulado como "(não está presente)") descreve o comportamento de linhas de entrada que não corresponde a nenhuma linha existente. Cada célula nesta tabela descreve o valor atual e original para um campo em uma linha, juntamente com o <xref:System.Data.DataRowState> para o valor após o `Load` método for concluído. Nesse caso, o método não permite que você indique a opção de carregamento e usa o padrão, `PreserveChanges`.  
  
|DataRowState existente|Valores depois `Load` método e a ação de evento|  
|---------------------------|--------------------------------------------------|  
|Added|Atual = \<existente ><br /><br /> Original = \<entrada ><br /><br /> Estado = \<modificado ><br /><br /> RowAction = ChangeOriginal|  
|Modificado em|Atual = \<existente ><br /><br /> Original = \<entrada ><br /><br /> Estado = \<modificado ><br /><br /> RowAction = ChangeOriginal|  
|Deleted|Atual = \<não disponível ><br /><br /> Original = \<entrada ><br /><br /> Estado = \<excluído ><br /><br /> RowAction = ChangeOriginal|  
|Unchanged|Atual = \<entrada ><br /><br /> Original = \<entrada ><br /><br /> Estado = \<inalterado ><br /><br /> RowAction = ChangeCurrentAndOriginal|  
|(Não está presente)|Atual = \<entrada ><br /><br /> Original = \<entrada ><br /><br /> Estado = \<inalterado ><br /><br /> RowAction = ChangeCurrentAndOriginal|  
  
 Os valores em uma <xref:System.Data.DataColumn> pode ser restrito por meio do uso de propriedades, como <xref:System.Data.DataColumn.ReadOnly%2A> e <xref:System.Data.DataColumn.AutoIncrement%2A>. O `Load` método lida com essas colunas de uma maneira consistente com o comportamento definido pelas propriedades da coluna. A restrição de somente leitura em um <xref:System.Data.DataColumn> é aplicável somente para as alterações que ocorrem na memória. O `Load` método o substituirá os valores de coluna somente leitura, se necessário.  
  
 Para determinar qual versão do campo de chave primária a ser usado para comparar a linha atual com uma linha de entrada, o `Load` método usa a versão original do valor da chave primária em uma linha, se ele existir. Caso contrário, o `Load` método usa a versão atual do campo de chave primária.  
  
   
  
## Examples  
 O exemplo a seguir demonstra vários dos problemas envolvidos na chamada a <xref:System.Data.DataTable.Load%2A> método. Primeiro, o exemplo se concentra em problemas de esquema, inclusive inferindo um esquema a partir do <xref:System.Data.IDataReader>carregado e, em seguida, tratando esquemas incompatíveis e esquemas com colunas ausentes ou adicionais. O exemplo, em seguida, chama o `Load` método, exibindo os dados antes e após a operação de carregamento.  
  
 [!code-csharp[DataWorks DataTableLoad.IDataReader#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTableLoad.IDataReader/CS/source.cs#1)]
 [!code-vb[DataWorks DataTableLoad.IDataReader#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTableLoad.IDataReader/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public void Load (System.Data.IDataReader reader, System.Data.LoadOption loadOption);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Load(class System.Data.IDataReader reader, valuetype System.Data.LoadOption loadOption) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.Load(System.Data.IDataReader,System.Data.LoadOption)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Load(System::Data::IDataReader ^ reader, System::Data::LoadOption loadOption);" />
      <MemberSignature Language="F#" Value="member this.Load : System.Data.IDataReader * System.Data.LoadOption -&gt; unit" Usage="dataTable.Load (reader, loadOption)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Data.IDataReader" />
        <Parameter Name="loadOption" Type="System.Data.LoadOption" />
      </Parameters>
      <Docs>
        <param name="reader">Um <see cref="T:System.Data.IDataReader" /> que fornece um ou vários conjuntos de resultados.</param>
        <param name="loadOption">Um valor da enumeração <see cref="T:System.Data.LoadOption" /> que indica como as linhas que já estão no <see cref="T:System.Data.DataTable" /> são combinadas com linhas de entrada que compartilham a mesma chave primária.</param>
        <summary>Preenche um <see cref="T:System.Data.DataTable" /> com valores de uma fonte de dados usando o <see cref="T:System.Data.IDataReader" />fornecido. Se o <see langword="DataTable" /> já contiver linhas, os dados de entrada da fonte de dados serão mesclados com as linhas existentes de acordo com o valor do parâmetro <paramref name="loadOption" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O `Load` método consome o primeiro conjunto de resultados de carregado <xref:System.Data.IDataReader>e após a conclusão bem-sucedida, define a posição do leitor para o próximo conjunto de resultados, se houver. Durante a conversão de dados, o `Load` método usa as mesmas regras de conversão que o <xref:System.Data.Common.DbDataAdapter.Fill%2A> método.  
  
 O `Load` método deve levar em conta três problemas específicos ao carregar os dados de um <xref:System.Data.IDataReader> instância: operações de esquema, dados e eventos. Ao trabalhar com o esquema, o `Load` método poderá encontrar as condições conforme descrito na tabela a seguir. As operações de esquema ocorrem para todos os conjuntos de resultados importados, mesmo aqueles que contêm nenhum dado.  
  
|Condição|Comportamento|  
|---------------|--------------|  
|O <xref:System.Data.DataTable> não tiver nenhum esquema.|O `Load` método infere o esquema com base em que o conjunto de resultados de importado <xref:System.Data.IDataReader>.|  
|O <xref:System.Data.DataTable> tem um esquema, mas ele não é compatível com o esquema carregado.|O `Load` método gera uma exceção correspondente para o erro específico que ocorre durante a tentativa de carregar dados no esquema incompatível.|  
|Os esquemas são compatíveis, mas o esquema de conjunto de resultados carregado contém colunas que não existem no `DataTable`.|O `Load` método adiciona as colunas extras para `DataTable`do esquema. O método gera uma exceção se correspondente colunas no <xref:System.Data.DataTable> e o conjunto de resultados carregados não são compatíveis de valor. O método também recupera informações de restrição de conjunto de resultados de todas as colunas adicionadas. Exceto para o caso da restrição Primary Key, essas informações de restrição são usadas somente se o atual <xref:System.Data.DataTable> não contém nenhuma coluna no início da operação de carregamento.|  
|Os esquemas são compatíveis, mas o esquema de conjunto de resultados carregado contém menos colunas do que faz o `DataTable`.|Se uma coluna ausente tem um valor padrão definido ou tipo de dados da coluna é anulável, o `Load` método permite que as linhas a serem adicionados, substituindo o valor padrão ou null da coluna ausente. Se nenhum valor padrão ou null pode ser usado, em seguida, a `Load` método lançará uma exceção. Se nenhum valor padrão específico tiver sido fornecido, o `Load` método usa o valor nulo como o valor padrão implícito.|  
  
 Antes de considerar o comportamento do `Load` método em termos de operações de dados, considere a possibilidade de que cada linha dentro de um <xref:System.Data.DataTable> mantém o valor atual e o valor original para cada coluna. Esses valores podem ser equivalentes, ou pode ser diferentes se os dados na linha tem sido alterados desde o preenchimento de `DataTable`. Ver [estados de linha e versões de linha](~/docs/framework/data/adonet/dataset-datatable-dataview/row-states-and-row-versions.md) para obter mais informações.  
  
 Nessa chamada de método, especificado <xref:System.Data.LoadOption> parâmetro influencia o processamento dos dados de entrada. Como o método de carga deve tratar o carregamento de linhas que têm a mesma chave primária como linhas existentes? Ele modifica valores atuais, valores originais ou ambos? Esses problemas e muito mais, são controladas pelo `loadOption` parâmetro.  
  
 Se a linha existente e a linha de entrada contêm valores de chave primária correspondentes, a linha é processada usando seu valor de estado de linha atual, caso contrário, ele será tratado como uma nova linha.  
  
 Em termos de operações de evento, o <xref:System.Data.DataTable.RowChanging> evento ocorre antes de cada linha é alterada e o <xref:System.Data.DataTable.RowChanged> evento ocorre depois que cada linha foi alterada. Em cada caso, o <xref:System.Data.DataRowChangeEventArgs.Action%2A> propriedade do <xref:System.Data.DataRowChangeEventArgs> instância passada para o manipulador de eventos contém informações sobre a ação específica associada ao evento. Esse valor de ação varia, dependendo do estado da linha antes da operação de carregamento. Em cada caso, ambos os eventos ocorrem e a ação é a mesma para cada. A ação pode ser aplicada para a versão atual ou original de cada linha, ou ambos, dependendo do estado atual da linha.  
  
 A tabela a seguir exibe o comportamento para o método de carga quando chamado com cada um do `LoadOption` valores e também mostra como os valores interagem com o estado de linha para a linha que está sendo carregado. A linha final (rotulado como "(não está presente)") descreve o comportamento de linhas de entrada que não corresponde a nenhuma linha existente. Cada célula nesta tabela descreve o valor atual e original para um campo em uma linha, juntamente com o <xref:System.Data.DataRowState> para o valor após o `Load` método for concluído.  
  
|DataRowState existente|Upsert|OverwriteChanges|PreserveChanges (comportamento padrão)|  
|---------------------------|------------|----------------------|------------------------------------------|  
|Added|Atual = \<entrada ><br /><br /> Original = -\<não disponível ><br /><br /> Estado = \<adicionado ><br /><br /> RowAction = Change|Atual = \<entrada ><br /><br /> Original = \<entrada ><br /><br /> Estado = \<inalterado ><br /><br /> RowAction = ChangeCurrentAndOriginal|Atual = \<existente ><br /><br /> Original = \<entrada ><br /><br /> Estado = \<modificado ><br /><br /> RowAction = ChangeOriginal|  
|Modificado em|Atual = \<entrada ><br /><br /> Original = \<existente ><br /><br /> Estado = \<modificado ><br /><br /> RowAction = Change|Atual = \<entrada ><br /><br /> Original = \<entrada ><br /><br /> Estado = \<inalterado ><br /><br /> RowAction = ChangeCurrentAndOriginal|Atual = \<existente ><br /><br /> Original = \<entrada ><br /><br /> Estado = \<modificado ><br /><br /> RowAction = ChangeOriginal|  
xcluído|(Carga faz não afetam excluída linhas)<br /><br /> Atual =--<br /><br /> Original = \<existente ><br /><br /> Estado = \<excluído ><br /><br /> (Nova linha é adicionada com as seguintes características)<br /><br /> Atual = \<entrada ><br /><br /> Original = \<não disponível ><br /><br /> Estado = \<adicionado ><br /><br /> RowAction = Add|Desfazer exclusão e<br /><br /> Atual = \<entrada ><br /><br /> Original = \<entrada ><br /><br /> Estado = \<inalterado ><br /><br /> RowAction = ChangeCurrentAndOriginal|Atual = \<não disponível ><br /><br /> Original = \<entrada ><br /><br /> Estado = \<excluído ><br /><br /> RowAction = ChangeOriginal|  
|Unchanged|Atual = \<entrada ><br /><br /> Original = \<existente ><br /><br /> Se o novo valor é o mesmo que o valor existente, em seguida<br /><br /> Estado = \<inalterado ><br /><br /> RowAction = Nothing<br /><br /> Else<br /><br /> Estado = \<modificado ><br /><br /> RowAction = Change|Atual = \<entrada ><br /><br /> Original = \<entrada ><br /><br /> Estado = \<inalterado ><br /><br /> RowAction = ChangeCurrentAndOriginal|Atual = \<entrada ><br /><br /> Original = \<entrada ><br /><br /> Estado = \<inalterado ><br /><br /> RowAction = ChangeCurrentAndOriginal|  
Não está presente)|Atual = \<entrada ><br /><br /> Original = \<não disponível ><br /><br /> Estado = \<adicionado ><br /><br /> RowAction = Add|Atual = \<entrada ><br /><br /> Original = \<entrada ><br /><br /> Estado = \<inalterado ><br /><br /> RowAction = ChangeCurrentAndOriginal|Atual = \<entrada ><br /><br /> Original = \<entrada ><br /><br /> Estado = \<inalterado ><br /><br /> RowAction = ChangeCurrentAndOriginal|  
  
 Os valores em uma <xref:System.Data.DataColumn> pode ser restrito por meio do uso de propriedades, como <xref:System.Data.DataColumn.ReadOnly%2A> e <xref:System.Data.DataColumn.AutoIncrement%2A>. O `Load` método lida com essas colunas de uma maneira consistente com o comportamento definido pelas propriedades da coluna. A restrição de somente leitura em um <xref:System.Data.DataColumn> é aplicável somente para as alterações que ocorrem na memória. O `Load` método o substituirá os valores de coluna somente leitura, se necessário.  
  
 Se você especifica as opções OverwriteChanges ou PreserveChanges ao chamar o `Load` método e, em seguida, a suposição é feita de que os dados de entrada é proveniente do `DataTable`da fonte de dados primário e o DataTable controla as alterações e podem ser propagadas as alterações de volta para a fonte de dados. Se você selecionar a opção de Upsert, supõe-se que os dados estão vindo de um de uma fonte de dados secundários, como os dados fornecidos por um componente de camada intermediária, talvez alterado por um usuário. Nesse caso, a suposição é que a intenção é para agregar dados de um ou mais fontes de dados no `DataTable`e talvez se propagar os dados de volta para a fonte de dados primário. O <xref:System.Data.LoadOption> parâmetro é usado para determinar a versão específica da linha a ser usado para comparação de chave primária. A tabela a seguir fornece os detalhes.  
  
|Opção de carga|Versão do DataRow usado para comparação de chave primária|  
|-----------------|-----------------------------------------------------|  
|`OverwriteChanges`|Versão Original, caso exista, ou a versão Atual|  
|`PreserveChanges`|Versão Original, caso exista, ou a versão Atual|  
|`Upsert`|Versão atual, se ele existir, a versão Original caso contrário|  
  
   
  
## Examples  
 O exemplo a seguir demonstra vários dos problemas envolvidos na chamada a <xref:System.Data.DataTable.Load%2A> método. Primeiro, o exemplo se concentra em problemas de esquema, inclusive inferindo um esquema a partir do <xref:System.Data.IDataReader>carregado e, em seguida, tratando esquemas incompatíveis e esquemas com colunas ausentes ou adicionais. O exemplo, em seguida, se concentra em problemas de dados, incluindo a manipulação de várias opções de carregamento.  
  
 [!code-csharp[DataWorks DataTableLoad.LoadOption#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTableLoad.LoadOption/CS/source.cs#1)]
 [!code-vb[DataWorks DataTableLoad.LoadOption#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTableLoad.LoadOption/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public virtual void Load (System.Data.IDataReader reader, System.Data.LoadOption loadOption, System.Data.FillErrorEventHandler errorHandler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Load(class System.Data.IDataReader reader, valuetype System.Data.LoadOption loadOption, class System.Data.FillErrorEventHandler errorHandler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.Load(System.Data.IDataReader,System.Data.LoadOption,System.Data.FillErrorEventHandler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Load(System::Data::IDataReader ^ reader, System::Data::LoadOption loadOption, System::Data::FillErrorEventHandler ^ errorHandler);" />
      <MemberSignature Language="F#" Value="abstract member Load : System.Data.IDataReader * System.Data.LoadOption * System.Data.FillErrorEventHandler -&gt; unit&#xA;override this.Load : System.Data.IDataReader * System.Data.LoadOption * System.Data.FillErrorEventHandler -&gt; unit" Usage="dataTable.Load (reader, loadOption, errorHandler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Data.IDataReader" />
        <Parameter Name="loadOption" Type="System.Data.LoadOption" />
        <Parameter Name="errorHandler" Type="System.Data.FillErrorEventHandler" />
      </Parameters>
      <Docs>
        <param name="reader">Um <see cref="T:System.Data.IDataReader" /> que fornece um conjunto de resultados.</param>
        <param name="loadOption">Um valor da enumeração <see cref="T:System.Data.LoadOption" /> que indica como as linhas que já estão no <see cref="T:System.Data.DataTable" /> são combinadas com linhas de entrada que compartilham a mesma chave primária.</param>
        <param name="errorHandler">Um delegado <see cref="T:System.Data.FillErrorEventHandler" /> a ser chamado quando ocorrer um erro ao carregar os dados.</param>
        <summary>Preenche um <see cref="T:System.Data.DataTable" /> com valores de uma fonte de dados usando o <see cref="T:System.Data.IDataReader" /> fornecido comum delegado de tratamento de erro.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O `Load` método consome o primeiro conjunto de resultados de carregado <xref:System.Data.IDataReader>e após a conclusão bem-sucedida, define a posição do leitor para o próximo conjunto de resultados, se houver. Durante a conversão de dados, o `Load` método usa as mesmas regras de conversão que o <xref:System.Data.Common.DbDataAdapter.Fill%2A?displayProperty=nameWithType> método.  
  
 O `Load` método deve levar em conta três problemas específicos ao carregar os dados de um <xref:System.Data.IDataReader> instância: operações de esquema, dados e eventos. Ao trabalhar com o esquema, o `Load` método poderá encontrar as condições conforme descrito na tabela a seguir. As operações de esquema ocorrem para todos os conjuntos de resultados importados, mesmo aqueles que contêm nenhum dado.  
  
|Condição|Comportamento|  
|---------------|--------------|  
|O <xref:System.Data.DataTable> não tiver nenhum esquema.|O `Load` método infere o esquema com base em que o conjunto de resultados de importado <xref:System.Data.IDataReader>.|  
|O <xref:System.Data.DataTable> tem um esquema, mas ele não é compatível com o esquema carregado.|O `Load` método gera uma exceção correspondente para o erro específico que ocorre durante a tentativa de carregar dados no esquema incompatível.|  
|Os esquemas são compatíveis, mas o esquema de conjunto de resultados carregado contém colunas que não existem no `DataTable`.|O `Load` método adiciona colunas extras para `DataTable`do esquema. O método gera uma exceção se correspondente colunas no <xref:System.Data.DataTable> e o conjunto de resultados carregados não são compatíveis de valor. O método também recupera informações de restrição de conjunto de resultados de todas as colunas adicionadas. Exceto para o caso da restrição Primary Key, essas informações de restrição são usadas somente se o atual <xref:System.Data.DataTable> não contém nenhuma coluna no início da operação de carregamento.|  
|Os esquemas são compatíveis, mas o esquema de conjunto de resultados carregado contém menos colunas do que faz o `DataTable`.|Se uma coluna ausente tem um valor padrão definido ou tipo de dados da coluna é anulável, o `Load` método permite que as linhas a serem adicionados, substituindo o valor padrão ou null da coluna ausente. Se nenhum valor padrão ou null pode ser usado, em seguida, a `Load` método lançará uma exceção. Se nenhum valor padrão específico tiver sido fornecido, o `Load` método usa o valor nulo como o valor padrão implícito.|  
  
 Antes de considerar o comportamento do `Load` método em termos de operações de dados, considere a possibilidade de que cada linha dentro de um <xref:System.Data.DataTable> mantém o valor atual e o valor original para cada coluna. Esses valores podem ser equivalentes, ou pode ser diferentes se os dados na linha tem sido alterados desde o preenchimento de `DataTable`. Ver [estados de linha e versões de linha](~/docs/framework/data/adonet/dataset-datatable-dataview/row-states-and-row-versions.md) para obter mais informações.  
  
 Nessa chamada de método, especificado <xref:System.Data.LoadOption> parâmetro influencia o processamento dos dados de entrada. Como o método de carga deve tratar o carregamento de linhas que têm a mesma chave primária como linhas existentes? Ele modifica valores atuais, valores originais ou ambos? Esses problemas e muito mais, são controladas pelo `loadOption` parâmetro.  
  
 Se a linha existente e a linha de entrada contêm valores de chave primária correspondentes, a linha é processada usando seu valor de estado de linha atual, caso contrário, ele será tratado como uma nova linha.  
  
 Em termos de operações de evento, o <xref:System.Data.DataTable.RowChanging> evento ocorre antes de cada linha é alterada e o <xref:System.Data.DataTable.RowChanged> evento ocorre depois que cada linha foi alterada. Em cada caso, o <xref:System.Data.DataRowChangeEventArgs.Action%2A> propriedade do <xref:System.Data.DataRowChangeEventArgs> instância passada para o manipulador de eventos contém informações sobre a ação específica associada ao evento. Esse valor de ação varia, dependendo do estado da linha antes da operação de carregamento. Em cada caso, ambos os eventos ocorrem e a ação é a mesma para cada. A ação pode ser aplicada para a versão atual ou original de cada linha, ou ambos, dependendo do estado atual da linha.  
  
 A tabela a seguir exibe o comportamento para o método de carga quando chamado com cada um do `LoadOption` valores e também mostra como os valores interagem com o estado de linha para a linha que está sendo carregado. A linha final (rotulado como "(não está presente)") descreve o comportamento de linhas de entrada que não corresponde a nenhuma linha existente. Cada célula nesta tabela descreve o valor atual e original para um campo em uma linha, juntamente com o <xref:System.Data.DataRowState> para o valor após o `Load` método for concluído.  
  
|DataRowState existente|Upsert|OverwriteChanges|PreserveChanges (comportamento padrão)|  
|---------------------------|------------|----------------------|------------------------------------------|  
|Added|Atual = \<entrada ><br /><br /> Original = -\<não disponível ><br /><br /> Estado = \<adicionado ><br /><br /> RowAction = Change|Atual = \<entrada ><br /><br /> Original = \<entrada ><br /><br /> Estado = \<inalterado ><br /><br /> RowAction = ChangeCurrentAndOriginal|Atual = \<existente ><br /><br /> Original = \<entrada ><br /><br /> Estado = \<modificado ><br /><br /> RowAction = ChangeOriginal|  
|Modificado em|Atual = \<entrada ><br /><br /> Original = \<existente ><br /><br /> Estado = \<modificado ><br /><br /> RowAction = Change|Atual = \<entrada ><br /><br /> Original = \<entrada ><br /><br /> Estado = \<inalterado ><br /><br /> RowAction = ChangeCurrentAndOriginal|Atual = \<existente ><br /><br /> Original = \<entrada ><br /><br /> Estado = \<modificado ><br /><br /> RowAction = ChangeOriginal|  
xcluído|(Carga faz não afetam excluída linhas)<br /><br /> Atual =--<br /><br /> Original = \<existente ><br /><br /> Estado = \<excluído ><br /><br /> (Nova linha é adicionada com as seguintes características)<br /><br /> Atual = \<entrada ><br /><br /> Original = \<não disponível ><br /><br /> Estado = \<adicionado ><br /><br /> RowAction = Add|Desfazer exclusão e<br /><br /> Atual = \<entrada ><br /><br /> Original = \<entrada ><br /><br /> Estado = \<inalterado ><br /><br /> RowAction = ChangeCurrentAndOriginal|Atual = \<não disponível ><br /><br /> Original = \<entrada ><br /><br /> Estado = \<excluído ><br /><br /> RowAction = ChangeOriginal|  
|Unchanged|Atual = \<entrada ><br /><br /> Original = \<existente ><br /><br /> Se o novo valor é o mesmo que o valor existente, em seguida<br /><br /> Estado = \<inalterado ><br /><br /> RowAction = Nothing<br /><br /> Else<br /><br /> Estado = \<modificado ><br /><br /> RowAction = Change|Atual = \<entrada ><br /><br /> Original = \<entrada ><br /><br /> Estado = \<inalterado ><br /><br /> RowAction = ChangeCurrentAndOriginal|Atual = \<entrada ><br /><br /> Original = \<entrada ><br /><br /> Estado = \<inalterado ><br /><br /> RowAction = ChangeCurrentAndOriginal|  
Não está presente)|Atual = \<entrada ><br /><br /> Original = \<não disponível ><br /><br /> Estado = \<adicionado ><br /><br /> RowAction = Add|Atual = \<entrada ><br /><br /> Original = \<entrada ><br /><br /> Estado = \<inalterado ><br /><br /> RowAction = ChangeCurrentAndOriginal|Atual = \<entrada ><br /><br /> Original = \<entrada ><br /><br /> Estado = \<inalterado ><br /><br /> RowAction = ChangeCurrentAndOriginal|  
  
 Os valores em uma <xref:System.Data.DataColumn> pode ser restrito por meio do uso de propriedades, como <xref:System.Data.DataColumn.ReadOnly%2A> e <xref:System.Data.DataColumn.AutoIncrement%2A>. O `Load` método lida com essas colunas de uma maneira consistente com o comportamento definido pelas propriedades da coluna. A restrição de somente leitura em um <xref:System.Data.DataColumn> é aplicável somente para as alterações que ocorrem na memória. O `Load` método o substituirá os valores de coluna somente leitura, se necessário.  
  
 Se você especifica as opções OverwriteChanges ou PreserveChanges ao chamar o `Load` método e, em seguida, a suposição é feita de que os dados de entrada é proveniente do `DataTable`da fonte de dados primário e o DataTable controla as alterações e podem ser propagadas as alterações de volta para a fonte de dados. Se você selecionar a opção de Upsert, supõe-se que os dados estão vindo de um de uma fonte de dados secundários, como os dados fornecidos por um componente de camada intermediária, talvez alterado por um usuário. Nesse caso, a suposição é que a intenção é para agregar dados de um ou mais fontes de dados no `DataTable`e talvez se propagar os dados de volta para a fonte de dados primário. O <xref:System.Data.LoadOption> parâmetro é usado para determinar a versão específica da linha a ser usado para comparação de chave primária. A tabela a seguir fornece os detalhes.  
  
|Opção de carga|Versão do DataRow usado para comparação de chave primária|  
|-----------------|-----------------------------------------------------|  
|`OverwriteChanges`|Versão Original, caso exista, ou a versão Atual|  
|`PreserveChanges`|Versão Original, caso exista, ou a versão Atual|  
|`Upsert`|Versão atual, se ele existir, a versão Original caso contrário|  
  
 O `errorHandler` parâmetro é um <xref:System.Data.FillErrorEventHandler> delegado que se refere a um procedimento que é chamado quando ocorre um erro ao carregar dados. O <xref:System.Data.FillErrorEventArgs> parâmetro passado ao procedimento fornece as propriedades que permitem que você recupere informações sobre o erro ocorreu, a linha atual de dados, e o <xref:System.Data.DataTable> sendo preenchido. Usando esse mecanismo de delegado, em vez de um bloco try/catch mais simples, permite que você determine o erro, lidar com a situação e continuar processando se desejar. O <xref:System.Data.FillErrorEventArgs> parâmetro fornece um <xref:System.Data.FillErrorEventArgs.Continue%2A> propriedade: defina essa propriedade como `true` para indicar que você tratou o erro e deseja continuar o processamento. Defina a propriedade como `false` para indicar que você deseja interromper o processamento. Lembre-se que definir a propriedade como `false` faz com que o código que disparou o problema para lançar uma exceção.  
  
   
  
## Examples  
 [!code-csharp[DataWorks DataTableLoad.ErrorEventHandler#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTableLoad.ErrorEventHandler/CS/source.cs#1)]
 [!code-vb[DataWorks DataTableLoad.ErrorEventHandler#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTableLoad.ErrorEventHandler/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="LoadDataRow">
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Localiza e atualiza uma linha específica. Se nenhuma linha correspondente for encontrada, uma nova linha será criada usando os valores fornecidos.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="LoadDataRow">
      <MemberSignature Language="C#" Value="public System.Data.DataRow LoadDataRow (object[] values, bool fAcceptChanges);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.DataRow LoadDataRow(object[] values, bool fAcceptChanges) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.LoadDataRow(System.Object[],System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function LoadDataRow (values As Object(), fAcceptChanges As Boolean) As DataRow" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::DataRow ^ LoadDataRow(cli::array &lt;System::Object ^&gt; ^ values, bool fAcceptChanges);" />
      <MemberSignature Language="F#" Value="member this.LoadDataRow : obj[] * bool -&gt; System.Data.DataRow" Usage="dataTable.LoadDataRow (values, fAcceptChanges)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataRow</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="values" Type="System.Object[]" />
        <Parameter Name="fAcceptChanges" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="values">Uma matriz de valores usados para criar a nova linha.</param>
        <param name="fAcceptChanges">
          <see langword="true" /> para aceitar alterações; caso contrário, <see langword="false" />.</param>
        <summary>Localiza e atualiza uma linha específica. Se nenhuma linha correspondente for encontrada, uma nova linha será criada usando os valores fornecidos.</summary>
        <returns>O novo <see cref="T:System.Data.DataRow" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Data.DataTable.LoadDataRow%2A> método usa uma matriz de valores e localiza os valores correspondentes das colunas de chave primária.  
  
 Se uma coluna tiver um valor padrão, passe um valor nulo na matriz para definir o valor padrão para essa coluna. Da mesma forma, se uma coluna tiver seu <xref:System.Data.DataColumn.AutoIncrement%2A> propriedade definida como true, passar um valor nulo na matriz para definir o valor gerado automaticamente para a linha.  
  
 Se o `fAcceptChanges` parâmetro é `true` ou não especificado, os novos dados são adicionados e, em seguida <xref:System.Data.DataTable.AcceptChanges%2A> é chamado para aceitar todas as alterações no <xref:System.Data.DataTable>; se o argumento for `false`, recentemente adicionado as linhas são marcadas como inserções e as alterações as linhas existentes são marcadas como modificações.  
  
 Exceções também podem ocorrer durante a um <xref:System.Data.DataTable.ColumnChanging> ou <xref:System.Data.DataTable.RowChanging> eventos. Se ocorrer uma exceção, a linha não será adicionada à tabela.  
  
 Use <xref:System.Data.DataTable.LoadDataRow%2A> em conjunto com <xref:System.Data.DataTable.BeginLoadData%2A> e <xref:System.Data.DataTable.EndLoadData%2A>.  
  
   
  
## Examples  
 O exemplo a seguir usa o <xref:System.Data.DataTable.LoadDataRow%2A> método para tentar encontrar uma linha. Se nenhuma linha for encontrada, os valores são usados para criar uma nova linha.  
  
 [!code-csharp[Classic WebData DataTable.LoadDataRow Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.LoadDataRow Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.LoadDataRow Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.LoadDataRow Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">A matriz é maior que o número de colunas na tabela.</exception>
        <exception cref="T:System.InvalidCastException">Um valor não corresponde a seu respectivo tipo de coluna.</exception>
        <exception cref="T:System.Data.ConstraintException">Adicionar a linha invalida uma restrição.</exception>
        <exception cref="T:System.Data.NoNullAllowedException">Tentativa de colocar um valor nulo em uma coluna em que <see cref="P:System.Data.DataColumn.AllowDBNull" /> é falso.</exception>
      </Docs>
    </Member>
    <Member MemberName="LoadDataRow">
      <MemberSignature Language="C#" Value="public System.Data.DataRow LoadDataRow (object[] values, System.Data.LoadOption loadOption);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.DataRow LoadDataRow(object[] values, valuetype System.Data.LoadOption loadOption) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.LoadDataRow(System.Object[],System.Data.LoadOption)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::DataRow ^ LoadDataRow(cli::array &lt;System::Object ^&gt; ^ values, System::Data::LoadOption loadOption);" />
      <MemberSignature Language="F#" Value="member this.LoadDataRow : obj[] * System.Data.LoadOption -&gt; System.Data.DataRow" Usage="dataTable.LoadDataRow (values, loadOption)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataRow</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="values" Type="System.Object[]" />
        <Parameter Name="loadOption" Type="System.Data.LoadOption" />
      </Parameters>
      <Docs>
        <param name="values">Uma matriz de valores usados para criar a nova linha.</param>
        <param name="loadOption">Usado para determinar como os valores da matriz são aplicados aos valores correspondentes em uma linha existente.</param>
        <summary>Localiza e atualiza uma linha específica. Se nenhuma linha correspondente for encontrada, uma nova linha será criada usando os valores fornecidos.</summary>
        <returns>O novo <see cref="T:System.Data.DataRow" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Data.DataTable.LoadDataRow%2A> método usa uma matriz de valores e localiza os valores correspondentes das colunas de chave primária.  
  
 Se uma coluna tiver um valor padrão, passe um valor nulo na matriz para definir o valor padrão para essa coluna. Da mesma forma, se uma coluna tiver seu <xref:System.Data.DataColumn.AutoIncrement%2A> propriedade definida como true, passar um valor nulo na matriz para definir o valor gerado automaticamente para a linha.  
  
 O valor da `loadOption` parâmetro é usado para determinar como os valores na matriz são aplicados a uma linha existente. Por exemplo, se `loadOption` é definido como `OverwriteChanges`, o `Original` e `Current` valores de cada coluna são substituídos pelos valores na linha de entrada e o `RowState` estiver definida como `Unchanged`.  
  
 Exceções também podem ocorrer durante a um <xref:System.Data.DataTable.ColumnChanging> ou <xref:System.Data.DataTable.RowChanging> eventos. Se ocorrer uma exceção, a linha não será adicionada à tabela.  
  
 Use <xref:System.Data.DataTable.LoadDataRow%2A> em conjunto com <xref:System.Data.DataTable.BeginLoadData%2A> e <xref:System.Data.DataTable.EndLoadData%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Locale">
      <MemberSignature Language="C#" Value="public System.Globalization.CultureInfo Locale { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Globalization.CultureInfo Locale" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataTable.Locale" />
      <MemberSignature Language="VB.NET" Value="Public Property Locale As CultureInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Globalization::CultureInfo ^ Locale { System::Globalization::CultureInfo ^ get(); void set(System::Globalization::CultureInfo ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Locale : System.Globalization.CultureInfo with get, set" Usage="System.Data.DataTable.Locale" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.Data.DataSysDescription("DataTableLocaleDescr")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Globalization.CultureInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define as informações de localidade usadas para comparar cadeias de caracteres na tabela.</summary>
        <value>Um <see cref="T:System.Globalization.CultureInfo" /> que contém dados sobre a localidade do computador do usuário. O padrão é o <see cref="T:System.Globalization.CultureInfo" /> do objeto <see cref="T:System.Data.DataSet" /> (retornado pela propriedade <see cref="P:System.Data.DataSet.Locale" />) ao qual pertence o <see cref="T:System.Data.DataTable" />; se a tabela não pertencer a um <see cref="T:System.Data.DataSet" />, o padrão será o atual sistema <see cref="T:System.Globalization.CultureInfo" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Um <xref:System.Globalization.CultureInfo> representa as preferências de software de uma cultura específica ou a comunidade.  
  
 Quando usado para comparações de cadeia de caracteres, o <xref:System.Globalization.CultureInfo> afeta a classificação, comparações e filtragem.  
  
> [!NOTE]
>  Nas colunas que contêm expressões, o <xref:System.StringComparison.InvariantCulture> é usado. O <xref:System.StringComparison.CurrentCulture> será ignorado.  
  
   
  
## Examples  
 O exemplo a seguir define o <xref:System.Globalization.CultureInfo> por meio de <xref:System.Data.DataTable.Locale%2A> e imprime o nome de idioma ISO.  
  
 [!code-csharp[Classic WebData DataTable.Locale Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.Locale Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.Locale Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.Locale Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Globalization.CultureInfo" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Merge">
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Mesclar o <see cref="T:System.Data.DataTable" /> especificado ao <see cref="T:System.Data.DataTable" /> atual.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O método `Merge` é usado para mesclar dois objetos <xref:System.Data.DataTable> que têm esquemas amplamente semelhantes. Uma mesclagem é normalmente usada em um aplicativo cliente incorporar as alterações mais recentes feitas em uma fonte de dados a um <xref:System.Data.DataTable>existente. Isso permite que o aplicativo cliente tenha um <xref:System.Data.DataTable> atualizado com os dados mais recentes a partir da fonte de dados.  
  
 A operação de mesclagem leva em conta apenas a tabela original, e a tabela a ser mesclada. As tabelas filho não são afetadas ou incluídas. Se uma tabela tiver uma ou mais tabelas filho, definidas como parte de uma relação, cada tabela filho deverá ser mesclada individualmente.  
  
   
  
## Examples  
 O aplicativo de console a seguir demonstra o comportamento do `missingSchemaAction` parâmetro do <xref:System.Data.DataTable.Merge%2A> método. Este exemplo cria duas versões da mesma tabela, a modificação do esquema para a segunda versão. O código, em seguida, tenta mesclar a segunda tabela primeiro.  
  
> [!NOTE]
>  Este exemplo mostra como usar uma das versões sobrecarregadas de mesclagem. Para obter outros exemplos que possam estar disponíveis, consulte os tópicos de sobrecarga individuais.  
  
 [!code-csharp[DataWorks DataTableMergeOverload#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTableMergeOverload/CS/source.cs#1)]
 [!code-vb[DataWorks DataTableMergeOverload#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTableMergeOverload/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Merge">
      <MemberSignature Language="C#" Value="public void Merge (System.Data.DataTable table);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Merge(class System.Data.DataTable table) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.Merge(System.Data.DataTable)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Merge (table As DataTable)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Merge(System::Data::DataTable ^ table);" />
      <MemberSignature Language="F#" Value="member this.Merge : System.Data.DataTable -&gt; unit" Usage="dataTable.Merge table" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="table" Type="System.Data.DataTable" />
      </Parameters>
      <Docs>
        <param name="table">O <see cref="T:System.Data.DataTable" /> a ser mesclado com o <see cref="T:System.Data.DataTable" /> atual.</param>
        <summary>Mesclar o <see cref="T:System.Data.DataTable" /> especificado ao <see cref="T:System.Data.DataTable" /> atual.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O método Merge é usado para mesclar dois <xref:System.Data.DataTable> objetos que têm esquemas amplamente semelhantes. Uma mesclagem é normalmente usada em um aplicativo cliente incorporar as alterações mais recentes feitas em uma fonte de dados a um <xref:System.Data.DataTable>existente. Isso permite que o aplicativo cliente tenha um <xref:System.Data.DataTable> atualizado com os dados mais recentes a partir da fonte de dados.  
  
 A operação de mesclagem leva em conta apenas a tabela original, e a tabela a ser mesclada. As tabelas filho não são afetadas ou incluídas. Se uma tabela tiver uma ou mais tabelas filho, definidas como parte de uma relação, cada tabela filho deverá ser mesclada individualmente.  
  
 O método `Merge` é chamado geralmente ao final de uma série de procedimentos que envolvem a validação de alterações, a reconciliação de erros, a atualização da fonte de dados com as alterações e, por fim, a atualização do <xref:System.Data.DataTable>existente.  
  
 Ao executar uma mesclagem, as alterações feitas aos dados existentes antes da mesclagem são preservadas por padrão durante a operação de mesclagem. Os desenvolvedores podem modificar esse comportamento chamando uma das duas sobrecargas desse método e especificando um valor false para o `preserveChanges` parâmetro.  
  
 Em um aplicativo cliente, é comum ter um único botão que o usuário pode clicar que reúne os dados alterados e os valida antes de enviar de volta para um componente de camada intermediária. Nesse cenário, o método <xref:System.Data.DataTable.GetChanges%2A> é invocado primeiro. O método retorna um segundo <xref:System.Data.DataTable> otimizado para validação e mesclagem. Este segundo <xref:System.Data.DataTable> objeto contém apenas o <xref:System.Data.DataRow> objetos que foram modificados, resultando em um subconjunto do original <xref:System.Data.DataTable>. Esse subconjunto é geralmente menor e, portanto, com mais eficiência passado para um componente de camada intermediária. O componente de camada intermediária, em seguida, atualiza a fonte de dados original com as alterações por meio de procedimentos armazenados. A camada intermediária pode enviar novamente em qualquer um novo <xref:System.Data.DataTable> que inclui dados originais e os dados mais recentes da fonte de dados (executando a consulta original novamente), ou pode enviar novamente o subconjunto com eventuais alterações feitas a partir da fonte de dados. (Por exemplo, se a fonte de dados cria automaticamente valores de chave primária exclusivos, esses valores podem ser propagados de volta para o aplicativo cliente.) Em ambos os casos, o <xref:System.Data.DataTable> retornado pode ser mesclado de volta ao <xref:System.Data.DataTable> original do aplicativo cliente com o método <xref:System.Data.DataTable.Merge%2A>.  
  
 Ao mesclar uma nova fonte <xref:System.Data.DataTable> no destino, qualquer linha de origem com um <xref:System.Data.DataRowState> valor de `Unchanged`, `Modified`, ou `Deleted`, corresponde às linhas de destino com os mesmos valores de chave primária. As linhas de origem com um valor de <xref:System.Data.DataRowState> de `Added` correspondem às novas linhas de destino com os mesmos valores de chave primária das novas linhas de origem.  
  
   
  
## Examples  
 O aplicativo de console a seguir cria um simples <xref:System.Data.DataTable> e adiciona dados à tabela. O exemplo cria uma cópia da tabela, adicionando linhas para a cópia. Por fim, o exemplo chama o <xref:System.Data.DataTable.Merge%2A> método para mesclar os dados na segunda tabela com os dados na primeira tabela.  
  
 [!code-csharp[DataWorks DataTable.Merge#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTable.Merge/CS/source.cs#1)]
 [!code-vb[DataWorks DataTable.Merge#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTable.Merge/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Merge">
      <MemberSignature Language="C#" Value="public void Merge (System.Data.DataTable table, bool preserveChanges);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Merge(class System.Data.DataTable table, bool preserveChanges) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.Merge(System.Data.DataTable,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Merge (table As DataTable, preserveChanges As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Merge(System::Data::DataTable ^ table, bool preserveChanges);" />
      <MemberSignature Language="F#" Value="member this.Merge : System.Data.DataTable * bool -&gt; unit" Usage="dataTable.Merge (table, preserveChanges)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="table" Type="System.Data.DataTable" />
        <Parameter Name="preserveChanges" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="table">O <see langword="DataTable" /> a ser mesclado com o <see langword="DataTable" /> atual.</param>
        <param name="preserveChanges">
          <see langword="true" />, para preservar alterações no <see langword="DataTable" /> atual; caso contrário, <see langword="false" />.</param>
        <summary>Mescla o <see cref="T:System.Data.DataTable" /> especificado com o <see langword="DataTable" /> atual, indicando se as alterações no <see langword="DataTable" /> atual devem ser preservadas.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O método Merge é usado para mesclar dois <xref:System.Data.DataTable> objetos que têm esquemas amplamente semelhantes. Uma mesclagem é normalmente usada em um aplicativo cliente incorporar as alterações mais recentes feitas em uma fonte de dados a um <xref:System.Data.DataTable>existente. Isso permite que o aplicativo cliente tenha um <xref:System.Data.DataTable> atualizado com os dados mais recentes a partir da fonte de dados.  
  
 A operação de mesclagem leva em conta apenas a tabela original, e a tabela a ser mesclada. As tabelas filho não são afetadas ou incluídas. Se uma tabela tiver uma ou mais tabelas filho, definidas como parte de uma relação, cada tabela filho deverá ser mesclada individualmente.  
  
 O método `Merge` é chamado geralmente ao final de uma série de procedimentos que envolvem a validação de alterações, a reconciliação de erros, a atualização da fonte de dados com as alterações e, por fim, a atualização do <xref:System.Data.DataTable>existente.  
  
 Ao executar uma mesclagem, as alterações feitas aos dados existentes antes da mesclagem são preservadas durante a operação de mesclagem, a menos que o desenvolvedor especifique false para o `preserveChanges` parâmetro. Se o `preserveChanges` parâmetro é definido como `true`, valores de entrada não substituirão os valores existentes na versão de linha atual da linha existente. Se o `preserveChanges` parâmetro é definido como `false`, valores de entrada substituirão os valores existentes na versão de linha atual da linha existente. Para obter mais informações sobre as versões de linha, consulte [estados de linha e versões de linha](~/docs/framework/data/adonet/dataset-datatable-dataview/row-states-and-row-versions.md).  
  
 Em um aplicativo cliente, é comum ter um único botão que o usuário pode clicar que reúne os dados alterados e os valida antes de enviar de volta para um componente de camada intermediária. Nesse cenário, o método <xref:System.Data.DataTable.GetChanges%2A> é invocado primeiro. O método retorna um segundo <xref:System.Data.DataTable> otimizado para validação e mesclagem. Este segundo objeto <xref:System.Data.DataTable> contém apenas os objetos <xref:System.Data.DataTable> e <xref:System.Data.DataRow> que foram modificados, resultando em um subconjunto do <xref:System.Data.DataTable> original. Esse subconjunto é geralmente menor e, portanto, esse subconjunto é passado com mais eficiência de volta para um componente de camada intermediária. O componente de camada intermediária, em seguida, atualiza a fonte de dados original com as alterações por meio de procedimentos armazenados. A camada intermediária pode enviar novamente em qualquer um novo <xref:System.Data.DataTable> que inclui dados originais e os dados mais recentes da fonte de dados (executando a consulta original novamente), ou pode enviar novamente o subconjunto com eventuais alterações feitas a partir da fonte de dados. (Por exemplo, se a fonte de dados cria automaticamente valores de chave primária exclusivos, esses valores podem ser propagados de volta para o aplicativo cliente.) Em ambos os casos, o <xref:System.Data.DataTable> retornado pode ser mesclado de volta ao <xref:System.Data.DataTable> original do aplicativo cliente com o método <xref:System.Data.DataTable.Merge%2A>.  
  
 Durante a mesclagem de uma nova fonte <xref:System.Data.DataTable> no destino, qualquer linha de origem com um valor <xref:System.Data.DataRowState> de `Unchanged`, `Modified` ou `Deleted` são correspondidos para selecionar linhas com os mesmos valores de chave primária. As linhas de origem com um valor de <xref:System.Data.DataRowState> de `Added` correspondem às novas linhas de destino com os mesmos valores de chave primária das novas linhas de origem.  
  
   
  
## Examples  
 O aplicativo de console a seguir cria uma <xref:System.Data.DataTable> contendo linhas, modifica alguns dos dados nessas linhas e tenta mesclar dados de outro <xref:System.Data.DataTable>. O exemplo demonstra os comportamentos diferentes para o `preserveChanges` parâmetro.  
  
 [!code-csharp[DataWorks DataTable.MergePreserveChanges#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTable.MergePreserveChanges/CS/source.cs#1)]
 [!code-vb[DataWorks DataTable.MergePreserveChanges#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTable.MergePreserveChanges/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Merge">
      <MemberSignature Language="C#" Value="public void Merge (System.Data.DataTable table, bool preserveChanges, System.Data.MissingSchemaAction missingSchemaAction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Merge(class System.Data.DataTable table, bool preserveChanges, valuetype System.Data.MissingSchemaAction missingSchemaAction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.Merge(System.Data.DataTable,System.Boolean,System.Data.MissingSchemaAction)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Merge(System::Data::DataTable ^ table, bool preserveChanges, System::Data::MissingSchemaAction missingSchemaAction);" />
      <MemberSignature Language="F#" Value="member this.Merge : System.Data.DataTable * bool * System.Data.MissingSchemaAction -&gt; unit" Usage="dataTable.Merge (table, preserveChanges, missingSchemaAction)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="table" Type="System.Data.DataTable" />
        <Parameter Name="preserveChanges" Type="System.Boolean" />
        <Parameter Name="missingSchemaAction" Type="System.Data.MissingSchemaAction" />
      </Parameters>
      <Docs>
        <param name="table">O <see cref="T:System.Data.DataTable" /> a ser mesclado com o <see cref="T:System.Data.DataTable" /> atual.</param>
        <param name="preserveChanges">
          <see langword="true" />, para preservar alterações no <see cref="T:System.Data.DataTable" /> atual; caso contrário, <see langword="false" />.</param>
        <param name="missingSchemaAction">Um dos valores de <see cref="T:System.Data.MissingSchemaAction" />.</param>
        <summary>Mescla o <see cref="T:System.Data.DataTable" /> especificado com o <see langword="DataTable" /> atual, indicando se as alterações e a maneira como manipular o esquema ausente no <see langword="DataTable" /> atual devem ser preservadas.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O método `Merge` é usado para mesclar dois objetos <xref:System.Data.DataTable> que têm esquemas amplamente semelhantes. Uma mesclagem é normalmente usada em um aplicativo cliente incorporar as alterações mais recentes feitas em uma fonte de dados a um <xref:System.Data.DataTable>existente. Isso permite que o aplicativo cliente tenha um <xref:System.Data.DataTable> atualizado com os dados mais recentes a partir da fonte de dados.  
  
 A operação de mesclagem leva em conta apenas a tabela original, e a tabela a ser mesclada. As tabelas filho não são afetadas ou incluídas. Se uma tabela tiver uma ou mais tabelas filho, definidas como parte de uma relação, cada tabela filho deverá ser mesclada individualmente.  
  
 O método `Merge` é chamado geralmente ao final de uma série de procedimentos que envolvem a validação de alterações, a reconciliação de erros, a atualização da fonte de dados com as alterações e, por fim, a atualização do <xref:System.Data.DataTable>existente.  
  
 Ao executar uma mesclagem, as alterações feitas aos dados existentes antes da mesclagem são preservadas durante a operação de mesclagem, a menos que o desenvolvedor especifique false para o `preserveChanges` parâmetro. Se o `preserveChanges` parâmetro é definido como `true`, valores de entrada não substituirão os valores existentes na versão de linha atual da linha existente. Se o `preserveChanges` parâmetro é definido como `false`, valores de entrada substituirão os valores existentes na versão de linha atual da linha existente. Para obter mais informações sobre as versões de linha, consulte [estados de linha e versões de linha](~/docs/framework/data/adonet/dataset-datatable-dataview/row-states-and-row-versions.md).  
  
 Em um aplicativo cliente, é comum ter um único botão que o usuário pode clicar que reúne os dados alterados e os valida antes de enviar de volta para um componente de camada intermediária. Nesse cenário, o método <xref:System.Data.DataTable.GetChanges%2A> é invocado primeiro. O método retorna um segundo <xref:System.Data.DataTable> otimizado para validação e mesclagem. Este segundo objeto <xref:System.Data.DataTable> contém apenas os objetos <xref:System.Data.DataTable> e <xref:System.Data.DataRow> que foram modificados, resultando em um subconjunto do <xref:System.Data.DataTable> original. Esse subconjunto é geralmente menor e, portanto, esse subconjunto é passado com mais eficiência de volta para um componente de camada intermediária. O componente de camada intermediária, em seguida, atualiza a fonte de dados original com as alterações por meio de procedimentos armazenados. A camada intermediária pode enviar novamente em qualquer um novo <xref:System.Data.DataTable> que inclui dados originais e os dados mais recentes da fonte de dados (executando a consulta original novamente), ou pode enviar novamente o subconjunto com eventuais alterações feitas a partir da fonte de dados. (Por exemplo, se a fonte de dados cria automaticamente valores de chave primária exclusivos, esses valores podem ser propagados de volta para o aplicativo cliente.) Em ambos os casos, o <xref:System.Data.DataTable> retornado pode ser mesclado de volta ao <xref:System.Data.DataTable> original do aplicativo cliente com o método <xref:System.Data.DataTable.Merge%2A>.  
  
 Quando o <xref:System.Data.DataTable.Merge%2A> método é chamado, os esquemas dos dois <xref:System.Data.DataTable> objetos são comparados, porque é possível que os esquemas podem ter sido alterados. Por exemplo, em um cenário entre empresas, novas colunas podem ter sido adicionadas a um esquema XML por um processo automatizado. Se a fonte <xref:System.Data.DataTable> contiver elementos do esquema (objetos <xref:System.Data.DataColumn> adicionados) que estão faltando no destino, os elementos do esquema poderão ser adicionados ao destino definindo o argumento `missingSchemaAction` como `MissingSchemaAction.Add`. Nesse caso, o <xref:System.Data.DataTable> mesclado contém o esquema e os dados adicionados.  
  
 Após a mesclagem de esquemas, os dados são mesclados.  
  
 Durante a mesclagem de uma nova fonte <xref:System.Data.DataTable> no destino, qualquer linha de origem com um valor <xref:System.Data.DataRowState> de `Unchanged`, `Modified` ou `Deleted` são correspondidos para selecionar linhas com os mesmos valores de chave primária. As linhas de origem com um valor de <xref:System.Data.DataRowState> de `Added` correspondem às novas linhas de destino com os mesmos valores de chave primária das novas linhas de origem.  
  
   
  
## Examples  
 O aplicativo de console a seguir demonstra o comportamento do `missingSchemaAction` parâmetro do <xref:System.Data.DataTable.Merge%2A> método. Este exemplo cria duas versões da mesma tabela, a modificação do esquema para a segunda versão. O código, em seguida, tenta mesclar a segunda tabela primeiro.  
  
 [!code-csharp[DataWorks DataTable.MergeMissingSchemaAction#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTable.MergeMissingSchemaAction/CS/source.cs#1)]
 [!code-vb[DataWorks DataTable.MergeMissingSchemaAction#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTable.MergeMissingSchemaAction/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MinimumCapacity">
      <MemberSignature Language="C#" Value="public int MinimumCapacity { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 MinimumCapacity" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataTable.MinimumCapacity" />
      <MemberSignature Language="VB.NET" Value="Public Property MinimumCapacity As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int MinimumCapacity { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.MinimumCapacity : int with get, set" Usage="System.Data.DataTable.MinimumCapacity" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.ComponentModel.DefaultValue(50)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.Data.DataSysDescription("DataTableMinimumCapacityDescr")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define o tamanho inicial para essa tabela.</summary>
        <value>O tamanho inicial em linhas dessa tabela. O padrão é 50.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Data.DataTable.MinimumCapacity%2A> permite que o sistema criar um conjunto apropriado de recursos antes de buscar dados. Em uma situação de quando o desempenho for crítico, definir essa propriedade pode otimizar o desempenho.  
  
   
  
## Examples  
 O exemplo a seguir define o <xref:System.Data.DataTable.MinimumCapacity%2A> de um <xref:System.Data.DataTable>.  
  
 [!code-csharp[Classic WebData DataTable.MinimumCapacity Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.MinimumCapacity Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.MinimumCapacity Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.MinimumCapacity Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Namespace">
      <MemberSignature Language="C#" Value="public string Namespace { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Namespace" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataTable.Namespace" />
      <MemberSignature Language="VB.NET" Value="Public Property Namespace As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Namespace { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Namespace : string with get, set" Usage="System.Data.DataTable.Namespace" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.Data.DataSysDescription("DataTableNamespaceDescr")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define o namespace da representação XML dos dados armazenados no <see cref="T:System.Data.DataTable" />.</summary>
        <value>O namespace do <see cref="T:System.Data.DataTable" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="NewRow">
      <MemberSignature Language="C#" Value="public System.Data.DataRow NewRow ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.DataRow NewRow() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.NewRow" />
      <MemberSignature Language="VB.NET" Value="Public Function NewRow () As DataRow" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::DataRow ^ NewRow();" />
      <MemberSignature Language="F#" Value="member this.NewRow : unit -&gt; System.Data.DataRow" Usage="dataTable.NewRow " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataRow</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Cria um novo <see cref="T:System.Data.DataRow" /> com o mesmo esquema que a tabela.</summary>
        <returns>Um <see cref="T:System.Data.DataRow" /> com o mesmo esquema que o <see cref="T:System.Data.DataTable" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Você deve usar o <xref:System.Data.DataTable.NewRow%2A> método para criar novos <xref:System.Data.DataRow> objetos com o mesmo esquema que o <xref:System.Data.DataTable>. Depois de criar uma <xref:System.Data.DataRow>, você pode adicioná-lo para o <xref:System.Data.DataRowCollection>, por meio de <xref:System.Data.DataTable> do objeto <xref:System.Data.DataTable.Rows%2A> propriedade. Quando você usa <xref:System.Data.DataTable.NewRow%2A> para criar novas linhas, as linhas devem ser adicionadas ou excluídas da tabela de dados antes de chamar <xref:System.Data.DataTable.Clear%2A>.  
  
   
  
## Examples  
 O exemplo a seguir cria uma <xref:System.Data.DataTable>, adiciona dois <xref:System.Data.DataColumn> objetos que determinam o esquema da tabela e cria vários novos <xref:System.Data.DataRow> objetos usando o <xref:System.Data.DataTable.NewRow%2A> método. Aqueles <xref:System.Data.DataRow> objetos, em seguida, são adicionados para o <xref:System.Data.DataRowCollection> usando o <xref:System.Data.DataRowCollection.Add%2A> método.  
  
 [!code-csharp[Classic WebData DataTable.NewRow Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.NewRow Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.NewRow Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.NewRow Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="NewRowArray">
      <MemberSignature Language="C#" Value="protected internal System.Data.DataRow[] NewRowArray (int size);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig instance class System.Data.DataRow[] NewRowArray(int32 size) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.NewRowArray(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Function NewRowArray (size As Integer) As DataRow()" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; cli::array &lt;System::Data::DataRow ^&gt; ^ NewRowArray(int size);" />
      <MemberSignature Language="F#" Value="member this.NewRowArray : int -&gt; System.Data.DataRow[]" Usage="dataTable.NewRowArray size" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataRow[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="size" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="size">Um valor <see cref="T:System.Int32" /> que descreve o tamanho da matriz.</param>
        <summary>Retorna uma matriz de <see cref="T:System.Data.DataRow" />.</summary>
        <returns>A nova matriz.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="NewRowFromBuilder">
      <MemberSignature Language="C#" Value="protected virtual System.Data.DataRow NewRowFromBuilder (System.Data.DataRowBuilder builder);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Data.DataRow NewRowFromBuilder(class System.Data.DataRowBuilder builder) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.NewRowFromBuilder(System.Data.DataRowBuilder)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function NewRowFromBuilder (builder As DataRowBuilder) As DataRow" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Data::DataRow ^ NewRowFromBuilder(System::Data::DataRowBuilder ^ builder);" />
      <MemberSignature Language="F#" Value="abstract member NewRowFromBuilder : System.Data.DataRowBuilder -&gt; System.Data.DataRow&#xA;override this.NewRowFromBuilder : System.Data.DataRowBuilder -&gt; System.Data.DataRow" Usage="dataTable.NewRowFromBuilder builder" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataRow</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="builder" Type="System.Data.DataRowBuilder" />
      </Parameters>
      <Docs>
        <param name="builder">Um objeto <see cref="T:System.Data.DataRowBuilder" />.</param>
        <summary>Cria uma nova linha de uma linha existente.</summary>
        <returns>Uma classe derivada <see cref="T:System.Data.DataRow" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnColumnChanged">
      <MemberSignature Language="C#" Value="protected internal virtual void OnColumnChanged (System.Data.DataColumnChangeEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnColumnChanged(class System.Data.DataColumnChangeEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.OnColumnChanged(System.Data.DataColumnChangeEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnColumnChanged (e As DataColumnChangeEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnColumnChanged(System::Data::DataColumnChangeEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnColumnChanged : System.Data.DataColumnChangeEventArgs -&gt; unit&#xA;override this.OnColumnChanged : System.Data.DataColumnChangeEventArgs -&gt; unit" Usage="dataTable.OnColumnChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Data.DataColumnChangeEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Um <see cref="T:System.Data.DataColumnChangeEventArgs" /> que contém os dados do evento.</param>
        <summary>Aciona o evento <see cref="E:System.Data.DataTable.ColumnChanged" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A geração de um evento invoca o manipulador de eventos por meio de um delegado. Para obter uma visão geral, consulte [tratando e gerando eventos](~/docs/standard/events/index.md).  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Ao substituir <see cref="M:System.Data.DataTable.OnColumnChanged(System.Data.DataColumnChangeEventArgs)" /> em uma classe derivada, certifique-se de chamar a classe base <see cref="M:System.Data.DataTable.OnColumnChanged(System.Data.DataColumnChangeEventArgs)" /> método.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnColumnChanging">
      <MemberSignature Language="C#" Value="protected internal virtual void OnColumnChanging (System.Data.DataColumnChangeEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnColumnChanging(class System.Data.DataColumnChangeEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.OnColumnChanging(System.Data.DataColumnChangeEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnColumnChanging (e As DataColumnChangeEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnColumnChanging(System::Data::DataColumnChangeEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnColumnChanging : System.Data.DataColumnChangeEventArgs -&gt; unit&#xA;override this.OnColumnChanging : System.Data.DataColumnChangeEventArgs -&gt; unit" Usage="dataTable.OnColumnChanging e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Data.DataColumnChangeEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Um <see cref="T:System.Data.DataColumnChangeEventArgs" /> que contém os dados do evento.</param>
        <summary>Aciona o evento <see cref="E:System.Data.DataTable.ColumnChanging" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A geração de um evento invoca o manipulador de eventos por meio de um delegado. Para obter uma visão geral, consulte [tratando e gerando eventos](~/docs/standard/events/index.md).  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Ao substituir <see cref="M:System.Data.DataTable.OnColumnChanging(System.Data.DataColumnChangeEventArgs)" /> em uma classe derivada, certifique-se de chamar a classe base <see cref="M:System.Data.DataTable.OnColumnChanging(System.Data.DataColumnChangeEventArgs)" /> método.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnPropertyChanging">
      <MemberSignature Language="C#" Value="protected virtual void OnPropertyChanging (System.ComponentModel.PropertyChangedEventArgs pcevent);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnPropertyChanging(class System.ComponentModel.PropertyChangedEventArgs pcevent) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.OnPropertyChanging(System.ComponentModel.PropertyChangedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnPropertyChanging (pcevent As PropertyChangedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnPropertyChanging(System::ComponentModel::PropertyChangedEventArgs ^ pcevent);" />
      <MemberSignature Language="F#" Value="abstract member OnPropertyChanging : System.ComponentModel.PropertyChangedEventArgs -&gt; unit&#xA;override this.OnPropertyChanging : System.ComponentModel.PropertyChangedEventArgs -&gt; unit" Usage="dataTable.OnPropertyChanging pcevent" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pcevent" Type="System.ComponentModel.PropertyChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="pcevent">Um <see cref="T:System.ComponentModel.PropertyChangedEventArgs" /> que contém os dados do evento.</param>
        <summary>Aciona o evento <see cref="E:System.ComponentModel.INotifyPropertyChanged.PropertyChanged" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A geração de um evento invoca o manipulador de eventos por meio de um delegado. Para obter uma visão geral, consulte [tratando e gerando eventos](~/docs/standard/events/index.md).  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Ao substituir <see cref="M:System.Data.DataTable.OnPropertyChanging(System.ComponentModel.PropertyChangedEventArgs)" /> em uma classe derivada, certifique-se de chamar a classe base <see cref="M:System.Data.DataTable.OnPropertyChanging(System.ComponentModel.PropertyChangedEventArgs)" /> método.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnRemoveColumn">
      <MemberSignature Language="C#" Value="protected virtual void OnRemoveColumn (System.Data.DataColumn column);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnRemoveColumn(class System.Data.DataColumn column) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.OnRemoveColumn(System.Data.DataColumn)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnRemoveColumn (column As DataColumn)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnRemoveColumn(System::Data::DataColumn ^ column);" />
      <MemberSignature Language="F#" Value="abstract member OnRemoveColumn : System.Data.DataColumn -&gt; unit&#xA;override this.OnRemoveColumn : System.Data.DataColumn -&gt; unit" Usage="dataTable.OnRemoveColumn column" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="column" Type="System.Data.DataColumn" />
      </Parameters>
      <Docs>
        <param name="column">O <see cref="T:System.Data.DataColumn" /> sendo removido.</param>
        <summary>Notifica o <see cref="T:System.Data.DataTable" /> que um <see cref="T:System.Data.DataColumn" /> está sendo removido.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A geração de um evento invoca o manipulador de eventos por meio de um delegado. Para obter mais informações, consulte [tratando e gerando eventos](~/docs/standard/events/index.md).  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Ao substituir <see cref="M:System.Data.DataTable.OnRemoveColumn(System.Data.DataColumn)" /> em uma classe derivada, certifique-se de chamar a classe base <see cref="M:System.Data.DataTable.OnRemoveColumn(System.Data.DataColumn)" /> método.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnRowChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnRowChanged (System.Data.DataRowChangeEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnRowChanged(class System.Data.DataRowChangeEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.OnRowChanged(System.Data.DataRowChangeEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnRowChanged (e As DataRowChangeEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnRowChanged(System::Data::DataRowChangeEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnRowChanged : System.Data.DataRowChangeEventArgs -&gt; unit&#xA;override this.OnRowChanged : System.Data.DataRowChangeEventArgs -&gt; unit" Usage="dataTable.OnRowChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Data.DataRowChangeEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Um <see cref="T:System.Data.DataRowChangeEventArgs" /> que contém os dados do evento.</param>
        <summary>Aciona o evento <see cref="E:System.Data.DataTable.RowChanged" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A geração de um evento invoca o manipulador de eventos por meio de um delegado. Para obter uma visão geral, consulte [tratando e gerando eventos](~/docs/standard/events/index.md).  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Ao substituir <see cref="M:System.Data.DataTable.OnRowChanged(System.Data.DataRowChangeEventArgs)" /> em uma classe derivada, certifique-se de chamar a classe base <see cref="M:System.Data.DataTable.OnRowChanged(System.Data.DataRowChangeEventArgs)" /> método.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnRowChanging">
      <MemberSignature Language="C#" Value="protected virtual void OnRowChanging (System.Data.DataRowChangeEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnRowChanging(class System.Data.DataRowChangeEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.OnRowChanging(System.Data.DataRowChangeEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnRowChanging (e As DataRowChangeEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnRowChanging(System::Data::DataRowChangeEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnRowChanging : System.Data.DataRowChangeEventArgs -&gt; unit&#xA;override this.OnRowChanging : System.Data.DataRowChangeEventArgs -&gt; unit" Usage="dataTable.OnRowChanging e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Data.DataRowChangeEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Um <see cref="T:System.Data.DataRowChangeEventArgs" /> que contém os dados do evento.</param>
        <summary>Aciona o evento <see cref="E:System.Data.DataTable.RowChanging" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A geração de um evento invoca o manipulador de eventos por meio de um delegado. Para obter uma visão geral, consulte [tratando e gerando eventos](~/docs/standard/events/index.md).  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Ao substituir <see cref="M:System.Data.DataTable.OnRowChanging(System.Data.DataRowChangeEventArgs)" /> em uma classe derivada, certifique-se de chamar a classe base <see cref="M:System.Data.DataTable.OnRowChanging(System.Data.DataRowChangeEventArgs)" /> método.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnRowDeleted">
      <MemberSignature Language="C#" Value="protected virtual void OnRowDeleted (System.Data.DataRowChangeEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnRowDeleted(class System.Data.DataRowChangeEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.OnRowDeleted(System.Data.DataRowChangeEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnRowDeleted (e As DataRowChangeEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnRowDeleted(System::Data::DataRowChangeEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnRowDeleted : System.Data.DataRowChangeEventArgs -&gt; unit&#xA;override this.OnRowDeleted : System.Data.DataRowChangeEventArgs -&gt; unit" Usage="dataTable.OnRowDeleted e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Data.DataRowChangeEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Um <see cref="T:System.Data.DataRowChangeEventArgs" /> que contém os dados do evento.</param>
        <summary>Aciona o evento <see cref="E:System.Data.DataTable.RowDeleted" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A geração de um evento invoca o manipulador de eventos por meio de um delegado. Para obter uma visão geral, consulte [tratando e gerando eventos](~/docs/standard/events/index.md).  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Ao substituir <see cref="M:System.Data.DataTable.OnRowDeleted(System.Data.DataRowChangeEventArgs)" /> em uma classe derivada, certifique-se de chamar a classe base <see cref="M:System.Data.DataTable.OnRowDeleted(System.Data.DataRowChangeEventArgs)" /> método.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnRowDeleting">
      <MemberSignature Language="C#" Value="protected virtual void OnRowDeleting (System.Data.DataRowChangeEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnRowDeleting(class System.Data.DataRowChangeEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.OnRowDeleting(System.Data.DataRowChangeEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnRowDeleting (e As DataRowChangeEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnRowDeleting(System::Data::DataRowChangeEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnRowDeleting : System.Data.DataRowChangeEventArgs -&gt; unit&#xA;override this.OnRowDeleting : System.Data.DataRowChangeEventArgs -&gt; unit" Usage="dataTable.OnRowDeleting e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Data.DataRowChangeEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Um <see cref="T:System.Data.DataRowChangeEventArgs" /> que contém os dados do evento.</param>
        <summary>Aciona o evento <see cref="E:System.Data.DataTable.RowDeleting" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A geração de um evento invoca o manipulador de eventos por meio de um delegado. Para obter uma visão geral, consulte [tratando e gerando eventos](~/docs/standard/events/index.md).  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Ao substituir <see cref="M:System.Data.DataTable.OnRowDeleting(System.Data.DataRowChangeEventArgs)" /> em uma classe derivada, certifique-se de chamar a classe base <see cref="M:System.Data.DataTable.OnRowDeleting(System.Data.DataRowChangeEventArgs)" /> método.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnTableCleared">
      <MemberSignature Language="C#" Value="protected virtual void OnTableCleared (System.Data.DataTableClearEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnTableCleared(class System.Data.DataTableClearEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.OnTableCleared(System.Data.DataTableClearEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnTableCleared (e As DataTableClearEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnTableCleared(System::Data::DataTableClearEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnTableCleared : System.Data.DataTableClearEventArgs -&gt; unit&#xA;override this.OnTableCleared : System.Data.DataTableClearEventArgs -&gt; unit" Usage="dataTable.OnTableCleared e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Data.DataTableClearEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Um <see cref="T:System.Data.DataTableClearEventArgs" /> que contém os dados do evento.</param>
        <summary>Aciona o evento <see cref="E:System.Data.DataTable.TableCleared" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gera o <xref:System.Data.DataTable.TableCleared> evento, que é acionado imediatamente depois que todas as linhas têm sido limpo com êxito, mas antes de <xref:System.Data.DataTable.Clear%2A> método retorna o controle ao chamador.  
  
 A geração de um evento invoca o manipulador de eventos por meio de um delegado. Para obter uma visão geral, consulte [tratando e gerando eventos](~/docs/standard/events/index.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnTableClearing">
      <MemberSignature Language="C#" Value="protected virtual void OnTableClearing (System.Data.DataTableClearEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnTableClearing(class System.Data.DataTableClearEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.OnTableClearing(System.Data.DataTableClearEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnTableClearing (e As DataTableClearEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnTableClearing(System::Data::DataTableClearEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnTableClearing : System.Data.DataTableClearEventArgs -&gt; unit&#xA;override this.OnTableClearing : System.Data.DataTableClearEventArgs -&gt; unit" Usage="dataTable.OnTableClearing e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Data.DataTableClearEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Um <see cref="T:System.Data.DataTableClearEventArgs" /> que contém os dados do evento.</param>
        <summary>Aciona o evento <see cref="E:System.Data.DataTable.TableClearing" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gera o <xref:System.Data.DataTable.TableClearing> evento, que é disparado antes do processamento do <xref:System.Data.DataTable.Clear%2A> operação é iniciada.  
  
 A geração de um evento invoca o manipulador de eventos por meio de um delegado. Para obter uma visão geral, consulte [tratando e gerando eventos](~/docs/standard/events/index.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnTableNewRow">
      <MemberSignature Language="C#" Value="protected virtual void OnTableNewRow (System.Data.DataTableNewRowEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnTableNewRow(class System.Data.DataTableNewRowEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.OnTableNewRow(System.Data.DataTableNewRowEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnTableNewRow (e As DataTableNewRowEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnTableNewRow(System::Data::DataTableNewRowEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnTableNewRow : System.Data.DataTableNewRowEventArgs -&gt; unit&#xA;override this.OnTableNewRow : System.Data.DataTableNewRowEventArgs -&gt; unit" Usage="dataTable.OnTableNewRow e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Data.DataTableNewRowEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Um <see cref="T:System.Data.DataTableNewRowEventArgs" /> que contém os dados do evento.</param>
        <summary>Aciona o evento <see cref="E:System.Data.DataTable.TableNewRow" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gera o <xref:System.Data.DataTable.TableNewRow> evento, que é acionado depois que um novo <xref:System.Data.DataRow> foi criado usando <xref:System.Data.DataTable.NewRow%2A>.  
  
 A geração de um evento invoca o manipulador de eventos por meio de um delegado. Para obter uma visão geral, consulte [tratando e gerando eventos](~/docs/standard/events/index.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ParentRelations">
      <MemberSignature Language="C#" Value="public System.Data.DataRelationCollection ParentRelations { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Data.DataRelationCollection ParentRelations" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataTable.ParentRelations" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ParentRelations As DataRelationCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Data::DataRelationCollection ^ ParentRelations { System::Data::DataRelationCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ParentRelations : System.Data.DataRelationCollection" Usage="System.Data.DataTable.ParentRelations" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.Data.DataSysDescription("DataTableParentRelationsDescr")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Data.DataRelationCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém a coleção de relações de pai desta <see cref="T:System.Data.DataTable" />.</summary>
        <value>Uma <see cref="T:System.Data.DataRelationCollection" /> que contém as relações de pai da tabela. Será retornada uma coleção vazia se não houver nenhum objeto <see cref="T:System.Data.DataRelation" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O exemplo a seguir usa o <xref:System.Data.DataTable.ParentRelations%2A> propriedade para retornar cada pai <xref:System.Data.DataRelation> em um <xref:System.Data.DataTable>. Cada relação, em seguida, é usada como um argumento na <xref:System.Data.DataRow.GetParentRows%2A> método da <xref:System.Data.DataRow> para retornar uma matriz de linhas. Em seguida, o valor de cada coluna na linha é impresso.  
  
 [!code-csharp[Classic WebData DataTable.ParentRelations Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.ParentRelations Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.ParentRelations Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.ParentRelations Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Data.DataTable.ChildRelations" />
        <altmember cref="T:System.Data.DataRelation" />
        <altmember cref="T:System.Data.DataSet" />
        <altmember cref="P:System.Data.DataSet.Relations" />
      </Docs>
    </Member>
    <Member MemberName="Prefix">
      <MemberSignature Language="C#" Value="public string Prefix { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Prefix" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataTable.Prefix" />
      <MemberSignature Language="VB.NET" Value="Public Property Prefix As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Prefix { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Prefix : string with get, set" Usage="System.Data.DataTable.Prefix" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.ComponentModel.DefaultValue("")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.Data.DataSysDescription("DataTablePrefixDescr")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define o namespace da representação XML dos dados armazenados no <see cref="T:System.Data.DataTable" />.</summary>
        <value>O prefixo de <see cref="T:System.Data.DataTable" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PrimaryKey">
      <MemberSignature Language="C#" Value="public System.Data.DataColumn[] PrimaryKey { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Data.DataColumn[] PrimaryKey" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataTable.PrimaryKey" />
      <MemberSignature Language="VB.NET" Value="Public Property PrimaryKey As DataColumn()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property cli::array &lt;System::Data::DataColumn ^&gt; ^ PrimaryKey { cli::array &lt;System::Data::DataColumn ^&gt; ^ get(); void set(cli::array &lt;System::Data::DataColumn ^&gt; ^ value); };" />
      <MemberSignature Language="F#" Value="member this.PrimaryKey : System.Data.DataColumn[] with get, set" Usage="System.Data.DataTable.PrimaryKey" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.ComponentModel.Editor("Microsoft.VSDesigner.Data.Design.PrimaryKeyEditor, Microsoft.VSDesigner, Version=0.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "System.Drawing.Design.UITypeEditor, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.ComponentModel.TypeConverter(typeof(System.Data.PrimaryKeyTypeConverter))</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.ComponentModel.Editor("Microsoft.VSDesigner.Data.Design.PrimaryKeyEditor, Microsoft.VSDesigner, Version=7.0.5000.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", typeof(System.Drawing.Design.UITypeEditor))</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.Data.DataSysDescription("DataTablePrimaryKeyDescr")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.Editor("Microsoft.VSDesigner.Data.Design.PrimaryKeyEditor, Microsoft.VSDesigner, Version=8.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "System.Drawing.Design.UITypeEditor, System.Drawing, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.Editor("Microsoft.VSDesigner.Data.Design.PrimaryKeyEditor, Microsoft.VSDesigner, Version=10.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "System.Drawing.Design.UITypeEditor, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8">
          <AttributeName>System.ComponentModel.Editor("Microsoft.VSDesigner.Data.Design.PrimaryKeyEditor, Microsoft.VSDesigner, Version=9.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "System.Drawing.Design.UITypeEditor, System.Drawing, Version=2.0.5.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Data.DataColumn[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define uma matriz de colunas que funcionam como chaves primárias da tabela de dados.</summary>
        <value>Uma matriz de objetos de <see cref="T:System.Data.DataColumn" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A chave primária de uma tabela deve ser exclusiva para identificar o registro na tabela. Também é possível ter uma tabela com uma chave primária composta de duas ou mais colunas. Isso ocorre quando uma única coluna não pode conter valores exclusivos suficientes. Por exemplo, uma chave primária de duas colunas pode consistir em uma coluna "FirstName" e "LastName". Porque as chaves primárias podem ser compostas por mais de uma coluna, o <xref:System.Data.DataTable.PrimaryKey%2A> propriedade consiste em uma matriz de <xref:System.Data.DataColumn> objetos.  
  
   
  
## Examples  
 O primeiro exemplo mostra como retornar colunas de chave primária para uma <xref:System.Data.DataTable> exibidas em um `DataGrid`. O segundo exemplo demonstra como definir as colunas de chave primária para uma <xref:System.Data.DataTable>.  
  
 [!code-csharp[Classic WebData DataTable.PrimaryKey Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.PrimaryKey Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.PrimaryKey Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.PrimaryKey Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Data.DataException">A chave é uma chave estrangeira.</exception>
        <altmember cref="T:System.Data.DataColumn" />
        <altmember cref="P:System.Data.DataTable.PrimaryKey" />
        <altmember cref="T:System.Data.DataColumnCollection" />
      </Docs>
    </Member>
    <MemberGroup MemberName="ReadXml">
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Lê o esquema XML e os dados para o <see cref="T:System.Data.DataTable" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O método <xref:System.Data.DataTable.ReadXml%2A> fornece uma maneira de ler apenas dados ou dados e esquema em um <xref:System.Data.DataTable> a partir de um documento XML, e o método <xref:System.Data.DataTable.ReadXmlSchema%2A> lê apenas o esquema. Para ler dados e esquema, use um dos `ReadXML` sobrecargas que incluem o `XmlReadMode` parâmetro e defina seu valor como `ReadSchema`.  
  
 Observe que o mesmo é verdadeiro para os métodos <xref:System.Data.DataTable.WriteXml%2A> e <xref:System.Data.DataTable.WriteXmlSchema%2A>, respectivamente. Para gravar dados XML ou o esquema e os dados do `DataTable`, use o método `WriteXml`. Para gravar apenas o esquema, use o método `WriteXmlSchema`.  
  
> [!NOTE]
>  Um <xref:System.InvalidOperationException> será lançado se um tipo de coluna no `DataRow` de leitura ou gravação implementa <xref:System.Dynamic.IDynamicMetaObjectProvider> e não implementa <xref:System.Xml.Serialization.IXmlSerializable>.  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Data.DataSet.ReadXml" />
      </Docs>
    </MemberGroup>
    <Member MemberName="ReadXml">
      <MemberSignature Language="C#" Value="public System.Data.XmlReadMode ReadXml (System.IO.Stream stream);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Data.XmlReadMode ReadXml(class System.IO.Stream stream) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.ReadXml(System.IO.Stream)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::XmlReadMode ReadXml(System::IO::Stream ^ stream);" />
      <MemberSignature Language="F#" Value="member this.ReadXml : System.IO.Stream -&gt; System.Data.XmlReadMode" Usage="dataTable.ReadXml stream" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.XmlReadMode</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
      </Parameters>
      <Docs>
        <param name="stream">Um objeto que deriva de <see cref="T:System.IO.Stream" /></param>
        <summary>Lê o esquema XML e dados para o <see cref="T:System.Data.DataTable" /> usando o <see cref="T:System.IO.Stream" /> especificado.</summary>
        <returns>O <see cref="T:System.Data.XmlReadMode" /> usado para ler os dados.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O atual <xref:System.Data.DataTable> e seus descendentes são carregados com os dados da fornecido <xref:System.IO.Stream>. O comportamento desse método é idêntico do <xref:System.Data.DataSet.ReadXml%2A?displayProperty=nameWithType> os métodos, exceto que nesse caso, os dados são carregados somente para a tabela atual e seus descendentes.  
  
 O método <xref:System.Data.DataTable.ReadXml%2A> fornece uma maneira de ler apenas dados ou dados e esquema em um <xref:System.Data.DataTable> a partir de um documento XML, e o método <xref:System.Data.DataTable.ReadXmlSchema%2A> lê apenas o esquema.  
  
 Observe que o mesmo é verdadeiro para os métodos <xref:System.Data.DataTable.WriteXml%2A> e <xref:System.Data.DataTable.WriteXmlSchema%2A>, respectivamente. Para gravar dados XML ou o esquema e os dados do `DataTable`, use o método `WriteXml`. Para gravar apenas o esquema, use o método `WriteXmlSchema`.  
  
> [!NOTE]
>  Um <xref:System.InvalidOperationException> será lançado se um tipo de coluna no `DataRow` de leitura ou gravação implementa <xref:System.Dynamic.IDynamicMetaObjectProvider> e não implementa <xref:System.Xml.Serialization.IXmlSerializable>.  
  
 Se um esquema embutido for especificado, o esquema embutido será usado para estender a estrutura relacional existente antes de carregar os dados. Se houver algum conflito (por exemplo, a mesma coluna na mesma tabela definida com tipos de dados diferentes), uma exceção será gerada.  
  
 Se nenhum esquema embutido for especificado, a estrutura relacional será estendida por meio de inferência, conforme necessário, de acordo com a estrutura do documento XML. Se o esquema não puder ser estendido por meio de inferência para expor todos os dados, uma exceção será gerada.  
  
> [!NOTE]
>  O `DataSet` não associa um elemento XML ao `DataColumn` correspondente `DataTable` quando caracteres XML legais como (“_”) escapam no XML serializável. O próprio `DataSet` só escapa com caracteres XML ilegais em nomes de elemento XML e, assim, só pode consumir o mesmo. Quando os caracteres legais no nome de elemento XML são escapadas, o elemento é ignorado durante o processamento.  
  
   
  
## Examples  
 O exemplo a seguir cria um <xref:System.Data.DataTable> que contém duas colunas e dez linhas. O exemplo grava o <xref:System.Data.DataTable> esquemas e dados para um fluxo de memória, invocando o <xref:System.Data.DataTable.WriteXml%2A> método. O exemplo cria um segundo <xref:System.Data.DataTable> e chama o <xref:System.Data.DataTable.ReadXml%2A> método preenchê-lo com o esquema e os dados.  
  
 [!code-csharp[DataWorks DataTable.ReadXml#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTable.ReadXml/CS/source.cs#1)]
 [!code-vb[DataWorks DataTable.ReadXml#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTable.ReadXml/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReadXml">
      <MemberSignature Language="C#" Value="public System.Data.XmlReadMode ReadXml (System.IO.TextReader reader);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Data.XmlReadMode ReadXml(class System.IO.TextReader reader) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.ReadXml(System.IO.TextReader)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReadXml (reader As TextReader) As XmlReadMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::XmlReadMode ReadXml(System::IO::TextReader ^ reader);" />
      <MemberSignature Language="F#" Value="member this.ReadXml : System.IO.TextReader -&gt; System.Data.XmlReadMode" Usage="dataTable.ReadXml reader" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.XmlReadMode</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.IO.TextReader" />
      </Parameters>
      <Docs>
        <param name="reader">O <see cref="T:System.IO.TextReader" /> que será usado para ler os dados.</param>
        <summary>Lê o esquema XML e dados para o <see cref="T:System.Data.DataTable" /> usando o <see cref="T:System.IO.TextReader" /> especificado.</summary>
        <returns>O <see cref="T:System.Data.XmlReadMode" /> usado para ler os dados.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O atual <xref:System.Data.DataTable> e seus descendentes são carregados com os dados da fornecido <xref:System.IO.TextReader>. O comportamento desse método é idêntico do <xref:System.Data.DataSet.ReadXml%2A?displayProperty=nameWithType> os métodos, exceto que nesse caso, os dados são carregados somente para a tabela atual e seus descendentes.  
  
 O método <xref:System.Data.DataTable.ReadXml%2A> fornece uma maneira de ler apenas dados ou dados e esquema em um <xref:System.Data.DataTable> a partir de um documento XML, e o método <xref:System.Data.DataTable.ReadXmlSchema%2A> lê apenas o esquema.  
  
 Observe que o mesmo é verdadeiro para os métodos <xref:System.Data.DataTable.WriteXml%2A> e <xref:System.Data.DataTable.WriteXmlSchema%2A>, respectivamente. Para gravar dados XML ou o esquema e os dados do `DataTable`, use o método `WriteXml`. Para gravar apenas o esquema, use o método `WriteXmlSchema`.  
  
> [!NOTE]
>  Um <xref:System.InvalidOperationException> será lançado se um tipo de coluna no `DataRow` de leitura ou gravação implementa <xref:System.Dynamic.IDynamicMetaObjectProvider> e não implementa <xref:System.Xml.Serialization.IXmlSerializable>.  
  
 Se um esquema embutido for especificado, o esquema embutido será usado para estender a estrutura relacional existente antes de carregar os dados. Se houver algum conflito (por exemplo, a mesma coluna na mesma tabela definida com tipos de dados diferentes), uma exceção será gerada.  
  
 Se nenhum esquema embutido for especificado, a estrutura relacional será estendida por meio de inferência, conforme necessário, de acordo com a estrutura do documento XML. Se o esquema não puder ser estendido por meio de inferência para expor todos os dados, uma exceção será gerada.  
  
> [!NOTE]
>  O `DataSet` não associa um elemento XML ao `DataColumn` correspondente `DataTable` quando caracteres XML legais como (“_”) escapam no XML serializável. O próprio `DataSet` só escapa com caracteres XML ilegais em nomes de elemento XML e, assim, só pode consumir o mesmo. Quando os caracteres legais no nome de elemento XML são escapadas, o elemento é ignorado durante o processamento.  
  
   
  
## Examples  
 O exemplo a seguir cria um <xref:System.Data.DataTable> que contém duas colunas e dez linhas. O exemplo grava o <xref:System.Data.DataTable> esquemas e dados para um fluxo de memória, invocando o <xref:System.Data.DataTable.WriteXml%2A> método. O exemplo cria um segundo <xref:System.Data.DataTable> e chama o <xref:System.Data.DataTable.ReadXml%2A> método preenchê-lo com o esquema e os dados.  
  
 [!code-csharp[DataWorks DataTable.ReadXmlText#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTable.ReadXmlText/CS/source.cs#1)]
 [!code-vb[DataWorks DataTable.ReadXmlText#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTable.ReadXmlText/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReadXml">
      <MemberSignature Language="C#" Value="public System.Data.XmlReadMode ReadXml (string fileName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Data.XmlReadMode ReadXml(string fileName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.ReadXml(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReadXml (fileName As String) As XmlReadMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::XmlReadMode ReadXml(System::String ^ fileName);" />
      <MemberSignature Language="F#" Value="member this.ReadXml : string -&gt; System.Data.XmlReadMode" Usage="dataTable.ReadXml fileName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.XmlReadMode</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="fileName">O nome do arquivo do qual os dados serão lidos.</param>
        <summary>Lê o esquema XML e dados para o <see cref="T:System.Data.DataTable" /> do arquivo especificado.</summary>
        <returns>O <see cref="T:System.Data.XmlReadMode" /> usado para ler os dados.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O atual <xref:System.Data.DataTable> e seus descendentes são carregados com os dados do arquivo denominado fornecido <xref:System.String>. O comportamento desse método é idêntico do <xref:System.Data.DataSet.ReadXml%2A?displayProperty=nameWithType> os métodos, exceto que nesse caso, os dados são carregados somente para a tabela atual e seus descendentes.  
  
 O método <xref:System.Data.DataTable.ReadXml%2A> fornece uma maneira de ler apenas dados ou dados e esquema em um <xref:System.Data.DataTable> a partir de um documento XML, e o método <xref:System.Data.DataTable.ReadXmlSchema%2A> lê apenas o esquema.  
  
 Observe que o mesmo é verdadeiro para os métodos <xref:System.Data.DataTable.WriteXml%2A> e <xref:System.Data.DataTable.WriteXmlSchema%2A>, respectivamente. Para gravar dados XML ou o esquema e os dados do `DataTable`, use o método `WriteXml`. Para gravar apenas o esquema, use o método `WriteXmlSchema`.  
  
> [!NOTE]
>  Um <xref:System.InvalidOperationException> será lançado se um tipo de coluna no `DataRow` de leitura ou gravação implementa <xref:System.Dynamic.IDynamicMetaObjectProvider> e não implementa <xref:System.Xml.Serialization.IXmlSerializable>.  
  
 Se um esquema embutido for especificado, o esquema embutido será usado para estender a estrutura relacional existente antes de carregar os dados. Se houver algum conflito (por exemplo, a mesma coluna na mesma tabela definida com tipos de dados diferentes), uma exceção será gerada.  
  
 Se nenhum esquema embutido for especificado, a estrutura relacional será estendida por meio de inferência, conforme necessário, de acordo com a estrutura do documento XML. Se o esquema não puder ser estendido por meio de inferência para expor todos os dados, uma exceção será gerada.  
  
> [!NOTE]
>  O `DataSet` não associa um elemento XML ao `DataColumn` correspondente `DataTable` quando caracteres XML legais como (“_”) escapam no XML serializável. O próprio `DataSet` só escapa com caracteres XML ilegais em nomes de elemento XML e, assim, só pode consumir o mesmo. Quando os caracteres legais no nome de elemento XML são escapadas, o elemento é ignorado durante o processamento.  
  
```csharp  
using System.Data;  
public class A {  
   static void Main(string[] args) {  
      DataTable tabl = new DataTable("mytable");  
      tabl.Columns.Add(new DataColumn("id", typeof(int)));  
      for (int i = 0; i < 10; i++) {  
         DataRow row = tabl.NewRow();  
         row["id"] = i;  
         tabl.Rows.Add(row);  
      }  
      tabl.WriteXml("f.xml", XmlWriteMode.WriteSchema);  
      DataTable newt = new DataTable();  
      newt.ReadXml("f.xml");  
   }  
}  
```  
  
   
  
## Examples  
 O exemplo a seguir cria um <xref:System.Data.DataTable> que contém duas colunas e dez linhas. O exemplo grava o <xref:System.Data.DataTable> esquema e os dados no disco. O exemplo cria um segundo <xref:System.Data.DataTable> e chama o <xref:System.Data.DataTable.ReadXml%2A> método preenchê-lo com o esquema e os dados.  
  
 [!code-csharp[DataWorks DataTable.ReadXmlString#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTable.ReadXmlString/CS/source.cs#1)]
 [!code-vb[DataWorks DataTable.ReadXmlString#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTable.ReadXmlString/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReadXml">
      <MemberSignature Language="C#" Value="public System.Data.XmlReadMode ReadXml (System.Xml.XmlReader reader);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Data.XmlReadMode ReadXml(class System.Xml.XmlReader reader) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.ReadXml(System.Xml.XmlReader)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReadXml (reader As XmlReader) As XmlReadMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::XmlReadMode ReadXml(System::Xml::XmlReader ^ reader);" />
      <MemberSignature Language="F#" Value="member this.ReadXml : System.Xml.XmlReader -&gt; System.Data.XmlReadMode" Usage="dataTable.ReadXml reader" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.XmlReadMode</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Xml.XmlReader" />
      </Parameters>
      <Docs>
        <param name="reader">O <see cref="T:System.Xml.XmlReader" /> que será usado para ler os dados.</param>
        <summary>Lê o esquema XML e dados no <see cref="T:System.Data.DataTable" /> usando o <see cref="T:System.Xml.XmlReader" /> especificado.</summary>
        <returns>O <see cref="T:System.Data.XmlReadMode" /> usado para ler os dados.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O atual <xref:System.Data.DataTable> e seus descendentes são carregados com os dados do arquivo denominado fornecido <xref:System.Xml.XmlReader>. O comportamento desse método é idêntico do <xref:System.Data.DataTable.ReadXml%2A> os métodos, exceto que nesse caso, os dados são carregados somente para a tabela atual e seus descendentes.  
  
 O método <xref:System.Data.DataTable.ReadXml%2A> fornece uma maneira de ler apenas dados ou dados e esquema em um <xref:System.Data.DataTable> a partir de um documento XML, e o método <xref:System.Data.DataTable.ReadXmlSchema%2A> lê apenas o esquema.  
  
 Observe que o mesmo é verdadeiro para os métodos <xref:System.Data.DataTable.WriteXml%2A> e <xref:System.Data.DataTable.WriteXmlSchema%2A>, respectivamente. Para gravar dados XML ou o esquema e os dados do `DataTable`, use o método `WriteXml`. Para gravar apenas o esquema, use o método `WriteXmlSchema`.  
  
> [!NOTE]
>  Um <xref:System.InvalidOperationException> será lançado se um tipo de coluna no `DataRow` de leitura ou gravação implementa <xref:System.Dynamic.IDynamicMetaObjectProvider> e não implementa <xref:System.Xml.Serialization.IXmlSerializable>.  
  
 Se um esquema embutido for especificado, o esquema embutido será usado para estender a estrutura relacional existente antes de carregar os dados. Se houver algum conflito (por exemplo, a mesma coluna na mesma tabela definida com tipos de dados diferentes), uma exceção será gerada.  
  
 Se nenhum esquema embutido for especificado, a estrutura relacional será estendida por meio de inferência, conforme necessário, de acordo com a estrutura do documento XML. Se o esquema não puder ser estendido por meio de inferência para expor todos os dados, uma exceção será gerada.  
  
> [!NOTE]
>  O `DataSet` não associa um elemento XML ao `DataColumn` correspondente `DataTable` quando caracteres XML legais como (“_”) escapam no XML serializável. O próprio `DataSet` só escapa com caracteres XML ilegais em nomes de elemento XML e, assim, só pode consumir o mesmo. Quando os caracteres legais no nome de elemento XML são escapadas, o elemento é ignorado durante o processamento.  
  
   
  
## Examples  
 O exemplo a seguir cria um <xref:System.Data.DataTable> que contém duas colunas e dez linhas. O exemplo grava o <xref:System.Data.DataTable> esquemas e dados para um <xref:System.Xml.XmlReader>. O exemplo cria um segundo <xref:System.Data.DataTable> e chama o <xref:System.Data.DataTable.ReadXml%2A> método preenchê-lo com esquema e dados do <xref:System.Xml.XmlReader> instância.  
  
 [!code-csharp[DataWorks DataTable.ReadXmlXmlReader#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTable.ReadXmlXmlReader/CS/source.cs#1)]
 [!code-vb[DataWorks DataTable.ReadXmlXmlReader#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTable.ReadXmlXmlReader/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="ReadXmlSchema">
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Lê um esquema XML para o <see cref="T:System.Data.DataTable" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use o método `ReadXmlSchema` para criar o esquema de um <xref:System.Data.DataTable>. O esquema inclui tabela, relação e definições de restrição.  
  
 Para gravar um esquema em um documento XML, use o método <xref:System.Data.DataTable.WriteXmlSchema%2A>.  
  
 O esquema XML é interpretado de acordo com o padrão XSD.  
  
 O método `ReadXmlSchema` é invocado geralmente antes de invocar o método <xref:System.Data.DataTable.ReadXml%2A> usado para preencher o <xref:System.Data.DataTable>.  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Data.DataSet.ReadXmlSchema" />
      </Docs>
    </MemberGroup>
    <Member MemberName="ReadXmlSchema">
      <MemberSignature Language="C#" Value="public void ReadXmlSchema (System.IO.Stream stream);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ReadXmlSchema(class System.IO.Stream stream) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.ReadXmlSchema(System.IO.Stream)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ReadXmlSchema(System::IO::Stream ^ stream);" />
      <MemberSignature Language="F#" Value="member this.ReadXmlSchema : System.IO.Stream -&gt; unit" Usage="dataTable.ReadXmlSchema stream" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
      </Parameters>
      <Docs>
        <param name="stream">O fluxo usado para ler o esquema.</param>
        <summary>Lê um esquema XML para a <see cref="T:System.Data.DataTable" /> usando o fluxo especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use o método <xref:System.Data.DataTable.ReadXmlSchema%2A> para criar o esquema de um <xref:System.Data.DataTable>. O esquema inclui tabela, relação e definições de restrição.  
  
 Para gravar um esquema em um documento XML, use o método <xref:System.Data.DataTable.WriteXmlSchema%2A>.  
  
 O esquema XML é interpretado de acordo com o padrão XSD.  
  
 A corrupção de dados poderá ocorrer se os tipos msdata:DataType e xs:type não coincidirem. Nenhuma exceção será gerada.  
  
 O método `ReadXmlSchema` é invocado geralmente antes de invocar o método <xref:System.Data.DataTable.ReadXml%2A> usado para preencher o <xref:System.Data.DataTable>.  
  
 Para criar uma relação aninhada usando o esquema XML, use elementos aninhados implícitos. Você também pode configurar a relação aninhada para usar nomes de coluna explícito. Elementos devem ser aninhados implicitamente para que o DataTables correspondente participar de uma relação aninhada.  
  
   
  
## Examples  
 O aplicativo de console a seguir cria um novo <xref:System.Data.DataTable>e grava o esquema para a tabela para um <xref:System.IO.MemoryStream>. Em seguida, o exemplo cria um novo <xref:System.Data.DataTable> e lê o esquema do esquema XML salvo.  
  
 [!code-csharp[DataWorks DataTable.ReadXmlIOStream#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTable.ReadXmlIOStream/CS/source.cs#1)]
 [!code-vb[DataWorks DataTable.ReadXmlIOStream#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTable.ReadXmlIOStream/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Data.DataSet.ReadXmlSchema(System.IO.Stream)" />
      </Docs>
    </Member>
    <Member MemberName="ReadXmlSchema">
      <MemberSignature Language="C#" Value="public void ReadXmlSchema (System.IO.TextReader reader);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ReadXmlSchema(class System.IO.TextReader reader) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.ReadXmlSchema(System.IO.TextReader)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ReadXmlSchema (reader As TextReader)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ReadXmlSchema(System::IO::TextReader ^ reader);" />
      <MemberSignature Language="F#" Value="member this.ReadXmlSchema : System.IO.TextReader -&gt; unit" Usage="dataTable.ReadXmlSchema reader" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.IO.TextReader" />
      </Parameters>
      <Docs>
        <param name="reader">O <see cref="T:System.IO.TextReader" /> usado para ler as informações de esquema.</param>
        <summary>Lê um esquema XML para a <see cref="T:System.Data.DataTable" /> usando o <see cref="T:System.IO.TextReader" /> especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use o método <xref:System.Data.DataTable.ReadXmlSchema%2A> para criar o esquema de um <xref:System.Data.DataTable>. O esquema inclui tabela, relação e definições de restrição.  
  
 Para gravar um esquema em um documento XML, use o método <xref:System.Data.DataTable.WriteXmlSchema%2A>.  
  
 O esquema XML é interpretado de acordo com o padrão XSD.  
  
 A corrupção de dados poderá ocorrer se os tipos msdata:DataType e xs:type não coincidirem. Nenhuma exceção será gerada.  
  
 O método `ReadXmlSchema` é invocado geralmente antes de invocar o método <xref:System.Data.DataTable.ReadXml%2A> usado para preencher o <xref:System.Data.DataTable>.  
  
 Para criar uma relação aninhada usando o esquema XML, use elementos aninhados implícitos. Você também pode reconfigurar a relação aninhada para usar nomes de coluna explícito. Elementos devem ser aninhados implicitamente para que o DataTables correspondente participar de uma relação aninhada.  
  
   
  
## Examples  
 O aplicativo de console a seguir cria um novo <xref:System.Data.DataTable>e grava o esquema para a tabela para um <xref:System.IO.MemoryStream>. Em seguida, o exemplo cria um novo <xref:System.Data.DataTable> e lê o esquema do esquema XML salvo, usando um <xref:System.IO.StreamReader> (que herda de <xref:System.IO.TextReader>) como sua fonte.  
  
 [!code-csharp[DataWorks DataTable.ReadXmlSchema#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTable.ReadXmlSchema/CS/source.cs#1)]
 [!code-vb[DataWorks DataTable.ReadXmlSchema#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTable.ReadXmlSchema/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Data.DataSet.ReadXmlSchema(System.IO.TextReader)" />
      </Docs>
    </Member>
    <Member MemberName="ReadXmlSchema">
      <MemberSignature Language="C#" Value="public void ReadXmlSchema (string fileName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ReadXmlSchema(string fileName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.ReadXmlSchema(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ReadXmlSchema (fileName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ReadXmlSchema(System::String ^ fileName);" />
      <MemberSignature Language="F#" Value="member this.ReadXmlSchema : string -&gt; unit" Usage="dataTable.ReadXmlSchema fileName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="fileName">O nome do arquivo do qual as informações de esquema devem ser lidas.</param>
        <summary>Lê um esquema XML para a <see cref="T:System.Data.DataTable" /> do arquivo especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use o método <xref:System.Data.DataTable.ReadXmlSchema%2A> para criar o esquema de um <xref:System.Data.DataTable>. O esquema inclui tabela, relação e definições de restrição.  
  
 Para gravar um esquema em um documento XML, use o método <xref:System.Data.DataTable.WriteXmlSchema%2A>.  
  
 O esquema XML é interpretado de acordo com o padrão XSD.  
  
 A corrupção de dados poderá ocorrer se os tipos msdata:DataType e xs:type não coincidirem. Nenhuma exceção será gerada.  
  
 O método `ReadXmlSchema` é invocado geralmente antes de invocar o método <xref:System.Data.DataTable.ReadXml%2A> usado para preencher o `DataTable`.  
  
 Para criar uma relação aninhada usando o esquema XML, use elementos aninhados implícitos. Você também pode reconfigurar a relação aninhada para usar nomes de coluna explícito. Elementos devem ser aninhados implicitamente para que o DataTables correspondente participar de uma relação aninhada.  
  
   
  
## Examples  
 O aplicativo de console a seguir cria um novo <xref:System.Data.DataTable>e grava o esquema para a tabela em um arquivo. Em seguida, o exemplo cria um novo <xref:System.Data.DataTable> e lê o esquema do esquema XML salvo, usando o arquivo como sua fonte.  
  
 [!code-csharp[DataWorks DataTable.ReadXmlSchemaString#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTable.ReadXmlSchemaString/CS/source.cs#1)]
 [!code-vb[DataWorks DataTable.ReadXmlSchemaString#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTable.ReadXmlSchemaString/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Data.DataSet.ReadXmlSchema(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="ReadXmlSchema">
      <MemberSignature Language="C#" Value="public void ReadXmlSchema (System.Xml.XmlReader reader);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ReadXmlSchema(class System.Xml.XmlReader reader) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.ReadXmlSchema(System.Xml.XmlReader)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ReadXmlSchema (reader As XmlReader)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ReadXmlSchema(System::Xml::XmlReader ^ reader);" />
      <MemberSignature Language="F#" Value="member this.ReadXmlSchema : System.Xml.XmlReader -&gt; unit" Usage="dataTable.ReadXmlSchema reader" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Xml.XmlReader" />
      </Parameters>
      <Docs>
        <param name="reader">O <see cref="T:System.Xml.XmlReader" /> usado para ler as informações de esquema.</param>
        <summary>Lê um esquema XML para a <see cref="T:System.Data.DataTable" /> usando o <see cref="T:System.Xml.XmlReader" /> especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use o método <xref:System.Data.DataTable.ReadXmlSchema%2A> para criar o esquema de um <xref:System.Data.DataTable>. O esquema inclui tabela, relação e definições de restrição.  
  
 Para gravar um esquema em um documento XML, use o método <xref:System.Data.DataTable.WriteXmlSchema%2A>.  
  
 O esquema XML é interpretado de acordo com o padrão XSD.  
  
 A corrupção de dados poderá ocorrer se os tipos msdata:DataType e xs:type não coincidirem. Nenhuma exceção será gerada.  
  
 O método `ReadXmlSchema` é invocado geralmente antes de invocar o método <xref:System.Data.DataTable.ReadXml%2A> usado para preencher o <xref:System.Data.DataTable>.  
  
> [!NOTE]
>  A maneira de criar uma relação aninhada usando o esquema XML é ter elementos aninhados implícitos. Além disso, a relação aninhada pode ser novamente com fio, para usar nomes de coluna explícito. É obrigatório para os elementos sejam aninhadas implicitamente para o DataTables correspondente participar de uma relação aninhada.  
  
   
  
## Examples  
 O aplicativo de console a seguir cria um novo <xref:System.Data.DataTable>e grava o esquema para a tabela para um <xref:System.IO.MemoryStream>. Em seguida, o exemplo cria um novo <xref:System.Data.DataTable> e lê o esquema do esquema XML salvo, usando um <xref:System.Xml.XmlTextReader> (que herda de <xref:System.Xml.XmlReader>) como sua fonte.  
  
 [!code-csharp[DataWorks DataTable.ReadXmlSchemaReader#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTable.ReadXmlSchemaReader/CS/source.cs#1)]
 [!code-vb[DataWorks DataTable.ReadXmlSchemaReader#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTable.ReadXmlSchemaReader/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Data.DataSet.ReadXmlSchema(System.Xml.XmlReader)" />
      </Docs>
    </Member>
    <Member MemberName="ReadXmlSerializable">
      <MemberSignature Language="C#" Value="protected virtual void ReadXmlSerializable (System.Xml.XmlReader reader);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void ReadXmlSerializable(class System.Xml.XmlReader reader) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.ReadXmlSerializable(System.Xml.XmlReader)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub ReadXmlSerializable (reader As XmlReader)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void ReadXmlSerializable(System::Xml::XmlReader ^ reader);" />
      <MemberSignature Language="F#" Value="abstract member ReadXmlSerializable : System.Xml.XmlReader -&gt; unit&#xA;override this.ReadXmlSerializable : System.Xml.XmlReader -&gt; unit" Usage="dataTable.ReadXmlSerializable reader" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Xml.XmlReader" />
      </Parameters>
      <Docs>
        <param name="reader">Um objeto <see cref="T:System.Xml.XmlReader" />.</param>
        <summary>Lê de um fluxo XML.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RejectChanges">
      <MemberSignature Language="C#" Value="public void RejectChanges ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RejectChanges() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.RejectChanges" />
      <MemberSignature Language="VB.NET" Value="Public Sub RejectChanges ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RejectChanges();" />
      <MemberSignature Language="F#" Value="member this.RejectChanges : unit -&gt; unit" Usage="dataTable.RejectChanges " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Reverte todas as alterações feitas na tabela desde que foi carregado ou desde a última vez em que <see cref="M:System.Data.DataTable.AcceptChanges" /> foi chamado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando <xref:System.Data.DataTable.RejectChanges%2A> for chamado, qualquer <xref:System.Data.DataRow> objetos que ainda estão em modo de edição cancelar suas edições. Novas linhas são removidas. As linhas com o <xref:System.Data.DataRowState> definido como `Modified` ou `Deleted` retornado para seu estado original.  
  
   
  
## Examples  
 O exemplo a seguir faz várias alterações para um <xref:System.Data.DataTable>, mas rejeita as alterações, invocando o <xref:System.Data.DataTable.RejectChanges%2A> método.  
  
 [!code-csharp[Classic WebData DataTable.RejectChanges Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.RejectChanges Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.RejectChanges Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.RejectChanges Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RemotingFormat">
      <MemberSignature Language="C#" Value="public System.Data.SerializationFormat RemotingFormat { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Data.SerializationFormat RemotingFormat" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataTable.RemotingFormat" />
      <MemberSignature Language="VB.NET" Value="Public Property RemotingFormat As SerializationFormat" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Data::SerializationFormat RemotingFormat { System::Data::SerializationFormat get(); void set(System::Data::SerializationFormat value); };" />
      <MemberSignature Language="F#" Value="member this.RemotingFormat : System.Data.SerializationFormat with get, set" Usage="System.Data.DataTable.RemotingFormat" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.ComponentModel.DefaultValue(Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Data.SerializationFormat</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define o formato de serialização.</summary>
        <value>Uma enumeração <see cref="T:System.Data.SerializationFormat" /> que especifica a serialização de <see langword="Binary" /> ou <see langword="Xml" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Reset">
      <MemberSignature Language="C#" Value="public virtual void Reset ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Reset() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.Reset" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Reset ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Reset();" />
      <MemberSignature Language="F#" Value="abstract member Reset : unit -&gt; unit&#xA;override this.Reset : unit -&gt; unit" Usage="dataTable.Reset " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Redefine o <see cref="T:System.Data.DataTable" /> com o estado original. A redefinição remove todos os dados, índices, relações e colunas da tabela. Se um DataSet incluir uma DataTable, a tabela ainda fará parte do DataSet depois que a tabela for redefinida.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RowChanged">
      <MemberSignature Language="C#" Value="public event System.Data.DataRowChangeEventHandler RowChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Data.DataRowChangeEventHandler RowChanged" />
      <MemberSignature Language="DocId" Value="E:System.Data.DataTable.RowChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event RowChanged As DataRowChangeEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Data::DataRowChangeEventHandler ^ RowChanged;" />
      <MemberSignature Language="F#" Value="member this.RowChanged : System.Data.DataRowChangeEventHandler " Usage="member this.RowChanged : System.Data.DataRowChangeEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.Data.DataSysDescription("DataTableRowChangedDescr")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Data.DataRowChangeEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ocorre após um <see cref="T:System.Data.DataRow" /> ter sido alterado com êxito.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para obter mais informações, consulte [manipulação de eventos de DataTable](~/docs/framework/data/adonet/dataset-datatable-dataview/handling-datatable-events.md).  
  
   
  
## Examples  
 [!code-csharp[Classic WebData DataTable.RowChanged Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.RowChanged Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.RowChanged Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.RowChanged Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RowChanging">
      <MemberSignature Language="C#" Value="public event System.Data.DataRowChangeEventHandler RowChanging;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Data.DataRowChangeEventHandler RowChanging" />
      <MemberSignature Language="DocId" Value="E:System.Data.DataTable.RowChanging" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event RowChanging As DataRowChangeEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Data::DataRowChangeEventHandler ^ RowChanging;" />
      <MemberSignature Language="F#" Value="member this.RowChanging : System.Data.DataRowChangeEventHandler " Usage="member this.RowChanging : System.Data.DataRowChangeEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.Data.DataSysDescription("DataTableRowChangingDescr")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Data.DataRowChangeEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ocorre quando uma <see cref="T:System.Data.DataRow" /> está sendo alterada.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para obter mais informações, consulte [manipulação de eventos de DataTable](~/docs/framework/data/adonet/dataset-datatable-dataview/handling-datatable-events.md).  
  
   
  
## Examples  
 [!code-csharp[Classic WebData DataTable.RowChanging Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.RowChanging Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.RowChanging Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.RowChanging Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RowDeleted">
      <MemberSignature Language="C#" Value="public event System.Data.DataRowChangeEventHandler RowDeleted;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Data.DataRowChangeEventHandler RowDeleted" />
      <MemberSignature Language="DocId" Value="E:System.Data.DataTable.RowDeleted" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event RowDeleted As DataRowChangeEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Data::DataRowChangeEventHandler ^ RowDeleted;" />
      <MemberSignature Language="F#" Value="member this.RowDeleted : System.Data.DataRowChangeEventHandler " Usage="member this.RowDeleted : System.Data.DataRowChangeEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.Data.DataSysDescription("DataTableRowDeletedDescr")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Data.DataRowChangeEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ocorre depois que uma linha na tabela é excluída.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para obter mais informações, consulte [manipulação de eventos de DataTable](~/docs/framework/data/adonet/dataset-datatable-dataview/handling-datatable-events.md).  
  
   
  
## Examples  
 [!code-csharp[Classic WebData DataTable.RowDeleted Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.RowDeleted Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.RowDeleted Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.RowDeleted Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RowDeleting">
      <MemberSignature Language="C#" Value="public event System.Data.DataRowChangeEventHandler RowDeleting;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Data.DataRowChangeEventHandler RowDeleting" />
      <MemberSignature Language="DocId" Value="E:System.Data.DataTable.RowDeleting" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event RowDeleting As DataRowChangeEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Data::DataRowChangeEventHandler ^ RowDeleting;" />
      <MemberSignature Language="F#" Value="member this.RowDeleting : System.Data.DataRowChangeEventHandler " Usage="member this.RowDeleting : System.Data.DataRowChangeEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.Data.DataSysDescription("DataTableRowDeletingDescr")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Data.DataRowChangeEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ocorre antes de uma linha na tabela estar prestes a ser excluída.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para obter mais informações, consulte [manipulação de eventos de DataTable](~/docs/framework/data/adonet/dataset-datatable-dataview/handling-datatable-events.md).  
  
   
  
## Examples  
 [!code-csharp[Classic WebData DataTable.RowDeleting Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.RowDeleting Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.RowDeleting Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.RowDeleting Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Rows">
      <MemberSignature Language="C#" Value="public System.Data.DataRowCollection Rows { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Data.DataRowCollection Rows" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataTable.Rows" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Rows As DataRowCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Data::DataRowCollection ^ Rows { System::Data::DataRowCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Rows : System.Data.DataRowCollection" Usage="System.Data.DataTable.Rows" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.Data.DataSysDescription("DataTableRowsDescr")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Data.DataRowCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém a coleção de linhas que pertencem a essa tabela.</summary>
        <value>Um <see cref="T:System.Data.DataRowCollection" /> que contém objetos <see cref="T:System.Data.DataRow" />; caso contrário, um valor nulo se nenhum objeto <see cref="T:System.Data.DataRow" /> existir.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para criar um novo <xref:System.Data.DataRow>, você deve usar o <xref:System.Data.DataTable.NewRow%2A> método para retornar um novo objeto. Esse objeto é configurado automaticamente de acordo com o esquema definido para o <xref:System.Data.DataTable> por meio de sua coleção de <xref:System.Data.DataColumn> objetos. Depois de criar uma nova linha e definir os valores para cada coluna na linha, adicione a linha para o <xref:System.Data.DataRowCollection> usando o `Add` método.  
  
 Cada <xref:System.Data.DataRow> na coleção representa uma linha de dados na tabela. Para confirmar uma alteração para o valor de uma coluna na linha, você deve chamar o <xref:System.Data.DataTable.AcceptChanges%2A> método.  
  
   
  
## Examples  
 O exemplo a seguir mostra dois exemplos de retorno e linhas de configuração. O primeiro exemplo usa o <xref:System.Data.DataTable.Rows%2A> propriedade e imprime o valor de cada coluna para cada linha. O segundo exemplo usa o <xref:System.Data.DataTable> do objeto <xref:System.Data.DataTable.NewRow%2A> método para criar uma nova <xref:System.Data.DataRow> objeto com o esquema a <xref:System.Data.DataTable>. Depois de definir os valores de linha, a linha é adicionada para o <xref:System.Data.DataRowCollection> por meio de `Add` método.  
  
 [!code-csharp[Classic WebData DataTable.Rows Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.Rows Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.Rows Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.Rows Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Data.DataTable.AcceptChanges" />
        <altmember cref="T:System.Data.DataRow" />
        <altmember cref="T:System.Data.DataRowCollection" />
        <altmember cref="M:System.Data.DataTable.NewRow" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Select">
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Obtém uma matriz de objetos <see cref="T:System.Data.DataRow" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Select">
      <MemberSignature Language="C#" Value="public System.Data.DataRow[] Select ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.DataRow[] Select() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.Select" />
      <MemberSignature Language="VB.NET" Value="Public Function Select () As DataRow()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Data::DataRow ^&gt; ^ Select();" />
      <MemberSignature Language="F#" Value="member this.Select : unit -&gt; System.Data.DataRow[]" Usage="dataTable.Select " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataRow[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Obtém uma matriz de todos os objetos <see cref="T:System.Data.DataRow" />.</summary>
        <returns>Uma matriz de objetos de <see cref="T:System.Data.DataRow" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para garantir que a ordem de classificação apropriado, especificar critérios de classificação com <xref:System.Data.DataTable.Select%2A> ou <xref:System.Data.DataTable.Select%2A>.  
  
   
  
## Examples  
 O exemplo a seguir retorna uma matriz de <xref:System.Data.DataRow> objetos por meio de <xref:System.Data.DataTable.Select%2A> método.  
  
 [!code-csharp[Classic WebData DataTable.Select Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.Select Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.Select Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.Select Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Data.DataTable.CaseSensitive" />
      </Docs>
    </Member>
    <Member MemberName="Select">
      <MemberSignature Language="C#" Value="public System.Data.DataRow[] Select (string filterExpression);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.DataRow[] Select(string filterExpression) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.Select(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Select (filterExpression As String) As DataRow()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Data::DataRow ^&gt; ^ Select(System::String ^ filterExpression);" />
      <MemberSignature Language="F#" Value="member this.Select : string -&gt; System.Data.DataRow[]" Usage="dataTable.Select filterExpression" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataRow[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="filterExpression" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="filterExpression">Os critérios a serem usados para filtrar as linhas. Para ver exemplos de como filtrar linhas, consulte [DataView RowFilter Syntax [C#]](http://www.csharp-examples.net/dataview-rowfilter/).</param>
        <summary>Obtém uma matriz de todos os objetos <see cref="T:System.Data.DataRow" /> que correspondem aos critérios de filtro.</summary>
        <returns>Uma matriz de objetos de <see cref="T:System.Data.DataRow" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para criar o `filterExpression` argumento, usem as mesmas regras que se aplicam para o <xref:System.Data.DataColumn> da classe <xref:System.Data.DataColumn.Expression%2A> valor da propriedade para a criação de filtros.  
  
 Para garantir que a ordem de classificação apropriado, especificar critérios de classificação com <xref:System.Data.DataTable.Select%2A> ou <xref:System.Data.DataTable.Select%2A>.  
  
 Se a coluna no filtro contém um valor nulo, ele não fará parte do resultado.  
  
   
  
## Examples  
 O exemplo a seguir usa uma expressão de filtro para retornar uma matriz de <xref:System.Data.DataRow> objetos.  
  
 [!code-csharp[Classic WebData DataTable.Select1 Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.Select1 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.Select1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.Select1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Data.DataTable.CaseSensitive" />
      </Docs>
    </Member>
    <Member MemberName="Select">
      <MemberSignature Language="C#" Value="public System.Data.DataRow[] Select (string filterExpression, string sort);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.DataRow[] Select(string filterExpression, string sort) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.Select(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Select (filterExpression As String, sort As String) As DataRow()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Data::DataRow ^&gt; ^ Select(System::String ^ filterExpression, System::String ^ sort);" />
      <MemberSignature Language="F#" Value="member this.Select : string * string -&gt; System.Data.DataRow[]" Usage="dataTable.Select (filterExpression, sort)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataRow[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="filterExpression" Type="System.String" />
        <Parameter Name="sort" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="filterExpression">Os critérios a serem usados para filtrar as linhas. Para ver exemplos de como filtrar linhas, consulte [DataView RowFilter Syntax [C#]](http://www.csharp-examples.net/dataview-rowfilter/).</param>
        <param name="sort">Uma cadeia de caracteres que especifica a direção da coluna e da classificação.</param>
        <summary>Obtém uma matriz de todos os objetos <see cref="T:System.Data.DataRow" /> que correspondem aos critérios de filtro, na ordem de classificação especificada.</summary>
        <returns>Uma matriz de objetos <see cref="T:System.Data.DataRow" /> que correspondem à expressão de filtro.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para formar o `filterExpression` argumento, usem as mesmas regras para criar o <xref:System.Data.DataColumn> da classe <xref:System.Data.DataColumn.Expression%2A> valor da propriedade. O `Sort` argumento também usa as mesmas regras para a criação da classe <xref:System.Data.DataColumn.Expression%2A> cadeias de caracteres.  
  
 Se a coluna no filtro contém um valor nulo, ele não fará parte do resultado.  
  
   
  
## Examples  
 O exemplo a seguir usa uma expressão de filtro para retornar uma matriz de <xref:System.Data.DataRow> objetos.  
  
 [!code-csharp[Classic WebData DataTable.Select2 Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.Select2 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.Select2 Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.Select2 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Data.DataTable.CaseSensitive" />
      </Docs>
    </Member>
    <Member MemberName="Select">
      <MemberSignature Language="C#" Value="public System.Data.DataRow[] Select (string filterExpression, string sort, System.Data.DataViewRowState recordStates);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.DataRow[] Select(string filterExpression, string sort, valuetype System.Data.DataViewRowState recordStates) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.Select(System.String,System.String,System.Data.DataViewRowState)" />
      <MemberSignature Language="VB.NET" Value="Public Function Select (filterExpression As String, sort As String, recordStates As DataViewRowState) As DataRow()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Data::DataRow ^&gt; ^ Select(System::String ^ filterExpression, System::String ^ sort, System::Data::DataViewRowState recordStates);" />
      <MemberSignature Language="F#" Value="member this.Select : string * string * System.Data.DataViewRowState -&gt; System.Data.DataRow[]" Usage="dataTable.Select (filterExpression, sort, recordStates)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataRow[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="filterExpression" Type="System.String" />
        <Parameter Name="sort" Type="System.String" />
        <Parameter Name="recordStates" Type="System.Data.DataViewRowState" />
      </Parameters>
      <Docs>
        <param name="filterExpression">Os critérios a serem usados para filtrar as linhas. Para ver exemplos de como filtrar linhas, consulte [DataView RowFilter Syntax [C#]](http://www.csharp-examples.net/dataview-rowfilter/).</param>
        <param name="sort">Uma cadeia de caracteres que especifica a direção da coluna e da classificação.</param>
        <param name="recordStates">Um dos valores de <see cref="T:System.Data.DataViewRowState" />.</param>
        <summary>Obtém uma matriz de todos os objetos <see cref="T:System.Data.DataRow" /> que correspondem ao filtro, na ordem de classificação correspondente ao estado especificado.</summary>
        <returns>Uma matriz de objetos de <see cref="T:System.Data.DataRow" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para formar o `filterExpression` argumento, usem as mesmas regras para criar o <xref:System.Data.DataColumn> da classe <xref:System.Data.DataColumn.Expression%2A> valor da propriedade. O `Sort` argumento também usa as mesmas regras para a criação da classe <xref:System.Data.DataColumn.Expression%2A> cadeias de caracteres.  
  
 Se a coluna no filtro contém um valor nulo, ele não fará parte do resultado.  
  
   
  
## Examples  
 O exemplo a seguir usa um estado de registro e de expressão de filtro para retornar uma matriz de <xref:System.Data.DataRow> objetos.  
  
 [!code-csharp[Classic WebData DataTable.Select3 Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.Select3 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.Select3 Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.Select3 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Site">
      <MemberSignature Language="C#" Value="public override System.ComponentModel.ISite Site { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ComponentModel.ISite Site" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataTable.Site" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property Site As ISite" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::ComponentModel::ISite ^ Site { System::ComponentModel::ISite ^ get(); void set(System::ComponentModel::ISite ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Site : System.ComponentModel.ISite with get, set" Usage="System.Data.DataTable.Site" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ComponentModel.ISite</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define um <see cref="T:System.ComponentModel.ISite" /> para o <see cref="T:System.Data.DataTable" />.</summary>
        <value>Um <see cref="T:System.ComponentModel.ISite" /> para o <see cref="T:System.Data.DataTable" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sites de associar uma <xref:System.ComponentModel.Component> para um <xref:System.ComponentModel.Container> e habilitar a comunicação entre eles, bem como fornecem uma maneira para o contêiner gerenciar seus componentes.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.ComponentModel.IListSource.ContainsListCollection">
      <MemberSignature Language="C#" Value="bool System.ComponentModel.IListSource.ContainsListCollection { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.ComponentModel.IListSource.ContainsListCollection" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataTable.System#ComponentModel#IListSource#ContainsListCollection" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property ContainsListCollection As Boolean Implements IListSource.ContainsListCollection" />
      <MemberSignature Language="C++ CLI" Value="property bool System::ComponentModel::IListSource::ContainsListCollection { bool get(); };" />
      <MemberSignature Language="F#" Usage="System.ComponentModel.IListSource.ContainsListCollection" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Para obter uma descrição desse membro, consulte <see cref="P:System.ComponentModel.IListSource.ContainsListCollection" />.</summary>
        <value>
          <see langword="true" /> se a coleção for uma coleção de objetos <see cref="T:System.Collections.IList" />; caso contrário, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este membro é uma implementação do membro de interface explícita. Ele só pode ser usado quando a instância de <xref:System.Data.DataTable> é convertida em uma interface de <xref:System.ComponentModel.IListSource>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.ComponentModel.IListSource.GetList">
      <MemberSignature Language="C#" Value="System.Collections.IList IListSource.GetList ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.IList System.ComponentModel.IListSource.GetList() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.System#ComponentModel#IListSource#GetList" />
      <MemberSignature Language="VB.NET" Value="Function GetList () As IList Implements IListSource.GetList" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::IList ^ System.ComponentModel.IListSource.GetList() = System::ComponentModel::IListSource::GetList;" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IList</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Para obter uma descrição desse membro, consulte <see cref="M:System.ComponentModel.IListSource.GetList" />.</summary>
        <returns>Um <see cref="T:System.Collections.IList" /> que pode ser associado a uma fonte de dados de objeto.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este membro é uma implementação do membro de interface explícita. Ele só pode ser usado quando a instância de <xref:System.Data.DataTable> é convertida em uma interface de <xref:System.ComponentModel.IListSource>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.Serialization.ISerializable.GetObjectData">
      <MemberSignature Language="C#" Value="void ISerializable.GetObjectData (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.Serialization.ISerializable.GetObjectData(class System.Runtime.Serialization.SerializationInfo info, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.System#Runtime#Serialization#ISerializable#GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="VB.NET" Value="Sub GetObjectData (info As SerializationInfo, context As StreamingContext) Implements ISerializable.GetObjectData" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.Serialization.ISerializable.GetObjectData(System::Runtime::Serialization::SerializationInfo ^ info, System::Runtime::Serialization::StreamingContext context) = System::Runtime::Serialization::ISerializable::GetObjectData;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="info" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="info">To be added.</param>
        <param name="context">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Xml.Serialization.IXmlSerializable.GetSchema">
      <MemberSignature Language="C#" Value="System.Xml.Schema.XmlSchema IXmlSerializable.GetSchema ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Xml.Schema.XmlSchema System.Xml.Serialization.IXmlSerializable.GetSchema() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.System#Xml#Serialization#IXmlSerializable#GetSchema" />
      <MemberSignature Language="VB.NET" Value="Function GetSchema () As XmlSchema Implements IXmlSerializable.GetSchema" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Xml::Schema::XmlSchema ^ System.Xml.Serialization.IXmlSerializable.GetSchema() = System::Xml::Serialization::IXmlSerializable::GetSchema;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Xml.Serialization.IXmlSerializable.GetSchema</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.Schema.XmlSchema</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Para obter uma descrição desse membro, consulte <see cref="M:System.Xml.Serialization.IXmlSerializable.GetSchema" />.</summary>
        <returns>Um <see cref="T:System.Xml.Schema.XmlSchema" /> que descreve a representação XML do objeto produzido pelo método <see cref="M:System.Xml.Serialization.IXmlSerializable.WriteXml(System.Xml.XmlWriter)" /> e consumido pelo método <see cref="M:System.Xml.Serialization.IXmlSerializable.ReadXml(System.Xml.XmlReader)" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este membro é uma implementação do membro de interface explícita. Ele só pode ser usado quando a instância de <xref:System.Data.DataSet> é convertida em uma interface de <xref:System.Xml.Serialization.IXmlSerializable>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Xml.Serialization.IXmlSerializable.ReadXml">
      <MemberSignature Language="C#" Value="void IXmlSerializable.ReadXml (System.Xml.XmlReader reader);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Xml.Serialization.IXmlSerializable.ReadXml(class System.Xml.XmlReader reader) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.System#Xml#Serialization#IXmlSerializable#ReadXml(System.Xml.XmlReader)" />
      <MemberSignature Language="VB.NET" Value="Sub ReadXml (reader As XmlReader) Implements IXmlSerializable.ReadXml" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Xml.Serialization.IXmlSerializable.ReadXml(System::Xml::XmlReader ^ reader) = System::Xml::Serialization::IXmlSerializable::ReadXml;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Xml.Serialization.IXmlSerializable.ReadXml(System.Xml.XmlReader)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Xml.XmlReader" />
      </Parameters>
      <Docs>
        <param name="reader">Um XmlReader.</param>
        <summary>Para obter uma descrição desse membro, consulte <see cref="M:System.Xml.Serialization.IXmlSerializable.ReadXml(System.Xml.XmlReader)" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este membro é uma implementação do membro de interface explícita. Ele só pode ser usado quando a instância de <xref:System.Data.DataSet> é convertida em uma interface de <xref:System.Xml.Serialization.IXmlSerializable>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Xml.Serialization.IXmlSerializable.WriteXml">
      <MemberSignature Language="C#" Value="void IXmlSerializable.WriteXml (System.Xml.XmlWriter writer);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Xml.Serialization.IXmlSerializable.WriteXml(class System.Xml.XmlWriter writer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.System#Xml#Serialization#IXmlSerializable#WriteXml(System.Xml.XmlWriter)" />
      <MemberSignature Language="VB.NET" Value="Sub WriteXml (writer As XmlWriter) Implements IXmlSerializable.WriteXml" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Xml.Serialization.IXmlSerializable.WriteXml(System::Xml::XmlWriter ^ writer) = System::Xml::Serialization::IXmlSerializable::WriteXml;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Xml.Serialization.IXmlSerializable.WriteXml(System.Xml.XmlWriter)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Xml.XmlWriter" />
      </Parameters>
      <Docs>
        <param name="writer">Um XmlWriter.</param>
        <summary>Para obter uma descrição desse membro, consulte <see cref="M:System.Xml.Serialization.IXmlSerializable.WriteXml(System.Xml.XmlWriter)" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este membro é uma implementação do membro de interface explícita. Ele só pode ser usado quando a instância de <xref:System.Data.DataSet> é convertida em uma interface de <xref:System.Xml.Serialization.IXmlSerializable>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TableCleared">
      <MemberSignature Language="C#" Value="public event System.Data.DataTableClearEventHandler TableCleared;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Data.DataTableClearEventHandler TableCleared" />
      <MemberSignature Language="DocId" Value="E:System.Data.DataTable.TableCleared" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event TableCleared As DataTableClearEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Data::DataTableClearEventHandler ^ TableCleared;" />
      <MemberSignature Language="F#" Value="member this.TableCleared : System.Data.DataTableClearEventHandler " Usage="member this.TableCleared : System.Data.DataTableClearEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataTableClearEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ocorre depois que uma <see cref="T:System.Data.DataTable" /> é limpa.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Data.DataTable.TableCleared> evento é acionado imediatamente depois que todas as linhas têm sido limpo com êxito, mas antes de <xref:System.Data.DataTable.Clear%2A> método retorna o controle ao chamador. O <xref:System.Data.DataTable.TableCleared> evento não é acionado se houver em todas as exceções durante a operação de limpeza.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TableClearing">
      <MemberSignature Language="C#" Value="public event System.Data.DataTableClearEventHandler TableClearing;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Data.DataTableClearEventHandler TableClearing" />
      <MemberSignature Language="DocId" Value="E:System.Data.DataTable.TableClearing" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event TableClearing As DataTableClearEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Data::DataTableClearEventHandler ^ TableClearing;" />
      <MemberSignature Language="F#" Value="member this.TableClearing : System.Data.DataTableClearEventHandler " Usage="member this.TableClearing : System.Data.DataTableClearEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataTableClearEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ocorre quando uma <see cref="T:System.Data.DataTable" /> é limpa.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Data.DataTable.TableClearing> evento é disparado antes do processamento do <xref:System.Data.DataTable.Clear%2A> operação é iniciada. Esse evento sempre é disparado quando o <xref:System.Data.DataTable.Clear%2A> método é invocado, mesmo se a tabela não contiver nenhuma linha.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TableName">
      <MemberSignature Language="C#" Value="public string TableName { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string TableName" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataTable.TableName" />
      <MemberSignature Language="VB.NET" Value="Public Property TableName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ TableName { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.TableName : string with get, set" Usage="System.Data.DataTable.TableName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.ComponentModel.DefaultValue("")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0">
          <AttributeName>System.ComponentModel.RefreshProperties</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8">
          <AttributeName>System.ComponentModel.RefreshProperties(System.ComponentModel.RefreshProperties.All)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.Data.DataSysDescription("DataTableTableNameDescr")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define o nome de <see cref="T:System.Data.DataTable" />.</summary>
        <value>O nome do <see cref="T:System.Data.DataTable" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Data.DataTable.TableName%2A> é usado para retornar a esta tabela do pai <xref:System.Data.DataSet> do objeto <xref:System.Data.DataTableCollection> (retornado pela <xref:System.Data.DataSet.Tables%2A> propriedade).  
  
   
  
## Examples  
 O exemplo a seguir imprime o <xref:System.Data.DataTable.TableName%2A> para cada tabela em uma coleção de <xref:System.Data.DataTable> objetos.  
  
 [!code-csharp[Classic WebData DataTable.TableName Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.TableName Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.TableName Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.TableName Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <see langword="null" /> ou uma cadeia de caracteres vazia ("") é passada e essa tabela pertence a uma coleção.</exception>
        <exception cref="T:System.Data.DuplicateNameException">A tabela pertence a uma coleção que já tem uma tabela com o mesmo nome. (A comparação diferencia maiúsculas de minúsculas).</exception>
        <altmember cref="T:System.Data.DataSet" />
        <altmember cref="P:System.Data.DataSet.Tables" />
      </Docs>
    </Member>
    <Member MemberName="TableNewRow">
      <MemberSignature Language="C#" Value="public event System.Data.DataTableNewRowEventHandler TableNewRow;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Data.DataTableNewRowEventHandler TableNewRow" />
      <MemberSignature Language="DocId" Value="E:System.Data.DataTable.TableNewRow" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event TableNewRow As DataTableNewRowEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Data::DataTableNewRowEventHandler ^ TableNewRow;" />
      <MemberSignature Language="F#" Value="member this.TableNewRow : System.Data.DataTableNewRowEventHandler " Usage="member this.TableNewRow : System.Data.DataTableNewRowEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataTableNewRowEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ocorre quando um novo <see cref="T:System.Data.DataRow" /> é inserido.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 É acionado depois que um novo <xref:System.Data.DataRow> foi criado usando <xref:System.Data.DataTable.NewRow%2A>. Este evento é disparado antes da chamada `NewRow` retorno do método. O novo <xref:System.Data.DataRow> instância é desanexada; ele não foi adicionado à coleção.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="abstract member ToString : unit -&gt; string&#xA;override this.ToString : unit -&gt; string" Usage="dataTable.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Obterá o <see cref="P:System.Data.DataTable.TableName" /> e a <see cref="P:System.Data.DataTable.DisplayExpression" />, se houver algum como uma cadeia de caracteres concatenada.</summary>
        <returns>Uma cadeia de caracteres que consiste nos valores de <see cref="P:System.Data.DataTable.TableName" /> e <see cref="P:System.Data.DataTable.DisplayExpression" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Obtém o <xref:System.Data.DataTable.TableName%2A> e <xref:System.Data.DataTable.DisplayExpression%2A> para o <xref:System.Data.DataTable>.  
  
   
  
## Examples  
 O exemplo a seguir retorna o <xref:System.Data.DataTable.TableName%2A> e <xref:System.Data.DataTable.DisplayExpression%2A> usando o <xref:System.Data.DataTable.ToString%2A> método.  
  
 [!code-csharp[Classic WebData DataTable.ToString Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.ToString Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.ToString Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.ToString Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="WriteXml">
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Grava o conteúdo atual do <see cref="T:System.Data.DataTable" /> como XML.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O método <xref:System.Data.DataTable.WriteXml%2A> fornece uma maneira de gravar apenas dados ou dados e esquema em um <xref:System.Data.DataTable> a partir de um documento XML, e o método <xref:System.Data.DataTable.WriteXmlSchema%2A> grava apenas o esquema. Para gravar dados e esquema, use uma das sobrecargas que incluam o parâmetro <xref:System.Data.XmlWriteMode> e defina o valor como `WriteSchema`.  
  
 Observe que o mesmo é verdadeiro para os métodos <xref:System.Data.DataTable.ReadXml%2A> e <xref:System.Data.DataTable.ReadXmlSchema%2A>, respectivamente. Para ler dados XML, ou o esquema e os dados no `DataTable`, use o método `ReadXml`. Para ler apenas o esquema, use o método `ReadXmlSchema`.  
  
> [!NOTE]
>  Um <xref:System.InvalidOperationException> será lançado se um tipo de coluna no `DataRow` de leitura ou gravação implementa <xref:System.Dynamic.IDynamicMetaObjectProvider> e não implementa <xref:System.Xml.Serialization.IXmlSerializable>.  
  
   
  
## Examples  
 O aplicativo de console a seguir cria dois <xref:System.Data.DataTable> instâncias, adiciona cada um a um <xref:System.Data.DataSet>, cria um <xref:System.Data.DataRelation> relacionar as duas tabelas e, em seguida, usa o <xref:System.Data.DataTable.WriteXml%2A> método para gravar os dados contidos dentro da tabela pai para uma <xref:System.IO.TextWriter>. O exemplo demonstra o comportamento durante a definição do parâmetro `writeHierarchy` como cada um de seus valores.  
  
> [!NOTE]
>  Este exemplo mostra como usar uma das versões sobrecarregadas do WriteXml. Para obter outros exemplos que possam estar disponíveis, consulte os tópicos de sobrecarga individuais.  
  
 [!code-csharp[DataWorks DataTable.WriteXmlOverload#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTable.WriteXmlOverload/CS/source.cs#1)]
 [!code-vb[DataWorks DataTable.WriteXmlOverload#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTable.WriteXmlOverload/VB/source.vb#1)]  
  
 O exemplo exibe a seguinte saída na janela do console:  
  
```  
==============================  
Customer table, without hierarchy  
==============================  
<NewDataSet>  
  <xs:schema id="NewDataSet" xmlns="" xmlns:xs="http://www.w3.org/2001/XMLSchema  
" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">  
    <xs:element name="NewDataSet" msdata:IsDataSet="true" msdata:MainDataTable="Table1">  
      <xs:complexType>  
        <xs:choice minOccurs="0" maxOccurs="unbounded">  
          <xs:element name="Table1">  
            <xs:complexType>  
              <xs:sequence>  
                <xs:element name="ID" type="xs:int" />  
                <xs:element name="Name" type="xs:string" minOccurs="0" />  
              </xs:sequence>  
            </xs:complexType>  
          </xs:element>  
        </xs:choice>  
      </xs:complexType>  
      <xs:unique name="Constraint1" msdata:PrimaryKey="true">  
        <xs:selector xpath=".//Table1" />  
        <xs:field xpath="ID" />  
      </xs:unique>  
    </xs:element>  
  </xs:schema>  
  <Table1>  
    <ID>1</ID>  
    <Name>Mary</Name>  
  </Table1>  
  <Table1>  
    <ID>2</ID>  
    <Name>Andy</Name>  
  </Table1>  
  <Table1>  
    <ID>3</ID>  
    <Name>Peter</Name>  
  </Table1>  
  <Table1>  
    <ID>4</ID>  
    <Name>Russ</Name>  
  </Table1>  
</NewDataSet>  
==============================  
Customer table, with hierarchy  
==============================  
<NewDataSet>  
  <xs:schema id="NewDataSet" xmlns="" xmlns:xs="http://www.w3.org/2001/XMLSchema  
" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">  
    <xs:element name="NewDataSet" msdata:IsDataSet="true" msdata:MainDataTable="Table1">  
      <xs:complexType>  
        <xs:choice minOccurs="0" maxOccurs="unbounded">  
          <xs:element name="Table1">  
            <xs:complexType>  
              <xs:sequence>  
                <xs:element name="ID" type="xs:int" />  
                <xs:element name="Name" type="xs:string" minOccurs="0" />  
              </xs:sequence>  
            </xs:complexType>  
          </xs:element>  
          <xs:element name="Table2">  
            <xs:complexType>  
              <xs:sequence>  
                <xs:element name="OrderID" type="xs:int" />  
                <xs:element name="CustomerID" type="xs:int" minOccurs="0" />  
                <xs:element name="OrderDate" type="xs:dateTime" minOccurs="0" />  
  
              </xs:sequence>  
            </xs:complexType>  
          </xs:element>  
        </xs:choice>  
      </xs:complexType>  
      <xs:unique name="Constraint1" msdata:PrimaryKey="true">  
        <xs:selector xpath=".//Table1" />  
        <xs:field xpath="ID" />  
      </xs:unique>  
      <xs:unique name="Table2_Constraint1" msdata:ConstraintName="Constraint1" m  
sdata:PrimaryKey="true">  
        <xs:selector xpath=".//Table2" />  
        <xs:field xpath="OrderID" />  
      </xs:unique>  
      <xs:keyref name="CustomerOrder" refer="Constraint1">  
        <xs:selector xpath=".//Table2" />  
        <xs:field xpath="CustomerID" />  
      </xs:keyref>  
    </xs:element>  
  </xs:schema>  
  <Table1>  
    <ID>1</ID>  
    <Name>Mary</Name>  
  </Table1>  
  <Table1>  
    <ID>2</ID>  
    <Name>Andy</Name>  
  </Table1>  
  <Table1>  
    <ID>3</ID>  
    <Name>Peter</Name>  
  </Table1>  
  <Table1>  
    <ID>4</ID>  
    <Name>Russ</Name>  
  </Table1>  
  <Table2>  
    <OrderID>1</OrderID>  
    <CustomerID>1</CustomerID>  
    <OrderDate>2003-12-02T00:00:00.0000000-08:00</OrderDate>  
  </Table2>  
  <Table2>  
    <OrderID>2</OrderID>  
    <CustomerID>1</CustomerID>  
    <OrderDate>2004-01-03T00:00:00.0000000-08:00</OrderDate>  
  </Table2>  
  <Table2>  
    <OrderID>3</OrderID>  
    <CustomerID>2</CustomerID>  
    <OrderDate>2004-11-13T00:00:00.0000000-08:00</OrderDate>  
  </Table2>  
  <Table2>  
    <OrderID>4</OrderID>  
    <CustomerID>3</CustomerID>  
    <OrderDate>2004-05-16T00:00:00.0000000-07:00</OrderDate>  
  </Table2>  
  <Table2>  
    <OrderID>5</OrderID>  
    <CustomerID>3</CustomerID>  
    <OrderDate>2004-05-22T00:00:00.0000000-07:00</OrderDate>  
  </Table2>  
  <Table2>  
    <OrderID>6</OrderID>  
    <CustomerID>4</CustomerID>  
    <OrderDate>2004-06-15T00:00:00.0000000-07:00</OrderDate>  
  </Table2>  
</NewDataSet>  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="WriteXml">
      <MemberSignature Language="C#" Value="public void WriteXml (System.IO.Stream stream);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXml(class System.IO.Stream stream) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.WriteXml(System.IO.Stream)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXml(System::IO::Stream ^ stream);" />
      <MemberSignature Language="F#" Value="member this.WriteXml : System.IO.Stream -&gt; unit" Usage="dataTable.WriteXml stream" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
      </Parameters>
      <Docs>
        <param name="stream">O fluxo no qual os dados serão gravados.</param>
        <summary>Grava o conteúdo atual do <see cref="T:System.Data.DataTable" /> como XML usando o <see cref="T:System.IO.Stream" /> especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O método <xref:System.Data.DataTable.WriteXml%2A> fornece uma maneira de gravar apenas dados ou dados e esquema em um <xref:System.Data.DataTable> a partir de um documento XML, e o método <xref:System.Data.DataTable.WriteXmlSchema%2A> grava apenas o esquema. Para gravar dados e esquema, use uma das sobrecargas que inclua o parâmetro <xref:System.Data.XmlWriteMode> e defina o valor como `WriteSchema`.  
  
 Observe que o mesmo é verdadeiro para os métodos <xref:System.Data.DataTable.ReadXml%2A> e <xref:System.Data.DataTable.ReadXmlSchema%2A>, respectivamente. Para ler dados XML, ou o esquema e os dados no `DataTable`, use o método `ReadXml`. Para ler apenas o esquema, use o método `ReadXmlSchema`.  
  
> [!NOTE]
>  Um <xref:System.InvalidOperationException> será lançado se um tipo de coluna no `DataRow` de leitura ou gravação implementa <xref:System.Dynamic.IDynamicMetaObjectProvider> e não implementa <xref:System.Xml.Serialization.IXmlSerializable>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteXml">
      <MemberSignature Language="C#" Value="public void WriteXml (System.IO.TextWriter writer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXml(class System.IO.TextWriter writer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.WriteXml(System.IO.TextWriter)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteXml (writer As TextWriter)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXml(System::IO::TextWriter ^ writer);" />
      <MemberSignature Language="F#" Value="member this.WriteXml : System.IO.TextWriter -&gt; unit" Usage="dataTable.WriteXml writer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.IO.TextWriter" />
      </Parameters>
      <Docs>
        <param name="writer">O <see cref="T:System.IO.TextWriter" /> com o qual gravar o conteúdo.</param>
        <summary>Grava o conteúdo atual do <see cref="T:System.Data.DataTable" /> como XML usando o <see cref="T:System.IO.TextWriter" /> especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O método <xref:System.Data.DataTable.WriteXml%2A> fornece uma maneira de gravar apenas dados ou dados e esquema em um <xref:System.Data.DataTable> a partir de um documento XML, e o método <xref:System.Data.DataTable.WriteXmlSchema%2A> grava apenas o esquema. Para gravar dados e esquema, use uma das sobrecargas que inclua o parâmetro <xref:System.Data.XmlWriteMode> e defina o valor como `WriteSchema`.  
  
 Observe que o mesmo é verdadeiro para os métodos <xref:System.Data.DataTable.ReadXml%2A> e <xref:System.Data.DataTable.ReadXmlSchema%2A>, respectivamente. Para ler dados XML, ou o esquema e os dados no `DataTable`, use o método `ReadXml`. Para ler apenas o esquema, use o método `ReadXmlSchema`.  
  
> [!NOTE]
>  Um <xref:System.InvalidOperationException> será lançado se um tipo de coluna no `DataRow` de leitura ou gravação implementa <xref:System.Dynamic.IDynamicMetaObjectProvider> e não implementa <xref:System.Xml.Serialization.IXmlSerializable>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteXml">
      <MemberSignature Language="C#" Value="public void WriteXml (string fileName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXml(string fileName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.WriteXml(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteXml (fileName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXml(System::String ^ fileName);" />
      <MemberSignature Language="F#" Value="member this.WriteXml : string -&gt; unit" Usage="dataTable.WriteXml fileName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="fileName">O arquivo no qual os dados XML devem ser gravados.</param>
        <summary>Grava o conteúdo atual da <see cref="T:System.Data.DataTable" /> como XML usando o arquivo especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O método <xref:System.Data.DataTable.WriteXml%2A> fornece uma maneira de gravar apenas dados ou dados e esquema em um <xref:System.Data.DataTable> a partir de um documento XML, e o método <xref:System.Data.DataTable.WriteXmlSchema%2A> grava apenas o esquema. Para gravar dados e esquema, use uma das sobrecargas que inclua o parâmetro <xref:System.Data.XmlWriteMode> e defina o valor como `WriteSchema`.  
  
 Observe que o mesmo é verdadeiro para os métodos <xref:System.Data.DataTable.ReadXml%2A> e <xref:System.Data.DataTable.ReadXmlSchema%2A>, respectivamente. Para ler dados XML, ou o esquema e os dados no `DataTable`, use o método `ReadXml`. Para ler apenas o esquema, use o método `ReadXmlSchema`.  
  
> [!NOTE]
>  Um <xref:System.InvalidOperationException> será lançado se um tipo de coluna no `DataRow` de leitura ou gravação implementa <xref:System.Dynamic.IDynamicMetaObjectProvider> e não implementa <xref:System.Xml.Serialization.IXmlSerializable>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteXml">
      <MemberSignature Language="C#" Value="public void WriteXml (System.Xml.XmlWriter writer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXml(class System.Xml.XmlWriter writer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.WriteXml(System.Xml.XmlWriter)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteXml (writer As XmlWriter)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXml(System::Xml::XmlWriter ^ writer);" />
      <MemberSignature Language="F#" Value="member this.WriteXml : System.Xml.XmlWriter -&gt; unit" Usage="dataTable.WriteXml writer" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Xml.Serialization.IXmlSerializable.WriteXml(System.Xml.XmlWriter)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Xml.XmlWriter" />
      </Parameters>
      <Docs>
        <param name="writer">O <see cref="T:System.Xml.XmlWriter" /> com o qual o conteúdo será gravado.</param>
        <summary>Grava o conteúdo atual do <see cref="T:System.Data.DataTable" /> como XML usando o <see cref="T:System.Xml.XmlWriter" /> especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O método <xref:System.Data.DataTable.WriteXml%2A> fornece uma maneira de gravar apenas dados ou dados e esquema em um <xref:System.Data.DataTable> a partir de um documento XML, e o método <xref:System.Data.DataTable.WriteXmlSchema%2A> grava apenas o esquema. Para gravar dados e esquema, use uma das sobrecargas que incluam o parâmetro <xref:System.Data.XmlWriteMode> e defina o valor como `WriteSchema`.  
  
 Observe que o mesmo é verdadeiro para os métodos <xref:System.Data.DataTable.ReadXml%2A> e <xref:System.Data.DataTable.ReadXmlSchema%2A>, respectivamente. Para ler dados XML, ou o esquema e os dados no `DataTable`, use o método `ReadXml`. Para ler apenas o esquema, use o método `ReadXmlSchema`.  
  
> [!NOTE]
>  Um <xref:System.InvalidOperationException> será lançado se um tipo de coluna no `DataRow` de leitura ou gravação implementa <xref:System.Dynamic.IDynamicMetaObjectProvider> e não implementa <xref:System.Xml.Serialization.IXmlSerializable>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteXml">
      <MemberSignature Language="C#" Value="public void WriteXml (System.IO.Stream stream, bool writeHierarchy);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXml(class System.IO.Stream stream, bool writeHierarchy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.WriteXml(System.IO.Stream,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXml(System::IO::Stream ^ stream, bool writeHierarchy);" />
      <MemberSignature Language="F#" Value="member this.WriteXml : System.IO.Stream * bool -&gt; unit" Usage="dataTable.WriteXml (stream, writeHierarchy)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
        <Parameter Name="writeHierarchy" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="stream">O fluxo no qual os dados serão gravados.</param>
        <param name="writeHierarchy">Se for <see langword="true" />, grave o conteúdo da tabela atual e todos os descendentes. Se <see langword="false" /> (o valor padrão), grave apenas os dados da tabela atual.</param>
        <summary>Grava o conteúdo atual do <see cref="T:System.Data.DataTable" /> como XML usando o <see cref="T:System.IO.Stream" /> especificado. Para salvar os dados para a tabela e todos os descendentes, defina o parâmetro <paramref name="writeHierarchy" /> como <see langword="true" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use o método <xref:System.Data.DataTable.WriteXmlSchema%2A> para gravar o esquema de um <xref:System.Data.DataTable> em um documento XML. O esquema inclui tabela, relação e definições de restrição.  
  
 O esquema XML é gravado usando o padrão XSD.  
  
 Para gravar os dados em um documento XML, use o método <xref:System.Data.DataTable.WriteXml%2A>.  
  
 Normalmente, o método `WriteXml` grava os dados somente para a tabela atual. Para gravar os dados da tabela atual e todos os descendentes, tabelas relacionadas, chame um método com o parâmetro `writeHierarchy` definido como `true`.  
  
> [!NOTE]
>  Um <xref:System.InvalidOperationException> será lançado se um tipo de coluna no `DataRow` de leitura ou gravação implementa <xref:System.Dynamic.IDynamicMetaObjectProvider> e não implementa <xref:System.Xml.Serialization.IXmlSerializable>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteXml">
      <MemberSignature Language="C#" Value="public void WriteXml (System.IO.Stream stream, System.Data.XmlWriteMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXml(class System.IO.Stream stream, valuetype System.Data.XmlWriteMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.WriteXml(System.IO.Stream,System.Data.XmlWriteMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXml(System::IO::Stream ^ stream, System::Data::XmlWriteMode mode);" />
      <MemberSignature Language="F#" Value="member this.WriteXml : System.IO.Stream * System.Data.XmlWriteMode -&gt; unit" Usage="dataTable.WriteXml (stream, mode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
        <Parameter Name="mode" Type="System.Data.XmlWriteMode" />
      </Parameters>
      <Docs>
        <param name="stream">O fluxo no qual os dados serão gravados.</param>
        <param name="mode">Um dos valores de <see cref="T:System.Data.XmlWriteMode" />.</param>
        <summary>Grava os dados atuais e, opcionalmente, o esquema do <see cref="T:System.Data.DataTable" /> no arquivo especificado usando o <see cref="T:System.Data.XmlWriteMode" /> especificado. Para gravar o esquema, defina o valor do parâmetro <paramref name="mode" /> como <see langword="WriteSchema" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O método <xref:System.Data.DataTable.WriteXml%2A> fornece uma maneira de gravar apenas dados ou dados e esquema em um <xref:System.Data.DataTable> a partir de um documento XML, e o método <xref:System.Data.DataTable.WriteXmlSchema%2A> grava apenas o esquema. Para gravar dados e esquema, use uma das sobrecargas que inclua o parâmetro <xref:System.Data.XmlWriteMode> e defina o valor como `WriteSchema`.  
  
 Observe que o mesmo é verdadeiro para os métodos <xref:System.Data.DataTable.ReadXml%2A> e <xref:System.Data.DataTable.ReadXmlSchema%2A>, respectivamente. Para ler dados XML, ou o esquema e os dados no `DataTable`, use o método `ReadXml`. Para ler apenas o esquema, use o método `ReadXmlSchema`.  
  
> [!NOTE]
>  Um <xref:System.InvalidOperationException> será lançado se um tipo de coluna no `DataRow` de leitura ou gravação implementa <xref:System.Dynamic.IDynamicMetaObjectProvider> e não implementa <xref:System.Xml.Serialization.IXmlSerializable>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteXml">
      <MemberSignature Language="C#" Value="public void WriteXml (System.IO.TextWriter writer, bool writeHierarchy);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXml(class System.IO.TextWriter writer, bool writeHierarchy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.WriteXml(System.IO.TextWriter,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteXml (writer As TextWriter, writeHierarchy As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXml(System::IO::TextWriter ^ writer, bool writeHierarchy);" />
      <MemberSignature Language="F#" Value="member this.WriteXml : System.IO.TextWriter * bool -&gt; unit" Usage="dataTable.WriteXml (writer, writeHierarchy)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.IO.TextWriter" />
        <Parameter Name="writeHierarchy" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="writer">O <see cref="T:System.IO.TextWriter" /> com o qual gravar o conteúdo.</param>
        <param name="writeHierarchy">Se for <see langword="true" />, grave o conteúdo da tabela atual e todos os descendentes. Se <see langword="false" /> (o valor padrão), grave apenas os dados da tabela atual.</param>
        <summary>Grava o conteúdo atual do <see cref="T:System.Data.DataTable" /> como XML usando o <see cref="T:System.IO.TextWriter" /> especificado. Para salvar os dados para a tabela e todos os descendentes, defina o parâmetro <paramref name="writeHierarchy" /> como <see langword="true" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O método <xref:System.Data.DataTable.WriteXml%2A> fornece uma maneira de gravar apenas dados ou dados e esquema em um <xref:System.Data.DataTable> a partir de um documento XML, e o método <xref:System.Data.DataTable.WriteXmlSchema%2A> grava apenas o esquema. Para gravar dados e esquema, use uma das sobrecargas que inclua o parâmetro <xref:System.Data.XmlWriteMode> e defina o valor como `WriteSchema`.  
  
 Normalmente, o método `WriteXml` grava os dados somente para a tabela atual. Para gravar os dados da tabela atual e todos os seus descendentes, tabelas relacionadas, chame o método com o `writeHierarchy` parâmetro definido como `true`.  
  
> [!NOTE]
>  Um <xref:System.InvalidOperationException> será lançado se um tipo de coluna no `DataRow` de leitura ou gravação implementa <xref:System.Dynamic.IDynamicMetaObjectProvider> e não implementa <xref:System.Xml.Serialization.IXmlSerializable>.  
  
   
  
## Examples  
 O aplicativo de console a seguir cria dois <xref:System.Data.DataTable> instâncias, adiciona cada um a um <xref:System.Data.DataSet>, cria um <xref:System.Data.DataRelation> relacionar as duas tabelas e, em seguida, usa o <xref:System.Data.DataTable.WriteXml%2A> método para gravar os dados contidos dentro da tabela pai para uma <xref:System.IO.TextWriter>. O exemplo demonstra o comportamento ao definir a `writeHierarchy` parâmetro para `true`.  
  
 [!code-csharp[DataWorks DataTable.WriteXml#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTable.WriteXml/CS/source.cs#1)]
 [!code-vb[DataWorks DataTable.WriteXml#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTable.WriteXml/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteXml">
      <MemberSignature Language="C#" Value="public void WriteXml (System.IO.TextWriter writer, System.Data.XmlWriteMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXml(class System.IO.TextWriter writer, valuetype System.Data.XmlWriteMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.WriteXml(System.IO.TextWriter,System.Data.XmlWriteMode)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteXml (writer As TextWriter, mode As XmlWriteMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXml(System::IO::TextWriter ^ writer, System::Data::XmlWriteMode mode);" />
      <MemberSignature Language="F#" Value="member this.WriteXml : System.IO.TextWriter * System.Data.XmlWriteMode -&gt; unit" Usage="dataTable.WriteXml (writer, mode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.IO.TextWriter" />
        <Parameter Name="mode" Type="System.Data.XmlWriteMode" />
      </Parameters>
      <Docs>
        <param name="writer">O <see cref="T:System.IO.TextWriter" /> usado para gravar o documento.</param>
        <param name="mode">Um dos valores de <see cref="T:System.Data.XmlWriteMode" />.</param>
        <summary>Grava os dados atuais e, opcionalmente, o esquema do <see cref="T:System.Data.DataTable" /> usando o <see cref="T:System.IO.TextWriter" /> e o <see cref="T:System.Data.XmlWriteMode" /> especificados. Para gravar o esquema, defina o valor do parâmetro <paramref name="mode" /> como <see langword="WriteSchema" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O método <xref:System.Data.DataTable.WriteXml%2A> fornece uma maneira de gravar apenas dados ou dados e esquema em um <xref:System.Data.DataTable> a partir de um documento XML, e o método <xref:System.Data.DataTable.WriteXmlSchema%2A> grava apenas o esquema. Para gravar dados e esquema, use uma das sobrecargas que inclua o parâmetro <xref:System.Data.XmlWriteMode> e defina o valor como `WriteSchema`.  
  
 Observe que o mesmo é verdadeiro para os métodos <xref:System.Data.DataTable.ReadXml%2A> e <xref:System.Data.DataTable.ReadXmlSchema%2A>, respectivamente. Para ler dados XML, ou o esquema e os dados no `DataTable`, use o método `ReadXml`. Para ler apenas o esquema, use o método `ReadXmlSchema`.  
  
> [!NOTE]
>  Um <xref:System.InvalidOperationException> será lançado se um tipo de coluna no `DataRow` de leitura ou gravação implementa <xref:System.Dynamic.IDynamicMetaObjectProvider> e não implementa <xref:System.Xml.Serialization.IXmlSerializable>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteXml">
      <MemberSignature Language="C#" Value="public void WriteXml (string fileName, bool writeHierarchy);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXml(string fileName, bool writeHierarchy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.WriteXml(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteXml (fileName As String, writeHierarchy As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXml(System::String ^ fileName, bool writeHierarchy);" />
      <MemberSignature Language="F#" Value="member this.WriteXml : string * bool -&gt; unit" Usage="dataTable.WriteXml (fileName, writeHierarchy)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
        <Parameter Name="writeHierarchy" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="fileName">O arquivo no qual os dados XML devem ser gravados.</param>
        <param name="writeHierarchy">Se for <see langword="true" />, grave o conteúdo da tabela atual e todos os descendentes. Se <see langword="false" /> (o valor padrão), grave apenas os dados da tabela atual.</param>
        <summary>Grava o conteúdo atual da <see cref="T:System.Data.DataTable" /> como XML usando o arquivo especificado. Para salvar os dados para a tabela e todos os descendentes, defina o parâmetro <paramref name="writeHierarchy" /> como <see langword="true" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O método <xref:System.Data.DataTable.WriteXml%2A> fornece uma maneira de gravar apenas dados ou dados e esquema em um <xref:System.Data.DataTable> a partir de um documento XML, e o método <xref:System.Data.DataTable.WriteXmlSchema%2A> grava apenas o esquema. Para gravar dados e esquema, use uma das sobrecargas que inclua o parâmetro <xref:System.Data.XmlWriteMode> e defina o valor como `WriteSchema`.  
  
 Observe que o mesmo é verdadeiro para os métodos <xref:System.Data.DataTable.ReadXml%2A> e <xref:System.Data.DataTable.ReadXmlSchema%2A>, respectivamente. Para ler dados XML, ou o esquema e os dados no `DataTable`, use o método `ReadXml`. Para ler apenas o esquema, use o método `ReadXmlSchema`.  
  
 Normalmente, o método `WriteXml` grava os dados somente para a tabela atual. Para gravar os dados da tabela atual e todos os descendentes, tabelas relacionadas, chame um método com o parâmetro `writeHierarchy` definido como `true`.  
  
> [!NOTE]
>  Um <xref:System.InvalidOperationException> será lançado se um tipo de coluna no `DataRow` de leitura ou gravação implementa <xref:System.Dynamic.IDynamicMetaObjectProvider> e não implementa <xref:System.Xml.Serialization.IXmlSerializable>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteXml">
      <MemberSignature Language="C#" Value="public void WriteXml (string fileName, System.Data.XmlWriteMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXml(string fileName, valuetype System.Data.XmlWriteMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.WriteXml(System.String,System.Data.XmlWriteMode)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteXml (fileName As String, mode As XmlWriteMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXml(System::String ^ fileName, System::Data::XmlWriteMode mode);" />
      <MemberSignature Language="F#" Value="member this.WriteXml : string * System.Data.XmlWriteMode -&gt; unit" Usage="dataTable.WriteXml (fileName, mode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
        <Parameter Name="mode" Type="System.Data.XmlWriteMode" />
      </Parameters>
      <Docs>
        <param name="fileName">O nome do arquivo no qual os dados serão gravados.</param>
        <param name="mode">Um dos valores de <see cref="T:System.Data.XmlWriteMode" />.</param>
        <summary>Grava os dados atuais e, opcionalmente, o esquema da <see cref="T:System.Data.DataTable" /> usando o arquivo especificado e o <see cref="T:System.Data.XmlWriteMode" />. Para gravar o esquema, defina o valor do parâmetro <paramref name="mode" /> como <see langword="WriteSchema" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O método <xref:System.Data.DataTable.WriteXml%2A> fornece uma maneira de gravar apenas dados ou dados e esquema em um <xref:System.Data.DataTable> a partir de um documento XML, e o método <xref:System.Data.DataTable.WriteXmlSchema%2A> grava apenas o esquema. Para gravar dados e esquema, use uma das sobrecargas que incluam o parâmetro <xref:System.Data.XmlWriteMode> e defina o valor como `WriteSchema`.  
  
 Observe que o mesmo é verdadeiro para os métodos <xref:System.Data.DataTable.ReadXml%2A> e <xref:System.Data.DataTable.ReadXmlSchema%2A>, respectivamente. Para ler dados XML, ou o esquema e os dados no `DataTable`, use o método `ReadXml`. Para ler apenas o esquema, use o método `ReadXmlSchema`.  
  
> [!NOTE]
>  Um <xref:System.InvalidOperationException> será lançado se um tipo de coluna no `DataRow` de leitura ou gravação implementa <xref:System.Dynamic.IDynamicMetaObjectProvider> e não implementa <xref:System.Xml.Serialization.IXmlSerializable>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteXml">
      <MemberSignature Language="C#" Value="public void WriteXml (System.Xml.XmlWriter writer, bool writeHierarchy);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXml(class System.Xml.XmlWriter writer, bool writeHierarchy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.WriteXml(System.Xml.XmlWriter,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteXml (writer As XmlWriter, writeHierarchy As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXml(System::Xml::XmlWriter ^ writer, bool writeHierarchy);" />
      <MemberSignature Language="F#" Value="member this.WriteXml : System.Xml.XmlWriter * bool -&gt; unit" Usage="dataTable.WriteXml (writer, writeHierarchy)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Xml.XmlWriter" />
        <Parameter Name="writeHierarchy" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="writer">O <see cref="T:System.Xml.XmlWriter" /> com o qual o conteúdo será gravado.</param>
        <param name="writeHierarchy">Se for <see langword="true" />, grave o conteúdo da tabela atual e todos os descendentes. Se <see langword="false" /> (o valor padrão), grave apenas os dados da tabela atual.</param>
        <summary>Grava o conteúdo atual do <see cref="T:System.Data.DataTable" /> como XML usando o <see cref="T:System.Xml.XmlWriter" /> especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O método <xref:System.Data.DataTable.WriteXml%2A> fornece uma maneira de gravar apenas dados ou dados e esquema em um <xref:System.Data.DataTable> a partir de um documento XML, e o método <xref:System.Data.DataTable.WriteXmlSchema%2A> grava apenas o esquema. Para gravar dados e esquema, use uma das sobrecargas que incluam o parâmetro <xref:System.Data.XmlWriteMode> e defina o valor como `WriteSchema`.  
  
 Observe que o mesmo é verdadeiro para os métodos <xref:System.Data.DataTable.ReadXml%2A> e <xref:System.Data.DataTable.ReadXmlSchema%2A>, respectivamente. Para ler dados XML, ou o esquema e os dados no `DataTable`, use o método `ReadXml`. Para ler apenas o esquema, use o método `ReadXmlSchema`.  
  
 Normalmente, o método `WriteXml` grava os dados somente para a tabela atual. Para gravar os dados da tabela atual e seus todas descendentes, tabelas relacionadas, chame o método com o `writeHierarchy` parâmetro definido como `true`.  
  
> [!NOTE]
>  Um <xref:System.InvalidOperationException> será lançado se um tipo de coluna no `DataRow` de leitura ou gravação implementa <xref:System.Dynamic.IDynamicMetaObjectProvider> e não implementa <xref:System.Xml.Serialization.IXmlSerializable>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteXml">
      <MemberSignature Language="C#" Value="public void WriteXml (System.Xml.XmlWriter writer, System.Data.XmlWriteMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXml(class System.Xml.XmlWriter writer, valuetype System.Data.XmlWriteMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.WriteXml(System.Xml.XmlWriter,System.Data.XmlWriteMode)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteXml (writer As XmlWriter, mode As XmlWriteMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXml(System::Xml::XmlWriter ^ writer, System::Data::XmlWriteMode mode);" />
      <MemberSignature Language="F#" Value="member this.WriteXml : System.Xml.XmlWriter * System.Data.XmlWriteMode -&gt; unit" Usage="dataTable.WriteXml (writer, mode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Xml.XmlWriter" />
        <Parameter Name="mode" Type="System.Data.XmlWriteMode" />
      </Parameters>
      <Docs>
        <param name="writer">O <see cref="T:System.Xml.XmlWriter" /> usado para gravar o documento.</param>
        <param name="mode">Um dos valores de <see cref="T:System.Data.XmlWriteMode" />.</param>
        <summary>Grava os dados atuais e, opcionalmente, o esquema do <see cref="T:System.Data.DataTable" /> usando o <see cref="T:System.Xml.XmlWriter" /> e o <see cref="T:System.Data.XmlWriteMode" /> especificados. Para gravar o esquema, defina o valor do parâmetro <paramref name="mode" /> como <see langword="WriteSchema" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O método <xref:System.Data.DataTable.WriteXml%2A> fornece uma maneira de gravar apenas dados ou dados e esquema em um <xref:System.Data.DataTable> a partir de um documento XML, e o método <xref:System.Data.DataTable.WriteXmlSchema%2A> grava apenas o esquema. Para gravar dados e esquema, use uma das sobrecargas que incluam o parâmetro <xref:System.Data.XmlWriteMode> e defina o valor como `WriteSchema`.  
  
 Observe que o mesmo é verdadeiro para os métodos <xref:System.Data.DataTable.ReadXml%2A> e <xref:System.Data.DataTable.ReadXmlSchema%2A>, respectivamente. Para ler dados XML, ou o esquema e os dados no `DataTable`, use o método `ReadXml`. Para ler apenas o esquema, use o método `ReadXmlSchema`.  
  
> [!NOTE]
>  Um <xref:System.InvalidOperationException> será lançado se um tipo de coluna no `DataRow` de leitura ou gravação implementa <xref:System.Dynamic.IDynamicMetaObjectProvider> e não implementa <xref:System.Xml.Serialization.IXmlSerializable>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteXml">
      <MemberSignature Language="C#" Value="public void WriteXml (System.IO.Stream stream, System.Data.XmlWriteMode mode, bool writeHierarchy);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXml(class System.IO.Stream stream, valuetype System.Data.XmlWriteMode mode, bool writeHierarchy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.WriteXml(System.IO.Stream,System.Data.XmlWriteMode,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXml(System::IO::Stream ^ stream, System::Data::XmlWriteMode mode, bool writeHierarchy);" />
      <MemberSignature Language="F#" Value="member this.WriteXml : System.IO.Stream * System.Data.XmlWriteMode * bool -&gt; unit" Usage="dataTable.WriteXml (stream, mode, writeHierarchy)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
        <Parameter Name="mode" Type="System.Data.XmlWriteMode" />
        <Parameter Name="writeHierarchy" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="stream">O fluxo no qual os dados serão gravados.</param>
        <param name="mode">Um dos valores de <see cref="T:System.Data.XmlWriteMode" />.</param>
        <param name="writeHierarchy">Se for <see langword="true" />, grave o conteúdo da tabela atual e todos os descendentes. Se <see langword="false" /> (o valor padrão), grave apenas os dados da tabela atual.</param>
        <summary>Grava os dados atuais e, opcionalmente, o esquema do <see cref="T:System.Data.DataTable" /> no arquivo especificado usando o <see cref="T:System.Data.XmlWriteMode" /> especificado. Para gravar o esquema, defina o valor do parâmetro <paramref name="mode" /> como <see langword="WriteSchema" />. Para salvar os dados para a tabela e todos os descendentes, defina o parâmetro <paramref name="writeHierarchy" /> como <see langword="true" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O método <xref:System.Data.DataTable.WriteXml%2A> fornece uma maneira de gravar apenas dados ou dados e esquema em um `DataTable` a partir de um documento XML, e o método <xref:System.Data.DataTable.WriteXmlSchema%2A> grava apenas o esquema. Para gravar dados e esquema, use uma das sobrecargas que inclua o parâmetro `XmlWriteMode` e defina o valor como `WriteSchema`.  
  
 Observe que o mesmo é verdadeiro para os métodos <xref:System.Data.DataTable.ReadXml%2A> e <xref:System.Data.DataTable.ReadXmlSchema%2A>, respectivamente. Para ler dados XML, ou o esquema e os dados no `DataTable`, use o método `ReadXml`. Para ler apenas o esquema, use o método `ReadXmlSchema`.  
  
 Normalmente, o `WriteXml` método salva os dados apenas para a tabela atual. O método `WriteXml` fornece uma maneira de gravar apenas dados ou dados e esquema em um `DataTable` a partir de um documento XML, e o método `WriteXmlSchema` grava apenas o esquema. Para gravar dados e esquema, use uma das sobrecargas que inclua o parâmetro `XmlWriteMode` e defina o valor como `WriteSchema`.  
  
 Observe que o mesmo é verdadeiro para os métodos <xref:System.Data.DataTable.ReadXml%2A> e <xref:System.Data.DataTable.ReadXmlSchema%2A>, respectivamente. Para ler dados XML, ou o esquema e os dados no `DataTable`, use o método `ReadXml`. Para ler apenas o esquema, use o método `ReadXmlSchema`.  
  
 Normalmente, o método `WriteXml` grava os dados somente para a tabela atual. Para gravar os dados da tabela atual e todos os descendentes, tabelas relacionadas, chame um método com o parâmetro `writeHierarchy` definido como `true`.  
  
> [!NOTE]
>  Um <xref:System.InvalidOperationException> será lançado se um tipo de coluna no `DataRow` de leitura ou gravação implementa <xref:System.Dynamic.IDynamicMetaObjectProvider> e não implementa <xref:System.Xml.Serialization.IXmlSerializable>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteXml">
      <MemberSignature Language="C#" Value="public void WriteXml (System.IO.TextWriter writer, System.Data.XmlWriteMode mode, bool writeHierarchy);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXml(class System.IO.TextWriter writer, valuetype System.Data.XmlWriteMode mode, bool writeHierarchy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.WriteXml(System.IO.TextWriter,System.Data.XmlWriteMode,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteXml (writer As TextWriter, mode As XmlWriteMode, writeHierarchy As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXml(System::IO::TextWriter ^ writer, System::Data::XmlWriteMode mode, bool writeHierarchy);" />
      <MemberSignature Language="F#" Value="member this.WriteXml : System.IO.TextWriter * System.Data.XmlWriteMode * bool -&gt; unit" Usage="dataTable.WriteXml (writer, mode, writeHierarchy)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.IO.TextWriter" />
        <Parameter Name="mode" Type="System.Data.XmlWriteMode" />
        <Parameter Name="writeHierarchy" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="writer">O <see cref="T:System.IO.TextWriter" /> usado para gravar o documento.</param>
        <param name="mode">Um dos valores de <see cref="T:System.Data.XmlWriteMode" />.</param>
        <param name="writeHierarchy">Se for <see langword="true" />, grave o conteúdo da tabela atual e todos os descendentes. Se <see langword="false" /> (o valor padrão), grave apenas os dados da tabela atual.</param>
        <summary>Grava os dados atuais e, opcionalmente, o esquema do <see cref="T:System.Data.DataTable" /> usando o <see cref="T:System.IO.TextWriter" /> e o <see cref="T:System.Data.XmlWriteMode" /> especificados. Para gravar o esquema, defina o valor do parâmetro <paramref name="mode" /> como <see langword="WriteSchema" />. Para salvar os dados para a tabela e todos os descendentes, defina o parâmetro <paramref name="writeHierarchy" /> como <see langword="true" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O método <xref:System.Data.DataTable.WriteXml%2A> fornece uma maneira de gravar apenas dados ou dados e esquema em um <xref:System.Data.DataTable> a partir de um documento XML, e o método <xref:System.Data.DataTable.WriteXmlSchema%2A> grava apenas o esquema. Para gravar dados e esquema, use uma das sobrecargas que inclua o parâmetro <xref:System.Data.XmlWriteMode> e defina o valor como `WriteSchema`.  
  
 Observe que o mesmo é verdadeiro para os métodos <xref:System.Data.DataTable.ReadXml%2A> e <xref:System.Data.DataTable.ReadXmlSchema%2A>, respectivamente. Para ler dados XML, ou o esquema e os dados no `DataTable`, use o método `ReadXml`. Para ler apenas o esquema, use o método `ReadXmlSchema`.  
  
 Normalmente, o `WriteXml` método salva os dados apenas para a tabela atual. O método <xref:System.Data.DataTable.WriteXml%2A> fornece uma maneira de gravar apenas dados ou dados e esquema em um <xref:System.Data.DataTable> a partir de um documento XML, e o método <xref:System.Data.DataTable.WriteXmlSchema%2A> grava apenas o esquema. Para gravar dados e esquema, use uma das sobrecargas que inclua o parâmetro <xref:System.Data.XmlWriteMode> e defina o valor como `WriteSchema`.  
  
 Observe que o mesmo é verdadeiro para os métodos <xref:System.Data.DataTable.ReadXml%2A> e <xref:System.Data.DataTable.ReadXmlSchema%2A>, respectivamente. Para ler dados XML, ou o esquema e os dados no `DataTable`, use o método `ReadXml`. Para ler apenas o esquema, use o método `ReadXmlSchema`.  
  
 Normalmente, o método `WriteXml` grava os dados somente para a tabela atual. Para gravar os dados da tabela atual e todos os descendentes, tabelas relacionadas, chame um método com o parâmetro `writeHierarchy` definido como `true`.  
  
> [!NOTE]
>  Um <xref:System.InvalidOperationException> será lançado se um tipo de coluna no `DataRow` de leitura ou gravação implementa <xref:System.Dynamic.IDynamicMetaObjectProvider> e não implementa <xref:System.Xml.Serialization.IXmlSerializable>.  
  
   
  
## Examples  
 O aplicativo de console a seguir cria dois <xref:System.Data.DataTable> instâncias, adiciona cada um a um <xref:System.Data.DataSet>, cria um <xref:System.Data.DataRelation> relacionar as duas tabelas e, em seguida, usa o <xref:System.Data.DataTable.WriteXml%2A> método para gravar os dados contidos dentro da tabela pai para uma <xref:System.IO.TextWriter>. O exemplo demonstra o comportamento durante a definição do parâmetro `writeHierarchy` como cada um de seus valores.  
  
 [!code-csharp[DataWorks DataTable.WriteXmlIO#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTable.WriteXmlIO/CS/source.cs#1)]
 [!code-vb[DataWorks DataTable.WriteXmlIO#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTable.WriteXmlIO/VB/source.vb#1)]  
  
 O exemplo exibe a seguinte saída na janela do console:  
  
```  
==============================  
Customer table, without hierarchy  
==============================  
<NewDataSet>  
  <xs:schema id="NewDataSet" xmlns="" xmlns:xs="http://www.w3.org/2001/XMLSchema  
" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">  
    <xs:element name="NewDataSet" msdata:IsDataSet="true" msdata:MainDataTable="Table1">  
      <xs:complexType>  
        <xs:choice minOccurs="0" maxOccurs="unbounded">  
          <xs:element name="Table1">  
            <xs:complexType>  
              <xs:sequence>  
                <xs:element name="ID" type="xs:int" />  
                <xs:element name="Name" type="xs:string" minOccurs="0" />  
              </xs:sequence>  
            </xs:complexType>  
          </xs:element>  
        </xs:choice>  
      </xs:complexType>  
      <xs:unique name="Constraint1" msdata:PrimaryKey="true">  
        <xs:selector xpath=".//Table1" />  
        <xs:field xpath="ID" />  
      </xs:unique>  
    </xs:element>  
  </xs:schema>  
  <Table1>  
    <ID>1</ID>  
    <Name>Mary</Name>  
  </Table1>  
  <Table1>  
    <ID>2</ID>  
    <Name>Andy</Name>  
  </Table1>  
  <Table1>  
    <ID>3</ID>  
    <Name>Peter</Name>  
  </Table1>  
  <Table1>  
    <ID>4</ID>  
    <Name>Russ</Name>  
  </Table1>  
</NewDataSet>  
==============================  
Customer table, with hierarchy  
==============================  
<NewDataSet>  
  <xs:schema id="NewDataSet" xmlns="" xmlns:xs="http://www.w3.org/2001/XMLSchema  
" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">  
    <xs:element name="NewDataSet" msdata:IsDataSet="true" msdata:MainDataTable="Table1">  
      <xs:complexType>  
        <xs:choice minOccurs="0" maxOccurs="unbounded">  
          <xs:element name="Table1">  
            <xs:complexType>  
              <xs:sequence>  
                <xs:element name="ID" type="xs:int" />  
                <xs:element name="Name" type="xs:string" minOccurs="0" />  
              </xs:sequence>  
            </xs:complexType>  
          </xs:element>  
          <xs:element name="Table2">  
            <xs:complexType>  
              <xs:sequence>  
                <xs:element name="OrderID" type="xs:int" />  
                <xs:element name="CustomerID" type="xs:int" minOccurs="0" />  
                <xs:element name="OrderDate" type="xs:dateTime" minOccurs="0" />  
  
              </xs:sequence>  
            </xs:complexType>  
          </xs:element>  
        </xs:choice>  
      </xs:complexType>  
      <xs:unique name="Constraint1" msdata:PrimaryKey="true">  
        <xs:selector xpath=".//Table1" />  
        <xs:field xpath="ID" />  
      </xs:unique>  
      <xs:unique name="Table2_Constraint1" msdata:ConstraintName="Constraint1" m  
sdata:PrimaryKey="true">  
        <xs:selector xpath=".//Table2" />  
        <xs:field xpath="OrderID" />  
      </xs:unique>  
      <xs:keyref name="CustomerOrder" refer="Constraint1">  
        <xs:selector xpath=".//Table2" />  
        <xs:field xpath="CustomerID" />  
      </xs:keyref>  
    </xs:element>  
  </xs:schema>  
  <Table1>  
    <ID>1</ID>  
    <Name>Mary</Name>  
  </Table1>  
  <Table1>  
    <ID>2</ID>  
    <Name>Andy</Name>  
  </Table1>  
  <Table1>  
    <ID>3</ID>  
    <Name>Peter</Name>  
  </Table1>  
  <Table1>  
    <ID>4</ID>  
    <Name>Russ</Name>  
  </Table1>  
  <Table2>  
    <OrderID>1</OrderID>  
    <CustomerID>1</CustomerID>  
    <OrderDate>2003-12-02T00:00:00.0000000-08:00</OrderDate>  
  </Table2>  
  <Table2>  
    <OrderID>2</OrderID>  
    <CustomerID>1</CustomerID>  
    <OrderDate>2004-01-03T00:00:00.0000000-08:00</OrderDate>  
  </Table2>  
  <Table2>  
    <OrderID>3</OrderID>  
    <CustomerID>2</CustomerID>  
    <OrderDate>2004-11-13T00:00:00.0000000-08:00</OrderDate>  
  </Table2>  
  <Table2>  
    <OrderID>4</OrderID>  
    <CustomerID>3</CustomerID>  
    <OrderDate>2004-05-16T00:00:00.0000000-07:00</OrderDate>  
  </Table2>  
  <Table2>  
    <OrderID>5</OrderID>  
    <CustomerID>3</CustomerID>  
    <OrderDate>2004-05-22T00:00:00.0000000-07:00</OrderDate>  
  </Table2>  
  <Table2>  
    <OrderID>6</OrderID>  
    <CustomerID>4</CustomerID>  
    <OrderDate>2004-06-15T00:00:00.0000000-07:00</OrderDate>  
  </Table2>  
</NewDataSet>  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteXml">
      <MemberSignature Language="C#" Value="public void WriteXml (string fileName, System.Data.XmlWriteMode mode, bool writeHierarchy);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXml(string fileName, valuetype System.Data.XmlWriteMode mode, bool writeHierarchy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.WriteXml(System.String,System.Data.XmlWriteMode,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteXml (fileName As String, mode As XmlWriteMode, writeHierarchy As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXml(System::String ^ fileName, System::Data::XmlWriteMode mode, bool writeHierarchy);" />
      <MemberSignature Language="F#" Value="member this.WriteXml : string * System.Data.XmlWriteMode * bool -&gt; unit" Usage="dataTable.WriteXml (fileName, mode, writeHierarchy)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
        <Parameter Name="mode" Type="System.Data.XmlWriteMode" />
        <Parameter Name="writeHierarchy" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="fileName">O nome do arquivo no qual os dados serão gravados.</param>
        <param name="mode">Um dos valores de <see cref="T:System.Data.XmlWriteMode" />.</param>
        <param name="writeHierarchy">Se for <see langword="true" />, grave o conteúdo da tabela atual e todos os descendentes. Se <see langword="false" /> (o valor padrão), grave apenas os dados da tabela atual.</param>
        <summary>Grava os dados atuais e, opcionalmente, o esquema da <see cref="T:System.Data.DataTable" /> usando o arquivo especificado e o <see cref="T:System.Data.XmlWriteMode" />. Para gravar o esquema, defina o valor do parâmetro <paramref name="mode" /> como <see langword="WriteSchema" />. Para salvar os dados para a tabela e todos os descendentes, defina o parâmetro <paramref name="writeHierarchy" /> como <see langword="true" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O método <xref:System.Data.DataTable.WriteXml%2A> fornece uma maneira de gravar apenas dados ou dados e esquema em um <xref:System.Data.DataTable> a partir de um documento XML, e o método <xref:System.Data.DataTable.WriteXmlSchema%2A> grava apenas o esquema. Para gravar dados e esquema, use uma das sobrecargas que incluam o parâmetro <xref:System.Data.XmlWriteMode> e defina o valor como `WriteSchema`.  
  
 Observe que o mesmo é verdadeiro para os métodos <xref:System.Data.DataTable.ReadXml%2A> e <xref:System.Data.DataTable.ReadXmlSchema%2A>, respectivamente. Para ler dados XML, ou o esquema e os dados no `DataTable`, use o método `ReadXml`. Para ler apenas o esquema, use o método `ReadXmlSchema`.  
  
 Normalmente, o `WriteXml` método salva os dados apenas para a tabela atual. Se você quiser salvar os dados para a tabela atual e todas as do esquema, o <xref:System.Data.DataTable.WriteXml%2A> método fornece uma maneira de gravar apenas dados ou dados e esquema de um <xref:System.Data.DataTable> em um documento XML, enquanto o <xref:System.Data.DataTable.WriteXmlSchema%2A> método grava apenas o esquema. Para gravar dados e esquema, use uma das sobrecargas que incluam o parâmetro <xref:System.Data.XmlWriteMode> e defina o valor como `WriteSchema`.  
  
 Observe que o mesmo é verdadeiro para os métodos <xref:System.Data.DataTable.ReadXml%2A> e <xref:System.Data.DataTable.ReadXmlSchema%2A>, respectivamente. Para ler dados XML, ou o esquema e os dados no `DataTable`, use o método `ReadXml`. Para ler apenas o esquema, use o método `ReadXmlSchema`.  
  
 Normalmente, o método `WriteXml` grava os dados somente para a tabela atual. Para gravar os dados da tabela atual e todos os descendentes, tabelas relacionadas, chame o método com o `writeHierarchy` parâmetro definido como `true`.  
  
> [!NOTE]
>  Um <xref:System.InvalidOperationException> será lançado se um tipo de coluna no `DataRow` de leitura ou gravação implementa <xref:System.Dynamic.IDynamicMetaObjectProvider> e não implementa <xref:System.Xml.Serialization.IXmlSerializable>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteXml">
      <MemberSignature Language="C#" Value="public void WriteXml (System.Xml.XmlWriter writer, System.Data.XmlWriteMode mode, bool writeHierarchy);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXml(class System.Xml.XmlWriter writer, valuetype System.Data.XmlWriteMode mode, bool writeHierarchy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.WriteXml(System.Xml.XmlWriter,System.Data.XmlWriteMode,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteXml (writer As XmlWriter, mode As XmlWriteMode, writeHierarchy As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXml(System::Xml::XmlWriter ^ writer, System::Data::XmlWriteMode mode, bool writeHierarchy);" />
      <MemberSignature Language="F#" Value="member this.WriteXml : System.Xml.XmlWriter * System.Data.XmlWriteMode * bool -&gt; unit" Usage="dataTable.WriteXml (writer, mode, writeHierarchy)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Xml.XmlWriter" />
        <Parameter Name="mode" Type="System.Data.XmlWriteMode" />
        <Parameter Name="writeHierarchy" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="writer">O <see cref="T:System.Xml.XmlWriter" /> usado para gravar o documento.</param>
        <param name="mode">Um dos valores de <see cref="T:System.Data.XmlWriteMode" />.</param>
        <param name="writeHierarchy">Se for <see langword="true" />, grave o conteúdo da tabela atual e todos os descendentes. Se <see langword="false" /> (o valor padrão), grave apenas os dados da tabela atual.</param>
        <summary>Grava os dados atuais e, opcionalmente, o esquema do <see cref="T:System.Data.DataTable" /> usando o <see cref="T:System.Xml.XmlWriter" /> e o <see cref="T:System.Data.XmlWriteMode" /> especificados. Para gravar o esquema, defina o valor do parâmetro <paramref name="mode" /> como <see langword="WriteSchema" />. Para salvar os dados para a tabela e todos os descendentes, defina o parâmetro <paramref name="writeHierarchy" /> como <see langword="true" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O método <xref:System.Data.DataTable.WriteXml%2A> fornece uma maneira de gravar apenas dados ou dados e esquema em um <xref:System.Data.DataTable> a partir de um documento XML, e o método <xref:System.Data.DataTable.WriteXmlSchema%2A> grava apenas o esquema. Para gravar dados e esquema, use uma das sobrecargas que incluam o parâmetro <xref:System.Data.XmlWriteMode> e defina o valor como `WriteSchema`.  
  
 Observe que o mesmo é verdadeiro para os métodos <xref:System.Data.DataTable.ReadXml%2A> e <xref:System.Data.DataTable.ReadXmlSchema%2A>, respectivamente. Para ler dados XML, ou o esquema e os dados no `DataTable`, use o método `ReadXml`. Para ler apenas o esquema, use o método `ReadXmlSchema`.  
  
 Normalmente, o método `WriteXml` grava os dados somente para a tabela atual. Para gravar os dados da tabela atual e seus todas descendentes, tabelas relacionadas, chame o método com o `writeHierarchy` parâmetro definido como `true`.  
  
> [!NOTE]
>  Um <xref:System.InvalidOperationException> será lançado se um tipo de coluna no `DataRow` de leitura ou gravação implementa <xref:System.Dynamic.IDynamicMetaObjectProvider> e não implementa <xref:System.Xml.Serialization.IXmlSerializable>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="WriteXmlSchema">
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Grava a estrutura de dados atual do <see cref="T:System.Data.DataTable" /> como um esquema XML.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use o método <xref:System.Data.DataTable.WriteXmlSchema%2A> para gravar o esquema de um <xref:System.Data.DataTable> em um documento XML. O esquema inclui tabela, relação e definições de restrição.  
  
 O esquema XML é gravado usando o padrão XSD.  
  
 Para gravar os dados em um documento XML, use o método <xref:System.Data.DataTable.WriteXml%2A>.  
  
   
  
## Examples  
 O aplicativo de console a seguir cria dois <xref:System.Data.DataTable> instâncias, adiciona cada um a um <xref:System.Data.DataSet>, cria um <xref:System.Data.DataRelation> relacionar as duas tabelas e, em seguida, usa o <xref:System.Data.DataTable.WriteXmlSchema%2A> método para gravar os dados contidos dentro da tabela pai para uma <xref:System.IO.TextWriter>. O exemplo demonstra o comportamento durante a definição do parâmetro `writeHierarchy` como cada um de seus valores.  
  
> [!NOTE]
>  Este exemplo mostra como usar uma das versões sobrecarregadas do `WriteXmlSchema` para outros exemplos que podem estar disponíveis, consulte os tópicos de sobrecarga individuais.  
  
 [!code-csharp[DataWorks DataTable.WriteXmlSchemaOverload#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTable.WriteXmlSchemaOverload/CS/source.cs#1)]
 [!code-vb[DataWorks DataTable.WriteXmlSchemaOverload#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTable.WriteXmlSchemaOverload/VB/source.vb#1)]  
  
 O exemplo exibe a seguinte saída na janela do console:  
  
```  
==============================  
Customer table, without hierarchy  
==============================  
<?xml version="1.0" encoding="utf-16"?>  
<xs:schema id="NewDataSet" xmlns="" xmlns:xs="http://www.w3.org/2001/XMLSchema"  
xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">  
  <xs:element name="NewDataSet" msdata:IsDataSet="true" msdata:MainDataTable="Ta  
ble1">  
    <xs:complexType>  
      <xs:choice minOccurs="0" maxOccurs="unbounded">  
        <xs:element name="Table1">  
          <xs:complexType>  
            <xs:sequence>  
              <xs:element name="ID" type="xs:int" />  
              <xs:element name="Name" type="xs:string" minOccurs="0" />  
            </xs:sequence>  
          </xs:complexType>  
        </xs:element>  
      </xs:choice>  
    </xs:complexType>  
    <xs:unique name="Constraint1" msdata:PrimaryKey="true">  
      <xs:selector xpath=".//Table1" />  
      <xs:field xpath="ID" />  
    </xs:unique>  
  </xs:element>  
</xs:schema>  
==============================  
Customer table, with hierarchy  
==============================  
<?xml version="1.0" encoding="utf-16"?>  
<xs:schema id="NewDataSet" xmlns="" xmlns:xs="http://www.w3.org/2001/XMLSchema"  
xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">  
  <xs:element name="NewDataSet" msdata:IsDataSet="true" msdata:MainDataTable="Table1">  
    <xs:complexType>  
      <xs:choice minOccurs="0" maxOccurs="unbounded">  
        <xs:element name="Table1">  
          <xs:complexType>  
            <xs:sequence>  
              <xs:element name="ID" type="xs:int" />  
              <xs:element name="Name" type="xs:string" minOccurs="0" />  
            </xs:sequence>  
          </xs:complexType>  
        </xs:element>  
        <xs:element name="Table2">  
          <xs:complexType>  
            <xs:sequence>  
              <xs:element name="OrderID" type="xs:int" />  
              <xs:element name="CustomerID" type="xs:int" minOccurs="0" />  
              <xs:element name="OrderDate" type="xs:dateTime" minOccurs="0" />  
            </xs:sequence>  
          </xs:complexType>  
        </xs:element>  
      </xs:choice>  
    </xs:complexType>  
    <xs:unique name="Constraint1" msdata:PrimaryKey="true">  
      <xs:selector xpath=".//Table1" />  
      <xs:field xpath="ID" />  
    </xs:unique>  
    <xs:unique name="Table2_Constraint1" msdata:ConstraintName="Constraint1" msdata:PrimaryKey="true">  
      <xs:selector xpath=".//Table2" />  
      <xs:field xpath="OrderID" />  
    </xs:unique>  
    <xs:keyref name="CustomerOrder" refer="Constraint1">  
      <xs:selector xpath=".//Table2" />  
      <xs:field xpath="CustomerID" />  
    </xs:keyref>  
  </xs:element>  
</xs:schema>  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="WriteXmlSchema">
      <MemberSignature Language="C#" Value="public void WriteXmlSchema (System.IO.Stream stream);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXmlSchema(class System.IO.Stream stream) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.WriteXmlSchema(System.IO.Stream)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXmlSchema(System::IO::Stream ^ stream);" />
      <MemberSignature Language="F#" Value="member this.WriteXmlSchema : System.IO.Stream -&gt; unit" Usage="dataTable.WriteXmlSchema stream" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
      </Parameters>
      <Docs>
        <param name="stream">O fluxo no qual o esquema XML será gravado.</param>
        <summary>Grava a estrutura de dados atual do <see cref="T:System.Data.DataTable" /> como um esquema XML para o fluxo especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use o método <xref:System.Data.DataTable.WriteXmlSchema%2A> para gravar o esquema de um <xref:System.Data.DataTable> em um documento XML. O esquema inclui tabela, relação e definições de restrição.  
  
 O esquema XML é gravado usando o padrão XSD.  
  
 Para gravar os dados em um documento XML, use o método <xref:System.Data.DataTable.WriteXml%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteXmlSchema">
      <MemberSignature Language="C#" Value="public void WriteXmlSchema (System.IO.TextWriter writer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXmlSchema(class System.IO.TextWriter writer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.WriteXmlSchema(System.IO.TextWriter)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteXmlSchema (writer As TextWriter)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXmlSchema(System::IO::TextWriter ^ writer);" />
      <MemberSignature Language="F#" Value="member this.WriteXmlSchema : System.IO.TextWriter -&gt; unit" Usage="dataTable.WriteXmlSchema writer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.IO.TextWriter" />
      </Parameters>
      <Docs>
        <param name="writer">O <see cref="T:System.IO.TextWriter" /> com o qual gravar.</param>
        <summary>Grava a estrutura de dados atual do <see cref="T:System.Data.DataTable" /> como um esquema XML usando o <see cref="T:System.IO.TextWriter" /> especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use o método <xref:System.Data.DataTable.WriteXmlSchema%2A> para gravar o esquema de um <xref:System.Data.DataTable> em um documento XML. O esquema inclui tabela, relação e definições de restrição.  
  
 O esquema XML é gravado usando o padrão XSD.  
  
 Para gravar os dados em um documento XML, use o método <xref:System.Data.DataTable.WriteXml%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteXmlSchema">
      <MemberSignature Language="C#" Value="public void WriteXmlSchema (string fileName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXmlSchema(string fileName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.WriteXmlSchema(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteXmlSchema (fileName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXmlSchema(System::String ^ fileName);" />
      <MemberSignature Language="F#" Value="member this.WriteXmlSchema : string -&gt; unit" Usage="dataTable.WriteXmlSchema fileName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="fileName">O nome do arquivo a ser usado.</param>
        <summary>Grava a estrutura de dados atual do <see cref="T:System.Data.DataTable" /> como um esquema XML para o arquivo especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use o método <xref:System.Data.DataTable.WriteXmlSchema%2A> para gravar o esquema de um <xref:System.Data.DataTable> em um documento XML. O esquema inclui tabela, relação e definições de restrição.  
  
 O esquema XML é gravado usando o padrão XSD.  
  
 Para gravar os dados em um documento XML, use o método <xref:System.Data.DataTable.WriteXml%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteXmlSchema">
      <MemberSignature Language="C#" Value="public void WriteXmlSchema (System.Xml.XmlWriter writer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXmlSchema(class System.Xml.XmlWriter writer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.WriteXmlSchema(System.Xml.XmlWriter)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteXmlSchema (writer As XmlWriter)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXmlSchema(System::Xml::XmlWriter ^ writer);" />
      <MemberSignature Language="F#" Value="member this.WriteXmlSchema : System.Xml.XmlWriter -&gt; unit" Usage="dataTable.WriteXmlSchema writer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Xml.XmlWriter" />
      </Parameters>
      <Docs>
        <param name="writer">O <see cref="T:System.Xml.XmlWriter" /> a ser usado.</param>
        <summary>Grava a estrutura de dados atual do <see cref="T:System.Data.DataTable" /> como um esquema XML usando o <see cref="T:System.Xml.XmlWriter" /> especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use o método <xref:System.Data.DataTable.WriteXmlSchema%2A> para gravar o esquema de um <xref:System.Data.DataTable> em um documento XML. O esquema inclui tabela, relação e definições de restrição.  
  
 O esquema XML é gravado usando o padrão XSD.  
  
 Para gravar os dados em um documento XML, use o método <xref:System.Data.DataTable.WriteXml%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteXmlSchema">
      <MemberSignature Language="C#" Value="public void WriteXmlSchema (System.IO.Stream stream, bool writeHierarchy);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXmlSchema(class System.IO.Stream stream, bool writeHierarchy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.WriteXmlSchema(System.IO.Stream,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXmlSchema(System::IO::Stream ^ stream, bool writeHierarchy);" />
      <MemberSignature Language="F#" Value="member this.WriteXmlSchema : System.IO.Stream * bool -&gt; unit" Usage="dataTable.WriteXmlSchema (stream, writeHierarchy)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
        <Parameter Name="writeHierarchy" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="stream">O fluxo no qual o esquema XML será gravado.</param>
        <param name="writeHierarchy">Se for <see langword="true" />, grave o esquema da tabela atual e todos os descendentes. Se <see langword="false" /> (o valor padrão), grave apenas o esquema da tabela atual.</param>
        <summary>Grava a estrutura de dados atual do <see cref="T:System.Data.DataTable" /> como um esquema XML para o fluxo especificado. Para salvar o esquema da tabela e todos os descendentes, defina o parâmetro <paramref name="writeHierarchy" /> como <see langword="true" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use o método <xref:System.Data.DataTable.WriteXmlSchema%2A> para gravar o esquema de um <xref:System.Data.DataTable> em um documento XML. O esquema inclui tabela, relação e definições de restrição.  
  
 O esquema XML é gravado usando o padrão XSD.  
  
 Para gravar os dados em um documento XML, use o método <xref:System.Data.DataTable.WriteXml%2A>.  
  
 Normalmente, o método `WriteXmlSchema` grava o esquema somente para a tabela atual. Para gravar o esquema da tabela atual e o descendente inteiro, tabelas relacionadas, chame um método com o parâmetro `writeHierarchy` definido como `true`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteXmlSchema">
      <MemberSignature Language="C#" Value="public void WriteXmlSchema (System.IO.TextWriter writer, bool writeHierarchy);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXmlSchema(class System.IO.TextWriter writer, bool writeHierarchy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.WriteXmlSchema(System.IO.TextWriter,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteXmlSchema (writer As TextWriter, writeHierarchy As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXmlSchema(System::IO::TextWriter ^ writer, bool writeHierarchy);" />
      <MemberSignature Language="F#" Value="member this.WriteXmlSchema : System.IO.TextWriter * bool -&gt; unit" Usage="dataTable.WriteXmlSchema (writer, writeHierarchy)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.IO.TextWriter" />
        <Parameter Name="writeHierarchy" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="writer">O <see cref="T:System.IO.TextWriter" /> com o qual gravar.</param>
        <param name="writeHierarchy">Se for <see langword="true" />, grave o esquema da tabela atual e todos os descendentes. Se <see langword="false" /> (o valor padrão), grave apenas o esquema da tabela atual.</param>
        <summary>Grava a estrutura de dados atual do <see cref="T:System.Data.DataTable" /> como um esquema XML usando o <see cref="T:System.IO.TextWriter" /> especificado. Para salvar o esquema da tabela e todos os descendentes, defina o parâmetro <paramref name="writeHierarchy" /> como <see langword="true" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use o método <xref:System.Data.DataTable.WriteXmlSchema%2A> para gravar o esquema de um <xref:System.Data.DataTable> em um documento XML. O esquema inclui tabela, relação e definições de restrição.  
  
 O esquema XML é gravado usando o padrão XSD.  
  
 Para gravar os dados em um documento XML, use o método <xref:System.Data.DataTable.WriteXml%2A>.  
  
 Normalmente, o método `WriteXmlSchema` grava o esquema somente para a tabela atual. Para gravar o esquema da tabela atual e o descendente inteiro, tabelas relacionadas, chame um método com o parâmetro `writeHierarchy` definido como `true`.  
  
   
  
## Examples  
 O aplicativo de console a seguir cria dois <xref:System.Data.DataTable> instâncias, adiciona cada um a um <xref:System.Data.DataSet>, cria um <xref:System.Data.DataRelation> relacionar as duas tabelas e, em seguida, usa o <xref:System.Data.DataTable.WriteXmlSchema%2A> método para gravar os dados contidos dentro da tabela pai para uma <xref:System.IO.TextWriter>. O exemplo demonstra o comportamento durante a definição do parâmetro `writeHierarchy` como cada um de seus valores.  
  
 [!code-csharp[DataWorks DataTable.WriteXmlSchema#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTable.WriteXmlSchema/CS/source.cs#1)]
 [!code-vb[DataWorks DataTable.WriteXmlSchema#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTable.WriteXmlSchema/VB/source.vb#1)]  
  
 O exemplo exibe a seguinte saída na janela do console:  
  
```  
==============================  
Customer table, without hierarchy  
==============================  
<?xml version="1.0" encoding="utf-16"?>  
<xs:schema id="NewDataSet" xmlns="" xmlns:xs="http://www.w3.org/2001/XMLSchema"  
xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">  
  <xs:element name="NewDataSet" msdata:IsDataSet="true" msdata:MainDataTable="Ta  
ble1">  
    <xs:complexType>  
      <xs:choice minOccurs="0" maxOccurs="unbounded">  
        <xs:element name="Table1">  
          <xs:complexType>  
            <xs:sequence>  
              <xs:element name="ID" type="xs:int" />  
              <xs:element name="Name" type="xs:string" minOccurs="0" />  
            </xs:sequence>  
          </xs:complexType>  
        </xs:element>  
      </xs:choice>  
    </xs:complexType>  
    <xs:unique name="Constraint1" msdata:PrimaryKey="true">  
      <xs:selector xpath=".//Table1" />  
      <xs:field xpath="ID" />  
    </xs:unique>  
  </xs:element>  
</xs:schema>  
==============================  
Customer table, with hierarchy  
==============================  
<?xml version="1.0" encoding="utf-16"?>  
<xs:schema id="NewDataSet" xmlns="" xmlns:xs="http://www.w3.org/2001/XMLSchema"  
xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">  
  <xs:element name="NewDataSet" msdata:IsDataSet="true" msdata:MainDataTable="Table1">  
    <xs:complexType>  
      <xs:choice minOccurs="0" maxOccurs="unbounded">  
        <xs:element name="Table1">  
          <xs:complexType>  
            <xs:sequence>  
              <xs:element name="ID" type="xs:int" />  
              <xs:element name="Name" type="xs:string" minOccurs="0" />  
            </xs:sequence>  
          </xs:complexType>  
        </xs:element>  
        <xs:element name="Table2">  
          <xs:complexType>  
            <xs:sequence>  
              <xs:element name="OrderID" type="xs:int" />  
              <xs:element name="CustomerID" type="xs:int" minOccurs="0" />  
              <xs:element name="OrderDate" type="xs:dateTime" minOccurs="0" />  
            </xs:sequence>  
          </xs:complexType>  
        </xs:element>  
      </xs:choice>  
    </xs:complexType>  
    <xs:unique name="Constraint1" msdata:PrimaryKey="true">  
      <xs:selector xpath=".//Table1" />  
      <xs:field xpath="ID" />  
    </xs:unique>  
    <xs:unique name="Table2_Constraint1" msdata:ConstraintName="Constraint1" msdata:PrimaryKey="true">  
      <xs:selector xpath=".//Table2" />  
      <xs:field xpath="OrderID" />  
    </xs:unique>  
    <xs:keyref name="CustomerOrder" refer="Constraint1">  
      <xs:selector xpath=".//Table2" />  
      <xs:field xpath="CustomerID" />  
    </xs:keyref>  
  </xs:element>  
</xs:schema>  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteXmlSchema">
      <MemberSignature Language="C#" Value="public void WriteXmlSchema (string fileName, bool writeHierarchy);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXmlSchema(string fileName, bool writeHierarchy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.WriteXmlSchema(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteXmlSchema (fileName As String, writeHierarchy As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXmlSchema(System::String ^ fileName, bool writeHierarchy);" />
      <MemberSignature Language="F#" Value="member this.WriteXmlSchema : string * bool -&gt; unit" Usage="dataTable.WriteXmlSchema (fileName, writeHierarchy)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
        <Parameter Name="writeHierarchy" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="fileName">O nome do arquivo a ser usado.</param>
        <param name="writeHierarchy">Se for <see langword="true" />, grave o esquema da tabela atual e todos os descendentes. Se <see langword="false" /> (o valor padrão), grave apenas o esquema da tabela atual.</param>
        <summary>Grava a estrutura de dados atual do <see cref="T:System.Data.DataTable" /> como um esquema XML para o arquivo especificado. Para salvar o esquema da tabela e todos os descendentes, defina o parâmetro <paramref name="writeHierarchy" /> como <see langword="true" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use o método <xref:System.Data.DataTable.WriteXmlSchema%2A> para gravar o esquema de um <xref:System.Data.DataTable> em um documento XML. O esquema inclui tabela, relação e definições de restrição.  
  
 O esquema XML é gravado usando o padrão XSD.  
  
 Para gravar os dados em um documento XML, use o método <xref:System.Data.DataTable.WriteXml%2A>.  
  
 Normalmente, o método `WriteXmlSchema` grava o esquema somente para a tabela atual. Para gravar o esquema da tabela atual e o descendente inteiro, tabelas relacionadas, chame um método com o parâmetro `writeHierarchy` definido como `true`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteXmlSchema">
      <MemberSignature Language="C#" Value="public void WriteXmlSchema (System.Xml.XmlWriter writer, bool writeHierarchy);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXmlSchema(class System.Xml.XmlWriter writer, bool writeHierarchy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.WriteXmlSchema(System.Xml.XmlWriter,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteXmlSchema (writer As XmlWriter, writeHierarchy As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXmlSchema(System::Xml::XmlWriter ^ writer, bool writeHierarchy);" />
      <MemberSignature Language="F#" Value="member this.WriteXmlSchema : System.Xml.XmlWriter * bool -&gt; unit" Usage="dataTable.WriteXmlSchema (writer, writeHierarchy)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Xml.XmlWriter" />
        <Parameter Name="writeHierarchy" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="writer">O <see cref="T:System.Xml.XmlWriter" /> usado para gravar o documento.</param>
        <param name="writeHierarchy">Se for <see langword="true" />, grave o esquema da tabela atual e todos os descendentes. Se <see langword="false" /> (o valor padrão), grave apenas o esquema da tabela atual.</param>
        <summary>Grava a estrutura de dados atual do <see cref="T:System.Data.DataTable" /> como um esquema XML usando o <see cref="T:System.Xml.XmlWriter" /> especificado. Para salvar o esquema da tabela e todos os descendentes, defina o parâmetro <paramref name="writeHierarchy" /> como <see langword="true" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use o método <xref:System.Data.DataTable.WriteXmlSchema%2A> para gravar o esquema de um <xref:System.Data.DataTable> em um documento XML. O esquema inclui tabela, relação e definições de restrição.  
  
 O esquema XML é gravado usando o padrão XSD.  
  
 Para gravar os dados em um documento XML, use o método <xref:System.Data.DataTable.WriteXml%2A>.  
  
 Normalmente, o método `WriteXmlSchema` grava o esquema somente para a tabela atual. Para gravar o esquema da tabela atual e o descendente inteiro, tabelas relacionadas, chame um método com o parâmetro `writeHierarchy` definido como `true`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>