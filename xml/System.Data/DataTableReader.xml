<Type Name="DataTableReader" FullName="System.Data.DataTableReader">
  <Metadata><Meta Name="ms.openlocfilehash" Value="29593a8cafbdc6b69f6caeda60868612a408b7dc" /><Meta Name="ms.sourcegitcommit" Value="434f60616a9793fa8436744549fc856e94f7a648" /><Meta Name="ms.translationtype" Value="HT" /><Meta Name="ms.contentlocale" Value="pt-BR" /><Meta Name="ms.lasthandoff" Value="08/24/2018" /><Meta Name="ms.locfileid" Value="37670265" /></Metadata><TypeSignature Language="C#" Value="public sealed class DataTableReader : System.Data.Common.DbDataReader" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit DataTableReader extends System.Data.Common.DbDataReader" />
  <TypeSignature Language="DocId" Value="T:System.Data.DataTableReader" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class DataTableReader&#xA;Inherits DbDataReader" />
  <TypeSignature Language="C++ CLI" Value="public ref class DataTableReader sealed : System::Data::Common::DbDataReader" />
  <TypeSignature Language="F#" Value="type DataTableReader = class&#xA;    inherit DbDataReader" />
  <AssemblyInfo>
    <AssemblyName>System.Data</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Data.Common</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Data.Common.DbDataReader</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>O <see cref="T:System.Data.DataTableReader" /> obtém o conteúdo de um ou mais objetos <see cref="T:System.Data.DataTable" /> na forma de um ou mais conjuntos de resultados somente leitura de somente avanço.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Data.DataTableReader> funciona bem como qualquer outro leitor de dados, como o <xref:System.Data.SqlClient.SqlDataReader>, exceto que o <xref:System.Data.DataTableReader> fornece para iterar em linhas em um <xref:System.Data.DataTable>. Em outras palavras, ele fornece para iterar sobre linhas em um cache. Os dados em cache podem ser modificados enquanto o <xref:System.Data.DataTableReader> estiver ativo, e o leitor automaticamente mantém sua posição.  
  
 Quando você cria um <xref:System.Data.DataTableReader> de um <xref:System.Data.DataTable>, resultante <xref:System.Data.DataTableReader> objeto contém um conjunto de resultados com os mesmos dados que o <xref:System.Data.DataTable> do qual ele foi criado, exceto para quaisquer linhas que foram marcadas como excluídas. As colunas aparecem na mesma ordem como original <xref:System.Data.DataTable>. A estrutura do resultado retornado é idêntica no esquema e os dados para o original <xref:System.Data.DataTable>. Um <xref:System.Data.DataTableReader> que foi criado chamando o <xref:System.Data.DataSet.CreateDataReader*> método de um <xref:System.Data.DataSet> objeto contém vários conjuntos de resultados se o <xref:System.Data.DataSet> contém mais de uma tabela. Os resultados estão na mesma sequência como o <xref:System.Data.DataTable> objetos na <xref:System.Data.DataTableCollection> da <xref:System.Data.DataSet> objeto.  
  
 O conjunto de resultados retornado contém apenas a versão atual de cada <xref:System.Data.DataRow>; linhas que são marcadas para exclusão são ignoradas.  
  
 O `DataTableReader` fornece um estável iterador; ou seja, o conteúdo do `DataTableReader` não serão invalidadas se o tamanho da coleção subjacente é modificado durante a iteração. Por exemplo, se um ou mais as linhas as <xref:System.Data.DataTable.Rows%2A> coleção são excluídos ou removidos durante a iteração, a posição atual dentro a `DataTableReader` é mantida adequadamente e não invalida o iterador.  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicializa uma nova instância da classe <see cref="T:System.Data.DataTableReader" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DataTableReader (System.Data.DataTable dataTable);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Data.DataTable dataTable) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTableReader.#ctor(System.Data.DataTable)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DataTableReader(System::Data::DataTable ^ dataTable);" />
      <MemberSignature Language="F#" Value="new System.Data.DataTableReader : System.Data.DataTable -&gt; System.Data.DataTableReader" Usage="new System.Data.DataTableReader dataTable" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="dataTable" Type="System.Data.DataTable" />
      </Parameters>
      <Docs>
        <param name="dataTable">O <see cref="T:System.Data.DataTable" /> do qual o novo <see cref="T:System.Data.DataTableReader" /> obtém seu conjunto de resultados.</param>
        <summary>Inicializa uma nova instância da classe <see cref="T:System.Data.DataTableReader" /> usando dados do <see cref="T:System.Data.DataTable" /> fornecido.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DataTableReader (System.Data.DataTable[] dataTables);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Data.DataTable[] dataTables) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTableReader.#ctor(System.Data.DataTable[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (dataTables As DataTable())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DataTableReader(cli::array &lt;System::Data::DataTable ^&gt; ^ dataTables);" />
      <MemberSignature Language="F#" Value="new System.Data.DataTableReader : System.Data.DataTable[] -&gt; System.Data.DataTableReader" Usage="new System.Data.DataTableReader dataTables" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="dataTables" Type="System.Data.DataTable[]" />
      </Parameters>
      <Docs>
        <param name="dataTables">A matriz de objetos <see cref="T:System.Data.DataTable" /> que fornece os resultados para o novo objeto <see cref="T:System.Data.DataTableReader" />.</param>
        <summary>Inicializa uma nova instância da classe <see cref="T:System.Data.DataTableReader" /> usando a matriz de objetos <see cref="T:System.Data.DataTable" /> fornecida.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se for necessário criar uma <xref:System.Data.DataTableReader> com base em todos ou um subconjunto das tabelas dentro de um determinado <xref:System.Data.DataSet>, chame o `DataSet`do <xref:System.Data.DataSet.CreateDataReader*> método. Se você quiser criar um novo <xref:System.Data.DataTableReader> instância com base em um grupo de `DataTable` instâncias que não seriam relacionadas, usar esse construtor. Você também pode tirar proveito desse construtor para reorganizar a ordenação do `DataTables` dentro de `DataTableReader`, se sua ordem dentro de sua fonte de `DataSet` não atender às suas necessidades.  
  
   
  
## Examples  
 No exemplo a seguir, o método TestConstructor cria dois <xref:System.Data.DataTable> instâncias. Para demonstrar esse construtor para o <xref:System.Data.DataTableReader> classe, o exemplo cria um novo `DataTableReader` com base em uma matriz que contém os dois `DataTables`e executa uma operação simple, imprimir o conteúdo de algumas colunas primeiro no console janela. Para testar este aplicativo, crie um novo aplicativo de Console e cole o código de exemplo para o arquivo recém-criado.  
  
 [!code-csharp[DataWorks DataTableReader.ctor#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTableReader.ctor/CS/source.cs#1)]
 [!code-vb[DataWorks DataTableReader.ctor#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTableReader.ctor/VB/source.vb#1)]  
  
 A janela do Console exibe os seguintes resultados:  
  
```  
1 Mary  
2 Andy  
3 Peter  
4 Russ  
1 Wireless Network Card  
2 Hard Drive  
3 Monitor  
4 CPU  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public override void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTableReader.Close" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Close();" />
      <MemberSignature Language="F#" Value="override this.Close : unit -&gt; unit" Usage="dataTableReader.Close " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Fecha o <see cref="T:System.Data.DataTableReader" /> atual.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Chamando `Close()` em um fechado `DataTableReader` objeto não gera um erro.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Depth">
      <MemberSignature Language="C#" Value="public override int Depth { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Depth" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataTableReader.Depth" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property Depth As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int Depth { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Depth : int" Usage="System.Data.DataTableReader.Depth" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>A profundidade de aninhamento da linha atual do <see cref="T:System.Data.DataTableReader" />.</summary>
        <value>A profundidade de aninhamento da linha atual; sempre zero.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `DataTableReader` não oferece suporte a aninhamento. O `Depth` propriedade sempre retorna zero.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FieldCount">
      <MemberSignature Language="C#" Value="public override int FieldCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 FieldCount" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataTableReader.FieldCount" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property FieldCount As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int FieldCount { int get(); };" />
      <MemberSignature Language="F#" Value="member this.FieldCount : int" Usage="System.Data.DataTableReader.FieldCount" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Retorna o número de colunas na linha atual.</summary>
        <value>Quando não posicionado em um conjunto de resultados válido, 0; Caso contrário, o número de colunas na linha atual.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException">Foi feita uma tentativa de recuperar a contagem de campos em um <see cref="T:System.Data.DataTableReader" /> fechado.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetBoolean">
      <MemberSignature Language="C#" Value="public override bool GetBoolean (int ordinal);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool GetBoolean(int32 ordinal) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTableReader.GetBoolean(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetBoolean (ordinal As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool GetBoolean(int ordinal);" />
      <MemberSignature Language="F#" Value="override this.GetBoolean : int -&gt; bool" Usage="dataTableReader.GetBoolean ordinal" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ordinal" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="ordinal">O ordinal da coluna baseado em zero.</param>
        <summary>Obtém o valor da coluna especificada como um <see cref="T:System.Boolean" />.</summary>
        <returns>O valor da coluna especificada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nenhuma conversão é realizada; portanto os dados recuperados devem já ser um valor booliano ou conversível para um valor booliano ou uma exceção será gerada.  
  
 Chamar <xref:System.Data.DataTableReader.IsDBNull%2A> para ver se há valores nulos antes de chamar esse método.  
  
   
  
## Examples  
 O exemplo a seguir exibe o conteúdo da coluna numerados como 2 no passado <xref:System.Data.DataTableReader>. Se o valor da coluna dentro de uma linha específica for nula, o código exibe o texto \<nulo >. Se os dados dentro da coluna não são do tipo correto, o exemplo exibe uma mensagem de erro para cada linha.  
  
 [!code-csharp[DataWorks DataTableReader.GetBoolean#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTableReader.GetBoolean/CS/source.cs#1)]
 [!code-vb[DataWorks DataTableReader.GetBoolean#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTableReader.GetBoolean/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">O índice passado estava fora do intervalo de 0 a <see cref="P:System.Data.DataTableReader.FieldCount" /> -1.</exception>
        <exception cref="T:System.Data.DeletedRowInaccessibleException">Foi feita uma tentativa de recuperar dados de uma linha excluída.</exception>
        <exception cref="T:System.InvalidOperationException">Foi feita uma tentativa de ler ou acessar uma coluna em um <see cref="T:System.Data.DataTableReader" /> fechado.</exception>
        <exception cref="T:System.InvalidCastException">A coluna especificada não contém um <see langword="Boolean" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetByte">
      <MemberSignature Language="C#" Value="public override byte GetByte (int ordinal);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance unsigned int8 GetByte(int32 ordinal) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTableReader.GetByte(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetByte (ordinal As Integer) As Byte" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Byte GetByte(int ordinal);" />
      <MemberSignature Language="F#" Value="override this.GetByte : int -&gt; byte" Usage="dataTableReader.GetByte ordinal" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ordinal" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="ordinal">O ordinal da coluna baseado em zero.</param>
        <summary>Obtém o valor da coluna especificada como um byte.</summary>
        <returns>O valor da coluna especificada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nenhuma conversão é realizada; Portanto, os dados recuperados já devem estar um byte ou conversível para um byte.  
  
 Chamar <xref:System.Data.DataTableReader.IsDBNull%2A> para ver se há valores nulos antes de chamar esse método.  
  
   
  
## Examples  
 O exemplo a seguir exibe o conteúdo da coluna numerados como 2 no passado <xref:System.Data.DataTableReader>. Se o valor da coluna dentro de uma linha específica for nula, o código exibe o texto \<nulo >. Se os dados dentro da coluna não são do tipo correto, o exemplo exibe uma mensagem de erro para cada linha.  
  
 [!code-csharp[DataWorks DataTableReader.GetByte#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTableReader.GetByte/CS/source.cs#1)]
 [!code-vb[DataWorks DataTableReader.GetByte#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTableReader.GetByte/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">O índice passado estava fora do intervalo de 0 a <see cref="P:System.Data.DataTableReader.FieldCount" /> -1.</exception>
        <exception cref="T:System.Data.DeletedRowInaccessibleException">Foi feita uma tentativa de recuperar dados de uma linha excluída.</exception>
        <exception cref="T:System.InvalidOperationException">Foi feita uma tentativa de ler ou acessar uma coluna em um <see langword="DataTableReader" /> fechado.</exception>
        <exception cref="T:System.InvalidCastException">A coluna especificada não contém um byte.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetBytes">
      <MemberSignature Language="C#" Value="public override long GetBytes (int ordinal, long dataIndex, byte[] buffer, int bufferIndex, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int64 GetBytes(int32 ordinal, int64 dataIndex, unsigned int8[] buffer, int32 bufferIndex, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTableReader.GetBytes(System.Int32,System.Int64,System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetBytes (ordinal As Integer, dataIndex As Long, buffer As Byte(), bufferIndex As Integer, length As Integer) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override long GetBytes(int ordinal, long dataIndex, cli::array &lt;System::Byte&gt; ^ buffer, int bufferIndex, int length);" />
      <MemberSignature Language="F#" Value="override this.GetBytes : int * int64 * byte[] * int * int -&gt; int64" Usage="dataTableReader.GetBytes (ordinal, dataIndex, buffer, bufferIndex, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ordinal" Type="System.Int32" />
        <Parameter Name="dataIndex" Type="System.Int64" />
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="bufferIndex" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="ordinal">O ordinal da coluna baseado em zero.</param>
        <param name="dataIndex">O índice no campo no qual será iniciada a operação de leitura.</param>
        <param name="buffer">O buffer no qual o fluxo de bytes deve ser lido.</param>
        <param name="bufferIndex">O índice no buffer no qual será iniciada a colocação dos dados.</param>
        <param name="length">O tamanho máximo a ser copiado no buffer.</param>
        <summary>Lê um fluxo de bytes, começando no deslocamento de coluna especificado no buffer como uma matriz iniciada no deslocamento de buffer especificado.</summary>
        <returns>O número real de bytes lidos.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `GetBytes` Retorna o número de bytes disponíveis no campo. Na maioria das vezes, isso é o comprimento exato do campo. No entanto, o número retornado pode ser menor que o comprimento real do campo se `GetBytes` já foi usado para obter os bytes do campo. Isso pode ser o caso, por exemplo, quando o <xref:System.Data.DataTableReader> está lendo uma estrutura de dados grande em um buffer  
  
 Se você passar um buffer que está `null` (`Nothing` no Visual Basic), `GetBytes` retorna o comprimento do campo inteiro em bytes, não o tamanho restante com base no parâmetro de deslocamento de buffer.  
  
 Nenhuma conversão é realizada; Portanto, os dados recuperados já devem ser uma matriz de bytes ou conversível para uma matriz de bytes.  
  
   
  
## Examples  
 O exemplo a seguir cria um <xref:System.Data.DataTableReader> com base nos dados nos dados de exemplo AdventureWorks e salva cada imagem é recuperada em um arquivo separado na pasta C:\. Para testar este aplicativo, crie um novo aplicativo de Console, fazer referência ao assembly Drawing e cole o código de exemplo para o arquivo recém-criado.  
  
 [!code-csharp[DataWorks DataTableReader.GetBytes#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTableReader.GetBytes/CS/source.cs#1)]
 [!code-vb[DataWorks DataTableReader.GetBytes#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTableReader.GetBytes/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">O índice passado estava fora do intervalo de 0 a <see cref="P:System.Data.DataTableReader.FieldCount" /> -1.</exception>
        <exception cref="T:System.Data.DeletedRowInaccessibleException">Foi feita uma tentativa de recuperar dados de uma linha excluída.</exception>
        <exception cref="T:System.InvalidOperationException">Foi feita uma tentativa de ler ou acessar uma coluna em um <see langword="DataTableReader" /> fechado.</exception>
        <exception cref="T:System.InvalidCastException">A coluna especificada não contém uma matriz de bytes.</exception>
        <altmember cref="M:System.Data.DataTableReader.GetChars(System.Int32,System.Int64,System.Char[],System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetChar">
      <MemberSignature Language="C#" Value="public override char GetChar (int ordinal);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance char GetChar(int32 ordinal) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTableReader.GetChar(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetChar (ordinal As Integer) As Char" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override char GetChar(int ordinal);" />
      <MemberSignature Language="F#" Value="override this.GetChar : int -&gt; char" Usage="dataTableReader.GetChar ordinal" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ordinal" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="ordinal">O ordinal da coluna baseado em zero.</param>
        <summary>Obtém o valor da coluna especificada como um caractere.</summary>
        <returns>O valor da coluna.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nenhuma conversão é realizada; Portanto, os dados recuperados já devem ser um caractere ou conversível para um caractere.  
  
 Chamar <xref:System.Data.DataTableReader.IsDBNull%2A> para ver se há valores nulos antes de chamar esse método.  
  
   
  
## Examples  
 O exemplo a seguir exibe o conteúdo da coluna numerados como 2 dentro a DataTableReader no passado. Se o valor da coluna dentro de uma linha específica for nula, o código exibe o texto \<nulo >. Se os dados dentro da coluna não são do tipo correto, o exemplo exibe uma mensagem de erro para cada linha.  
  
 [!code-csharp[DataWorks DataTableReader.GetChar#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTableReader.GetChar/CS/source.cs#1)]
 [!code-vb[DataWorks DataTableReader.GetChar#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTableReader.GetChar/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">O índice passado estava fora do intervalo de 0 a <see cref="P:System.Data.DataTableReader.FieldCount" /> -1.</exception>
        <exception cref="T:System.Data.DeletedRowInaccessibleException">Foi feita uma tentativa de recuperar dados de uma linha excluída.</exception>
        <exception cref="T:System.InvalidOperationException">Foi feita uma tentativa de ler ou acessar uma coluna em um <see langword="DataTableReader" /> fechado.</exception>
        <exception cref="T:System.InvalidCastException">O campo especificado não contém um caractere.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetChars">
      <MemberSignature Language="C#" Value="public override long GetChars (int ordinal, long dataIndex, char[] buffer, int bufferIndex, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int64 GetChars(int32 ordinal, int64 dataIndex, char[] buffer, int32 bufferIndex, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTableReader.GetChars(System.Int32,System.Int64,System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetChars (ordinal As Integer, dataIndex As Long, buffer As Char(), bufferIndex As Integer, length As Integer) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override long GetChars(int ordinal, long dataIndex, cli::array &lt;char&gt; ^ buffer, int bufferIndex, int length);" />
      <MemberSignature Language="F#" Value="override this.GetChars : int * int64 * char[] * int * int -&gt; int64" Usage="dataTableReader.GetChars (ordinal, dataIndex, buffer, bufferIndex, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ordinal" Type="System.Int32" />
        <Parameter Name="dataIndex" Type="System.Int64" />
        <Parameter Name="buffer" Type="System.Char[]" />
        <Parameter Name="bufferIndex" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="ordinal">O ordinal da coluna baseado em zero.</param>
        <param name="dataIndex">O índice no campo no qual será iniciada a operação de leitura.</param>
        <param name="buffer">O buffer no qual o fluxo de caracteres deve ser lido.</param>
        <param name="bufferIndex">O índice no buffer no qual será iniciada a colocação dos dados.</param>
        <param name="length">O tamanho máximo a ser copiado no buffer.</param>
        <summary>Retorna o valor da coluna especificada como uma matriz de caracteres.</summary>
        <returns>O número real de caracteres lidos.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `GetChars` Retorna o número de caracteres disponíveis no campo. Na maioria das vezes, isso é o comprimento exato do campo. No entanto, o número retornado pode ser menor que o comprimento real do campo se `GetChars` já foi usado para obter caracteres do campo.  
  
 O número real de caracteres lidos pode ser menor que o tamanho solicitado, se o final do campo for atingido. Se você passar um buffer que é nulo (`Nothing` no Visual Basic), `GetChars` retorna o comprimento de todo o campo em caracteres, não o tamanho restante com base no parâmetro de deslocamento de buffer.  
  
 Nenhuma conversão é realizada; portanto os dados a serem recuperados já devem ser uma matriz de caracteres ou conversível para uma matriz de caracteres.  
  
   
  
## Examples  
 O exemplo a seguir demonstra o `GetChars` método. O `TestGetChars` método espera que seja passado um `DataTableReader` preenchida com duas colunas de dados: um nome de arquivo na primeira coluna e uma matriz de caracteres no segundo. Além disso, `TestGetChars` permite que você especifique o tamanho do buffer a ser usado como ele lê os dados da matriz de caracteres no `DataTableReader`. `TestGetChars` cria um arquivo correspondente a cada linha de dados a `DataTableReader`, usando os dados fornecidos na primeira coluna do `DataTableReader` como o nome do arquivo.  
  
 Este procedimento demonstra o uso do `GetChars` método de leitura de dados que foram armazenados no `DataTable` como uma matriz de caracteres. Qualquer outro tipo de dados causa o `GetChars` método para lançar um `InvalidCastException`.  
  
 [!code-csharp[DataWorks DataTableReader.GetChars#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTableReader.GetChars/CS/source.cs#1)]
 [!code-vb[DataWorks DataTableReader.GetChars#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTableReader.GetChars/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">O índice passado estava fora do intervalo de 0 a <see cref="P:System.Data.DataTableReader.FieldCount" /> -1.</exception>
        <exception cref="T:System.Data.DeletedRowInaccessibleException">Foi feita uma tentativa de recuperar dados de uma linha excluída.</exception>
        <exception cref="T:System.InvalidOperationException">Foi feita uma tentativa de ler ou acessar uma coluna em um <see langword="DataTableReader" /> fechado.</exception>
        <exception cref="T:System.InvalidCastException">A coluna especificada não contém uma matriz de caracteres.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetDataTypeName">
      <MemberSignature Language="C#" Value="public override string GetDataTypeName (int ordinal);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string GetDataTypeName(int32 ordinal) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTableReader.GetDataTypeName(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetDataTypeName (ordinal As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ GetDataTypeName(int ordinal);" />
      <MemberSignature Language="F#" Value="override this.GetDataTypeName : int -&gt; string" Usage="dataTableReader.GetDataTypeName ordinal" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ordinal" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="ordinal">O ordinal da coluna baseado em zero.</param>
        <summary>Obtém uma cadeia de caracteres que representa o tipo de dados da coluna especificada.</summary>
        <returns>Uma cadeia de caracteres que representa o tipo de dados da coluna.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Data.DataTableReader.GetDataTypeName%2A> método sempre retorna o tipo de subjacente <xref:System.Data.DataColumn> em vez de um tipo específico de provedor.  
  
   
  
## Examples  
 O aplicativo de console a seguir exibe uma lista de campos e os nomes de tipo em um simples <xref:System.Data.DataTable>:  
  
 [!code-csharp[DataWorks DataTableReader.GetDataTypeName#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTableReader.GetDataTypeName/CS/source.cs#1)]
 [!code-vb[DataWorks DataTableReader.GetDataTypeName#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTableReader.GetDataTypeName/VB/source.vb#1)]  
  
 A janela do Console exibe os seguintes resultados:  
  
```  
ID: Int32  
Name: String  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">O índice passado estava fora do intervalo de 0 a <see cref="P:System.Data.DataTableReader.FieldCount" /> -1.</exception>
        <exception cref="T:System.InvalidOperationException">Foi feita uma tentativa de ler ou acessar uma coluna em um <see cref="T:System.Data.DataTableReader" /> fechado.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetDateTime">
      <MemberSignature Language="C#" Value="public override DateTime GetDateTime (int ordinal);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance valuetype System.DateTime GetDateTime(int32 ordinal) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTableReader.GetDateTime(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetDateTime (ordinal As Integer) As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override DateTime GetDateTime(int ordinal);" />
      <MemberSignature Language="F#" Value="override this.GetDateTime : int -&gt; DateTime" Usage="dataTableReader.GetDateTime ordinal" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ordinal" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="ordinal">O ordinal da coluna baseado em zero.</param>
        <summary>Obtém o valor da coluna especificada como um objeto <see cref="T:System.DateTime" />.</summary>
        <returns>O valor da coluna especificada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nenhuma conversão é realizada; Portanto, os dados recuperados já devem ser um <xref:System.DateTime> ou conversível para um `DataTime`.  
  
 Chamar <xref:System.Data.DataTableReader.IsDBNull%2A> para ver se há valores nulos antes de chamar esse método.  
  
   
  
## Examples  
 O exemplo a seguir exibe o conteúdo da coluna numerados como 2 no passado <xref:System.Data.DataTableReader>. Se o valor da coluna dentro de uma linha específica for nula, o código exibe o texto \<nulo >. Se os dados dentro da coluna não são do tipo correto, o exemplo exibe uma mensagem de erro para cada linha.  
  
 [!code-csharp[DataWorks DataTableReader.GetDateTime#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTableReader.GetDateTime/CS/source.cs#1)]
 [!code-vb[DataWorks DataTableReader.GetDateTime#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTableReader.GetDateTime/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">O índice passado estava fora do intervalo de 0 a <see cref="P:System.Data.DataTableReader.FieldCount" /> -1.</exception>
        <exception cref="T:System.Data.DeletedRowInaccessibleException">Foi feita uma tentativa de recuperar dados de uma linha excluída.</exception>
        <exception cref="T:System.InvalidOperationException">Foi feita uma tentativa de ler ou acessar uma coluna em um <see langword="DataTableReader" /> fechado.</exception>
        <exception cref="T:System.InvalidCastException">A coluna especificada não contém um valor de DateTime.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetDecimal">
      <MemberSignature Language="C#" Value="public override decimal GetDecimal (int ordinal);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance valuetype System.Decimal GetDecimal(int32 ordinal) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTableReader.GetDecimal(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetDecimal (ordinal As Integer) As Decimal" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Decimal GetDecimal(int ordinal);" />
      <MemberSignature Language="F#" Value="override this.GetDecimal : int -&gt; decimal" Usage="dataTableReader.GetDecimal ordinal" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ordinal" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="ordinal">O ordinal da coluna baseado em zero.</param>
        <summary>Obtém o valor da coluna especificada como um <see cref="T:System.Decimal" />.</summary>
        <returns>O valor da coluna especificada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nenhuma conversão é realizada; Portanto, os dados recuperados já devem ser um <xref:System.Decimal> ou conversível para um `Decimal`.  
  
 Chamar <xref:System.Data.DataTableReader.IsDBNull%2A> para ver se há valores nulos antes de chamar esse método.  
  
   
  
## Examples  
 O exemplo a seguir exibe o conteúdo da coluna numerados como 2 no passado <xref:System.Data.DataTableReader>. Se o valor da coluna dentro de uma linha específica for nula, o código exibe o texto \<nulo >. Se os dados dentro da coluna não são do tipo correto, o exemplo exibe uma mensagem de erro para cada linha.  
  
 [!code-csharp[DataWorks DataTableReader.GetDecimal#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTableReader.GetDecimal/CS/source.cs#1)]
 [!code-vb[DataWorks DataTableReader.GetDecimal#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTableReader.GetDecimal/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">O índice passado estava fora do intervalo de 0 a <see cref="P:System.Data.DataTableReader.FieldCount" /> -1.</exception>
        <exception cref="T:System.Data.DeletedRowInaccessibleException">Foi feita uma tentativa de recuperar dados de uma linha excluída.</exception>
        <exception cref="T:System.InvalidOperationException">Foi feita uma tentativa de ler ou acessar uma coluna em um <see langword="DataTableReader" /> fechado.</exception>
        <exception cref="T:System.InvalidCastException">A coluna especificada não contém um valor <see langword="Decimal" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetDouble">
      <MemberSignature Language="C#" Value="public override double GetDouble (int ordinal);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance float64 GetDouble(int32 ordinal) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTableReader.GetDouble(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetDouble (ordinal As Integer) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override double GetDouble(int ordinal);" />
      <MemberSignature Language="F#" Value="override this.GetDouble : int -&gt; double" Usage="dataTableReader.GetDouble ordinal" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ordinal" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="ordinal">O ordinal com base em zero da coluna.</param>
        <summary>Obtém o valor da coluna como um número de ponto flutuante de precisão dupla.</summary>
        <returns>O valor da coluna especificada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nenhuma conversão é realizada; Portanto, os dados recuperados já devem ser um número de ponto flutuante de precisão dupla ou devem ser conversível para um número de ponto flutuante de precisão dupla.  
  
 Chamar <xref:System.Data.DataTableReader.IsDBNull%2A> para ver se há valores nulos antes de chamar esse método.  
  
   
  
## Examples  
 O exemplo a seguir exibe o conteúdo da coluna numerados como 2 no passado <xref:System.Data.DataTableReader>. Se o valor da coluna dentro de uma linha específica for nula, o código exibe o texto \<nulo >. Se os dados dentro da coluna não são do tipo correto, o exemplo exibe uma mensagem de erro para cada linha.  
  
 [!code-csharp[DataWorks DataTableReader.GetDouble#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTableReader.GetDouble/CS/source.cs#1)]
 [!code-vb[DataWorks DataTableReader.GetDouble#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTableReader.GetDouble/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">O índice passado estava fora do intervalo de 0 a <see cref="P:System.Data.DataTableReader.FieldCount" /> -1.</exception>
        <exception cref="T:System.Data.DeletedRowInaccessibleException">Foi feita uma tentativa de recuperar dados de uma linha excluída.</exception>
        <exception cref="T:System.InvalidOperationException">Foi feita uma tentativa de ler ou acessar uma coluna em um <see langword="DataTableReader" /> fechado.</exception>
        <exception cref="T:System.InvalidCastException">A coluna especificada não contém um número de ponto flutuante de precisão dupla.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetEnumerator">
      <MemberSignature Language="C#" Value="public override System.Collections.IEnumerator GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Collections.IEnumerator GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTableReader.GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetEnumerator () As IEnumerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Collections::IEnumerator ^ GetEnumerator();" />
      <MemberSignature Language="F#" Value="override this.GetEnumerator : unit -&gt; System.Collections.IEnumerator" Usage="dataTableReader.GetEnumerator " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retorna um enumerador que pode ser usado para iterar na coleção de item.</summary>
        <returns>Um objeto <see cref="T:System.Collections.IEnumerator" /> que representa a coleção de itens.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Enumeradores permitem apenas lendo os dados no <xref:System.Data.DataTableReader>. Os enumeradores não podem ser usados para modificar a coleção subjacente.  
  
 Primeiro, o enumerador está posicionado antes do primeiro elemento na coleção. AT isso posicionar, chamar <xref:System.Collections.IEnumerator.Current%2A> gera uma exceção. Por isso, você deve chamar `MoveNext` para avançar o enumerador até o primeiro elemento da coleção antes de ler o valor de `Current`.  
  
 `Current` Retorna um <xref:System.Data.Common.DbDataRecord>e retorna o mesmo objeto até que <xref:System.Collections.IEnumerator.MoveNext%2A> ou <xref:System.Collections.IEnumerator.Reset%2A> é chamado. `MoveNext` define `Current` como o próximo elemento.  
  
 Após o final da coleção for passado, o enumerador é posicionado após o último elemento na coleção e chamada `MoveNext` retorna false. Se a última chamada para `MoveNext` retornou `false`, chamar `Current` gera uma exceção. Além disso, porque o <xref:System.Data.DataTableReader> fornece acesso somente de encaminhamento aos seus dados, chamando o <xref:System.Collections.IEnumerator.Reset%2A> método de IEnumerator lança um <xref:System.NotSupportedException>.  
  
 O <xref:System.Data.DataTableReader> fornece um enumerador estável. Isso significa que, mesmo que ocorram adições ou exclusões de linha nos dados subjacentes, o enumerador retornado por uma chamada para <xref:System.Data.DataTableReader.GetEnumerator%2A> ainda é válido.  
  
   
  
## Examples  
 O exemplo a seguir demonstra o uso do método <xref:System.Data.DataTableReader.GetEnumerator%2A>. Isso inclui o comportamento do enumerador quando linhas são excluídas da subjacente <xref:System.Data.DataTable> enquanto o enumerador está ativo.  
  
 [!code-csharp[DataWorks DataTableReader.GetEnumerator#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTableReader.GetEnumerator/CS/source.cs#1)]
 [!code-vb[DataWorks DataTableReader.GetEnumerator#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTableReader.GetEnumerator/VB/source.vb#1)]  
  
 O procedimento exibe o texto a seguir na janela do Console:  
  
```  
Peter  
Mary  
Russ  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Foi feita uma tentativa de ler ou acessar uma coluna em um <see cref="T:System.Data.DataTableReader" /> fechado.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetFieldType">
      <MemberSignature Language="C#" Value="public override Type GetFieldType (int ordinal);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Type GetFieldType(int32 ordinal) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTableReader.GetFieldType(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetFieldType (ordinal As Integer) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override Type ^ GetFieldType(int ordinal);" />
      <MemberSignature Language="F#" Value="override this.GetFieldType : int -&gt; Type" Usage="dataTableReader.GetFieldType ordinal" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ordinal" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="ordinal">O ordinal da coluna baseado em zero.</param>
        <summary>Obtém o <see cref="T:System.Type" /> que é o tipo de dados do objeto.</summary>
        <returns>O <see cref="T:System.Type" /> que é o tipo de dados do objeto.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Chame o procedimento a seguir, passando um <xref:System.Data.DataTableReader> instância para exibir uma lista de todos os campos e o nome completo para cada tipo na janela do Console.  
  
 [!code-csharp[DataWorks DataTableReader.GetFieldType#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTableReader.GetFieldType/CS/source.cs#1)]
 [!code-vb[DataWorks DataTableReader.GetFieldType#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTableReader.GetFieldType/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">O índice passado estava fora do intervalo de 0 a <see cref="P:System.Data.DataTableReader.FieldCount" /> -1.</exception>
        <exception cref="T:System.InvalidOperationException">Foi feita uma tentativa de ler ou acessar uma coluna em um <see cref="T:System.Data.DataTableReader" /> fechado.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetFloat">
      <MemberSignature Language="C#" Value="public override float GetFloat (int ordinal);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance float32 GetFloat(int32 ordinal) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTableReader.GetFloat(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetFloat (ordinal As Integer) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override float GetFloat(int ordinal);" />
      <MemberSignature Language="F#" Value="override this.GetFloat : int -&gt; single" Usage="dataTableReader.GetFloat ordinal" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ordinal" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="ordinal">O ordinal da coluna baseado em zero.</param>
        <summary>Obtém o valor da coluna especificada como um número de ponto flutuante de precisão simples.</summary>
        <returns>O valor da coluna.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nenhuma conversão é realizada; Portanto, os dados recuperados já devem ser um número de ponto flutuante de precisão simples ou devem ser conversível para um número de ponto flutuante de precisão simples.  
  
 Chamar <xref:System.Data.DataTableReader.IsDBNull%2A> para ver se há valores nulos antes de chamar esse método.  
  
   
  
## Examples  
 O exemplo a seguir exibe o conteúdo da coluna numerados como 2 no passado <xref:System.Data.DataTableReader>. Se o valor da coluna dentro de uma linha específica for nula, o código exibe o texto \<nulo >. Se os dados dentro da coluna não são do tipo correto, o exemplo exibe uma mensagem de erro para cada linha.  
  
 [!code-csharp[DataWorks DataTableReader.GetFloat#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTableReader.GetFloat/CS/source.cs#1)]
 [!code-vb[DataWorks DataTableReader.GetFloat#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTableReader.GetFloat/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">O índice passado estava fora do intervalo de 0 a <see cref="P:System.Data.DataTableReader.FieldCount" /> -1.</exception>
        <exception cref="T:System.Data.DeletedRowInaccessibleException">Foi feita uma tentativa de recuperar dados de uma linha excluída.</exception>
        <exception cref="T:System.InvalidOperationException">Foi feita uma tentativa de ler ou acessar uma coluna em um <see cref="T:System.Data.DataTableReader" /> fechado.</exception>
        <exception cref="T:System.InvalidCastException">A coluna especificada não contém um número de ponto flutuante de precisão simples.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetGuid">
      <MemberSignature Language="C#" Value="public override Guid GetGuid (int ordinal);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance valuetype System.Guid GetGuid(int32 ordinal) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTableReader.GetGuid(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetGuid (ordinal As Integer) As Guid" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override Guid GetGuid(int ordinal);" />
      <MemberSignature Language="F#" Value="override this.GetGuid : int -&gt; Guid" Usage="dataTableReader.GetGuid ordinal" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Guid</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ordinal" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="ordinal">O ordinal da coluna baseado em zero.</param>
        <summary>Obtém o valor da coluna especificada como um GUID (identificador global exclusivo).</summary>
        <returns>O valor da coluna especificada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nenhuma conversão é realizada; Portanto, os dados recuperados já devem ser um <xref:System.Guid> ou conversível para um `Guid`.  
  
 Chamar <xref:System.Data.DataTableReader.IsDBNull%2A> para ver se há valores nulos antes de chamar esse método.  
  
   
  
## Examples  
 O exemplo a seguir exibe o conteúdo da coluna numerados como 2 dentro a DataTableReader no passado. Se o valor da coluna dentro de uma linha específica for nula, o código exibe o texto \<nulo >. Se os dados dentro da coluna não são do tipo correto, o exemplo exibe uma mensagem de erro para cada linha.  
  
 [!code-csharp[DataWorks DataTableReader.GetGuid#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTableReader.GetGuid/CS/source.cs#1)]
 [!code-vb[DataWorks DataTableReader.GetGuid#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTableReader.GetGuid/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">O índice passado estava fora do intervalo de 0 a <see cref="P:System.Data.DataTableReader.FieldCount" /> -1.</exception>
        <exception cref="T:System.Data.DeletedRowInaccessibleException">Foi feita uma tentativa de recuperar dados de uma linha excluída.</exception>
        <exception cref="T:System.InvalidOperationException">Foi feita uma tentativa de ler ou acessar uma coluna em um <see cref="T:System.Data.DataTableReader" /> fechado.</exception>
        <exception cref="T:System.InvalidCastException">A coluna especificada não contém um GUID.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetInt16">
      <MemberSignature Language="C#" Value="public override short GetInt16 (int ordinal);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int16 GetInt16(int32 ordinal) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTableReader.GetInt16(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetInt16 (ordinal As Integer) As Short" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override short GetInt16(int ordinal);" />
      <MemberSignature Language="F#" Value="override this.GetInt16 : int -&gt; int16" Usage="dataTableReader.GetInt16 ordinal" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ordinal" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="ordinal">O ordinal da coluna baseado em zero</param>
        <summary>Obtém o valor da coluna especificada como um inteiro com sinal de 16 bits.</summary>
        <returns>O valor da coluna especificada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nenhuma conversão é realizada; Portanto, os dados recuperados já devem ser um <xref:System.Int16> ou conversível para um `Int16`.  
  
 Chamar <xref:System.Data.DataTableReader.IsDBNull%2A> para ver se há valores nulos antes de chamar esse método.  
  
   
  
## Examples  
 O exemplo a seguir exibe o conteúdo da coluna numerados como 2 no passado <xref:System.Data.DataTableReader>. Se o valor da coluna dentro de uma linha específica for nula, o código exibe o texto \<nulo >. Se os dados dentro da coluna não são do tipo correto, o exemplo exibe uma mensagem de erro para cada linha.  
  
 [!code-csharp[DataWorks DataTableReader.GetInt16#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTableReader.GetInt16/CS/source.cs#1)]
 [!code-vb[DataWorks DataTableReader.GetInt16#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTableReader.GetInt16/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">O índice passado estava fora do intervalo de 0 a <see cref="P:System.Data.DataTableReader.FieldCount" /> -1.</exception>
        <exception cref="T:System.Data.DeletedRowInaccessibleException">Foi feita uma tentativa de recuperar dados de uma linha excluída.</exception>
        <exception cref="T:System.InvalidOperationException">Foi feita uma tentativa de ler ou acessar uma coluna em um <see cref="T:System.Data.DataTableReader" /> fechado.</exception>
        <exception cref="T:System.InvalidCastException">A coluna especificada não contém um inteiro com sinal de 16 bits.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetInt32">
      <MemberSignature Language="C#" Value="public override int GetInt32 (int ordinal);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetInt32(int32 ordinal) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTableReader.GetInt32(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetInt32 (ordinal As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetInt32(int ordinal);" />
      <MemberSignature Language="F#" Value="override this.GetInt32 : int -&gt; int" Usage="dataTableReader.GetInt32 ordinal" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ordinal" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="ordinal">O ordinal da coluna baseado em zero</param>
        <summary>Obtém o valor da coluna especificada como um inteiro com sinal de 32 bits.</summary>
        <returns>O valor da coluna especificada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nenhuma conversão é realizada; Portanto, os dados recuperados já devem ser um <xref:System.Int32> ou conversível para um `Int32`.  
  
 Chamar <xref:System.Data.DataTableReader.IsDBNull%2A> para ver se há valores nulos antes de chamar esse método.  
  
   
  
## Examples  
 O exemplo a seguir exibe o conteúdo da coluna numerados como 2 no passado <xref:System.Data.DataTableReader>. Se o valor da coluna dentro de uma linha específica for nula, o código exibe o texto \<nulo >. Se os dados dentro da coluna não são do tipo correto, o exemplo exibe uma mensagem de erro para cada linha.  
  
 [!code-csharp[DataWorks DataTableReader.GetInt32#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTableReader.GetInt32/CS/source.cs#1)]
 [!code-vb[DataWorks DataTableReader.GetInt32#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTableReader.GetInt32/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">O índice passado estava fora do intervalo de 0 a <see cref="P:System.Data.DataTableReader.FieldCount" /> -1.</exception>
        <exception cref="T:System.Data.DeletedRowInaccessibleException">Foi feita uma tentativa de recuperar dados de uma linha excluída.</exception>
        <exception cref="T:System.InvalidOperationException">Foi feita uma tentativa de ler ou acessar uma coluna em um <see cref="T:System.Data.DataTableReader" /> fechado.</exception>
        <exception cref="T:System.InvalidCastException">A coluna especificada não contém um valor inteiro com sinal de 32 bits.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetInt64">
      <MemberSignature Language="C#" Value="public override long GetInt64 (int ordinal);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int64 GetInt64(int32 ordinal) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTableReader.GetInt64(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetInt64 (ordinal As Integer) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override long GetInt64(int ordinal);" />
      <MemberSignature Language="F#" Value="override this.GetInt64 : int -&gt; int64" Usage="dataTableReader.GetInt64 ordinal" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ordinal" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="ordinal">O ordinal da coluna baseado em zero</param>
        <summary>Obtém o valor da coluna especificada como um inteiro com sinal de 64 bits.</summary>
        <returns>O valor da coluna especificada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nenhuma conversão é realizada; Portanto, os dados recuperados já devem ser um <xref:System.Int64> ou conversível para um `Int64`.  
  
 Chamar <xref:System.Data.DataTableReader.IsDBNull%2A> para ver se há valores nulos antes de chamar esse método.  
  
   
  
## Examples  
 O exemplo a seguir exibe o conteúdo da coluna numerados como 2 no passado <xref:System.Data.DataTableReader>. Se o valor da coluna dentro de uma linha específica for nula, o código exibe o texto \<nulo >. Se os dados dentro da coluna não são do tipo correto, o exemplo exibe uma mensagem de erro para cada linha.  
  
 [!code-csharp[DataWorks DataTableReader.GetInt64#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTableReader.GetInt64/CS/source.cs#1)]
 [!code-vb[DataWorks DataTableReader.GetInt64#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTableReader.GetInt64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">O índice passado estava fora do intervalo de 0 a <see cref="P:System.Data.DataTableReader.FieldCount" /> -1.</exception>
        <exception cref="T:System.Data.DeletedRowInaccessibleException">Foi feita uma tentativa de recuperar dados de uma linha excluída.</exception>
        <exception cref="T:System.InvalidOperationException">Foi feita uma tentativa de ler ou acessar uma coluna em um <see cref="T:System.Data.DataTableReader" /> fechado.</exception>
        <exception cref="T:System.InvalidCastException">A coluna especificada não contém um valor inteiro com sinal de 64 bits.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetName">
      <MemberSignature Language="C#" Value="public override string GetName (int ordinal);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string GetName(int32 ordinal) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTableReader.GetName(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetName (ordinal As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ GetName(int ordinal);" />
      <MemberSignature Language="F#" Value="override this.GetName : int -&gt; string" Usage="dataTableReader.GetName ordinal" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ordinal" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="ordinal">O ordinal da coluna baseado em zero</param>
        <summary>Obtém o valor da coluna especificada como um <see cref="T:System.String" />.</summary>
        <returns>O nome da coluna especificada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O `GetName` e <xref:System.Data.DataTableReader.GetOrdinal%2A> métodos oferecem funcionalidade inversa. Ou seja, chamando `GetOrdinal` no valor de retorno de chamada `GetName` deve retornar o parâmetro original passado para `GetName`; o mesmo se aplica a chamar os procedimentos na ordem oposta.  
  
   
  
## Examples  
 O exemplo simples a seguir inclui um procedimento que lista os nomes de todas as colunas dentro de especificado `DataTableReader`e a posição ordinal da coluna, a janela do Console.  
  
 [!code-csharp[DataWorks DataTableReader.GetName#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTableReader.GetName/CS/source.cs#1)]
 [!code-vb[DataWorks DataTableReader.GetName#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTableReader.GetName/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">O índice passado estava fora do intervalo de 0 a <see cref="P:System.Data.DataTableReader.FieldCount" /> -1.</exception>
        <exception cref="T:System.InvalidOperationException">Foi feita uma tentativa de ler ou acessar uma coluna em um <see cref="T:System.Data.DataTableReader" /> fechado.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetOrdinal">
      <MemberSignature Language="C#" Value="public override int GetOrdinal (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetOrdinal(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTableReader.GetOrdinal(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetOrdinal (name As String) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetOrdinal(System::String ^ name);" />
      <MemberSignature Language="F#" Value="override this.GetOrdinal : string -&gt; int" Usage="dataTableReader.GetOrdinal name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">O nome da coluna.</param>
        <summary>Obtém a ordinal da coluna, de acordo com o nome da coluna.</summary>
        <returns>O ordinal da coluna baseado em zero.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Como a maioria dos métodos fornecidos pelo <xref:System.Data.DataTableReader> classe deve ser fornecida com um número ordinal de coluna, você pode usar o `GetOrdinal` método para recuperar o número da coluna, considerando o nome da coluna.  
  
 `GetOrdinal` executa uma pesquisa diferencia maiusculas de minúsculas primeiro. Se ele falhar, uma segunda pesquisa diferencia maiusculas de minúsculas será feita. Se o número da coluna não for encontrado um `IndexOutOfRangeException` é gerada.  
  
 `GetOrdinal` não distingue largura de kana.  
  
 Como pesquisas baseadas em ordinais são mais eficientes do que pesquisas por nome, é ineficiente chamar `GetOrdinal` dentro de um loop. Economize tempo chamando `GetOrdinal` uma vez e atribuindo os resultados para uma variável de inteiro para uso dentro do loop  
  
   
  
## Examples  
 Se você tiver apenas um nome de coluna, caso em que o nome da coluna é o usuário fornecido e você deve recuperar as informações da coluna, você pode usar um procedimento semelhante ao seguinte para extrair as informações necessárias. Neste exemplo, o procedimento aceita um nome de coluna e retorna os dados que estão contidos dentro da coluna da linha atual no <xref:System.Data.DataTableReader> :  
  
 [!code-csharp[DataWorks DataTableReader.GetOrdinal#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTableReader.GetOrdinal/CS/source.cs#1)]
 [!code-vb[DataWorks DataTableReader.GetOrdinal#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTableReader.GetOrdinal/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Foi feita uma tentativa de ler ou acessar uma coluna em um <see cref="T:System.Data.DataTableReader" /> fechado.</exception>
        <exception cref="T:System.ArgumentException">O nome especificado não é um nome de coluna válido.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetProviderSpecificFieldType">
      <MemberSignature Language="C#" Value="public override Type GetProviderSpecificFieldType (int ordinal);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Type GetProviderSpecificFieldType(int32 ordinal) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTableReader.GetProviderSpecificFieldType(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetProviderSpecificFieldType (ordinal As Integer) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override Type ^ GetProviderSpecificFieldType(int ordinal);" />
      <MemberSignature Language="F#" Value="override this.GetProviderSpecificFieldType : int -&gt; Type" Usage="dataTableReader.GetProviderSpecificFieldType ordinal" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ordinal" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="ordinal">O ordinal da coluna baseado em zero.</param>
        <summary>Obtém o tipo da coluna especificada no formato específico do provedor.</summary>
        <returns>O <see cref="T:System.Type" /> que é o tipo de dados do objeto.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Porque o <xref:System.Data.DataTableReader> sempre retorna o tipo armazenado dentro do subjacente <xref:System.Data.DataColumn>, o valor retornado pela chamada a <xref:System.Data.DataTableReader.GetProviderSpecificFieldType%2A> método sempre retorna o mesmo tipo que o tipo armazenado dentro a <xref:System.Data.DataTable>. Quando você trabalha com o <xref:System.Data.DataTableReader> classe, chamando o <xref:System.Data.DataTableReader.GetProviderSpecificFieldType%2A> método retorna o mesmo tipo que chamar o <xref:System.Type.GetType%2A> método.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">O índice passado estava fora do intervalo de 0 a <see cref="P:System.Data.DataTableReader.FieldCount" /> -1.</exception>
        <exception cref="T:System.InvalidOperationException">Foi feita uma tentativa de ler ou acessar uma coluna em um <see cref="T:System.Data.DataTableReader" /> fechado.</exception>
        <altmember cref="M:System.Data.DataTableReader.GetFieldType(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetProviderSpecificValue">
      <MemberSignature Language="C#" Value="public override object GetProviderSpecificValue (int ordinal);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance object GetProviderSpecificValue(int32 ordinal) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTableReader.GetProviderSpecificValue(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetProviderSpecificValue (ordinal As Integer) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Object ^ GetProviderSpecificValue(int ordinal);" />
      <MemberSignature Language="F#" Value="override this.GetProviderSpecificValue : int -&gt; obj" Usage="dataTableReader.GetProviderSpecificValue ordinal" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ordinal" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="ordinal">O número com base em zero da coluna cujo valor é recuperado.</param>
        <summary>Obtém o valor da coluna especificada no formato específico do provedor.</summary>
        <returns>O valor da coluna especificada no formato específico do provedor.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Porque o <xref:System.Data.DataTableReader> sempre retorna o tipo armazenado dentro do subjacente <xref:System.Data.DataColumn>, o valor retornado pela chamada a <xref:System.Data.DataTableReader.GetProviderSpecificValue%2A> método sempre retorna dados do mesmo tipo que os dados armazenados no <xref:System.Data.DataTable>. Quando você trabalha com o <xref:System.Data.DataTableReader> classe, chamando o <xref:System.Data.DataTableReader.GetProviderSpecificValue%2A> método retorna o mesmo valor e digite como chamar o <xref:System.Data.DataTableReader.GetValue%2A> método.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">O índice passado estava fora do intervalo de 0 a <see cref="P:System.Data.DataTableReader.FieldCount" /> -1.</exception>
        <exception cref="T:System.Data.DeletedRowInaccessibleException">Foi feita uma tentativa de recuperar dados de uma linha excluída.</exception>
        <exception cref="T:System.InvalidOperationException">Foi feita uma tentativa de ler ou acessar uma coluna em um <see cref="T:System.Data.DataTableReader" /> fechado</exception>
        <altmember cref="M:System.Data.DataTableReader.GetValue(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetProviderSpecificValues">
      <MemberSignature Language="C#" Value="public override int GetProviderSpecificValues (object[] values);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetProviderSpecificValues(object[] values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTableReader.GetProviderSpecificValues(System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetProviderSpecificValues (values As Object()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetProviderSpecificValues(cli::array &lt;System::Object ^&gt; ^ values);" />
      <MemberSignature Language="F#" Value="override this.GetProviderSpecificValues : obj[] -&gt; int" Usage="dataTableReader.GetProviderSpecificValues values" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="values" Type="System.Object[]" />
      </Parameters>
      <Docs>
        <param name="values">Uma matriz de objetos a ser preenchida com as informações de tipo para as colunas no <see cref="T:System.Data.DataTableReader" />.</param>
        <summary>Preenche a matriz fornecida com informações de tipo específicas do provedor para todas as colunas no <see cref="T:System.Data.DataTableReader" />.</summary>
        <returns>O número de valores de coluna copiados para a matriz.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Porque o <xref:System.Data.DataTableReader> sempre retorna os dados do tipo armazenado dentro do subjacente <xref:System.Data.DataColumn>, os valores retornados por meio da chamada a <xref:System.Data.DataTableReader.GetProviderSpecificValues%2A> método é sempre os mesmos tipos de dados armazenados no <xref:System.Data.DataTable>. Quando você trabalha com o <xref:System.Data.DataTableReader> classe, chamando o <xref:System.Data.DataTableReader.GetProviderSpecificValues%2A> método retorna os mesmos valores e tipos como chamar o <xref:System.Data.DataTableReader.GetValues%2A> método.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Data.DeletedRowInaccessibleException">Foi feita uma tentativa de recuperar dados de uma linha excluída.</exception>
        <exception cref="T:System.InvalidOperationException">Foi feita uma tentativa de ler ou acessar uma coluna em um <see cref="T:System.Data.DataTableReader" /> fechado.</exception>
        <altmember cref="M:System.Data.DataTableReader.GetValues(System.Object[])" />
      </Docs>
    </Member>
    <Member MemberName="GetSchemaTable">
      <MemberSignature Language="C#" Value="public override System.Data.DataTable GetSchemaTable ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Data.DataTable GetSchemaTable() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTableReader.GetSchemaTable" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetSchemaTable () As DataTable" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Data::DataTable ^ GetSchemaTable();" />
      <MemberSignature Language="F#" Value="override this.GetSchemaTable : unit -&gt; System.Data.DataTable" Usage="dataTableReader.GetSchemaTable " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataTable</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retorna um <see cref="T:System.Data.DataTable" /> que descreve os metadados da coluna do <see cref="T:System.Data.DataTableReader" />.</summary>
        <returns>Um <see cref="T:System.Data.DataTable" /> que descreve os metadados de coluna.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O método GetSchemaTable retorna metadados sobre cada coluna na seguinte ordem:  
  
|Coluna de DataReader|Descrição|  
|-----------------------|-----------------|  
|ColumnName|O nome da coluna como ele aparece no <xref:System.Data.DataTable>.|  
|ColumnOrdinal|O ordinal da coluna|  
|ColumnSize|-1 se o <xref:System.Data.Common.SchemaTableColumn.ColumnSize> (ou <xref:System.Data.DataColumn.MaxLength%2A>) propriedade da <xref:System.Data.DataColumn> não pode ser determinado ou não é relevante; caso contrário, 0 ou um inteiro positivo que contém o `MaxLength` valor.|  
|NumericPrecision|Se o tipo de coluna é um tipo numérico, essa é a precisão máxima da coluna. Se o tipo de coluna não é um tipo de dados numéricos, esse é um valor nulo.|  
|NumericScale|Se o tipo de dados de coluna tem um componente de escala, retorne o número de dígitos à direita da vírgula decimal. Caso contrário, retorna um valor nulo.|  
|DataType|O tipo subjacente da coluna.|  
|ProviderType|O indicador de tipo de dados da coluna. Se o tipo de dados da coluna varia de uma linha para outra, esse valor é <xref:System.Object>. Esta coluna não pode conter um valor nulo.|  
|IsLong|`true` Se o tipo de dados da coluna é <xref:System.String> e seu <xref:System.Data.DataColumn.MaxLength%2A> propriedade é -1. Caso contrário, `false`.|  
|AllowDBNull|`true` Se a restrição AllowDbNull for definida como true para a coluna; Caso contrário, `false`.|  
|IsReadOnly|`true` Se a coluna não pode ser modificada; Caso contrário, `false`.|  
|IsRowVersion|`false`, para cada coluna.|  
|IsUnique|`true`: Duas linhas não no <xref:System.Data.DataTable> pode ter o mesmo valor nesta coluna. `IsUnique` é garantido para ser true se a coluna representa uma chave por si só, ou se houver uma restrição de tipo UNIQUE que se aplica somente a esta coluna. `false`: A coluna pode conter valores duplicados no `DataTable`. O padrão desta coluna é `false`.|  
|IsKey|`true`: A coluna for de um conjunto de colunas que, juntas, identificam exclusivamente a linha a <xref:System.Data.DataTable>. O conjunto de colunas com `IsKey` definido como `true` deve identificar exclusivamente uma linha no `DataTable`. Não há nenhum requisito de que esse conjunto de colunas é um conjunto mínimo de colunas. Esse conjunto de colunas pode ser gerado por um `DataTable` chave primária, uma restrição exclusiva ou um índice exclusivo. `false`: A coluna não é necessário para identificar exclusivamente a linha. Esse valor é `true` se a coluna participa de uma chave primária única ou composta. Caso contrário, seu valor é `false`.|  
|IsAutoIncrement|`true`: A coluna atribui valores a novas linhas em incrementos fixos. `false`: A coluna não atribui valores às novas linhas em incrementos fixos. O padrão desta coluna é `false`.|  
|BaseCatalogName|O nome do catálogo no repositório de dados que contém a coluna. `Null` Se o nome do catálogo de base não puder ser determinado. O valor padrão para esta coluna é uma `null` valor.|  
|BaseSchemaName|Esse valor é sempre `Null`.|  
|BaseTableName|O nome do <xref:System.Data.DataTable>.|  
|BaseColumnName|O nome da coluna no <xref:System.Data.DataTable>.|  
|AutoIncrementSeed|O valor de <xref:System.Data.DataTable>do <xref:System.Data.DataColumn.AutoIncrementSeed%2A> propriedade.|  
|AutoIncrementStep|O valor de <xref:System.Data.DataTable>do <xref:System.Data.DataColumn.AutoIncrementStep%2A> propriedade.|  
|DefaultValue|O valor de <xref:System.Data.DataColumn>do <xref:System.Data.DataColumn.DefaultValue%2A> propriedade.|  
|Expressão|A cadeia de caracteres de expressão, se a coluna atual for uma coluna de expressão e todas as colunas usadas na expressão pertencem ao mesmo `T:System.Data.DataTable` que contém a coluna de expressão; caso contrário `null`.|  
|ColumnMapping|O <xref:System.Data.MappingType> valor associado com o <xref:System.Data.DataColumn>. O tipo pode ser um dos `Attribute`, `Element`, `Hidden`, ou `SimpleContent`. O valor padrão é `Element`.|  
|BaseTableNamespace|O valor de <xref:System.Data.DataTable>do <xref:System.Data.DataTable.Namespace%2A> propriedade.|  
|BaseColumnNamespace|O valor de <xref:System.Data.DataColumn>do <xref:System.Data.DataColumn.Namespace%2A> propriedade.|  
  
   
  
## Examples  
 O exemplo de aplicativo de console a seguir recupera informações de esquema sobre a coluna especificada. Passe o `DisplaySchemaTableInfo` procedimento um <xref:System.Data.DataTableReader> e um inteiro que representa a posição ordinal de uma coluna dentro de `DataTableReader`, e o procedimento gera informações de esquema para a janela do console.  
  
 [!code-csharp[DataWorks DataTableReader.GetSchemaTable#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTableReader.GetSchemaTable/CS/source.cs#1)]
 [!code-vb[DataWorks DataTableReader.GetSchemaTable#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTableReader.GetSchemaTable/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">O <see cref="T:System.Data.DataTableReader" /> está fechado.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetString">
      <MemberSignature Language="C#" Value="public override string GetString (int ordinal);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string GetString(int32 ordinal) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTableReader.GetString(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetString (ordinal As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ GetString(int ordinal);" />
      <MemberSignature Language="F#" Value="override this.GetString : int -&gt; string" Usage="dataTableReader.GetString ordinal" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ordinal" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="ordinal">O ordinal da coluna baseado em zero</param>
        <summary>Obtém o valor da coluna especificada como uma cadeia de caracteres.</summary>
        <returns>O valor da coluna especificada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Chamar <xref:System.Data.DataTableReader.IsDBNull%2A> para ver se há valores nulos antes de chamar esse método.  
  
   
  
## Examples  
 O exemplo a seguir exibe o conteúdo da coluna numerados como 2 no passado <xref:System.Data.DataTableReader>. Se o valor da coluna dentro de uma linha específica for nula, o código exibe o texto \<nulo >. Se os dados dentro da coluna do tipo correto, o exemplo exibem uma mensagem de erro para cada linha.  
  
 [!code-csharp[DataWorks DataTableReader.GetString#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTableReader.GetString/CS/source.cs#1)]
 [!code-vb[DataWorks DataTableReader.GetString#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTableReader.GetString/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">O índice passado estava fora do intervalo de 0 a <see cref="P:System.Data.DataTableReader.FieldCount" /> -1.</exception>
        <exception cref="T:System.Data.DeletedRowInaccessibleException">Foi feita uma tentativa de recuperar dados de uma linha excluída.</exception>
        <exception cref="T:System.InvalidOperationException">Foi feita uma tentativa de ler ou acessar uma coluna em um <see cref="T:System.Data.DataTableReader" /> fechado.</exception>
        <exception cref="T:System.InvalidCastException">A coluna especificada não contém uma cadeia de caracteres.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetValue">
      <MemberSignature Language="C#" Value="public override object GetValue (int ordinal);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance object GetValue(int32 ordinal) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTableReader.GetValue(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetValue (ordinal As Integer) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Object ^ GetValue(int ordinal);" />
      <MemberSignature Language="F#" Value="override this.GetValue : int -&gt; obj" Usage="dataTableReader.GetValue ordinal" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ordinal" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="ordinal">O ordinal da coluna baseado em zero</param>
        <summary>Obtém o valor da coluna especificada em seu formato nativo.</summary>
        <returns>O valor da coluna especificada. Esse método retorna <see langword="DBNull" /> para colunas nulas.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Embora você possa chamar <xref:System.Data.DataTableReader.IsDBNull%2A> para ver se há valores nulos antes de chamar esse método, você não precisa fazer isso.  
  
   
  
## Examples  
 O exemplo a seguir itera em todas as colunas dentro da linha atual em um <xref:System.Data.DataTableReader>, exibindo o conteúdo de cada coluna e o nome da coluna. Em geral, se seu objetivo é trabalhar com todas as colunas dentro de uma linha recuperada por um <xref:System.Data.DataTableReader>, considere usar o <xref:System.Data.DataTableReader.GetValues%2A> método em vez disso, porque ele é mais eficiente.  
  
 [!code-csharp[DataWorks DataTableReader.GetValue#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTableReader.GetValue/CS/source.cs#1)]
 [!code-vb[DataWorks DataTableReader.GetValue#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTableReader.GetValue/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">O índice passado estava fora do intervalo de 0 a <see cref="P:System.Data.DataTableReader.FieldCount" /> -1.</exception>
        <exception cref="T:System.Data.DeletedRowInaccessibleException">Foi feita uma tentativa de recuperar dados de uma linha excluída.</exception>
        <exception cref="T:System.InvalidOperationException">Foi feita uma tentativa de ler ou acessar colunas em um <see cref="T:System.Data.DataTableReader" /> fechado.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetValues">
      <MemberSignature Language="C#" Value="public override int GetValues (object[] values);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetValues(object[] values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTableReader.GetValues(System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetValues (values As Object()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetValues(cli::array &lt;System::Object ^&gt; ^ values);" />
      <MemberSignature Language="F#" Value="override this.GetValues : obj[] -&gt; int" Usage="dataTableReader.GetValues values" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="values" Type="System.Object[]" />
      </Parameters>
      <Docs>
        <param name="values">Uma matriz de <see cref="T:System.Object" /> para a qual copiar os valores da coluna de <see cref="T:System.Data.DataTableReader" />.</param>
        <summary>Popula uma matriz de objetos com os valores da coluna da linha atual.</summary>
        <returns>O número de valores de coluna copiados para a matriz.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para a maioria dos aplicativos, esse método fornece um meio eficaz para recuperar todas as colunas, em vez de recuperar cada coluna individualmente. Se sua intenção for recuperar os valores de coluna de uma linha dentro de <xref:System.Data.DataTableReader>, o `GetValues` método fornece a solução mais eficiente.  
  
 Você pode passar um <xref:System.Object> matriz que contém menos do que o número de colunas que estão contidos na linha resultante. Somente a quantidade de dados a `Object` matriz pode conter é copiado para a matriz. Você também pode passar um `Object` matriz cujo tamanho é maior que o número de colunas que estão contidos na linha resultante, nesse caso, os elementos da matriz adicional permanece inalterado pela chamada de método.  
  
 Esse método coloca `DBNull` na matriz de saída para colunas nulas.  
  
   
  
## Examples  
 O exemplo a seguir demonstra o uso de uma matriz que é o tamanho correto, para ler todos os valores da linha atual fornecido <xref:System.Data.DataTableReader>. Além disso, o exemplo demonstra o uso de uma matriz de tamanho fixo que pode ser menor ou maior que o número de colunas disponíveis.  
  
 [!code-csharp[DataWorks DataTableReader.GetValueObject#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTableReader.GetValueObject/CS/source.cs#1)]
 [!code-vb[DataWorks DataTableReader.GetValueObject#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTableReader.GetValueObject/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">O índice passado estava fora do intervalo de 0 a <see cref="P:System.Data.DataTableReader.FieldCount" /> -1.</exception>
        <exception cref="T:System.Data.DeletedRowInaccessibleException">Foi feita uma tentativa de recuperar dados de uma linha excluída.</exception>
        <exception cref="T:System.InvalidOperationException">Foi feita uma tentativa de ler ou acessar uma coluna em um <see cref="T:System.Data.DataTableReader" /> fechado.</exception>
      </Docs>
    </Member>
    <Member MemberName="HasRows">
      <MemberSignature Language="C#" Value="public override bool HasRows { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool HasRows" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataTableReader.HasRows" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property HasRows As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool HasRows { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.HasRows : bool" Usage="System.Data.DataTableReader.HasRows" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém um valor que indica se o <see cref="T:System.Data.DataTableReader" /> contém uma ou mais linhas.</summary>
        <value><see langword="true" /> se o <see cref="T:System.Data.DataTableReader" /> contiver uma ou mais linhas; caso contrário, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O `HasRows` propriedade retorna informações sobre o conjunto de resultados atual. Se o <xref:System.Data.DataTableReader> contém o resultado de vários conjuntos, você pode examinar o valor da `HasRows` propriedade imediatamente depois de chamar o <xref:System.Data.DataTableReader.NextResult%2A> método para determinar se o novo conjunto de resultados contém linhas.  
  
 Use o `HasRows` propriedade para evitar a necessidade de chamar o <xref:System.Data.DataTableReader.Read%2A> método o <xref:System.Data.DataTableReader> se não houver nenhuma linha no conjunto de resultados atual.  
  
   
  
## Examples  
 O exemplo a seguir preenche dois <xref:System.Data.DataTable> instâncias com dados. A primeira <xref:System.Data.DataTable> contém uma linha, e o segundo não contém nenhuma linha. O exemplo a seguir cria uma <xref:System.Data.DataTableReader> que contém ambos <xref:System.Data.DataTable> objetos e, em seguida, chama o método PrintData para exibir o conteúdo de cada um, verificando o valor do <xref:System.Data.DataTableReader.HasRows%2A> propriedade de cada antes que ele faz a chamada para PrintData.  
  
 [!code-csharp[DataWorks DataTableReader.HasRows#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTableReader.HasRows/CS/source.cs#1)]
 [!code-vb[DataWorks DataTableReader.HasRows#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTableReader.HasRows/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Foi feita uma tentativa de recuperar informações sobre um <see cref="T:System.Data.DataTableReader" /> fechado.</exception>
        <altmember cref="M:System.Data.DataTableReader.NextResult" />
        <altmember cref="M:System.Data.DataTableReader.Read" />
      </Docs>
    </Member>
    <Member MemberName="IsClosed">
      <MemberSignature Language="C#" Value="public override bool IsClosed { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsClosed" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataTableReader.IsClosed" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property IsClosed As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsClosed { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsClosed : bool" Usage="System.Data.DataTableReader.IsClosed" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém um valor que indica se o <see cref="T:System.Data.DataTableReader" /> está fechado.</summary>
        <value>Retorna <see langword="true" /> se o <see cref="T:System.Data.DataTableReader" /> estiver fechado; caso contrário, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.DataTableReader.Close%2A> é o único método e `IsClosed` e <xref:System.Data.DataTableReader.RecordsAffected%2A> são as únicas propriedades que podem ser acessadas após a <xref:System.Data.DataTableReader> foi fechado.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsDBNull">
      <MemberSignature Language="C#" Value="public override bool IsDBNull (int ordinal);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool IsDBNull(int32 ordinal) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTableReader.IsDBNull(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function IsDBNull (ordinal As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool IsDBNull(int ordinal);" />
      <MemberSignature Language="F#" Value="override this.IsDBNull : int -&gt; bool" Usage="dataTableReader.IsDBNull ordinal" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ordinal" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="ordinal">O ordinal da coluna baseado em zero</param>
        <summary>Obtém um valor que indica se a coluna contém valores ausentes ou inexistente.</summary>
        <returns><see langword="true" /> se o valor da coluna especificada for equivalente a <see cref="T:System.DBNull" />; caso contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Chame esse método para verificar se há valores de coluna nulos antes de chamar os métodos get tipado (por exemplo, <xref:System.Data.DataTableReader.GetByte%2A>, <xref:System.Data.DataTableReader.GetChar%2A>e assim por diante) para evitar gerar um erro.  
  
   
  
## Examples  
 O exemplo a seguir exibe o conteúdo da coluna numerados como 2 no passado <xref:System.Data.DataTableReader>. Se o valor da coluna dentro de uma linha específica for nula, o código exibe o texto \<nulo >. Se os dados dentro da coluna do tipo correto, o exemplo exibem uma mensagem de erro para cada linha.  
  
 [!code-csharp[DataWorks DataTableReader.IsDbNull#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTableReader.IsDbNull/CS/source.cs#1)]
 [!code-vb[DataWorks DataTableReader.IsDbNull#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTableReader.IsDbNull/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">O índice passado estava fora do intervalo de 0 a <see cref="P:System.Data.DataTableReader.FieldCount" /> -1.</exception>
        <exception cref="T:System.Data.DeletedRowInaccessibleException">Foi feita uma tentativa de recuperar dados de uma linha excluída.</exception>
        <exception cref="T:System.InvalidOperationException">Foi feita uma tentativa de ler ou acessar uma coluna em um <see cref="T:System.Data.DataTableReader" /> fechado.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Item">
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Obtém o valor da coluna especificada em seu formato nativo.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Item">
      <MemberSignature Language="C#" Value="public override object this[int ordinal] { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object Item(int32)" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataTableReader.Item(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Default Public Overrides ReadOnly Property Item(ordinal As Integer) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Object ^ default[int] { System::Object ^ get(int ordinal); };" />
      <MemberSignature Language="F#" Value="member this.Item(int) : obj" Usage="System.Data.DataTableReader.Item" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ordinal" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="ordinal">O ordinal da coluna baseado em zero.</param>
        <summary>Obtém o valor da coluna especificada em seu formato nativo de acordo com o ordinal da coluna.</summary>
        <value>O valor da coluna especificada em seu formato nativo.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Essa sobrecarga para <xref:System.Data.DataTableReader.Item%2A> se comporta de forma idêntica ao <xref:System.Data.DataTableReader.GetValue%2A> método.  
  
   
  
## Examples  
 O exemplo a seguir exibe o conteúdo de todas as colunas em todas as linhas de fornecido <xref:System.Data.DataTableReader>. O código usa o <xref:System.Data.DataTableReader.Item%2A> método (o indexador, no Microsoft c#) para recuperar o valor contido em cada coluna.  
  
 [!code-csharp[DataWorks DataTableReader.Item#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTableReader.Item/CS/source.cs#1)]
 [!code-vb[DataWorks DataTableReader.Item#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTableReader.Item/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IndexOutOfRangeException">O índice passado estava fora do intervalo de 0 a <see cref="P:System.Data.DataTableReader.FieldCount" /> -1.</exception>
        <altmember cref="M:System.Data.DataTableReader.GetValue(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Item">
      <MemberSignature Language="C#" Value="public override object this[string name] { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object Item(string)" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataTableReader.Item(System.String)" />
      <MemberSignature Language="VB.NET" Value="Default Public Overrides ReadOnly Property Item(name As String) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Object ^ default[System::String ^] { System::Object ^ get(System::String ^ name); };" />
      <MemberSignature Language="F#" Value="member this.Item(string) : obj" Usage="System.Data.DataTableReader.Item" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">O nome da coluna.</param>
        <summary>Obtém o valor da coluna especificada em seu formato nativo de acordo com o nome da coluna.</summary>
        <value>O valor da coluna especificada em seu formato nativo.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Uma pesquisa diferencia maiusculas de minúsculas é realizada pela primeira vez. Se ele falhar, uma segunda pesquisa diferencia maiusculas de minúsculas será feita.  
  
 Esse método não distingue largura kana.  
  
 Essa versão sobrecarregada de <xref:System.Data.DataTableReader.Item%2A> corresponde ao chamar o <xref:System.Data.DataTableReader.GetOrdinal%2A> método e, em seguida, chamar subsequentemente o <xref:System.Data.DataTableReader.GetValue%2A> método.  
  
   
  
## Examples  
 Dado um <xref:System.Data.DataTableReader> e um nome de coluna, o procedimento GetValueByName retorna o valor da coluna especificada. Antes de chamar esse procedimento, você deve criar um novo <xref:System.Data.DataTableReader> da instância e chamar seu método Read pelo menos uma vez para posicionar o ponteiro de linha em uma linha de dados.  
  
 [!code-csharp[DataWorks DataTableReader.ItemName#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTableReader.ItemName/CS/source.cs#1)]
 [!code-vb[DataWorks DataTableReader.ItemName#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTableReader.ItemName/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">O nome especificado não é um nome de coluna válido.</exception>
        <exception cref="T:System.Data.DeletedRowInaccessibleException">Foi feita uma tentativa de recuperar dados de uma linha excluída.</exception>
        <exception cref="T:System.InvalidOperationException">Foi feita uma tentativa de ler ou acessar uma coluna em um <see cref="T:System.Data.DataTableReader" /> fechado.</exception>
      </Docs>
    </Member>
    <Member MemberName="NextResult">
      <MemberSignature Language="C#" Value="public override bool NextResult ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool NextResult() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTableReader.NextResult" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function NextResult () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool NextResult();" />
      <MemberSignature Language="F#" Value="override this.NextResult : unit -&gt; bool" Usage="dataTableReader.NextResult " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Avança o <see cref="T:System.Data.DataTableReader" /> para o próximo conjunto de resultados, se houver.</summary>
        <returns><see langword="true" /> se houver outro conjunto de resultados; caso contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Usado para processar vários resultados que podem ser gerados com a criação de um <xref:System.Data.DataTableReader> em um <xref:System.Data.DataSet> que contém duas ou mais tabelas ou uma matriz que contém duas ou mais <xref:System.Data.DataTable> instâncias.  
  
 Um novo <xref:System.Data.DataTableReader> é posicionado no primeiro resultado.  
  
   
  
## Examples  
 No exemplo a seguir, o método TestConstructor cria dois <xref:System.Data.DataTable> instâncias. Para demonstrar esse construtor para o <xref:System.Data.DataTableReader> classe, o exemplo cria um novo `DataTableReader` com base em uma matriz que contém os dois `DataTables`e executa uma operação simple, imprimir o conteúdo de algumas colunas primeiro no console janela. Para testar este aplicativo, crie um novo aplicativo de Console e cole o código de exemplo para o arquivo recém-criado.  
  
 [!code-csharp[DataWorks DataTableReader.NextResult#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTableReader.NextResult/CS/source.cs#1)]
 [!code-vb[DataWorks DataTableReader.NextResult#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTableReader.NextResult/VB/source.vb#1)]  
  
 A janela do Console exibe os seguintes resultados:  
  
```  
1 Mary  
2 Andy  
3 Peter  
4 Russ  
1 Wireless Network Card  
2 Hard Drive  
3 Monitor  
4 CPU  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Foi feita uma tentativa de navegar em um <see cref="T:System.Data.DataTableReader" /> fechado.</exception>
      </Docs>
    </Member>
    <Member MemberName="Read">
      <MemberSignature Language="C#" Value="public override bool Read ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Read() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTableReader.Read" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Read () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Read();" />
      <MemberSignature Language="F#" Value="override this.Read : unit -&gt; bool" Usage="dataTableReader.Read " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Avança o <see cref="T:System.Data.DataTableReader" /> para o próximo registro.</summary>
        <returns><see langword="true" /> se houver outra linha a ser lida; caso contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A posição padrão do <xref:System.Data.DataTableReader> é antes do primeiro registro. Portanto, você deve chamar `Read` para começar a acessar todos os dados.  
  
   
  
## Examples  
 O procedimento PrintColumns executa um loop em todas as linhas as <xref:System.Data.DataTableReader>, exibindo o conteúdo de cada coluna na janela do Console.  
  
 [!code-csharp[DataWorks DataTableReader.Read#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTableReader.Read/CS/source.cs#1)]
 [!code-vb[DataWorks DataTableReader.Read#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTableReader.Read/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Foi feita uma tentativa de ler ou acessar uma coluna em um <see cref="T:System.Data.DataTableReader" /> fechado.</exception>
      </Docs>
    </Member>
    <Member MemberName="RecordsAffected">
      <MemberSignature Language="C#" Value="public override int RecordsAffected { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 RecordsAffected" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataTableReader.RecordsAffected" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property RecordsAffected As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int RecordsAffected { int get(); };" />
      <MemberSignature Language="F#" Value="member this.RecordsAffected : int" Usage="System.Data.DataTableReader.RecordsAffected" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém o número de linhas inseridas, alteradas ou excluídas pela execução da instrução SQL.</summary>
        <value>O <see cref="T:System.Data.DataTableReader" /> não dá suporte a essa propriedade e sempre retorna 0.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>