<Type Name="DataSet" FullName="System.Data.DataSet">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="ec9e5fff5e07bca319a9c925c53f91dac22c30f5" />
    <Meta Name="ms.sourcegitcommit" Value="ad09e88f48ca55b181e8d272cfc3742eadc3f939" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="pt-BR" />
    <Meta Name="ms.lasthandoff" Value="06/08/2018" />
    <Meta Name="ms.locfileid" Value="35231158" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class DataSet : System.ComponentModel.MarshalByValueComponent, System.ComponentModel.IListSource, System.ComponentModel.ISupportInitialize, System.ComponentModel.ISupportInitializeNotification, System.Runtime.Serialization.ISerializable, System.Xml.Serialization.IXmlSerializable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit DataSet extends System.ComponentModel.MarshalByValueComponent implements class System.ComponentModel.IListSource, class System.ComponentModel.ISupportInitialize, class System.ComponentModel.ISupportInitializeNotification, class System.Runtime.Serialization.ISerializable, class System.Xml.Serialization.IXmlSerializable" />
  <TypeSignature Language="DocId" Value="T:System.Data.DataSet" />
  <TypeSignature Language="VB.NET" Value="Public Class DataSet&#xA;Inherits MarshalByValueComponent&#xA;Implements IListSource, ISerializable, ISupportInitialize, ISupportInitializeNotification, IXmlSerializable" />
  <TypeSignature Language="C++ CLI" Value="public ref class DataSet : System::ComponentModel::MarshalByValueComponent, System::ComponentModel::IListSource, System::ComponentModel::ISupportInitialize, System::ComponentModel::ISupportInitializeNotification, System::Runtime::Serialization::ISerializable, System::Xml::Serialization::IXmlSerializable" />
  <AssemblyInfo>
    <AssemblyName>System.Data</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Data.Common</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.ComponentModel.MarshalByValueComponent</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.ComponentModel.IListSource</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.ComponentModel.ISupportInitialize</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.ComponentModel.ISupportInitializeNotification</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Runtime.Serialization.ISerializable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Xml.Serialization.IXmlSerializable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.ComponentModel.DefaultProperty("DataSetName")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.ComponentModel.Designer("Microsoft.VSDesigner.Data.VS.DataSetDesigner, Microsoft.VSDesigner, Version=0.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.ComponentModel.ToolboxItem("Microsoft.VSDesigner.Data.VS.DataSetToolboxItem, Microsoft.VSDesigner, Version=0.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Xml.Serialization.XmlRoot("DataSet")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Xml.Serialization.XmlSchemaProvider("GetDataSetSchema")</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Representa um cache de dados na memória.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Data.DataSet>, que é um cache na memória de dados recuperados de uma fonte de dados é um componente importante da arquitetura do ADO.NET. O <xref:System.Data.DataSet> consiste em uma coleção de <xref:System.Data.DataTable> objetos que você pode se relacionam entre si com <xref:System.Data.DataRelation> objetos. Você também pode impor a integridade de dados no <xref:System.Data.DataSet> usando o <xref:System.Data.UniqueConstraint> e <xref:System.Data.ForeignKeyConstraint> objetos. Para obter mais detalhes sobre como trabalhar com <xref:System.Data.DataSet> objetos, consulte [DataSets, DataTables e DataViews](~/docs/framework/data/adonet/dataset-datatable-dataview/index.md).  
  
 Enquanto <xref:System.Data.DataTable> objetos contêm os dados, o <xref:System.Data.DataRelationCollection> permite que você navegue pelas hierarquia da tabela. As tabelas estão contidas em um <xref:System.Data.DataTableCollection> acessados por meio de <xref:System.Data.DataSet.Tables%2A> propriedade. Ao acessar <xref:System.Data.DataTable> objetos, observe que eles são condicionalmente diferencia maiusculas de minúsculas. Por exemplo, se um <xref:System.Data.DataTable> chamado "mydatatable" e outro chamado "Mydatatable", uma cadeia de caracteres usada para pesquisar uma das tabelas é considerada como maiusculas e minúsculas. No entanto, se existe "mydatatable" e "Mydatatable" não, a cadeia de caracteres de pesquisa é considerada como maiusculas e minúsculas. Para obter mais informações sobre como trabalhar com <xref:System.Data.DataTable> objetos, consulte [criando um DataTable](~/docs/framework/data/adonet/dataset-datatable-dataview/creating-a-datatable.md).  
  
 Um <xref:System.Data.DataSet> pode ler e gravar dados e esquema como documentos XML. Os dados e esquema podem ser transportados em HTTP e usadas por qualquer aplicativo, em qualquer plataforma que é habilitado para XML. Você pode salvar o esquema como um esquema XML com o <xref:System.Data.DataSet.WriteXmlSchema%2A> método e esquema e os dados podem ser salvos usando o <xref:System.Data.DataSet.WriteXml%2A> método. Para ler um documento XML que inclui o esquema e dados, use o <xref:System.Data.DataSet.ReadXml%2A> método.  
  
 Em uma implementação típica de várias camadas, as etapas para criar e atualizar um <xref:System.Data.DataSet>, e por sua vez, atualizando os dados originais são para:  
  
1.  Criar e preencher cada <xref:System.Data.DataTable> em uma <xref:System.Data.DataSet> com dados de uma fonte de dados usando um <xref:System.Data.Common.DataAdapter>.  
  
2.  Alterar os dados na individuais <xref:System.Data.DataTable> objetos adicionando, atualizando ou excluindo <xref:System.Data.DataRow> objetos.  
  
3.  Invocar o <xref:System.Data.DataSet.GetChanges%2A> método para criar um segundo <xref:System.Data.DataSet> que recursos apenas as alterações aos dados.  
  
4.  Chamar o <xref:System.Data.Common.DataAdapter.Update%2A> método o <xref:System.Data.Common.DataAdapter>, passando o segundo <xref:System.Data.DataSet> como um argumento.  
  
5.  Invocar o <xref:System.Data.DataSet.Merge%2A> método para mesclar as alterações da segunda <xref:System.Data.DataSet> o primeiro.  
  
6.  Invocar o <xref:System.Data.DataSet.AcceptChanges%2A> sobre o <xref:System.Data.DataSet>. Como alternativa, invocar <xref:System.Data.DataSet.RejectChanges%2A> para cancelar as alterações.  
  
> [!NOTE]
>  O <xref:System.Data.DataSet> e <xref:System.Data.DataTable> objetos herdam <xref:System.ComponentModel.MarshalByValueComponent>e oferece suporte a <xref:System.Runtime.Serialization.ISerializable> interface de comunicação remota. Esses são os únicos objetos ADO.NET que podem ser remotos.  
  
> [!NOTE]
>  Classes herdadas de <xref:System.Data.DataSet> não são finalizados pelo coletor de lixo, pois o finalizador foram suprimido no <xref:System.Data.DataSet>. A classe derivada pode chamar o <xref:System.GC.ReRegisterForFinalize%2A> método no construtor para permitir que a classe a ser finalizada pelo coletor de lixo.  
  
   
  
## Examples  
 O exemplo a seguir consiste em vários métodos que, combinados, criar e preencher uma <xref:System.Data.DataSet> do **Northwind** banco de dados.  
  
 [!code-csharp[Classic WebData DataSet Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet Example/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe>Este tipo é seguro para operações de leitura e multithread. Você deve sincronizar todas as operações de gravação.</threadsafe>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicializa uma nova instância da classe <see cref="T:System.Data.DataSet" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DataSet ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DataSet();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inicializa uma nova instância da classe <see cref="T:System.Data.DataSet" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Essa implementação do <xref:System.Data.DataSet> construtor sem parâmetros e cria um nome padrão, "NewDataSet", para a nova instância.  
  
 Um nome para o <xref:System.Data.DataSet> é necessário para garantir que a representação XML do <xref:System.Data.DataSet> sempre tem um nome para o elemento do documento, que é o elemento de nível mais alto em uma definição de esquema.  
  
   
  
## Examples  
 O exemplo a seguir cria um novo <xref:System.Data.DataSet>e adiciona dois <xref:System.Data.DataTable> objetos a ele.  
  
 [!code-vb[Classic WebData DataSet.DataSet Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.DataSet Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Data.DataTableCollection" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DataSet (string dataSetName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string dataSetName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.#ctor(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (dataSetName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DataSet(System::String ^ dataSetName);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="dataSetName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="dataSetName">O nome do <see cref="T:System.Data.DataSet" />.</param>
        <summary>Inicializa uma nova instância de uma classe <see cref="T:System.Data.DataSet" /> com o nome especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Um nome para o <xref:System.Data.DataSet> é necessário para garantir que a representação XML do <xref:System.Data.DataSet> sempre tem um nome para o elemento do documento, que é o elemento de nível mais alto em uma definição de esquema.  
  
   
  
## Examples  
 O exemplo a seguir cria um novo <xref:System.Data.DataSet>, para que duas <xref:System.Data.DataTable> objetos são adicionados.  
  
 [!code-vb[Classic WebData DataSet.DataSet1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.DataSet1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Data.DataSet.DataSetName" />
        <altmember cref="T:System.Data.DataTableCollection" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected DataSet (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(class System.Runtime.Serialization.SerializationInfo info, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New (info As SerializationInfo, context As StreamingContext)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; DataSet(System::Runtime::Serialization::SerializationInfo ^ info, System::Runtime::Serialization::StreamingContext context);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="info" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="info">Os dados necessários para serializar ou desserializar um objeto.</param>
        <param name="context">A origem e o destino de um determinado fluxo serializado.</param>
        <summary>Inicializa uma nova instância de uma classe <see cref="T:System.Data.DataSet" /> que tem as informações de serialização e contexto fornecidas.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected DataSet (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context, bool ConstructSchema);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(class System.Runtime.Serialization.SerializationInfo info, valuetype System.Runtime.Serialization.StreamingContext context, bool ConstructSchema) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New (info As SerializationInfo, context As StreamingContext, ConstructSchema As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; DataSet(System::Runtime::Serialization::SerializationInfo ^ info, System::Runtime::Serialization::StreamingContext context, bool ConstructSchema);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="info" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" />
        <Parameter Name="ConstructSchema" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="info">O objeto <see cref="T:System.Runtime.Serialization.SerializationInfo" />.</param>
        <param name="context">O objeto <see cref="T:System.Runtime.Serialization.StreamingContext" />.</param>
        <param name="ConstructSchema">O valor booliano.</param>
        <summary>Inicializa uma nova instância da classe <see cref="T:System.Data.DataSet" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AcceptChanges">
      <MemberSignature Language="C#" Value="public void AcceptChanges ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AcceptChanges() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.AcceptChanges" />
      <MemberSignature Language="VB.NET" Value="Public Sub AcceptChanges ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AcceptChanges();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Confirma todas as alterações feitas nesse <see cref="T:System.Data.DataSet" /> desde que foi carregado ou desde a última vez que <see cref="M:System.Data.DataSet.AcceptChanges" /> foi chamado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Tanto o <xref:System.Data.DataRow> e <xref:System.Data.DataTable> classes têm <xref:System.Data.DataSet.AcceptChanges%2A> métodos. Chamando <xref:System.Data.DataTable.AcceptChanges%2A> no <xref:System.Data.DataTable> faz com que o nível de <xref:System.Data.DataRow.AcceptChanges%2A> método para cada <xref:System.Data.DataRow> a ser chamado. Da mesma forma, invocar <xref:System.Data.DataSet.AcceptChanges%2A> no <xref:System.Data.DataSet> faz com que <xref:System.Data.DataTable.AcceptChanges%2A> seja chamado em cada tabela dentro a <xref:System.Data.DataSet>. Dessa maneira, você tem vários níveis em que o método pode ser chamado. Chamando o <xref:System.Data.DataSet.AcceptChanges%2A> do <xref:System.Data.DataSet> permite que você chame o método em todos os objetos subordinados (por exemplo, tabelas e linhas) com uma chamada.  
  
 Quando você chama `AcceptChanges` no `DataSet`, qualquer <xref:System.Data.DataRow> objetos ainda no modo de edição terminam suas edições com êxito. O <xref:System.Data.DataRow.RowState%2A> propriedade de cada <xref:System.Data.DataRow> também será alterado; `Added` e `Modified` linhas se tornam `Unchanged`, e `Deleted` linhas são removidas.  
  
 Se o `DataSet` contém <xref:System.Data.ForeignKeyConstraint> objetos, invocando o `AcceptChanges` também faz com que o método de <xref:System.Data.ForeignKeyConstraint.AcceptRejectRule%2A> devem ser aplicadas.  
  
> [!NOTE]
>  `AcceptChanges` e `RejectChanges` só se aplicam a `DataRow` relacionados a alterações (ou seja, adicionar, remover, excluir e modificar). Eles não são aplicáveis para o esquema ou alterações estruturais.  
>   
>  Chamar AcceptChanges não replicará essas alterações de volta para a fonte de dados se o conjunto de dados tenha sido preenchido usando um DataAdapter. Nessa situação, chame <xref:System.Data.Common.DataAdapter.Update%2A> em vez disso. Consulte [Atualizar fontes de dados com DataAdapters](http://msdn.microsoft.com/library/33y2221y.aspx) para obter mais informações.  
  
   
  
## Examples  
 O exemplo a seguir adiciona uma <xref:System.Data.DataRow> para um <xref:System.Data.DataTable> em um <xref:System.Data.DataSet>. O <xref:System.Data.DataSet.AcceptChanges%2A> método é chamado no <xref:System.Data.DataSet>, que transforma em cascata para todos os <xref:System.Data.DataTable> objetos que ele contém.  
  
 [!code-csharp[Classic WebData DataSet.AcceptChanges#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.AcceptChanges/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.AcceptChanges#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.AcceptChanges/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginInit">
      <MemberSignature Language="C#" Value="public void BeginInit ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void BeginInit() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.BeginInit" />
      <MemberSignature Language="VB.NET" Value="Public Sub BeginInit ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void BeginInit();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Começa a inicialização de um <see cref="T:System.Data.DataSet" /> usado em um formulário ou por outro componente. A inicialização ocorre no tempo de execução.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O ambiente de design do Visual Studio .NET usa esse método para iniciar a inicialização de um componente que é usado em um formulário ou por outro componente. O <xref:System.Data.DataSet.EndInit%2A> método termina a inicialização. Usando o <xref:System.Data.DataSet.BeginInit%2A> e <xref:System.Data.DataSet.EndInit%2A> métodos impede que o controle que está sendo usada antes de ser totalmente inicializado.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CaseSensitive">
      <MemberSignature Language="C#" Value="public bool CaseSensitive { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CaseSensitive" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataSet.CaseSensitive" />
      <MemberSignature Language="VB.NET" Value="Public Property CaseSensitive As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool CaseSensitive { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define um valor que indica se comparações de cadeia de caracteres dentro de objetos <see cref="T:System.Data.DataTable" /> diferenciam maiúsculas de minúsculas.</summary>
        <value>
          <see langword="true" /> se as comparações de cadeias de caracteres diferenciarem maiúsculas de minúsculas; caso contrário, <see langword="false" />. O padrão é <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Data.DataSet.CaseSensitive%2A> propriedade afeta como classificação, pesquisa e operações de filtragem são executadas em cada <xref:System.Data.DataTable> objeto contido em um <xref:System.Data.DataSet> ao usar o <xref:System.Data.DataTable.Select%2A> método.  
  
 Por padrão, definindo o <xref:System.Data.DataSet.CaseSensitive%2A> propriedade para um <xref:System.Data.DataSet> também define o <xref:System.Data.DataTable.CaseSensitive%2A> propriedade de cada um associado <xref:System.Data.DataTable> com o mesmo valor.  
  
   
  
## Examples  
 O exemplo a seguir alterna o <xref:System.Data.DataSet.CaseSensitive%2A> propriedade.  
  
 [!code-vb[Classic WebData DataSet.CaseSensitive Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.CaseSensitive Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Clear">
      <MemberSignature Language="C#" Value="public void Clear ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Clear() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.Clear" />
      <MemberSignature Language="VB.NET" Value="Public Sub Clear ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Clear();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Limpa o <see cref="T:System.Data.DataSet" /> de todos os dados, removendo todas as linhas em todas as tabelas.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se o <xref:System.Data.DataSet> está associado a um <xref:System.Xml.XmlDataDocument>, chamar <xref:System.Data.DataSet.Clear%2A?displayProperty=nameWithType> ou <xref:System.Data.DataTable.Clear%2A?displayProperty=nameWithType> gera o <xref:System.NotSupportedException>. Para evitar essa situação, percorra cada tabela, removendo cada linha, um por vez.  
  
   
  
## Examples  
 O exemplo a seguir limpa o <xref:System.Data.DataSet> de todas as linhas em todas as tabelas.  
  
 [!code-csharp[Classic WebData DataSet.Clear Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.Clear Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.Clear Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.Clear Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Clone">
      <MemberSignature Language="C#" Value="public virtual System.Data.DataSet Clone ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Data.DataSet Clone() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.Clone" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Clone () As DataSet" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Data::DataSet ^ Clone();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataSet</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Copia a estrutura do <see cref="T:System.Data.DataSet" />, incluindo todos os esquemas, relações e restrições <see cref="T:System.Data.DataTable" />. Não copia todos os dados.</summary>
        <returns>Um novo <see cref="T:System.Data.DataSet" /> com o mesmo esquema que o <see cref="T:System.Data.DataSet" /> atual, mas sem nenhum dado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Se essas classes têm sido derivadas, também será o clone das subclasses mesmo.  
  
   
  
## Examples  
 O exemplo a seguir cria um clone de um <xref:System.Data.DataSet> esquema do objeto.  
  
 [!code-csharp[Classic WebData DataSet.Clone Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.Clone Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.Clone Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.Clone Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Data.DataSet.Copy" />
      </Docs>
    </Member>
    <Member MemberName="Copy">
      <MemberSignature Language="C#" Value="public System.Data.DataSet Copy ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.DataSet Copy() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.Copy" />
      <MemberSignature Language="VB.NET" Value="Public Function Copy () As DataSet" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::DataSet ^ Copy();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataSet</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Copia a estrutura e os dados para este <see cref="T:System.Data.DataSet" />.</summary>
        <returns>Um novo <see cref="T:System.Data.DataSet" /> com a mesma estrutura (esquemas de tabela, relações e restrições) e dados que esse <see cref="T:System.Data.DataSet" />.  
  
 <block subset="none" type="note"><para> Se essas classes tiverem sido subclassificadas, a cópia também pertencerá às mesmas subclasses. </para></block></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O exemplo a seguir usa o <xref:System.Data.DataSet.Copy%2A> método para criar uma cópia do original <xref:System.Data.DataSet>.  
  
 [!code-csharp[Classic WebData DataSet.Copy Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.Copy Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.Copy Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.Copy Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Data.DataSet.Clone" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateDataReader">
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Retorna um <see cref="T:System.Data.DataTableReader" /> com um resultado definido por <see cref="T:System.Data.DataTable" />, na mesma sequência em que as tabelas são exibidas na coleção <see cref="P:System.Data.DataSet.Tables" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para garantir a ordem dos conjuntos de resultados em retornado <xref:System.Data.DataTableReader>, se um <xref:System.Data.DataTable> dentro a <xref:System.Data.DataSet> está vazio, ele será representado por um resultado vazio definido em retornado `DataTableReader`.  
  
   
  
## Examples  
 Neste exemplo, um aplicativo de Console, cria três <xref:System.Data.DataTable> instâncias e adiciona cada um para um <xref:System.Data.DataSet>. O exemplo chama o <xref:System.Data.DataSet.CreateDataReader%2A> método e exibe o conteúdo do retornado <xref:System.Data.DataTableReader>. Observe que define a ordem do resultado da `DataTableReader` é controlada pela ordem do `DataTable` instâncias passadas como parâmetros.  
  
> [!NOTE]
>  Este exemplo mostra como usar uma das versões sobrecarregadas de `CreateDataReader`. Para obter outros exemplos que possam estar disponíveis, consulte os tópicos de sobrecarga individuais.  
  
 [!code-csharp[DataWorks DataSet.CreateDataReader#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataSet.CreateDataReader/CS/source.cs#1)]
 [!code-vb[DataWorks DataSet.CreateDataReader#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataSet.CreateDataReader/VB/source.vb#1)]  
  
 O exemplo exibe o código a seguir na janela do Console:  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateDataReader">
      <MemberSignature Language="C#" Value="public System.Data.DataTableReader CreateDataReader ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.DataTableReader CreateDataReader() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.CreateDataReader" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateDataReader () As DataTableReader" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::DataTableReader ^ CreateDataReader();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataTableReader</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retorna um <see cref="T:System.Data.DataTableReader" /> com um resultado definido por <see cref="T:System.Data.DataTable" />, na mesma sequência em que as tabelas são exibidas na coleção <see cref="P:System.Data.DataSet.Tables" />.</summary>
        <returns>Um <see cref="T:System.Data.DataTableReader" /> que contém um ou mais conjuntos de resultados, correspondentes às instâncias <see cref="T:System.Data.DataTable" /> contidas no <see cref="T:System.Data.DataSet" /> de origem.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para garantir a ordem dos conjuntos de resultados em retornado <xref:System.Data.DataTableReader>, se um <xref:System.Data.DataTable> dentro a <xref:System.Data.DataSet> está vazio, é representado por um resultado vazio definido em retornado `DataTableReader`.  
  
   
  
## Examples  
 O exemplo a seguir cria três <xref:System.Data.DataTable> instâncias e adiciona cada um para um <xref:System.Data.DataSet>. O exemplo, em seguida, passa o preenchido `DataSet` para um procedimento que chama o <xref:System.Data.DataSet.CreateDataReader%2A> método e prossegue para iterar por todos os conjuntos de resultados contidos a <xref:System.Data.DataTableReader>. O exemplo exibe os resultados na janela do Console.  
  
 [!code-csharp[DataWorks DataSet.DataTableReader#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataSet.DataTableReader/CS/source.cs#1)]
 [!code-vb[DataWorks DataSet.DataTableReader#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataSet.DataTableReader/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateDataReader">
      <MemberSignature Language="C#" Value="public System.Data.DataTableReader CreateDataReader (params System.Data.DataTable[] dataTables);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.DataTableReader CreateDataReader(class System.Data.DataTable[] dataTables) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.CreateDataReader(System.Data.DataTable[])" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateDataReader (ParamArray dataTables As DataTable()) As DataTableReader" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::DataTableReader ^ CreateDataReader(... cli::array &lt;System::Data::DataTable ^&gt; ^ dataTables);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataTableReader</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dataTables" Type="System.Data.DataTable[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="dataTables">Uma matriz de DataTables que fornece a ordem dos conjuntos de resultado a serem retornados no <see cref="T:System.Data.DataTableReader" />.</param>
        <summary>Retorna um <see cref="T:System.Data.DataTableReader" /> com um conjunto de resultados por <see cref="T:System.Data.DataTable" />.</summary>
        <returns>Um <see cref="T:System.Data.DataTableReader" /> que contém um ou mais conjuntos de resultados, correspondentes às instâncias <see cref="T:System.Data.DataTable" /> contidas no <see cref="T:System.Data.DataSet" /> de origem. Os conjuntos de resultados retornados estão na ordem especificada pelo parâmetro <paramref name="dataTables" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para garantir que a ordem do resultado define dentro retornado <xref:System.Data.DataTableReader>, se um <xref:System.Data.DataTable> dentro a <xref:System.Data.DataSet> está vazio, é representado por um resultado vazio definido em retornado `DataTableReader`. Porque esta versão sobrecarregada permite que você forneça uma lista de `DataTable` instâncias como parâmetros, você pode especificar a ordem na qual os conjuntos de resultados aparecem em retornado `DataTableReader`.  
  
   
  
## Examples  
 Neste exemplo, um aplicativo de Console, cria três <xref:System.Data.DataTable> instâncias e adiciona cada um para um <xref:System.Data.DataSet>. O exemplo chama o <xref:System.Data.DataSet.CreateDataReader%2A> método e exibe o conteúdo do retornado <xref:System.Data.DataTableReader>. Observe que define a ordem do resultado da `DataTableReader` é controlada pela ordem do `DataTable` instâncias passadas como parâmetros. O exemplo exibe os resultados na janela do Console.  
  
 [!code-csharp[DataWorks DataSet.DataTableReaderTables#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataSet.DataTableReaderTables/CS/source.cs#1)]
 [!code-vb[DataWorks DataSet.DataTableReaderTables#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataSet.DataTableReaderTables/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DataSetName">
      <MemberSignature Language="C#" Value="public string DataSetName { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string DataSetName" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataSet.DataSetName" />
      <MemberSignature Language="VB.NET" Value="Public Property DataSetName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ DataSetName { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue("")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define o nome do <see cref="T:System.Data.DataSet" /> atual.</summary>
        <value>O nome do <see cref="T:System.Data.DataSet" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O exemplo a seguir cria um novo <xref:System.Data.DataSet> com o determinado <xref:System.Data.DataSet.DataSetName%2A>.  
  
 [!code-csharp[Classic WebData DataSet.DataSetName Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.DataSetName Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.DataSetName Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.DataSetName Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DefaultViewManager">
      <MemberSignature Language="C#" Value="public System.Data.DataViewManager DefaultViewManager { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Data.DataViewManager DefaultViewManager" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataSet.DefaultViewManager" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DefaultViewManager As DataViewManager" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Data::DataViewManager ^ DefaultViewManager { System::Data::DataViewManager ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Data.DataViewManager</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém uma exibição personalizada dos dados contidos no <see cref="T:System.Data.DataSet" /> para permitir a filtragem, a pesquisa e a navegação usando um <see cref="T:System.Data.DataViewManager" /> personalizado.</summary>
        <value>Um objeto <see cref="T:System.Data.DataViewManager" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Data.DataViewManager> retornado pelo <xref:System.Data.DataSet.DefaultViewManager%2A> propriedade permite que você crie configurações personalizadas para cada <xref:System.Data.DataTable> no <xref:System.Data.DataSet>.  
  
 Quando você obtém um <xref:System.Data.DataView> de um <xref:System.Data.DataTable>, a ordem de classificação, filtragem, e <xref:System.Data.DataViewRowState> são configurados de acordo com as configurações no <xref:System.Data.DataSet.DefaultViewManager%2A> propriedade.  
  
   
  
## Examples  
 O exemplo a seguir obtém o padrão <xref:System.Data.DataViewManager> para um <xref:System.Data.DataSet>e adiciona um <xref:System.Data.DataTable> para o <xref:System.Data.DataTableCollection>.  
  
 [!code-vb[Classic WebData DataSet.DefaultViewManager Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.DefaultViewManager Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="DetermineSchemaSerializationMode">
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Determina o <see cref="P:System.Data.DataSet.SchemaSerializationMode" /> para um <see cref="T:System.Data.DataSet" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método pode ser chamado durante a desserialização de um <xref:System.Data.DataSet> tipado para determinar seu <xref:System.Data.DataSet.SchemaSerializationMode%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="DetermineSchemaSerializationMode">
      <MemberSignature Language="C#" Value="protected System.Data.SchemaSerializationMode DetermineSchemaSerializationMode (System.Xml.XmlReader reader);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance valuetype System.Data.SchemaSerializationMode DetermineSchemaSerializationMode(class System.Xml.XmlReader reader) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.DetermineSchemaSerializationMode(System.Xml.XmlReader)" />
      <MemberSignature Language="VB.NET" Value="Protected Function DetermineSchemaSerializationMode (reader As XmlReader) As SchemaSerializationMode" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; System::Data::SchemaSerializationMode DetermineSchemaSerializationMode(System::Xml::XmlReader ^ reader);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.SchemaSerializationMode</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Xml.XmlReader" />
      </Parameters>
      <Docs>
        <param name="reader">A instância <see cref="T:System.Xml.XmlReader" /> que é passada durante a desserialização do <see cref="T:System.Data.DataSet" />.</param>
        <summary>Determina o <see cref="P:System.Data.DataSet.SchemaSerializationMode" /> para um <see cref="T:System.Data.DataSet" />.</summary>
        <returns>Uma enumeração <see cref="T:System.Data.SchemaSerializationMode" /> que indica se as informações de esquema foram omitidas do conteúdo.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método pode ser chamado durante a desserialização de um <xref:System.Data.DataSet> tipado para determinar seu <xref:System.Data.DataSet.SchemaSerializationMode%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DetermineSchemaSerializationMode">
      <MemberSignature Language="C#" Value="protected System.Data.SchemaSerializationMode DetermineSchemaSerializationMode (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance valuetype System.Data.SchemaSerializationMode DetermineSchemaSerializationMode(class System.Runtime.Serialization.SerializationInfo info, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.DetermineSchemaSerializationMode(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="VB.NET" Value="Protected Function DetermineSchemaSerializationMode (info As SerializationInfo, context As StreamingContext) As SchemaSerializationMode" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; System::Data::SchemaSerializationMode DetermineSchemaSerializationMode(System::Runtime::Serialization::SerializationInfo ^ info, System::Runtime::Serialization::StreamingContext context);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.SchemaSerializationMode</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="info" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="info">O <see cref="T:System.Runtime.Serialization.SerializationInfo" /> com o qual o construtor protegido <see cref="M:System.Data.DataSet.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" /> de <see langword="DataSet" /> é invocado durante a desserialização em cenários de comunicação remota.</param>
        <param name="context">O <see cref="T:System.Runtime.Serialization.StreamingContext" /> com o qual o construtor protegido <see cref="M:System.Data.DataSet.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" /> de <see langword="DataSet" /> é invocado durante a desserialização em cenários de comunicação remota.</param>
        <summary>Determina o <see cref="P:System.Data.DataSet.SchemaSerializationMode" /> para um <see cref="T:System.Data.DataSet" />.</summary>
        <returns>Uma enumeração <see cref="T:System.Data.SchemaSerializationMode" /> que indica se as informações de esquema foram omitidas do conteúdo.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método pode ser chamado durante a desserialização de um <xref:System.Data.DataSet> tipado para determinar seu <xref:System.Data.DataSet.SchemaSerializationMode%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EndInit">
      <MemberSignature Language="C#" Value="public void EndInit ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void EndInit() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.EndInit" />
      <MemberSignature Language="VB.NET" Value="Public Sub EndInit ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void EndInit();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Encerra a inicialização de um <see cref="T:System.Data.DataSet" /> que é usado em um formulário ou por outro componente. A inicialização ocorre no tempo de execução.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O ambiente de design do Visual Studio .NET usa esse método para encerrar a inicialização de um componente que é usado em um formulário ou por outro componente. O <xref:System.Data.DataSet.BeginInit%2A> método inicia a inicialização. Usando o <xref:System.Data.DataSet.BeginInit%2A> e <xref:System.Data.DataSet.EndInit%2A> métodos impede que o controle que está sendo usada antes de ser totalmente inicializado.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EnforceConstraints">
      <MemberSignature Language="C#" Value="public bool EnforceConstraints { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool EnforceConstraints" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataSet.EnforceConstraints" />
      <MemberSignature Language="VB.NET" Value="Public Property EnforceConstraints As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool EnforceConstraints { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define um valor que indica se as regras de restrição são seguidas ao tentar qualquer operação de atualização.</summary>
        <value>
          <see langword="true" /> se as regras forem impostas; caso contrário, <see langword="false" />. O padrão é <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Restrições são definidas no <xref:System.Data.DataTable> nível (<xref:System.Data.DataTable.Constraints%2A> propriedade). Para obter mais informações sobre a criação de restrições, consulte [restrições de DataTable](~/docs/framework/data/adonet/dataset-datatable-dataview/datatable-constraints.md).  
  
   
  
## Examples  
 O exemplo a seguir cria um <xref:System.Data.DataSet> com uma tabela, uma coluna, cinco linhas e um <xref:System.Data.UniqueConstraint>. O <xref:System.Data.DataSet.EnforceConstraints%2A> está definida como `false` e os valores de cada linha são definidos para o mesmo valor. Quando o <xref:System.Data.DataSet.EnforceConstraints%2A> propriedade é redefinida para `true`, um <xref:System.Data.ConstraintException> é gerado.  
  
 [!code-csharp[Classic WebData DataSet.EnforceConstraints Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.EnforceConstraints Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.EnforceConstraints Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.EnforceConstraints Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Data.ConstraintException">Não é possível impor uma ou mais restrições.</exception>
      </Docs>
    </Member>
    <Member MemberName="ExtendedProperties">
      <MemberSignature Language="C#" Value="public System.Data.PropertyCollection ExtendedProperties { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Data.PropertyCollection ExtendedProperties" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataSet.ExtendedProperties" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ExtendedProperties As PropertyCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Data::PropertyCollection ^ ExtendedProperties { System::Data::PropertyCollection ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Data.PropertyCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém a coleção de informações de usuário personalizadas associadas a um <see langword="DataSet" />.</summary>
        <value>Um <see cref="T:System.Data.PropertyCollection" /> com todas as informações de usuário personalizadas.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Data.DataSet.ExtendedProperties%2A> propriedade permite que você armazene informações personalizadas com o `DataSet`. Por exemplo, você pode armazenar um tempo quando os dados devem ser atualizados.  
  
 Propriedades estendidas devem ser do tipo <xref:System.String> se deseja que sejam persistentes quando o <xref:System.Data.DataSet> é gravada como XML.  
  
   
  
## Examples  
 O exemplo a seguir adiciona uma propriedade personalizada para o <xref:System.Data.PropertyCollection> retornado pelo <xref:System.Data.DataColumn.ExtendedProperties%2A> propriedade. O segundo exemplo recupera a propriedade personalizada.  
  
 [!code-csharp[Classic WebData DataColumn.ExtendedProperties Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataColumn.ExtendedProperties Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataColumn.ExtendedProperties Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataColumn.ExtendedProperties Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetChanges">
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Obtém uma cópia do <see cref="T:System.Data.DataSet" /> que contém todas as alterações feitas nele desde que foi carregado pela última vez ou desde que <see cref="M:System.Data.DataSet.AcceptChanges" /> foi chamado.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetChanges">
      <MemberSignature Language="C#" Value="public System.Data.DataSet GetChanges ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.DataSet GetChanges() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.GetChanges" />
      <MemberSignature Language="VB.NET" Value="Public Function GetChanges () As DataSet" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::DataSet ^ GetChanges();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataSet</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Obtém uma cópia do <see cref="T:System.Data.DataSet" /> que contém todas as alterações feitas nele desde que ele foi carregado ou desde que o <see cref="M:System.Data.DataSet.AcceptChanges" /> foi chamado pela última vez.</summary>
        <returns>Uma cópia das alterações desse <see cref="T:System.Data.DataSet" /> que pode ter ações realizadas nele e posteriormente ser mesclada novamente usando <see cref="M:System.Data.DataSet.Merge(System.Data.DataSet)" />. Se não forem encontradas linhas alteradas, o método retornará <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cria um novo <xref:System.Data.DataSet> que contém uma cópia de todas as linhas no original <xref:System.Data.DataSet> que possuem alterações pendentes. Restrições de relação podem fazer com que linhas inalteradas adicionais a serem adicionados ao novo <xref:System.Data.DataSet> se linhas inalteradas contenham chaves primárias correspondentes a chaves estrangeiras em linhas alteradas. O método retorna `null` se não houver nenhuma linha original <xref:System.Data.DataSet> que possuem alterações pendentes.  
  
   
  
## Examples  
 O exemplo a seguir cria um <xref:System.Data.DataSet> simples com uma tabela, duas colunas e dez linhas. Dois valores são alterados e uma linha é adicionada. Um subconjunto dos dados alterados é criado usando o <xref:System.Data.DataSet.GetChanges%2A> método. Após reconciliar erros, uma nova coluna é adicionada ao subconjunto, alterando o esquema. Quando o <xref:System.Data.DataSet.Merge%2A> método for chamado com o `missingSchemaAction` definida como `MissingSchemaAction.Add`, a nova coluna é adicionada ao valor original <xref:System.Data.DataSet> esquema do objeto.  
  
 [!code-csharp[Classic WebData DataSet.GetChanges Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.GetChanges Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.GetChanges Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.GetChanges Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Data.DataSet.HasChanges" />
      </Docs>
    </Member>
    <Member MemberName="GetChanges">
      <MemberSignature Language="C#" Value="public System.Data.DataSet GetChanges (System.Data.DataRowState rowStates);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.DataSet GetChanges(valuetype System.Data.DataRowState rowStates) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.GetChanges(System.Data.DataRowState)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetChanges (rowStates As DataRowState) As DataSet" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::DataSet ^ GetChanges(System::Data::DataRowState rowStates);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataSet</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rowStates" Type="System.Data.DataRowState" />
      </Parameters>
      <Docs>
        <param name="rowStates">Um dos valores de <see cref="T:System.Data.DataRowState" />.</param>
        <summary>Obtém uma cópia do <see cref="T:System.Data.DataSet" /> que contém todas as alterações feitas desde o último carregamento ou desde que <see cref="M:System.Data.DataSet.AcceptChanges" /> foi chamado, filtrado por <see cref="T:System.Data.DataRowState" />.</summary>
        <returns>Uma cópia filtrada do <see cref="T:System.Data.DataSet" /> que pode ter ações executadas nela e, mais tarde, ser mesclada novamente com o <see cref="M:System.Data.DataSet.Merge(System.Data.DataSet)" />. Se nenhuma linha do <see cref="T:System.Data.DataRowState" /> desejado for encontrada, o método retornará <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Data.DataSet.GetChanges%2A> método é usado para produzir um segundo <xref:System.Data.DataSet> objeto que contém apenas as alterações introduzidas ao original. Use o `rowStates` argumento para especificar o tipo de alterações deve incluir o novo objeto.  
  
 Isso retornado a cópia foi projetada para ser mescladas em original nesse <xref:System.Data.DataSet>. Restrições de relação podem causar linhas pai marcado como `Unchanged` a ser incluído. Se não houver linhas de desejado <xref:System.Data.DataRowState> forem encontrados, o <xref:System.Data.DataSet.GetChanges%2A> método retornará `null`.  
  
   
  
## Examples  
 O exemplo a seguir usa o <xref:System.Data.DataSet.GetChanges%2A> método para criar um segundo <xref:System.Data.DataSet> objeto, que é usado para atualizar uma fonte de dados.  
  
 [!code-csharp[Classic WebData DataSet.GetChanges1 Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.GetChanges1 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.GetChanges1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.GetChanges1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetDataSetSchema">
      <MemberSignature Language="C#" Value="public static System.Xml.Schema.XmlSchemaComplexType GetDataSetSchema (System.Xml.Schema.XmlSchemaSet schemaSet);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Xml.Schema.XmlSchemaComplexType GetDataSetSchema(class System.Xml.Schema.XmlSchemaSet schemaSet) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.GetDataSetSchema(System.Xml.Schema.XmlSchemaSet)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetDataSetSchema (schemaSet As XmlSchemaSet) As XmlSchemaComplexType" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Xml::Schema::XmlSchemaComplexType ^ GetDataSetSchema(System::Xml::Schema::XmlSchemaSet ^ schemaSet);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.Schema.XmlSchemaComplexType</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="schemaSet" Type="System.Xml.Schema.XmlSchemaSet" />
      </Parameters>
      <Docs>
        <param name="schemaSet">O conjunto de esquemas especificado.</param>
        <summary>Obtém uma cópia de <see cref="T:System.Xml.Schema.XmlSchemaSet" /> para DataSet.</summary>
        <returns>Uma cópia de <see cref="T:System.Xml.Schema.XmlSchemaSet" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetObjectData">
      <MemberSignature Language="C#" Value="public virtual void GetObjectData (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void GetObjectData(class System.Runtime.Serialization.SerializationInfo info, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub GetObjectData (info As SerializationInfo, context As StreamingContext)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void GetObjectData(System::Runtime::Serialization::SerializationInfo ^ info, System::Runtime::Serialization::StreamingContext context);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="info" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="info">Um <see cref="T:System.Runtime.Serialization.SerializationInfo" /> que contém os dados serializados associados a <see cref="T:System.Data.DataSet" />.</param>
        <param name="context">Um <see cref="T:System.Runtime.Serialization.StreamingContext" /> que contém a origem e o destino do fluxo serializado associado a <see cref="T:System.Data.DataSet" />.</param>
        <summary>Popula um objeto de informações de serialização com os dados necessários para serializar o <see cref="T:System.Data.DataSet" />.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">O parâmetro <paramref name="info" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetSchemaSerializable">
      <MemberSignature Language="C#" Value="protected virtual System.Xml.Schema.XmlSchema GetSchemaSerializable ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Xml.Schema.XmlSchema GetSchemaSerializable() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.GetSchemaSerializable" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function GetSchemaSerializable () As XmlSchema" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Xml::Schema::XmlSchema ^ GetSchemaSerializable();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.Schema.XmlSchema</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retorna uma instância <see cref="T:System.Xml.Schema.XmlSchema" /> serializável.</summary>
        <returns>A instância <see cref="T:System.Xml.Schema.XmlSchema" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetSerializationData">
      <MemberSignature Language="C#" Value="protected void GetSerializationData (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void GetSerializationData(class System.Runtime.Serialization.SerializationInfo info, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.GetSerializationData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub GetSerializationData (info As SerializationInfo, context As StreamingContext)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void GetSerializationData(System::Runtime::Serialization::SerializationInfo ^ info, System::Runtime::Serialization::StreamingContext context);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="info" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="info">A instância <see cref="T:System.Runtime.Serialization.SerializationInfo" />.</param>
        <param name="context">O contexto de streaming.</param>
        <summary>Desserializa os dados da tabela do fluxo XML ou binário.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetXml">
      <MemberSignature Language="C#" Value="public string GetXml ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetXml() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.GetXml" />
      <MemberSignature Language="VB.NET" Value="Public Function GetXml () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetXml();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retorna a representação XML dos dados armazenados no <see cref="T:System.Data.DataSet" />.</summary>
        <returns>Uma cadeia de caracteres que é uma representação dos dados armazenados no <see cref="T:System.Data.DataSet" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Chamar esse método é idêntico ao chamar <xref:System.Data.DataSet.WriteXml%2A> com <xref:System.Data.XmlWriteMode> definido como <xref:System.Data.XmlWriteMode.IgnoreSchema>.  
  
 <xref:System.Data.DataSet.GetXml%2A> Retorna o XML como uma cadeia de caracteres e, portanto, requer mais sobrecarga do que <xref:System.Data.DataSet.WriteXml%2A> para gravar um arquivo XML.  
  
 Se você criar um <xref:System.Data.DataSet> usando inferência de esquema e serializar ele usando os serviços Web ou XML, a ordenação de coluna pode ser alterado.  
  
   
  
## Examples  
 O exemplo a seguir cria um <xref:System.Data.DataSet> e <xref:System.Data.DataTable>, adiciona dados de exemplo e, em seguida, exibe os dados em formato XML.  
  
 [!code-csharp[Classic WebData DataSet.GetXml Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.GetXml Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.GetXml Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.GetXml Example/VB/source.vb#1)]  
  
 Este exemplo demonstra como gravar dados em um arquivo XML de um conjunto de dados e ler dados no conjunto de dados do XML. Este exemplo cria um conjunto de dados com duas tabelas, usar duas maneiras para exportar um conjunto de dados para os arquivos XML (WriteXml e GetXml) e usar duas formas (ReadXml e InferXmlSchema) para importar um conjunto de dados de arquivos XML.  
  
 Antes de compilar e executar o exemplo, você precisa criar quatro arquivos XML no diretório de exemplo. Primeiro, crie ElementsWithAttributes.xml:  
  
```  
<MySchool>  
  <Course CourseID="C1045" Year="2012"  Title="Calculus" Credits="4" DepartmentID="7">New</Course>  
  <Course CourseID="C1061" Year="2012"  Title="Physics" Credits="4" DepartmentID="1" />  
  <Department DepartmentID="1" Name="Engineering" Budget="350000" StartDate="2007-09-01T00:00:00+08:00" Administrator="2" />  
  <Department DepartmentID="7" Name="Mathematics" Budget="250024" StartDate="2007-09-01T00:00:00+08:00" Administrator="3">Cancelled</Department>  
</MySchool>  
```  
  
 Em seguida, crie ElementsWithChildElementsxml.xml:  
  
```  
<MySchool>  
  <Course>  
    <CourseID>C1045</CourseID>  
    <Year>2012</Year>  
    <Title>Calculus</Title>  
    <Credits>4</Credits>  
    <DepartmentID>7</DepartmentID>  
  </Course>  
  <Course>  
    <CourseID>C1061</CourseID>  
    <Year>2012</Year>  
    <Title>Physics</Title>  
    <Credits>4</Credits>  
    <DepartmentID>1</DepartmentID>  
  </Course>  
  <Course>  
    <CourseID>C2021</CourseID>  
    <Year>2012</Year>  
    <Title>Composition</Title>  
    <Credits>3</Credits>  
    <DepartmentID>2</DepartmentID>  
  </Course>  
  <Course>  
    <CourseID>C2042</CourseID>  
    <Year>2012</Year>  
    <Title>Literature</Title>  
    <Credits>4</Credits>  
    <DepartmentID>2</DepartmentID>  
  </Course>  
  <Department>  
    <DepartmentID>1</DepartmentID>  
    <Name>Engineering</Name>  
    <Budget>350000</Budget>  
    <StartDate>2007-09-01T00:00:00+08:00</StartDate>  
    <Administrator>2</Administrator>  
  </Department>  
  <Department>  
    <DepartmentID>2</DepartmentID>  
    <Name>English</Name>  
    <Budget>120000</Budget>  
    <StartDate>2007-09-01T00:00:00+08:00</StartDate>  
    <Administrator>6</Administrator>  
  </Department>  
  <Department>  
    <DepartmentID>4</DepartmentID>  
    <Name>Economics</Name>  
    <Budget>200000</Budget>  
    <StartDate>2007-09-01T00:00:00+08:00</StartDate>  
    <Administrator>4</Administrator>  
  </Department>  
  <Department>  
    <DepartmentID>7</DepartmentID>  
    <Name>Mathematics</Name>  
    <Budget>250024</Budget>  
    <StartDate>2007-09-01T00:00:00+08:00</StartDate>  
    <Administrator>3</Administrator>  
  </Department>  
</MySchool>  
```  
  
 Agora crie ElementsWithOnlyAttributes.xml:  
  
```  
<MySchool>  
  <Course CourseID="C1045" Year="2012"  Title="Calculus" Credits="4" DepartmentID="7" />  
  <Course CourseID="C1061" Year="2012"  Title="Physics" Credits="4" DepartmentID="1" />  
  <Department DepartmentID="1" Name="Engineering" Budget="350000" StartDate="2007-09-01T00:00:00+08:00" Administrator="2" />  
  <Department DepartmentID="7" Name="Mathematics" Budget="250024" StartDate="2007-09-01T00:00:00+08:00" Administrator="3" />  
</MySchool>  
```  
  
 E, finalmente, crie RepeatingElements.xml:  
  
```  
<MySchool>  
  <Course>C1045</Course>  
  <Course>C1061</Course>  
  <Department>Engineering</Department>   
  <Department>Mathematics</Department>  
</MySchool>  
```  
  
 Agora você pode compilar e executar o seguinte código-fonte.  [Como repositório de dados do conjunto de dados no arquivo XML](https://code.msdn.microsoft.com/How-to-Store-Data-of-7b9710f3) tem projetos do Visual Basic e c# para este exemplo.  
  
```  
using System;  
using System.Data;  
using System.IO;  
using System.Text;  
using System.Xml;  
  
// Use WriteXml method to export the dataset.  
static class DataTableHelper {  
   public static void WriteDataSetToXML(DataSet dataset, String xmlFileName) {  
      using (FileStream fsWriterStream = new FileStream(xmlFileName, FileMode.Create)) {  
         using (XmlTextWriter xmlWriter = new XmlTextWriter(fsWriterStream, Encoding.Unicode)) {  
            dataset.WriteXml(xmlWriter, XmlWriteMode.WriteSchema);  
            Console.WriteLine("Write {0} to the File {1}.", dataset.DataSetName, xmlFileName);  
            Console.WriteLine();  
         }  
      }  
   }  
  
   // Use GetXml method to get the XML data of the dataset and then export to the file.  
   public static void GetXMLFromDataSet(DataSet dataset, String xmlFileName) {  
      using (StreamWriter writer = new StreamWriter(xmlFileName)) {  
         writer.WriteLine(dataset.GetXml());  
         Console.WriteLine("Get Xml data from {0} and write to the File {1}.", dataset.DataSetName, xmlFileName);  
         Console.WriteLine();  
      }  
   }  
  
   // Use ReadXml method to import the dataset from the dataset.  
   public static void ReadXmlIntoDataSet(DataSet newDataSet, String xmlFileName) {  
      using (FileStream fsReaderStream = new FileStream(xmlFileName, FileMode.Open)) {  
         using (XmlTextReader xmlReader = new XmlTextReader(fsReaderStream)) {  
            newDataSet.ReadXml(xmlReader, XmlReadMode.ReadSchema);  
         }  
      }  
   }  
  
   // Display the columns and value of DataSet.  
   public static void ShowDataSet(DataSet dataset) {  
      foreach (DataTable table in dataset.Tables) {  
         Console.WriteLine("Table {0}:", table.TableName);  
         ShowDataTable(table);  
      }  
   }  
  
   // Display the columns and value of DataTable.  
   private static void ShowDataTable(DataTable table) {  
      foreach (DataColumn col in table.Columns) {  
         Console.Write("{0,-14}", col.ColumnName);  
      }  
      Console.WriteLine("{0,-14}", "");  
  
      foreach (DataRow row in table.Rows) {  
         if (row.RowState == DataRowState.Deleted) {  
            foreach (DataColumn col in table.Columns) {  
               if (col.DataType.Equals(typeof(DateTime))) {  
                  Console.Write("{0,-14:d}", row[col, DataRowVersion.Original]);  
               }  
               else if (col.DataType.Equals(typeof(Decimal))) {  
                  Console.Write("{0,-14:C}", row[col, DataRowVersion.Original]);  
               }  
               else {  
                  Console.Write("{0,-14}", row[col, DataRowVersion.Original]);  
               }  
            }  
         }  
         else {  
            foreach (DataColumn col in table.Columns) {  
               if (col.DataType.Equals(typeof(DateTime))) {  
                  Console.Write("{0,-14:d}", row[col]);  
               }  
               else if (col.DataType.Equals(typeof(Decimal))) {  
                  Console.Write("{0,-14:C}", row[col]);  
               }  
               else {  
                  Console.Write("{0,-14}", row[col]);  
               }  
            }  
         }  
         Console.WriteLine("{0,-14}", "");  
      }  
   }  
  
   // Display the columns of DataSet.  
   public static void ShowDataSetSchema(DataSet dataSet) {  
      Console.WriteLine("{0} contains the following tables:", dataSet.DataSetName);  
      foreach (DataTable table in dataSet.Tables) {  
         Console.WriteLine("   Table {0} contains the following columns:", table.TableName);  
         ShowDataTableSchema(table);  
      }  
   }  
  
   // Display the columns of DataTable  
   private static void ShowDataTableSchema(DataTable table) {  
      String columnString = "";  
      foreach (DataColumn col in table.Columns) {  
         columnString += col.ColumnName + "   ";  
      }  
      Console.WriteLine(columnString);  
   }  
}  
  
class Program {  
   static void Main(string[] args) {  
      // Create the DataSet  
      DataSet school = new DataSet("MySchool");  
      DataTable course = CreateCourse();  
      DataTable department = CreateDepartment();  
      school.Tables.Add(course);  
      school.Tables.Add(department);  
  
      // Define the constraint between the tables.  
      ForeignKeyConstraint courseDepartFK = new ForeignKeyConstraint("CourseDepartFK", department.Columns["DepartmentID"], course.Columns["DepartmentID"]);  
      courseDepartFK.DeleteRule = Rule.Cascade;  
      courseDepartFK.UpdateRule = Rule.Cascade;  
      courseDepartFK.AcceptRejectRule = AcceptRejectRule.None;  
      course.Constraints.Add(courseDepartFK);  
  
      InsertDepartments(department);  
      InsertCourses(course);  
  
      // Export the dataset to the XML file.  
      Console.WriteLine("Data of the whole DataSet {0}", school.DataSetName);  
      DataTableHelper.ShowDataSet(school);  
  
      String xmlWithSchemaFileName = "WriterXMLWithSchema.xml";  
      String xmlGetDataFileName = "GetXML.xml";  
  
      // Use two ways to export the dataset to the Xml file.  
      DataTableHelper.WriteDataSetToXML(school, xmlWithSchemaFileName);  
      DataTableHelper.GetXMLFromDataSet(school, xmlGetDataFileName);  
  
      // Import the dataset from the XML file.  
      // Use two ways to import the dataset from the Xml file.  
      Console.WriteLine("Read Xml document into a new DataSet:");  
      DataSet newSchool = new DataSet("NewSchool");  
      DataTableHelper.ReadXmlIntoDataSet(newSchool, xmlWithSchemaFileName);  
      DataTableHelper.ShowDataSetSchema(newSchool);  
      Console.WriteLine();  
  
      Console.WriteLine("Infer a schema for a DataSet from an XML document:");  
      InferDataSetSchemaFromXml();  
  
      Console.WriteLine("Press any key to exit.");  
      Console.ReadKey();  
   }  
  
   static DataTable CreateCourse() {  
      DataTable course = new DataTable("Course");  
      DataColumn[] cols ={  
                              new DataColumn("CourseID",typeof(String)),  
                              new DataColumn("Year",typeof(Int32)),  
                              new DataColumn("Title",typeof(String)),  
                              new DataColumn("Credits",typeof(Int32)),  
                              new DataColumn("DepartmentID",typeof(Int32))};  
      course.Columns.AddRange(cols);  
  
      course.PrimaryKey = new DataColumn[] { course.Columns["CourseID"], course.Columns["Year"] };  
  
      return course;  
   }  
  
   static DataTable CreateDepartment() {  
      DataTable department = new DataTable("Department");  
      DataColumn[] cols = {   
                                new DataColumn("DepartmentID", typeof(Int32)),  
                                new DataColumn("Name",typeof(String)),  
                                new DataColumn("Budget",typeof(Decimal)),  
                                new DataColumn("StartDate",typeof(DateTime)),  
                                new DataColumn("Administrator",typeof(Int32))};  
      department.Columns.AddRange(cols);  
  
      department.PrimaryKey = new DataColumn[] { department.Columns["DepartmentID"] };  
  
      return department;  
   }  
  
   static void InsertDepartments(DataTable department) {  
      Object[] rows = {   
                            new Object[]{1,"Engineering",350000.00,new DateTime(2007,9,1),2},  
                            new Object[]{2,"English",120000.00,new DateTime(2007,9,1),6},  
                            new Object[]{4,"Economics",200000.00,new DateTime(2007,9,1),4},  
                            new Object[]{7,"Mathematics",250024.00,new DateTime(2007,9,1),3}};  
  
      foreach (Object[] row in rows) {  
         department.Rows.Add(row);  
      }  
   }  
  
   static void InsertCourses(DataTable course) {  
      Object[] rows ={  
                               new Object[]{"C1045",2012,"Calculus",4,7},  
                               new Object[]{"C1061",2012,"Physics",4,1},  
                               new Object[]{"C2021",2012,"Composition",3,2},  
                               new Object[]{"C2042",2012,"Literature",4,2}};  
  
      foreach (Object[] row in rows) {  
         course.Rows.Add(row);  
      }  
   }  
  
   // Display the results of inferring schema from four types of XML structures  
   private static void InferDataSetSchemaFromXml() {  
      String[] xmlFileNames = {   
  
                                    @"ElementsWithOnlyAttributes.xml",   
                                    @"ElementsWithAttributes.xml",  
                                    @"RepeatingElements.xml",   
                                    @"ElementsWithChildElements.xml" };  
  
      foreach (String xmlFileName in xmlFileNames) {  
         Console.WriteLine("Result of {0}", Path.GetFileNameWithoutExtension(xmlFileName));  
         DataSet newSchool = new DataSet();  
         newSchool.InferXmlSchema(xmlFileName, null);  
         DataTableHelper.ShowDataSetSchema(newSchool);  
         Console.WriteLine();  
      }  
   }  
}  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetXmlSchema">
      <MemberSignature Language="C#" Value="public string GetXmlSchema ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetXmlSchema() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.GetXmlSchema" />
      <MemberSignature Language="VB.NET" Value="Public Function GetXmlSchema () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetXmlSchema();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retorna o Esquema XML para a representação XML dos dados armazenados no <see cref="T:System.Data.DataSet" />.</summary>
        <returns>Cadeia de caracteres que é o Esquema XML para a representação XML dos dados armazenados no <see cref="T:System.Data.DataSet" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Chamar esse método é idêntico ao chamar <xref:System.Data.DataSet.WriteXmlSchema%2A>, exceto que somente o esquema principal é gravado.  
  
 <xref:System.Data.DataSet.GetXmlSchema%2A> Retorna o XML como uma cadeia de caracteres e, portanto, requer mais sobrecarga do que <xref:System.Data.DataSet.WriteXmlSchema%2A> para gravar um arquivo XML.  
  
 Se você criar um <xref:System.Data.DataSet> usando inferência de esquema e serializar ele usando os serviços Web ou XML, a ordenação de coluna pode ser alterado.  
  
   
  
## Examples  
 O exemplo a seguir cria um <xref:System.Data.DataSet> e <xref:System.Data.DataTable>e, em seguida, exibe o esquema em formato XML.  
  
 [!code-csharp[Classic WebData DataSet.GetXmlSchema Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.GetXmlSchema Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.GetXmlSchema Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.GetXmlSchema Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="HasChanges">
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Obtém um valor que indica se o <see cref="T:System.Data.DataSet" /> tem alterações, incluindo linhas novas, excluídas ou modificadas.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="HasChanges">
      <MemberSignature Language="C#" Value="public bool HasChanges ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool HasChanges() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.HasChanges" />
      <MemberSignature Language="VB.NET" Value="Public Function HasChanges () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool HasChanges();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Obtém um valor que indica se o <see cref="T:System.Data.DataSet" /> tem alterações, incluindo linhas novas, excluídas ou modificadas.</summary>
        <returns>
          <see langword="true" /> se o <see cref="T:System.Data.DataSet" /> tem alterações; caso contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O exemplo a seguir usa o <xref:System.Data.DataSet.GetChanges%2A> método para criar um segundo <xref:System.Data.DataSet> objeto que é usado para atualizar uma fonte de dados.  
  
 [!code-csharp[Classic WebData DataSet.HasChanges Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.HasChanges Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.HasChanges Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.HasChanges Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="HasChanges">
      <MemberSignature Language="C#" Value="public bool HasChanges (System.Data.DataRowState rowStates);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool HasChanges(valuetype System.Data.DataRowState rowStates) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.HasChanges(System.Data.DataRowState)" />
      <MemberSignature Language="VB.NET" Value="Public Function HasChanges (rowStates As DataRowState) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool HasChanges(System::Data::DataRowState rowStates);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rowStates" Type="System.Data.DataRowState" />
      </Parameters>
      <Docs>
        <param name="rowStates">Um dos valores de <see cref="T:System.Data.DataRowState" />.</param>
        <summary>Obtém um valor que indica se o <see cref="T:System.Data.DataSet" /> tem alterações, incluindo linhas novas, excluídas ou modificadas, filtradas por <see cref="T:System.Data.DataRowState" />.</summary>
        <returns>
          <see langword="true" /> se o <see cref="T:System.Data.DataSet" /> tem alterações; caso contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Examine o <xref:System.Data.DataSet.HasChanges%2A> propriedade o `DataSet` antes de chamar o <xref:System.Data.DataSet.GetChanges%2A> método.  
  
   
  
## Examples  
 O exemplo a seguir usa o <xref:System.Data.DataSet.GetChanges%2A> método para criar um segundo <xref:System.Data.DataSet> objeto, que é usado para atualizar uma fonte de dados.  
  
 [!code-csharp[Classic WebData DataSet.GetChanges1 Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.GetChanges1 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.GetChanges1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.GetChanges1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="HasErrors">
      <MemberSignature Language="C#" Value="public bool HasErrors { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool HasErrors" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataSet.HasErrors" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property HasErrors As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool HasErrors { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém um valor que indica se há erros em qualquer um dos objetos <see cref="T:System.Data.DataTable" /> nesse <see cref="T:System.Data.DataSet" />.</summary>
        <value>
          <see langword="true" /> se qualquer tabela contém um erro; caso contrário, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cada <xref:System.Data.DataTable> em uma <xref:System.Data.DataSet> também tem um <xref:System.Data.DataTable.HasErrors%2A> propriedade. Use o `HasErrors` propriedade o `DataSet` primeiro para determinar se qualquer tabela tem erros, antes de verificar individuais <xref:System.Data.DataTable> objetos. Se um `DataTable` tem erros, o <xref:System.Data.DataTable.GetErrors%2A> método retorna uma matriz de <xref:System.Data.DataRow> objetos que contêm os erros.  
  
   
  
## Examples  
 O exemplo a seguir usa o <xref:System.Data.DataSet.HasErrors%2A> propriedade para determinar se um <xref:System.Data.DataSet> objeto contém erros. Nesse caso, os erros para cada <xref:System.Data.DataRow> em cada <xref:System.Data.DataTable> são impressas.  
  
 [!code-csharp[Classic WebData DataSet.HasErrors Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.HasErrors Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.HasErrors Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.HasErrors Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="InferXmlSchema">
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Aplica o esquema XML ao <see cref="T:System.Data.DataSet" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="InferXmlSchema">
      <MemberSignature Language="C#" Value="public void InferXmlSchema (System.IO.Stream stream, string[] nsArray);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void InferXmlSchema(class System.IO.Stream stream, string[] nsArray) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.InferXmlSchema(System.IO.Stream,System.String[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void InferXmlSchema(System::IO::Stream ^ stream, cli::array &lt;System::String ^&gt; ^ nsArray);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
        <Parameter Name="nsArray" Type="System.String[]" />
      </Parameters>
      <Docs>
        <param name="stream">O <see langword="Stream" /> do qual ler o esquema.</param>
        <param name="nsArray">Uma matriz de cadeias de caracteres de Uniform Resource Identifier (URI) do namespace a serem excluídas da inferência do esquema.</param>
        <summary>Aplica o esquema XML do <see cref="T:System.IO.Stream" /> especificado ao <see cref="T:System.Data.DataSet" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="InferXmlSchema">
      <MemberSignature Language="C#" Value="public void InferXmlSchema (System.IO.TextReader reader, string[] nsArray);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void InferXmlSchema(class System.IO.TextReader reader, string[] nsArray) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.InferXmlSchema(System.IO.TextReader,System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub InferXmlSchema (reader As TextReader, nsArray As String())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void InferXmlSchema(System::IO::TextReader ^ reader, cli::array &lt;System::String ^&gt; ^ nsArray);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.IO.TextReader" />
        <Parameter Name="nsArray" Type="System.String[]" />
      </Parameters>
      <Docs>
        <param name="reader">O <see langword="TextReader" /> do qual ler o esquema.</param>
        <param name="nsArray">Uma matriz de cadeias de caracteres de Uniform Resource Identifier (URI) do namespace a serem excluídas da inferência do esquema.</param>
        <summary>Aplica o esquema XML do <see cref="T:System.IO.TextReader" /> especificado ao <see cref="T:System.Data.DataSet" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="InferXmlSchema">
      <MemberSignature Language="C#" Value="public void InferXmlSchema (string fileName, string[] nsArray);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void InferXmlSchema(string fileName, string[] nsArray) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.InferXmlSchema(System.String,System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub InferXmlSchema (fileName As String, nsArray As String())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void InferXmlSchema(System::String ^ fileName, cli::array &lt;System::String ^&gt; ^ nsArray);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
        <Parameter Name="nsArray" Type="System.String[]" />
      </Parameters>
      <Docs>
        <param name="fileName">O nome do arquivo (incluindo o caminho) do qual o esquema é lido.</param>
        <param name="nsArray">Uma matriz de cadeias de caracteres de Uniform Resource Identifier (URI) do namespace a serem excluídas da inferência do esquema.</param>
        <summary>Aplica o esquema XML do arquivo especificado no <see cref="T:System.Data.DataSet" />.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.Security.SecurityException">
          <see cref="T:System.Security.Permissions.FileIOPermission" /> não é definido como <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Para ler e gravar arquivos. Enumeração associada: <see cref="T:System.Security.Permissions.FileIOPermissionAccess" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="InferXmlSchema">
      <MemberSignature Language="C#" Value="public void InferXmlSchema (System.Xml.XmlReader reader, string[] nsArray);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void InferXmlSchema(class System.Xml.XmlReader reader, string[] nsArray) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.InferXmlSchema(System.Xml.XmlReader,System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub InferXmlSchema (reader As XmlReader, nsArray As String())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void InferXmlSchema(System::Xml::XmlReader ^ reader, cli::array &lt;System::String ^&gt; ^ nsArray);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Xml.XmlReader" />
        <Parameter Name="nsArray" Type="System.String[]" />
      </Parameters>
      <Docs>
        <param name="reader">O <see langword="XMLReader" /> do qual ler o esquema.</param>
        <param name="nsArray">Uma matriz de cadeias de caracteres de Uniform Resource Identifier (URI) do namespace a serem excluídas da inferência do esquema.</param>
        <summary>Aplica o esquema XML do <see cref="T:System.Xml.XmlReader" /> especificado ao <see cref="T:System.Data.DataSet" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Initialized">
      <MemberSignature Language="C#" Value="public event EventHandler Initialized;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Initialized" />
      <MemberSignature Language="DocId" Value="E:System.Data.DataSet.Initialized" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Initialized As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event EventHandler ^ Initialized;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ocorre após o <see cref="T:System.Data.DataSet" /> ser inicializado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para obter mais informações, consulte <xref:System.Data.DataSet.IsInitialized%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="InitializeDerivedDataSet">
      <MemberSignature Language="C#" Value="protected virtual void InitializeDerivedDataSet ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void InitializeDerivedDataSet() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.InitializeDerivedDataSet" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub InitializeDerivedDataSet ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void InitializeDerivedDataSet();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Desserialize todos os dados de tabelas do DataSet do fluxo XML ou binário.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsBinarySerialized">
      <MemberSignature Language="C#" Value="protected bool IsBinarySerialized (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance bool IsBinarySerialized(class System.Runtime.Serialization.SerializationInfo info, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.IsBinarySerialized(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="VB.NET" Value="Protected Function IsBinarySerialized (info As SerializationInfo, context As StreamingContext) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; bool IsBinarySerialized(System::Runtime::Serialization::SerializationInfo ^ info, System::Runtime::Serialization::StreamingContext context);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="info" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="info">O objeto <see cref="T:System.Runtime.Serialization.SerializationInfo" />.</param>
        <param name="context">O objeto <see cref="T:System.Runtime.Serialization.StreamingContext" />.</param>
        <summary>Inspeciona o formato da representação serializada do <see langword="DataSet" />.</summary>
        <returns>
          <see langword="true" /> se o <see cref="T:System.Runtime.Serialization.SerializationInfo" /> especificado representar um <see langword="DataSet" /> serializado em seu formato binário, caso contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse membro oferece suporte à infraestrutura .NET Framework e não se destina à utilização diretamente no seu código.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsInitialized">
      <MemberSignature Language="C#" Value="public bool IsInitialized { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsInitialized" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataSet.IsInitialized" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsInitialized As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsInitialized { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém um valor que indica se o <see cref="T:System.Data.DataSet" /> é inicializado.</summary>
        <value>
          <see langword="true" /> para indicar que o componente concluiu a inicialização; caso contrário, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Retorna o status do <xref:System.Data.DataSet> enquanto ele está sendo construído, para a instância pelo Visual Studio. O <xref:System.Data.DataSet.BeginInit%2A> método define como `false` e <xref:System.Data.DataSet.EndInit%2A> método define como `true`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Load">
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Preenche um <see cref="T:System.Data.DataSet" /> com valores de uma fonte de dados usando o <see cref="T:System.Data.IDataReader" />fornecido.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O método <xref:System.Data.DataTable.Load%2A> fornece uma técnica para preencher um único <xref:System.Data.DataTable> com dados, recuperado a partir de uma instância <xref:System.Data.IDataReader>. Esse método fornece a mesma funcionalidade, mas permite que você carregue vários conjuntos de resultados de uma `IDataReader` em várias tabelas em um `DataSet`.  
  
 Se o `DataSet` já contiver linhas, os dados de entrada da fonte de dados serão mesclados com as linhas existentes.  
  
 O `Load` método pode ser usado em vários cenários comuns, todos os centralizado em torno de obter dados de uma fonte de dados especificado e adicioná-la ao contêiner de dados atual (nesse caso, um `DataSet`). Esses cenários descrevem o uso padrão para um `DataSet`, que descreve a atualização e o comportamento de mesclagem.  
  
 Um `DataSet` sincroniza ou atualiza com uma fonte de dados primário. O `DataSet` rastreia as alterações, permitindo que a sincronização com a fonte de dados primário. Além disso, um `DataSet` pode aceitar dados incrementais de um ou mais fontes de dados secundários. O `DataSet` não é responsável pelo controle de alterações para permitir a sincronização com a fonte de dados secundário.  
  
 Dadas essas duas fontes de dados hipotéticas, um usuário deve exigir um dos seguintes comportamentos:  
  
-   Inicializar `DataSet` de uma fonte de dados primário. Nesse cenário, o usuário deseja inicializar vazio `DataSet` com valores da fonte de dados primário. Conteúdo da DataTable um ou mais é modificado. Posteriormente, o usuário deseja propagar alterações de volta para a fonte de dados primária.  
  
-   Preservar alterações e ressincronizar a partir da fonte de dados primária. Nesse cenário, o usuário deseja ter a `DataSet` preenchido no cenário anterior e execute uma sincronização incremental com a fonte de dados primário, preservando as modificações feitas no `DataSet`.  
  
-   Feed de dados incremental das fontes de dados secundárias. Nesse cenário, o usuário deseja mesclar alterações de uma ou mais fontes de dados secundárias e propaga essas alterações de volta para a fonte de dados primária.  
  
 O `Load` método possibilita todos esses cenários. Esse método permite que você especifique um parâmetro de opção de carga, que indica como as linhas já está em um <xref:System.Data.DataTable> combinar com linhas que está sendo carregadas. A tabela a seguir descreve as três opções de carregamento fornecidas pela enumeração <xref:System.Data.LoadOption>. Em cada caso, a descrição indica o comportamento quando a chave primária de uma linha nos dados de entrada corresponde à chave primária de uma linha existente.  
  
|Carregar Opção|Descrição|  
|-----------------|-----------------|  
|`PreserveChanges` (padrão)|Atualiza a versão original da linha com o valor da linha de entrada.|  
|`OverwriteChanges`|Atualiza as versões atual e original da linha com o valor da linha de entrada.|  
|`Upsert`|Atualiza a versão atual da linha com o valor da linha de entrada.|  
  
 Em geral, as opções `PreserveChanges` e `OverwriteChanges` se destinam a cenários nos quais o usuário precisa sincronizar o `DataSet` e suas alterações com a fonte de dados primária. A opção `Upsert` facilita a agregação de alterações de uma ou mais fontes de dados secundárias.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public void Load (System.Data.IDataReader reader, System.Data.LoadOption loadOption, params System.Data.DataTable[] tables);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Load(class System.Data.IDataReader reader, valuetype System.Data.LoadOption loadOption, class System.Data.DataTable[] tables) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.Load(System.Data.IDataReader,System.Data.LoadOption,System.Data.DataTable[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Load(System::Data::IDataReader ^ reader, System::Data::LoadOption loadOption, ... cli::array &lt;System::Data::DataTable ^&gt; ^ tables);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Data.IDataReader" />
        <Parameter Name="loadOption" Type="System.Data.LoadOption" />
        <Parameter Name="tables" Type="System.Data.DataTable[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="reader">Um <see cref="T:System.Data.IDataReader" /> que fornece um ou vários conjuntos de resultados.</param>
        <param name="loadOption">Um valor da enumeração <see cref="T:System.Data.LoadOption" /> que indica como as linhas que já estão nas instâncias <see cref="T:System.Data.DataTable" /> em <see cref="T:System.Data.DataSet" /> serão combinadas com linhas de entrada que compartilham a mesma chave primária.</param>
        <param name="tables">Uma matriz de instâncias <see cref="T:System.Data.DataTable" />, da qual o método <see cref="M:System.Data.DataSet.Load(System.Data.IDataReader,System.Data.LoadOption,System.Data.DataTable[])" /> recupera informações de nome e namespace. Cada uma dessas tabelas deve ser um membro do <see cref="T:System.Data.DataTableCollection" /> contido por este <see cref="T:System.Data.DataSet" />.</param>
        <summary>Preenche um <see cref="T:System.Data.DataSet" /> com valores de uma fonte de dados usando o <see cref="T:System.Data.IDataReader" /> fornecido, usando uma matriz de instâncias <see cref="T:System.Data.DataTable" /> para fornecer o esquema e as informações de namespace.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O método <xref:System.Data.DataTable.Load%2A> fornece uma técnica para preencher um único <xref:System.Data.DataTable> com dados, recuperado a partir de uma instância <xref:System.Data.IDataReader>. Esse método fornece a mesma funcionalidade, mas permite que você carregue vários conjuntos de resultados de uma <xref:System.Data.IDataReader> em várias tabelas em um <xref:System.Data.DataSet>.  
  
> [!NOTE]
>  A operação de carregamento falhará com um <xref:System.InvalidOperationException> se qualquer uma das colunas de dados de origem na entrada `reader` são colunas computadas.  
  
 O `loadOption` parâmetro permite que você especifique como deseja que os dados importados para interagir com os dados existentes e pode ser qualquer um dos valores do <xref:System.Data.LoadOption> enumeração. Consulte a documentação para o <xref:System.Data.DataTable> <xref:System.Data.DataTable.Load%2A> método para obter mais informações sobre como usar esse parâmetro.  
  
 O `tables` parâmetro permite que você especifique uma matriz de <xref:System.Data.DataTable> instâncias, que indica a ordem das tabelas correspondentes para cada conjunto de resultados carregado de leitor. O <xref:System.Data.DataSet.Load%2A> método preenchimentos cada fornecidos <xref:System.Data.DataTable> instância com dados de um único conjunto de resultados de leitor de dados de origem. Depois de cada conjunto de resultados, o <xref:System.Data.DataSet.Load%2A> método prossegue para o próximo resultado definido dentro do leitor, até que não haja não mais conjuntos de resultados.  
  
 O esquema de resolução de nome para este método é o mesmo que seguido a <xref:System.Data.Common.DbDataAdapter.Fill%2A> método o <xref:System.Data.Common.DbDataAdapter> classe.  
  
   
  
## Examples  
 O exemplo a seguir cria um novo <xref:System.Data.DataSet>, adiciona dois <xref:System.Data.DataTable> instâncias para o <xref:System.Data.DataSet>e, em seguida, preenche a <xref:System.Data.DataSet> usando o <xref:System.Data.DataSet.Load%2A> método, recuperando dados de um <xref:System.Data.DataTableReader> que contém dois conjuntos de resultados. Por fim, o exemplo exibe o conteúdo das tabelas na janela do console.  
  
 [!code-csharp[DataWorks DataSet.LoadTables#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataSet.LoadTables/CS/source.cs#1)]
 [!code-vb[DataWorks DataSet.LoadTables#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataSet.LoadTables/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public void Load (System.Data.IDataReader reader, System.Data.LoadOption loadOption, params string[] tables);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Load(class System.Data.IDataReader reader, valuetype System.Data.LoadOption loadOption, string[] tables) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.Load(System.Data.IDataReader,System.Data.LoadOption,System.String[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Load(System::Data::IDataReader ^ reader, System::Data::LoadOption loadOption, ... cli::array &lt;System::String ^&gt; ^ tables);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Data.IDataReader" />
        <Parameter Name="loadOption" Type="System.Data.LoadOption" />
        <Parameter Name="tables" Type="System.String[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="reader">Um <see cref="T:System.Data.IDataReader" /> que fornece um ou vários conjuntos de resultados.</param>
        <param name="loadOption">Um valor da enumeração <see cref="T:System.Data.LoadOption" /> que indica como as linhas que já estão nas instâncias <see cref="T:System.Data.DataTable" /> dentro de <see langword="DataSet" /> serão combinadas com linhas de entrada que compartilham a mesma chave primária.</param>
        <param name="tables">Uma matriz de cadeias de caracteres da qual o <see langword="Load" /> método recupera informações de nome de tabela.</param>
        <summary>Preenche um <see cref="T:System.Data.DataSet" /> com valores de uma fonte de dados usando o <see cref="T:System.Data.IDataReader" />, usando uma matriz de cadeias de caracteres para fornecer os nomes das tabelas dentro de <see langword="DataSet" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O método <xref:System.Data.DataTable.Load%2A> fornece uma técnica para preencher um único <xref:System.Data.DataTable> com dados, recuperado a partir de uma instância <xref:System.Data.IDataReader>. Esse método fornece a mesma funcionalidade, mas permite que você carregue vários conjuntos de resultados de uma `IDataReader` em várias tabelas em um `DataSet`.  
  
> [!NOTE]
>  A operação de carregamento falhará com um <xref:System.InvalidOperationException> se qualquer uma das colunas de dados de origem na entrada `reader` são colunas computadas.  
  
 O `loadOption` parâmetro permite que você especifique como deseja que os dados importados para interagir com os dados existentes e pode ser qualquer um dos valores do <xref:System.Data.LoadOption> enumeração. Consulte a documentação para o <xref:System.Data.DataTable.Load%2A> método para obter mais informações sobre como usar esse parâmetro.  
  
 O `tables` parâmetro permite que você especifique uma matriz de nomes de tabela, que indica a ordem das tabelas correspondentes para cada conjunto de resultados carregado de leitor. O `Load` método tenta localizar uma tabela dentro do `DataSet` correspondente ao nome encontrado na matriz de nomes de tabela, na ordem. Se uma tabela de correspondência for encontrada, essa tabela é carregada com o conteúdo do conjunto de resultados atual. Se nenhuma tabela correspondente for encontrada, uma tabela é criada usando o nome fornecido na matriz de nomes de tabela e o novo esquema da tabela é inferido do conjunto de resultados. Depois de cada conjunto de resultados, o `Load` método prossegue para o próximo resultado definido dentro do leitor, até que não haja não mais conjuntos de resultados.  
  
 O namespace padrão associado `DataSet`, se houver, está associado com cada recém-criado `DataTable`. O esquema de resolução de nome para este método é o mesmo que seguido a <xref:System.Data.Common.DbDataAdapter.Fill%2A> método o <xref:System.Data.Common.DbDataAdapter> classe.  
  
   
  
## Examples  
 O exemplo de aplicativo de Console a seguir primeiro cria tabelas e carrega dados de um leitor em um <xref:System.Data.DataSet>, usando o `Load` método. O exemplo adiciona tabelas para uma <xref:System.Data.DataSet> e tenta preencher as tabelas com dados de um <xref:System.Data.DataTableReader>. Neste exemplo, porque os parâmetros passados para o `Load` método indicar um nome de tabela não existe, o `Load` método cria uma nova tabela para corresponder ao nome passado como um parâmetro. Depois que os dados forem carregados, o exemplo exibe o conteúdo de todas as suas tabelas na janela do Console.  
  
 [!code-csharp[DataWorks DataSet.LoadString#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataSet.LoadString/CS/source.cs#1)]
 [!code-vb[DataWorks DataSet.LoadString#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataSet.LoadString/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public virtual void Load (System.Data.IDataReader reader, System.Data.LoadOption loadOption, System.Data.FillErrorEventHandler errorHandler, params System.Data.DataTable[] tables);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Load(class System.Data.IDataReader reader, valuetype System.Data.LoadOption loadOption, class System.Data.FillErrorEventHandler errorHandler, class System.Data.DataTable[] tables) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.Load(System.Data.IDataReader,System.Data.LoadOption,System.Data.FillErrorEventHandler,System.Data.DataTable[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Load(System::Data::IDataReader ^ reader, System::Data::LoadOption loadOption, System::Data::FillErrorEventHandler ^ errorHandler, ... cli::array &lt;System::Data::DataTable ^&gt; ^ tables);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Data.IDataReader" />
        <Parameter Name="loadOption" Type="System.Data.LoadOption" />
        <Parameter Name="errorHandler" Type="System.Data.FillErrorEventHandler" />
        <Parameter Name="tables" Type="System.Data.DataTable[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="reader">Um <see cref="T:System.Data.IDataReader" /> que fornece um ou vários conjuntos de resultados.</param>
        <param name="loadOption">Um valor da enumeração <see cref="T:System.Data.LoadOption" /> que indica como as linhas que já estão nas instâncias <see cref="T:System.Data.DataTable" /> em <see cref="T:System.Data.DataSet" /> serão combinadas com linhas de entrada que compartilham a mesma chave primária.</param>
        <param name="errorHandler">Um delegado <see cref="T:System.Data.FillErrorEventHandler" /> a ser chamado quando ocorrer um erro ao carregar os dados.</param>
        <param name="tables">Uma matriz de instâncias <see cref="T:System.Data.DataTable" />, da qual o método <see cref="M:System.Data.DataSet.Load(System.Data.IDataReader,System.Data.LoadOption,System.Data.FillErrorEventHandler,System.Data.DataTable[])" /> recupera informações de nome e namespace.</param>
        <summary>Preenche um <see cref="T:System.Data.DataSet" /> com valores de uma fonte de dados usando o <see cref="T:System.Data.IDataReader" /> fornecido, usando uma matriz de instâncias <see cref="T:System.Data.DataTable" /> para fornecer o esquema e as informações de namespace.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O método <xref:System.Data.DataTable.Load%2A> fornece uma técnica para preencher um único <xref:System.Data.DataTable> com dados, recuperado a partir de uma instância <xref:System.Data.IDataReader>. Esse método fornece a mesma funcionalidade, mas permite que você carregue vários conjuntos de resultados de uma <xref:System.Data.IDataReader> em várias tabelas em um <xref:System.Data.DataSet>.  
  
> [!NOTE]
>  A operação de carregamento falhará com um <xref:System.InvalidOperationException> se qualquer uma das colunas de dados de origem na entrada `reader` são colunas computadas.  
  
 O `loadOption` parâmetro permite que você especifique como deseja que os dados importados para interagir com os dados existentes e pode ser qualquer um dos valores do <xref:System.Data.LoadOption> enumeração. Consulte a documentação para o <xref:System.Data.DataTable> <xref:System.Data.DataTable.Load%2A> método para obter mais informações sobre como usar esse parâmetro.  
  
 O `errorHandler` parâmetro é um <xref:System.Data.FillErrorEventHandler> representante que se refere a um procedimento que é chamado quando ocorre um erro ao carregar dados. O <xref:System.Data.FillErrorEventArgs> parâmetro passado ao procedimento fornece propriedades que permitem recuperar informações sobre o erro ocorreu, a linha atual de dados, e o <xref:System.Data.DataTable> sendo preenchido. Usando esse mecanismo de delegado, em vez de um bloco try/catch mais simples, permite que você determine o erro, manipule a situação e continuar o processamento se desejar. O <xref:System.Data.FillErrorEventArgs> parâmetro fornece um <xref:System.Data.FillErrorEventArgs.Continue%2A> propriedade: defina essa propriedade como `true` para indicar que você manuseou o erro e quiser continuar o processamento; defina a propriedade como `false` para indicar que você deseja interromper o processamento. Esteja ciente que definir a propriedade como `false` faz com que o código que disparou o problema para gerar uma exceção.  
  
 O `tables` parâmetro permite que você especifique uma matriz de <xref:System.Data.DataTable> instâncias, que indica a ordem das tabelas correspondentes para cada conjunto de resultados carregado de leitor. O <xref:System.Data.DataSet.Load%2A> método preenchimentos cada fornecidos <xref:System.Data.DataTable> instância com dados de um único conjunto de resultados de leitor de dados de origem. Depois de cada conjunto de resultados, o <xref:System.Data.DataSet.Load%2A> método prossegue para o próximo resultado definido dentro do leitor, até que não haja não mais conjuntos de resultados.  
  
 O esquema de resolução de nome para este método é o mesmo que seguido a <xref:System.Data.Common.DbDataAdapter.Fill%2A> método o <xref:System.Data.Common.DbDataAdapter> classe.  
  
   
  
## Examples  
 O exemplo a seguir adiciona uma tabela para um <xref:System.Data.DataSet>e, em seguida, tenta usar o <xref:System.Data.DataSet.Load%2A> método para carregar dados de um <xref:System.Data.DataTableReader> que contém um esquema incompatível. Em vez de interceptação de erro, este exemplo usa um <xref:System.Data.FillErrorEventHandler> delegado para investigar e tratar o erro. A saída é exibida na janela do console.  
  
 [!code-csharp[DataWorks DataSet.Load#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataSet.Load/CS/source.cs#1)]
 [!code-vb[DataWorks DataSet.Load#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataSet.Load/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Locale">
      <MemberSignature Language="C#" Value="public System.Globalization.CultureInfo Locale { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Globalization.CultureInfo Locale" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataSet.Locale" />
      <MemberSignature Language="VB.NET" Value="Public Property Locale As CultureInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Globalization::CultureInfo ^ Locale { System::Globalization::CultureInfo ^ get(); void set(System::Globalization::CultureInfo ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Globalization.CultureInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define as informações de localidade usadas para comparar cadeias de caracteres na tabela.</summary>
        <value>Um <see cref="T:System.Globalization.CultureInfo" /> que contém dados sobre a localidade do computador do usuário. O padrão é <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Data.DataSet.Locale%2A> propriedade especifica a localidade para a qual a classificação se aplica.  
  
 Por padrão, definindo o <xref:System.Data.DataSet.Locale%2A> para um <xref:System.Data.DataSet> também define o <xref:System.Data.DataSet.Locale%2A> para cada <xref:System.Data.DataTable> objeto em que `DataSet` com o mesmo valor.  
  
> [!NOTE]
>  Em colunas que contêm expressões, o <xref:System.StringComparison.InvariantCulture> é usado. O <xref:System.StringComparison.CurrentCulture> será ignorado.  
  
   
  
## Examples  
 O exemplo a seguir obtém o <xref:System.Globalization.CultureInfo> para um <xref:System.Data.DataSet> e imprime o <xref:System.Globalization.CultureInfo.DisplayName%2A> e <xref:System.Globalization.CultureInfo.EnglishName%2A> propriedades.  
  
 [!code-vb[Classic WebData DataSet.Locale Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.Locale Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Merge">
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Mescla um <see cref="T:System.Data.DataSet" />, <see cref="T:System.Data.DataTable" /> ou matriz de objetos <see cref="T:System.Data.DataRow" /> no <see langword="DataSet" /> ou <see langword="DataTable" /> atual.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Merge">
      <MemberSignature Language="C#" Value="public void Merge (System.Data.DataRow[] rows);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Merge(class System.Data.DataRow[] rows) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.Merge(System.Data.DataRow[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub Merge (rows As DataRow())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Merge(cli::array &lt;System::Data::DataRow ^&gt; ^ rows);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rows" Type="System.Data.DataRow[]" />
      </Parameters>
      <Docs>
        <param name="rows">A matriz de objetos <see langword="DataRow" /> a serem mesclados no <see langword="DataSet" />.</param>
        <summary>Mescla uma matriz de objetos <see cref="T:System.Data.DataRow" /> no <see cref="T:System.Data.DataSet" /> atual.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O método <xref:System.Data.DataSet.Merge%2A> é usado para mesclar dois objetos <xref:System.Data.DataSet> que têm esquemas amplamente semelhantes. Uma mesclagem é normalmente usada em um aplicativo cliente incorporar as alterações mais recentes feitas em uma fonte de dados a um <xref:System.Data.DataSet>existente. Isso permite que o aplicativo cliente tenha um <xref:System.Data.DataSet> atualizado com os dados mais recentes a partir da fonte de dados.  
  
 O método <xref:System.Data.DataSet.Merge%2A> é chamado geralmente ao final de uma série de procedimentos que envolvem a validação de alterações, a reconciliação de erros, a atualização da fonte de dados com as alterações e, por fim, a atualização do <xref:System.Data.DataSet>existente.  
  
 Em um aplicativo cliente, é comum ter um único botão em que o usuário possa clicar reunindo os dados alterados e os valida antes de enviar de volta para um componente de camada intermediária. Nesse cenário, o método <xref:System.Data.DataSet.GetChanges%2A> é invocado primeiro. O método retorna um segundo <xref:System.Data.DataSet> otimizado para validação e mesclagem. Este segundo objeto <xref:System.Data.DataSet> contém apenas os objetos <xref:System.Data.DataTable> e <xref:System.Data.DataRow> que foram modificados, resultando em um subconjunto do <xref:System.Data.DataSet> original. Esse subconjunto é geralmente menor e, portanto, com mais eficiência passado para um componente de camada intermediária. Em seguida, o componente de camada intermediária atualiza a fonte de dados original com as alterações por meio de procedimentos armazenados. A camada intermediária pode enviar novamente em qualquer um novo <xref:System.Data.DataSet> que inclui dados originais e os dados mais recentes da fonte de dados (executando a consulta original novamente), ou pode enviar novamente o subconjunto com eventuais alterações feitas a partir da fonte de dados. (Por exemplo, se a fonte de dados cria automaticamente valores de chave primária exclusivos, esses valores podem ser propagados de volta para o aplicativo cliente.) Em ambos os casos, o <xref:System.Data.DataSet> retornado pode ser mesclado de volta ao <xref:System.Data.DataSet> original do aplicativo cliente com o método <xref:System.Data.DataSet.Merge%2A>.  
  
 Quando o método <xref:System.Data.DataSet.Merge%2A> é chamado, os esquemas dos dois objetos de <xref:System.Data.DataSet> são comparados, porque é possível que os esquemas possam ter sido alterados. Por exemplo, em um cenário entre empresas, novas colunas podem ter sido adicionadas a um esquema XML por um processo automatizado. Se a fonte <xref:System.Data.DataSet> contiver elementos do esquema (objetos <xref:System.Data.DataColumn> adicionados) que estão faltando no destino, os elementos do esquema poderão ser adicionados ao destino definindo o argumento `missingSchemaAction` como `MissingSchemaAction.Add`. Nesse caso, o <xref:System.Data.DataSet> mesclado contém o esquema e os dados adicionados.  
  
 Após a mesclagem de esquemas, os dados são mesclados.  
  
 Durante a mesclagem de uma nova fonte <xref:System.Data.DataSet> no destino, qualquer linha de origem com um valor <xref:System.Data.DataRowState> de `Unchanged`, `Modified` ou `Deleted` são correspondidos para selecionar linhas com os mesmos valores de chave primária. As linhas de origem com um valor de <xref:System.Data.DataRowState> de `Added` correspondem às novas linhas de destino com os mesmos valores de chave primária das novas linhas de origem.  
  
 Durante uma mesclagem, as restrições permanecem desabilitadas. Se qualquer restrição não pode ser habilitada no final de uma mesclagem, um <xref:System.Data.ConstraintException> é gerado e os dados mesclados são mantidos enquanto as restrições são desabilitadas. Nesse caso, a propriedade <xref:System.Data.DataSet.EnforceConstraints%2A> é definida como `false`, e todas as linhas inválidas são marcadas com erro. Os erros deverão ser resolvidos antes de tentar redefinir a propriedade <xref:System.Data.DataSet.EnforceConstraints%2A> como `true`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Merge">
      <MemberSignature Language="C#" Value="public void Merge (System.Data.DataSet dataSet);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Merge(class System.Data.DataSet dataSet) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.Merge(System.Data.DataSet)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Merge(System::Data::DataSet ^ dataSet);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dataSet" Type="System.Data.DataSet" />
      </Parameters>
      <Docs>
        <param name="dataSet">O <see langword="DataSet" /> cujos dados e esquema serão mesclados.</param>
        <summary>Mescla um <see cref="T:System.Data.DataSet" /> especificado e seu esquema no <see langword="DataSet" /> atual.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O método <xref:System.Data.DataSet.Merge%2A> é usado para mesclar dois objetos <xref:System.Data.DataSet> que têm esquemas amplamente semelhantes. Uma mesclagem é normalmente usada em um aplicativo cliente incorporar as alterações mais recentes feitas em uma fonte de dados a um <xref:System.Data.DataSet>existente. Isso permite que o aplicativo cliente tenha um <xref:System.Data.DataSet> atualizado com os dados mais recentes a partir da fonte de dados.  
  
 O método <xref:System.Data.DataSet.Merge%2A> é chamado geralmente ao final de uma série de procedimentos que envolvem a validação de alterações, a reconciliação de erros, a atualização da fonte de dados com as alterações e, por fim, a atualização do <xref:System.Data.DataSet>existente.  
  
 Em um aplicativo cliente, é comum ter um único botão em que o usuário possa clicar reunindo os dados alterados e os valida antes de enviar de volta para um componente de camada intermediária. Nesse cenário, o método <xref:System.Data.DataSet.GetChanges%2A> é invocado primeiro. O método retorna um segundo <xref:System.Data.DataSet> otimizado para validação e mesclagem. Este segundo objeto <xref:System.Data.DataSet> contém apenas os objetos <xref:System.Data.DataTable> e <xref:System.Data.DataRow> que foram modificados, resultando em um subconjunto do <xref:System.Data.DataSet> original. Este subconjunto é geralmente menor e, assim, passado com mais eficiência para um componente de camada intermediária. Em seguida, o componente de camada intermediária atualiza a fonte de dados original com as alterações por meio de procedimentos armazenados. A camada intermediária pode enviar novamente em qualquer um novo <xref:System.Data.DataSet> que inclui dados originais e os dados mais recentes da fonte de dados (executando a consulta original novamente), ou pode enviar novamente o subconjunto com eventuais alterações feitas a partir da fonte de dados. (Por exemplo, se a fonte de dados cria automaticamente valores de chave primária exclusivos, esses valores podem ser propagados de volta para o aplicativo cliente.) Em ambos os casos, o <xref:System.Data.DataSet> retornado pode ser mesclado de volta ao <xref:System.Data.DataSet> original do aplicativo cliente com o método <xref:System.Data.DataSet.Merge%2A>.  
  
 Quando o método <xref:System.Data.DataSet.Merge%2A> é chamado, os esquemas dos dois objetos de <xref:System.Data.DataSet> são comparados, porque é possível que os esquemas possam ter sido alterados. Por exemplo, em um cenário entre empresas, novas colunas podem ter sido adicionadas a um esquema XML por um processo automatizado. Se a fonte <xref:System.Data.DataSet> contiver elementos do esquema (objetos <xref:System.Data.DataColumn> adicionados) que estão faltando no destino, os elementos do esquema poderão ser adicionados ao destino definindo o argumento `missingSchemaAction` como `MissingSchemaAction.Add`. Nesse caso, o <xref:System.Data.DataSet> mesclado contém o esquema e os dados adicionados.  
  
 Após a mesclagem de esquemas, os dados são mesclados.  
  
 Durante a mesclagem de uma nova fonte <xref:System.Data.DataSet> no destino, qualquer linha de origem com um valor <xref:System.Data.DataRowState> de `Unchanged`, `Modified` ou `Deleted` são correspondidos para selecionar linhas com os mesmos valores de chave primária. As linhas de origem com um valor de `DataRowState` de `Added` correspondem às novas linhas de destino com os mesmos valores de chave primária das novas linhas de origem.  
  
 Durante uma mesclagem, as restrições permanecem desabilitadas. Se alguma restrição não puder ser habilitada ao final da mesclagem, um <xref:System.Data.ConstraintException> será gerado e os dados mesclados serão mantidos quando as restrições estiverem desabilitadas. Nesse caso, a propriedade <xref:System.Data.DataSet.EnforceConstraints%2A> é definida como `false`, e todas as linhas inválidas são marcadas com erro. Os erros deverão ser resolvidos antes de tentar redefinir a propriedade <xref:System.Data.DataSet.EnforceConstraints%2A> como `true`.  
  
   
  
## Examples  
 O exemplo a seguir usa o <xref:System.Data.DataSet.GetChanges%2A>, atualização, e <xref:System.Data.DataSet.Merge%2A> métodos em um <xref:System.Data.DataSet>.  
  
 [!code-csharp[Classic WebData DataSet.Merge Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.Merge Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.Merge Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.Merge Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Data.ConstraintException">Não é possível habilitar uma ou mais restrições.</exception>
        <exception cref="T:System.ArgumentNullException">O <paramref name="dataSet" /> é <see langword="null" />.</exception>
        <altmember cref="T:System.Data.ForeignKeyConstraint" />
        <altmember cref="M:System.Data.DataSet.GetChanges" />
        <altmember cref="T:System.Data.UniqueConstraint" />
      </Docs>
    </Member>
    <Member MemberName="Merge">
      <MemberSignature Language="C#" Value="public void Merge (System.Data.DataTable table);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Merge(class System.Data.DataTable table) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.Merge(System.Data.DataTable)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Merge (table As DataTable)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Merge(System::Data::DataTable ^ table);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="table" Type="System.Data.DataTable" />
      </Parameters>
      <Docs>
        <param name="table">O <see cref="T:System.Data.DataTable" /> cujos dados e esquema serão mesclados.</param>
        <summary>Mescla um <see cref="T:System.Data.DataTable" /> especificado e seu esquema no <see cref="T:System.Data.DataSet" /> atual.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O método <xref:System.Data.DataSet.Merge%2A> é usado para mesclar dois objetos <xref:System.Data.DataSet> que têm esquemas amplamente semelhantes. Uma mesclagem é normalmente usada em um aplicativo cliente incorporar as alterações mais recentes feitas em uma fonte de dados a um <xref:System.Data.DataSet>existente. Isso permite que o aplicativo cliente tenha um <xref:System.Data.DataSet> atualizado com os dados mais recentes a partir da fonte de dados.  
  
 O método <xref:System.Data.DataSet.Merge%2A> é chamado geralmente ao final de uma série de procedimentos que envolvem a validação de alterações, a reconciliação de erros, a atualização da fonte de dados com as alterações e, por fim, a atualização do <xref:System.Data.DataSet>existente.  
  
 Em um aplicativo cliente, é comum ter um único botão em que o usuário possa clicar reunindo os dados alterados e os valida antes de enviar de volta para um componente de camada intermediária. Nesse cenário, o método <xref:System.Data.DataSet.GetChanges%2A> é invocado primeiro. O método retorna um segundo <xref:System.Data.DataSet> otimizado para validação e mesclagem. Este segundo objeto <xref:System.Data.DataSet> contém apenas os objetos <xref:System.Data.DataTable> e <xref:System.Data.DataRow> que foram modificados, resultando em um subconjunto do <xref:System.Data.DataSet> original. Este subconjunto é geralmente menor e, assim, passado com mais eficiência para um componente de camada intermediária. Em seguida, o componente de camada intermediária atualiza a fonte de dados original com as alterações por meio de procedimentos armazenados. A camada intermediária pode enviar novamente em qualquer um novo <xref:System.Data.DataSet> que inclui dados originais e os dados mais recentes da fonte de dados (executando a consulta original novamente), ou pode enviar novamente o subconjunto com eventuais alterações feitas a partir da fonte de dados. (Por exemplo, se a fonte de dados cria automaticamente valores de chave primária exclusivos, esses valores podem ser propagados de volta para o aplicativo cliente.) Em ambos os casos, o <xref:System.Data.DataSet> retornado pode ser mesclado de volta ao <xref:System.Data.DataSet> original do aplicativo cliente com o método <xref:System.Data.DataSet.Merge%2A>.  
  
 Quando o método <xref:System.Data.DataSet.Merge%2A> é chamado, os esquemas dos dois objetos de <xref:System.Data.DataSet> são comparados, porque é possível que os esquemas possam ter sido alterados. Por exemplo, em um cenário entre empresas, novas colunas podem ter sido adicionadas a um esquema XML por um processo automatizado. Se a fonte <xref:System.Data.DataSet> contiver elementos do esquema (objetos <xref:System.Data.DataColumn> adicionados) que estão faltando no destino, os elementos do esquema poderão ser adicionados ao destino definindo o argumento `missingSchemaAction` como `MissingSchemaAction.Add`. Nesse caso, o <xref:System.Data.DataSet> mesclado contém o esquema e os dados adicionados.  
  
 Após a mesclagem de esquemas, os dados são mesclados.  
  
 Durante a mesclagem de uma nova fonte <xref:System.Data.DataSet> no destino, qualquer linha de origem com um valor <xref:System.Data.DataRowState> de `Unchanged`, `Modified` ou `Deleted` são correspondidos para selecionar linhas com os mesmos valores de chave primária. As linhas de origem com um valor de `DataRowState` de `Added` correspondem às novas linhas de destino com os mesmos valores de chave primária das novas linhas de origem.  
  
 Durante uma mesclagem, as restrições permanecem desabilitadas. Se alguma restrição não puder ser habilitada ao final da mesclagem, um <xref:System.Data.ConstraintException> será gerado e os dados mesclados serão mantidos quando as restrições estiverem desabilitadas. Nesse caso, a propriedade <xref:System.Data.DataSet.EnforceConstraints%2A> é definida como `false`, e todas as linhas inválidas são marcadas com erro. Os erros deverão ser resolvidos antes de tentar redefinir a propriedade <xref:System.Data.DataSet.EnforceConstraints%2A> como `true`.  
  
   
  
## Examples  
 O exemplo a seguir cria um <xref:System.Data.DataSet> simples com uma tabela, duas colunas e dez linhas. Um segundo <xref:System.Data.DataTable> é criado que é idêntico ao primeiro. Duas linhas são adicionadas para a segunda tabela, em seguida, é mesclada no <xref:System.Data.DataSet>.  
  
 [!code-csharp[Classic WebData DataSet.Merge3 Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.Merge3 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.Merge3 Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.Merge3 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">O <paramref name="table" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Merge">
      <MemberSignature Language="C#" Value="public void Merge (System.Data.DataSet dataSet, bool preserveChanges);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Merge(class System.Data.DataSet dataSet, bool preserveChanges) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.Merge(System.Data.DataSet,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Merge(System::Data::DataSet ^ dataSet, bool preserveChanges);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dataSet" Type="System.Data.DataSet" />
        <Parameter Name="preserveChanges" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="dataSet">O <see langword="DataSet" /> cujos dados e esquema serão mesclados.</param>
        <param name="preserveChanges">
          <see langword="true" /> para preservar alterações no <see langword="DataSet" /> atual; caso contrário, <see langword="false" />.</param>
        <summary>Mescla um <see cref="T:System.Data.DataSet" /> especificado e seu esquema no <see langword="DataSet" /> atual, preservando ou descartando as alterações neste <see langword="DataSet" /> de acordo com o argumento determinado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O método <xref:System.Data.DataSet.Merge%2A> é usado para mesclar dois objetos <xref:System.Data.DataSet> que têm esquemas amplamente semelhantes. Uma mesclagem é normalmente usada em um aplicativo cliente incorporar as alterações mais recentes feitas em uma fonte de dados a um <xref:System.Data.DataSet>existente. Isso permite que o aplicativo cliente tenha um <xref:System.Data.DataSet> atualizado com os dados mais recentes a partir da fonte de dados.  
  
 O método <xref:System.Data.DataSet.Merge%2A> é chamado geralmente ao final de uma série de procedimentos que envolvem a validação de alterações, a reconciliação de erros, a atualização da fonte de dados com as alterações e, por fim, a atualização do <xref:System.Data.DataSet>existente.  
  
 Em um aplicativo cliente, é comum ter um único botão em que o usuário possa clicar reunindo os dados alterados e os valida antes de enviar de volta para um componente de camada intermediária. Nesse cenário, o método <xref:System.Data.DataSet.GetChanges%2A> é invocado primeiro. O método retorna um segundo <xref:System.Data.DataSet> otimizado para validação e mesclagem. Este segundo objeto <xref:System.Data.DataSet> contém apenas os objetos <xref:System.Data.DataTable> e <xref:System.Data.DataRow> que foram modificados, resultando em um subconjunto do <xref:System.Data.DataSet> original. Este subconjunto é geralmente menor e, assim, passado com mais eficiência para um componente de camada intermediária. Em seguida, o componente de camada intermediária atualiza a fonte de dados original com as alterações por meio de procedimentos armazenados. A camada intermediária pode enviar novamente em qualquer um novo <xref:System.Data.DataSet> que inclui dados originais e os dados mais recentes da fonte de dados (executando a consulta original novamente), ou pode enviar novamente o subconjunto com eventuais alterações feitas a partir da fonte de dados. (Por exemplo, se a fonte de dados cria automaticamente valores de chave primária exclusivos, esses valores podem ser propagados de volta para o aplicativo cliente.) Em ambos os casos, o <xref:System.Data.DataSet> retornado pode ser mesclado de volta ao <xref:System.Data.DataSet> original do aplicativo cliente com o método <xref:System.Data.DataSet.Merge%2A>.  
  
 Quando o método <xref:System.Data.DataSet.Merge%2A> é chamado, os esquemas dos dois objetos de <xref:System.Data.DataSet> são comparados, porque é possível que os esquemas possam ter sido alterados. Por exemplo, em um cenário entre empresas, novas colunas podem ter sido adicionadas a um esquema XML por um processo automatizado. Se a fonte <xref:System.Data.DataSet> contiver elementos do esquema (objetos <xref:System.Data.DataColumn> adicionados) que estão faltando no destino, os elementos do esquema poderão ser adicionados ao destino definindo o argumento `missingSchemaAction` como `MissingSchemaAction.Add`. Nesse caso, o <xref:System.Data.DataSet> mesclado contém o esquema e os dados adicionados.  
  
 Após a mesclagem de esquemas, os dados são mesclados.  
  
 Durante a mesclagem de uma nova fonte <xref:System.Data.DataSet> no destino, qualquer linha de origem com um valor <xref:System.Data.DataRowState> de `Unchanged`, `Modified` ou `Deleted` são correspondidos para selecionar linhas com os mesmos valores de chave primária. As linhas de origem com um valor de `DataRowState` de `Added` correspondem às novas linhas de destino com os mesmos valores de chave primária das novas linhas de origem.  
  
 Durante uma mesclagem, as restrições permanecem desabilitadas. Se alguma restrição não puder ser habilitada ao final da mesclagem, um <xref:System.Data.ConstraintException> será gerado e os dados mesclados serão mantidos quando as restrições estiverem desabilitadas. Nesse caso, a propriedade <xref:System.Data.DataSet.EnforceConstraints%2A> é definida como `false`, e todas as linhas inválidas são marcadas com erro. Os erros deverão ser resolvidos antes de tentar redefinir a propriedade <xref:System.Data.DataSet.EnforceConstraints%2A> como `true`.  
  
   
  
## Examples  
 O exemplo a seguir cria um <xref:System.Data.DataSet> simples com uma tabela, duas colunas e dez linhas. Depois de adicionar dez linhas, dois valores são alterados e uma linha é adicionada. Um subconjunto dos dados alterados é criado usando o <xref:System.Data.DataSet.GetChanges%2A> método. Após reconciliar erros, os dados de subconjunto são mesclados no original <xref:System.Data.DataSet>.  
  
 [!code-csharp[Classic WebData DataSet.GetChanges Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.GetChanges Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.GetChanges Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.GetChanges Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Data.ForeignKeyConstraint" />
        <altmember cref="T:System.Data.UniqueConstraint" />
      </Docs>
    </Member>
    <Member MemberName="Merge">
      <MemberSignature Language="C#" Value="public void Merge (System.Data.DataRow[] rows, bool preserveChanges, System.Data.MissingSchemaAction missingSchemaAction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Merge(class System.Data.DataRow[] rows, bool preserveChanges, valuetype System.Data.MissingSchemaAction missingSchemaAction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.Merge(System.Data.DataRow[],System.Boolean,System.Data.MissingSchemaAction)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Merge(cli::array &lt;System::Data::DataRow ^&gt; ^ rows, bool preserveChanges, System::Data::MissingSchemaAction missingSchemaAction);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rows" Type="System.Data.DataRow[]" />
        <Parameter Name="preserveChanges" Type="System.Boolean" />
        <Parameter Name="missingSchemaAction" Type="System.Data.MissingSchemaAction" />
      </Parameters>
      <Docs>
        <param name="rows">A matriz de objetos <see cref="T:System.Data.DataRow" /> a serem mesclados no <see langword="DataSet" />.</param>
        <param name="preserveChanges">
          <see langword="true" /> para preservar alterações no <see langword="DataSet" />; caso contrário, <see langword="false" />.</param>
        <param name="missingSchemaAction">Um dos valores de <see cref="T:System.Data.MissingSchemaAction" />.</param>
        <summary>Mescla uma matriz de objetos <see cref="T:System.Data.DataRow" /> no <see cref="T:System.Data.DataSet" />, preservando ou descartando alterações no <see langword="DataSet" /> atual e manipulando um esquema incompatível de acordo com os argumentos fornecidos.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O método <xref:System.Data.DataSet.Merge%2A> é usado para mesclar dois objetos <xref:System.Data.DataSet> que têm esquemas amplamente semelhantes. Uma mesclagem é normalmente usada em um aplicativo cliente incorporar as alterações mais recentes feitas em uma fonte de dados a um <xref:System.Data.DataSet>existente. Isso permite que o aplicativo cliente tenha um <xref:System.Data.DataSet> atualizado com os dados mais recentes a partir da fonte de dados.  
  
 O método <xref:System.Data.DataSet.Merge%2A> é chamado geralmente ao final de uma série de procedimentos que envolvem a validação de alterações, a reconciliação de erros, a atualização da fonte de dados com as alterações e, por fim, a atualização do <xref:System.Data.DataSet>existente.  
  
 Em um aplicativo cliente, é comum ter um único botão em que o usuário possa clicar reunindo os dados alterados e os valida antes de enviar de volta para um componente de camada intermediária. Nesse cenário, o método <xref:System.Data.DataSet.GetChanges%2A> é invocado primeiro. O método retorna um segundo <xref:System.Data.DataSet> otimizado para validação e mesclagem. Este segundo objeto <xref:System.Data.DataSet> contém apenas os objetos <xref:System.Data.DataTable> e <xref:System.Data.DataRow> que foram modificados, resultando em um subconjunto do <xref:System.Data.DataSet> original. Este subconjunto é geralmente menor e, assim, passado com mais eficiência para um componente de camada intermediária. Em seguida, o componente de camada intermediária atualiza a fonte de dados original com as alterações por meio de procedimentos armazenados. A camada intermediária pode enviar novamente em qualquer um novo <xref:System.Data.DataSet> que inclui dados originais e os dados mais recentes da fonte de dados (executando a consulta original novamente), ou pode enviar novamente o subconjunto com eventuais alterações feitas a partir da fonte de dados. (Por exemplo, se a fonte de dados cria automaticamente valores de chave primária exclusivos, esses valores podem ser propagados de volta para o aplicativo cliente.) Em ambos os casos, o <xref:System.Data.DataSet> retornado pode ser mesclado de volta ao <xref:System.Data.DataSet> original do aplicativo cliente com o método <xref:System.Data.DataSet.Merge%2A>.  
  
 Para facilitar a explicação sobre o <xref:System.Data.DataSet.Merge%2A> método, usamos "destino" para significar atual <xref:System.Data.DataSet>e "fonte" para nomear a segunda (parâmetro) <xref:System.Data.DataSet>. O destino <xref:System.Data.DataSet> é chamada assim porque ele é o objeto no qual ocorre uma ação (mesclagem). A segunda <xref:System.Data.DataSet> é chamado de "origem" porque as informações que ele contém não é alterado, mas em vez disso, são mescladas em atual <xref:System.Data.DataSet>.  
  
 Quando o método <xref:System.Data.DataSet.Merge%2A> é chamado, os esquemas dos dois objetos de <xref:System.Data.DataSet> são comparados, porque é possível que os esquemas possam ter sido alterados. Por exemplo, em um cenário entre empresas, novas colunas podem ter sido adicionadas a um esquema XML por um processo automatizado. Se a fonte <xref:System.Data.DataSet> contiver elementos do esquema (objetos <xref:System.Data.DataColumn> adicionados) que estão faltando no destino, os elementos do esquema poderão ser adicionados ao destino definindo o argumento `missingSchemaAction` como `MissingSchemaAction.Add`. Nesse caso, o <xref:System.Data.DataSet> mesclado contém o esquema e os dados adicionados.  
  
 Após a mesclagem de esquemas, os dados são mesclados.  
  
 Durante a mesclagem de uma nova fonte <xref:System.Data.DataSet> no destino, qualquer linha de origem com um valor <xref:System.Data.DataRowState> de `Unchanged`, `Modified` ou `Deleted` são correspondidos para selecionar linhas com os mesmos valores de chave primária. As linhas de origem com um valor de `DataRowState` de `Added` correspondem às novas linhas de destino com os mesmos valores de chave primária das novas linhas de origem.  
  
 Durante uma mesclagem, as restrições permanecem desabilitadas. Se alguma restrição não puder ser habilitada ao final da mesclagem, um <xref:System.Data.ConstraintException> será gerado e os dados mesclados serão mantidos quando as restrições estiverem desabilitadas. Nesse caso, a propriedade <xref:System.Data.DataSet.EnforceConstraints%2A> é definida como `false`, e todas as linhas inválidas são marcadas com erro. Os erros deverão ser resolvidos antes de tentar redefinir a propriedade <xref:System.Data.DataSet.EnforceConstraints%2A> como `true`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Merge">
      <MemberSignature Language="C#" Value="public void Merge (System.Data.DataSet dataSet, bool preserveChanges, System.Data.MissingSchemaAction missingSchemaAction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Merge(class System.Data.DataSet dataSet, bool preserveChanges, valuetype System.Data.MissingSchemaAction missingSchemaAction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.Merge(System.Data.DataSet,System.Boolean,System.Data.MissingSchemaAction)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Merge(System::Data::DataSet ^ dataSet, bool preserveChanges, System::Data::MissingSchemaAction missingSchemaAction);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dataSet" Type="System.Data.DataSet" />
        <Parameter Name="preserveChanges" Type="System.Boolean" />
        <Parameter Name="missingSchemaAction" Type="System.Data.MissingSchemaAction" />
      </Parameters>
      <Docs>
        <param name="dataSet">O <see langword="DataSet" /> cujos dados e esquema serão mesclados.</param>
        <param name="preserveChanges">
          <see langword="true" /> para preservar alterações no <see langword="DataSet" /> atual; caso contrário, <see langword="false" />.</param>
        <param name="missingSchemaAction">Um dos valores de <see cref="T:System.Data.MissingSchemaAction" />.</param>
        <summary>Mescla um <see cref="T:System.Data.DataSet" /> especificado e seu esquema com o atual <see langword="DataSet" />, preservando ou descartando alterações no <see langword="DataSet" /> atual e manipulando um esquema incompatível de acordo com os argumentos fornecidos.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O método <xref:System.Data.DataSet.Merge%2A> é usado para mesclar dois objetos <xref:System.Data.DataSet> que têm esquemas amplamente semelhantes. Uma mesclagem é normalmente usada em um aplicativo cliente incorporar as alterações mais recentes feitas em uma fonte de dados a um <xref:System.Data.DataSet>existente. Isso permite que o aplicativo cliente tenha um <xref:System.Data.DataSet> atualizado com os dados mais recentes a partir da fonte de dados.  
  
 O método <xref:System.Data.DataSet.Merge%2A> é chamado geralmente ao final de uma série de procedimentos que envolvem a validação de alterações, a reconciliação de erros, a atualização da fonte de dados com as alterações e, por fim, a atualização do <xref:System.Data.DataSet>existente.  
  
 Em um aplicativo cliente, é comum ter um único botão em que o usuário possa clicar reunindo os dados alterados e os valida antes de enviar de volta para um componente de camada intermediária. Nesse cenário, o método <xref:System.Data.DataSet.GetChanges%2A> é invocado primeiro. O método retorna um segundo <xref:System.Data.DataSet> otimizado para validação e mesclagem. Este segundo objeto <xref:System.Data.DataSet> contém apenas os objetos <xref:System.Data.DataTable> e <xref:System.Data.DataRow> que foram modificados, resultando em um subconjunto do <xref:System.Data.DataSet> original. Este subconjunto é geralmente menor e, assim, passado com mais eficiência para um componente de camada intermediária. Em seguida, o componente de camada intermediária atualiza a fonte de dados original com as alterações por meio de procedimentos armazenados. A camada intermediária pode enviar novamente em qualquer um novo <xref:System.Data.DataSet> que inclui dados originais e os dados mais recentes da fonte de dados (executando a consulta original novamente), ou pode enviar novamente o subconjunto com eventuais alterações feitas a partir da fonte de dados. (Por exemplo, se a fonte de dados cria automaticamente valores de chave primária exclusivos, esses valores podem ser propagados de volta para o aplicativo cliente.) Em ambos os casos, o <xref:System.Data.DataSet> retornado pode ser mesclado de volta ao <xref:System.Data.DataSet> original do aplicativo cliente com o método <xref:System.Data.DataSet.Merge%2A>.  
  
 Para facilitar a explicação sobre o <xref:System.Data.DataSet.Merge%2A> método, usamos "destino" para significar atual <xref:System.Data.DataSet>e "fonte" para nomear a segunda (parâmetro) <xref:System.Data.DataSet>. O destino <xref:System.Data.DataSet> é chamada assim porque ele é o objeto no qual ocorre uma ação (mesclagem). A segunda <xref:System.Data.DataSet> é chamado de "origem" porque as informações que ele contém não é alterado, mas em vez disso, são mescladas em atual <xref:System.Data.DataSet>.  
  
 Quando o método <xref:System.Data.DataSet.Merge%2A> é chamado, os esquemas dos dois objetos de <xref:System.Data.DataSet> são comparados, porque é possível que os esquemas possam ter sido alterados. Por exemplo, em um cenário entre empresas, novas colunas podem ter sido adicionadas a um esquema XML por um processo automatizado. Se a fonte <xref:System.Data.DataSet> contiver elementos do esquema (objetos <xref:System.Data.DataColumn> adicionados) que estão faltando no destino, os elementos do esquema poderão ser adicionados ao destino definindo o argumento `missingSchemaAction` como `MissingSchemaAction.Add`. Nesse caso, o <xref:System.Data.DataSet> mesclado contém o esquema e os dados adicionados.  
  
 Após a mesclagem de esquemas, os dados são mesclados.  
  
 Durante a mesclagem de uma nova fonte <xref:System.Data.DataSet> no destino, qualquer linha de origem com um valor <xref:System.Data.DataRowState> de `Unchanged`, `Modified` ou `Deleted` são correspondidos para selecionar linhas com os mesmos valores de chave primária. As linhas de origem com um valor de `DataRowState` de `Added` correspondem às novas linhas de destino com os mesmos valores de chave primária das novas linhas de origem.  
  
 Durante uma mesclagem, as restrições permanecem desabilitadas. Se alguma restrição não puder ser habilitada ao final da mesclagem, um <xref:System.Data.ConstraintException> será gerado e os dados mesclados serão mantidos quando as restrições estiverem desabilitadas. Nesse caso, a propriedade <xref:System.Data.DataSet.EnforceConstraints%2A> é definida como `false`, e todas as linhas inválidas são marcadas com erro. Os erros deverão ser resolvidos antes de tentar redefinir a propriedade <xref:System.Data.DataSet.EnforceConstraints%2A> como `true`.  
  
   
  
## Examples  
 O exemplo a seguir cria um <xref:System.Data.DataSet> simples com uma tabela, duas colunas e dez linhas. Dois valores são alterados e uma linha é adicionada. Um subconjunto dos dados alterados é criado usando o <xref:System.Data.DataSet.GetChanges%2A> método. Após reconciliar erros, uma nova coluna é adicionada ao subconjunto, alterando o esquema. Quando o <xref:System.Data.DataSet.Merge%2A> método for chamado com o `missingSchemaAction` definida como `MissingSchemaAction.Add`, a nova coluna é adicionada ao valor original <xref:System.Data.DataSet> esquema do objeto.  
  
 [!code-csharp[Classic WebData DataSet.Merge2 Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.Merge2 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.Merge2 Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.Merge2 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">O <paramref name="dataSet" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Merge">
      <MemberSignature Language="C#" Value="public void Merge (System.Data.DataTable table, bool preserveChanges, System.Data.MissingSchemaAction missingSchemaAction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Merge(class System.Data.DataTable table, bool preserveChanges, valuetype System.Data.MissingSchemaAction missingSchemaAction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.Merge(System.Data.DataTable,System.Boolean,System.Data.MissingSchemaAction)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Merge(System::Data::DataTable ^ table, bool preserveChanges, System::Data::MissingSchemaAction missingSchemaAction);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="table" Type="System.Data.DataTable" />
        <Parameter Name="preserveChanges" Type="System.Boolean" />
        <Parameter Name="missingSchemaAction" Type="System.Data.MissingSchemaAction" />
      </Parameters>
      <Docs>
        <param name="table">O <see langword="DataTable" /> cujos dados e esquema serão mesclados.</param>
        <param name="preserveChanges">Um dos valores de <see cref="T:System.Data.MissingSchemaAction" />.</param>
        <param name="missingSchemaAction">
          <see langword="true" /> para preservar alterações no <see langword="DataSet" />; caso contrário, <see langword="false" />.</param>
        <summary>Mescla um <see cref="T:System.Data.DataTable" /> especificado e seu esquema com o atual <see langword="DataSet" />, preservando ou descartando alterações no <see langword="DataSet" /> e manipulando um esquema incompatível de acordo com os argumentos fornecidos.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O método <xref:System.Data.DataSet.Merge%2A> é usado para mesclar dois objetos <xref:System.Data.DataSet> que têm esquemas amplamente semelhantes. Uma mesclagem é normalmente usada em um aplicativo cliente incorporar as alterações mais recentes feitas em uma fonte de dados a um <xref:System.Data.DataSet>existente. Isso permite que o aplicativo cliente tenha um <xref:System.Data.DataSet> atualizado com os dados mais recentes a partir da fonte de dados.  
  
 O método <xref:System.Data.DataSet.Merge%2A> é chamado geralmente ao final de uma série de procedimentos que envolvem a validação de alterações, a reconciliação de erros, a atualização da fonte de dados com as alterações e, por fim, a atualização do <xref:System.Data.DataSet>existente.  
  
 iOn um aplicativo cliente, é comum que haja um único botão que o usuário pode clicar que coleta os dados alterados e valida antes de enviá-la de volta para um componente de camada intermediária. Nesse cenário, o método <xref:System.Data.DataSet.GetChanges%2A> é invocado primeiro. O método retorna um segundo <xref:System.Data.DataSet> otimizado para validação e mesclagem. Este segundo objeto <xref:System.Data.DataSet> contém apenas os objetos <xref:System.Data.DataTable> e <xref:System.Data.DataRow> que foram modificados, resultando em um subconjunto do <xref:System.Data.DataSet> original. Este subconjunto é geralmente menor e, assim, passado com mais eficiência para um componente de camada intermediária. Em seguida, o componente de camada intermediária atualiza a fonte de dados original com as alterações por meio de procedimentos armazenados. A camada intermediária pode enviar novamente em qualquer um novo <xref:System.Data.DataSet> que inclui dados originais e os dados mais recentes da fonte de dados (executando a consulta original novamente), ou pode enviar novamente o subconjunto com eventuais alterações feitas a partir da fonte de dados. (Por exemplo, se a fonte de dados cria automaticamente valores de chave primária exclusivos, esses valores podem ser propagados de volta para o aplicativo cliente.) Em ambos os casos, o <xref:System.Data.DataSet> retornado pode ser mesclado de volta ao <xref:System.Data.DataSet> original do aplicativo cliente com o método <xref:System.Data.DataSet.Merge%2A>.  
  
 Quando o método <xref:System.Data.DataSet.Merge%2A> é chamado, os esquemas dos dois objetos de <xref:System.Data.DataSet> são comparados, porque é possível que os esquemas possam ter sido alterados. Por exemplo, em um cenário entre empresas, novas colunas podem ter sido adicionadas a um esquema XML por um processo automatizado. Se a fonte <xref:System.Data.DataSet> contiver elementos do esquema (objetos <xref:System.Data.DataColumn> adicionados) que estão faltando no destino, os elementos do esquema poderão ser adicionados ao destino definindo o argumento `missingSchemaAction` como `MissingSchemaAction.Add`. Nesse caso, o <xref:System.Data.DataSet> mesclado contém o esquema e os dados adicionados.  
  
 Após a mesclagem de esquemas, os dados são mesclados.  
  
 Durante a mesclagem de uma nova fonte <xref:System.Data.DataSet> no destino, qualquer linha de origem com um valor <xref:System.Data.DataRowState> de `Unchanged`, `Modified` ou `Deleted` são correspondidos para selecionar linhas com os mesmos valores de chave primária. As linhas de origem com um valor de `DataRowState` de `Added` correspondem às novas linhas de destino com os mesmos valores de chave primária das novas linhas de origem.  
  
 Durante uma mesclagem, as restrições permanecem desabilitadas. Se alguma restrição não puder ser habilitada ao final da mesclagem, um <xref:System.Data.ConstraintException> será gerado e os dados mesclados serão mantidos quando as restrições estiverem desabilitadas. Nesse caso, a propriedade <xref:System.Data.DataSet.EnforceConstraints%2A> é definida como `false`, e todas as linhas inválidas são marcadas com erro. Os erros deverão ser resolvidos antes de tentar redefinir a propriedade <xref:System.Data.DataSet.EnforceConstraints%2A> como `true`.  
  
   
  
## Examples  
 O exemplo a seguir cria um <xref:System.Data.DataSet> simples com uma tabela, duas colunas e dez linhas. Um segundo <xref:System.Data.DataTable> é criado que é praticamente idêntico ao primeiro exceto que um novo `DataColumn` é adicionada à tabela. Duas linhas são adicionadas para a segunda tabela, em seguida, é mesclada no <xref:System.Data.DataSet> com o `preserveChanges` argumento definido como `false`e o `missingSchemaAction` argumento definido como `MissingSchemaAction.Add`.  
  
 [!code-csharp[Classic WebData DataSet.Merge4 Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.Merge4 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.Merge4 Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.Merge4 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">O <paramref name="dataSet" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="MergeFailed">
      <MemberSignature Language="C#" Value="public event System.Data.MergeFailedEventHandler MergeFailed;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Data.MergeFailedEventHandler MergeFailed" />
      <MemberSignature Language="DocId" Value="E:System.Data.DataSet.MergeFailed" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event MergeFailed As MergeFailedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Data::MergeFailedEventHandler ^ MergeFailed;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.MergeFailedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ocorre quando uma origem e um destino <see cref="T:System.Data.DataRow" /> têm o mesmo valor de chave primária e <see cref="P:System.Data.DataSet.EnforceConstraints" /> é definido como true.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para obter mais informações sobre a manipulação de eventos, consulte [NIB: consumindo eventos](http://msdn.microsoft.com/library/01e4f1bc-e55e-413f-98c7-6588493e5f67).  
  
   
  
## Examples  
 O exemplo a seguir demonstra o uso do <xref:System.Data.DataSet.MergeFailed> evento.  
  
 [!code-csharp[Classic WebData DataSet.MergeFailed Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.MergeFailed Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.MergeFailed Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.MergeFailed Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Namespace">
      <MemberSignature Language="C#" Value="public string Namespace { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Namespace" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataSet.Namespace" />
      <MemberSignature Language="VB.NET" Value="Public Property Namespace As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Namespace { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue("")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define o namespace do <see cref="T:System.Data.DataSet" />.</summary>
        <value>O namespace do <see cref="T:System.Data.DataSet" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Data.DataSet.Namespace%2A> propriedade é usada ao ler e gravar um XML de documento para o <xref:System.Data.DataSet> usando o <xref:System.Data.DataSet.ReadXml%2A>, <xref:System.Data.DataSet.WriteXml%2A>, <xref:System.Data.DataSet.ReadXmlSchema%2A>, ou <xref:System.Data.DataSet.WriteXmlSchema%2A> métodos.  
  
 O namespace de um documento XML é usado para definir o escopo de atributos e elementos ao ler no XML um <xref:System.Data.DataSet>. Por exemplo, se um <xref:System.Data.DataSet> contém um esquema que foram lidos a partir de um documento com o namespace "myCompany" e é feita uma tentativa de ler dados somente de um documento com um namespace diferente, quaisquer dados que não correspondem ao esquema existente serão ignorados.  
  
   
  
## Examples  
 O exemplo a seguir define o <xref:System.Data.DataSet.Prefix%2A> antes de chamar o <xref:System.Data.DataSet.ReadXml%2A> método.  
  
 [!code-csharp[Classic WebData DataSet.Namespace Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.Namespace Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.Namespace Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.Namespace Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">O namespace já tem dados.</exception>
      </Docs>
    </Member>
    <Member MemberName="OnPropertyChanging">
      <MemberSignature Language="C#" Value="protected virtual void OnPropertyChanging (System.ComponentModel.PropertyChangedEventArgs pcevent);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnPropertyChanging(class System.ComponentModel.PropertyChangedEventArgs pcevent) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.OnPropertyChanging(System.ComponentModel.PropertyChangedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnPropertyChanging (pcevent As PropertyChangedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnPropertyChanging(System::ComponentModel::PropertyChangedEventArgs ^ pcevent);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pcevent" Type="System.ComponentModel.PropertyChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="pcevent">Um <see cref="T:System.ComponentModel.PropertyChangedEventArgs" /> que contém os dados do evento.</param>
        <summary>Aciona o evento <see cref="M:System.Data.DataSet.OnPropertyChanging(System.ComponentModel.PropertyChangedEventArgs)" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A geração de um evento invoca o manipulador de eventos por meio de um delegado. Para obter uma visão geral, consulte [tratamento e gerando eventos](~/docs/standard/events/index.md).  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Ao substituir <see cref="M:System.Data.DataSet.OnPropertyChanging(System.ComponentModel.PropertyChangedEventArgs)" /> em uma classe derivada, certifique-se de chamar a classe base <see cref="M:System.Data.DataSet.OnPropertyChanging(System.ComponentModel.PropertyChangedEventArgs)" /> método.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnRemoveRelation">
      <MemberSignature Language="C#" Value="protected virtual void OnRemoveRelation (System.Data.DataRelation relation);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnRemoveRelation(class System.Data.DataRelation relation) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.OnRemoveRelation(System.Data.DataRelation)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnRemoveRelation (relation As DataRelation)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnRemoveRelation(System::Data::DataRelation ^ relation);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="relation" Type="System.Data.DataRelation" />
      </Parameters>
      <Docs>
        <param name="relation">O <see cref="T:System.Data.DataRelation" /> sendo removido.</param>
        <summary>Ocorre quando um objeto <see cref="T:System.Data.DataRelation" /> é removido de um <see cref="T:System.Data.DataTable" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método deve ser substituído por subclasses para restringir as tabelas que está sendo removidas  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnRemoveTable">
      <MemberSignature Language="C#" Value="protected internal virtual void OnRemoveTable (System.Data.DataTable table);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnRemoveTable(class System.Data.DataTable table) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.OnRemoveTable(System.Data.DataTable)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnRemoveTable (table As DataTable)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnRemoveTable(System::Data::DataTable ^ table);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="table" Type="System.Data.DataTable" />
      </Parameters>
      <Docs>
        <param name="table">O <see cref="T:System.Data.DataTable" /> sendo removido.</param>
        <summary>Ocorre quando um <see cref="T:System.Data.DataTable" /> é removido de um <see cref="T:System.Data.DataSet" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método pode ser substituído por subclasses para impedir que as tabelas que está sendo removido.  
  
   
  
## Examples  
 O exemplo a seguir mostra uma classe que deriva de <xref:System.Data.DataSet> com o <xref:System.Data.DataSet.OnRemoveTable%2A> método substituído.  
  
 [!code-csharp[Classic WebData DataSet.OnRemoveTable Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.OnRemoveTable Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.OnRemoveTable Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.OnRemoveTable Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Prefix">
      <MemberSignature Language="C#" Value="public string Prefix { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Prefix" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataSet.Prefix" />
      <MemberSignature Language="VB.NET" Value="Public Property Prefix As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Prefix { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue("")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define um prefixo XML que cria o alias do namespace do <see cref="T:System.Data.DataSet" />.</summary>
        <value>O prefixo XML para o namespace <see cref="T:System.Data.DataSet" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Data.DataSet.Prefix%2A> em um documento XML, a propriedade é usada para identificar elementos que pertencem ao namespace do <xref:System.Data.DataSet> objeto (conforme definido pelo <xref:System.Data.DataSet.Namespace%2A> propriedade).  
  
   
  
## Examples  
 O exemplo a seguir define o <xref:System.Data.DataSet.Prefix%2A> antes de chamar o <xref:System.Data.DataSet.ReadXml%2A> método.  
  
 [!code-csharp[Classic WebData DataSet.Namespace Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.Namespace Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.Namespace Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.Namespace Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RaisePropertyChanging">
      <MemberSignature Language="C#" Value="protected internal void RaisePropertyChanging (string name);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig instance void RaisePropertyChanging(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.RaisePropertyChanging(System.String)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Sub RaisePropertyChanging (name As String)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; void RaisePropertyChanging(System::String ^ name);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">O nome da propriedade que está prestes a ser alterada.</param>
        <summary>Envia uma notificação de que a propriedade <see cref="T:System.Data.DataSet" /> especificada está prestes a ser alterada.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="ReadXml">
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Lê o esquema XML e os dados para o <see cref="T:System.Data.DataSet" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReadXml">
      <MemberSignature Language="C#" Value="public System.Data.XmlReadMode ReadXml (System.IO.Stream stream);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Data.XmlReadMode ReadXml(class System.IO.Stream stream) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.ReadXml(System.IO.Stream)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::XmlReadMode ReadXml(System::IO::Stream ^ stream);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.XmlReadMode</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
      </Parameters>
      <Docs>
        <param name="stream">Um objeto que deriva de <see cref="T:System.IO.Stream" />.</param>
        <summary>Lê o esquema XML e dados para o <see cref="T:System.Data.DataSet" /> usando o <see cref="T:System.IO.Stream" /> especificado.</summary>
        <returns>O <see cref="T:System.Data.XmlReadMode" /> usado para ler os dados.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O método <xref:System.Data.DataSet.ReadXml%2A> fornece uma maneira de ler apenas dados ou dados e esquema em um <xref:System.Data.DataSet> a partir de um documento XML, e o método <xref:System.Data.DataSet.ReadXmlSchema%2A> lê apenas o esquema. Para ler dados e esquema, use uma das sobrecargas `ReadXML` que inclui o parâmetro de `mode` e defina o valor como `ReadSchema`.  
  
 Observe que o mesmo é verdadeiro para os métodos <xref:System.Data.DataSet.WriteXml%2A> e <xref:System.Data.DataSet.WriteXmlSchema%2A>, respectivamente. Para gravar dados XML ou o esquema e os dados do `DataSet`, use o método `WriteXml`. Para gravar apenas o esquema, use o método `WriteXmlSchema`.  
  
> [!NOTE]
>  Um <xref:System.InvalidOperationException> será lançado se um tipo de coluna no `DataRow` de leitura ou gravação implementa <xref:System.Dynamic.IDynamicMetaObjectProvider> e não implementa <xref:System.Xml.Serialization.IXmlSerializable>.  
  
 Se um esquema embutido for especificado, o esquema embutido será usado para estender a estrutura relacional existente antes de carregar os dados. Se houver algum conflito (por exemplo, a mesma coluna na mesma tabela definida com tipos de dados diferentes), uma exceção será gerada.  
  
 Se nenhum esquema embutido for especificado, a estrutura relacional será estendida por meio de inferência, conforme necessário, de acordo com a estrutura do documento XML. Se o esquema não puder ser estendido por meio de inferência para expor todos os dados, uma exceção será gerada.  
  
> [!NOTE]
>  O `DataSet` não associa um elemento XML ao `DataColumn` correspondente `DataTable` quando caracteres XML legais como (“_”) escapam no XML serializável. O próprio `DataSet` só escapa com caracteres XML ilegais em nomes de elemento XML e, assim, só pode consumir o mesmo. Quando os caracteres legais no nome de elemento XML são escapadas, o elemento é ignorado durante o processamento.  
  
 Se o esquema XML para <xref:System.Data.DataSet> incluir `targetNamespace`, os dados não poderão ser lidos e você poderá encontrar exceções ao chamar <xref:System.Data.DataSet.ReadXml%2A> para carregar o <xref:System.Data.DataSet> com XML que contenha elementos sem nenhum namespace de qualificação. Para ler os elementos não qualificados, defina `elementFormDefault` igual a "qualificado" em seu esquema XML, como demonstrado no exemplo a seguir.  
  
```  
<xsd:schema id="MyDataSet"   
   elementFormDefault="qualified"   
   targetNamespace="http://www.tempuri.org/MyDataSet.xsd"   
   xmlns="http://www.tempuri.org/MyDataSet.xsd"   
   xmlns:xsd="http://www.w3.org/2001/XMLSchema"   
   xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">  
</xsd:schema>  
```  
  
> [!NOTE]
>  Se o esquema para o <xref:System.Data.DataSet> contiver elementos do mesmo nome, mas de tipo diferente, no mesmo namespace, uma exceção será gerada quando você tentar ler o esquema no <xref:System.Data.DataSet> com <xref:System.Data.DataSet.ReadXml%2A> especificando `XmlReadMode.ReadSchema`. Esta exceção não ocorrerá se você estiver usando a versão 1.0 do.NET Framework.  
  
   
  
## Examples  
 O exemplo a seguir primeiramente cria um <xref:System.Data.DataSet> simples com um <xref:System.Data.DataTable>, duas colunas e dez linhas. O esquema <xref:System.Data.DataSet> e os dados são gravados em disco invocando o método <xref:System.Data.DataSet.WriteXml%2A>. Um segundo <xref:System.Data.DataSet> é criado e o método <xref:System.Data.DataSet.ReadXml%2A> é usado para preenchê-lo com esquema e dados.  
  
 [!code-csharp[Classic WebData DataSet.ReadXml1 Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.ReadXml1 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.ReadXml1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.ReadXml1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Data.DataSet.ReadXmlSchema(System.Xml.XmlReader)" />
        <altmember cref="M:System.Data.DataSet.WriteXml(System.IO.Stream)" />
        <altmember cref="M:System.Data.DataSet.WriteXmlSchema(System.IO.Stream)" />
      </Docs>
    </Member>
    <Member MemberName="ReadXml">
      <MemberSignature Language="C#" Value="public System.Data.XmlReadMode ReadXml (System.IO.TextReader reader);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Data.XmlReadMode ReadXml(class System.IO.TextReader reader) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.ReadXml(System.IO.TextReader)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReadXml (reader As TextReader) As XmlReadMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::XmlReadMode ReadXml(System::IO::TextReader ^ reader);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.XmlReadMode</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.IO.TextReader" />
      </Parameters>
      <Docs>
        <param name="reader">O <see langword="TextReader" /> do qual ler o esquema e os dados.</param>
        <summary>Lê o esquema XML e dados para o <see cref="T:System.Data.DataSet" /> usando o <see cref="T:System.IO.TextReader" /> especificado.</summary>
        <returns>O <see cref="T:System.Data.XmlReadMode" /> usado para ler os dados.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O método <xref:System.Data.DataSet.ReadXml%2A> fornece uma maneira de ler apenas dados ou dados e esquema em um <xref:System.Data.DataSet> a partir de um documento XML, e o método <xref:System.Data.DataSet.ReadXmlSchema%2A> lê apenas o esquema. Para ler dados e esquema, use uma das sobrecargas `ReadXML` que inclui o parâmetro de `mode` e defina o valor como `ReadSchema`.  
  
 Observe que o mesmo é verdadeiro para os métodos <xref:System.Data.DataSet.WriteXml%2A> e <xref:System.Data.DataSet.WriteXmlSchema%2A>, respectivamente. Para gravar dados XML ou o esquema e os dados do `DataSet`, use o método `WriteXml`. Para gravar apenas o esquema, use o método `WriteXmlSchema`.  
  
> [!NOTE]
>  Um <xref:System.InvalidOperationException> será lançado se um tipo de coluna no `DataRow` de leitura ou gravação implementa <xref:System.Dynamic.IDynamicMetaObjectProvider> e não implementa <xref:System.Xml.Serialization.IXmlSerializable>.  
  
 Se um esquema embutido for especificado, o esquema embutido será usado para estender a estrutura relacional existente antes de carregar os dados. Se houver algum conflito (por exemplo, a mesma coluna na mesma tabela definida com tipos de dados diferentes), uma exceção será gerada.  
  
 Se nenhum esquema embutido for especificado, a estrutura relacional será estendida por meio de inferência, conforme necessário, de acordo com a estrutura do documento XML. Se o esquema não puder ser estendido por meio de inferência para expor todos os dados, uma exceção será gerada.  
  
> [!NOTE]
>  O `DataSet` não associa um elemento XML ao `DataColumn` correspondente `DataTable` quando caracteres XML legais como (“_”) escapam no XML serializável. O próprio `DataSet` só escapa com caracteres XML ilegais em nomes de elemento XML e, assim, só pode consumir o mesmo. Quando os caracteres legais no nome de elemento XML são escapadas, o elemento é ignorado durante o processamento.  
  
 Se o esquema XML para <xref:System.Data.DataSet> incluir `targetNamespace`, os dados não poderão ser lidos e você poderá encontrar exceções ao chamar <xref:System.Data.DataSet.ReadXml%2A> para carregar o <xref:System.Data.DataSet> com XML que contenha elementos sem nenhum namespace de qualificação. Para ler elementos não qualificados, defina `elementFormDefault` igual a "qualificado" no Esquema XML como o exemplo a seguir demonstra.  
  
```  
<xsd:schema id="MyDataSet"   
   elementFormDefault="qualified"   
   targetNamespace="http://www.tempuri.org/MyDataSet.xsd"   
   xmlns="http://www.tempuri.org/MyDataSet.xsd"   
   xmlns:xsd="http://www.w3.org/2001/XMLSchema"   
   xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">  
</xsd:schema>  
```  
  
 Classes que herdam o <xref:System.IO.TextReader> classe inclui o <xref:System.IO.StreamReader> e <xref:System.IO.StringReader> classes.  
  
> [!NOTE]
>  Se o esquema para o <xref:System.Data.DataSet> contiver elementos do mesmo nome, mas de tipo diferente, no mesmo namespace, uma exceção será gerada quando você tentar ler o esquema no <xref:System.Data.DataSet> com <xref:System.Data.DataSet.ReadXml%2A> especificando `XmlReadMode.ReadSchema`. Esta exceção não ocorrerá se você estiver usando a versão 1.0 do.NET Framework.  
  
   
  
## Examples  
 O exemplo a seguir primeiramente cria um <xref:System.Data.DataSet> simples com um <xref:System.Data.DataTable>, duas colunas e dez linhas. O esquema <xref:System.Data.DataSet> e os dados são gravados em disco invocando o método <xref:System.Data.DataSet.WriteXml%2A>. Um segundo <xref:System.Data.DataSet> é criado e o método <xref:System.Data.DataSet.ReadXml%2A> é usado para preenchê-lo com esquema e dados.  
  
 [!code-csharp[Classic WebData DataSet.ReadXml2 Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.ReadXml2 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.ReadXml2 Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.ReadXml2 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReadXml">
      <MemberSignature Language="C#" Value="public System.Data.XmlReadMode ReadXml (string fileName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Data.XmlReadMode ReadXml(string fileName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.ReadXml(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReadXml (fileName As String) As XmlReadMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::XmlReadMode ReadXml(System::String ^ fileName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.XmlReadMode</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="fileName">O nome do arquivo (incluindo o caminho) do qual será realizada a leitura.</param>
        <summary>Lê o esquema XML e dados no <see cref="T:System.Data.DataSet" /> usando o arquivo especificado.</summary>
        <returns>O <see langword="XmlReadMode" /> usado para ler os dados.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O método <xref:System.Data.DataSet.ReadXml%2A> fornece uma maneira de ler apenas dados ou dados e esquema em um <xref:System.Data.DataSet> a partir de um documento XML, e o método <xref:System.Data.DataSet.ReadXmlSchema%2A> lê apenas o esquema. Para ler dados e esquema, use uma das sobrecargas `ReadXML` que inclui o parâmetro de `mode` e defina o valor como `ReadSchema`.  
  
 Observe que o mesmo é verdadeiro para os métodos <xref:System.Data.DataSet.WriteXml%2A> e <xref:System.Data.DataSet.WriteXmlSchema%2A>, respectivamente. Para gravar dados XML ou o esquema e os dados do `DataSet`, use o método `WriteXml`. Para gravar apenas o esquema, use o método `WriteXmlSchema`.  
  
> [!NOTE]
>  Um <xref:System.InvalidOperationException> será lançado se um tipo de coluna no `DataRow` de leitura ou gravação implementa <xref:System.Dynamic.IDynamicMetaObjectProvider> e não implementa <xref:System.Xml.Serialization.IXmlSerializable>.  
  
 Se um esquema embutido for especificado, o esquema embutido será usado para estender a estrutura relacional existente antes de carregar os dados. Se houver algum conflito (por exemplo, a mesma coluna na mesma tabela definida com tipos de dados diferentes), uma exceção será gerada.  
  
 Se nenhum esquema embutido for especificado, a estrutura relacional será estendida por meio de inferência, conforme necessário, de acordo com a estrutura do documento XML. Se o esquema não puder ser estendido por meio de inferência para expor todos os dados, uma exceção será gerada.  
  
> [!NOTE]
>  O `DataSet` não associa um elemento XML ao `DataColumn` correspondente `DataTable` quando caracteres XML legais como (“_”) escapam no XML serializável. O próprio `DataSet` só escapa com caracteres XML ilegais em nomes de elemento XML e, assim, só pode consumir o mesmo. Quando os caracteres legais no nome de elemento XML são escapadas, o elemento é ignorado durante o processamento.  
  
 Se o esquema XML de um <xref:System.Data.DataSet> incluir `targetNamespace`, os dados não poderão ser lidos e você poderá encontrar exceções ao chamar <xref:System.Data.DataSet.ReadXml%2A> para carregar <xref:System.Data.DataSet> com XML que contenha elementos sem nenhum namespace de qualificação. Para ler elementos não qualificados, defina `elementFormDefault` igual a "qualificado" no Esquema XML como o exemplo a seguir demonstra.  
  
```  
<xsd:schema id="MyDataSet"   
   elementFormDefault="qualified"   
   targetNamespace="http://www.tempuri.org/MyDataSet.xsd"   
   xmlns="http://www.tempuri.org/MyDataSet.xsd"   
   xmlns:xsd="http://www.w3.org/2001/XMLSchema"   
   xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">  
</xsd:schema>  
```  
  
> [!NOTE]
>  Se o esquema para o <xref:System.Data.DataSet> contiver elementos do mesmo nome, mas de tipo diferente, no mesmo namespace, uma exceção será gerada quando você tentar ler o esquema no <xref:System.Data.DataSet> com <xref:System.Data.DataSet.ReadXml%2A> especificando `XmlReadMode.ReadSchema`. Esta exceção não ocorrerá se você estiver usando a versão 1.0 do.NET Framework.  
  
   
  
## Examples  
 O exemplo a seguir primeiramente cria um <xref:System.Data.DataSet> simples com um <xref:System.Data.DataTable>, duas colunas e dez linhas. O esquema <xref:System.Data.DataSet> e os dados são gravados em disco invocando o método <xref:System.Data.DataSet.WriteXml%2A>. Um segundo <xref:System.Data.DataSet> é criado e o método <xref:System.Data.DataSet.ReadXml%2A> é usado para preenchê-lo com esquema e dados.  
  
 [!code-csharp[Classic WebData DataSet.ReadXml3 Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.ReadXml3 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.ReadXml3 Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.ReadXml3 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">
          <see cref="T:System.Security.Permissions.FileIOPermission" /> não é definido como <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">para ler e gravar arquivos. Enumeração associada: <see cref="T:System.Security.Permissions.FileIOPermissionAccess" /></permission>
      </Docs>
    </Member>
    <Member MemberName="ReadXml">
      <MemberSignature Language="C#" Value="public System.Data.XmlReadMode ReadXml (System.Xml.XmlReader reader);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Data.XmlReadMode ReadXml(class System.Xml.XmlReader reader) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.ReadXml(System.Xml.XmlReader)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReadXml (reader As XmlReader) As XmlReadMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::XmlReadMode ReadXml(System::Xml::XmlReader ^ reader);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.XmlReadMode</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Xml.XmlReader" />
      </Parameters>
      <Docs>
        <param name="reader">O <see cref="T:System.Xml.XmlReader" /> do qual ler.</param>
        <summary>Lê o esquema XML e dados para o <see cref="T:System.Data.DataSet" /> usando o <see cref="T:System.Xml.XmlReader" /> especificado.</summary>
        <returns>O <see langword="XmlReadMode" /> usado para ler os dados.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O método <xref:System.Data.DataSet.ReadXml%2A> fornece uma maneira de ler apenas dados ou dados e esquema em um <xref:System.Data.DataSet> a partir de um documento XML, e o método <xref:System.Data.DataSet.ReadXmlSchema%2A> lê apenas o esquema. Para ler dados e esquema, use uma das sobrecargas `ReadXML` que inclui o parâmetro de `mode` e defina o valor como `ReadSchema`.  
  
 Observe que o mesmo é verdadeiro para os métodos <xref:System.Data.DataSet.WriteXml%2A> e <xref:System.Data.DataSet.WriteXmlSchema%2A>, respectivamente. Para gravar dados XML ou o esquema e os dados do `DataSet`, use o método `WriteXml`. Para gravar apenas o esquema, use o método `WriteXmlSchema`.  
  
> [!NOTE]
>  Um <xref:System.InvalidOperationException> será lançado se um tipo de coluna no `DataRow` de leitura ou gravação implementa <xref:System.Dynamic.IDynamicMetaObjectProvider> e não implementa <xref:System.Xml.Serialization.IXmlSerializable>.  
  
 Se um esquema embutido for especificado, o esquema embutido será usado para estender a estrutura relacional existente antes de carregar os dados. Se houver algum conflito (por exemplo, a mesma coluna na mesma tabela definida com tipos de dados diferentes), uma exceção será gerada.  
  
 Se nenhum esquema embutido for especificado, a estrutura relacional será estendida por meio de inferência, conforme necessário, de acordo com a estrutura do documento XML. Se o esquema não puder ser estendido por meio de inferência para expor todos os dados, uma exceção será gerada.  
  
> [!NOTE]
>  O `DataSet` não associa um elemento XML ao `DataColumn` correspondente `DataTable` quando caracteres XML legais como (“_”) escapam no XML serializável. O próprio `DataSet` só escapa com caracteres XML ilegais em nomes de elemento XML e, assim, só pode consumir o mesmo. Quando os caracteres legais no nome de elemento XML são escapadas, o elemento é ignorado durante o processamento.  
  
 Se o esquema XML de um <xref:System.Data.DataSet> incluir `targetNamespace`, os dados não poderão ser lidos e você poderá encontrar exceções ao chamar <xref:System.Data.DataSet.ReadXml%2A> para carregar <xref:System.Data.DataSet> com XML que contenha elementos sem nenhum namespace de qualificação. Para ler elementos não qualificados, defina `elementFormDefault` igual a "qualificado" no Esquema XML como o exemplo a seguir demonstra.  
  
```  
<xsd:schema id="MyDataSet"   
   elementFormDefault="qualified"   
   targetNamespace="http://www.tempuri.org/MyDataSet.xsd"   
   xmlns="http://www.tempuri.org/MyDataSet.xsd"   
   xmlns:xsd="http://www.w3.org/2001/XMLSchema"   
   xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">  
</xsd:schema>  
```  
  
 <xref:System.Xml.XmlTextReader?displayProperty=nameWithType> herda de <xref:System.Xml.XmlReader>.  
  
> [!NOTE]
>  Se o esquema para o <xref:System.Data.DataSet> contiver elementos do mesmo nome, mas de tipo diferente, no mesmo namespace, uma exceção será gerada quando você tentar ler o esquema no <xref:System.Data.DataSet> com <xref:System.Data.DataSet.ReadXml%2A> especificando `XmlReadMode.ReadSchema`. Esta exceção não ocorrerá se você estiver usando a versão 1.0 do.NET Framework.  
  
   
  
## Examples  
 O exemplo a seguir primeiramente cria um <xref:System.Data.DataSet> simples com um <xref:System.Data.DataTable>, duas colunas e dez linhas. O esquema <xref:System.Data.DataSet> e os dados são gravados em disco invocando o método <xref:System.Data.DataSet.WriteXml%2A>. Um segundo <xref:System.Data.DataSet> é criado e o método <xref:System.Data.DataSet.ReadXml%2A> é usado para preenchê-lo com esquema e dados.  
  
 [!code-csharp[Classic WebData DataSet.ReadXml Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.ReadXml Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.ReadXml Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.ReadXml Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReadXml">
      <MemberSignature Language="C#" Value="public System.Data.XmlReadMode ReadXml (System.IO.Stream stream, System.Data.XmlReadMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Data.XmlReadMode ReadXml(class System.IO.Stream stream, valuetype System.Data.XmlReadMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.ReadXml(System.IO.Stream,System.Data.XmlReadMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::XmlReadMode ReadXml(System::IO::Stream ^ stream, System::Data::XmlReadMode mode);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.XmlReadMode</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
        <Parameter Name="mode" Type="System.Data.XmlReadMode" />
      </Parameters>
      <Docs>
        <param name="stream">O <see cref="T:System.IO.Stream" /> do qual ler.</param>
        <param name="mode">Um dos valores de <see cref="T:System.Data.XmlReadMode" />.</param>
        <summary>Lê o esquema XML e os dados no <see cref="T:System.Data.DataSet" /> usando o <see cref="T:System.IO.Stream" /> e <see cref="T:System.Data.XmlReadMode" /> especificados.</summary>
        <returns>O <see langword="XmlReadMode" /> usado para ler os dados.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O método <xref:System.Data.DataSet.ReadXml%2A> fornece uma maneira de ler apenas dados ou dados e esquema em um <xref:System.Data.DataSet> a partir de um documento XML, e o método <xref:System.Data.DataSet.ReadXmlSchema%2A> lê apenas o esquema. Para ler dados e esquema, use uma das sobrecargas `ReadXML` que inclui o parâmetro de `mode` e defina o valor como `ReadSchema`.  
  
 O mesmo é verdadeiro para o <xref:System.Data.DataSet.WriteXml%2A> e <xref:System.Data.DataSet.WriteXmlSchema%2A> métodos, respectivamente. Para gravar dados XML ou o esquema e os dados do `DataSet`, use o método `WriteXml`. Para gravar apenas o esquema, use o método `WriteXmlSchema`.  
  
> [!NOTE]
>  Quando você usa <xref:System.Data.DataSet.ReadXml%2A> e definir <xref:System.Data.XmlReadMode> para `Diffgram`, o conteúdo do destino `DataSet` e original `DataSet` pode ser diferente devido a como o diffgram é gerado e processado. Para obter mais informações sobre diffgrams, consulte [DiffGrams](~/docs/framework/data/adonet/dataset-datatable-dataview/diffgrams.md).  
  
> [!NOTE]
>  Um <xref:System.InvalidOperationException> será lançado se um tipo de coluna no `DataRow` de leitura ou gravação implementa <xref:System.Dynamic.IDynamicMetaObjectProvider> e não implementa <xref:System.Xml.Serialization.IXmlSerializable>.  
  
 Se um esquema embutido for especificado, o esquema embutido será usado para estender a estrutura relacional existente antes de carregar os dados. Se houver algum conflito (por exemplo, a mesma coluna na mesma tabela definida com tipos de dados diferentes), uma exceção será gerada.  
  
 Se nenhum esquema embutido for especificado, a estrutura relacional será estendida por meio de inferência, conforme necessário, de acordo com a estrutura do documento XML. Se o esquema não puder ser estendido por meio de inferência para expor todos os dados, uma exceção será gerada.  
  
> [!NOTE]
>  O `DataSet` não associa um elemento XML ao `DataColumn` correspondente `DataTable` quando caracteres XML legais como (“_”) escapam no XML serializável. O próprio `DataSet` só escapa com caracteres XML ilegais em nomes de elemento XML e, assim, só pode consumir o mesmo. Quando os caracteres legais no nome de elemento XML são escapadas, o elemento é ignorado durante o processamento.  
  
 Se o esquema XML para <xref:System.Data.DataSet> incluir `targetNamespace`, os dados não poderão ser lidos e você poderá encontrar exceções ao chamar <xref:System.Data.DataSet.ReadXml%2A> para carregar o <xref:System.Data.DataSet> com XML que contenha elementos sem nenhum namespace de qualificação. Para ler elementos não qualificados, defina `elementFormDefault` igual a "qualificado" no Esquema XML como o exemplo a seguir demonstra.  
  
```  
<xsd:schema id="MyDataSet"   
   elementFormDefault="qualified"   
   targetNamespace="http://www.tempuri.org/MyDataSet.xsd"   
   xmlns="http://www.tempuri.org/MyDataSet.xsd"   
   xmlns:xsd="http://www.w3.org/2001/XMLSchema"   
   xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">  
</xsd:schema>  
```  
  
> [!NOTE]
>  Se o esquema para o <xref:System.Data.DataSet> contiver elementos do mesmo nome, mas de tipo diferente, no mesmo namespace, uma exceção será gerada quando você tentar ler o esquema no <xref:System.Data.DataSet> com <xref:System.Data.DataSet.ReadXml%2A> especificando `XmlReadMode.ReadSchema`. Esta exceção não ocorrerá se você estiver usando a versão 1.0 do.NET Framework.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReadXml">
      <MemberSignature Language="C#" Value="public System.Data.XmlReadMode ReadXml (System.IO.TextReader reader, System.Data.XmlReadMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Data.XmlReadMode ReadXml(class System.IO.TextReader reader, valuetype System.Data.XmlReadMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.ReadXml(System.IO.TextReader,System.Data.XmlReadMode)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReadXml (reader As TextReader, mode As XmlReadMode) As XmlReadMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::XmlReadMode ReadXml(System::IO::TextReader ^ reader, System::Data::XmlReadMode mode);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.XmlReadMode</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.IO.TextReader" />
        <Parameter Name="mode" Type="System.Data.XmlReadMode" />
      </Parameters>
      <Docs>
        <param name="reader">O <see cref="T:System.IO.TextReader" /> do qual ler.</param>
        <param name="mode">Um dos valores de <see cref="T:System.Data.XmlReadMode" />.</param>
        <summary>Lê o esquema XML e os dados no <see cref="T:System.Data.DataSet" /> usando o <see cref="T:System.IO.TextReader" /> e <see cref="T:System.Data.XmlReadMode" /> especificados.</summary>
        <returns>O <see langword="XmlReadMode" /> usado para ler os dados.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O método <xref:System.Data.DataSet.ReadXml%2A> fornece uma maneira de ler apenas dados ou dados e esquema em um <xref:System.Data.DataSet> a partir de um documento XML, e o método <xref:System.Data.DataSet.ReadXmlSchema%2A> lê apenas o esquema. Para ler dados e esquema, use uma das sobrecargas `ReadXML` que inclui o parâmetro de `mode` e defina o valor como `ReadSchema`.  
  
 Observe que o mesmo é verdadeiro para os métodos <xref:System.Data.DataSet.WriteXml%2A> e <xref:System.Data.DataSet.WriteXmlSchema%2A>, respectivamente. Para gravar dados XML ou o esquema e os dados do `DataSet`, use o método `WriteXml`. Para gravar apenas o esquema, use o método `WriteXmlSchema`.  
  
> [!NOTE]
>  Um <xref:System.InvalidOperationException> será lançado se um tipo de coluna no `DataRow` de leitura ou gravação implementa <xref:System.Dynamic.IDynamicMetaObjectProvider> e não implementa <xref:System.Xml.Serialization.IXmlSerializable>.  
  
 Se um esquema embutido for especificado, o esquema embutido será usado para estender a estrutura relacional existente antes de carregar os dados. Se houver algum conflito (por exemplo, a mesma coluna na mesma tabela definida com tipos de dados diferentes), uma exceção será gerada.  
  
 Se nenhum esquema embutido for especificado, a estrutura relacional será estendida por meio de inferência, conforme necessário, de acordo com a estrutura do documento XML. Se o esquema não puder ser estendido por meio de inferência para expor todos os dados, uma exceção será gerada.  
  
> [!NOTE]
>  O `DataSet` não associa um elemento XML ao `DataColumn` correspondente `DataTable` quando caracteres XML legais como (“_”) escapam no XML serializável. O próprio `DataSet` só escapa com caracteres XML ilegais em nomes de elemento XML e, assim, só pode consumir o mesmo. Quando os caracteres legais no nome de elemento XML são escapadas, o elemento é ignorado durante o processamento.  
  
 Se o esquema XML para <xref:System.Data.DataSet> incluir `targetNamespace`, os dados não poderão ser lidos e você poderá encontrar exceções ao chamar <xref:System.Data.DataSet.ReadXml%2A> para carregar o <xref:System.Data.DataSet> com XML que contenha elementos sem nenhum namespace de qualificação. Para ler elementos não qualificados, defina `elementFormDefault` igual a "qualificado" no Esquema XML como o exemplo a seguir demonstra.  
  
```  
<xsd:schema id="MyDataSet"   
   elementFormDefault="qualified"   
   targetNamespace="http://www.tempuri.org/MyDataSet.xsd"   
   xmlns="http://www.tempuri.org/MyDataSet.xsd"   
   xmlns:xsd="http://www.w3.org/2001/XMLSchema"   
   xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">  
</xsd:schema>  
```  
  
> [!NOTE]
>  Se o esquema para o <xref:System.Data.DataSet> contiver elementos do mesmo nome, mas de tipo diferente, no mesmo namespace, uma exceção será gerada quando você tentar ler o esquema no <xref:System.Data.DataSet> com <xref:System.Data.DataSet.ReadXml%2A> especificando `XmlReadMode.ReadSchema`. Esta exceção não ocorrerá se você estiver usando a versão 1.0 do.NET Framework.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReadXml">
      <MemberSignature Language="C#" Value="public System.Data.XmlReadMode ReadXml (string fileName, System.Data.XmlReadMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Data.XmlReadMode ReadXml(string fileName, valuetype System.Data.XmlReadMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.ReadXml(System.String,System.Data.XmlReadMode)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReadXml (fileName As String, mode As XmlReadMode) As XmlReadMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::XmlReadMode ReadXml(System::String ^ fileName, System::Data::XmlReadMode mode);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.XmlReadMode</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
        <Parameter Name="mode" Type="System.Data.XmlReadMode" />
      </Parameters>
      <Docs>
        <param name="fileName">O nome do arquivo (incluindo o caminho) do qual será realizada a leitura.</param>
        <param name="mode">Um dos valores de <see cref="T:System.Data.XmlReadMode" />.</param>
        <summary>Lê dados e o esquema XML no <see cref="T:System.Data.DataSet" /> usando o arquivo especificado e <see cref="T:System.Data.XmlReadMode" />.</summary>
        <returns>O <see langword="XmlReadMode" /> usado para ler os dados.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O método <xref:System.Data.DataSet.ReadXml%2A> fornece uma maneira de ler apenas dados ou dados e esquema em um <xref:System.Data.DataSet> a partir de um documento XML, e o método <xref:System.Data.DataSet.ReadXmlSchema%2A> lê apenas o esquema. Para ler dados e esquema, use uma das sobrecargas `ReadXML` que inclui o parâmetro de `mode` e defina o valor como `ReadSchema`.  
  
 Observe que o mesmo é verdadeiro para os métodos <xref:System.Data.DataSet.WriteXml%2A> e <xref:System.Data.DataSet.WriteXmlSchema%2A>, respectivamente. Para gravar dados XML ou o esquema e os dados do `DataSet`, use o método `WriteXml`. Para gravar apenas o esquema, use o método `WriteXmlSchema`.  
  
> [!NOTE]
>  Um <xref:System.InvalidOperationException> será lançado se um tipo de coluna no `DataRow` de leitura ou gravação implementa <xref:System.Dynamic.IDynamicMetaObjectProvider> e não implementa <xref:System.Xml.Serialization.IXmlSerializable>.  
  
 Se um esquema embutido for especificado, o esquema embutido será usado para estender a estrutura relacional existente antes de carregar os dados. Se houver algum conflito (por exemplo, a mesma coluna na mesma tabela definida com tipos de dados diferentes), uma exceção será gerada.  
  
 Se nenhum esquema embutido for especificado, a estrutura relacional será estendida por meio de inferência, conforme necessário, de acordo com a estrutura do documento XML. Se o esquema não puder ser estendido por meio de inferência para expor todos os dados, uma exceção será gerada.  
  
> [!NOTE]
>  O `DataSet` não associa um elemento XML ao `DataColumn` correspondente `DataTable` quando caracteres XML legais como (“_”) escapam no XML serializável. O próprio `DataSet` só escapa com caracteres XML ilegais em nomes de elemento XML e, assim, só pode consumir o mesmo. Quando os caracteres legais no nome de elemento XML são escapadas, o elemento é ignorado durante o processamento.  
  
 Se o esquema XML de um <xref:System.Data.DataSet> incluir `targetNamespace`, os dados não poderão ser lidos e você poderá encontrar exceções ao chamar <xref:System.Data.DataSet.ReadXml%2A> para carregar <xref:System.Data.DataSet> com XML que contenha elementos sem nenhum namespace de qualificação. Para ler elementos não qualificados, defina `elementFormDefault` igual a "qualificado" no Esquema XML como o exemplo a seguir demonstra.  
  
```  
<xsd:schema id="MyDataSet"   
   elementFormDefault="qualified"   
   targetNamespace="http://www.tempuri.org/MyDataSet.xsd"   
   xmlns="http://www.tempuri.org/MyDataSet.xsd"   
   xmlns:xsd="http://www.w3.org/2001/XMLSchema"   
   xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">  
</xsd:schema>  
```  
  
> [!NOTE]
>  Se o esquema para o <xref:System.Data.DataSet> contiver elementos do mesmo nome, mas de tipo diferente, no mesmo namespace, uma exceção será gerada quando você tentar ler o esquema no <xref:System.Data.DataSet> com <xref:System.Data.DataSet.ReadXml%2A> especificando `XmlReadMode.ReadSchema`. Esta exceção não ocorrerá se você estiver usando a versão 1.0 do.NET Framework.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">
          <see cref="T:System.Security.Permissions.FileIOPermission" /> não é definido como <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">para ler e gravar arquivos. Enumeração associada: <see cref="T:System.Security.Permissions.FileIOPermissionAccess" /></permission>
      </Docs>
    </Member>
    <Member MemberName="ReadXml">
      <MemberSignature Language="C#" Value="public System.Data.XmlReadMode ReadXml (System.Xml.XmlReader reader, System.Data.XmlReadMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Data.XmlReadMode ReadXml(class System.Xml.XmlReader reader, valuetype System.Data.XmlReadMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.ReadXml(System.Xml.XmlReader,System.Data.XmlReadMode)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReadXml (reader As XmlReader, mode As XmlReadMode) As XmlReadMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::XmlReadMode ReadXml(System::Xml::XmlReader ^ reader, System::Data::XmlReadMode mode);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.XmlReadMode</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Xml.XmlReader" />
        <Parameter Name="mode" Type="System.Data.XmlReadMode" />
      </Parameters>
      <Docs>
        <param name="reader">O <see cref="T:System.Xml.XmlReader" /> do qual ler.</param>
        <param name="mode">Um dos valores de <see cref="T:System.Data.XmlReadMode" />.</param>
        <summary>Lê o esquema XML e os dados no <see cref="T:System.Data.DataSet" /> usando o <see cref="T:System.Xml.XmlReader" /> e <see cref="T:System.Data.XmlReadMode" /> especificados.</summary>
        <returns>O <see langword="XmlReadMode" /> usado para ler os dados.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O método <xref:System.Data.DataSet.ReadXml%2A> fornece uma maneira de ler apenas dados ou dados e esquema em um <xref:System.Data.DataSet> a partir de um documento XML, e o método <xref:System.Data.DataSet.ReadXmlSchema%2A> lê apenas o esquema. Para ler dados e esquema, use uma das sobrecargas `ReadXML` que inclui o parâmetro de `mode` e defina o valor como `ReadSchema`.  
  
 Observe que o mesmo é verdadeiro para os métodos <xref:System.Data.DataSet.WriteXml%2A> e <xref:System.Data.DataSet.WriteXmlSchema%2A>, respectivamente. Para gravar dados XML ou o esquema e os dados do `DataSet`, use o método `WriteXml`. Para gravar apenas o esquema, use o método `WriteXmlSchema`.  
  
> [!NOTE]
>  Um <xref:System.InvalidOperationException> será lançado se um tipo de coluna no `DataRow` de leitura ou gravação implementa <xref:System.Dynamic.IDynamicMetaObjectProvider> e não implementa <xref:System.Xml.Serialization.IXmlSerializable>.  
  
 Se um esquema embutido for especificado, o esquema embutido será usado para estender a estrutura relacional existente antes de carregar os dados. Se houver algum conflito (por exemplo, a mesma coluna na mesma tabela definida com tipos de dados diferentes), uma exceção será gerada.  
  
 Se nenhum esquema embutido for especificado, a estrutura relacional será estendida por meio de inferência, conforme necessário, de acordo com a estrutura do documento XML. Se o esquema não puder ser estendido por meio de inferência para expor todos os dados, uma exceção será gerada.  
  
> [!NOTE]
>  O `DataSet` não associa um elemento XML ao `DataColumn` correspondente `DataTable` quando caracteres XML legais como (“_”) escapam no XML serializável. O próprio `DataSet` só escapa com caracteres XML ilegais em nomes de elemento XML e, assim, só pode consumir o mesmo. Quando os caracteres legais no nome de elemento XML são escapadas, o elemento é ignorado durante o processamento.  
  
 Se o esquema XML de um <xref:System.Data.DataSet> incluir `targetNamespace`, os dados não poderão ser lidos e você poderá encontrar exceções ao chamar <xref:System.Data.DataSet.ReadXml%2A> para carregar <xref:System.Data.DataSet> com XML que contenha elementos sem nenhum namespace de qualificação. Para ler elementos não qualificados, defina `elementFormDefault` igual a "qualificado" no Esquema XML como o exemplo a seguir demonstra.  
  
```  
<xsd:schema id="MyDataSet"   
   elementFormDefault="qualified"   
   targetNamespace="http://www.tempuri.org/MyDataSet.xsd"   
   xmlns="http://www.tempuri.org/MyDataSet.xsd"   
   xmlns:xsd="http://www.w3.org/2001/XMLSchema"   
   xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">  
</xsd:schema>  
```  
  
> [!NOTE]
>  Se o esquema para o <xref:System.Data.DataSet> contiver elementos do mesmo nome, mas de tipo diferente, no mesmo namespace, uma exceção será gerada quando você tentar ler o esquema no <xref:System.Data.DataSet> com <xref:System.Data.DataSet.ReadXml%2A> especificando `XmlReadMode.ReadSchema`. Esta exceção não ocorrerá se você estiver usando a versão 1.0 do.NET Framework.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="ReadXmlSchema">
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Lê um esquema XML para o <see cref="T:System.Data.DataSet" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReadXmlSchema">
      <MemberSignature Language="C#" Value="public void ReadXmlSchema (System.IO.Stream stream);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ReadXmlSchema(class System.IO.Stream stream) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.ReadXmlSchema(System.IO.Stream)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ReadXmlSchema(System::IO::Stream ^ stream);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
      </Parameters>
      <Docs>
        <param name="stream">O <see cref="T:System.IO.Stream" /> do qual ler.</param>
        <summary>Lê o esquema XML do <see cref="T:System.IO.Stream" /> especificado no <see cref="T:System.Data.DataSet" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use o método <xref:System.Data.DataSet.ReadXmlSchema%2A> para criar o esquema de um <xref:System.Data.DataSet>. O esquema inclui tabela, relação e definições de restrição. Para gravar um esquema em um documento XML, use o método <xref:System.Data.DataSet.WriteXmlSchema%2A>.  
  
 O esquema XML é gravado usando o padrão XSD.  
  
> [!NOTE]
>  A corrupção de dados poderá ocorrer se os tipos msdata:DataType e xs:type não coincidirem. Nenhuma exceção será gerada.  
  
 O método <xref:System.Data.DataSet.ReadXmlSchema%2A> é invocado geralmente antes de invocar o método <xref:System.Data.DataSet.ReadXml%2A> usado para preencher o <xref:System.Data.DataSet>.  
  
 Classes que derivam de <xref:System.IO.Stream> classe incluir <xref:System.IO.BufferedStream>, <xref:System.IO.FileStream>, <xref:System.IO.MemoryStream>, e <xref:System.Net.Sockets.NetworkStream>.  
  
> [!NOTE]
>  Se o esquema para o <xref:System.Data.DataSet> contiver elementos do mesmo nome, mas de tipo diferente, no mesmo namespace, uma exceção será gerada quando você tentar ler o esquema no <xref:System.Data.DataSet> com <xref:System.Data.DataSet.ReadXmlSchema%2A>. Esta exceção não ocorrerá se você estiver usando a versão 1.0 do.NET Framework.  
  
   
  
## Examples  
 O exemplo a seguir cria um <xref:System.IO.FileStream> objeto para ler um esquema XML com e, em seguida, invoca o <xref:System.Data.DataSet.ReadXmlSchema%2A> método com o objeto.  
  
 [!code-csharp[Classic WebData DataSet.ReadXmlSchema1 Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.ReadXmlSchema1 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.ReadXmlSchema1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.ReadXmlSchema1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReadXmlSchema">
      <MemberSignature Language="C#" Value="public void ReadXmlSchema (System.IO.TextReader reader);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ReadXmlSchema(class System.IO.TextReader reader) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.ReadXmlSchema(System.IO.TextReader)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ReadXmlSchema (reader As TextReader)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ReadXmlSchema(System::IO::TextReader ^ reader);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.IO.TextReader" />
      </Parameters>
      <Docs>
        <param name="reader">O <see cref="T:System.IO.TextReader" /> do qual ler.</param>
        <summary>Lê o esquema XML do <see cref="T:System.IO.TextReader" /> especificado no <see cref="T:System.Data.DataSet" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use o método <xref:System.Data.DataSet.ReadXmlSchema%2A> para criar o esquema de um <xref:System.Data.DataSet>. O esquema inclui tabela, relação e definições de restrição. Para gravar um esquema em um documento XML, use o método <xref:System.Data.DataSet.WriteXmlSchema%2A>.  
  
 O esquema XML é gravado usando o padrão XSD.  
  
> [!NOTE]
>  A corrupção de dados poderá ocorrer se os tipos msdata:DataType e xs:type não coincidirem. Nenhuma exceção será gerada.  
  
 O método <xref:System.Data.DataSet.ReadXmlSchema%2A> é invocado geralmente antes de invocar o método <xref:System.Data.DataSet.ReadXml%2A> usado para preencher o <xref:System.Data.DataSet>.  
  
 Classes que herdam o <xref:System.IO.TextReader> classe inclui o <xref:System.IO.StreamReader> e <xref:System.IO.StringReader> classes.  
  
> [!NOTE]
>  Se o esquema para o <xref:System.Data.DataSet> contiver elementos do mesmo nome, mas de tipo diferente, no mesmo namespace, uma exceção será gerada quando você tentar ler o esquema no <xref:System.Data.DataSet> com <xref:System.Data.DataSet.ReadXmlSchema%2A>. Esta exceção não ocorrerá se você estiver usando a versão 1.0 do.NET Framework.  
  
   
  
## Examples  
 O exemplo a seguir cria um <xref:System.IO.StreamReader> para ler um esquema de objeto e invoca o <xref:System.Data.DataSet.ReadXmlSchema%2A> método com o objeto.  
  
 [!code-csharp[Classic WebData DataSet.ReadXmlSchema2 Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.ReadXmlSchema2 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.ReadXmlSchema2 Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.ReadXmlSchema2 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReadXmlSchema">
      <MemberSignature Language="C#" Value="public void ReadXmlSchema (string fileName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ReadXmlSchema(string fileName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.ReadXmlSchema(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ReadXmlSchema (fileName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ReadXmlSchema(System::String ^ fileName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="fileName">O nome de arquivo (incluindo o caminho) do qual será realizada a leitura.</param>
        <summary>Lê o esquema XML do arquivo especificado no <see cref="T:System.Data.DataSet" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use o método <xref:System.Data.DataSet.ReadXmlSchema%2A> para criar o esquema de um <xref:System.Data.DataSet>. O esquema inclui tabela, relação e definições de restrição. Para gravar um esquema em um documento XML, use o método <xref:System.Data.DataSet.WriteXmlSchema%2A>.  
  
 O esquema XML é gravado usando o padrão XSD.  
  
> [!NOTE]
>  A corrupção de dados poderá ocorrer se os tipos msdata:DataType e xs:type não coincidirem. Nenhuma exceção será gerada.  
  
 O método <xref:System.Data.DataSet.ReadXmlSchema%2A> é invocado geralmente antes de invocar o método <xref:System.Data.DataSet.ReadXml%2A> usado para preencher o <xref:System.Data.DataSet>.  
  
> [!NOTE]
>  Se o esquema para o <xref:System.Data.DataSet> contém elementos de mesmo nome, mas tipo diferente, no mesmo namespace, uma exceção é lançada ao tentar ler o esquema para o <xref:System.Data.DataSet> com <xref:System.Data.DataSet.ReadXmlSchema%2A>. Esta exceção não ocorrerá se você estiver usando a versão 1.0 do.NET Framework.  
  
   
  
## Examples  
 [!code-csharp[Classic WebData DataSet.ReadXmlSchema3 Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.ReadXmlSchema3 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.ReadXmlSchema3 Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.ReadXmlSchema3 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">
          <see cref="T:System.Security.Permissions.FileIOPermission" /> não é definido como <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">para ler e gravar arquivos. Enumeração associada: <see cref="T:System.Security.Permissions.FileIOPermissionAccess" /></permission>
      </Docs>
    </Member>
    <Member MemberName="ReadXmlSchema">
      <MemberSignature Language="C#" Value="public void ReadXmlSchema (System.Xml.XmlReader reader);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ReadXmlSchema(class System.Xml.XmlReader reader) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.ReadXmlSchema(System.Xml.XmlReader)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ReadXmlSchema (reader As XmlReader)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ReadXmlSchema(System::Xml::XmlReader ^ reader);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Xml.XmlReader" />
      </Parameters>
      <Docs>
        <param name="reader">O <see cref="T:System.Xml.XmlReader" /> do qual ler.</param>
        <summary>Lê o esquema XML do <see cref="T:System.Xml.XmlReader" /> especificado no <see cref="T:System.Data.DataSet" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use o método <xref:System.Data.DataSet.ReadXmlSchema%2A> para criar o esquema de um <xref:System.Data.DataSet>. O esquema inclui tabela, relação e definições de restrição.  
  
 O esquema XML é gravado usando o padrão XSD.  
  
> [!NOTE]
>  A corrupção de dados poderá ocorrer se os tipos msdata:DataType e xs:type não coincidirem. Nenhuma exceção será gerada.  
  
 O método <xref:System.Data.DataSet.ReadXmlSchema%2A> é invocado geralmente antes de invocar o método <xref:System.Data.DataSet.ReadXml%2A> usado para preencher o <xref:System.Data.DataSet>.  
  
 O <xref:System.Xml.XmlReader?displayProperty=nameWithType> classe é abstrata. Uma classe que herda de `XmlReader` é o <xref:System.Xml.XmlTextReader?displayProperty=nameWithType> classe.  
  
> [!NOTE]
>  Se o esquema para o <xref:System.Data.DataSet> contiver elementos do mesmo nome, mas de tipo diferente, no mesmo namespace, uma exceção será gerada quando você tentar ler o esquema no <xref:System.Data.DataSet> com <xref:System.Data.DataSet.ReadXmlSchema%2A>. Esta exceção não ocorrerá se você estiver usando a versão 1.0 do.NET Framework.  
  
   
  
## Examples  
 O exemplo a seguir cria um novo <xref:System.Data.DataSet> e <xref:System.IO.FileStream?displayProperty=nameWithType> objeto. O <xref:System.IO.FileStream> objeto criado com um caminho de arquivo e o nome do arquivo, é usado para criar um <xref:System.Xml.XmlTextReader?displayProperty=nameWithType> que é passado como um argumento para o <xref:System.Data.DataSet.ReadXmlSchema%2A> método.  
  
 [!code-csharp[Classic WebData DataSet.ReadXmlSchema Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.ReadXmlSchema Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.ReadXmlSchema Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.ReadXmlSchema Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReadXmlSerializable">
      <MemberSignature Language="C#" Value="protected virtual void ReadXmlSerializable (System.Xml.XmlReader reader);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void ReadXmlSerializable(class System.Xml.XmlReader reader) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.ReadXmlSerializable(System.Xml.XmlReader)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub ReadXmlSerializable (reader As XmlReader)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void ReadXmlSerializable(System::Xml::XmlReader ^ reader);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Xml.XmlReader" />
      </Parameters>
      <Docs>
        <param name="reader">O leitor XML especificado.</param>
        <summary>Ignora os atributos e retorna um DataSet vazio.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RejectChanges">
      <MemberSignature Language="C#" Value="public virtual void RejectChanges ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void RejectChanges() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.RejectChanges" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub RejectChanges ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void RejectChanges();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Reverte todas as alterações feitas ao <see cref="T:System.Data.DataSet" /> desde que foi criado ou desde a última vez em que o <see cref="M:System.Data.DataSet.AcceptChanges" /> foi chamado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Invocar o <xref:System.Data.DataSet.RejectChanges%2A?displayProperty=nameWithType> para chamar o <xref:System.Data.DataTable.RejectChanges%2A?displayProperty=nameWithType> método em todos os <xref:System.Data.DataTable> objetos contidos pelo <xref:System.Data.DataSet>.  
  
 <xref:System.Data.DataRow> objetos contidos pelo <xref:System.Data.DataSet> pode cada ser definida em modo de edição, chamando o <xref:System.Data.DataRow.BeginEdit%2A?displayProperty=nameWithType> método. Depois de invocar a <xref:System.Data.DataRow.EndEdit%2A?displayProperty=nameWithType> método, as alterações podem ser rejeitadas por chamar o <xref:System.Data.DataTable.RejectChanges%2A?displayProperty=nameWithType> no <xref:System.Data.DataTable> ao qual o <xref:System.Data.DataRow> objetos pertence.  
  
 Quando o <xref:System.Data.DataTable.RejectChanges%2A?displayProperty=nameWithType> método é chamado, quaisquer linhas ainda no modo de edição cancelar suas edições. Novas linhas são removidas. Retornará linhas excluídas e modificadas para seu estado original (`DataRowState.Unchanged`).  
  
 AcceptChanges e RejectChanges só se aplicam a <xref:System.Data.DataRow> alterações relacionadas (ou seja, `Add`, `Remove`, `Delete`, e `Modify`). Eles não são aplicáveis para o esquema ou alterações estruturais.  
  
   
  
## Examples  
 O exemplo a seguir mostra uma classe que deriva de <xref:System.Data.DataSet> classe. O <xref:System.Data.DataSet.RejectChanges%2A> evento é invocado a partir de uma função.  
  
 [!code-csharp[Classic WebData DataSet.RejectChanges Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.RejectChanges Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.RejectChanges Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.RejectChanges Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Relations">
      <MemberSignature Language="C#" Value="public System.Data.DataRelationCollection Relations { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Data.DataRelationCollection Relations" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataSet.Relations" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Relations As DataRelationCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Data::DataRelationCollection ^ Relations { System::Data::DataRelationCollection ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Data.DataRelationCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtenha a coleção de relações que vinculam tabelas e permitem a navegação de tabelas pai para tabelas filha.</summary>
        <value>Um <see cref="T:System.Data.DataRelationCollection" /> que contém uma coleção de objetos <see cref="T:System.Data.DataRelation" />. Será retornada uma coleção vazia se não houver nenhum objeto <see cref="T:System.Data.DataRelation" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O exemplo a seguir imprime o nome da coluna de todas as tabelas filho por meio de <xref:System.Data.DataSet.Relations%2A> propriedade.  
  
 [!code-vb[Classic WebData DataSet.Relations Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.Relations Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RemotingFormat">
      <MemberSignature Language="C#" Value="public System.Data.SerializationFormat RemotingFormat { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Data.SerializationFormat RemotingFormat" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataSet.RemotingFormat" />
      <MemberSignature Language="VB.NET" Value="Public Property RemotingFormat As SerializationFormat" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Data::SerializationFormat RemotingFormat { System::Data::SerializationFormat get(); void set(System::Data::SerializationFormat value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Data.SerializationFormat</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define um <see cref="T:System.Data.SerializationFormat" /> para o <see cref="T:System.Data.DataSet" /> usado durante a comunicação remota.</summary>
        <value>Um objeto <see cref="T:System.Data.SerializationFormat" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Reset">
      <MemberSignature Language="C#" Value="public virtual void Reset ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Reset() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.Reset" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Reset ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Reset();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Limpa todas as tabelas e remove todas as relações, restrições externas e tabelas de <see cref="T:System.Data.DataSet" />. As subclasses devem substituir <see cref="M:System.Data.DataSet.Reset" /> para restaurar um <see cref="T:System.Data.DataSet" /> ao seu estado original.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SchemaSerializationMode">
      <MemberSignature Language="C#" Value="public virtual System.Data.SchemaSerializationMode SchemaSerializationMode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Data.SchemaSerializationMode SchemaSerializationMode" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataSet.SchemaSerializationMode" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property SchemaSerializationMode As SchemaSerializationMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Data::SchemaSerializationMode SchemaSerializationMode { System::Data::SchemaSerializationMode get(); void set(System::Data::SchemaSerializationMode value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Data.SchemaSerializationMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define um <see cref="T:System.Data.SchemaSerializationMode" /> para um <see cref="T:System.Data.DataSet" />.</summary>
        <value>Obtém ou define um <see cref="T:System.Data.SchemaSerializationMode" /> para um <see cref="T:System.Data.DataSet" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Um <xref:System.Data.DataSet> serializa os dados de instância e esquema por padrão em cenários de comunicação remota e serviços da Web. Definindo o <xref:System.Data.DataSet.SchemaSerializationMode%2A> propriedade de um tipo `DataSet` para <xref:System.Data.SchemaSerializationMode.ExcludeSchema> faz com que as informações de esquema a ser excluído da carga de serialização.  
  
 <xref:System.Data.SchemaSerializationMode.ExcludeSchema> há suporte apenas para um tipo `DataSet`. Para não digitada `DataSet` essa propriedade só pode ser definida como <xref:System.Data.SchemaSerializationMode.IncludeSchema>.  
  
 <xref:System.Data.SchemaSerializationMode.ExcludeSchema> só deve ser usado em casos onde as informações de esquema de subjacente digitadas `DataTables`, `DataRelations` e `Constraints` não foi modificado. Se tiveram de modificações de informações de esquema ocorreu e completa devem ser serializadas com <xref:System.Data.SchemaSerializationMode.IncludeSchema>.  
  
 <xref:System.Data.SchemaSerializationMode.ExcludeSchema> há suporte na versão 2.0 do .NET Framework ou posterior.  
  
 Quando <xref:System.Data.SchemaSerializationMode.ExcludeSchema> for definida, somente as propriedades de tempo de execução de nível superior presentes no <xref:System.Data.DataSet> são serializados. Além disso, eles são serializados somente se estejam diferentes dos valores padrão. Nenhum do `Tables`, `Relations` ou `Constraints` são serializados. As propriedades de tempo de execução serializado incluem <xref:System.Data.DataSet.DataSetName%2A>, <xref:System.Data.DataSet.Namespace%2A>, <xref:System.Data.DataSet.Prefix%2A>, <xref:System.Data.DataSet.Locale%2A>, <xref:System.Data.DataSet.EnforceConstraints%2A>, e <xref:System.Data.DataSet.CaseSensitive%2A>. Essas propriedades são serializadas para certificar-se de que a integridade dos dados de tempo de execução geral é preservada.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ShouldSerializeRelations">
      <MemberSignature Language="C#" Value="protected virtual bool ShouldSerializeRelations ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool ShouldSerializeRelations() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.ShouldSerializeRelations" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function ShouldSerializeRelations () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool ShouldSerializeRelations();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Obtém um valor que indica se a propriedade <see cref="P:System.Data.DataSet.Relations" /> deve ser persistida.</summary>
        <returns>
          <see langword="true" /> se o valor da propriedade tiver sido alterado do padrão, caso contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Você normalmente usa esse método se você estiver criando ou um designer para o <xref:System.Data.DataSet>, ou criar seu próprio controle incorporando o <xref:System.Data.DataSet>.  
  
   
  
## Examples  
 Os exemplos a seguir mostram uma classe que deriva de <xref:System.Data.DataSet> classe. O <xref:System.Data.DataSet.Reset%2A> e <xref:System.Data.DataSet.ShouldSerializeRelations%2A> métodos são chamados de dentro de funções na classe derivada.  
  
 [!code-csharp[Classic WebData DataSet.ShouldSerializeRelations Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.ShouldSerializeRelations Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.ShouldSerializeRelations Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.ShouldSerializeRelations Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ShouldSerializeTables">
      <MemberSignature Language="C#" Value="protected virtual bool ShouldSerializeTables ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool ShouldSerializeTables() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.ShouldSerializeTables" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function ShouldSerializeTables () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool ShouldSerializeTables();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Obtém um valor que indica se a propriedade <see cref="P:System.Data.DataSet.Tables" /> deve ser persistida.</summary>
        <returns>
          <see langword="true" /> se o valor da propriedade tiver sido alterado do padrão, caso contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Você normalmente usa esse método somente se você estiver criando ou um designer para o <xref:System.Data.DataSet>, ou criar seu próprio controle incorporando o <xref:System.Data.DataSet>.  
  
   
  
## Examples  
 O exemplo a seguir mostra uma classe que deriva de <xref:System.Data.DataSet> classe. O <xref:System.Data.DataSet.ShouldSerializeTables%2A> método é chamado de dentro de funções na classe derivada.  
  
 [!code-csharp[Classic WebData DataSet.ShouldSerializeTables Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.ShouldSerializeTables Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.ShouldSerializeTables Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.ShouldSerializeTables Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Site">
      <MemberSignature Language="C#" Value="public override System.ComponentModel.ISite Site { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ComponentModel.ISite Site" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataSet.Site" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property Site As ISite" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::ComponentModel::ISite ^ Site { System::ComponentModel::ISite ^ get(); void set(System::ComponentModel::ISite ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ComponentModel.ISite</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define um <see cref="T:System.ComponentModel.ISite" /> para o <see cref="T:System.Data.DataSet" />.</summary>
        <value>Um <see cref="T:System.ComponentModel.ISite" /> para o <see cref="T:System.Data.DataSet" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sites de associar um <xref:System.ComponentModel.Component> para um <xref:System.ComponentModel.Container> e habilitar a comunicação entre eles, bem como fornecer uma maneira para o contêiner gerenciar seus componentes.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.ComponentModel.IListSource.ContainsListCollection">
      <MemberSignature Language="C#" Value="bool System.ComponentModel.IListSource.ContainsListCollection { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.ComponentModel.IListSource.ContainsListCollection" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataSet.System#ComponentModel#IListSource#ContainsListCollection" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property ContainsListCollection As Boolean Implements IListSource.ContainsListCollection" />
      <MemberSignature Language="C++ CLI" Value="property bool System.ComponentModel.IListSource.ContainsListCollection { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Para obter uma descrição desse membro, consulte <see cref="P:System.ComponentModel.IListSource.ContainsListCollection" />.</summary>
        <value>Para obter uma descrição desse membro, consulte <see cref="P:System.ComponentModel.IListSource.ContainsListCollection" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este membro é uma implementação do membro de interface explícita. Ele só pode ser usado quando a instância de <xref:System.Data.DataSet> é convertida em uma interface de <xref:System.ComponentModel.IListSource>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.ComponentModel.IListSource.GetList">
      <MemberSignature Language="C#" Value="System.Collections.IList IListSource.GetList ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.IList System.ComponentModel.IListSource.GetList() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.System#ComponentModel#IListSource#GetList" />
      <MemberSignature Language="VB.NET" Value="Function GetList () As IList Implements IListSource.GetList" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::IList ^ System.ComponentModel.IListSource.GetList() = System::ComponentModel::IListSource::GetList;" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IList</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Para obter uma descrição desse membro, consulte <see cref="M:System.ComponentModel.IListSource.GetList" />.</summary>
        <returns>Para obter uma descrição desse membro, consulte <see cref="M:System.ComponentModel.IListSource.GetList" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este membro é uma implementação do membro de interface explícita. Ele só pode ser usado quando a instância de <xref:System.Data.DataSet> é convertida em uma interface de <xref:System.ComponentModel.IListSource>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Xml.Serialization.IXmlSerializable.GetSchema">
      <MemberSignature Language="C#" Value="System.Xml.Schema.XmlSchema IXmlSerializable.GetSchema ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Xml.Schema.XmlSchema System.Xml.Serialization.IXmlSerializable.GetSchema() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.System#Xml#Serialization#IXmlSerializable#GetSchema" />
      <MemberSignature Language="VB.NET" Value="Function GetSchema () As XmlSchema Implements IXmlSerializable.GetSchema" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Xml::Schema::XmlSchema ^ System.Xml.Serialization.IXmlSerializable.GetSchema() = System::Xml::Serialization::IXmlSerializable::GetSchema;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Xml.Serialization.IXmlSerializable.GetSchema</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.Schema.XmlSchema</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Para obter uma descrição desse membro, consulte <see cref="M:System.Xml.Serialization.IXmlSerializable.GetSchema" />.</summary>
        <returns>Para obter uma descrição desse membro, consulte <see cref="M:System.Xml.Serialization.IXmlSerializable.GetSchema" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este membro é uma implementação do membro de interface explícita. Ele só pode ser usado quando a instância de <xref:System.Data.DataSet> é convertida em uma interface de <xref:System.Xml.Serialization.IXmlSerializable>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Xml.Serialization.IXmlSerializable.ReadXml">
      <MemberSignature Language="C#" Value="void IXmlSerializable.ReadXml (System.Xml.XmlReader reader);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Xml.Serialization.IXmlSerializable.ReadXml(class System.Xml.XmlReader reader) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.System#Xml#Serialization#IXmlSerializable#ReadXml(System.Xml.XmlReader)" />
      <MemberSignature Language="VB.NET" Value="Sub ReadXml (reader As XmlReader) Implements IXmlSerializable.ReadXml" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Xml.Serialization.IXmlSerializable.ReadXml(System::Xml::XmlReader ^ reader) = System::Xml::Serialization::IXmlSerializable::ReadXml;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Xml.Serialization.IXmlSerializable.ReadXml(System.Xml.XmlReader)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Xml.XmlReader" />
      </Parameters>
      <Docs>
        <param name="reader">Um <see cref="T:System.Xml.XmlReader" />.</param>
        <summary>Para obter uma descrição desse membro, consulte <see cref="M:System.Xml.Serialization.IXmlSerializable.ReadXml(System.Xml.XmlReader)" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este membro é uma implementação do membro de interface explícita. Ele só pode ser usado quando a instância de <xref:System.Data.DataSet> é convertida em uma interface de <xref:System.Xml.Serialization.IXmlSerializable>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Xml.Serialization.IXmlSerializable.WriteXml">
      <MemberSignature Language="C#" Value="void IXmlSerializable.WriteXml (System.Xml.XmlWriter writer);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Xml.Serialization.IXmlSerializable.WriteXml(class System.Xml.XmlWriter writer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.System#Xml#Serialization#IXmlSerializable#WriteXml(System.Xml.XmlWriter)" />
      <MemberSignature Language="VB.NET" Value="Sub WriteXml (writer As XmlWriter) Implements IXmlSerializable.WriteXml" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Xml.Serialization.IXmlSerializable.WriteXml(System::Xml::XmlWriter ^ writer) = System::Xml::Serialization::IXmlSerializable::WriteXml;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Xml.Serialization.IXmlSerializable.WriteXml(System.Xml.XmlWriter)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Xml.XmlWriter" />
      </Parameters>
      <Docs>
        <param name="writer">Um <see cref="T:System.Xml.XmlWriter" />.</param>
        <summary>Para obter uma descrição desse membro, consulte <see cref="M:System.Xml.Serialization.IXmlSerializable.WriteXml(System.Xml.XmlWriter)" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este membro é uma implementação do membro de interface explícita. Ele só pode ser usado quando a instância de <xref:System.Data.DataSet> é convertida em uma interface de <xref:System.Xml.Serialization.IXmlSerializable>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Tables">
      <MemberSignature Language="C#" Value="public System.Data.DataTableCollection Tables { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Data.DataTableCollection Tables" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataSet.Tables" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Tables As DataTableCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Data::DataTableCollection ^ Tables { System::Data::DataTableCollection ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Data.DataTableCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém a coleção de tabelas contidas no <see cref="T:System.Data.DataSet" />.</summary>
        <value>O <see cref="T:System.Data.DataTableCollection" /> contido por este <see cref="T:System.Data.DataSet" />. Será retornada uma coleção vazia se não houver nenhum objeto <see cref="T:System.Data.DataTable" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para adicionar tabelas à coleção, use <xref:System.Data.DataTableCollection.Add%2A> método o <xref:System.Data.DataTableCollection>. Para remover tabelas, use o <xref:System.Data.DataTableCollection.Remove%2A> método.  
  
   
  
## Examples  
 O exemplo a seguir retorna o <xref:System.Data.DataSet> do objeto <xref:System.Data.DataTableCollection>e imprime as colunas e linhas em cada tabela.  
  
 [!code-csharp[Classic WebData DataSet.Tables Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.Tables Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.Tables Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.Tables Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="WriteXml">
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Grava os dados XML e opcionalmente o esquema, do <see cref="T:System.Data.DataSet" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WriteXml">
      <MemberSignature Language="C#" Value="public void WriteXml (System.IO.Stream stream);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXml(class System.IO.Stream stream) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.WriteXml(System.IO.Stream)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXml(System::IO::Stream ^ stream);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
      </Parameters>
      <Docs>
        <param name="stream">Um objeto <see cref="T:System.IO.Stream" /> usado para gravar em um arquivo.</param>
        <summary>Grava os dados atuais para o <see cref="T:System.Data.DataSet" /> usando o <see cref="T:System.IO.Stream" /> especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O método `WriteXml` fornece uma maneira de gravar apenas dados ou dados e esquema em um <xref:System.Data.DataSet> a partir de um documento XML, e o método <xref:System.Data.DataSet.WriteXmlSchema%2A> grava apenas o esquema. Para gravar dados e esquema, use uma das sobrecargas que inclua o parâmetro `mode` e defina o valor como `WriteSchema`.  
  
 Observe que o mesmo é verdadeiro para os métodos <xref:System.Data.DataSet.ReadXml%2A> e <xref:System.Data.DataSet.ReadXmlSchema%2A>, respectivamente. Para ler dados XML, ou o esquema e os dados no `DataSet`, use o método `ReadXml`. Para ler apenas o esquema, use o método `ReadXmlSchema`.  
  
> [!NOTE]
>  Um <xref:System.InvalidOperationException> será lançado se um tipo de coluna no `DataRow` de leitura ou gravação implementa <xref:System.Dynamic.IDynamicMetaObjectProvider> e não implementa <xref:System.Xml.Serialization.IXmlSerializable>.  
  
   
  
## Examples  
 O exemplo a seguir cria um <xref:System.IO.FileStream?displayProperty=nameWithType> objeto. O objeto é usado com o <xref:System.Data.DataSet.WriteXml%2A> método para escrever um documento XML.  
  
 [!code-csharp[Classic WebData DataSet.WriteXml Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.WriteXml Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.WriteXml Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.WriteXml Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteXml">
      <MemberSignature Language="C#" Value="public void WriteXml (System.IO.TextWriter writer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXml(class System.IO.TextWriter writer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.WriteXml(System.IO.TextWriter)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteXml (writer As TextWriter)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXml(System::IO::TextWriter ^ writer);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.IO.TextWriter" />
      </Parameters>
      <Docs>
        <param name="writer">O objeto <see cref="T:System.IO.TextWriter" /> com o qual gravar.</param>
        <summary>Grava os dados atuais para o <see cref="T:System.Data.DataSet" /> usando o <see cref="T:System.IO.TextWriter" /> especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O método `WriteXml` fornece uma maneira de gravar apenas dados ou dados e esquema em um <xref:System.Data.DataSet> a partir de um documento XML, e o método <xref:System.Data.DataSet.WriteXmlSchema%2A> grava apenas o esquema. Para gravar dados e esquema, use uma das sobrecargas que inclua o parâmetro `mode` e defina o valor como `WriteSchema`.  
  
 Observe que o mesmo é verdadeiro para os métodos <xref:System.Data.DataSet.ReadXml%2A> e <xref:System.Data.DataSet.ReadXmlSchema%2A>, respectivamente. Para ler dados XML, ou o esquema e os dados no `DataSet`, use o método `ReadXml`. Para ler apenas o esquema, use o método `ReadXmlSchema`.  
  
> [!NOTE]
>  Um <xref:System.InvalidOperationException> será lançado se um tipo de coluna no `DataRow` de leitura ou gravação implementa <xref:System.Dynamic.IDynamicMetaObjectProvider> e não implementa <xref:System.Xml.Serialization.IXmlSerializable>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteXml">
      <MemberSignature Language="C#" Value="public void WriteXml (string fileName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXml(string fileName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.WriteXml(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteXml (fileName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXml(System::String ^ fileName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="fileName">O nome do arquivo (incluindo o caminho) no qual gravar.</param>
        <summary>Grava os dados atuais do <see cref="T:System.Data.DataSet" /> no arquivo especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O método `WriteXml` fornece uma maneira de gravar apenas dados ou dados e esquema em um <xref:System.Data.DataSet> a partir de um documento XML, e o método <xref:System.Data.DataSet.WriteXmlSchema%2A> grava apenas o esquema. Para gravar dados e esquema, use uma das sobrecargas que inclua o parâmetro `mode` e defina o valor como `WriteSchema`.  
  
 Observe que o mesmo é verdadeiro para os métodos <xref:System.Data.DataSet.ReadXml%2A> e <xref:System.Data.DataSet.ReadXmlSchema%2A>, respectivamente. Para ler dados XML, ou o esquema e os dados no `DataSet`, use o método `ReadXml`. Para ler apenas o esquema, use o método `ReadXmlSchema`.  
  
> [!NOTE]
>  Um <xref:System.InvalidOperationException> será lançado se um tipo de coluna no `DataRow` de leitura ou gravação implementa <xref:System.Dynamic.IDynamicMetaObjectProvider> e não implementa <xref:System.Xml.Serialization.IXmlSerializable>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">
          <see cref="T:System.Security.Permissions.FileIOPermission" /> não é definido como <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" />.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">para ler e gravar arquivos. Enumeração associada: <see cref="T:System.Security.Permissions.FileIOPermissionAccess" /></permission>
      </Docs>
    </Member>
    <Member MemberName="WriteXml">
      <MemberSignature Language="C#" Value="public void WriteXml (System.Xml.XmlWriter writer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXml(class System.Xml.XmlWriter writer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.WriteXml(System.Xml.XmlWriter)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteXml (writer As XmlWriter)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXml(System::Xml::XmlWriter ^ writer);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Xml.Serialization.IXmlSerializable.WriteXml(System.Xml.XmlWriter)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Xml.XmlWriter" />
      </Parameters>
      <Docs>
        <param name="writer">O <see cref="T:System.Xml.XmlWriter" /> com o qual gravar.</param>
        <summary>Grava os dados atuais do <see cref="T:System.Data.DataSet" /> no <see cref="T:System.Xml.XmlWriter" /> especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O método `WriteXml` fornece uma maneira de gravar apenas dados ou dados e esquema em um <xref:System.Data.DataSet> a partir de um documento XML, e o método <xref:System.Data.DataSet.WriteXmlSchema%2A> grava apenas o esquema. Para gravar dados e esquema, use uma das sobrecargas que inclua o parâmetro `mode` e defina o valor como `WriteSchema`.  
  
 Observe que o mesmo é verdadeiro para os métodos <xref:System.Data.DataSet.ReadXml%2A> e <xref:System.Data.DataSet.ReadXmlSchema%2A>, respectivamente. Para ler dados XML, ou o esquema e os dados no `DataSet`, use o método `ReadXml`. Para ler apenas o esquema, use o método `ReadXmlSchema`.  
  
> [!NOTE]
>  Um <xref:System.InvalidOperationException> será lançado se um tipo de coluna no `DataRow` de leitura ou gravação implementa <xref:System.Dynamic.IDynamicMetaObjectProvider> e não implementa <xref:System.Xml.Serialization.IXmlSerializable>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteXml">
      <MemberSignature Language="C#" Value="public void WriteXml (System.IO.Stream stream, System.Data.XmlWriteMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXml(class System.IO.Stream stream, valuetype System.Data.XmlWriteMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.WriteXml(System.IO.Stream,System.Data.XmlWriteMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXml(System::IO::Stream ^ stream, System::Data::XmlWriteMode mode);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
        <Parameter Name="mode" Type="System.Data.XmlWriteMode" />
      </Parameters>
      <Docs>
        <param name="stream">Um objeto <see cref="T:System.IO.Stream" /> usado para gravar em um arquivo.</param>
        <param name="mode">Um dos valores de <see cref="T:System.Data.XmlWriteMode" />.</param>
        <summary>Grava os dados atuais e, opcionalmente, o esquema do <see cref="T:System.Data.DataSet" /> usando o <see cref="T:System.IO.Stream" /> e o <see cref="T:System.Data.XmlWriteMode" /> especificados. Para gravar o esquema, defina o valor do parâmetro <paramref name="mode" /> como <see langword="WriteSchema" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O método `WriteXml` fornece uma maneira de gravar apenas dados ou dados e esquema em um <xref:System.Data.DataSet> a partir de um documento XML, e o método <xref:System.Data.DataSet.WriteXmlSchema%2A> grava apenas o esquema. Para gravar dados e esquema, defina o parâmetro `mode` como `WriteSchema`.  
  
 Observe que o mesmo é verdadeiro para os métodos <xref:System.Data.DataSet.ReadXml%2A> e <xref:System.Data.DataSet.ReadXmlSchema%2A>, respectivamente. Para ler dados XML, ou o esquema e os dados no `DataSet`, use o método `ReadXml`. Para ler apenas o esquema, use o método `ReadXmlSchema`.  
  
> [!NOTE]
>  Um <xref:System.InvalidOperationException> será lançado se um tipo de coluna no `DataRow` de leitura ou gravação implementa <xref:System.Dynamic.IDynamicMetaObjectProvider> e não implementa <xref:System.Xml.Serialization.IXmlSerializable>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteXml">
      <MemberSignature Language="C#" Value="public void WriteXml (System.IO.TextWriter writer, System.Data.XmlWriteMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXml(class System.IO.TextWriter writer, valuetype System.Data.XmlWriteMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.WriteXml(System.IO.TextWriter,System.Data.XmlWriteMode)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteXml (writer As TextWriter, mode As XmlWriteMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXml(System::IO::TextWriter ^ writer, System::Data::XmlWriteMode mode);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.IO.TextWriter" />
        <Parameter Name="mode" Type="System.Data.XmlWriteMode" />
      </Parameters>
      <Docs>
        <param name="writer">Um objeto <see cref="T:System.IO.TextWriter" /> usado para gravar o documento.</param>
        <param name="mode">Um dos valores de <see cref="T:System.Data.XmlWriteMode" />.</param>
        <summary>Grava os dados atuais e, opcionalmente, o esquema do <see cref="T:System.Data.DataSet" /> usando o <see cref="T:System.IO.TextWriter" /> e o <see cref="T:System.Data.XmlWriteMode" /> especificados. Para gravar o esquema, defina o valor do parâmetro <paramref name="mode" /> como <see langword="WriteSchema" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O método `WriteXml` fornece uma maneira de gravar apenas dados ou dados e esquema em um <xref:System.Data.DataSet> a partir de um documento XML, e o método <xref:System.Data.DataSet.WriteXmlSchema%2A> grava apenas o esquema. Para gravar dados e esquema, defina o parâmetro `mode` como `WriteSchema`.  
  
 Observe que o mesmo é verdadeiro para os métodos <xref:System.Data.DataSet.ReadXml%2A> e <xref:System.Data.DataSet.ReadXmlSchema%2A>, respectivamente. Para ler dados XML, ou o esquema e os dados no `DataSet`, use o método `ReadXml`. Para ler apenas o esquema, use o método `ReadXmlSchema`.  
  
> [!NOTE]
>  Um <xref:System.InvalidOperationException> será lançado se um tipo de coluna no `DataRow` de leitura ou gravação implementa <xref:System.Dynamic.IDynamicMetaObjectProvider> e não implementa <xref:System.Xml.Serialization.IXmlSerializable>.  
  
   
  
## Examples  
 O exemplo a seguir primeiramente cria um <xref:System.Data.DataSet> simples com um <xref:System.Data.DataTable>, duas colunas e dez linhas. O esquema <xref:System.Data.DataSet> e os dados são gravados em disco invocando o método <xref:System.Data.DataSet.WriteXml%2A>. Um segundo <xref:System.Data.DataSet> é criado e o método <xref:System.Data.DataSet.ReadXml%2A> é usado para preenchê-lo com esquema e dados.  
  
 [!code-csharp[Classic WebData DataSet.ReadXml2 Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.ReadXml2 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.ReadXml2 Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.ReadXml2 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteXml">
      <MemberSignature Language="C#" Value="public void WriteXml (string fileName, System.Data.XmlWriteMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXml(string fileName, valuetype System.Data.XmlWriteMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.WriteXml(System.String,System.Data.XmlWriteMode)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteXml (fileName As String, mode As XmlWriteMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXml(System::String ^ fileName, System::Data::XmlWriteMode mode);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
        <Parameter Name="mode" Type="System.Data.XmlWriteMode" />
      </Parameters>
      <Docs>
        <param name="fileName">O nome do arquivo (incluindo o caminho) no qual gravar.</param>
        <param name="mode">Um dos valores de <see cref="T:System.Data.XmlWriteMode" />.</param>
        <summary>Grava os dados atuais e, opcionalmente, o esquema do <see cref="T:System.Data.DataSet" /> no arquivo especificado usando o <see cref="T:System.Data.XmlWriteMode" /> especificado. Para gravar o esquema, defina o valor do parâmetro <paramref name="mode" /> como <see langword="WriteSchema" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O método `WriteXml` fornece uma maneira de gravar apenas dados ou dados e esquema em um <xref:System.Data.DataSet> a partir de um documento XML, e o método <xref:System.Data.DataSet.WriteXmlSchema%2A> grava apenas o esquema. Para gravar dados e esquema, defina o parâmetro `mode` como `WriteSchema`.  
  
 Observe que o mesmo é verdadeiro para os métodos <xref:System.Data.DataSet.ReadXml%2A> e <xref:System.Data.DataSet.ReadXmlSchema%2A>, respectivamente. Para ler dados XML, ou o esquema e os dados no `DataSet`, use o método `ReadXml`. Para ler apenas o esquema, use o método `ReadXmlSchema`.  
  
> [!NOTE]
>  Um <xref:System.InvalidOperationException> será lançado se um tipo de coluna no `DataRow` de leitura ou gravação implementa <xref:System.Dynamic.IDynamicMetaObjectProvider> e não implementa <xref:System.Xml.Serialization.IXmlSerializable>.  
  
   
  
## Examples  
 O exemplo a seguir usa o <xref:System.Data.DataSet.WriteXml%2A> método para escrever um documento XML.  
  
 [!code-csharp[Classic WebData DataSet.WriteXml7 Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.WriteXml7 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.WriteXml7 Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.WriteXml7 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">
          <see cref="T:System.Security.Permissions.FileIOPermission" /> não é definido como <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" />.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">para ler e gravar arquivos. Enumeração associada: <see cref="T:System.Security.Permissions.FileIOPermissionAccess" /></permission>
      </Docs>
    </Member>
    <Member MemberName="WriteXml">
      <MemberSignature Language="C#" Value="public void WriteXml (System.Xml.XmlWriter writer, System.Data.XmlWriteMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXml(class System.Xml.XmlWriter writer, valuetype System.Data.XmlWriteMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.WriteXml(System.Xml.XmlWriter,System.Data.XmlWriteMode)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteXml (writer As XmlWriter, mode As XmlWriteMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXml(System::Xml::XmlWriter ^ writer, System::Data::XmlWriteMode mode);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Xml.XmlWriter" />
        <Parameter Name="mode" Type="System.Data.XmlWriteMode" />
      </Parameters>
      <Docs>
        <param name="writer">O <see cref="T:System.Xml.XmlWriter" /> com o qual gravar.</param>
        <param name="mode">Um dos valores de <see cref="T:System.Data.XmlWriteMode" />.</param>
        <summary>Grava os dados atuais e, opcionalmente, o esquema do <see cref="T:System.Data.DataSet" /> usando o <see cref="T:System.Xml.XmlWriter" /> e o <see cref="T:System.Data.XmlWriteMode" /> especificados. Para gravar o esquema, defina o valor do parâmetro <paramref name="mode" /> como <see langword="WriteSchema" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O método `WriteXml` fornece uma maneira de gravar apenas dados ou dados e esquema em um <xref:System.Data.DataSet> a partir de um documento XML, e o método <xref:System.Data.DataSet.WriteXmlSchema%2A> grava apenas o esquema. Para gravar dados e esquema, defina o parâmetro `mode` como `WriteSchema`.  
  
 Observe que o mesmo é verdadeiro para os métodos <xref:System.Data.DataSet.ReadXml%2A> e <xref:System.Data.DataSet.ReadXmlSchema%2A>, respectivamente. Para ler dados XML, ou o esquema e os dados no `DataSet`, use o método `ReadXml`. Para ler apenas o esquema, use o método `ReadXmlSchema`.  
  
> [!NOTE]
>  Um <xref:System.InvalidOperationException> será lançado se um tipo de coluna no `DataRow` de leitura ou gravação implementa <xref:System.Dynamic.IDynamicMetaObjectProvider> e não implementa <xref:System.Xml.Serialization.IXmlSerializable>.  
  
   
  
## Examples  
 O exemplo a seguir cria um <xref:System.IO.FileStream?displayProperty=nameWithType> que é usado para criar um novo objeto <xref:System.Xml.XmlTextWriter>. O <xref:System.Xml.XmlTextWriter> objeto é usado com o <xref:System.Data.DataSet.WriteXml%2A> método para escrever um documento XML.  
  
 [!code-csharp[Classic WebData DataSet.WriteXml6 Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.WriteXml6 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.WriteXml6 Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.WriteXml6 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="WriteXmlSchema">
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Grava a estrutura <see cref="T:System.Data.DataSet" /> como um esquema XML.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WriteXmlSchema">
      <MemberSignature Language="C#" Value="public void WriteXmlSchema (System.IO.Stream stream);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXmlSchema(class System.IO.Stream stream) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.WriteXmlSchema(System.IO.Stream)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXmlSchema(System::IO::Stream ^ stream);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
      </Parameters>
      <Docs>
        <param name="stream">Um objeto <see cref="T:System.IO.Stream" /> usado para gravar em um arquivo.</param>
        <summary>Grava a estrutura <see cref="T:System.Data.DataSet" /> como um esquema XML no objeto <see cref="T:System.IO.Stream" /> especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use o método <xref:System.Data.DataSet.WriteXmlSchema%2A> para gravar o esquema de um <xref:System.Data.DataSet> em um documento XML. O esquema inclui tabela, relação e definições de restrição. Para gravar um esquema em um documento XML, use o método <xref:System.Data.DataSet.WriteXmlSchema%2A>.  
  
 O esquema XML é gravado usando o padrão XSD.  
  
 Para gravar os dados em um documento XML, use o método <xref:System.Data.DataSet.WriteXml%2A>.  
  
 Classes que derivam de <xref:System.IO.Stream> classe incluir <xref:System.IO.BufferedStream>, <xref:System.IO.FileStream>, <xref:System.IO.MemoryStream>, e <xref:System.Net.Sockets.NetworkStream>.  
  
   
  
## Examples  
 O exemplo a seguir cria um novo <xref:System.IO.FileStream> objeto que é passado para o <xref:System.Data.DataSet.WriteXmlSchema%2A> método para gravar o esquema no disco.  
  
 [!code-csharp[Classic WebData DataSet.WriteXmlSchema Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.WriteXmlSchema Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.WriteXmlSchema Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.WriteXmlSchema Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteXmlSchema">
      <MemberSignature Language="C#" Value="public void WriteXmlSchema (System.IO.TextWriter writer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXmlSchema(class System.IO.TextWriter writer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.WriteXmlSchema(System.IO.TextWriter)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteXmlSchema (writer As TextWriter)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXmlSchema(System::IO::TextWriter ^ writer);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.IO.TextWriter" />
      </Parameters>
      <Docs>
        <param name="writer">O objeto <see cref="T:System.IO.TextWriter" /> com o qual gravar.</param>
        <summary>Grava a estrutura <see cref="T:System.Data.DataSet" /> como um esquema XML no objeto <see cref="T:System.IO.TextWriter" /> especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use o método <xref:System.Data.DataSet.WriteXmlSchema%2A> para gravar o esquema de um <xref:System.Data.DataSet> em um documento XML. O esquema inclui tabela, relação e definições de restrição. Para gravar um esquema em um documento XML, use o método <xref:System.Data.DataSet.WriteXmlSchema%2A>.  
  
 O esquema XML é gravado usando o padrão XSD.  
  
 Para gravar os dados em um documento XML, use o método <xref:System.Data.DataSet.WriteXml%2A>.  
  
 Classes de derivar do <xref:System.IO.TextWriter?displayProperty=nameWithType> classe inclui o <xref:System.Web.HttpWriter?displayProperty=nameWithType>, <xref:System.CodeDom.Compiler.IndentedTextWriter?displayProperty=nameWithType>, <xref:System.Web.UI.HtmlTextWriter?displayProperty=nameWithType>, <xref:System.IO.StreamWriter?displayProperty=nameWithType>, e <xref:System.IO.StringWriter?displayProperty=nameWithType>.  
  
   
  
## Examples  
 O exemplo a seguir cria um <xref:System.Text.StringBuilder?displayProperty=nameWithType> objeto que é usado para criar um novo <xref:System.IO.StringWriter?displayProperty=nameWithType>. O <xref:System.IO.StringWriter> é passado para o <xref:System.Data.DataSet.WriteXmlSchema%2A> método e a cadeia de caracteres resultante é impressa para a janela do console.  
  
 [!code-csharp[Classic WebData DataSet.WriteXmlSchema1 Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.WriteXmlSchema1 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.WriteXmlSchema1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.WriteXmlSchema1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteXmlSchema">
      <MemberSignature Language="C#" Value="public void WriteXmlSchema (string fileName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXmlSchema(string fileName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.WriteXmlSchema(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteXmlSchema (fileName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXmlSchema(System::String ^ fileName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="fileName">O nome do arquivo (incluindo o caminho) no qual gravar.</param>
        <summary>Grava a estrutura <see cref="T:System.Data.DataSet" /> como um esquema XML em um arquivo.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use o método <xref:System.Data.DataSet.WriteXmlSchema%2A> para gravar o esquema de um <xref:System.Data.DataSet> em um documento XML. O esquema inclui tabela, relação e definições de restrição. Para gravar um esquema em um documento XML, use o método <xref:System.Data.DataSet.WriteXmlSchema%2A>.  
  
 O esquema XML é gravado usando o padrão XSD.  
  
 Para gravar os dados em um documento XML, use o método <xref:System.Data.DataSet.WriteXml%2A>.  
  
   
  
## Examples  
 [!code-csharp[Classic WebData DataSet.WriteXmlSchema3 Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.WriteXmlSchema3 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.WriteXmlSchema3 Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.WriteXmlSchema3 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">
          <see cref="T:System.Security.Permissions.FileIOPermission" /> não é definido como <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" />.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">para ler e gravar arquivos. Enumeração associada: <see cref="T:System.Security.Permissions.FileIOPermissionAccess" /></permission>
      </Docs>
    </Member>
    <Member MemberName="WriteXmlSchema">
      <MemberSignature Language="C#" Value="public void WriteXmlSchema (System.Xml.XmlWriter writer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXmlSchema(class System.Xml.XmlWriter writer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.WriteXmlSchema(System.Xml.XmlWriter)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteXmlSchema (writer As XmlWriter)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXmlSchema(System::Xml::XmlWriter ^ writer);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Xml.XmlWriter" />
      </Parameters>
      <Docs>
        <param name="writer">O <see cref="T:System.Xml.XmlWriter" /> no qual ocorrerá a gravação.</param>
        <summary>Grava a estrutura <see cref="T:System.Data.DataSet" /> como um esquema XML em um objeto <see cref="T:System.Xml.XmlWriter" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use o método <xref:System.Data.DataSet.WriteXmlSchema%2A> para gravar o esquema de um <xref:System.Data.DataSet> em um documento XML. O esquema inclui tabela, relação e definições de restrição. Para gravar um esquema em um documento XML, use o método <xref:System.Data.DataSet.WriteXmlSchema%2A>.  
  
 O esquema XML é gravado usando o padrão XSD.  
  
 Para gravar os dados em um documento XML, use o método <xref:System.Data.DataSet.WriteXml%2A>.  
  
 Uma classe que herda de <xref:System.Xml.XmlWriter?displayProperty=nameWithType> classe é o <xref:System.Xml.XmlTextWriter> classe.  
  
   
  
## Examples  
 O exemplo a seguir cria um novo <xref:System.IO.FileStream?displayProperty=nameWithType> objeto com o caminho especificado. O <xref:System.IO.FileStream> objeto é usado para criar um <xref:System.Xml.XmlTextWriter> objeto. O <xref:System.Data.DataSet.WriteXmlSchema%2A> método é invocado, em seguida, com o <xref:System.Xml.XmlTextWriter> objeto para o esquema de gravação no disco.  
  
 [!code-csharp[Classic WebData DataSet.WriteXmlSchema2 Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.WriteXmlSchema2 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.WriteXmlSchema2 Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.WriteXmlSchema2 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteXmlSchema">
      <MemberSignature Language="C#" Value="public void WriteXmlSchema (System.IO.Stream stream, Converter&lt;Type,string&gt; multipleTargetConverter);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXmlSchema(class System.IO.Stream stream, class System.Converter`2&lt;class System.Type, string&gt; multipleTargetConverter) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.WriteXmlSchema(System.IO.Stream,System.Converter{System.Type,System.String})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXmlSchema(System::IO::Stream ^ stream, Converter&lt;Type ^, System::String ^&gt; ^ multipleTargetConverter);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
        <Parameter Name="multipleTargetConverter" Type="System.Converter&lt;System.Type,System.String&gt;" />
      </Parameters>
      <Docs>
        <param name="stream">O objeto <see cref="T:System.IO.Stream" /> no qual gravar.</param>
        <param name="multipleTargetConverter">Um representante usado para converter <see cref="T:System.Type" /> na cadeia de caracteres.</param>
        <summary>Grava a estrutura <see cref="T:System.Data.DataSet" /> como um esquema XML no objeto <see cref="T:System.IO.Stream" /> especificado.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteXmlSchema">
      <MemberSignature Language="C#" Value="public void WriteXmlSchema (System.IO.TextWriter writer, Converter&lt;Type,string&gt; multipleTargetConverter);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXmlSchema(class System.IO.TextWriter writer, class System.Converter`2&lt;class System.Type, string&gt; multipleTargetConverter) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.WriteXmlSchema(System.IO.TextWriter,System.Converter{System.Type,System.String})" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteXmlSchema (writer As TextWriter, multipleTargetConverter As Converter(Of Type, String))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXmlSchema(System::IO::TextWriter ^ writer, Converter&lt;Type ^, System::String ^&gt; ^ multipleTargetConverter);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.IO.TextWriter" />
        <Parameter Name="multipleTargetConverter" Type="System.Converter&lt;System.Type,System.String&gt;" />
      </Parameters>
      <Docs>
        <param name="writer">O objeto <see cref="T:System.IO.TextWriter" /> no qual gravar.</param>
        <param name="multipleTargetConverter">Um representante usado para converter <see cref="T:System.Type" /> na cadeia de caracteres.</param>
        <summary>Grava a estrutura <see cref="T:System.Data.DataSet" /> como um esquema XML no <see cref="T:System.IO.TextWriter" /> especificado.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteXmlSchema">
      <MemberSignature Language="C#" Value="public void WriteXmlSchema (string fileName, Converter&lt;Type,string&gt; multipleTargetConverter);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXmlSchema(string fileName, class System.Converter`2&lt;class System.Type, string&gt; multipleTargetConverter) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.WriteXmlSchema(System.String,System.Converter{System.Type,System.String})" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteXmlSchema (fileName As String, multipleTargetConverter As Converter(Of Type, String))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXmlSchema(System::String ^ fileName, Converter&lt;Type ^, System::String ^&gt; ^ multipleTargetConverter);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
        <Parameter Name="multipleTargetConverter" Type="System.Converter&lt;System.Type,System.String&gt;" />
      </Parameters>
      <Docs>
        <param name="fileName">O nome do arquivo no qual gravar.</param>
        <param name="multipleTargetConverter">Um representante usado para converter <see cref="T:System.Type" /> na cadeia de caracteres.</param>
        <summary>Grava a estrutura <see cref="T:System.Data.DataSet" /> como um esquema XML em um arquivo.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteXmlSchema">
      <MemberSignature Language="C#" Value="public void WriteXmlSchema (System.Xml.XmlWriter writer, Converter&lt;Type,string&gt; multipleTargetConverter);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXmlSchema(class System.Xml.XmlWriter writer, class System.Converter`2&lt;class System.Type, string&gt; multipleTargetConverter) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.WriteXmlSchema(System.Xml.XmlWriter,System.Converter{System.Type,System.String})" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteXmlSchema (writer As XmlWriter, multipleTargetConverter As Converter(Of Type, String))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXmlSchema(System::Xml::XmlWriter ^ writer, Converter&lt;Type ^, System::String ^&gt; ^ multipleTargetConverter);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Xml.XmlWriter" />
        <Parameter Name="multipleTargetConverter" Type="System.Converter&lt;System.Type,System.String&gt;" />
      </Parameters>
      <Docs>
        <param name="writer">O objeto <see cref="T:System.Xml.XmlWriter" /> no qual gravar.</param>
        <param name="multipleTargetConverter">Um representante usado para converter <see cref="T:System.Type" /> na cadeia de caracteres.</param>
        <summary>Grava a estrutura <see cref="T:System.Data.DataSet" /> como um esquema XML no <see cref="T:System.Xml.XmlWriter" /> especificado.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>