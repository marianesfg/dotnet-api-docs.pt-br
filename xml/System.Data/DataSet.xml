<Type Name="DataSet" FullName="System.Data.DataSet">
  <Metadata><Meta Name="ms.openlocfilehash" Value="5722a0fd981990611404db2615089cc410571a77" /><Meta Name="ms.sourcegitcommit" Value="662f143e6be46d519ff8ab4451d543d91e651478" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="pt-BR" /><Meta Name="ms.lasthandoff" Value="12/18/2018" /><Meta Name="ms.locfileid" Value="53568714" /></Metadata><TypeSignature Language="C#" Value="public class DataSet : System.ComponentModel.MarshalByValueComponent, System.ComponentModel.IListSource, System.ComponentModel.ISupportInitializeNotification, System.Runtime.Serialization.ISerializable, System.Xml.Serialization.IXmlSerializable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit DataSet extends System.ComponentModel.MarshalByValueComponent implements class System.ComponentModel.IListSource, class System.ComponentModel.ISupportInitialize, class System.ComponentModel.ISupportInitializeNotification, class System.Runtime.Serialization.ISerializable, class System.Xml.Serialization.IXmlSerializable" />
  <TypeSignature Language="DocId" Value="T:System.Data.DataSet" />
  <TypeSignature Language="VB.NET" Value="Public Class DataSet&#xA;Inherits MarshalByValueComponent&#xA;Implements IListSource, ISerializable, ISupportInitializeNotification, IXmlSerializable" />
  <TypeSignature Language="C++ CLI" Value="public ref class DataSet : System::ComponentModel::MarshalByValueComponent, System::ComponentModel::IListSource, System::ComponentModel::ISupportInitializeNotification, System::Runtime::Serialization::ISerializable, System::Xml::Serialization::IXmlSerializable" />
  <TypeSignature Language="F#" Value="type DataSet = class&#xA;    inherit MarshalByValueComponent&#xA;    interface IListSource&#xA;    interface IXmlSerializable&#xA;    interface ISupportInitializeNotification&#xA;    interface ISerializable&#xA;    interface ISupportInitialize" />
  <AssemblyInfo>
    <AssemblyName>System.Data</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Data.Common</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.ComponentModel.MarshalByValueComponent</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.ComponentModel.IListSource</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.ComponentModel.ISupportInitialize</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.ComponentModel.ISupportInitializeNotification</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Runtime.Serialization.ISerializable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Xml.Serialization.IXmlSerializable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
      <AttributeName>System.ComponentModel.DefaultProperty("DataSetName")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="xamarinmac-3.0">
      <AttributeName>System.ComponentModel.Designer("Microsoft.VSDesigner.Data.VS.DataSetDesigner, Microsoft.VSDesigner, Version=0.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="xamarinmac-3.0">
      <AttributeName>System.ComponentModel.ToolboxItem("Microsoft.VSDesigner.Data.VS.DataSetToolboxItem, Microsoft.VSDesigner, Version=0.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Xml.Serialization.XmlRoot("DataSet")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
      <AttributeName>System.Xml.Serialization.XmlSchemaProvider("GetDataSetSchema")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8;netcore-2.0">
      <AttributeName>System.ComponentModel.ToolboxItem("Microsoft.VSDesigner.Data.VS.DataSetToolboxItem, Microsoft.VSDesigner, Version=10.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1">
      <AttributeName>System.ComponentModel.Designer("Microsoft.VSDesigner.Data.VS.DataSetDesigner, Microsoft.VSDesigner, Version=7.0.5000.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1">
      <AttributeName>System.ComponentModel.ToolboxItem("Microsoft.VSDesigner.Data.VS.DataSetToolboxItem, Microsoft.VSDesigner, Version=7.0.5000.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
      <AttributeName>System.ComponentModel.Designer("Microsoft.VSDesigner.Data.VS.DataSetDesigner, Microsoft.VSDesigner, Version=8.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
      <AttributeName>System.ComponentModel.ToolboxItem("Microsoft.VSDesigner.Data.VS.DataSetToolboxItem, Microsoft.VSDesigner, Version=8.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName>System.ComponentModel.Designer("Microsoft.VSDesigner.Data.VS.DataSetDesigner, Microsoft.VSDesigner, Version=10.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8">
      <AttributeName>System.ComponentModel.Designer("Microsoft.VSDesigner.Data.VS.DataSetDesigner, Microsoft.VSDesigner, Version=9.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8">
      <AttributeName>System.ComponentModel.ToolboxItem("Microsoft.VSDesigner.Data.VS.DataSetToolboxItem, Microsoft.VSDesigner, Version=9.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Representa um cache de dados na memória.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Data.DataSet>, que é um cache na memória dos dados recuperados de uma fonte de dados é um componente importante da arquitetura do ADO.NET. O <xref:System.Data.DataSet> consiste em uma coleção de <xref:System.Data.DataTable> objetos que você pode se relacionam entre si com <xref:System.Data.DataRelation> objetos. Você também pode impor a integridade dos dados na <xref:System.Data.DataSet> usando o <xref:System.Data.UniqueConstraint> e <xref:System.Data.ForeignKeyConstraint> objetos. Para obter mais detalhes sobre como trabalhar com <xref:System.Data.DataSet> objetos, consulte [DataSets, DataTables e DataViews](~/docs/framework/data/adonet/dataset-datatable-dataview/index.md).  
  
 Enquanto <xref:System.Data.DataTable> objetos contêm os dados, o <xref:System.Data.DataRelationCollection> permite que você navegue pelas hierarquia da tabela. As tabelas estão contidas em um <xref:System.Data.DataTableCollection> acessado por meio de <xref:System.Data.DataSet.Tables%2A> propriedade. Ao acessar <xref:System.Data.DataTable> objetos, observe que eles são condicionalmente diferencia maiusculas de minúsculas. Por exemplo, se houver um <xref:System.Data.DataTable> é denominado "mydatatable" e o outro é denominado "Mydatatable", uma cadeia de caracteres usada para pesquisar uma das tabelas é considerada como diferencia maiusculas de minúsculas. No entanto, se existe "mydatatable" e "Mydatatable" não, a cadeia de caracteres de pesquisa é considerada como diferencia maiusculas de minúsculas. Para obter mais informações sobre como trabalhar com <xref:System.Data.DataTable> objetos, consulte [criando um DataTable](~/docs/framework/data/adonet/dataset-datatable-dataview/creating-a-datatable.md).  
  
 Um <xref:System.Data.DataSet> podem ler e gravar dados e esquema, como documentos XML. Os dados e esquema podem ser transportados entre HTTP e usados por qualquer aplicativo, em qualquer plataforma que está habilitado para XML. Você pode salvar o esquema como um esquema XML com o <xref:System.Data.DataSet.WriteXmlSchema%2A> método e esquema e os dados podem ser salvos usando o <xref:System.Data.DataSet.WriteXml%2A> método. Para ler um documento XML que inclui o esquema e os dados, use o <xref:System.Data.DataSet.ReadXml%2A> método.  
  
 Em uma implementação típica de várias camadas, as etapas para criar e atualizar um <xref:System.Data.DataSet>, e por sua vez, atualizando os dados originais são para:  
  
1.  Criar e preencher cada <xref:System.Data.DataTable> em um <xref:System.Data.DataSet> com os dados de uma fonte de dados usando um <xref:System.Data.Common.DataAdapter>.  
  
2.  Alterar os dados em um indivíduo <xref:System.Data.DataTable> objetos, adicionando, atualizando ou excluindo <xref:System.Data.DataRow> objetos.  
  
3.  Invocar o <xref:System.Data.DataSet.GetChanges%2A> método para criar um segundo <xref:System.Data.DataSet> que apresenta apenas as alterações aos dados.  
  
4.  Chame o <xref:System.Data.Common.DataAdapter.Update%2A> método da <xref:System.Data.Common.DataAdapter>, passando o segundo <xref:System.Data.DataSet> como um argumento.  
  
5.  Invocar o <xref:System.Data.DataSet.Merge%2A> método para mesclar as alterações da segunda <xref:System.Data.DataSet> o primeiro.  
  
6.  Invocar o <xref:System.Data.DataSet.AcceptChanges%2A> sobre o <xref:System.Data.DataSet>. Como alternativa, invocar <xref:System.Data.DataSet.RejectChanges%2A> para cancelar as alterações.  
  
> [!NOTE]
>  O <xref:System.Data.DataSet> e <xref:System.Data.DataTable> objetos herdam <xref:System.ComponentModel.MarshalByValueComponent>e dão suporte a <xref:System.Runtime.Serialization.ISerializable> interface para comunicação remota. Esses são os únicos objetos ADO.NET que podem ser remotos.  
  
> [!NOTE]
>  As classes herdadas de <xref:System.Data.DataSet> não são finalizados pelo coletor de lixo, pois o finalizador foi suprimido no <xref:System.Data.DataSet>. A classe derivada pode chamar o <xref:System.GC.ReRegisterForFinalize%2A> método em seu construtor para permitir que a classe a finalização pelo coletor de lixo.  
  
   
  
## Examples  
 O exemplo a seguir consiste em vários métodos que, combinados, criar e preencher uma <xref:System.Data.DataSet> do **Northwind** banco de dados.  
  
 [!code-csharp[Classic WebData DataSet Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet Example/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe>Este tipo é seguro para operações de leitura e multithread. Você deve sincronizar todas as operações de gravação.</threadsafe>
    <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">Usando conjuntos de dados no ADO.NET</related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicializa uma nova instância da classe <see cref="T:System.Data.DataSet" />.</summary>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">Usando conjuntos de dados no ADO.NET</related>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DataSet ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DataSet();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inicializa uma nova instância da classe <see cref="T:System.Data.DataSet" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Essa implementação do <xref:System.Data.DataSet> construtor não usa nenhum parâmetro e cria um nome padrão, "NewDataSet", para a nova instância.  
  
 Um nome para o <xref:System.Data.DataSet> é necessário para garantir que a representação XML do <xref:System.Data.DataSet> sempre tem um nome para o elemento de documento, que é o elemento de nível mais alto em uma definição de esquema.  
  
   
  
## Examples  
 O exemplo a seguir cria um novo <xref:System.Data.DataSet>e adiciona dois <xref:System.Data.DataTable> objetos nele.  
  
 [!code-vb[Classic WebData DataSet.DataSet Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.DataSet Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Data.DataTableCollection" />
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">Usando conjuntos de dados no ADO.NET</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DataSet (string dataSetName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string dataSetName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.#ctor(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (dataSetName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DataSet(System::String ^ dataSetName);" />
      <MemberSignature Language="F#" Value="new System.Data.DataSet : string -&gt; System.Data.DataSet" Usage="new System.Data.DataSet dataSetName" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="dataSetName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="dataSetName">O nome do <see cref="T:System.Data.DataSet" />.</param>
        <summary>Inicializa uma nova instância de uma classe <see cref="T:System.Data.DataSet" /> com o nome especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Um nome para o <xref:System.Data.DataSet> é necessário para garantir que a representação XML do <xref:System.Data.DataSet> sempre tem um nome para o elemento de documento, que é o elemento de nível mais alto em uma definição de esquema.  
  
   
  
## Examples  
 O exemplo a seguir cria um novo <xref:System.Data.DataSet>, para os quais são os dois <xref:System.Data.DataTable> objetos são adicionados.  
  
 [!code-vb[Classic WebData DataSet.DataSet1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.DataSet1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Data.DataSet.DataSetName" />
        <altmember cref="T:System.Data.DataTableCollection" />
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">Usando conjuntos de dados no ADO.NET</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected DataSet (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(class System.Runtime.Serialization.SerializationInfo info, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New (info As SerializationInfo, context As StreamingContext)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; DataSet(System::Runtime::Serialization::SerializationInfo ^ info, System::Runtime::Serialization::StreamingContext context);" />
      <MemberSignature Language="F#" Value="new System.Data.DataSet : System.Runtime.Serialization.SerializationInfo * System.Runtime.Serialization.StreamingContext -&gt; System.Data.DataSet" Usage="new System.Data.DataSet (info, context)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="info" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="info">Os dados necessários para serializar ou desserializar um objeto.</param>
        <param name="context">A origem e o destino de um determinado fluxo serializado.</param>
        <summary>Inicializa uma nova instância de uma classe <see cref="T:System.Data.DataSet" /> que tem as informações de serialização e contexto fornecidas.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
[!INCLUDE [untrusted-data-instance-note](~/includes/untrusted-data-instance-note.md)]
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected DataSet (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context, bool ConstructSchema);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(class System.Runtime.Serialization.SerializationInfo info, valuetype System.Runtime.Serialization.StreamingContext context, bool ConstructSchema) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New (info As SerializationInfo, context As StreamingContext, ConstructSchema As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; DataSet(System::Runtime::Serialization::SerializationInfo ^ info, System::Runtime::Serialization::StreamingContext context, bool ConstructSchema);" />
      <MemberSignature Language="F#" Value="new System.Data.DataSet : System.Runtime.Serialization.SerializationInfo * System.Runtime.Serialization.StreamingContext * bool -&gt; System.Data.DataSet" Usage="new System.Data.DataSet (info, context, ConstructSchema)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="info" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" />
        <Parameter Name="ConstructSchema" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="info">O objeto <see cref="T:System.Runtime.Serialization.SerializationInfo" />.</param>
        <param name="context">O objeto <see cref="T:System.Runtime.Serialization.StreamingContext" />.</param>
        <param name="ConstructSchema">O valor booliano.</param>
        <summary>Inicializa uma nova instância da classe <see cref="T:System.Data.DataSet" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
[!INCLUDE [untrusted-data-instance-note](~/includes/untrusted-data-instance-note.md)]
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AcceptChanges">
      <MemberSignature Language="C#" Value="public void AcceptChanges ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AcceptChanges() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.AcceptChanges" />
      <MemberSignature Language="VB.NET" Value="Public Sub AcceptChanges ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AcceptChanges();" />
      <MemberSignature Language="F#" Value="member this.AcceptChanges : unit -&gt; unit" Usage="dataSet.AcceptChanges " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Confirma todas as alterações feitas nesse <see cref="T:System.Data.DataSet" /> desde que foi carregado ou desde a última vez que <see cref="M:System.Data.DataSet.AcceptChanges" /> foi chamado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Tanto a <xref:System.Data.DataRow> e <xref:System.Data.DataTable> classes têm <xref:System.Data.DataSet.AcceptChanges%2A> métodos. Chamando <xref:System.Data.DataTable.AcceptChanges%2A> no <xref:System.Data.DataTable> faz com que o nível de <xref:System.Data.DataRow.AcceptChanges%2A> método para cada <xref:System.Data.DataRow> a ser chamado. Da mesma forma, invocando <xref:System.Data.DataSet.AcceptChanges%2A> no <xref:System.Data.DataSet> faz com que <xref:System.Data.DataTable.AcceptChanges%2A> a ser chamado em cada tabela dentro a <xref:System.Data.DataSet>. Dessa forma, você tem vários níveis em que o método pode ser invocado. Chamar o <xref:System.Data.DataSet.AcceptChanges%2A> do <xref:System.Data.DataSet> permite que você chame o método em todos os objetos subordinados (por exemplo, tabelas e linhas) com uma chamada.  
  
 Quando você chama `AcceptChanges` sobre o `DataSet`, qualquer <xref:System.Data.DataRow> objetos ainda no modo de edição terminam suas edições com êxito. O <xref:System.Data.DataRow.RowState%2A> propriedade de cada <xref:System.Data.DataRow> também muda; `Added` e `Modified` linhas se tornam `Unchanged`, e `Deleted` linhas são removidas.  
  
 Se o `DataSet` contém <xref:System.Data.ForeignKeyConstraint> objetos, invocando o `AcceptChanges` método também faz com que o <xref:System.Data.ForeignKeyConstraint.AcceptRejectRule%2A> seja imposta.  
  
> [!NOTE]
>  `AcceptChanges` e `RejectChanges` se aplicam somente aos `DataRow` alterações (ou seja, adicionar, remover, excluir e modificar) relacionadas. Eles não são aplicáveis ao esquema ou alterações estruturais.  
>   
>  Chamar AcceptChanges não replicará essas alterações de volta para a fonte de dados se o conjunto de dados foi preenchido usando um DataAdapter. Nessa situação, chamar <xref:System.Data.Common.DataAdapter.Update%2A> em vez disso. Ver [Updating Data Sources with DataAdapters](~/docs/framework/data/adonet/updating-data-sources-with-dataadapters.md) para obter mais informações.  
  
   
  
## Examples  
 O exemplo a seguir adiciona uma <xref:System.Data.DataRow> para um <xref:System.Data.DataTable> em um <xref:System.Data.DataSet>. O <xref:System.Data.DataSet.AcceptChanges%2A> método é chamado em de <xref:System.Data.DataSet>, quais revezar a todos os <xref:System.Data.DataTable> objetos que ele contém.  
  
 [!code-csharp[Classic WebData DataSet.AcceptChanges#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.AcceptChanges/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.AcceptChanges#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.AcceptChanges/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">Usando conjuntos de dados no ADO.NET</related>
      </Docs>
    </Member>
    <Member MemberName="BeginInit">
      <MemberSignature Language="C#" Value="public void BeginInit ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void BeginInit() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.BeginInit" />
      <MemberSignature Language="VB.NET" Value="Public Sub BeginInit ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void BeginInit();" />
      <MemberSignature Language="F#" Value="abstract member BeginInit : unit -&gt; unit&#xA;override this.BeginInit : unit -&gt; unit" Usage="dataSet.BeginInit " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ComponentModel.ISupportInitialize.BeginInit</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Começa a inicialização de um <see cref="T:System.Data.DataSet" /> usado em um formulário ou por outro componente. A inicialização ocorre no tempo de execução.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O ambiente de design do Visual Studio .NET usa esse método para iniciar a inicialização de um componente que é usado em um formulário ou por outro componente. O <xref:System.Data.DataSet.EndInit%2A> método encerra a inicialização. Usando o <xref:System.Data.DataSet.BeginInit%2A> e <xref:System.Data.DataSet.EndInit%2A> métodos impede que o controle seja usado antes de ser totalmente inicializado.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">Usando conjuntos de dados no ADO.NET</related>
      </Docs>
    </Member>
    <Member MemberName="CaseSensitive">
      <MemberSignature Language="C#" Value="public bool CaseSensitive { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CaseSensitive" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataSet.CaseSensitive" />
      <MemberSignature Language="VB.NET" Value="Public Property CaseSensitive As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool CaseSensitive { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.CaseSensitive : bool with get, set" Usage="System.Data.DataSet.CaseSensitive" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.Data.DataSysDescription("DataSetCaseSensitiveDescr")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define um valor que indica se comparações de cadeia de caracteres dentro de objetos <see cref="T:System.Data.DataTable" /> diferenciam maiúsculas de minúsculas.</summary>
        <value><see langword="true" /> Se as comparações de cadeia de caracteres diferenciam maiusculas de minúsculas; Caso contrário, <see langword="false" />. O padrão é <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Data.DataSet.CaseSensitive%2A> propriedade afeta como classificação, pesquisa e operações de filtragem são executadas em cada <xref:System.Data.DataTable> objeto contido em um <xref:System.Data.DataSet> ao usar o <xref:System.Data.DataTable.Select%2A> método.  
  
 Por padrão, definindo a <xref:System.Data.DataSet.CaseSensitive%2A> propriedade para um <xref:System.Data.DataSet> também define o <xref:System.Data.DataTable.CaseSensitive%2A> propriedade de cada um associado <xref:System.Data.DataTable> com o mesmo valor.  
  
   
  
## Examples  
 O exemplo a seguir alterna o <xref:System.Data.DataSet.CaseSensitive%2A> propriedade.  
  
 [!code-vb[Classic WebData DataSet.CaseSensitive Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.CaseSensitive Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">Usando conjuntos de dados no ADO.NET</related>
      </Docs>
    </Member>
    <Member MemberName="Clear">
      <MemberSignature Language="C#" Value="public void Clear ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Clear() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.Clear" />
      <MemberSignature Language="VB.NET" Value="Public Sub Clear ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Clear();" />
      <MemberSignature Language="F#" Value="member this.Clear : unit -&gt; unit" Usage="dataSet.Clear " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Limpa o <see cref="T:System.Data.DataSet" /> de todos os dados, removendo todas as linhas em todas as tabelas.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se o <xref:System.Data.DataSet> está associado a um <xref:System.Xml.XmlDataDocument>, chamar <xref:System.Data.DataSet.Clear%2A?displayProperty=nameWithType> ou <xref:System.Data.DataTable.Clear%2A?displayProperty=nameWithType> aciona o <xref:System.NotSupportedException>. Para evitar essa situação, percorre cada tabela, removendo a cada linha, um por vez.  
  
   
  
## Examples  
 O exemplo a seguir limpa o <xref:System.Data.DataSet> de todas as linhas em todas as tabelas.  
  
 [!code-csharp[Classic WebData DataSet.Clear Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.Clear Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.Clear Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.Clear Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">Usando conjuntos de dados no ADO.NET</related>
      </Docs>
    </Member>
    <Member MemberName="Clone">
      <MemberSignature Language="C#" Value="public virtual System.Data.DataSet Clone ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Data.DataSet Clone() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.Clone" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Clone () As DataSet" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Data::DataSet ^ Clone();" />
      <MemberSignature Language="F#" Value="abstract member Clone : unit -&gt; System.Data.DataSet&#xA;override this.Clone : unit -&gt; System.Data.DataSet" Usage="dataSet.Clone " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataSet</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Copia a estrutura do <see cref="T:System.Data.DataSet" />, incluindo todos os esquemas, relações e restrições <see cref="T:System.Data.DataTable" />. Não copia todos os dados.</summary>
        <returns>Um novo <see cref="T:System.Data.DataSet" /> com o mesmo esquema que o <see cref="T:System.Data.DataSet" /> atual, mas sem nenhum dado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Se essas classes tiverem sido subclassificadas, o clone também será das mesmas classes subclasses.  
  
   
  
## Examples  
 O exemplo a seguir cria um clone de um <xref:System.Data.DataSet> esquema do objeto.  
  
 [!code-csharp[Classic WebData DataSet.Clone Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.Clone Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.Clone Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.Clone Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Data.DataSet.Copy" />
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">Usando conjuntos de dados no ADO.NET</related>
      </Docs>
    </Member>
    <Member MemberName="Copy">
      <MemberSignature Language="C#" Value="public System.Data.DataSet Copy ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.DataSet Copy() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.Copy" />
      <MemberSignature Language="VB.NET" Value="Public Function Copy () As DataSet" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::DataSet ^ Copy();" />
      <MemberSignature Language="F#" Value="member this.Copy : unit -&gt; System.Data.DataSet" Usage="dataSet.Copy " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataSet</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Copia a estrutura e os dados para este <see cref="T:System.Data.DataSet" />.</summary>
        <returns>Um novo <see cref="T:System.Data.DataSet" /> com a mesma estrutura (esquemas de tabela, relações e restrições) e dados que esse <see cref="T:System.Data.DataSet" />.  
  
 <block subset="none" type="note"><para>  
 Se essas classes tiverem sido subclassificadas, a cópia também será das mesmas classes subclasses.  
  
</para></block></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O exemplo a seguir usa o <xref:System.Data.DataSet.Copy%2A> método para criar uma cópia do original <xref:System.Data.DataSet>.  
  
 [!code-csharp[Classic WebData DataSet.Copy Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.Copy Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.Copy Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.Copy Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Data.DataSet.Clone" />
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">Usando conjuntos de dados no ADO.NET</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateDataReader">
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Retorna um <see cref="T:System.Data.DataTableReader" /> com um resultado definido por <see cref="T:System.Data.DataTable" />, na mesma sequência em que as tabelas são exibidas na coleção <see cref="P:System.Data.DataSet.Tables" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para garantir a ordem dos conjuntos de resultados retornado dentro do <xref:System.Data.DataTableReader>, se um <xref:System.Data.DataTable> dentro de <xref:System.Data.DataSet> é vazio, ele será representado por um resultado vazio definido dentro do retornado `DataTableReader`.  
  
   
  
## Examples  
 Neste exemplo, um aplicativo de Console cria três <xref:System.Data.DataTable> instâncias e adiciona cada um a um <xref:System.Data.DataSet>. O exemplo chama o <xref:System.Data.DataSet.CreateDataReader%2A> método e exibe o conteúdo de retornado <xref:System.Data.DataTableReader>. Observe que define a ordem do resultado a `DataTableReader` é controlado pela ordem dos `DataTable` instâncias passados como parâmetros.  
  
> [!NOTE]
>  Este exemplo mostra como usar uma das versões sobrecarregadas do `CreateDataReader`. Para obter outros exemplos que possam estar disponíveis, consulte os tópicos de sobrecarga individuais.  
  
 [!code-csharp[DataWorks DataSet.CreateDataReader#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataSet.CreateDataReader/CS/source.cs#1)]
 [!code-vb[DataWorks DataSet.CreateDataReader#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataSet.CreateDataReader/VB/source.vb#1)]  
  
 O exemplo exibe o código a seguir na janela do Console:  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">Usando conjuntos de dados no ADO.NET</related>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateDataReader">
      <MemberSignature Language="C#" Value="public System.Data.DataTableReader CreateDataReader ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.DataTableReader CreateDataReader() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.CreateDataReader" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateDataReader () As DataTableReader" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::DataTableReader ^ CreateDataReader();" />
      <MemberSignature Language="F#" Value="member this.CreateDataReader : unit -&gt; System.Data.DataTableReader" Usage="dataSet.CreateDataReader " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataTableReader</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retorna um <see cref="T:System.Data.DataTableReader" /> com um resultado definido por <see cref="T:System.Data.DataTable" />, na mesma sequência em que as tabelas são exibidas na coleção <see cref="P:System.Data.DataSet.Tables" />.</summary>
        <returns>Um <see cref="T:System.Data.DataTableReader" /> que contém um ou mais conjuntos de resultados, correspondentes às instâncias <see cref="T:System.Data.DataTable" /> contidas no <see cref="T:System.Data.DataSet" /> de origem.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para garantir a ordem dos conjuntos de resultados retornado dentro do <xref:System.Data.DataTableReader>, se um <xref:System.Data.DataTable> dentro de <xref:System.Data.DataSet> é vazio, ele é representado por um resultado vazio definido dentro do retornado `DataTableReader`.  
  
   
  
## Examples  
 O exemplo a seguir cria três <xref:System.Data.DataTable> instâncias e adiciona cada um a um <xref:System.Data.DataSet>. O exemplo, em seguida, passa o preenchido `DataSet` para um procedimento que chama o <xref:System.Data.DataSet.CreateDataReader%2A> método e continua para iterar em todos os conjuntos de resultados contidos o <xref:System.Data.DataTableReader>. O exemplo exibe os resultados na janela do Console.  
  
 [!code-csharp[DataWorks DataSet.DataTableReader#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataSet.DataTableReader/CS/source.cs#1)]
 [!code-vb[DataWorks DataSet.DataTableReader#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataSet.DataTableReader/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">Usando conjuntos de dados no ADO.NET</related>
      </Docs>
    </Member>
    <Member MemberName="CreateDataReader">
      <MemberSignature Language="C#" Value="public System.Data.DataTableReader CreateDataReader (params System.Data.DataTable[] dataTables);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.DataTableReader CreateDataReader(class System.Data.DataTable[] dataTables) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.CreateDataReader(System.Data.DataTable[])" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateDataReader (ParamArray dataTables As DataTable()) As DataTableReader" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::DataTableReader ^ CreateDataReader(... cli::array &lt;System::Data::DataTable ^&gt; ^ dataTables);" />
      <MemberSignature Language="F#" Value="member this.CreateDataReader : System.Data.DataTable[] -&gt; System.Data.DataTableReader" Usage="dataSet.CreateDataReader dataTables" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataTableReader</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dataTables" Type="System.Data.DataTable[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="dataTables">Uma matriz de DataTables que fornece a ordem dos conjuntos de resultado a serem retornados no <see cref="T:System.Data.DataTableReader" />.</param>
        <summary>Retorna um <see cref="T:System.Data.DataTableReader" /> com um conjunto de resultados por <see cref="T:System.Data.DataTable" />.</summary>
        <returns>Um <see cref="T:System.Data.DataTableReader" /> que contém um ou mais conjuntos de resultados, correspondentes às instâncias <see cref="T:System.Data.DataTable" /> contidas no <see cref="T:System.Data.DataSet" /> de origem. Os conjuntos de resultados retornados estão na ordem especificada pelo parâmetro <paramref name="dataTables" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para garantir que a ordem do resultado define dentro retornado <xref:System.Data.DataTableReader>, se um <xref:System.Data.DataTable> dentro de <xref:System.Data.DataSet> é vazio, ele é representado por um resultado vazio definido dentro do retornado `DataTableReader`. Porque esta versão sobrecarregada permite que você forneça uma lista dos `DataTable` instâncias como parâmetros, você pode especificar a ordem na qual os conjuntos de resultados são exibidos em retornado `DataTableReader`.  
  
   
  
## Examples  
 Neste exemplo, um aplicativo de Console cria três <xref:System.Data.DataTable> instâncias e adiciona cada um a um <xref:System.Data.DataSet>. O exemplo chama o <xref:System.Data.DataSet.CreateDataReader%2A> método e exibe o conteúdo de retornado <xref:System.Data.DataTableReader>. Observe que define a ordem do resultado a `DataTableReader` é controlado pela ordem dos `DataTable` instâncias passados como parâmetros. O exemplo exibe os resultados na janela do Console.  
  
 [!code-csharp[DataWorks DataSet.DataTableReaderTables#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataSet.DataTableReaderTables/CS/source.cs#1)]
 [!code-vb[DataWorks DataSet.DataTableReaderTables#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataSet.DataTableReaderTables/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">Usando conjuntos de dados no ADO.NET</related>
      </Docs>
    </Member>
    <Member MemberName="DataSetName">
      <MemberSignature Language="C#" Value="public string DataSetName { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string DataSetName" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataSet.DataSetName" />
      <MemberSignature Language="VB.NET" Value="Public Property DataSetName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ DataSetName { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.DataSetName : string with get, set" Usage="System.Data.DataSet.DataSetName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.ComponentModel.DefaultValue("")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.Data.DataSysDescription("DataSetDataSetNameDescr")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define o nome do <see cref="T:System.Data.DataSet" /> atual.</summary>
        <value>O nome do <see cref="T:System.Data.DataSet" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O exemplo a seguir cria um novo <xref:System.Data.DataSet> com o determinado <xref:System.Data.DataSet.DataSetName%2A>.  
  
 [!code-csharp[Classic WebData DataSet.DataSetName Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.DataSetName Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.DataSetName Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.DataSetName Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">Usando conjuntos de dados no ADO.NET</related>
      </Docs>
    </Member>
    <Member MemberName="DefaultViewManager">
      <MemberSignature Language="C#" Value="public System.Data.DataViewManager DefaultViewManager { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Data.DataViewManager DefaultViewManager" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataSet.DefaultViewManager" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DefaultViewManager As DataViewManager" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Data::DataViewManager ^ DefaultViewManager { System::Data::DataViewManager ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DefaultViewManager : System.Data.DataViewManager" Usage="System.Data.DataSet.DefaultViewManager" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.Data.DataSysDescription("DataSetDefaultViewDescr")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Data.DataViewManager</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém uma exibição personalizada dos dados contidos no <see cref="T:System.Data.DataSet" /> para permitir a filtragem, a pesquisa e a navegação usando um <see cref="T:System.Data.DataViewManager" /> personalizado.</summary>
        <value>Um objeto <see cref="T:System.Data.DataViewManager" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Data.DataViewManager> retornado pela <xref:System.Data.DataSet.DefaultViewManager%2A> propriedade permite que você crie configurações personalizadas para cada <xref:System.Data.DataTable> no <xref:System.Data.DataSet>.  
  
 Quando você obter um <xref:System.Data.DataView> de um <xref:System.Data.DataTable>, a ordem de classificação, filtragem, e <xref:System.Data.DataViewRowState> são configurados de acordo com as configurações a <xref:System.Data.DataSet.DefaultViewManager%2A> propriedade.  
  
   
  
## Examples  
 O exemplo a seguir obtém o padrão <xref:System.Data.DataViewManager> para um <xref:System.Data.DataSet>e adiciona uma <xref:System.Data.DataTable> para o <xref:System.Data.DataTableCollection>.  
  
 [!code-vb[Classic WebData DataSet.DefaultViewManager Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.DefaultViewManager Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">Usando conjuntos de dados no ADO.NET</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="DetermineSchemaSerializationMode">
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Determina o <see cref="P:System.Data.DataSet.SchemaSerializationMode" /> para um <see cref="T:System.Data.DataSet" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método pode ser chamado durante a desserialização de um <xref:System.Data.DataSet> tipado para determinar seu <xref:System.Data.DataSet.SchemaSerializationMode%2A>.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">Usando conjuntos de dados no ADO.NET</related>
      </Docs>
    </MemberGroup>
    <Member MemberName="DetermineSchemaSerializationMode">
      <MemberSignature Language="C#" Value="protected System.Data.SchemaSerializationMode DetermineSchemaSerializationMode (System.Xml.XmlReader reader);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance valuetype System.Data.SchemaSerializationMode DetermineSchemaSerializationMode(class System.Xml.XmlReader reader) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.DetermineSchemaSerializationMode(System.Xml.XmlReader)" />
      <MemberSignature Language="VB.NET" Value="Protected Function DetermineSchemaSerializationMode (reader As XmlReader) As SchemaSerializationMode" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; System::Data::SchemaSerializationMode DetermineSchemaSerializationMode(System::Xml::XmlReader ^ reader);" />
      <MemberSignature Language="F#" Value="member this.DetermineSchemaSerializationMode : System.Xml.XmlReader -&gt; System.Data.SchemaSerializationMode" Usage="dataSet.DetermineSchemaSerializationMode reader" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.SchemaSerializationMode</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Xml.XmlReader" />
      </Parameters>
      <Docs>
        <param name="reader">A instância <see cref="T:System.Xml.XmlReader" /> que é passada durante a desserialização do <see cref="T:System.Data.DataSet" />.</param>
        <summary>Determina o <see cref="P:System.Data.DataSet.SchemaSerializationMode" /> para um <see cref="T:System.Data.DataSet" />.</summary>
        <returns>Uma enumeração <see cref="T:System.Data.SchemaSerializationMode" /> que indica se as informações de esquema foram omitidas do conteúdo.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método pode ser chamado durante a desserialização de um <xref:System.Data.DataSet> tipado para determinar seu <xref:System.Data.DataSet.SchemaSerializationMode%2A>.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">Usando conjuntos de dados no ADO.NET</related>
      </Docs>
    </Member>
    <Member MemberName="DetermineSchemaSerializationMode">
      <MemberSignature Language="C#" Value="protected System.Data.SchemaSerializationMode DetermineSchemaSerializationMode (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance valuetype System.Data.SchemaSerializationMode DetermineSchemaSerializationMode(class System.Runtime.Serialization.SerializationInfo info, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.DetermineSchemaSerializationMode(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="VB.NET" Value="Protected Function DetermineSchemaSerializationMode (info As SerializationInfo, context As StreamingContext) As SchemaSerializationMode" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; System::Data::SchemaSerializationMode DetermineSchemaSerializationMode(System::Runtime::Serialization::SerializationInfo ^ info, System::Runtime::Serialization::StreamingContext context);" />
      <MemberSignature Language="F#" Value="member this.DetermineSchemaSerializationMode : System.Runtime.Serialization.SerializationInfo * System.Runtime.Serialization.StreamingContext -&gt; System.Data.SchemaSerializationMode" Usage="dataSet.DetermineSchemaSerializationMode (info, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.SchemaSerializationMode</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="info" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="info">O <see cref="T:System.Runtime.Serialization.SerializationInfo" /> com o qual o construtor protegido <see cref="M:System.Data.DataSet.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" /> de <see langword="DataSet" /> é invocado durante a desserialização em cenários de comunicação remota.</param>
        <param name="context">O <see cref="T:System.Runtime.Serialization.StreamingContext" /> com o qual o construtor protegido <see cref="M:System.Data.DataSet.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" /> de <see langword="DataSet" /> é invocado durante a desserialização em cenários de comunicação remota.</param>
        <summary>Determina o <see cref="P:System.Data.DataSet.SchemaSerializationMode" /> para um <see cref="T:System.Data.DataSet" />.</summary>
        <returns>Uma enumeração <see cref="T:System.Data.SchemaSerializationMode" /> que indica se as informações de esquema foram omitidas do conteúdo.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método pode ser chamado durante a desserialização de um <xref:System.Data.DataSet> tipado para determinar seu <xref:System.Data.DataSet.SchemaSerializationMode%2A>.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">Usando conjuntos de dados no ADO.NET</related>
      </Docs>
    </Member>
    <Member MemberName="EndInit">
      <MemberSignature Language="C#" Value="public void EndInit ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void EndInit() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.EndInit" />
      <MemberSignature Language="VB.NET" Value="Public Sub EndInit ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void EndInit();" />
      <MemberSignature Language="F#" Value="abstract member EndInit : unit -&gt; unit&#xA;override this.EndInit : unit -&gt; unit" Usage="dataSet.EndInit " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ComponentModel.ISupportInitialize.EndInit</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Encerra a inicialização de um <see cref="T:System.Data.DataSet" /> que é usado em um formulário ou por outro componente. A inicialização ocorre no tempo de execução.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O ambiente de design do Visual Studio .NET usa esse método para encerrar a inicialização de um componente que é usado em um formulário ou por outro componente. O <xref:System.Data.DataSet.BeginInit%2A> método começa a inicialização. Usando o <xref:System.Data.DataSet.BeginInit%2A> e <xref:System.Data.DataSet.EndInit%2A> métodos impede que o controle seja usado antes de ser totalmente inicializado.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">Usando conjuntos de dados no ADO.NET</related>
      </Docs>
    </Member>
    <Member MemberName="EnforceConstraints">
      <MemberSignature Language="C#" Value="public bool EnforceConstraints { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool EnforceConstraints" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataSet.EnforceConstraints" />
      <MemberSignature Language="VB.NET" Value="Public Property EnforceConstraints As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool EnforceConstraints { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.EnforceConstraints : bool with get, set" Usage="System.Data.DataSet.EnforceConstraints" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.ComponentModel.DefaultValue(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.Data.DataSysDescription("DataSetEnforceConstraintsDescr")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define um valor que indica se as regras de restrição são seguidas ao tentar qualquer operação de atualização.</summary>
        <value><see langword="true" /> Se as regras são impostas; Caso contrário, <see langword="false" />. O padrão é <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Restrições são definidas na <xref:System.Data.DataTable> nível (<xref:System.Data.DataTable.Constraints%2A> propriedade). Para obter mais informações sobre a criação de restrições, consulte [restrições de DataTable](~/docs/framework/data/adonet/dataset-datatable-dataview/datatable-constraints.md).  
  
   
  
## Examples  
 O exemplo a seguir cria uma <xref:System.Data.DataSet> com uma tabela, uma coluna, cinco linhas e um <xref:System.Data.UniqueConstraint>. O <xref:System.Data.DataSet.EnforceConstraints%2A> estiver definida como `false` e os valores de cada linha são definidos para o mesmo valor. Quando o <xref:System.Data.DataSet.EnforceConstraints%2A> propriedade será redefinida como `true`, um <xref:System.Data.ConstraintException> é gerado.  
  
 [!code-csharp[Classic WebData DataSet.EnforceConstraints Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.EnforceConstraints Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.EnforceConstraints Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.EnforceConstraints Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Data.ConstraintException">Não é possível impor uma ou mais restrições.</exception>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">Usando conjuntos de dados no ADO.NET</related>
      </Docs>
    </Member>
    <Member MemberName="ExtendedProperties">
      <MemberSignature Language="C#" Value="public System.Data.PropertyCollection ExtendedProperties { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Data.PropertyCollection ExtendedProperties" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataSet.ExtendedProperties" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ExtendedProperties As PropertyCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Data::PropertyCollection ^ ExtendedProperties { System::Data::PropertyCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ExtendedProperties : System.Data.PropertyCollection" Usage="System.Data.DataSet.ExtendedProperties" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.Data.DataSysDescription("ExtendedPropertiesDescr")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Data.PropertyCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém a coleção de informações de usuário personalizadas associadas a um <see langword="DataSet" />.</summary>
        <value>Um <see cref="T:System.Data.PropertyCollection" /> com todas as informações de usuário personalizadas.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Data.DataSet.ExtendedProperties%2A> propriedade permite que você armazene informações personalizadas com o `DataSet`. Por exemplo, você pode armazenar um tempo quando os dados devem ser atualizados.  
  
 As propriedades estendidas devem ser do tipo <xref:System.String> se quiser que eles persistidos quando o <xref:System.Data.DataSet> é gravado como XML.  
  
   
  
## Examples  
 O exemplo a seguir adiciona uma propriedade personalizada para o <xref:System.Data.PropertyCollection> retornado pelo <xref:System.Data.DataColumn.ExtendedProperties%2A> propriedade. O segundo exemplo recupera a propriedade personalizada.  
  
 [!code-csharp[Classic WebData DataColumn.ExtendedProperties Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataColumn.ExtendedProperties Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataColumn.ExtendedProperties Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataColumn.ExtendedProperties Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">Usando conjuntos de dados no ADO.NET</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetChanges">
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Obtém uma cópia do <see cref="T:System.Data.DataSet" /> que contém todas as alterações feitas nele desde que foi carregado pela última vez ou desde que <see cref="M:System.Data.DataSet.AcceptChanges" /> foi chamado.</summary>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">Usando conjuntos de dados no ADO.NET</related>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetChanges">
      <MemberSignature Language="C#" Value="public System.Data.DataSet GetChanges ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.DataSet GetChanges() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.GetChanges" />
      <MemberSignature Language="VB.NET" Value="Public Function GetChanges () As DataSet" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::DataSet ^ GetChanges();" />
      <MemberSignature Language="F#" Value="member this.GetChanges : unit -&gt; System.Data.DataSet" Usage="dataSet.GetChanges " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataSet</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Obtém uma cópia do <see cref="T:System.Data.DataSet" /> que contém todas as alterações feitas nele desde que ele foi carregado ou desde que o <see cref="M:System.Data.DataSet.AcceptChanges" /> foi chamado pela última vez.</summary>
        <returns>Uma cópia das alterações desse <see cref="T:System.Data.DataSet" /> que pode ter ações realizadas nele e posteriormente ser mesclada novamente usando <see cref="M:System.Data.DataSet.Merge(System.Data.DataSet)" />. Se não forem encontradas linhas alteradas, o método retornará <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cria um novo <xref:System.Data.DataSet> que contém uma cópia de todas as linhas no original <xref:System.Data.DataSet> que possuem alterações pendentes. Restrições de relação podem fazer com que linhas inalteradas adicionais a serem adicionados ao novo <xref:System.Data.DataSet> se linhas inalteradas contêm chaves primárias correspondentes a chaves estrangeiras em linhas alteradas. O método retornará `null` se não houver nenhuma linha no original <xref:System.Data.DataSet> que possuem alterações pendentes.  
  
   
  
## Examples  
 O exemplo a seguir cria um <xref:System.Data.DataSet> simples com uma tabela, duas colunas e dez linhas. Dois valores são alterados, e uma linha é adicionada. Um subconjunto dos dados alterados é criado usando o <xref:System.Data.DataSet.GetChanges%2A> método. Depois de reconciliação de erros, uma nova coluna é adicionada a um subconjunto, alterando o esquema. Quando o <xref:System.Data.DataSet.Merge%2A> método for chamado com o `missingSchemaAction` definido como `MissingSchemaAction.Add`, a nova coluna é adicionada ao original <xref:System.Data.DataSet> esquema do objeto.  
  
 [!code-csharp[Classic WebData DataSet.GetChanges Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.GetChanges Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.GetChanges Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.GetChanges Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Data.DataSet.HasChanges" />
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">Usando conjuntos de dados no ADO.NET</related>
      </Docs>
    </Member>
    <Member MemberName="GetChanges">
      <MemberSignature Language="C#" Value="public System.Data.DataSet GetChanges (System.Data.DataRowState rowStates);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.DataSet GetChanges(valuetype System.Data.DataRowState rowStates) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.GetChanges(System.Data.DataRowState)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetChanges (rowStates As DataRowState) As DataSet" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::DataSet ^ GetChanges(System::Data::DataRowState rowStates);" />
      <MemberSignature Language="F#" Value="member this.GetChanges : System.Data.DataRowState -&gt; System.Data.DataSet" Usage="dataSet.GetChanges rowStates" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataSet</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rowStates" Type="System.Data.DataRowState" />
      </Parameters>
      <Docs>
        <param name="rowStates">Um dos valores de <see cref="T:System.Data.DataRowState" />.</param>
        <summary>Obtém uma cópia do <see cref="T:System.Data.DataSet" /> que contém todas as alterações feitas desde o último carregamento ou desde que <see cref="M:System.Data.DataSet.AcceptChanges" /> foi chamado, filtrado por <see cref="T:System.Data.DataRowState" />.</summary>
        <returns>Uma cópia filtrada do <see cref="T:System.Data.DataSet" /> que pode ter ações executadas nela e, mais tarde, ser mesclada novamente com o <see cref="M:System.Data.DataSet.Merge(System.Data.DataSet)" />. Se nenhuma linha do <see cref="T:System.Data.DataRowState" /> desejado for encontrada, o método retornará <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Data.DataSet.GetChanges%2A> método é usado para produzir um segundo <xref:System.Data.DataSet> objeto que contém apenas as alterações introduzidas ao original. Use o `rowStates` argumento para especificar o tipo de alterações para o novo objeto deve incluir.  
  
 Isso retornado a cópia foi projetada para ser mesclada novamente nesse original <xref:System.Data.DataSet>. Restrições de relação podem causar linhas pai marcadas `Unchanged` a serem incluídos. Se não houver linhas de desejado <xref:System.Data.DataRowState> forem encontrados, o <xref:System.Data.DataSet.GetChanges%2A> retorno do método `null`.  
  
   
  
## Examples  
 O exemplo a seguir usa o <xref:System.Data.DataSet.GetChanges%2A> método para criar um segundo <xref:System.Data.DataSet> objeto, que é usado para atualizar uma fonte de dados.  
  
 [!code-csharp[Classic WebData DataSet.GetChanges1 Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.GetChanges1 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.GetChanges1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.GetChanges1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">Usando conjuntos de dados no ADO.NET</related>
      </Docs>
    </Member>
    <Member MemberName="GetDataSetSchema">
      <MemberSignature Language="C#" Value="public static System.Xml.Schema.XmlSchemaComplexType GetDataSetSchema (System.Xml.Schema.XmlSchemaSet schemaSet);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Xml.Schema.XmlSchemaComplexType GetDataSetSchema(class System.Xml.Schema.XmlSchemaSet schemaSet) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.GetDataSetSchema(System.Xml.Schema.XmlSchemaSet)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetDataSetSchema (schemaSet As XmlSchemaSet) As XmlSchemaComplexType" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Xml::Schema::XmlSchemaComplexType ^ GetDataSetSchema(System::Xml::Schema::XmlSchemaSet ^ schemaSet);" />
      <MemberSignature Language="F#" Value="static member GetDataSetSchema : System.Xml.Schema.XmlSchemaSet -&gt; System.Xml.Schema.XmlSchemaComplexType" Usage="System.Data.DataSet.GetDataSetSchema schemaSet" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.Schema.XmlSchemaComplexType</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="schemaSet" Type="System.Xml.Schema.XmlSchemaSet" />
      </Parameters>
      <Docs>
        <param name="schemaSet">O conjunto de esquemas especificado.</param>
        <summary>Obtém uma cópia de <see cref="T:System.Xml.Schema.XmlSchemaSet" /> para DataSet.</summary>
        <returns>Uma cópia de <see cref="T:System.Xml.Schema.XmlSchemaSet" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetObjectData">
      <MemberSignature Language="C#" Value="public virtual void GetObjectData (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void GetObjectData(class System.Runtime.Serialization.SerializationInfo info, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub GetObjectData (info As SerializationInfo, context As StreamingContext)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void GetObjectData(System::Runtime::Serialization::SerializationInfo ^ info, System::Runtime::Serialization::StreamingContext context);" />
      <MemberSignature Language="F#" Value="abstract member GetObjectData : System.Runtime.Serialization.SerializationInfo * System.Runtime.Serialization.StreamingContext -&gt; unit&#xA;override this.GetObjectData : System.Runtime.Serialization.SerializationInfo * System.Runtime.Serialization.StreamingContext -&gt; unit" Usage="dataSet.GetObjectData (info, context)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="info" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="info">Um <see cref="T:System.Runtime.Serialization.SerializationInfo" /> que contém os dados serializados associados a <see cref="T:System.Data.DataSet" />.</param>
        <param name="context">Um <see cref="T:System.Runtime.Serialization.StreamingContext" /> que contém a origem e o destino do fluxo serializado associado a <see cref="T:System.Data.DataSet" />.</param>
        <summary>Popula um objeto de informações de serialização com os dados necessários para serializar o <see cref="T:System.Data.DataSet" />.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">O parâmetro <paramref name="info" /> é <see langword="null" />.</exception>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">Usando conjuntos de dados no ADO.NET</related>
      </Docs>
    </Member>
    <Member MemberName="GetSchemaSerializable">
      <MemberSignature Language="C#" Value="protected virtual System.Xml.Schema.XmlSchema GetSchemaSerializable ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Xml.Schema.XmlSchema GetSchemaSerializable() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.GetSchemaSerializable" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function GetSchemaSerializable () As XmlSchema" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Xml::Schema::XmlSchema ^ GetSchemaSerializable();" />
      <MemberSignature Language="F#" Value="abstract member GetSchemaSerializable : unit -&gt; System.Xml.Schema.XmlSchema&#xA;override this.GetSchemaSerializable : unit -&gt; System.Xml.Schema.XmlSchema" Usage="dataSet.GetSchemaSerializable " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.Schema.XmlSchema</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retorna uma instância <see cref="T:System.Xml.Schema.XmlSchema" /> serializável.</summary>
        <returns>A instância <see cref="T:System.Xml.Schema.XmlSchema" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetSerializationData">
      <MemberSignature Language="C#" Value="protected void GetSerializationData (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void GetSerializationData(class System.Runtime.Serialization.SerializationInfo info, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.GetSerializationData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub GetSerializationData (info As SerializationInfo, context As StreamingContext)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void GetSerializationData(System::Runtime::Serialization::SerializationInfo ^ info, System::Runtime::Serialization::StreamingContext context);" />
      <MemberSignature Language="F#" Value="member this.GetSerializationData : System.Runtime.Serialization.SerializationInfo * System.Runtime.Serialization.StreamingContext -&gt; unit" Usage="dataSet.GetSerializationData (info, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="info" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="info">A instância <see cref="T:System.Runtime.Serialization.SerializationInfo" />.</param>
        <param name="context">O contexto de streaming.</param>
        <summary>Desserializa os dados da tabela do fluxo XML ou binário.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetXml">
      <MemberSignature Language="C#" Value="public string GetXml ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetXml() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.GetXml" />
      <MemberSignature Language="VB.NET" Value="Public Function GetXml () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetXml();" />
      <MemberSignature Language="F#" Value="member this.GetXml : unit -&gt; string" Usage="dataSet.GetXml " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retorna a representação XML dos dados armazenados no <see cref="T:System.Data.DataSet" />.</summary>
        <returns>Uma cadeia de caracteres que é uma representação dos dados armazenados no <see cref="T:System.Data.DataSet" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Chamar esse método é idêntico ao chamar <xref:System.Data.DataSet.WriteXml%2A> com <xref:System.Data.XmlWriteMode> definido como <xref:System.Data.XmlWriteMode.IgnoreSchema>.  
  
 <xref:System.Data.DataSet.GetXml%2A> Retorna o XML como uma cadeia de caracteres e, portanto, requer mais sobrecarga do que <xref:System.Data.DataSet.WriteXml%2A> para gravar um arquivo XML.  
  
 Se você compilar um <xref:System.Data.DataSet> usando inferência de esquema e serializar usando serviços da Web ou XML, a ordenação de coluna pode ser alterada.  
  
   
  
## Examples  
 O exemplo a seguir cria uma <xref:System.Data.DataSet> e <xref:System.Data.DataTable>, adiciona dados de exemplo e, em seguida, exibe os dados em formato XML.  
  
 [!code-csharp[Classic WebData DataSet.GetXml Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.GetXml Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.GetXml Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.GetXml Example/VB/source.vb#1)]  
  
 Este exemplo demonstra como gravar dados em um arquivo XML de um conjunto de dados e ler dados no conjunto de dados de XML. Este exemplo criar um conjunto de dados com duas tabelas, use duas maneiras de exportar um conjunto de dados para os arquivos XML (WriteXml e GetXml) e usar duas maneiras (ReadXml e InferXmlSchema) para importar um conjunto de dados de arquivos XML.  
  
 Antes de compilar e executar o exemplo, você precisará criar quatro arquivos XML no diretório de exemplo. Primeiro, crie ElementsWithAttributes.xml:  
  
```xml  
<MySchool>  
  <Course CourseID="C1045" Year="2012"  Title="Calculus" Credits="4" DepartmentID="7">New</Course>  
  <Course CourseID="C1061" Year="2012"  Title="Physics" Credits="4" DepartmentID="1" />  
  <Department DepartmentID="1" Name="Engineering" Budget="350000" StartDate="2007-09-01T00:00:00+08:00" Administrator="2" />  
  <Department DepartmentID="7" Name="Mathematics" Budget="250024" StartDate="2007-09-01T00:00:00+08:00" Administrator="3">Cancelled</Department>  
</MySchool>  
```  
  
 Em seguida, crie ElementsWithChildElementsxml.xml:  
  
```xml  
<MySchool>  
  <Course>  
    <CourseID>C1045</CourseID>  
    <Year>2012</Year>  
    <Title>Calculus</Title>  
    <Credits>4</Credits>  
    <DepartmentID>7</DepartmentID>  
  </Course>  
  <Course>  
    <CourseID>C1061</CourseID>  
    <Year>2012</Year>  
    <Title>Physics</Title>  
    <Credits>4</Credits>  
    <DepartmentID>1</DepartmentID>  
  </Course>  
  <Course>  
    <CourseID>C2021</CourseID>  
    <Year>2012</Year>  
    <Title>Composition</Title>  
    <Credits>3</Credits>  
    <DepartmentID>2</DepartmentID>  
  </Course>  
  <Course>  
    <CourseID>C2042</CourseID>  
    <Year>2012</Year>  
    <Title>Literature</Title>  
    <Credits>4</Credits>  
    <DepartmentID>2</DepartmentID>  
  </Course>  
  <Department>  
    <DepartmentID>1</DepartmentID>  
    <Name>Engineering</Name>  
    <Budget>350000</Budget>  
    <StartDate>2007-09-01T00:00:00+08:00</StartDate>  
    <Administrator>2</Administrator>  
  </Department>  
  <Department>  
    <DepartmentID>2</DepartmentID>  
    <Name>English</Name>  
    <Budget>120000</Budget>  
    <StartDate>2007-09-01T00:00:00+08:00</StartDate>  
    <Administrator>6</Administrator>  
  </Department>  
  <Department>  
    <DepartmentID>4</DepartmentID>  
    <Name>Economics</Name>  
    <Budget>200000</Budget>  
    <StartDate>2007-09-01T00:00:00+08:00</StartDate>  
    <Administrator>4</Administrator>  
  </Department>  
  <Department>  
    <DepartmentID>7</DepartmentID>  
    <Name>Mathematics</Name>  
    <Budget>250024</Budget>  
    <StartDate>2007-09-01T00:00:00+08:00</StartDate>  
    <Administrator>3</Administrator>  
  </Department>  
</MySchool>  
```  
  
 Agora crie ElementsWithOnlyAttributes.xml:  
  
```xml
<MySchool>  
  <Course CourseID="C1045" Year="2012"  Title="Calculus" Credits="4" DepartmentID="7" />  
  <Course CourseID="C1061" Year="2012"  Title="Physics" Credits="4" DepartmentID="1" />  
  <Department DepartmentID="1" Name="Engineering" Budget="350000" StartDate="2007-09-01T00:00:00+08:00" Administrator="2" />  
  <Department DepartmentID="7" Name="Mathematics" Budget="250024" StartDate="2007-09-01T00:00:00+08:00" Administrator="3" />  
</MySchool>  
```  
  
 E, finalmente, crie RepeatingElements.xml:  
  
```xml
<MySchool>  
  <Course>C1045</Course>  
  <Course>C1061</Course>  
  <Department>Engineering</Department>   
  <Department>Mathematics</Department>  
</MySchool>  
```  
  
 Agora você pode compilar e executar o seguinte código-fonte.  [Como Store dados do conjunto de dados no arquivo XML](https://code.msdn.microsoft.com/How-to-Store-Data-of-7b9710f3) tem projetos Visual Basic e c# para este exemplo.  
  
```csharp
using System;  
using System.Data;  
using System.IO;  
using System.Text;  
using System.Xml;  
  
// Use WriteXml method to export the dataset.  
static class DataTableHelper {  
   public static void WriteDataSetToXML(DataSet dataset, String xmlFileName) {  
      using (FileStream fsWriterStream = new FileStream(xmlFileName, FileMode.Create)) {  
         using (XmlTextWriter xmlWriter = new XmlTextWriter(fsWriterStream, Encoding.Unicode)) {  
            dataset.WriteXml(xmlWriter, XmlWriteMode.WriteSchema);  
            Console.WriteLine("Write {0} to the File {1}.", dataset.DataSetName, xmlFileName);  
            Console.WriteLine();  
         }  
      }  
   }  
  
   // Use GetXml method to get the XML data of the dataset and then export to the file.  
   public static void GetXMLFromDataSet(DataSet dataset, String xmlFileName) {  
      using (StreamWriter writer = new StreamWriter(xmlFileName)) {  
         writer.WriteLine(dataset.GetXml());  
         Console.WriteLine("Get Xml data from {0} and write to the File {1}.", dataset.DataSetName, xmlFileName);  
         Console.WriteLine();  
      }  
   }  
  
   // Use ReadXml method to import the dataset from the dataset.  
   public static void ReadXmlIntoDataSet(DataSet newDataSet, String xmlFileName) {  
      using (FileStream fsReaderStream = new FileStream(xmlFileName, FileMode.Open)) {  
         using (XmlTextReader xmlReader = new XmlTextReader(fsReaderStream)) {  
            newDataSet.ReadXml(xmlReader, XmlReadMode.ReadSchema);  
         }  
      }  
   }  
  
   // Display the columns and value of DataSet.  
   public static void ShowDataSet(DataSet dataset) {  
      foreach (DataTable table in dataset.Tables) {  
         Console.WriteLine("Table {0}:", table.TableName);  
         ShowDataTable(table);  
      }  
   }  
  
   // Display the columns and value of DataTable.  
   private static void ShowDataTable(DataTable table) {  
      foreach (DataColumn col in table.Columns) {  
         Console.Write("{0,-14}", col.ColumnName);  
      }  
      Console.WriteLine("{0,-14}", "");  
  
      foreach (DataRow row in table.Rows) {  
         if (row.RowState == DataRowState.Deleted) {  
            foreach (DataColumn col in table.Columns) {  
               if (col.DataType.Equals(typeof(DateTime))) {  
                  Console.Write("{0,-14:d}", row[col, DataRowVersion.Original]);  
               }  
               else if (col.DataType.Equals(typeof(Decimal))) {  
                  Console.Write("{0,-14:C}", row[col, DataRowVersion.Original]);  
               }  
               else {  
                  Console.Write("{0,-14}", row[col, DataRowVersion.Original]);  
               }  
            }  
         }  
         else {  
            foreach (DataColumn col in table.Columns) {  
               if (col.DataType.Equals(typeof(DateTime))) {  
                  Console.Write("{0,-14:d}", row[col]);  
               }  
               else if (col.DataType.Equals(typeof(Decimal))) {  
                  Console.Write("{0,-14:C}", row[col]);  
               }  
               else {  
                  Console.Write("{0,-14}", row[col]);  
               }  
            }  
         }  
         Console.WriteLine("{0,-14}", "");  
      }  
   }  
  
   // Display the columns of DataSet.  
   public static void ShowDataSetSchema(DataSet dataSet) {  
      Console.WriteLine("{0} contains the following tables:", dataSet.DataSetName);  
      foreach (DataTable table in dataSet.Tables) {  
         Console.WriteLine("   Table {0} contains the following columns:", table.TableName);  
         ShowDataTableSchema(table);  
      }  
   }  
  
   // Display the columns of DataTable  
   private static void ShowDataTableSchema(DataTable table) {  
      String columnString = "";  
      foreach (DataColumn col in table.Columns) {  
         columnString += col.ColumnName + "   ";  
      }  
      Console.WriteLine(columnString);  
   }  
}  
  
class Program {  
   static void Main(string[] args) {  
      // Create the DataSet  
      DataSet school = new DataSet("MySchool");  
      DataTable course = CreateCourse();  
      DataTable department = CreateDepartment();  
      school.Tables.Add(course);  
      school.Tables.Add(department);  
  
      // Define the constraint between the tables.  
      ForeignKeyConstraint courseDepartFK = new ForeignKeyConstraint("CourseDepartFK", department.Columns["DepartmentID"], course.Columns["DepartmentID"]);  
      courseDepartFK.DeleteRule = Rule.Cascade;  
      courseDepartFK.UpdateRule = Rule.Cascade;  
      courseDepartFK.AcceptRejectRule = AcceptRejectRule.None;  
      course.Constraints.Add(courseDepartFK);  
  
      InsertDepartments(department);  
      InsertCourses(course);  
  
      // Export the dataset to the XML file.  
      Console.WriteLine("Data of the whole DataSet {0}", school.DataSetName);  
      DataTableHelper.ShowDataSet(school);  
  
      String xmlWithSchemaFileName = "WriterXMLWithSchema.xml";  
      String xmlGetDataFileName = "GetXML.xml";  
  
      // Use two ways to export the dataset to the Xml file.  
      DataTableHelper.WriteDataSetToXML(school, xmlWithSchemaFileName);  
      DataTableHelper.GetXMLFromDataSet(school, xmlGetDataFileName);  
  
      // Import the dataset from the XML file.  
      // Use two ways to import the dataset from the Xml file.  
      Console.WriteLine("Read Xml document into a new DataSet:");  
      DataSet newSchool = new DataSet("NewSchool");  
      DataTableHelper.ReadXmlIntoDataSet(newSchool, xmlWithSchemaFileName);  
      DataTableHelper.ShowDataSetSchema(newSchool);  
      Console.WriteLine();  
  
      Console.WriteLine("Infer a schema for a DataSet from an XML document:");  
      InferDataSetSchemaFromXml();  
  
      Console.WriteLine("Press any key to exit.");  
      Console.ReadKey();  
   }  
  
   static DataTable CreateCourse() {  
      DataTable course = new DataTable("Course");  
      DataColumn[] cols ={  
                              new DataColumn("CourseID",typeof(String)),  
                              new DataColumn("Year",typeof(Int32)),  
                              new DataColumn("Title",typeof(String)),  
                              new DataColumn("Credits",typeof(Int32)),  
                              new DataColumn("DepartmentID",typeof(Int32))};  
      course.Columns.AddRange(cols);  
  
      course.PrimaryKey = new DataColumn[] { course.Columns["CourseID"], course.Columns["Year"] };  
  
      return course;  
   }  
  
   static DataTable CreateDepartment() {  
      DataTable department = new DataTable("Department");  
      DataColumn[] cols = {   
                                new DataColumn("DepartmentID", typeof(Int32)),  
                                new DataColumn("Name",typeof(String)),  
                                new DataColumn("Budget",typeof(Decimal)),  
                                new DataColumn("StartDate",typeof(DateTime)),  
                                new DataColumn("Administrator",typeof(Int32))};  
      department.Columns.AddRange(cols);  
  
      department.PrimaryKey = new DataColumn[] { department.Columns["DepartmentID"] };  
  
      return department;  
   }  
  
   static void InsertDepartments(DataTable department) {  
      Object[] rows = {   
                            new Object[]{1,"Engineering",350000.00,new DateTime(2007,9,1),2},  
                            new Object[]{2,"English",120000.00,new DateTime(2007,9,1),6},  
                            new Object[]{4,"Economics",200000.00,new DateTime(2007,9,1),4},  
                            new Object[]{7,"Mathematics",250024.00,new DateTime(2007,9,1),3}};  
  
      foreach (Object[] row in rows) {  
         department.Rows.Add(row);  
      }  
   }  
  
   static void InsertCourses(DataTable course) {  
      Object[] rows ={  
                               new Object[]{"C1045",2012,"Calculus",4,7},  
                               new Object[]{"C1061",2012,"Physics",4,1},  
                               new Object[]{"C2021",2012,"Composition",3,2},  
                               new Object[]{"C2042",2012,"Literature",4,2}};  
  
      foreach (Object[] row in rows) {  
         course.Rows.Add(row);  
      }  
   }  
  
   // Display the results of inferring schema from four types of XML structures  
   private static void InferDataSetSchemaFromXml() {  
      String[] xmlFileNames = {   
  
                                    @"ElementsWithOnlyAttributes.xml",   
                                    @"ElementsWithAttributes.xml",  
                                    @"RepeatingElements.xml",   
                                    @"ElementsWithChildElements.xml" };  
  
      foreach (String xmlFileName in xmlFileNames) {  
         Console.WriteLine("Result of {0}", Path.GetFileNameWithoutExtension(xmlFileName));  
         DataSet newSchool = new DataSet();  
         newSchool.InferXmlSchema(xmlFileName, null);  
         DataTableHelper.ShowDataSetSchema(newSchool);  
         Console.WriteLine();  
      }  
   }  
}  
```  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">Usando conjuntos de dados no ADO.NET</related>
      </Docs>
    </Member>
    <Member MemberName="GetXmlSchema">
      <MemberSignature Language="C#" Value="public string GetXmlSchema ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetXmlSchema() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.GetXmlSchema" />
      <MemberSignature Language="VB.NET" Value="Public Function GetXmlSchema () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetXmlSchema();" />
      <MemberSignature Language="F#" Value="member this.GetXmlSchema : unit -&gt; string" Usage="dataSet.GetXmlSchema " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retorna o Esquema XML para a representação XML dos dados armazenados no <see cref="T:System.Data.DataSet" />.</summary>
        <returns>Cadeia de caracteres que é o Esquema XML para a representação XML dos dados armazenados no <see cref="T:System.Data.DataSet" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Chamar esse método é idêntico ao chamar <xref:System.Data.DataSet.WriteXmlSchema%2A>, exceto que somente o esquema principal é gravado.  
  
 <xref:System.Data.DataSet.GetXmlSchema%2A> Retorna o XML como uma cadeia de caracteres e, portanto, requer mais sobrecarga do que <xref:System.Data.DataSet.WriteXmlSchema%2A> para gravar um arquivo XML.  
  
 Se você compilar um <xref:System.Data.DataSet> usando inferência de esquema e serializar usando serviços da Web ou XML, a ordenação de coluna pode ser alterada.  
  
   
  
## Examples  
 O exemplo a seguir cria uma <xref:System.Data.DataSet> e <xref:System.Data.DataTable>e, em seguida, exibe o esquema no formato XML.  
  
 [!code-csharp[Classic WebData DataSet.GetXmlSchema Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.GetXmlSchema Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.GetXmlSchema Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.GetXmlSchema Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">Usando conjuntos de dados no ADO.NET</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="HasChanges">
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Obtém um valor que indica se o <see cref="T:System.Data.DataSet" /> tem alterações, incluindo linhas novas, excluídas ou modificadas.</summary>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">Usando conjuntos de dados no ADO.NET</related>
      </Docs>
    </MemberGroup>
    <Member MemberName="HasChanges">
      <MemberSignature Language="C#" Value="public bool HasChanges ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool HasChanges() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.HasChanges" />
      <MemberSignature Language="VB.NET" Value="Public Function HasChanges () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool HasChanges();" />
      <MemberSignature Language="F#" Value="member this.HasChanges : unit -&gt; bool" Usage="dataSet.HasChanges " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Obtém um valor que indica se o <see cref="T:System.Data.DataSet" /> tem alterações, incluindo linhas novas, excluídas ou modificadas.</summary>
        <returns><see langword="true" /> se o <see cref="T:System.Data.DataSet" /> tiver alterações; caso contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O exemplo a seguir usa o <xref:System.Data.DataSet.GetChanges%2A> método para criar um segundo <xref:System.Data.DataSet> objeto que é usado para atualizar uma fonte de dados.  
  
 [!code-csharp[Classic WebData DataSet.HasChanges Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.HasChanges Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.HasChanges Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.HasChanges Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">Usando conjuntos de dados no ADO.NET</related>
      </Docs>
    </Member>
    <Member MemberName="HasChanges">
      <MemberSignature Language="C#" Value="public bool HasChanges (System.Data.DataRowState rowStates);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool HasChanges(valuetype System.Data.DataRowState rowStates) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.HasChanges(System.Data.DataRowState)" />
      <MemberSignature Language="VB.NET" Value="Public Function HasChanges (rowStates As DataRowState) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool HasChanges(System::Data::DataRowState rowStates);" />
      <MemberSignature Language="F#" Value="member this.HasChanges : System.Data.DataRowState -&gt; bool" Usage="dataSet.HasChanges rowStates" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rowStates" Type="System.Data.DataRowState" />
      </Parameters>
      <Docs>
        <param name="rowStates">Um dos valores de <see cref="T:System.Data.DataRowState" />.</param>
        <summary>Obtém um valor que indica se o <see cref="T:System.Data.DataSet" /> tem alterações, incluindo linhas novas, excluídas ou modificadas, filtradas por <see cref="T:System.Data.DataRowState" />.</summary>
        <returns><see langword="true" /> se o <see cref="T:System.Data.DataSet" /> tiver alterações; caso contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Examine os <xref:System.Data.DataSet.HasChanges%2A> propriedade do `DataSet` antes de invocar o <xref:System.Data.DataSet.GetChanges%2A> método.  
  
   
  
## Examples  
 O exemplo a seguir usa o <xref:System.Data.DataSet.GetChanges%2A> método para criar um segundo <xref:System.Data.DataSet> objeto, que é usado para atualizar uma fonte de dados.  
  
 [!code-csharp[Classic WebData DataSet.GetChanges1 Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.GetChanges1 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.GetChanges1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.GetChanges1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">Usando conjuntos de dados no ADO.NET</related>
      </Docs>
    </Member>
    <Member MemberName="HasErrors">
      <MemberSignature Language="C#" Value="public bool HasErrors { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool HasErrors" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataSet.HasErrors" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property HasErrors As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool HasErrors { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.HasErrors : bool" Usage="System.Data.DataSet.HasErrors" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.Data.DataSysDescription("DataSetHasErrorsDescr")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém um valor que indica se há erros em qualquer um dos objetos <see cref="T:System.Data.DataTable" /> nesse <see cref="T:System.Data.DataSet" />.</summary>
        <value><see langword="true" /> Se alguma tabela contiver um erro; Caso contrário, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cada <xref:System.Data.DataTable> em um <xref:System.Data.DataSet> também tem um <xref:System.Data.DataTable.HasErrors%2A> propriedade. Use o `HasErrors` propriedade do `DataSet` primeiro para determinar se alguma tabela tiver erros, antes de verificar individuais <xref:System.Data.DataTable> objetos. Se um `DataTable` tiver erros, o <xref:System.Data.DataTable.GetErrors%2A> método retorna uma matriz de <xref:System.Data.DataRow> objetos que contém os erros.  
  
   
  
## Examples  
 O exemplo a seguir usa o <xref:System.Data.DataSet.HasErrors%2A> propriedade para determinar se um <xref:System.Data.DataSet> objeto contém erros. Nesse caso, os erros para cada <xref:System.Data.DataRow> em cada <xref:System.Data.DataTable> são impressos.  
  
 [!code-csharp[Classic WebData DataSet.HasErrors Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.HasErrors Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.HasErrors Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.HasErrors Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">Usando conjuntos de dados no ADO.NET</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="InferXmlSchema">
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Aplica o esquema XML ao <see cref="T:System.Data.DataSet" />.</summary>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">Usando conjuntos de dados no ADO.NET</related>
      </Docs>
    </MemberGroup>
    <Member MemberName="InferXmlSchema">
      <MemberSignature Language="C#" Value="public void InferXmlSchema (System.IO.Stream stream, string[] nsArray);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void InferXmlSchema(class System.IO.Stream stream, string[] nsArray) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.InferXmlSchema(System.IO.Stream,System.String[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void InferXmlSchema(System::IO::Stream ^ stream, cli::array &lt;System::String ^&gt; ^ nsArray);" />
      <MemberSignature Language="F#" Value="member this.InferXmlSchema : System.IO.Stream * string[] -&gt; unit" Usage="dataSet.InferXmlSchema (stream, nsArray)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
        <Parameter Name="nsArray" Type="System.String[]" />
      </Parameters>
      <Docs>
        <param name="stream">O <see langword="Stream" /> do qual ler o esquema.</param>
        <param name="nsArray">Uma matriz de cadeias de caracteres de Uniform Resource Identifier (URI) do namespace a serem excluídas da inferência do esquema.</param>
        <summary>Aplica o esquema XML do <see cref="T:System.IO.Stream" /> especificado ao <see cref="T:System.Data.DataSet" />.</summary>
        <remarks>To be added.</remarks>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">Usando conjuntos de dados no ADO.NET</related>
      </Docs>
    </Member>
    <Member MemberName="InferXmlSchema">
      <MemberSignature Language="C#" Value="public void InferXmlSchema (System.IO.TextReader reader, string[] nsArray);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void InferXmlSchema(class System.IO.TextReader reader, string[] nsArray) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.InferXmlSchema(System.IO.TextReader,System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub InferXmlSchema (reader As TextReader, nsArray As String())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void InferXmlSchema(System::IO::TextReader ^ reader, cli::array &lt;System::String ^&gt; ^ nsArray);" />
      <MemberSignature Language="F#" Value="member this.InferXmlSchema : System.IO.TextReader * string[] -&gt; unit" Usage="dataSet.InferXmlSchema (reader, nsArray)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.IO.TextReader" />
        <Parameter Name="nsArray" Type="System.String[]" />
      </Parameters>
      <Docs>
        <param name="reader">O <see langword="TextReader" /> do qual ler o esquema.</param>
        <param name="nsArray">Uma matriz de cadeias de caracteres de Uniform Resource Identifier (URI) do namespace a serem excluídas da inferência do esquema.</param>
        <summary>Aplica o esquema XML do <see cref="T:System.IO.TextReader" /> especificado ao <see cref="T:System.Data.DataSet" />.</summary>
        <remarks>To be added.</remarks>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">Usando conjuntos de dados no ADO.NET</related>
      </Docs>
    </Member>
    <Member MemberName="InferXmlSchema">
      <MemberSignature Language="C#" Value="public void InferXmlSchema (string fileName, string[] nsArray);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void InferXmlSchema(string fileName, string[] nsArray) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.InferXmlSchema(System.String,System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub InferXmlSchema (fileName As String, nsArray As String())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void InferXmlSchema(System::String ^ fileName, cli::array &lt;System::String ^&gt; ^ nsArray);" />
      <MemberSignature Language="F#" Value="member this.InferXmlSchema : string * string[] -&gt; unit" Usage="dataSet.InferXmlSchema (fileName, nsArray)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
        <Parameter Name="nsArray" Type="System.String[]" />
      </Parameters>
      <Docs>
        <param name="fileName">O nome do arquivo (incluindo o caminho) do qual o esquema é lido.</param>
        <param name="nsArray">Uma matriz de cadeias de caracteres de Uniform Resource Identifier (URI) do namespace a serem excluídas da inferência do esquema.</param>
        <summary>Aplica o esquema XML do arquivo especificado no <see cref="T:System.Data.DataSet" />.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.Security.SecurityException"><see cref="T:System.Security.Permissions.FileIOPermission" /> não é definido como <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">para ler e gravar arquivos. Enumeração associada: <see cref="T:System.Security.Permissions.FileIOPermissionAccess" />.</permission>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">Usando conjuntos de dados no ADO.NET</related>
      </Docs>
    </Member>
    <Member MemberName="InferXmlSchema">
      <MemberSignature Language="C#" Value="public void InferXmlSchema (System.Xml.XmlReader reader, string[] nsArray);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void InferXmlSchema(class System.Xml.XmlReader reader, string[] nsArray) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.InferXmlSchema(System.Xml.XmlReader,System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub InferXmlSchema (reader As XmlReader, nsArray As String())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void InferXmlSchema(System::Xml::XmlReader ^ reader, cli::array &lt;System::String ^&gt; ^ nsArray);" />
      <MemberSignature Language="F#" Value="member this.InferXmlSchema : System.Xml.XmlReader * string[] -&gt; unit" Usage="dataSet.InferXmlSchema (reader, nsArray)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Xml.XmlReader" />
        <Parameter Name="nsArray" Type="System.String[]" />
      </Parameters>
      <Docs>
        <param name="reader">O <see langword="XMLReader" /> do qual ler o esquema.</param>
        <param name="nsArray">Uma matriz de cadeias de caracteres de Uniform Resource Identifier (URI) do namespace a serem excluídas da inferência do esquema.</param>
        <summary>Aplica o esquema XML do <see cref="T:System.Xml.XmlReader" /> especificado ao <see cref="T:System.Data.DataSet" />.</summary>
        <remarks>To be added.</remarks>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">Usando conjuntos de dados no ADO.NET</related>
      </Docs>
    </Member>
    <Member MemberName="Initialized">
      <MemberSignature Language="C#" Value="public event EventHandler Initialized;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Initialized" />
      <MemberSignature Language="DocId" Value="E:System.Data.DataSet.Initialized" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Initialized As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event EventHandler ^ Initialized;" />
      <MemberSignature Language="F#" Value="member this.Initialized : EventHandler " Usage="member this.Initialized : System.EventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.ComponentModel.ISupportInitializeNotification.Initialized</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ocorre após o <see cref="T:System.Data.DataSet" /> ser inicializado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para obter mais informações, consulte <xref:System.Data.DataSet.IsInitialized%2A>.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">Usando conjuntos de dados no ADO.NET</related>
      </Docs>
    </Member>
    <Member MemberName="InitializeDerivedDataSet">
      <MemberSignature Language="C#" Value="protected virtual void InitializeDerivedDataSet ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void InitializeDerivedDataSet() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.InitializeDerivedDataSet" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub InitializeDerivedDataSet ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void InitializeDerivedDataSet();" />
      <MemberSignature Language="F#" Value="abstract member InitializeDerivedDataSet : unit -&gt; unit&#xA;override this.InitializeDerivedDataSet : unit -&gt; unit" Usage="dataSet.InitializeDerivedDataSet " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Desserialize todos os dados de tabelas do DataSet do fluxo XML ou binário.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsBinarySerialized">
      <MemberSignature Language="C#" Value="protected bool IsBinarySerialized (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance bool IsBinarySerialized(class System.Runtime.Serialization.SerializationInfo info, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.IsBinarySerialized(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="VB.NET" Value="Protected Function IsBinarySerialized (info As SerializationInfo, context As StreamingContext) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; bool IsBinarySerialized(System::Runtime::Serialization::SerializationInfo ^ info, System::Runtime::Serialization::StreamingContext context);" />
      <MemberSignature Language="F#" Value="member this.IsBinarySerialized : System.Runtime.Serialization.SerializationInfo * System.Runtime.Serialization.StreamingContext -&gt; bool" Usage="dataSet.IsBinarySerialized (info, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="info" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="info">O objeto <see cref="T:System.Runtime.Serialization.SerializationInfo" />.</param>
        <param name="context">O objeto <see cref="T:System.Runtime.Serialization.StreamingContext" />.</param>
        <summary>Inspeciona o formato da representação serializada do <see langword="DataSet" />.</summary>
        <returns><see langword="true" /> se o <see cref="T:System.Runtime.Serialization.SerializationInfo" /> especificado representar um <see langword="DataSet" /> serializado em seu formato binário, caso contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse membro oferece suporte à infraestrutura .NET Framework e não se destina à utilização diretamente no seu código.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsInitialized">
      <MemberSignature Language="C#" Value="public bool IsInitialized { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsInitialized" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataSet.IsInitialized" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsInitialized As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsInitialized { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsInitialized : bool" Usage="System.Data.DataSet.IsInitialized" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.ComponentModel.ISupportInitializeNotification.IsInitialized</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém um valor que indica se o <see cref="T:System.Data.DataSet" /> é inicializado.</summary>
        <value><see langword="true" /> para indicar o componente concluiu a inicialização; Caso contrário, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Retorna o status do <xref:System.Data.DataSet> enquanto ele está sendo construído, por exemplo, o Visual Studio. O <xref:System.Data.DataSet.BeginInit%2A> método define-a como `false` e <xref:System.Data.DataSet.EndInit%2A> método define como `true`.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">Usando conjuntos de dados no ADO.NET</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Load">
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Preenche um <see cref="T:System.Data.DataSet" /> com valores de uma fonte de dados usando o <see cref="T:System.Data.IDataReader" />fornecido.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O método <xref:System.Data.DataTable.Load%2A> fornece uma técnica para preencher um único <xref:System.Data.DataTable> com dados, recuperado a partir de uma instância <xref:System.Data.IDataReader>. Esse método fornece a mesma funcionalidade, mas permite que você carregue vários conjuntos de resultados de uma `IDataReader` em várias tabelas dentro de um `DataSet`.  
  
 Se o `DataSet` já contiver linhas, os dados de entrada da fonte de dados serão mesclados com as linhas existentes.  
  
 O `Load` método pode ser usado em vários cenários comuns, tudo centralizados em torno de obtenção de dados de uma fonte de dados especificado e adicioná-lo para o contêiner de dados atual (nesse caso, um `DataSet`). Esses cenários descrevem o uso padrão para um `DataSet`, que descreve sua atualização e o comportamento de mesclagem.  
  
 Um `DataSet` sincroniza ou atualiza com uma fonte de dados primário. O `DataSet` rastreia as alterações, permitindo que a sincronização com fonte de dados principal. Além disso, um `DataSet` pode aceitar dados incrementais de um ou mais fontes de dados secundários. O `DataSet` não se responsabiliza por controle de alterações para permitir que a sincronização com a fonte de dados secundário.  
  
 Dadas essas duas fontes de dados hipotéticas, um usuário deve exigir um dos seguintes comportamentos:  
  
-   Inicializar `DataSet` de uma fonte de dados primário. Nesse cenário, o usuário deseja inicializar vazio `DataSet` com valores da fonte de dados primário. Conteúdo da DataTable um ou mais é modificado. Posteriormente, o usuário deseja propagar alterações de volta para a fonte de dados primária.  
  
-   Preservar alterações e ressincronizar a partir da fonte de dados primária. Nesse cenário, o usuário deseja levar a `DataSet` preenchido no cenário anterior e execute uma sincronização incremental com a fonte de dados primário, preservando as modificações feitas na `DataSet`.  
  
-   Feed de dados incremental das fontes de dados secundárias. Nesse cenário, o usuário deseja mesclar alterações de uma ou mais fontes de dados secundárias e propaga essas alterações de volta para a fonte de dados primária.  
  
 O `Load` método possibilita todos esses cenários. Esse método permite que você especifique um parâmetro de opção de carga, que indica como as linhas já em um <xref:System.Data.DataTable> combinar com linhas que está sendo carregadas. A tabela a seguir descreve as três opções de carregamento fornecidas pela enumeração <xref:System.Data.LoadOption>. Em cada caso, a descrição indica o comportamento quando a chave primária de uma linha nos dados de entrada corresponde à chave primária de uma linha existente.  
  
|Carregar Opção|Descrição|  
|-----------------|-----------------|  
|`PreserveChanges` (padrão)|Atualiza a versão original da linha com o valor da linha de entrada.|  
|`OverwriteChanges`|Atualiza as versões atual e original da linha com o valor da linha de entrada.|  
|`Upsert`|Atualiza a versão atual da linha com o valor da linha de entrada.|  
  
 Em geral, as opções `PreserveChanges` e `OverwriteChanges` se destinam a cenários nos quais o usuário precisa sincronizar o `DataSet` e suas alterações com a fonte de dados primária. A opção `Upsert` facilita a agregação de alterações de uma ou mais fontes de dados secundárias.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">Usando conjuntos de dados no ADO.NET</related>
      </Docs>
    </MemberGroup>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public void Load (System.Data.IDataReader reader, System.Data.LoadOption loadOption, params System.Data.DataTable[] tables);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Load(class System.Data.IDataReader reader, valuetype System.Data.LoadOption loadOption, class System.Data.DataTable[] tables) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.Load(System.Data.IDataReader,System.Data.LoadOption,System.Data.DataTable[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Load(System::Data::IDataReader ^ reader, System::Data::LoadOption loadOption, ... cli::array &lt;System::Data::DataTable ^&gt; ^ tables);" />
      <MemberSignature Language="F#" Value="member this.Load : System.Data.IDataReader * System.Data.LoadOption * System.Data.DataTable[] -&gt; unit" Usage="dataSet.Load (reader, loadOption, tables)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Data.IDataReader" />
        <Parameter Name="loadOption" Type="System.Data.LoadOption" />
        <Parameter Name="tables" Type="System.Data.DataTable[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="reader">Um <see cref="T:System.Data.IDataReader" /> que fornece um ou vários conjuntos de resultados.</param>
        <param name="loadOption">Um valor da enumeração <see cref="T:System.Data.LoadOption" /> que indica como as linhas que já estão nas instâncias <see cref="T:System.Data.DataTable" /> em <see cref="T:System.Data.DataSet" /> serão combinadas com linhas de entrada que compartilham a mesma chave primária.</param>
        <param name="tables">Uma matriz de instâncias <see cref="T:System.Data.DataTable" />, da qual o método <see cref="M:System.Data.DataSet.Load(System.Data.IDataReader,System.Data.LoadOption,System.Data.DataTable[])" /> recupera informações de nome e namespace. Cada uma dessas tabelas deve ser um membro do <see cref="T:System.Data.DataTableCollection" /> contido por este <see cref="T:System.Data.DataSet" />.</param>
        <summary>Preenche um <see cref="T:System.Data.DataSet" /> com valores de uma fonte de dados usando o <see cref="T:System.Data.IDataReader" /> fornecido, usando uma matriz de instâncias <see cref="T:System.Data.DataTable" /> para fornecer o esquema e as informações de namespace.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O método <xref:System.Data.DataTable.Load%2A> fornece uma técnica para preencher um único <xref:System.Data.DataTable> com dados, recuperado a partir de uma instância <xref:System.Data.IDataReader>. Esse método fornece a mesma funcionalidade, mas permite que você carregue vários conjuntos de resultados de uma <xref:System.Data.IDataReader> em várias tabelas dentro de um <xref:System.Data.DataSet>.  
  
> [!NOTE]
>  A operação de carregamento falhará com um <xref:System.InvalidOperationException> se qualquer uma das colunas de dados de origem na entrada `reader` são colunas computadas.  
  
 O `loadOption` parâmetro permite que você especifique como você deseja importar os dados para interagir com os dados existentes e pode ser qualquer um dos valores da <xref:System.Data.LoadOption> enumeração. Consulte a documentação para o <xref:System.Data.DataTable> <xref:System.Data.DataTable.Load%2A> método para obter mais informações sobre como usar esse parâmetro.  
  
 O `tables` parâmetro permite que você especifique uma matriz de <xref:System.Data.DataTable> instâncias, que indica a ordem das tabelas correspondentes a cada conjunto de resultados carregados do leitor. O <xref:System.Data.DataSet.Load%2A> método preenchimentos cada fornecidos <xref:System.Data.DataTable> instância com os dados de um único conjunto de resultados do leitor de dados de origem. Depois de cada conjunto de resultados, o <xref:System.Data.DataSet.Load%2A> método passa para o próximo resultado definido no leitor, até que não haja nada mais conjuntos de resultados.  
  
 O esquema de resolução de nome para esse método é o mesmo que seguido de <xref:System.Data.Common.DbDataAdapter.Fill%2A> método da <xref:System.Data.Common.DbDataAdapter> classe.  
  
   
  
## Examples  
 O exemplo a seguir cria um novo <xref:System.Data.DataSet>, adiciona dois <xref:System.Data.DataTable> instâncias para o <xref:System.Data.DataSet>e, em seguida, preenche o <xref:System.Data.DataSet> usando o <xref:System.Data.DataSet.Load%2A> método, recuperação de dados de um <xref:System.Data.DataTableReader> que contém dois conjuntos de resultados. Por fim, o exemplo exibe o conteúdo das tabelas na janela do console.  
  
 [!code-csharp[DataWorks DataSet.LoadTables#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataSet.LoadTables/CS/source.cs#1)]
 [!code-vb[DataWorks DataSet.LoadTables#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataSet.LoadTables/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">Usando conjuntos de dados no ADO.NET</related>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public void Load (System.Data.IDataReader reader, System.Data.LoadOption loadOption, params string[] tables);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Load(class System.Data.IDataReader reader, valuetype System.Data.LoadOption loadOption, string[] tables) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.Load(System.Data.IDataReader,System.Data.LoadOption,System.String[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Load(System::Data::IDataReader ^ reader, System::Data::LoadOption loadOption, ... cli::array &lt;System::String ^&gt; ^ tables);" />
      <MemberSignature Language="F#" Value="member this.Load : System.Data.IDataReader * System.Data.LoadOption * string[] -&gt; unit" Usage="dataSet.Load (reader, loadOption, tables)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Data.IDataReader" />
        <Parameter Name="loadOption" Type="System.Data.LoadOption" />
        <Parameter Name="tables" Type="System.String[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="reader">Um <see cref="T:System.Data.IDataReader" /> que fornece um ou vários conjuntos de resultados.</param>
        <param name="loadOption">Um valor da enumeração <see cref="T:System.Data.LoadOption" /> que indica como as linhas que já estão nas instâncias <see cref="T:System.Data.DataTable" /> dentro de <see langword="DataSet" /> serão combinadas com linhas de entrada que compartilham a mesma chave primária.</param>
        <param name="tables">Uma matriz de cadeias de caracteres da qual o <see langword="Load" /> método recupera informações de nome de tabela.</param>
        <summary>Preenche um <see cref="T:System.Data.DataSet" /> com valores de uma fonte de dados usando o <see cref="T:System.Data.IDataReader" />, usando uma matriz de cadeias de caracteres para fornecer os nomes das tabelas dentro de <see langword="DataSet" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O método <xref:System.Data.DataTable.Load%2A> fornece uma técnica para preencher um único <xref:System.Data.DataTable> com dados, recuperado a partir de uma instância <xref:System.Data.IDataReader>. Esse método fornece a mesma funcionalidade, mas permite que você carregue vários conjuntos de resultados de uma `IDataReader` em várias tabelas dentro de um `DataSet`.  
  
> [!NOTE]
>  A operação de carregamento falhará com um <xref:System.InvalidOperationException> se qualquer uma das colunas de dados de origem na entrada `reader` são colunas computadas.  
  
 O `loadOption` parâmetro permite que você especifique como você deseja importar os dados para interagir com os dados existentes e pode ser qualquer um dos valores da <xref:System.Data.LoadOption> enumeração. Consulte a documentação para o <xref:System.Data.DataTable.Load%2A> método para obter mais informações sobre como usar esse parâmetro.  
  
 O `tables` parâmetro permite que você especifique uma matriz de nomes de tabela, que indica a ordem das tabelas correspondentes a cada conjunto de resultados carregados do leitor. O `Load` método tenta localizar uma tabela dentro do `DataSet` correspondente ao nome encontrado na matriz de nomes de tabela, na ordem. Se uma tabela de correspondência for encontrada, essa tabela é carregada com o conteúdo do conjunto de resultados atual. Se nenhuma tabela correspondente for encontrada, uma tabela é criada usando o nome fornecido na matriz de nomes de tabela e o novo esquema da tabela é inferido do conjunto de resultados. Depois de cada conjunto de resultados, o `Load` método passa para o próximo resultado definido no leitor, até que não haja nada mais conjuntos de resultados.  
  
 O namespace padrão associado `DataSet`, se houver, está associado com cada recém-criados `DataTable`. O esquema de resolução de nome para esse método é o mesmo que seguido de <xref:System.Data.Common.DbDataAdapter.Fill%2A> método da <xref:System.Data.Common.DbDataAdapter> classe.  
  
   
  
## Examples  
 O exemplo de aplicativo de Console a seguir primeiro cria tabelas e carrega dados de um leitor em uma <xref:System.Data.DataSet>, usando o `Load` método. O exemplo, em seguida, adiciona tabelas para uma <xref:System.Data.DataSet> e tenta preencher as tabelas com dados de um <xref:System.Data.DataTableReader>. Neste exemplo, porque os parâmetros passados para o `Load` método indicar um nome de tabela não existir, o `Load` método cria uma nova tabela para coincidir com o nome passado como um parâmetro. Depois que os dados foram carregados, o exemplo exibe o conteúdo de todas as suas tabelas na janela do Console.  
  
 [!code-csharp[DataWorks DataSet.LoadString#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataSet.LoadString/CS/source.cs#1)]
 [!code-vb[DataWorks DataSet.LoadString#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataSet.LoadString/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">Usando conjuntos de dados no ADO.NET</related>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public virtual void Load (System.Data.IDataReader reader, System.Data.LoadOption loadOption, System.Data.FillErrorEventHandler errorHandler, params System.Data.DataTable[] tables);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Load(class System.Data.IDataReader reader, valuetype System.Data.LoadOption loadOption, class System.Data.FillErrorEventHandler errorHandler, class System.Data.DataTable[] tables) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.Load(System.Data.IDataReader,System.Data.LoadOption,System.Data.FillErrorEventHandler,System.Data.DataTable[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Load(System::Data::IDataReader ^ reader, System::Data::LoadOption loadOption, System::Data::FillErrorEventHandler ^ errorHandler, ... cli::array &lt;System::Data::DataTable ^&gt; ^ tables);" />
      <MemberSignature Language="F#" Value="abstract member Load : System.Data.IDataReader * System.Data.LoadOption * System.Data.FillErrorEventHandler * System.Data.DataTable[] -&gt; unit&#xA;override this.Load : System.Data.IDataReader * System.Data.LoadOption * System.Data.FillErrorEventHandler * System.Data.DataTable[] -&gt; unit" Usage="dataSet.Load (reader, loadOption, errorHandler, tables)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Data.IDataReader" />
        <Parameter Name="loadOption" Type="System.Data.LoadOption" />
        <Parameter Name="errorHandler" Type="System.Data.FillErrorEventHandler" />
        <Parameter Name="tables" Type="System.Data.DataTable[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="reader">Um <see cref="T:System.Data.IDataReader" /> que fornece um ou vários conjuntos de resultados.</param>
        <param name="loadOption">Um valor da enumeração <see cref="T:System.Data.LoadOption" /> que indica como as linhas que já estão nas instâncias <see cref="T:System.Data.DataTable" /> em <see cref="T:System.Data.DataSet" /> serão combinadas com linhas de entrada que compartilham a mesma chave primária.</param>
        <param name="errorHandler">Um delegado <see cref="T:System.Data.FillErrorEventHandler" /> a ser chamado quando ocorrer um erro ao carregar os dados.</param>
        <param name="tables">Uma matriz de instâncias <see cref="T:System.Data.DataTable" />, da qual o método <see cref="M:System.Data.DataSet.Load(System.Data.IDataReader,System.Data.LoadOption,System.Data.FillErrorEventHandler,System.Data.DataTable[])" /> recupera informações de nome e namespace.</param>
        <summary>Preenche um <see cref="T:System.Data.DataSet" /> com valores de uma fonte de dados usando o <see cref="T:System.Data.IDataReader" /> fornecido, usando uma matriz de instâncias <see cref="T:System.Data.DataTable" /> para fornecer o esquema e as informações de namespace.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O método <xref:System.Data.DataTable.Load%2A> fornece uma técnica para preencher um único <xref:System.Data.DataTable> com dados, recuperado a partir de uma instância <xref:System.Data.IDataReader>. Esse método fornece a mesma funcionalidade, mas permite que você carregue vários conjuntos de resultados de uma <xref:System.Data.IDataReader> em várias tabelas dentro de um <xref:System.Data.DataSet>.  
  
> [!NOTE]
>  A operação de carregamento falhará com um <xref:System.InvalidOperationException> se qualquer uma das colunas de dados de origem na entrada `reader` são colunas computadas.  
  
 O `loadOption` parâmetro permite que você especifique como você deseja importar os dados para interagir com os dados existentes e pode ser qualquer um dos valores da <xref:System.Data.LoadOption> enumeração. Consulte a documentação para o <xref:System.Data.DataTable> <xref:System.Data.DataTable.Load%2A> método para obter mais informações sobre como usar esse parâmetro.  
  
 O `errorHandler` parâmetro é um <xref:System.Data.FillErrorEventHandler> delegado que se refere a um procedimento que é chamado quando ocorre um erro ao carregar dados. O <xref:System.Data.FillErrorEventArgs> parâmetro passado ao procedimento fornece as propriedades que permitem que você recupere informações sobre o erro ocorreu, a linha atual de dados, e o <xref:System.Data.DataTable> sendo preenchido. Usando esse mecanismo de delegado, em vez de um bloco try/catch mais simples, permite que você determine o erro, lidar com a situação e continuar processando se desejar. O <xref:System.Data.FillErrorEventArgs> parâmetro fornece um <xref:System.Data.FillErrorEventArgs.Continue%2A> propriedade: defina essa propriedade como `true` para indicar que você tratou o erro e quiser continuar o processamento; defina a propriedade como `false` para indicar que você deseja interromper o processamento. Lembre-se que definir a propriedade como `false` faz com que o código que disparou o problema para lançar uma exceção.  
  
 O `tables` parâmetro permite que você especifique uma matriz de <xref:System.Data.DataTable> instâncias, que indica a ordem das tabelas correspondentes a cada conjunto de resultados carregados do leitor. O <xref:System.Data.DataSet.Load%2A> método preenchimentos cada fornecidos <xref:System.Data.DataTable> instância com os dados de um único conjunto de resultados do leitor de dados de origem. Depois de cada conjunto de resultados, o <xref:System.Data.DataSet.Load%2A> método passa para o próximo resultado definido no leitor, até que não haja nada mais conjuntos de resultados.  
  
 O esquema de resolução de nome para esse método é o mesmo que seguido de <xref:System.Data.Common.DbDataAdapter.Fill%2A> método da <xref:System.Data.Common.DbDataAdapter> classe.  
  
   
  
## Examples  
 O exemplo a seguir adiciona uma tabela para uma <xref:System.Data.DataSet>e, em seguida, tenta usar o <xref:System.Data.DataSet.Load%2A> método para carregar dados de um <xref:System.Data.DataTableReader> que contém um esquema incompatível. Em vez de interceptar o erro, este exemplo usa um <xref:System.Data.FillErrorEventHandler> delegado para investigar e tratar o erro. A saída é exibida na janela do console.  
  
 [!code-csharp[DataWorks DataSet.Load#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataSet.Load/CS/source.cs#1)]
 [!code-vb[DataWorks DataSet.Load#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataSet.Load/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">Usando conjuntos de dados no ADO.NET</related>
      </Docs>
    </Member>
    <Member MemberName="Locale">
      <MemberSignature Language="C#" Value="public System.Globalization.CultureInfo Locale { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Globalization.CultureInfo Locale" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataSet.Locale" />
      <MemberSignature Language="VB.NET" Value="Public Property Locale As CultureInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Globalization::CultureInfo ^ Locale { System::Globalization::CultureInfo ^ get(); void set(System::Globalization::CultureInfo ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Locale : System.Globalization.CultureInfo with get, set" Usage="System.Data.DataSet.Locale" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.Data.DataSysDescription("DataSetLocaleDescr")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Globalization.CultureInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define as informações de localidade usadas para comparar cadeias de caracteres na tabela.</summary>
        <value>Um <see cref="T:System.Globalization.CultureInfo" /> que contém dados sobre a localidade do computador do usuário. O padrão é <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Data.DataSet.Locale%2A> propriedade especifica a localidade para a qual a classificação se aplica.  
  
 Por padrão, definindo a <xref:System.Data.DataSet.Locale%2A> para um <xref:System.Data.DataSet> também define o <xref:System.Data.DataSet.Locale%2A> para cada <xref:System.Data.DataTable> objeto em que `DataSet` com o mesmo valor.  
  
> [!NOTE]
>  Nas colunas que contêm expressões, o <xref:System.StringComparison.InvariantCulture> é usado. O <xref:System.StringComparison.CurrentCulture> será ignorado.  
  
   
  
## Examples  
 O exemplo a seguir obtém a <xref:System.Globalization.CultureInfo> para um <xref:System.Data.DataSet> e imprime a <xref:System.Globalization.CultureInfo.DisplayName%2A> e <xref:System.Globalization.CultureInfo.EnglishName%2A> propriedades.  
  
 [!code-vb[Classic WebData DataSet.Locale Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.Locale Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">Usando conjuntos de dados no ADO.NET</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Merge">
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Mescla um <see cref="T:System.Data.DataSet" />, <see cref="T:System.Data.DataTable" /> ou matriz de objetos <see cref="T:System.Data.DataRow" /> no <see langword="DataSet" /> ou <see langword="DataTable" /> atual.</summary>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">Usando conjuntos de dados no ADO.NET</related>
      </Docs>
    </MemberGroup>
    <Member MemberName="Merge">
      <MemberSignature Language="C#" Value="public void Merge (System.Data.DataRow[] rows);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Merge(class System.Data.DataRow[] rows) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.Merge(System.Data.DataRow[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub Merge (rows As DataRow())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Merge(cli::array &lt;System::Data::DataRow ^&gt; ^ rows);" />
      <MemberSignature Language="F#" Value="member this.Merge : System.Data.DataRow[] -&gt; unit" Usage="dataSet.Merge rows" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rows" Type="System.Data.DataRow[]" />
      </Parameters>
      <Docs>
        <param name="rows">A matriz de objetos <see langword="DataRow" /> a serem mesclados no <see langword="DataSet" />.</param>
        <summary>Mescla uma matriz de objetos <see cref="T:System.Data.DataRow" /> no <see cref="T:System.Data.DataSet" /> atual.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O método <xref:System.Data.DataSet.Merge%2A> é usado para mesclar dois objetos <xref:System.Data.DataSet> que têm esquemas amplamente semelhantes. Uma mesclagem é normalmente usada em um aplicativo cliente incorporar as alterações mais recentes feitas em uma fonte de dados a um <xref:System.Data.DataSet>existente. Isso permite que o aplicativo cliente tenha um <xref:System.Data.DataSet> atualizado com os dados mais recentes a partir da fonte de dados.  
  
 O método <xref:System.Data.DataSet.Merge%2A> é chamado geralmente ao final de uma série de procedimentos que envolvem a validação de alterações, a reconciliação de erros, a atualização da fonte de dados com as alterações e, por fim, a atualização do <xref:System.Data.DataSet>existente.  
  
 Em um aplicativo cliente, é comum ter um único botão em que o usuário possa clicar reunindo os dados alterados e os valida antes de enviar de volta para um componente de camada intermediária. Nesse cenário, o método <xref:System.Data.DataSet.GetChanges%2A> é invocado primeiro. O método retorna um segundo <xref:System.Data.DataSet> otimizado para validação e mesclagem. Este segundo objeto <xref:System.Data.DataSet> contém apenas os objetos <xref:System.Data.DataTable> e <xref:System.Data.DataRow> que foram modificados, resultando em um subconjunto do <xref:System.Data.DataSet> original. Esse subconjunto é geralmente menor e, portanto, com mais eficiência passado para um componente de camada intermediária. Em seguida, o componente de camada intermediária atualiza a fonte de dados original com as alterações por meio de procedimentos armazenados. A camada intermediária pode enviar novamente em qualquer um novo <xref:System.Data.DataSet> que inclui dados originais e os dados mais recentes da fonte de dados (executando a consulta original novamente), ou pode enviar novamente o subconjunto com eventuais alterações feitas a partir da fonte de dados. (Por exemplo, se a fonte de dados cria automaticamente valores de chave primária exclusivos, esses valores podem ser propagados de volta para o aplicativo cliente.) Em ambos os casos, o <xref:System.Data.DataSet> retornado pode ser mesclado de volta ao <xref:System.Data.DataSet> original do aplicativo cliente com o método <xref:System.Data.DataSet.Merge%2A>.  
  
 Quando o método <xref:System.Data.DataSet.Merge%2A> é chamado, os esquemas dos dois objetos de <xref:System.Data.DataSet> são comparados, porque é possível que os esquemas possam ter sido alterados. Por exemplo, em um cenário entre empresas, novas colunas podem ter sido adicionadas a um esquema XML por um processo automatizado. Se a fonte <xref:System.Data.DataSet> contiver elementos do esquema (objetos <xref:System.Data.DataColumn> adicionados) que estão faltando no destino, os elementos do esquema poderão ser adicionados ao destino definindo o argumento `missingSchemaAction` como `MissingSchemaAction.Add`. Nesse caso, o <xref:System.Data.DataSet> mesclado contém o esquema e os dados adicionados.  
  
 Após a mesclagem de esquemas, os dados são mesclados.  
  
 Durante a mesclagem de uma nova fonte <xref:System.Data.DataSet> no destino, qualquer linha de origem com um valor <xref:System.Data.DataRowState> de `Unchanged`, `Modified` ou `Deleted` são correspondidos para selecionar linhas com os mesmos valores de chave primária. As linhas de origem com um valor de <xref:System.Data.DataRowState> de `Added` correspondem às novas linhas de destino com os mesmos valores de chave primária das novas linhas de origem.  
  
 Durante uma mesclagem, as restrições permanecem desabilitadas. Se qualquer restrição não pode ser habilitada no final de uma mesclagem, um <xref:System.Data.ConstraintException> é gerado e os dados mesclados serão mantidos quando as restrições estiverem desabilitadas. Nesse caso, a propriedade <xref:System.Data.DataSet.EnforceConstraints%2A> é definida como `false`, e todas as linhas inválidas são marcadas com erro. Os erros deverão ser resolvidos antes de tentar redefinir a propriedade <xref:System.Data.DataSet.EnforceConstraints%2A> como `true`.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">Usando conjuntos de dados no ADO.NET</related>
      </Docs>
    </Member>
    <Member MemberName="Merge">
      <MemberSignature Language="C#" Value="public void Merge (System.Data.DataSet dataSet);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Merge(class System.Data.DataSet dataSet) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.Merge(System.Data.DataSet)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Merge(System::Data::DataSet ^ dataSet);" />
      <MemberSignature Language="F#" Value="member this.Merge : System.Data.DataSet -&gt; unit" Usage="dataSet.Merge dataSet" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dataSet" Type="System.Data.DataSet" />
      </Parameters>
      <Docs>
        <param name="dataSet">O <see langword="DataSet" /> cujos dados e esquema serão mesclados.</param>
        <summary>Mescla um <see cref="T:System.Data.DataSet" /> especificado e seu esquema no <see langword="DataSet" /> atual.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O método <xref:System.Data.DataSet.Merge%2A> é usado para mesclar dois objetos <xref:System.Data.DataSet> que têm esquemas amplamente semelhantes. Uma mesclagem é normalmente usada em um aplicativo cliente incorporar as alterações mais recentes feitas em uma fonte de dados a um <xref:System.Data.DataSet>existente. Isso permite que o aplicativo cliente tenha um <xref:System.Data.DataSet> atualizado com os dados mais recentes a partir da fonte de dados.  
  
 O método <xref:System.Data.DataSet.Merge%2A> é chamado geralmente ao final de uma série de procedimentos que envolvem a validação de alterações, a reconciliação de erros, a atualização da fonte de dados com as alterações e, por fim, a atualização do <xref:System.Data.DataSet>existente.  
  
 Em um aplicativo cliente, é comum ter um único botão em que o usuário possa clicar reunindo os dados alterados e os valida antes de enviar de volta para um componente de camada intermediária. Nesse cenário, o método <xref:System.Data.DataSet.GetChanges%2A> é invocado primeiro. O método retorna um segundo <xref:System.Data.DataSet> otimizado para validação e mesclagem. Este segundo objeto <xref:System.Data.DataSet> contém apenas os objetos <xref:System.Data.DataTable> e <xref:System.Data.DataRow> que foram modificados, resultando em um subconjunto do <xref:System.Data.DataSet> original. Este subconjunto é geralmente menor e, assim, passado com mais eficiência para um componente de camada intermediária. Em seguida, o componente de camada intermediária atualiza a fonte de dados original com as alterações por meio de procedimentos armazenados. A camada intermediária pode enviar novamente em qualquer um novo <xref:System.Data.DataSet> que inclui dados originais e os dados mais recentes da fonte de dados (executando a consulta original novamente), ou pode enviar novamente o subconjunto com eventuais alterações feitas a partir da fonte de dados. (Por exemplo, se a fonte de dados cria automaticamente valores de chave primária exclusivos, esses valores podem ser propagados de volta para o aplicativo cliente.) Em ambos os casos, o <xref:System.Data.DataSet> retornado pode ser mesclado de volta ao <xref:System.Data.DataSet> original do aplicativo cliente com o método <xref:System.Data.DataSet.Merge%2A>.  
  
 Quando o método <xref:System.Data.DataSet.Merge%2A> é chamado, os esquemas dos dois objetos de <xref:System.Data.DataSet> são comparados, porque é possível que os esquemas possam ter sido alterados. Por exemplo, em um cenário entre empresas, novas colunas podem ter sido adicionadas a um esquema XML por um processo automatizado. Se a fonte <xref:System.Data.DataSet> contiver elementos do esquema (objetos <xref:System.Data.DataColumn> adicionados) que estão faltando no destino, os elementos do esquema poderão ser adicionados ao destino definindo o argumento `missingSchemaAction` como `MissingSchemaAction.Add`. Nesse caso, o <xref:System.Data.DataSet> mesclado contém o esquema e os dados adicionados.  
  
 Após a mesclagem de esquemas, os dados são mesclados.  
  
 Durante a mesclagem de uma nova fonte <xref:System.Data.DataSet> no destino, qualquer linha de origem com um valor <xref:System.Data.DataRowState> de `Unchanged`, `Modified` ou `Deleted` são correspondidos para selecionar linhas com os mesmos valores de chave primária. As linhas de origem com um valor de `DataRowState` de `Added` correspondem às novas linhas de destino com os mesmos valores de chave primária das novas linhas de origem.  
  
 Durante uma mesclagem, as restrições permanecem desabilitadas. Se alguma restrição não puder ser habilitada ao final da mesclagem, um <xref:System.Data.ConstraintException> será gerado e os dados mesclados serão mantidos quando as restrições estiverem desabilitadas. Nesse caso, a propriedade <xref:System.Data.DataSet.EnforceConstraints%2A> é definida como `false`, e todas as linhas inválidas são marcadas com erro. Os erros deverão ser resolvidos antes de tentar redefinir a propriedade <xref:System.Data.DataSet.EnforceConstraints%2A> como `true`.  
  
   
  
## Examples  
 O exemplo a seguir usa o <xref:System.Data.DataSet.GetChanges%2A>, Update, e <xref:System.Data.DataSet.Merge%2A> métodos em um <xref:System.Data.DataSet>.  
  
 [!code-csharp[Classic WebData DataSet.Merge Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.Merge Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.Merge Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.Merge Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Data.ConstraintException">Não é possível habilitar uma ou mais restrições.</exception>
        <exception cref="T:System.ArgumentNullException">O <paramref name="dataSet" /> é <see langword="null" />.</exception>
        <altmember cref="T:System.Data.ForeignKeyConstraint" />
        <altmember cref="M:System.Data.DataSet.GetChanges" />
        <altmember cref="T:System.Data.UniqueConstraint" />
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">Usando conjuntos de dados no ADO.NET</related>
      </Docs>
    </Member>
    <Member MemberName="Merge">
      <MemberSignature Language="C#" Value="public void Merge (System.Data.DataTable table);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Merge(class System.Data.DataTable table) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.Merge(System.Data.DataTable)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Merge (table As DataTable)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Merge(System::Data::DataTable ^ table);" />
      <MemberSignature Language="F#" Value="member this.Merge : System.Data.DataTable -&gt; unit" Usage="dataSet.Merge table" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="table" Type="System.Data.DataTable" />
      </Parameters>
      <Docs>
        <param name="table">O <see cref="T:System.Data.DataTable" /> cujos dados e esquema serão mesclados.</param>
        <summary>Mescla um <see cref="T:System.Data.DataTable" /> especificado e seu esquema no <see cref="T:System.Data.DataSet" /> atual.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O método <xref:System.Data.DataSet.Merge%2A> é usado para mesclar dois objetos <xref:System.Data.DataSet> que têm esquemas amplamente semelhantes. Uma mesclagem é normalmente usada em um aplicativo cliente incorporar as alterações mais recentes feitas em uma fonte de dados a um <xref:System.Data.DataSet>existente. Isso permite que o aplicativo cliente tenha um <xref:System.Data.DataSet> atualizado com os dados mais recentes a partir da fonte de dados.  
  
 O método <xref:System.Data.DataSet.Merge%2A> é chamado geralmente ao final de uma série de procedimentos que envolvem a validação de alterações, a reconciliação de erros, a atualização da fonte de dados com as alterações e, por fim, a atualização do <xref:System.Data.DataSet>existente.  
  
 Em um aplicativo cliente, é comum ter um único botão em que o usuário possa clicar reunindo os dados alterados e os valida antes de enviar de volta para um componente de camada intermediária. Nesse cenário, o método <xref:System.Data.DataSet.GetChanges%2A> é invocado primeiro. O método retorna um segundo <xref:System.Data.DataSet> otimizado para validação e mesclagem. Este segundo objeto <xref:System.Data.DataSet> contém apenas os objetos <xref:System.Data.DataTable> e <xref:System.Data.DataRow> que foram modificados, resultando em um subconjunto do <xref:System.Data.DataSet> original. Este subconjunto é geralmente menor e, assim, passado com mais eficiência para um componente de camada intermediária. Em seguida, o componente de camada intermediária atualiza a fonte de dados original com as alterações por meio de procedimentos armazenados. A camada intermediária pode enviar novamente em qualquer um novo <xref:System.Data.DataSet> que inclui dados originais e os dados mais recentes da fonte de dados (executando a consulta original novamente), ou pode enviar novamente o subconjunto com eventuais alterações feitas a partir da fonte de dados. (Por exemplo, se a fonte de dados cria automaticamente valores de chave primária exclusivos, esses valores podem ser propagados de volta para o aplicativo cliente.) Em ambos os casos, o <xref:System.Data.DataSet> retornado pode ser mesclado de volta ao <xref:System.Data.DataSet> original do aplicativo cliente com o método <xref:System.Data.DataSet.Merge%2A>.  
  
 Quando o método <xref:System.Data.DataSet.Merge%2A> é chamado, os esquemas dos dois objetos de <xref:System.Data.DataSet> são comparados, porque é possível que os esquemas possam ter sido alterados. Por exemplo, em um cenário entre empresas, novas colunas podem ter sido adicionadas a um esquema XML por um processo automatizado. Se a fonte <xref:System.Data.DataSet> contiver elementos do esquema (objetos <xref:System.Data.DataColumn> adicionados) que estão faltando no destino, os elementos do esquema poderão ser adicionados ao destino definindo o argumento `missingSchemaAction` como `MissingSchemaAction.Add`. Nesse caso, o <xref:System.Data.DataSet> mesclado contém o esquema e os dados adicionados.  
  
 Após a mesclagem de esquemas, os dados são mesclados.  
  
 Durante a mesclagem de uma nova fonte <xref:System.Data.DataSet> no destino, qualquer linha de origem com um valor <xref:System.Data.DataRowState> de `Unchanged`, `Modified` ou `Deleted` são correspondidos para selecionar linhas com os mesmos valores de chave primária. As linhas de origem com um valor de `DataRowState` de `Added` correspondem às novas linhas de destino com os mesmos valores de chave primária das novas linhas de origem.  
  
 Durante uma mesclagem, as restrições permanecem desabilitadas. Se alguma restrição não puder ser habilitada ao final da mesclagem, um <xref:System.Data.ConstraintException> será gerado e os dados mesclados serão mantidos quando as restrições estiverem desabilitadas. Nesse caso, a propriedade <xref:System.Data.DataSet.EnforceConstraints%2A> é definida como `false`, e todas as linhas inválidas são marcadas com erro. Os erros deverão ser resolvidos antes de tentar redefinir a propriedade <xref:System.Data.DataSet.EnforceConstraints%2A> como `true`.  
  
   
  
## Examples  
 O exemplo a seguir cria um <xref:System.Data.DataSet> simples com uma tabela, duas colunas e dez linhas. Um segundo <xref:System.Data.DataTable> é criado que é idêntico ao primeiro. Duas linhas são adicionadas para a segunda tabela, que, em seguida, é mesclada no <xref:System.Data.DataSet>.  
  
 [!code-csharp[Classic WebData DataSet.Merge3 Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.Merge3 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.Merge3 Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.Merge3 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">O <paramref name="table" /> é <see langword="null" />.</exception>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">Usando conjuntos de dados no ADO.NET</related>
      </Docs>
    </Member>
    <Member MemberName="Merge">
      <MemberSignature Language="C#" Value="public void Merge (System.Data.DataSet dataSet, bool preserveChanges);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Merge(class System.Data.DataSet dataSet, bool preserveChanges) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.Merge(System.Data.DataSet,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Merge(System::Data::DataSet ^ dataSet, bool preserveChanges);" />
      <MemberSignature Language="F#" Value="member this.Merge : System.Data.DataSet * bool -&gt; unit" Usage="dataSet.Merge (dataSet, preserveChanges)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dataSet" Type="System.Data.DataSet" />
        <Parameter Name="preserveChanges" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="dataSet">O <see langword="DataSet" /> cujos dados e esquema serão mesclados.</param>
        <param name="preserveChanges"><see langword="true" /> para preservar alterações no <see langword="DataSet" /> atual; caso contrário, <see langword="false" />.</param>
        <summary>Mescla um <see cref="T:System.Data.DataSet" /> especificado e seu esquema no <see langword="DataSet" /> atual, preservando ou descartando as alterações neste <see langword="DataSet" /> de acordo com o argumento determinado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O método <xref:System.Data.DataSet.Merge%2A> é usado para mesclar dois objetos <xref:System.Data.DataSet> que têm esquemas amplamente semelhantes. Uma mesclagem é normalmente usada em um aplicativo cliente incorporar as alterações mais recentes feitas em uma fonte de dados a um <xref:System.Data.DataSet>existente. Isso permite que o aplicativo cliente tenha um <xref:System.Data.DataSet> atualizado com os dados mais recentes a partir da fonte de dados.  
  
 O método <xref:System.Data.DataSet.Merge%2A> é chamado geralmente ao final de uma série de procedimentos que envolvem a validação de alterações, a reconciliação de erros, a atualização da fonte de dados com as alterações e, por fim, a atualização do <xref:System.Data.DataSet>existente.  
  
 Em um aplicativo cliente, é comum ter um único botão em que o usuário possa clicar reunindo os dados alterados e os valida antes de enviar de volta para um componente de camada intermediária. Nesse cenário, o método <xref:System.Data.DataSet.GetChanges%2A> é invocado primeiro. O método retorna um segundo <xref:System.Data.DataSet> otimizado para validação e mesclagem. Este segundo objeto <xref:System.Data.DataSet> contém apenas os objetos <xref:System.Data.DataTable> e <xref:System.Data.DataRow> que foram modificados, resultando em um subconjunto do <xref:System.Data.DataSet> original. Este subconjunto é geralmente menor e, assim, passado com mais eficiência para um componente de camada intermediária. Em seguida, o componente de camada intermediária atualiza a fonte de dados original com as alterações por meio de procedimentos armazenados. A camada intermediária pode enviar novamente em qualquer um novo <xref:System.Data.DataSet> que inclui dados originais e os dados mais recentes da fonte de dados (executando a consulta original novamente), ou pode enviar novamente o subconjunto com eventuais alterações feitas a partir da fonte de dados. (Por exemplo, se a fonte de dados cria automaticamente valores de chave primária exclusivos, esses valores podem ser propagados de volta para o aplicativo cliente.) Em ambos os casos, o <xref:System.Data.DataSet> retornado pode ser mesclado de volta ao <xref:System.Data.DataSet> original do aplicativo cliente com o método <xref:System.Data.DataSet.Merge%2A>.  
  
 Quando o método <xref:System.Data.DataSet.Merge%2A> é chamado, os esquemas dos dois objetos de <xref:System.Data.DataSet> são comparados, porque é possível que os esquemas possam ter sido alterados. Por exemplo, em um cenário entre empresas, novas colunas podem ter sido adicionadas a um esquema XML por um processo automatizado. Se a fonte <xref:System.Data.DataSet> contiver elementos do esquema (objetos <xref:System.Data.DataColumn> adicionados) que estão faltando no destino, os elementos do esquema poderão ser adicionados ao destino definindo o argumento `missingSchemaAction` como `MissingSchemaAction.Add`. Nesse caso, o <xref:System.Data.DataSet> mesclado contém o esquema e os dados adicionados.  
  
 Após a mesclagem de esquemas, os dados são mesclados.  
  
 Durante a mesclagem de uma nova fonte <xref:System.Data.DataSet> no destino, qualquer linha de origem com um valor <xref:System.Data.DataRowState> de `Unchanged`, `Modified` ou `Deleted` são correspondidos para selecionar linhas com os mesmos valores de chave primária. As linhas de origem com um valor de `DataRowState` de `Added` correspondem às novas linhas de destino com os mesmos valores de chave primária das novas linhas de origem.  
  
 Durante uma mesclagem, as restrições permanecem desabilitadas. Se alguma restrição não puder ser habilitada ao final da mesclagem, um <xref:System.Data.ConstraintException> será gerado e os dados mesclados serão mantidos quando as restrições estiverem desabilitadas. Nesse caso, a propriedade <xref:System.Data.DataSet.EnforceConstraints%2A> é definida como `false`, e todas as linhas inválidas são marcadas com erro. Os erros deverão ser resolvidos antes de tentar redefinir a propriedade <xref:System.Data.DataSet.EnforceConstraints%2A> como `true`.  
  
   
  
## Examples  
 O exemplo a seguir cria um <xref:System.Data.DataSet> simples com uma tabela, duas colunas e dez linhas. Depois de adicionar dez linhas, dois valores são alterados e uma linha é adicionada. Um subconjunto dos dados alterados é criado usando o <xref:System.Data.DataSet.GetChanges%2A> método. Depois de reconciliação de erros, os dados de subconjunto são mesclados no original <xref:System.Data.DataSet>.  
  
 [!code-csharp[Classic WebData DataSet.GetChanges Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.GetChanges Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.GetChanges Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.GetChanges Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Data.ForeignKeyConstraint" />
        <altmember cref="T:System.Data.UniqueConstraint" />
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">Usando conjuntos de dados no ADO.NET</related>
      </Docs>
    </Member>
    <Member MemberName="Merge">
      <MemberSignature Language="C#" Value="public void Merge (System.Data.DataRow[] rows, bool preserveChanges, System.Data.MissingSchemaAction missingSchemaAction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Merge(class System.Data.DataRow[] rows, bool preserveChanges, valuetype System.Data.MissingSchemaAction missingSchemaAction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.Merge(System.Data.DataRow[],System.Boolean,System.Data.MissingSchemaAction)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Merge(cli::array &lt;System::Data::DataRow ^&gt; ^ rows, bool preserveChanges, System::Data::MissingSchemaAction missingSchemaAction);" />
      <MemberSignature Language="F#" Value="member this.Merge : System.Data.DataRow[] * bool * System.Data.MissingSchemaAction -&gt; unit" Usage="dataSet.Merge (rows, preserveChanges, missingSchemaAction)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rows" Type="System.Data.DataRow[]" />
        <Parameter Name="preserveChanges" Type="System.Boolean" />
        <Parameter Name="missingSchemaAction" Type="System.Data.MissingSchemaAction" />
      </Parameters>
      <Docs>
        <param name="rows">A matriz de objetos <see cref="T:System.Data.DataRow" /> a serem mesclados no <see langword="DataSet" />.</param>
        <param name="preserveChanges"><see langword="true" /> para preservar alterações no <see langword="DataSet" />; caso contrário, <see langword="false" />.</param>
        <param name="missingSchemaAction">Um dos valores de <see cref="T:System.Data.MissingSchemaAction" />.</param>
        <summary>Mescla uma matriz de objetos <see cref="T:System.Data.DataRow" /> no <see cref="T:System.Data.DataSet" />, preservando ou descartando alterações no <see langword="DataSet" /> atual e manipulando um esquema incompatível de acordo com os argumentos fornecidos.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O método <xref:System.Data.DataSet.Merge%2A> é usado para mesclar dois objetos <xref:System.Data.DataSet> que têm esquemas amplamente semelhantes. Uma mesclagem é normalmente usada em um aplicativo cliente incorporar as alterações mais recentes feitas em uma fonte de dados a um <xref:System.Data.DataSet>existente. Isso permite que o aplicativo cliente tenha um <xref:System.Data.DataSet> atualizado com os dados mais recentes a partir da fonte de dados.  
  
 O método <xref:System.Data.DataSet.Merge%2A> é chamado geralmente ao final de uma série de procedimentos que envolvem a validação de alterações, a reconciliação de erros, a atualização da fonte de dados com as alterações e, por fim, a atualização do <xref:System.Data.DataSet>existente.  
  
 Em um aplicativo cliente, é comum ter um único botão em que o usuário possa clicar reunindo os dados alterados e os valida antes de enviar de volta para um componente de camada intermediária. Nesse cenário, o método <xref:System.Data.DataSet.GetChanges%2A> é invocado primeiro. O método retorna um segundo <xref:System.Data.DataSet> otimizado para validação e mesclagem. Este segundo objeto <xref:System.Data.DataSet> contém apenas os objetos <xref:System.Data.DataTable> e <xref:System.Data.DataRow> que foram modificados, resultando em um subconjunto do <xref:System.Data.DataSet> original. Este subconjunto é geralmente menor e, assim, passado com mais eficiência para um componente de camada intermediária. Em seguida, o componente de camada intermediária atualiza a fonte de dados original com as alterações por meio de procedimentos armazenados. A camada intermediária pode enviar novamente em qualquer um novo <xref:System.Data.DataSet> que inclui dados originais e os dados mais recentes da fonte de dados (executando a consulta original novamente), ou pode enviar novamente o subconjunto com eventuais alterações feitas a partir da fonte de dados. (Por exemplo, se a fonte de dados cria automaticamente valores de chave primária exclusivos, esses valores podem ser propagados de volta para o aplicativo cliente.) Em ambos os casos, o <xref:System.Data.DataSet> retornado pode ser mesclado de volta ao <xref:System.Data.DataSet> original do aplicativo cliente com o método <xref:System.Data.DataSet.Merge%2A>.  
  
 Para facilitar a explicação sobre o <xref:System.Data.DataSet.Merge%2A> método, usamos "destino" para significar atual <xref:System.Data.DataSet>e "fonte" para nomear a segunda (parâmetro) <xref:System.Data.DataSet>. O destino <xref:System.Data.DataSet> é chamada assim porque ele é o objeto no qual ocorre uma ação (mesclagem). A segunda <xref:System.Data.DataSet> é chamado uma "fonte" porque as informações que ela contém não é alterado, mas em vez disso, são mescladas na atual <xref:System.Data.DataSet>.  
  
 Quando o método <xref:System.Data.DataSet.Merge%2A> é chamado, os esquemas dos dois objetos de <xref:System.Data.DataSet> são comparados, porque é possível que os esquemas possam ter sido alterados. Por exemplo, em um cenário entre empresas, novas colunas podem ter sido adicionadas a um esquema XML por um processo automatizado. Se a fonte <xref:System.Data.DataSet> contiver elementos do esquema (objetos <xref:System.Data.DataColumn> adicionados) que estão faltando no destino, os elementos do esquema poderão ser adicionados ao destino definindo o argumento `missingSchemaAction` como `MissingSchemaAction.Add`. Nesse caso, o <xref:System.Data.DataSet> mesclado contém o esquema e os dados adicionados.  
  
 Após a mesclagem de esquemas, os dados são mesclados.  
  
 Durante a mesclagem de uma nova fonte <xref:System.Data.DataSet> no destino, qualquer linha de origem com um valor <xref:System.Data.DataRowState> de `Unchanged`, `Modified` ou `Deleted` são correspondidos para selecionar linhas com os mesmos valores de chave primária. As linhas de origem com um valor de `DataRowState` de `Added` correspondem às novas linhas de destino com os mesmos valores de chave primária das novas linhas de origem.  
  
 Durante uma mesclagem, as restrições permanecem desabilitadas. Se alguma restrição não puder ser habilitada ao final da mesclagem, um <xref:System.Data.ConstraintException> será gerado e os dados mesclados serão mantidos quando as restrições estiverem desabilitadas. Nesse caso, a propriedade <xref:System.Data.DataSet.EnforceConstraints%2A> é definida como `false`, e todas as linhas inválidas são marcadas com erro. Os erros deverão ser resolvidos antes de tentar redefinir a propriedade <xref:System.Data.DataSet.EnforceConstraints%2A> como `true`.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">Usando conjuntos de dados no ADO.NET</related>
      </Docs>
    </Member>
    <Member MemberName="Merge">
      <MemberSignature Language="C#" Value="public void Merge (System.Data.DataSet dataSet, bool preserveChanges, System.Data.MissingSchemaAction missingSchemaAction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Merge(class System.Data.DataSet dataSet, bool preserveChanges, valuetype System.Data.MissingSchemaAction missingSchemaAction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.Merge(System.Data.DataSet,System.Boolean,System.Data.MissingSchemaAction)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Merge(System::Data::DataSet ^ dataSet, bool preserveChanges, System::Data::MissingSchemaAction missingSchemaAction);" />
      <MemberSignature Language="F#" Value="member this.Merge : System.Data.DataSet * bool * System.Data.MissingSchemaAction -&gt; unit" Usage="dataSet.Merge (dataSet, preserveChanges, missingSchemaAction)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dataSet" Type="System.Data.DataSet" />
        <Parameter Name="preserveChanges" Type="System.Boolean" />
        <Parameter Name="missingSchemaAction" Type="System.Data.MissingSchemaAction" />
      </Parameters>
      <Docs>
        <param name="dataSet">O <see langword="DataSet" /> cujos dados e esquema serão mesclados.</param>
        <param name="preserveChanges"><see langword="true" /> para preservar alterações no <see langword="DataSet" /> atual; caso contrário, <see langword="false" />.</param>
        <param name="missingSchemaAction">Um dos valores de <see cref="T:System.Data.MissingSchemaAction" />.</param>
        <summary>Mescla um <see cref="T:System.Data.DataSet" /> especificado e seu esquema com o atual <see langword="DataSet" />, preservando ou descartando alterações no <see langword="DataSet" /> atual e manipulando um esquema incompatível de acordo com os argumentos fornecidos.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O método <xref:System.Data.DataSet.Merge%2A> é usado para mesclar dois objetos <xref:System.Data.DataSet> que têm esquemas amplamente semelhantes. Uma mesclagem é normalmente usada em um aplicativo cliente incorporar as alterações mais recentes feitas em uma fonte de dados a um <xref:System.Data.DataSet>existente. Isso permite que o aplicativo cliente tenha um <xref:System.Data.DataSet> atualizado com os dados mais recentes a partir da fonte de dados.  
  
 O método <xref:System.Data.DataSet.Merge%2A> é chamado geralmente ao final de uma série de procedimentos que envolvem a validação de alterações, a reconciliação de erros, a atualização da fonte de dados com as alterações e, por fim, a atualização do <xref:System.Data.DataSet>existente.  
  
 Em um aplicativo cliente, é comum ter um único botão em que o usuário possa clicar reunindo os dados alterados e os valida antes de enviar de volta para um componente de camada intermediária. Nesse cenário, o método <xref:System.Data.DataSet.GetChanges%2A> é invocado primeiro. O método retorna um segundo <xref:System.Data.DataSet> otimizado para validação e mesclagem. Este segundo objeto <xref:System.Data.DataSet> contém apenas os objetos <xref:System.Data.DataTable> e <xref:System.Data.DataRow> que foram modificados, resultando em um subconjunto do <xref:System.Data.DataSet> original. Este subconjunto é geralmente menor e, assim, passado com mais eficiência para um componente de camada intermediária. Em seguida, o componente de camada intermediária atualiza a fonte de dados original com as alterações por meio de procedimentos armazenados. A camada intermediária pode enviar novamente em qualquer um novo <xref:System.Data.DataSet> que inclui dados originais e os dados mais recentes da fonte de dados (executando a consulta original novamente), ou pode enviar novamente o subconjunto com eventuais alterações feitas a partir da fonte de dados. (Por exemplo, se a fonte de dados cria automaticamente valores de chave primária exclusivos, esses valores podem ser propagados de volta para o aplicativo cliente.) Em ambos os casos, o <xref:System.Data.DataSet> retornado pode ser mesclado de volta ao <xref:System.Data.DataSet> original do aplicativo cliente com o método <xref:System.Data.DataSet.Merge%2A>.  
  
 Para facilitar a explicação sobre o <xref:System.Data.DataSet.Merge%2A> método, usamos "destino" para significar atual <xref:System.Data.DataSet>e "fonte" para nomear a segunda (parâmetro) <xref:System.Data.DataSet>. O destino <xref:System.Data.DataSet> é chamada assim porque ele é o objeto no qual ocorre uma ação (mesclagem). A segunda <xref:System.Data.DataSet> é chamado uma "fonte" porque as informações que ela contém não é alterado, mas em vez disso, são mescladas na atual <xref:System.Data.DataSet>.  
  
 Quando o método <xref:System.Data.DataSet.Merge%2A> é chamado, os esquemas dos dois objetos de <xref:System.Data.DataSet> são comparados, porque é possível que os esquemas possam ter sido alterados. Por exemplo, em um cenário entre empresas, novas colunas podem ter sido adicionadas a um esquema XML por um processo automatizado. Se a fonte <xref:System.Data.DataSet> contiver elementos do esquema (objetos <xref:System.Data.DataColumn> adicionados) que estão faltando no destino, os elementos do esquema poderão ser adicionados ao destino definindo o argumento `missingSchemaAction` como `MissingSchemaAction.Add`. Nesse caso, o <xref:System.Data.DataSet> mesclado contém o esquema e os dados adicionados.  
  
 Após a mesclagem de esquemas, os dados são mesclados.  
  
 Durante a mesclagem de uma nova fonte <xref:System.Data.DataSet> no destino, qualquer linha de origem com um valor <xref:System.Data.DataRowState> de `Unchanged`, `Modified` ou `Deleted` são correspondidos para selecionar linhas com os mesmos valores de chave primária. As linhas de origem com um valor de `DataRowState` de `Added` correspondem às novas linhas de destino com os mesmos valores de chave primária das novas linhas de origem.  
  
 Durante uma mesclagem, as restrições permanecem desabilitadas. Se alguma restrição não puder ser habilitada ao final da mesclagem, um <xref:System.Data.ConstraintException> será gerado e os dados mesclados serão mantidos quando as restrições estiverem desabilitadas. Nesse caso, a propriedade <xref:System.Data.DataSet.EnforceConstraints%2A> é definida como `false`, e todas as linhas inválidas são marcadas com erro. Os erros deverão ser resolvidos antes de tentar redefinir a propriedade <xref:System.Data.DataSet.EnforceConstraints%2A> como `true`.  
  
   
  
## Examples  
 O exemplo a seguir cria um <xref:System.Data.DataSet> simples com uma tabela, duas colunas e dez linhas. Dois valores são alterados, e uma linha é adicionada. Um subconjunto dos dados alterados é criado usando o <xref:System.Data.DataSet.GetChanges%2A> método. Depois de reconciliação de erros, uma nova coluna é adicionada a um subconjunto, alterando o esquema. Quando o <xref:System.Data.DataSet.Merge%2A> método for chamado com o `missingSchemaAction` definido como `MissingSchemaAction.Add`, a nova coluna é adicionada ao original <xref:System.Data.DataSet> esquema do objeto.  
  
 [!code-csharp[Classic WebData DataSet.Merge2 Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.Merge2 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.Merge2 Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.Merge2 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">O <paramref name="dataSet" /> é <see langword="null" />.</exception>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">Usando conjuntos de dados no ADO.NET</related>
      </Docs>
    </Member>
    <Member MemberName="Merge">
      <MemberSignature Language="C#" Value="public void Merge (System.Data.DataTable table, bool preserveChanges, System.Data.MissingSchemaAction missingSchemaAction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Merge(class System.Data.DataTable table, bool preserveChanges, valuetype System.Data.MissingSchemaAction missingSchemaAction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.Merge(System.Data.DataTable,System.Boolean,System.Data.MissingSchemaAction)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Merge(System::Data::DataTable ^ table, bool preserveChanges, System::Data::MissingSchemaAction missingSchemaAction);" />
      <MemberSignature Language="F#" Value="member this.Merge : System.Data.DataTable * bool * System.Data.MissingSchemaAction -&gt; unit" Usage="dataSet.Merge (table, preserveChanges, missingSchemaAction)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="table" Type="System.Data.DataTable" />
        <Parameter Name="preserveChanges" Type="System.Boolean" />
        <Parameter Name="missingSchemaAction" Type="System.Data.MissingSchemaAction" />
      </Parameters>
      <Docs>
        <param name="table">O <see langword="DataTable" /> cujos dados e esquema serão mesclados.</param>
        <param name="preserveChanges">Um dos valores de <see cref="T:System.Data.MissingSchemaAction" />.</param>
        <param name="missingSchemaAction"><see langword="true" /> para preservar alterações no <see langword="DataSet" />; caso contrário, <see langword="false" />.</param>
        <summary>Mescla um <see cref="T:System.Data.DataTable" /> especificado e seu esquema com o atual <see langword="DataSet" />, preservando ou descartando alterações no <see langword="DataSet" /> e manipulando um esquema incompatível de acordo com os argumentos fornecidos.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O método <xref:System.Data.DataSet.Merge%2A> é usado para mesclar dois objetos <xref:System.Data.DataSet> que têm esquemas amplamente semelhantes. Uma mesclagem é normalmente usada em um aplicativo cliente incorporar as alterações mais recentes feitas em uma fonte de dados a um <xref:System.Data.DataSet>existente. Isso permite que o aplicativo cliente tenha um <xref:System.Data.DataSet> atualizado com os dados mais recentes a partir da fonte de dados.  
  
 O método <xref:System.Data.DataSet.Merge%2A> é chamado geralmente ao final de uma série de procedimentos que envolvem a validação de alterações, a reconciliação de erros, a atualização da fonte de dados com as alterações e, por fim, a atualização do <xref:System.Data.DataSet>existente.  
  
 iOn um aplicativo cliente, é comum ter um único botão que o usuário pode clicar que reúne os dados alterados e os valida antes de enviar de volta para um componente de camada intermediária. Nesse cenário, o método <xref:System.Data.DataSet.GetChanges%2A> é invocado primeiro. O método retorna um segundo <xref:System.Data.DataSet> otimizado para validação e mesclagem. Este segundo objeto <xref:System.Data.DataSet> contém apenas os objetos <xref:System.Data.DataTable> e <xref:System.Data.DataRow> que foram modificados, resultando em um subconjunto do <xref:System.Data.DataSet> original. Este subconjunto é geralmente menor e, assim, passado com mais eficiência para um componente de camada intermediária. Em seguida, o componente de camada intermediária atualiza a fonte de dados original com as alterações por meio de procedimentos armazenados. A camada intermediária pode enviar novamente em qualquer um novo <xref:System.Data.DataSet> que inclui dados originais e os dados mais recentes da fonte de dados (executando a consulta original novamente), ou pode enviar novamente o subconjunto com eventuais alterações feitas a partir da fonte de dados. (Por exemplo, se a fonte de dados cria automaticamente valores de chave primária exclusivos, esses valores podem ser propagados de volta para o aplicativo cliente.) Em ambos os casos, o <xref:System.Data.DataSet> retornado pode ser mesclado de volta ao <xref:System.Data.DataSet> original do aplicativo cliente com o método <xref:System.Data.DataSet.Merge%2A>.  
  
 Quando o método <xref:System.Data.DataSet.Merge%2A> é chamado, os esquemas dos dois objetos de <xref:System.Data.DataSet> são comparados, porque é possível que os esquemas possam ter sido alterados. Por exemplo, em um cenário entre empresas, novas colunas podem ter sido adicionadas a um esquema XML por um processo automatizado. Se a fonte <xref:System.Data.DataSet> contiver elementos do esquema (objetos <xref:System.Data.DataColumn> adicionados) que estão faltando no destino, os elementos do esquema poderão ser adicionados ao destino definindo o argumento `missingSchemaAction` como `MissingSchemaAction.Add`. Nesse caso, o <xref:System.Data.DataSet> mesclado contém o esquema e os dados adicionados.  
  
 Após a mesclagem de esquemas, os dados são mesclados.  
  
 Durante a mesclagem de uma nova fonte <xref:System.Data.DataSet> no destino, qualquer linha de origem com um valor <xref:System.Data.DataRowState> de `Unchanged`, `Modified` ou `Deleted` são correspondidos para selecionar linhas com os mesmos valores de chave primária. As linhas de origem com um valor de `DataRowState` de `Added` correspondem às novas linhas de destino com os mesmos valores de chave primária das novas linhas de origem.  
  
 Durante uma mesclagem, as restrições permanecem desabilitadas. Se alguma restrição não puder ser habilitada ao final da mesclagem, um <xref:System.Data.ConstraintException> será gerado e os dados mesclados serão mantidos quando as restrições estiverem desabilitadas. Nesse caso, a propriedade <xref:System.Data.DataSet.EnforceConstraints%2A> é definida como `false`, e todas as linhas inválidas são marcadas com erro. Os erros deverão ser resolvidos antes de tentar redefinir a propriedade <xref:System.Data.DataSet.EnforceConstraints%2A> como `true`.  
  
   
  
## Examples  
 O exemplo a seguir cria um <xref:System.Data.DataSet> simples com uma tabela, duas colunas e dez linhas. Um segundo <xref:System.Data.DataTable> é criado que é quase idêntica à primeira, exceto que um novo `DataColumn` é adicionada à tabela. Duas linhas são adicionadas para a segunda tabela, que, em seguida, é mesclada na <xref:System.Data.DataSet> com o `preserveChanges` argumento definido como `false`e o `missingSchemaAction` argumento definido como `MissingSchemaAction.Add`.  
  
 [!code-csharp[Classic WebData DataSet.Merge4 Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.Merge4 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.Merge4 Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.Merge4 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">O <paramref name="dataSet" /> é <see langword="null" />.</exception>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">Usando conjuntos de dados no ADO.NET</related>
      </Docs>
    </Member>
    <Member MemberName="MergeFailed">
      <MemberSignature Language="C#" Value="public event System.Data.MergeFailedEventHandler MergeFailed;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Data.MergeFailedEventHandler MergeFailed" />
      <MemberSignature Language="DocId" Value="E:System.Data.DataSet.MergeFailed" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event MergeFailed As MergeFailedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Data::MergeFailedEventHandler ^ MergeFailed;" />
      <MemberSignature Language="F#" Value="member this.MergeFailed : System.Data.MergeFailedEventHandler " Usage="member this.MergeFailed : System.Data.MergeFailedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.Data.DataSysDescription("DataSetMergeFailedDescr")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Data.MergeFailedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ocorre quando uma origem e um destino <see cref="T:System.Data.DataRow" /> têm o mesmo valor de chave primária e <see cref="P:System.Data.DataSet.EnforceConstraints" /> é definido como true.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para obter mais informações sobre como manipular eventos, consulte [tratando e gerando eventos](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 O exemplo a seguir demonstra o uso do <xref:System.Data.DataSet.MergeFailed> eventos.  
  
 [!code-csharp[Classic WebData DataSet.MergeFailed Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.MergeFailed Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.MergeFailed Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.MergeFailed Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">Usando conjuntos de dados no ADO.NET</related>
      </Docs>
    </Member>
    <Member MemberName="Namespace">
      <MemberSignature Language="C#" Value="public string Namespace { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Namespace" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataSet.Namespace" />
      <MemberSignature Language="VB.NET" Value="Public Property Namespace As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Namespace { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Namespace : string with get, set" Usage="System.Data.DataSet.Namespace" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.ComponentModel.DefaultValue("")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.Data.DataSysDescription("DataSetNamespaceDescr")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define o namespace do <see cref="T:System.Data.DataSet" />.</summary>
        <value>O namespace do <see cref="T:System.Data.DataSet" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Data.DataSet.Namespace%2A> propriedade é usada ao ler e gravar um XML de documento para o <xref:System.Data.DataSet> usando o <xref:System.Data.DataSet.ReadXml%2A>, <xref:System.Data.DataSet.WriteXml%2A>, <xref:System.Data.DataSet.ReadXmlSchema%2A>, ou <xref:System.Data.DataSet.WriteXmlSchema%2A> métodos.  
  
 O namespace de um documento XML é usado para definir o escopo de atributos e elementos quando lidos na XML um <xref:System.Data.DataSet>. Por exemplo, se um <xref:System.Data.DataSet> contém um esquema que foi lido de um documento com o namespace "myCompany" e é feita uma tentativa de ler dados somente de um documento com um namespace diferente, todos os dados que não correspondem ao esquema existente serão ignorados.  
  
   
  
## Examples  
 O exemplo a seguir define o <xref:System.Data.DataSet.Prefix%2A> antes de chamar o <xref:System.Data.DataSet.ReadXml%2A> método.  
  
 [!code-csharp[Classic WebData DataSet.Namespace Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.Namespace Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.Namespace Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.Namespace Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">O namespace já tem dados.</exception>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">Usando conjuntos de dados no ADO.NET</related>
      </Docs>
    </Member>
    <Member MemberName="OnPropertyChanging">
      <MemberSignature Language="C#" Value="protected virtual void OnPropertyChanging (System.ComponentModel.PropertyChangedEventArgs pcevent);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnPropertyChanging(class System.ComponentModel.PropertyChangedEventArgs pcevent) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.OnPropertyChanging(System.ComponentModel.PropertyChangedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnPropertyChanging (pcevent As PropertyChangedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnPropertyChanging(System::ComponentModel::PropertyChangedEventArgs ^ pcevent);" />
      <MemberSignature Language="F#" Value="abstract member OnPropertyChanging : System.ComponentModel.PropertyChangedEventArgs -&gt; unit&#xA;override this.OnPropertyChanging : System.ComponentModel.PropertyChangedEventArgs -&gt; unit" Usage="dataSet.OnPropertyChanging pcevent" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pcevent" Type="System.ComponentModel.PropertyChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="pcevent">Um <see cref="T:System.ComponentModel.PropertyChangedEventArgs" /> que contém os dados do evento.</param>
        <summary>Aciona o evento <see cref="M:System.Data.DataSet.OnPropertyChanging(System.ComponentModel.PropertyChangedEventArgs)" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A geração de um evento invoca o manipulador de eventos por meio de um delegado. Para obter uma visão geral, consulte [tratando e gerando eventos](~/docs/standard/events/index.md).  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Ao substituir <see cref="M:System.Data.DataSet.OnPropertyChanging(System.ComponentModel.PropertyChangedEventArgs)" /> em uma classe derivada, certifique-se de chamar a classe base <see cref="M:System.Data.DataSet.OnPropertyChanging(System.ComponentModel.PropertyChangedEventArgs)" /> método.</para></block>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">Usando conjuntos de dados no ADO.NET</related>
      </Docs>
    </Member>
    <Member MemberName="OnRemoveRelation">
      <MemberSignature Language="C#" Value="protected virtual void OnRemoveRelation (System.Data.DataRelation relation);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnRemoveRelation(class System.Data.DataRelation relation) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.OnRemoveRelation(System.Data.DataRelation)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnRemoveRelation (relation As DataRelation)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnRemoveRelation(System::Data::DataRelation ^ relation);" />
      <MemberSignature Language="F#" Value="abstract member OnRemoveRelation : System.Data.DataRelation -&gt; unit&#xA;override this.OnRemoveRelation : System.Data.DataRelation -&gt; unit" Usage="dataSet.OnRemoveRelation relation" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="relation" Type="System.Data.DataRelation" />
      </Parameters>
      <Docs>
        <param name="relation">O <see cref="T:System.Data.DataRelation" /> sendo removido.</param>
        <summary>Ocorre quando um objeto <see cref="T:System.Data.DataRelation" /> é removido de um <see cref="T:System.Data.DataTable" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método deve ser substituído por subclasses para restringir as tabelas que está sendo removidas  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">Usando conjuntos de dados no ADO.NET</related>
      </Docs>
    </Member>
    <Member MemberName="OnRemoveTable">
      <MemberSignature Language="C#" Value="protected internal virtual void OnRemoveTable (System.Data.DataTable table);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnRemoveTable(class System.Data.DataTable table) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.OnRemoveTable(System.Data.DataTable)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnRemoveTable (table As DataTable)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnRemoveTable(System::Data::DataTable ^ table);" />
      <MemberSignature Language="F#" Value="abstract member OnRemoveTable : System.Data.DataTable -&gt; unit&#xA;override this.OnRemoveTable : System.Data.DataTable -&gt; unit" Usage="dataSet.OnRemoveTable table" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="table" Type="System.Data.DataTable" />
      </Parameters>
      <Docs>
        <param name="table">O <see cref="T:System.Data.DataTable" /> sendo removido.</param>
        <summary>Ocorre quando um <see cref="T:System.Data.DataTable" /> é removido de um <see cref="T:System.Data.DataSet" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método pode ser substituído por subclasses para impedir que as tabelas que está sendo removido.  
  
   
  
## Examples  
 O exemplo a seguir mostra uma classe que deriva de <xref:System.Data.DataSet> com o <xref:System.Data.DataSet.OnRemoveTable%2A> método substituído.  
  
 [!code-csharp[Classic WebData DataSet.OnRemoveTable Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.OnRemoveTable Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.OnRemoveTable Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.OnRemoveTable Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">Usando conjuntos de dados no ADO.NET</related>
      </Docs>
    </Member>
    <Member MemberName="Prefix">
      <MemberSignature Language="C#" Value="public string Prefix { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Prefix" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataSet.Prefix" />
      <MemberSignature Language="VB.NET" Value="Public Property Prefix As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Prefix { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Prefix : string with get, set" Usage="System.Data.DataSet.Prefix" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.ComponentModel.DefaultValue("")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.Data.DataSysDescription("DataSetPrefixDescr")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define um prefixo XML que cria o alias do namespace do <see cref="T:System.Data.DataSet" />.</summary>
        <value>O prefixo XML para o namespace <see cref="T:System.Data.DataSet" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Data.DataSet.Prefix%2A> propriedade é usada em todo um documento XML para identificar elementos que pertencem ao namespace do <xref:System.Data.DataSet> objeto (conforme definido pelo <xref:System.Data.DataSet.Namespace%2A> propriedade).  
  
   
  
## Examples  
 O exemplo a seguir define o <xref:System.Data.DataSet.Prefix%2A> antes de chamar o <xref:System.Data.DataSet.ReadXml%2A> método.  
  
 [!code-csharp[Classic WebData DataSet.Namespace Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.Namespace Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.Namespace Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.Namespace Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">Usando conjuntos de dados no ADO.NET</related>
      </Docs>
    </Member>
    <Member MemberName="RaisePropertyChanging">
      <MemberSignature Language="C#" Value="protected internal void RaisePropertyChanging (string name);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig instance void RaisePropertyChanging(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.RaisePropertyChanging(System.String)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Sub RaisePropertyChanging (name As String)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; void RaisePropertyChanging(System::String ^ name);" />
      <MemberSignature Language="F#" Value="member this.RaisePropertyChanging : string -&gt; unit" Usage="dataSet.RaisePropertyChanging name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">O nome da propriedade que está prestes a ser alterada.</param>
        <summary>Envia uma notificação de que a propriedade <see cref="T:System.Data.DataSet" /> especificada está prestes a ser alterada.</summary>
        <remarks>To be added.</remarks>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">Usando conjuntos de dados no ADO.NET</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="ReadXml">
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Lê o esquema XML e os dados para o <see cref="T:System.Data.DataSet" />.</summary>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">Usando conjuntos de dados no ADO.NET</related>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReadXml">
      <MemberSignature Language="C#" Value="public System.Data.XmlReadMode ReadXml (System.IO.Stream stream);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Data.XmlReadMode ReadXml(class System.IO.Stream stream) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.ReadXml(System.IO.Stream)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::XmlReadMode ReadXml(System::IO::Stream ^ stream);" />
      <MemberSignature Language="F#" Value="member this.ReadXml : System.IO.Stream -&gt; System.Data.XmlReadMode" Usage="dataSet.ReadXml stream" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.XmlReadMode</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
      </Parameters>
      <Docs>
        <param name="stream">Um objeto que deriva de <see cref="T:System.IO.Stream" />.</param>
        <summary>Lê o esquema XML e dados para o <see cref="T:System.Data.DataSet" /> usando o <see cref="T:System.IO.Stream" /> especificado.</summary>
        <returns>O <see cref="T:System.Data.XmlReadMode" /> usado para ler os dados.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O método <xref:System.Data.DataSet.ReadXml%2A> fornece uma maneira de ler apenas dados ou dados e esquema em um <xref:System.Data.DataSet> a partir de um documento XML, e o método <xref:System.Data.DataSet.ReadXmlSchema%2A> lê apenas o esquema. Para ler dados e esquema, use uma das sobrecargas `ReadXML` que inclui o parâmetro de `mode` e defina o valor como `ReadSchema`.  
  
 Observe que o mesmo é verdadeiro para os métodos <xref:System.Data.DataSet.WriteXml%2A> e <xref:System.Data.DataSet.WriteXmlSchema%2A>, respectivamente. Para gravar dados XML ou o esquema e os dados do `DataSet`, use o método `WriteXml`. Para gravar apenas o esquema, use o método `WriteXmlSchema`.  
  
> [!NOTE]
>  Um <xref:System.InvalidOperationException> será lançado se um tipo de coluna no `DataRow` de leitura ou gravação implementa <xref:System.Dynamic.IDynamicMetaObjectProvider> e não implementa <xref:System.Xml.Serialization.IXmlSerializable>.  
  
 Se um esquema embutido for especificado, o esquema embutido será usado para estender a estrutura relacional existente antes de carregar os dados. Se houver algum conflito (por exemplo, a mesma coluna na mesma tabela definida com tipos de dados diferentes), uma exceção será gerada.  
  
 Se nenhum esquema embutido for especificado, a estrutura relacional será estendida por meio de inferência, conforme necessário, de acordo com a estrutura do documento XML. Se o esquema não puder ser estendido por meio de inferência para expor todos os dados, uma exceção será gerada.  
  
> [!NOTE]
>  O `DataSet` não associa um elemento XML ao `DataColumn` correspondente `DataTable` quando caracteres XML legais como (“_”) escapam no XML serializável. O próprio `DataSet` só escapa com caracteres XML ilegais em nomes de elemento XML e, assim, só pode consumir o mesmo. Quando os caracteres legais no nome de elemento XML são escapadas, o elemento é ignorado durante o processamento.  
  
 Se o esquema XML para <xref:System.Data.DataSet> incluir `targetNamespace`, os dados não poderão ser lidos e você poderá encontrar exceções ao chamar <xref:System.Data.DataSet.ReadXml%2A> para carregar o <xref:System.Data.DataSet> com XML que contenha elementos sem nenhum namespace de qualificação. Para ler os elementos não qualificados, defina `elementFormDefault` igual a "qualificado" no esquema XML, como demonstra o exemplo a seguir.  
  
```  
<xsd:schema id="MyDataSet"   
   elementFormDefault="qualified"   
   targetNamespace="http://www.tempuri.org/MyDataSet.xsd"   
   xmlns="http://www.tempuri.org/MyDataSet.xsd"   
   xmlns:xsd="http://www.w3.org/2001/XMLSchema"   
   xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">  
</xsd:schema>  
```  
  
> [!NOTE]
>  Se o esquema para o <xref:System.Data.DataSet> contiver elementos do mesmo nome, mas de tipo diferente, no mesmo namespace, uma exceção será gerada quando você tentar ler o esquema no <xref:System.Data.DataSet> com <xref:System.Data.DataSet.ReadXml%2A> especificando `XmlReadMode.ReadSchema`. Esta exceção não ocorrerá se você estiver usando a versão 1.0 do.NET Framework.  
  
   
  
## Examples  
 O exemplo a seguir primeiramente cria um <xref:System.Data.DataSet> simples com um <xref:System.Data.DataTable>, duas colunas e dez linhas. O esquema <xref:System.Data.DataSet> e os dados são gravados em disco invocando o método <xref:System.Data.DataSet.WriteXml%2A>. Um segundo <xref:System.Data.DataSet> é criado e o método <xref:System.Data.DataSet.ReadXml%2A> é usado para preenchê-lo com esquema e dados.  
  
 [!code-csharp[Classic WebData DataSet.ReadXml1 Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.ReadXml1 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.ReadXml1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.ReadXml1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Data.DataSet.ReadXmlSchema(System.Xml.XmlReader)" />
        <altmember cref="M:System.Data.DataSet.WriteXml(System.IO.Stream)" />
        <altmember cref="M:System.Data.DataSet.WriteXmlSchema(System.IO.Stream)" />
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">Usando conjuntos de dados no ADO.NET</related>
      </Docs>
    </Member>
    <Member MemberName="ReadXml">
      <MemberSignature Language="C#" Value="public System.Data.XmlReadMode ReadXml (System.IO.TextReader reader);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Data.XmlReadMode ReadXml(class System.IO.TextReader reader) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.ReadXml(System.IO.TextReader)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReadXml (reader As TextReader) As XmlReadMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::XmlReadMode ReadXml(System::IO::TextReader ^ reader);" />
      <MemberSignature Language="F#" Value="member this.ReadXml : System.IO.TextReader -&gt; System.Data.XmlReadMode" Usage="dataSet.ReadXml reader" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.XmlReadMode</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.IO.TextReader" />
      </Parameters>
      <Docs>
        <param name="reader">O <see langword="TextReader" /> do qual ler o esquema e os dados.</param>
        <summary>Lê o esquema XML e dados para o <see cref="T:System.Data.DataSet" /> usando o <see cref="T:System.IO.TextReader" /> especificado.</summary>
        <returns>O <see cref="T:System.Data.XmlReadMode" /> usado para ler os dados.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O método <xref:System.Data.DataSet.ReadXml%2A> fornece uma maneira de ler apenas dados ou dados e esquema em um <xref:System.Data.DataSet> a partir de um documento XML, e o método <xref:System.Data.DataSet.ReadXmlSchema%2A> lê apenas o esquema. Para ler dados e esquema, use uma das sobrecargas `ReadXML` que inclui o parâmetro de `mode` e defina o valor como `ReadSchema`.  
  
 Observe que o mesmo é verdadeiro para os métodos <xref:System.Data.DataSet.WriteXml%2A> e <xref:System.Data.DataSet.WriteXmlSchema%2A>, respectivamente. Para gravar dados XML ou o esquema e os dados do `DataSet`, use o método `WriteXml`. Para gravar apenas o esquema, use o método `WriteXmlSchema`.  
  
> [!NOTE]
>  Um <xref:System.InvalidOperationException> será lançado se um tipo de coluna no `DataRow` de leitura ou gravação implementa <xref:System.Dynamic.IDynamicMetaObjectProvider> e não implementa <xref:System.Xml.Serialization.IXmlSerializable>.  
  
 Se um esquema embutido for especificado, o esquema embutido será usado para estender a estrutura relacional existente antes de carregar os dados. Se houver algum conflito (por exemplo, a mesma coluna na mesma tabela definida com tipos de dados diferentes), uma exceção será gerada.  
  
 Se nenhum esquema embutido for especificado, a estrutura relacional será estendida por meio de inferência, conforme necessário, de acordo com a estrutura do documento XML. Se o esquema não puder ser estendido por meio de inferência para expor todos os dados, uma exceção será gerada.  
  
> [!NOTE]
>  O `DataSet` não associa um elemento XML ao `DataColumn` correspondente `DataTable` quando caracteres XML legais como (“_”) escapam no XML serializável. O próprio `DataSet` só escapa com caracteres XML ilegais em nomes de elemento XML e, assim, só pode consumir o mesmo. Quando os caracteres legais no nome de elemento XML são escapadas, o elemento é ignorado durante o processamento.  
  
 Se o esquema XML para <xref:System.Data.DataSet> incluir `targetNamespace`, os dados não poderão ser lidos e você poderá encontrar exceções ao chamar <xref:System.Data.DataSet.ReadXml%2A> para carregar o <xref:System.Data.DataSet> com XML que contenha elementos sem nenhum namespace de qualificação. Para ler elementos não qualificados, defina `elementFormDefault` igual a "qualificado" no Esquema XML como o exemplo a seguir demonstra.  
  
```  
<xsd:schema id="MyDataSet"   
   elementFormDefault="qualified"   
   targetNamespace="http://www.tempuri.org/MyDataSet.xsd"   
   xmlns="http://www.tempuri.org/MyDataSet.xsd"   
   xmlns:xsd="http://www.w3.org/2001/XMLSchema"   
   xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">  
</xsd:schema>  
```  
  
 Classes que herdam de <xref:System.IO.TextReader> classe incluem o <xref:System.IO.StreamReader> e <xref:System.IO.StringReader> classes.  
  
> [!NOTE]
>  Se o esquema para o <xref:System.Data.DataSet> contiver elementos do mesmo nome, mas de tipo diferente, no mesmo namespace, uma exceção será gerada quando você tentar ler o esquema no <xref:System.Data.DataSet> com <xref:System.Data.DataSet.ReadXml%2A> especificando `XmlReadMode.ReadSchema`. Esta exceção não ocorrerá se você estiver usando a versão 1.0 do.NET Framework.  
  
   
  
## Examples  
 O exemplo a seguir primeiramente cria um <xref:System.Data.DataSet> simples com um <xref:System.Data.DataTable>, duas colunas e dez linhas. O esquema <xref:System.Data.DataSet> e os dados são gravados em disco invocando o método <xref:System.Data.DataSet.WriteXml%2A>. Um segundo <xref:System.Data.DataSet> é criado e o método <xref:System.Data.DataSet.ReadXml%2A> é usado para preenchê-lo com esquema e dados.  
  
 [!code-csharp[Classic WebData DataSet.ReadXml2 Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.ReadXml2 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.ReadXml2 Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.ReadXml2 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">Usando conjuntos de dados no ADO.NET</related>
      </Docs>
    </Member>
    <Member MemberName="ReadXml">
      <MemberSignature Language="C#" Value="public System.Data.XmlReadMode ReadXml (string fileName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Data.XmlReadMode ReadXml(string fileName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.ReadXml(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReadXml (fileName As String) As XmlReadMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::XmlReadMode ReadXml(System::String ^ fileName);" />
      <MemberSignature Language="F#" Value="member this.ReadXml : string -&gt; System.Data.XmlReadMode" Usage="dataSet.ReadXml fileName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.XmlReadMode</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="fileName">O nome do arquivo (incluindo o caminho) do qual será realizada a leitura.</param>
        <summary>Lê o esquema XML e dados no <see cref="T:System.Data.DataSet" /> usando o arquivo especificado.</summary>
        <returns>O <see langword="XmlReadMode" /> usado para ler os dados.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O método <xref:System.Data.DataSet.ReadXml%2A> fornece uma maneira de ler apenas dados ou dados e esquema em um <xref:System.Data.DataSet> a partir de um documento XML, e o método <xref:System.Data.DataSet.ReadXmlSchema%2A> lê apenas o esquema. Para ler dados e esquema, use uma das sobrecargas `ReadXML` que inclui o parâmetro de `mode` e defina o valor como `ReadSchema`.  
  
 Observe que o mesmo é verdadeiro para os métodos <xref:System.Data.DataSet.WriteXml%2A> e <xref:System.Data.DataSet.WriteXmlSchema%2A>, respectivamente. Para gravar dados XML ou o esquema e os dados do `DataSet`, use o método `WriteXml`. Para gravar apenas o esquema, use o método `WriteXmlSchema`.  
  
> [!NOTE]
>  Um <xref:System.InvalidOperationException> será lançado se um tipo de coluna no `DataRow` de leitura ou gravação implementa <xref:System.Dynamic.IDynamicMetaObjectProvider> e não implementa <xref:System.Xml.Serialization.IXmlSerializable>.  
  
 Se um esquema embutido for especificado, o esquema embutido será usado para estender a estrutura relacional existente antes de carregar os dados. Se houver algum conflito (por exemplo, a mesma coluna na mesma tabela definida com tipos de dados diferentes), uma exceção será gerada.  
  
 Se nenhum esquema embutido for especificado, a estrutura relacional será estendida por meio de inferência, conforme necessário, de acordo com a estrutura do documento XML. Se o esquema não puder ser estendido por meio de inferência para expor todos os dados, uma exceção será gerada.  
  
> [!NOTE]
>  O `DataSet` não associa um elemento XML ao `DataColumn` correspondente `DataTable` quando caracteres XML legais como (“_”) escapam no XML serializável. O próprio `DataSet` só escapa com caracteres XML ilegais em nomes de elemento XML e, assim, só pode consumir o mesmo. Quando os caracteres legais no nome de elemento XML são escapadas, o elemento é ignorado durante o processamento.  
  
 Se o esquema XML de um <xref:System.Data.DataSet> incluir `targetNamespace`, os dados não poderão ser lidos e você poderá encontrar exceções ao chamar <xref:System.Data.DataSet.ReadXml%2A> para carregar <xref:System.Data.DataSet> com XML que contenha elementos sem nenhum namespace de qualificação. Para ler elementos não qualificados, defina `elementFormDefault` igual a "qualificado" no Esquema XML como o exemplo a seguir demonstra.  
  
```  
<xsd:schema id="MyDataSet"   
   elementFormDefault="qualified"   
   targetNamespace="http://www.tempuri.org/MyDataSet.xsd"   
   xmlns="http://www.tempuri.org/MyDataSet.xsd"   
   xmlns:xsd="http://www.w3.org/2001/XMLSchema"   
   xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">  
</xsd:schema>  
```  
  
> [!NOTE]
>  Se o esquema para o <xref:System.Data.DataSet> contiver elementos do mesmo nome, mas de tipo diferente, no mesmo namespace, uma exceção será gerada quando você tentar ler o esquema no <xref:System.Data.DataSet> com <xref:System.Data.DataSet.ReadXml%2A> especificando `XmlReadMode.ReadSchema`. Esta exceção não ocorrerá se você estiver usando a versão 1.0 do.NET Framework.  
  
   
  
## Examples  
 O exemplo a seguir primeiramente cria um <xref:System.Data.DataSet> simples com um <xref:System.Data.DataTable>, duas colunas e dez linhas. O esquema <xref:System.Data.DataSet> e os dados são gravados em disco invocando o método <xref:System.Data.DataSet.WriteXml%2A>. Um segundo <xref:System.Data.DataSet> é criado e o método <xref:System.Data.DataSet.ReadXml%2A> é usado para preenchê-lo com esquema e dados.  
  
 [!code-csharp[Classic WebData DataSet.ReadXml3 Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.ReadXml3 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.ReadXml3 Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.ReadXml3 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException"><see cref="T:System.Security.Permissions.FileIOPermission" /> não é definido como <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">para ler e gravar arquivos. Enumeração associada: <see cref="T:System.Security.Permissions.FileIOPermissionAccess" /></permission>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">Usando conjuntos de dados no ADO.NET</related>
      </Docs>
    </Member>
    <Member MemberName="ReadXml">
      <MemberSignature Language="C#" Value="public System.Data.XmlReadMode ReadXml (System.Xml.XmlReader reader);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Data.XmlReadMode ReadXml(class System.Xml.XmlReader reader) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.ReadXml(System.Xml.XmlReader)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReadXml (reader As XmlReader) As XmlReadMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::XmlReadMode ReadXml(System::Xml::XmlReader ^ reader);" />
      <MemberSignature Language="F#" Value="member this.ReadXml : System.Xml.XmlReader -&gt; System.Data.XmlReadMode" Usage="dataSet.ReadXml reader" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.XmlReadMode</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Xml.XmlReader" />
      </Parameters>
      <Docs>
        <param name="reader">O <see cref="T:System.Xml.XmlReader" /> do qual ler.</param>
        <summary>Lê o esquema XML e dados para o <see cref="T:System.Data.DataSet" /> usando o <see cref="T:System.Xml.XmlReader" /> especificado.</summary>
        <returns>O <see langword="XmlReadMode" /> usado para ler os dados.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O método <xref:System.Data.DataSet.ReadXml%2A> fornece uma maneira de ler apenas dados ou dados e esquema em um <xref:System.Data.DataSet> a partir de um documento XML, e o método <xref:System.Data.DataSet.ReadXmlSchema%2A> lê apenas o esquema. Para ler dados e esquema, use uma das sobrecargas `ReadXML` que inclui o parâmetro de `mode` e defina o valor como `ReadSchema`.  
  
 Observe que o mesmo é verdadeiro para os métodos <xref:System.Data.DataSet.WriteXml%2A> e <xref:System.Data.DataSet.WriteXmlSchema%2A>, respectivamente. Para gravar dados XML ou o esquema e os dados do `DataSet`, use o método `WriteXml`. Para gravar apenas o esquema, use o método `WriteXmlSchema`.  
  
> [!NOTE]
>  Um <xref:System.InvalidOperationException> será lançado se um tipo de coluna no `DataRow` de leitura ou gravação implementa <xref:System.Dynamic.IDynamicMetaObjectProvider> e não implementa <xref:System.Xml.Serialization.IXmlSerializable>.  
  
 Se um esquema embutido for especificado, o esquema embutido será usado para estender a estrutura relacional existente antes de carregar os dados. Se houver algum conflito (por exemplo, a mesma coluna na mesma tabela definida com tipos de dados diferentes), uma exceção será gerada.  
  
 Se nenhum esquema embutido for especificado, a estrutura relacional será estendida por meio de inferência, conforme necessário, de acordo com a estrutura do documento XML. Se o esquema não puder ser estendido por meio de inferência para expor todos os dados, uma exceção será gerada.  
  
> [!NOTE]
>  O `DataSet` não associa um elemento XML ao `DataColumn` correspondente `DataTable` quando caracteres XML legais como (“_”) escapam no XML serializável. O próprio `DataSet` só escapa com caracteres XML ilegais em nomes de elemento XML e, assim, só pode consumir o mesmo. Quando os caracteres legais no nome de elemento XML são escapadas, o elemento é ignorado durante o processamento.  
  
 Se o esquema XML de um <xref:System.Data.DataSet> incluir `targetNamespace`, os dados não poderão ser lidos e você poderá encontrar exceções ao chamar <xref:System.Data.DataSet.ReadXml%2A> para carregar <xref:System.Data.DataSet> com XML que contenha elementos sem nenhum namespace de qualificação. Para ler elementos não qualificados, defina `elementFormDefault` igual a "qualificado" no Esquema XML como o exemplo a seguir demonstra.  
  
```  
<xsd:schema id="MyDataSet"   
   elementFormDefault="qualified"   
   targetNamespace="http://www.tempuri.org/MyDataSet.xsd"   
   xmlns="http://www.tempuri.org/MyDataSet.xsd"   
   xmlns:xsd="http://www.w3.org/2001/XMLSchema"   
   xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">  
</xsd:schema>  
```  
  
 <xref:System.Xml.XmlTextReader?displayProperty=nameWithType> herda de <xref:System.Xml.XmlReader>.  
  
> [!NOTE]
>  Se o esquema para o <xref:System.Data.DataSet> contiver elementos do mesmo nome, mas de tipo diferente, no mesmo namespace, uma exceção será gerada quando você tentar ler o esquema no <xref:System.Data.DataSet> com <xref:System.Data.DataSet.ReadXml%2A> especificando `XmlReadMode.ReadSchema`. Esta exceção não ocorrerá se você estiver usando a versão 1.0 do.NET Framework.  
  
   
  
## Examples  
 O exemplo a seguir primeiramente cria um <xref:System.Data.DataSet> simples com um <xref:System.Data.DataTable>, duas colunas e dez linhas. O esquema <xref:System.Data.DataSet> e os dados são gravados em disco invocando o método <xref:System.Data.DataSet.WriteXml%2A>. Um segundo <xref:System.Data.DataSet> é criado e o método <xref:System.Data.DataSet.ReadXml%2A> é usado para preenchê-lo com esquema e dados.  
  
 [!code-csharp[Classic WebData DataSet.ReadXml Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.ReadXml Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.ReadXml Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.ReadXml Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">Usando conjuntos de dados no ADO.NET</related>
      </Docs>
    </Member>
    <Member MemberName="ReadXml">
      <MemberSignature Language="C#" Value="public System.Data.XmlReadMode ReadXml (System.IO.Stream stream, System.Data.XmlReadMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Data.XmlReadMode ReadXml(class System.IO.Stream stream, valuetype System.Data.XmlReadMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.ReadXml(System.IO.Stream,System.Data.XmlReadMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::XmlReadMode ReadXml(System::IO::Stream ^ stream, System::Data::XmlReadMode mode);" />
      <MemberSignature Language="F#" Value="member this.ReadXml : System.IO.Stream * System.Data.XmlReadMode -&gt; System.Data.XmlReadMode" Usage="dataSet.ReadXml (stream, mode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.XmlReadMode</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
        <Parameter Name="mode" Type="System.Data.XmlReadMode" />
      </Parameters>
      <Docs>
        <param name="stream">O <see cref="T:System.IO.Stream" /> do qual ler.</param>
        <param name="mode">Um dos valores de <see cref="T:System.Data.XmlReadMode" />.</param>
        <summary>Lê o esquema XML e os dados no <see cref="T:System.Data.DataSet" /> usando o <see cref="T:System.IO.Stream" /> e <see cref="T:System.Data.XmlReadMode" /> especificados.</summary>
        <returns>O <see langword="XmlReadMode" /> usado para ler os dados.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O método <xref:System.Data.DataSet.ReadXml%2A> fornece uma maneira de ler apenas dados ou dados e esquema em um <xref:System.Data.DataSet> a partir de um documento XML, e o método <xref:System.Data.DataSet.ReadXmlSchema%2A> lê apenas o esquema. Para ler dados e esquema, use uma das sobrecargas `ReadXML` que inclui o parâmetro de `mode` e defina o valor como `ReadSchema`.  
  
 O mesmo é verdadeiro para o <xref:System.Data.DataSet.WriteXml%2A> e <xref:System.Data.DataSet.WriteXmlSchema%2A> métodos, respectivamente. Para gravar dados XML ou o esquema e os dados do `DataSet`, use o método `WriteXml`. Para gravar apenas o esquema, use o método `WriteXmlSchema`.  
  
> [!NOTE]
>  Quando você usa <xref:System.Data.DataSet.ReadXml%2A> e você definir <xref:System.Data.XmlReadMode> à `Diffgram`, o conteúdo do destino `DataSet` e original `DataSet` pode ser diferente devido a como o diffgram é gerado e processado. Para obter mais informações sobre diffgrams, consulte [DiffGrams](~/docs/framework/data/adonet/dataset-datatable-dataview/diffgrams.md).  
  
> [!NOTE]
>  Um <xref:System.InvalidOperationException> será lançado se um tipo de coluna no `DataRow` de leitura ou gravação implementa <xref:System.Dynamic.IDynamicMetaObjectProvider> e não implementa <xref:System.Xml.Serialization.IXmlSerializable>.  
  
 Se um esquema embutido for especificado, o esquema embutido será usado para estender a estrutura relacional existente antes de carregar os dados. Se houver algum conflito (por exemplo, a mesma coluna na mesma tabela definida com tipos de dados diferentes), uma exceção será gerada.  
  
 Se nenhum esquema embutido for especificado, a estrutura relacional será estendida por meio de inferência, conforme necessário, de acordo com a estrutura do documento XML. Se o esquema não puder ser estendido por meio de inferência para expor todos os dados, uma exceção será gerada.  
  
> [!NOTE]
>  O `DataSet` não associa um elemento XML ao `DataColumn` correspondente `DataTable` quando caracteres XML legais como (“_”) escapam no XML serializável. O próprio `DataSet` só escapa com caracteres XML ilegais em nomes de elemento XML e, assim, só pode consumir o mesmo. Quando os caracteres legais no nome de elemento XML são escapadas, o elemento é ignorado durante o processamento.  
  
 Se o esquema XML para <xref:System.Data.DataSet> incluir `targetNamespace`, os dados não poderão ser lidos e você poderá encontrar exceções ao chamar <xref:System.Data.DataSet.ReadXml%2A> para carregar o <xref:System.Data.DataSet> com XML que contenha elementos sem nenhum namespace de qualificação. Para ler elementos não qualificados, defina `elementFormDefault` igual a "qualificado" no Esquema XML como o exemplo a seguir demonstra.  
  
```  
<xsd:schema id="MyDataSet"   
   elementFormDefault="qualified"   
   targetNamespace="http://www.tempuri.org/MyDataSet.xsd"   
   xmlns="http://www.tempuri.org/MyDataSet.xsd"   
   xmlns:xsd="http://www.w3.org/2001/XMLSchema"   
   xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">  
</xsd:schema>  
```  
  
> [!NOTE]
>  Se o esquema para o <xref:System.Data.DataSet> contiver elementos do mesmo nome, mas de tipo diferente, no mesmo namespace, uma exceção será gerada quando você tentar ler o esquema no <xref:System.Data.DataSet> com <xref:System.Data.DataSet.ReadXml%2A> especificando `XmlReadMode.ReadSchema`. Esta exceção não ocorrerá se você estiver usando a versão 1.0 do.NET Framework.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">Usando conjuntos de dados no ADO.NET</related>
      </Docs>
    </Member>
    <Member MemberName="ReadXml">
      <MemberSignature Language="C#" Value="public System.Data.XmlReadMode ReadXml (System.IO.TextReader reader, System.Data.XmlReadMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Data.XmlReadMode ReadXml(class System.IO.TextReader reader, valuetype System.Data.XmlReadMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.ReadXml(System.IO.TextReader,System.Data.XmlReadMode)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReadXml (reader As TextReader, mode As XmlReadMode) As XmlReadMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::XmlReadMode ReadXml(System::IO::TextReader ^ reader, System::Data::XmlReadMode mode);" />
      <MemberSignature Language="F#" Value="member this.ReadXml : System.IO.TextReader * System.Data.XmlReadMode -&gt; System.Data.XmlReadMode" Usage="dataSet.ReadXml (reader, mode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.XmlReadMode</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.IO.TextReader" />
        <Parameter Name="mode" Type="System.Data.XmlReadMode" />
      </Parameters>
      <Docs>
        <param name="reader">O <see cref="T:System.IO.TextReader" /> do qual ler.</param>
        <param name="mode">Um dos valores de <see cref="T:System.Data.XmlReadMode" />.</param>
        <summary>Lê o esquema XML e os dados no <see cref="T:System.Data.DataSet" /> usando o <see cref="T:System.IO.TextReader" /> e <see cref="T:System.Data.XmlReadMode" /> especificados.</summary>
        <returns>O <see langword="XmlReadMode" /> usado para ler os dados.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O método <xref:System.Data.DataSet.ReadXml%2A> fornece uma maneira de ler apenas dados ou dados e esquema em um <xref:System.Data.DataSet> a partir de um documento XML, e o método <xref:System.Data.DataSet.ReadXmlSchema%2A> lê apenas o esquema. Para ler dados e esquema, use uma das sobrecargas `ReadXML` que inclui o parâmetro de `mode` e defina o valor como `ReadSchema`.  
  
 Observe que o mesmo é verdadeiro para os métodos <xref:System.Data.DataSet.WriteXml%2A> e <xref:System.Data.DataSet.WriteXmlSchema%2A>, respectivamente. Para gravar dados XML ou o esquema e os dados do `DataSet`, use o método `WriteXml`. Para gravar apenas o esquema, use o método `WriteXmlSchema`.  
  
> [!NOTE]
>  Um <xref:System.InvalidOperationException> será lançado se um tipo de coluna no `DataRow` de leitura ou gravação implementa <xref:System.Dynamic.IDynamicMetaObjectProvider> e não implementa <xref:System.Xml.Serialization.IXmlSerializable>.  
  
 Se um esquema embutido for especificado, o esquema embutido será usado para estender a estrutura relacional existente antes de carregar os dados. Se houver algum conflito (por exemplo, a mesma coluna na mesma tabela definida com tipos de dados diferentes), uma exceção será gerada.  
  
 Se nenhum esquema embutido for especificado, a estrutura relacional será estendida por meio de inferência, conforme necessário, de acordo com a estrutura do documento XML. Se o esquema não puder ser estendido por meio de inferência para expor todos os dados, uma exceção será gerada.  
  
> [!NOTE]
>  O `DataSet` não associa um elemento XML ao `DataColumn` correspondente `DataTable` quando caracteres XML legais como (“_”) escapam no XML serializável. O próprio `DataSet` só escapa com caracteres XML ilegais em nomes de elemento XML e, assim, só pode consumir o mesmo. Quando os caracteres legais no nome de elemento XML são escapadas, o elemento é ignorado durante o processamento.  
  
 Se o esquema XML para <xref:System.Data.DataSet> incluir `targetNamespace`, os dados não poderão ser lidos e você poderá encontrar exceções ao chamar <xref:System.Data.DataSet.ReadXml%2A> para carregar o <xref:System.Data.DataSet> com XML que contenha elementos sem nenhum namespace de qualificação. Para ler elementos não qualificados, defina `elementFormDefault` igual a "qualificado" no Esquema XML como o exemplo a seguir demonstra.  
  
```  
<xsd:schema id="MyDataSet"   
   elementFormDefault="qualified"   
   targetNamespace="http://www.tempuri.org/MyDataSet.xsd"   
   xmlns="http://www.tempuri.org/MyDataSet.xsd"   
   xmlns:xsd="http://www.w3.org/2001/XMLSchema"   
   xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">  
</xsd:schema>  
```  
  
> [!NOTE]
>  Se o esquema para o <xref:System.Data.DataSet> contiver elementos do mesmo nome, mas de tipo diferente, no mesmo namespace, uma exceção será gerada quando você tentar ler o esquema no <xref:System.Data.DataSet> com <xref:System.Data.DataSet.ReadXml%2A> especificando `XmlReadMode.ReadSchema`. Esta exceção não ocorrerá se você estiver usando a versão 1.0 do.NET Framework.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">Usando conjuntos de dados no ADO.NET</related>
      </Docs>
    </Member>
    <Member MemberName="ReadXml">
      <MemberSignature Language="C#" Value="public System.Data.XmlReadMode ReadXml (string fileName, System.Data.XmlReadMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Data.XmlReadMode ReadXml(string fileName, valuetype System.Data.XmlReadMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.ReadXml(System.String,System.Data.XmlReadMode)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReadXml (fileName As String, mode As XmlReadMode) As XmlReadMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::XmlReadMode ReadXml(System::String ^ fileName, System::Data::XmlReadMode mode);" />
      <MemberSignature Language="F#" Value="member this.ReadXml : string * System.Data.XmlReadMode -&gt; System.Data.XmlReadMode" Usage="dataSet.ReadXml (fileName, mode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.XmlReadMode</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
        <Parameter Name="mode" Type="System.Data.XmlReadMode" />
      </Parameters>
      <Docs>
        <param name="fileName">O nome do arquivo (incluindo o caminho) do qual será realizada a leitura.</param>
        <param name="mode">Um dos valores de <see cref="T:System.Data.XmlReadMode" />.</param>
        <summary>Lê dados e o esquema XML no <see cref="T:System.Data.DataSet" /> usando o arquivo especificado e <see cref="T:System.Data.XmlReadMode" />.</summary>
        <returns>O <see langword="XmlReadMode" /> usado para ler os dados.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O método <xref:System.Data.DataSet.ReadXml%2A> fornece uma maneira de ler apenas dados ou dados e esquema em um <xref:System.Data.DataSet> a partir de um documento XML, e o método <xref:System.Data.DataSet.ReadXmlSchema%2A> lê apenas o esquema. Para ler dados e esquema, use uma das sobrecargas `ReadXML` que inclui o parâmetro de `mode` e defina o valor como `ReadSchema`.  
  
 Observe que o mesmo é verdadeiro para os métodos <xref:System.Data.DataSet.WriteXml%2A> e <xref:System.Data.DataSet.WriteXmlSchema%2A>, respectivamente. Para gravar dados XML ou o esquema e os dados do `DataSet`, use o método `WriteXml`. Para gravar apenas o esquema, use o método `WriteXmlSchema`.  
  
> [!NOTE]
>  Um <xref:System.InvalidOperationException> será lançado se um tipo de coluna no `DataRow` de leitura ou gravação implementa <xref:System.Dynamic.IDynamicMetaObjectProvider> e não implementa <xref:System.Xml.Serialization.IXmlSerializable>.  
  
 Se um esquema embutido for especificado, o esquema embutido será usado para estender a estrutura relacional existente antes de carregar os dados. Se houver algum conflito (por exemplo, a mesma coluna na mesma tabela definida com tipos de dados diferentes), uma exceção será gerada.  
  
 Se nenhum esquema embutido for especificado, a estrutura relacional será estendida por meio de inferência, conforme necessário, de acordo com a estrutura do documento XML. Se o esquema não puder ser estendido por meio de inferência para expor todos os dados, uma exceção será gerada.  
  
> [!NOTE]
>  O `DataSet` não associa um elemento XML ao `DataColumn` correspondente `DataTable` quando caracteres XML legais como (“_”) escapam no XML serializável. O próprio `DataSet` só escapa com caracteres XML ilegais em nomes de elemento XML e, assim, só pode consumir o mesmo. Quando os caracteres legais no nome de elemento XML são escapadas, o elemento é ignorado durante o processamento.  
  
 Se o esquema XML de um <xref:System.Data.DataSet> incluir `targetNamespace`, os dados não poderão ser lidos e você poderá encontrar exceções ao chamar <xref:System.Data.DataSet.ReadXml%2A> para carregar <xref:System.Data.DataSet> com XML que contenha elementos sem nenhum namespace de qualificação. Para ler elementos não qualificados, defina `elementFormDefault` igual a "qualificado" no Esquema XML como o exemplo a seguir demonstra.  
  
```  
<xsd:schema id="MyDataSet"   
   elementFormDefault="qualified"   
   targetNamespace="http://www.tempuri.org/MyDataSet.xsd"   
   xmlns="http://www.tempuri.org/MyDataSet.xsd"   
   xmlns:xsd="http://www.w3.org/2001/XMLSchema"   
   xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">  
</xsd:schema>  
```  
  
> [!NOTE]
>  Se o esquema para o <xref:System.Data.DataSet> contiver elementos do mesmo nome, mas de tipo diferente, no mesmo namespace, uma exceção será gerada quando você tentar ler o esquema no <xref:System.Data.DataSet> com <xref:System.Data.DataSet.ReadXml%2A> especificando `XmlReadMode.ReadSchema`. Esta exceção não ocorrerá se você estiver usando a versão 1.0 do.NET Framework.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException"><see cref="T:System.Security.Permissions.FileIOPermission" /> não é definido como <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">para ler e gravar arquivos. Enumeração associada: <see cref="T:System.Security.Permissions.FileIOPermissionAccess" /></permission>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">Usando conjuntos de dados no ADO.NET</related>
      </Docs>
    </Member>
    <Member MemberName="ReadXml">
      <MemberSignature Language="C#" Value="public System.Data.XmlReadMode ReadXml (System.Xml.XmlReader reader, System.Data.XmlReadMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Data.XmlReadMode ReadXml(class System.Xml.XmlReader reader, valuetype System.Data.XmlReadMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.ReadXml(System.Xml.XmlReader,System.Data.XmlReadMode)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReadXml (reader As XmlReader, mode As XmlReadMode) As XmlReadMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::XmlReadMode ReadXml(System::Xml::XmlReader ^ reader, System::Data::XmlReadMode mode);" />
      <MemberSignature Language="F#" Value="member this.ReadXml : System.Xml.XmlReader * System.Data.XmlReadMode -&gt; System.Data.XmlReadMode" Usage="dataSet.ReadXml (reader, mode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.XmlReadMode</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Xml.XmlReader" />
        <Parameter Name="mode" Type="System.Data.XmlReadMode" />
      </Parameters>
      <Docs>
        <param name="reader">O <see cref="T:System.Xml.XmlReader" /> do qual ler.</param>
        <param name="mode">Um dos valores de <see cref="T:System.Data.XmlReadMode" />.</param>
        <summary>Lê o esquema XML e os dados no <see cref="T:System.Data.DataSet" /> usando o <see cref="T:System.Xml.XmlReader" /> e <see cref="T:System.Data.XmlReadMode" /> especificados.</summary>
        <returns>O <see langword="XmlReadMode" /> usado para ler os dados.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O método <xref:System.Data.DataSet.ReadXml%2A> fornece uma maneira de ler apenas dados ou dados e esquema em um <xref:System.Data.DataSet> a partir de um documento XML, e o método <xref:System.Data.DataSet.ReadXmlSchema%2A> lê apenas o esquema. Para ler dados e esquema, use uma das sobrecargas `ReadXML` que inclui o parâmetro de `mode` e defina o valor como `ReadSchema`.  
  
 Observe que o mesmo é verdadeiro para os métodos <xref:System.Data.DataSet.WriteXml%2A> e <xref:System.Data.DataSet.WriteXmlSchema%2A>, respectivamente. Para gravar dados XML ou o esquema e os dados do `DataSet`, use o método `WriteXml`. Para gravar apenas o esquema, use o método `WriteXmlSchema`.  
  
> [!NOTE]
>  Um <xref:System.InvalidOperationException> será lançado se um tipo de coluna no `DataRow` de leitura ou gravação implementa <xref:System.Dynamic.IDynamicMetaObjectProvider> e não implementa <xref:System.Xml.Serialization.IXmlSerializable>.  
  
 Se um esquema embutido for especificado, o esquema embutido será usado para estender a estrutura relacional existente antes de carregar os dados. Se houver algum conflito (por exemplo, a mesma coluna na mesma tabela definida com tipos de dados diferentes), uma exceção será gerada.  
  
 Se nenhum esquema embutido for especificado, a estrutura relacional será estendida por meio de inferência, conforme necessário, de acordo com a estrutura do documento XML. Se o esquema não puder ser estendido por meio de inferência para expor todos os dados, uma exceção será gerada.  
  
> [!NOTE]
>  O `DataSet` não associa um elemento XML ao `DataColumn` correspondente `DataTable` quando caracteres XML legais como (“_”) escapam no XML serializável. O próprio `DataSet` só escapa com caracteres XML ilegais em nomes de elemento XML e, assim, só pode consumir o mesmo. Quando os caracteres legais no nome de elemento XML são escapadas, o elemento é ignorado durante o processamento.  
  
 Se o esquema XML de um <xref:System.Data.DataSet> incluir `targetNamespace`, os dados não poderão ser lidos e você poderá encontrar exceções ao chamar <xref:System.Data.DataSet.ReadXml%2A> para carregar <xref:System.Data.DataSet> com XML que contenha elementos sem nenhum namespace de qualificação. Para ler elementos não qualificados, defina `elementFormDefault` igual a "qualificado" no Esquema XML como o exemplo a seguir demonstra.  
  
```  
<xsd:schema id="MyDataSet"   
   elementFormDefault="qualified"   
   targetNamespace="http://www.tempuri.org/MyDataSet.xsd"   
   xmlns="http://www.tempuri.org/MyDataSet.xsd"   
   xmlns:xsd="http://www.w3.org/2001/XMLSchema"   
   xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">  
</xsd:schema>  
```  
  
> [!NOTE]
>  Se o esquema para o <xref:System.Data.DataSet> contiver elementos do mesmo nome, mas de tipo diferente, no mesmo namespace, uma exceção será gerada quando você tentar ler o esquema no <xref:System.Data.DataSet> com <xref:System.Data.DataSet.ReadXml%2A> especificando `XmlReadMode.ReadSchema`. Esta exceção não ocorrerá se você estiver usando a versão 1.0 do.NET Framework.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">Usando conjuntos de dados no ADO.NET</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="ReadXmlSchema">
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Lê um esquema XML para o <see cref="T:System.Data.DataSet" />.</summary>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">Usando conjuntos de dados no ADO.NET</related>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReadXmlSchema">
      <MemberSignature Language="C#" Value="public void ReadXmlSchema (System.IO.Stream stream);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ReadXmlSchema(class System.IO.Stream stream) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.ReadXmlSchema(System.IO.Stream)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ReadXmlSchema(System::IO::Stream ^ stream);" />
      <MemberSignature Language="F#" Value="member this.ReadXmlSchema : System.IO.Stream -&gt; unit" Usage="dataSet.ReadXmlSchema stream" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
      </Parameters>
      <Docs>
        <param name="stream">O <see cref="T:System.IO.Stream" /> do qual ler.</param>
        <summary>Lê o esquema XML do <see cref="T:System.IO.Stream" /> especificado no <see cref="T:System.Data.DataSet" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use o método <xref:System.Data.DataSet.ReadXmlSchema%2A> para criar o esquema de um <xref:System.Data.DataSet>. O esquema inclui tabela, relação e definições de restrição. Para gravar um esquema em um documento XML, use o método <xref:System.Data.DataSet.WriteXmlSchema%2A>.  
  
 O esquema XML é gravado usando o padrão XSD.  
  
> [!NOTE]
>  A corrupção de dados poderá ocorrer se os tipos msdata:DataType e xs:type não coincidirem. Nenhuma exceção será gerada.  
  
 O método <xref:System.Data.DataSet.ReadXmlSchema%2A> é invocado geralmente antes de invocar o método <xref:System.Data.DataSet.ReadXml%2A> usado para preencher o <xref:System.Data.DataSet>.  
  
 Classes que derivam de <xref:System.IO.Stream> classe incluir <xref:System.IO.BufferedStream>, <xref:System.IO.FileStream>, <xref:System.IO.MemoryStream>, e <xref:System.Net.Sockets.NetworkStream>.  
  
> [!NOTE]
>  Se o esquema para o <xref:System.Data.DataSet> contiver elementos do mesmo nome, mas de tipo diferente, no mesmo namespace, uma exceção será gerada quando você tentar ler o esquema no <xref:System.Data.DataSet> com <xref:System.Data.DataSet.ReadXmlSchema%2A>. Esta exceção não ocorrerá se você estiver usando a versão 1.0 do.NET Framework.  
  
   
  
## Examples  
 O exemplo a seguir cria uma <xref:System.IO.FileStream> leia um esquema XML com o objeto e invoca o <xref:System.Data.DataSet.ReadXmlSchema%2A> método com o objeto.  
  
 [!code-csharp[Classic WebData DataSet.ReadXmlSchema1 Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.ReadXmlSchema1 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.ReadXmlSchema1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.ReadXmlSchema1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">Usando conjuntos de dados no ADO.NET</related>
      </Docs>
    </Member>
    <Member MemberName="ReadXmlSchema">
      <MemberSignature Language="C#" Value="public void ReadXmlSchema (System.IO.TextReader reader);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ReadXmlSchema(class System.IO.TextReader reader) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.ReadXmlSchema(System.IO.TextReader)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ReadXmlSchema (reader As TextReader)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ReadXmlSchema(System::IO::TextReader ^ reader);" />
      <MemberSignature Language="F#" Value="member this.ReadXmlSchema : System.IO.TextReader -&gt; unit" Usage="dataSet.ReadXmlSchema reader" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.IO.TextReader" />
      </Parameters>
      <Docs>
        <param name="reader">O <see cref="T:System.IO.TextReader" /> do qual ler.</param>
        <summary>Lê o esquema XML do <see cref="T:System.IO.TextReader" /> especificado no <see cref="T:System.Data.DataSet" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use o método <xref:System.Data.DataSet.ReadXmlSchema%2A> para criar o esquema de um <xref:System.Data.DataSet>. O esquema inclui tabela, relação e definições de restrição. Para gravar um esquema em um documento XML, use o método <xref:System.Data.DataSet.WriteXmlSchema%2A>.  
  
 O esquema XML é gravado usando o padrão XSD.  
  
> [!NOTE]
>  A corrupção de dados poderá ocorrer se os tipos msdata:DataType e xs:type não coincidirem. Nenhuma exceção será gerada.  
  
 O método <xref:System.Data.DataSet.ReadXmlSchema%2A> é invocado geralmente antes de invocar o método <xref:System.Data.DataSet.ReadXml%2A> usado para preencher o <xref:System.Data.DataSet>.  
  
 Classes que herdam de <xref:System.IO.TextReader> classe incluem o <xref:System.IO.StreamReader> e <xref:System.IO.StringReader> classes.  
  
> [!NOTE]
>  Se o esquema para o <xref:System.Data.DataSet> contiver elementos do mesmo nome, mas de tipo diferente, no mesmo namespace, uma exceção será gerada quando você tentar ler o esquema no <xref:System.Data.DataSet> com <xref:System.Data.DataSet.ReadXmlSchema%2A>. Esta exceção não ocorrerá se você estiver usando a versão 1.0 do.NET Framework.  
  
   
  
## Examples  
 O exemplo a seguir cria uma <xref:System.IO.StreamReader> leia um esquema com o objeto e invoca o <xref:System.Data.DataSet.ReadXmlSchema%2A> método com o objeto.  
  
 [!code-csharp[Classic WebData DataSet.ReadXmlSchema2 Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.ReadXmlSchema2 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.ReadXmlSchema2 Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.ReadXmlSchema2 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">Usando conjuntos de dados no ADO.NET</related>
      </Docs>
    </Member>
    <Member MemberName="ReadXmlSchema">
      <MemberSignature Language="C#" Value="public void ReadXmlSchema (string fileName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ReadXmlSchema(string fileName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.ReadXmlSchema(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ReadXmlSchema (fileName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ReadXmlSchema(System::String ^ fileName);" />
      <MemberSignature Language="F#" Value="member this.ReadXmlSchema : string -&gt; unit" Usage="dataSet.ReadXmlSchema fileName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="fileName">O nome de arquivo (incluindo o caminho) do qual será realizada a leitura.</param>
        <summary>Lê o esquema XML do arquivo especificado no <see cref="T:System.Data.DataSet" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use o método <xref:System.Data.DataSet.ReadXmlSchema%2A> para criar o esquema de um <xref:System.Data.DataSet>. O esquema inclui tabela, relação e definições de restrição. Para gravar um esquema em um documento XML, use o método <xref:System.Data.DataSet.WriteXmlSchema%2A>.  
  
 O esquema XML é gravado usando o padrão XSD.  
  
> [!NOTE]
>  A corrupção de dados poderá ocorrer se os tipos msdata:DataType e xs:type não coincidirem. Nenhuma exceção será gerada.  
  
 O método <xref:System.Data.DataSet.ReadXmlSchema%2A> é invocado geralmente antes de invocar o método <xref:System.Data.DataSet.ReadXml%2A> usado para preencher o <xref:System.Data.DataSet>.  
  
> [!NOTE]
>  Se o esquema para seus <xref:System.Data.DataSet> contém elementos do mesmo nome, mas tipo diferente, no mesmo namespace, uma exceção é lançada quando você tenta ler o esquema para o <xref:System.Data.DataSet> com <xref:System.Data.DataSet.ReadXmlSchema%2A>. Esta exceção não ocorrerá se você estiver usando a versão 1.0 do.NET Framework.  
  
   
  
## Examples  
 [!code-csharp[Classic WebData DataSet.ReadXmlSchema3 Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.ReadXmlSchema3 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.ReadXmlSchema3 Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.ReadXmlSchema3 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException"><see cref="T:System.Security.Permissions.FileIOPermission" /> não é definido como <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">para ler e gravar arquivos. Enumeração associada: <see cref="T:System.Security.Permissions.FileIOPermissionAccess" /></permission>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">Usando conjuntos de dados no ADO.NET</related>
      </Docs>
    </Member>
    <Member MemberName="ReadXmlSchema">
      <MemberSignature Language="C#" Value="public void ReadXmlSchema (System.Xml.XmlReader reader);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ReadXmlSchema(class System.Xml.XmlReader reader) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.ReadXmlSchema(System.Xml.XmlReader)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ReadXmlSchema (reader As XmlReader)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ReadXmlSchema(System::Xml::XmlReader ^ reader);" />
      <MemberSignature Language="F#" Value="member this.ReadXmlSchema : System.Xml.XmlReader -&gt; unit" Usage="dataSet.ReadXmlSchema reader" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Xml.XmlReader" />
      </Parameters>
      <Docs>
        <param name="reader">O <see cref="T:System.Xml.XmlReader" /> do qual ler.</param>
        <summary>Lê o esquema XML do <see cref="T:System.Xml.XmlReader" /> especificado no <see cref="T:System.Data.DataSet" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use o método <xref:System.Data.DataSet.ReadXmlSchema%2A> para criar o esquema de um <xref:System.Data.DataSet>. O esquema inclui tabela, relação e definições de restrição.  
  
 O esquema XML é gravado usando o padrão XSD.  
  
> [!NOTE]
>  A corrupção de dados poderá ocorrer se os tipos msdata:DataType e xs:type não coincidirem. Nenhuma exceção será gerada.  
  
 O método <xref:System.Data.DataSet.ReadXmlSchema%2A> é invocado geralmente antes de invocar o método <xref:System.Data.DataSet.ReadXml%2A> usado para preencher o <xref:System.Data.DataSet>.  
  
 O <xref:System.Xml.XmlReader?displayProperty=nameWithType> classe é abstrata. Uma classe que herda de `XmlReader` é o <xref:System.Xml.XmlTextReader?displayProperty=nameWithType> classe.  
  
> [!NOTE]
>  Se o esquema para o <xref:System.Data.DataSet> contiver elementos do mesmo nome, mas de tipo diferente, no mesmo namespace, uma exceção será gerada quando você tentar ler o esquema no <xref:System.Data.DataSet> com <xref:System.Data.DataSet.ReadXmlSchema%2A>. Esta exceção não ocorrerá se você estiver usando a versão 1.0 do.NET Framework.  
  
   
  
## Examples  
 O exemplo a seguir cria um novo <xref:System.Data.DataSet> e <xref:System.IO.FileStream?displayProperty=nameWithType> objeto. O <xref:System.IO.FileStream> objeto, criado com um caminho de arquivo e o nome do arquivo, é usado para criar um <xref:System.Xml.XmlTextReader?displayProperty=nameWithType> que é passado como um argumento para o <xref:System.Data.DataSet.ReadXmlSchema%2A> método.  
  
 [!code-csharp[Classic WebData DataSet.ReadXmlSchema Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.ReadXmlSchema Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.ReadXmlSchema Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.ReadXmlSchema Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">Usando conjuntos de dados no ADO.NET</related>
      </Docs>
    </Member>
    <Member MemberName="ReadXmlSerializable">
      <MemberSignature Language="C#" Value="protected virtual void ReadXmlSerializable (System.Xml.XmlReader reader);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void ReadXmlSerializable(class System.Xml.XmlReader reader) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.ReadXmlSerializable(System.Xml.XmlReader)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub ReadXmlSerializable (reader As XmlReader)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void ReadXmlSerializable(System::Xml::XmlReader ^ reader);" />
      <MemberSignature Language="F#" Value="abstract member ReadXmlSerializable : System.Xml.XmlReader -&gt; unit&#xA;override this.ReadXmlSerializable : System.Xml.XmlReader -&gt; unit" Usage="dataSet.ReadXmlSerializable reader" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Xml.XmlReader" />
      </Parameters>
      <Docs>
        <param name="reader">O leitor XML especificado.</param>
        <summary>Ignora os atributos e retorna um DataSet vazio.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RejectChanges">
      <MemberSignature Language="C#" Value="public virtual void RejectChanges ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void RejectChanges() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.RejectChanges" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub RejectChanges ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void RejectChanges();" />
      <MemberSignature Language="F#" Value="abstract member RejectChanges : unit -&gt; unit&#xA;override this.RejectChanges : unit -&gt; unit" Usage="dataSet.RejectChanges " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Reverte todas as alterações feitas ao <see cref="T:System.Data.DataSet" /> desde que foi criado ou desde a última vez em que o <see cref="M:System.Data.DataSet.AcceptChanges" /> foi chamado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Invocar o <xref:System.Data.DataSet.RejectChanges%2A?displayProperty=nameWithType> para chamar o <xref:System.Data.DataTable.RejectChanges%2A?displayProperty=nameWithType> método em todos os <xref:System.Data.DataTable> objetos contidos pelo <xref:System.Data.DataSet>.  
  
 <xref:System.Data.DataRow> objetos contidos pelo <xref:System.Data.DataSet> pode cada ser definida no modo de edição, invocando o <xref:System.Data.DataRow.BeginEdit%2A?displayProperty=nameWithType> método. Depois de invocar o <xref:System.Data.DataRow.EndEdit%2A?displayProperty=nameWithType> método, alterações podem ser rejeitadas por meio da chamada a <xref:System.Data.DataTable.RejectChanges%2A?displayProperty=nameWithType> na <xref:System.Data.DataTable> ao qual o <xref:System.Data.DataRow> objetos pertencem.  
  
 Quando o <xref:System.Data.DataTable.RejectChanges%2A?displayProperty=nameWithType> método é chamado, nenhuma linha estiver no modo de edição cancelar suas edições. Novas linhas são removidas. Linhas excluídas e modificadas retornam para seu estado original (`DataRowState.Unchanged`).  
  
 AcceptChanges e RejectChanges se aplicam somente aos <xref:System.Data.DataRow> alterações relacionadas (ou seja, `Add`, `Remove`, `Delete`, e `Modify`). Eles não são aplicáveis ao esquema ou alterações estruturais.  
  
   
  
## Examples  
 O exemplo a seguir mostra uma classe que deriva de <xref:System.Data.DataSet> classe. O <xref:System.Data.DataSet.RejectChanges%2A> evento ser invocado de dentro de uma função.  
  
 [!code-csharp[Classic WebData DataSet.RejectChanges Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.RejectChanges Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.RejectChanges Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.RejectChanges Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">Usando conjuntos de dados no ADO.NET</related>
      </Docs>
    </Member>
    <Member MemberName="Relations">
      <MemberSignature Language="C#" Value="public System.Data.DataRelationCollection Relations { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Data.DataRelationCollection Relations" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataSet.Relations" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Relations As DataRelationCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Data::DataRelationCollection ^ Relations { System::Data::DataRelationCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Relations : System.Data.DataRelationCollection" Usage="System.Data.DataSet.Relations" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;netcore-2.2;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Content)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.Data.DataSysDescription("DataSetRelationsDescr")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Data.DataRelationCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém a coleção de relações que vinculam tabelas e permitem a navegação de tabelas principais para tabelas secundárias.</summary>
        <value>Um <see cref="T:System.Data.DataRelationCollection" /> que contém uma coleção de objetos <see cref="T:System.Data.DataRelation" />. Será retornada uma coleção vazia se não houver nenhum objeto <see cref="T:System.Data.DataRelation" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O exemplo a seguir imprime o nome da coluna de todas as tabelas filho por meio de <xref:System.Data.DataSet.Relations%2A> propriedade.  
  
 [!code-vb[Classic WebData DataSet.Relations Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.Relations Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">Usando conjuntos de dados no ADO.NET</related>
      </Docs>
    </Member>
    <Member MemberName="RemotingFormat">
      <MemberSignature Language="C#" Value="public System.Data.SerializationFormat RemotingFormat { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Data.SerializationFormat RemotingFormat" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataSet.RemotingFormat" />
      <MemberSignature Language="VB.NET" Value="Public Property RemotingFormat As SerializationFormat" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Data::SerializationFormat RemotingFormat { System::Data::SerializationFormat get(); void set(System::Data::SerializationFormat value); };" />
      <MemberSignature Language="F#" Value="member this.RemotingFormat : System.Data.SerializationFormat with get, set" Usage="System.Data.DataSet.RemotingFormat" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.ComponentModel.DefaultValue(Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Data.SerializationFormat</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define um <see cref="T:System.Data.SerializationFormat" /> para o <see cref="T:System.Data.DataSet" /> usado durante a comunicação remota.</summary>
        <value>Um objeto <see cref="T:System.Data.SerializationFormat" />.</value>
        <remarks>To be added.</remarks>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">Usando conjuntos de dados no ADO.NET</related>
      </Docs>
    </Member>
    <Member MemberName="Reset">
      <MemberSignature Language="C#" Value="public virtual void Reset ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Reset() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.Reset" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Reset ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Reset();" />
      <MemberSignature Language="F#" Value="abstract member Reset : unit -&gt; unit&#xA;override this.Reset : unit -&gt; unit" Usage="dataSet.Reset " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Limpa todas as tabelas e remove todas as relações, restrições externas e tabelas de <see cref="T:System.Data.DataSet" />. As subclasses devem substituir <see cref="M:System.Data.DataSet.Reset" /> para restaurar um <see cref="T:System.Data.DataSet" /> ao seu estado original.</summary>
        <remarks>To be added.</remarks>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">Usando conjuntos de dados no ADO.NET</related>
      </Docs>
    </Member>
    <Member MemberName="SchemaSerializationMode">
      <MemberSignature Language="C#" Value="public virtual System.Data.SchemaSerializationMode SchemaSerializationMode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Data.SchemaSerializationMode SchemaSerializationMode" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataSet.SchemaSerializationMode" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property SchemaSerializationMode As SchemaSerializationMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Data::SchemaSerializationMode SchemaSerializationMode { System::Data::SchemaSerializationMode get(); void set(System::Data::SchemaSerializationMode value); };" />
      <MemberSignature Language="F#" Value="member this.SchemaSerializationMode : System.Data.SchemaSerializationMode with get, set" Usage="System.Data.DataSet.SchemaSerializationMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;netcore-2.2;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Data.SchemaSerializationMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define um <see cref="T:System.Data.SchemaSerializationMode" /> para um <see cref="T:System.Data.DataSet" />.</summary>
        <value>Um <see cref="T:System.Data.SchemaSerializationMode" /> para um <see cref="T:System.Data.DataSet" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Um <xref:System.Data.DataSet> serializa seus dados de instância e esquema por padrão nos serviços da Web e cenários de comunicação remota. Definindo o <xref:System.Data.DataSet.SchemaSerializationMode%2A> propriedade de um `DataSet` para <xref:System.Data.SchemaSerializationMode.ExcludeSchema> faz com que as informações de esquema a ser excluído da carga de serialização.  
  
 <xref:System.Data.SchemaSerializationMode.ExcludeSchema> há suporte apenas para um tipo `DataSet`. Para não tipados `DataSet` essa propriedade só pode ser definida como <xref:System.Data.SchemaSerializationMode.IncludeSchema>.  
  
 <xref:System.Data.SchemaSerializationMode.ExcludeSchema> só deve ser usado em casos em que as informações de esquema de subjacente digitadas `DataTables`, `DataRelations` e `Constraints` não tiver sido modificado. Se tiveram de modificações de informações de esquema ocorreu e completa devem ser serializadas com <xref:System.Data.SchemaSerializationMode.IncludeSchema>.  
  
 <xref:System.Data.SchemaSerializationMode.ExcludeSchema> há suporte na versão 2.0 do .NET Framework ou posterior.  
  
 Quando <xref:System.Data.SchemaSerializationMode.ExcludeSchema> for definido, somente as propriedades de tempo de execução de nível superior presentes no <xref:System.Data.DataSet> são serializados. Além disso, elas são serializadas apenas se eles sejam diferentes dos valores padrão. Nenhum dos `Tables`, `Relations` ou `Constraints` são serializados. As propriedades de tempo de execução serializada incluem <xref:System.Data.DataSet.DataSetName%2A>, <xref:System.Data.DataSet.Namespace%2A>, <xref:System.Data.DataSet.Prefix%2A>, <xref:System.Data.DataSet.Locale%2A>, <xref:System.Data.DataSet.EnforceConstraints%2A>, e <xref:System.Data.DataSet.CaseSensitive%2A>. Essas propriedades são serializadas para certificar-se de que a integridade dos dados de tempo de execução geral seja preservada.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">Usando conjuntos de dados no ADO.NET</related>
      </Docs>
    </Member>
    <Member MemberName="ShouldSerializeRelations">
      <MemberSignature Language="C#" Value="protected virtual bool ShouldSerializeRelations ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool ShouldSerializeRelations() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.ShouldSerializeRelations" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function ShouldSerializeRelations () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool ShouldSerializeRelations();" />
      <MemberSignature Language="F#" Value="abstract member ShouldSerializeRelations : unit -&gt; bool&#xA;override this.ShouldSerializeRelations : unit -&gt; bool" Usage="dataSet.ShouldSerializeRelations " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Obtém um valor que indica se a propriedade <see cref="P:System.Data.DataSet.Relations" /> deve ser persistida.</summary>
        <returns><see langword="true" /> se o valor da propriedade tiver sido alterado do padrão, caso contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Você normalmente usa esse método se você estiver criando ou um designer para o <xref:System.Data.DataSet>, ou criar seu próprio controle incorporando o <xref:System.Data.DataSet>.  
  
   
  
## Examples  
 Os exemplos a seguir mostram uma classe que deriva de <xref:System.Data.DataSet> classe. O <xref:System.Data.DataSet.Reset%2A> e <xref:System.Data.DataSet.ShouldSerializeRelations%2A> métodos são chamados de dentro de funções na classe derivada.  
  
 [!code-csharp[Classic WebData DataSet.ShouldSerializeRelations Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.ShouldSerializeRelations Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.ShouldSerializeRelations Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.ShouldSerializeRelations Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">Usando conjuntos de dados no ADO.NET</related>
      </Docs>
    </Member>
    <Member MemberName="ShouldSerializeTables">
      <MemberSignature Language="C#" Value="protected virtual bool ShouldSerializeTables ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool ShouldSerializeTables() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.ShouldSerializeTables" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function ShouldSerializeTables () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool ShouldSerializeTables();" />
      <MemberSignature Language="F#" Value="abstract member ShouldSerializeTables : unit -&gt; bool&#xA;override this.ShouldSerializeTables : unit -&gt; bool" Usage="dataSet.ShouldSerializeTables " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Obtém um valor que indica se a propriedade <see cref="P:System.Data.DataSet.Tables" /> deve ser persistida.</summary>
        <returns><see langword="true" /> se o valor da propriedade tiver sido alterado do padrão, caso contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Você normalmente usa esse método somente se você estiver criando ou um designer para o <xref:System.Data.DataSet>, ou criar seu próprio controle incorporando o <xref:System.Data.DataSet>.  
  
   
  
## Examples  
 O exemplo a seguir mostra uma classe que deriva de <xref:System.Data.DataSet> classe. O <xref:System.Data.DataSet.ShouldSerializeTables%2A> método é chamado de dentro de funções na classe derivada.  
  
 [!code-csharp[Classic WebData DataSet.ShouldSerializeTables Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.ShouldSerializeTables Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.ShouldSerializeTables Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.ShouldSerializeTables Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">Usando conjuntos de dados no ADO.NET</related>
      </Docs>
    </Member>
    <Member MemberName="Site">
      <MemberSignature Language="C#" Value="public override System.ComponentModel.ISite Site { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ComponentModel.ISite Site" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataSet.Site" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property Site As ISite" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::ComponentModel::ISite ^ Site { System::ComponentModel::ISite ^ get(); void set(System::ComponentModel::ISite ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Site : System.ComponentModel.ISite with get, set" Usage="System.Data.DataSet.Site" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;netcore-2.2;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ComponentModel.ISite</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define um <see cref="T:System.ComponentModel.ISite" /> para o <see cref="T:System.Data.DataSet" />.</summary>
        <value>Um <see cref="T:System.ComponentModel.ISite" /> para o <see cref="T:System.Data.DataSet" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sites de associar uma <xref:System.ComponentModel.Component> para um <xref:System.ComponentModel.Container> e habilitar a comunicação entre eles, bem como fornecem uma maneira para o contêiner gerenciar seus componentes.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">Usando conjuntos de dados no ADO.NET</related>
      </Docs>
    </Member>
    <Member MemberName="System.ComponentModel.IListSource.ContainsListCollection">
      <MemberSignature Language="C#" Value="bool System.ComponentModel.IListSource.ContainsListCollection { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.ComponentModel.IListSource.ContainsListCollection" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataSet.System#ComponentModel#IListSource#ContainsListCollection" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property ContainsListCollection As Boolean Implements IListSource.ContainsListCollection" />
      <MemberSignature Language="C++ CLI" Value="property bool System::ComponentModel::IListSource::ContainsListCollection { bool get(); };" />
      <MemberSignature Language="F#" Usage="System.ComponentModel.IListSource.ContainsListCollection" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.ComponentModel.IListSource.ContainsListCollection</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Para obter uma descrição desse membro, consulte <see cref="P:System.ComponentModel.IListSource.ContainsListCollection" />.</summary>
        <value>Para obter uma descrição desse membro, consulte <see cref="P:System.ComponentModel.IListSource.ContainsListCollection" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este membro é uma implementação do membro de interface explícita. Ele só pode ser usado quando a instância de <xref:System.Data.DataSet> é convertida em uma interface de <xref:System.ComponentModel.IListSource>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.ComponentModel.IListSource.GetList">
      <MemberSignature Language="C#" Value="System.Collections.IList IListSource.GetList ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.IList System.ComponentModel.IListSource.GetList() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.System#ComponentModel#IListSource#GetList" />
      <MemberSignature Language="VB.NET" Value="Function GetList () As IList Implements IListSource.GetList" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::IList ^ System.ComponentModel.IListSource.GetList() = System::ComponentModel::IListSource::GetList;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ComponentModel.IListSource.GetList</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IList</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Para obter uma descrição desse membro, consulte <see cref="M:System.ComponentModel.IListSource.GetList" />.</summary>
        <returns>Para obter uma descrição desse membro, consulte <see cref="M:System.ComponentModel.IListSource.GetList" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este membro é uma implementação do membro de interface explícita. Ele só pode ser usado quando a instância de <xref:System.Data.DataSet> é convertida em uma interface de <xref:System.ComponentModel.IListSource>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.Serialization.ISerializable.GetObjectData">
      <MemberSignature Language="C#" Value="void ISerializable.GetObjectData (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.Serialization.ISerializable.GetObjectData(class System.Runtime.Serialization.SerializationInfo info, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.System#Runtime#Serialization#ISerializable#GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="VB.NET" Value="Sub GetObjectData (info As SerializationInfo, context As StreamingContext) Implements ISerializable.GetObjectData" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.Serialization.ISerializable.GetObjectData(System::Runtime::Serialization::SerializationInfo ^ info, System::Runtime::Serialization::StreamingContext context) = System::Runtime::Serialization::ISerializable::GetObjectData;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="info" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="info">O <see cref="T:System.Runtime.Serialization.SerializationInfo" /> a ser preenchido com dados.</param>
        <param name="context">O destino (consulte <see cref="T:System.Runtime.Serialization.StreamingContext" />) dessa serialização.</param>
        <summary>Popula um objeto de informações de serialização com os dados necessários para serializar o <see cref="T:System.Data.DataSet" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Xml.Serialization.IXmlSerializable.GetSchema">
      <MemberSignature Language="C#" Value="System.Xml.Schema.XmlSchema IXmlSerializable.GetSchema ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Xml.Schema.XmlSchema System.Xml.Serialization.IXmlSerializable.GetSchema() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.System#Xml#Serialization#IXmlSerializable#GetSchema" />
      <MemberSignature Language="VB.NET" Value="Function GetSchema () As XmlSchema Implements IXmlSerializable.GetSchema" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Xml::Schema::XmlSchema ^ System.Xml.Serialization.IXmlSerializable.GetSchema() = System::Xml::Serialization::IXmlSerializable::GetSchema;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Xml.Serialization.IXmlSerializable.GetSchema</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.Schema.XmlSchema</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Para obter uma descrição desse membro, consulte <see cref="M:System.Xml.Serialization.IXmlSerializable.GetSchema" />.</summary>
        <returns>Para obter uma descrição desse membro, consulte <see cref="M:System.Xml.Serialization.IXmlSerializable.GetSchema" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este membro é uma implementação do membro de interface explícita. Ele só pode ser usado quando a instância de <xref:System.Data.DataSet> é convertida em uma interface de <xref:System.Xml.Serialization.IXmlSerializable>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Xml.Serialization.IXmlSerializable.ReadXml">
      <MemberSignature Language="C#" Value="void IXmlSerializable.ReadXml (System.Xml.XmlReader reader);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Xml.Serialization.IXmlSerializable.ReadXml(class System.Xml.XmlReader reader) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.System#Xml#Serialization#IXmlSerializable#ReadXml(System.Xml.XmlReader)" />
      <MemberSignature Language="VB.NET" Value="Sub ReadXml (reader As XmlReader) Implements IXmlSerializable.ReadXml" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Xml.Serialization.IXmlSerializable.ReadXml(System::Xml::XmlReader ^ reader) = System::Xml::Serialization::IXmlSerializable::ReadXml;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Xml.Serialization.IXmlSerializable.ReadXml(System.Xml.XmlReader)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Xml.XmlReader" />
      </Parameters>
      <Docs>
        <param name="reader">Um <see cref="T:System.Xml.XmlReader" />.</param>
        <summary>Para obter uma descrição desse membro, consulte <see cref="M:System.Xml.Serialization.IXmlSerializable.ReadXml(System.Xml.XmlReader)" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este membro é uma implementação do membro de interface explícita. Ele só pode ser usado quando a instância de <xref:System.Data.DataSet> é convertida em uma interface de <xref:System.Xml.Serialization.IXmlSerializable>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Xml.Serialization.IXmlSerializable.WriteXml">
      <MemberSignature Language="C#" Value="void IXmlSerializable.WriteXml (System.Xml.XmlWriter writer);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Xml.Serialization.IXmlSerializable.WriteXml(class System.Xml.XmlWriter writer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.System#Xml#Serialization#IXmlSerializable#WriteXml(System.Xml.XmlWriter)" />
      <MemberSignature Language="VB.NET" Value="Sub WriteXml (writer As XmlWriter) Implements IXmlSerializable.WriteXml" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Xml.Serialization.IXmlSerializable.WriteXml(System::Xml::XmlWriter ^ writer) = System::Xml::Serialization::IXmlSerializable::WriteXml;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Xml.Serialization.IXmlSerializable.WriteXml(System.Xml.XmlWriter)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Xml.XmlWriter" />
      </Parameters>
      <Docs>
        <param name="writer">Um <see cref="T:System.Xml.XmlWriter" />.</param>
        <summary>Para obter uma descrição desse membro, consulte <see cref="M:System.Xml.Serialization.IXmlSerializable.WriteXml(System.Xml.XmlWriter)" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este membro é uma implementação do membro de interface explícita. Ele só pode ser usado quando a instância de <xref:System.Data.DataSet> é convertida em uma interface de <xref:System.Xml.Serialization.IXmlSerializable>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Tables">
      <MemberSignature Language="C#" Value="public System.Data.DataTableCollection Tables { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Data.DataTableCollection Tables" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataSet.Tables" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Tables As DataTableCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Data::DataTableCollection ^ Tables { System::Data::DataTableCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Tables : System.Data.DataTableCollection" Usage="System.Data.DataSet.Tables" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;netcore-2.2;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Content)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.Data.DataSysDescription("DataSetTablesDescr")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Data.DataTableCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém a coleção de tabelas contidas no <see cref="T:System.Data.DataSet" />.</summary>
        <value>O <see cref="T:System.Data.DataTableCollection" /> contido por este <see cref="T:System.Data.DataSet" />. Será retornada uma coleção vazia se não houver nenhum objeto <see cref="T:System.Data.DataTable" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para adicionar tabelas à coleção, use <xref:System.Data.DataTableCollection.Add%2A> método da <xref:System.Data.DataTableCollection>. Para remover tabelas, use o <xref:System.Data.DataTableCollection.Remove%2A> método.  
  
   
  
## Examples  
 O exemplo a seguir retorna o <xref:System.Data.DataSet> do objeto <xref:System.Data.DataTableCollection>e imprime as colunas e linhas em cada tabela.  
  
 [!code-csharp[Classic WebData DataSet.Tables Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.Tables Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.Tables Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.Tables Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">Usando conjuntos de dados no ADO.NET</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="WriteXml">
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Grava os dados XML e opcionalmente o esquema, do <see cref="T:System.Data.DataSet" />.</summary>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">Usando conjuntos de dados no ADO.NET</related>
      </Docs>
    </MemberGroup>
    <Member MemberName="WriteXml">
      <MemberSignature Language="C#" Value="public void WriteXml (System.IO.Stream stream);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXml(class System.IO.Stream stream) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.WriteXml(System.IO.Stream)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXml(System::IO::Stream ^ stream);" />
      <MemberSignature Language="F#" Value="member this.WriteXml : System.IO.Stream -&gt; unit" Usage="dataSet.WriteXml stream" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
      </Parameters>
      <Docs>
        <param name="stream">Um objeto <see cref="T:System.IO.Stream" /> usado para gravar em um arquivo.</param>
        <summary>Grava os dados atuais para o <see cref="T:System.Data.DataSet" /> usando o <see cref="T:System.IO.Stream" /> especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O método `WriteXml` fornece uma maneira de gravar apenas dados ou dados e esquema em um <xref:System.Data.DataSet> a partir de um documento XML, e o método <xref:System.Data.DataSet.WriteXmlSchema%2A> grava apenas o esquema. Para gravar dados e esquema, use uma das sobrecargas que inclua o parâmetro `mode` e defina o valor como `WriteSchema`.  
  
 Observe que o mesmo é verdadeiro para os métodos <xref:System.Data.DataSet.ReadXml%2A> e <xref:System.Data.DataSet.ReadXmlSchema%2A>, respectivamente. Para ler dados XML, ou o esquema e os dados no `DataSet`, use o método `ReadXml`. Para ler apenas o esquema, use o método `ReadXmlSchema`.  
  
> [!NOTE]
>  Um <xref:System.InvalidOperationException> será lançado se um tipo de coluna no `DataRow` de leitura ou gravação implementa <xref:System.Dynamic.IDynamicMetaObjectProvider> e não implementa <xref:System.Xml.Serialization.IXmlSerializable>.  
  
   
  
## Examples  
 O exemplo a seguir cria um <xref:System.IO.FileStream?displayProperty=nameWithType> objeto. O objeto é usado com o <xref:System.Data.DataSet.WriteXml%2A> método para gravar um documento XML.  
  
 [!code-csharp[Classic WebData DataSet.WriteXml Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.WriteXml Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.WriteXml Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.WriteXml Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">Usando conjuntos de dados no ADO.NET</related>
      </Docs>
    </Member>
    <Member MemberName="WriteXml">
      <MemberSignature Language="C#" Value="public void WriteXml (System.IO.TextWriter writer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXml(class System.IO.TextWriter writer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.WriteXml(System.IO.TextWriter)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteXml (writer As TextWriter)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXml(System::IO::TextWriter ^ writer);" />
      <MemberSignature Language="F#" Value="member this.WriteXml : System.IO.TextWriter -&gt; unit" Usage="dataSet.WriteXml writer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.IO.TextWriter" />
      </Parameters>
      <Docs>
        <param name="writer">O objeto <see cref="T:System.IO.TextWriter" /> com o qual gravar.</param>
        <summary>Grava os dados atuais para o <see cref="T:System.Data.DataSet" /> usando o <see cref="T:System.IO.TextWriter" /> especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O método `WriteXml` fornece uma maneira de gravar apenas dados ou dados e esquema em um <xref:System.Data.DataSet> a partir de um documento XML, e o método <xref:System.Data.DataSet.WriteXmlSchema%2A> grava apenas o esquema. Para gravar dados e esquema, use uma das sobrecargas que inclua o parâmetro `mode` e defina o valor como `WriteSchema`.  
  
 Observe que o mesmo é verdadeiro para os métodos <xref:System.Data.DataSet.ReadXml%2A> e <xref:System.Data.DataSet.ReadXmlSchema%2A>, respectivamente. Para ler dados XML, ou o esquema e os dados no `DataSet`, use o método `ReadXml`. Para ler apenas o esquema, use o método `ReadXmlSchema`.  
  
> [!NOTE]
>  Um <xref:System.InvalidOperationException> será lançado se um tipo de coluna no `DataRow` de leitura ou gravação implementa <xref:System.Dynamic.IDynamicMetaObjectProvider> e não implementa <xref:System.Xml.Serialization.IXmlSerializable>.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">Usando conjuntos de dados no ADO.NET</related>
      </Docs>
    </Member>
    <Member MemberName="WriteXml">
      <MemberSignature Language="C#" Value="public void WriteXml (string fileName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXml(string fileName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.WriteXml(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteXml (fileName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXml(System::String ^ fileName);" />
      <MemberSignature Language="F#" Value="member this.WriteXml : string -&gt; unit" Usage="dataSet.WriteXml fileName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="fileName">O nome do arquivo (incluindo o caminho) no qual gravar.</param>
        <summary>Grava os dados atuais do <see cref="T:System.Data.DataSet" /> no arquivo especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O método `WriteXml` fornece uma maneira de gravar apenas dados ou dados e esquema em um <xref:System.Data.DataSet> a partir de um documento XML, e o método <xref:System.Data.DataSet.WriteXmlSchema%2A> grava apenas o esquema. Para gravar dados e esquema, use uma das sobrecargas que inclua o parâmetro `mode` e defina o valor como `WriteSchema`.  
  
 Observe que o mesmo é verdadeiro para os métodos <xref:System.Data.DataSet.ReadXml%2A> e <xref:System.Data.DataSet.ReadXmlSchema%2A>, respectivamente. Para ler dados XML, ou o esquema e os dados no `DataSet`, use o método `ReadXml`. Para ler apenas o esquema, use o método `ReadXmlSchema`.  
  
> [!NOTE]
>  Um <xref:System.InvalidOperationException> será lançado se um tipo de coluna no `DataRow` de leitura ou gravação implementa <xref:System.Dynamic.IDynamicMetaObjectProvider> e não implementa <xref:System.Xml.Serialization.IXmlSerializable>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException"><see cref="T:System.Security.Permissions.FileIOPermission" /> não é definido como <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" />.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">para ler e gravar arquivos. Enumeração associada: <see cref="T:System.Security.Permissions.FileIOPermissionAccess" /></permission>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">Usando conjuntos de dados no ADO.NET</related>
      </Docs>
    </Member>
    <Member MemberName="WriteXml">
      <MemberSignature Language="C#" Value="public void WriteXml (System.Xml.XmlWriter writer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXml(class System.Xml.XmlWriter writer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.WriteXml(System.Xml.XmlWriter)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteXml (writer As XmlWriter)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXml(System::Xml::XmlWriter ^ writer);" />
      <MemberSignature Language="F#" Value="member this.WriteXml : System.Xml.XmlWriter -&gt; unit" Usage="dataSet.WriteXml writer" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Xml.Serialization.IXmlSerializable.WriteXml(System.Xml.XmlWriter)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Xml.XmlWriter" />
      </Parameters>
      <Docs>
        <param name="writer">O <see cref="T:System.Xml.XmlWriter" /> com o qual gravar.</param>
        <summary>Grava os dados atuais do <see cref="T:System.Data.DataSet" /> no <see cref="T:System.Xml.XmlWriter" /> especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O método `WriteXml` fornece uma maneira de gravar apenas dados ou dados e esquema em um <xref:System.Data.DataSet> a partir de um documento XML, e o método <xref:System.Data.DataSet.WriteXmlSchema%2A> grava apenas o esquema. Para gravar dados e esquema, use uma das sobrecargas que inclua o parâmetro `mode` e defina o valor como `WriteSchema`.  
  
 Observe que o mesmo é verdadeiro para os métodos <xref:System.Data.DataSet.ReadXml%2A> e <xref:System.Data.DataSet.ReadXmlSchema%2A>, respectivamente. Para ler dados XML, ou o esquema e os dados no `DataSet`, use o método `ReadXml`. Para ler apenas o esquema, use o método `ReadXmlSchema`.  
  
> [!NOTE]
>  Um <xref:System.InvalidOperationException> será lançado se um tipo de coluna no `DataRow` de leitura ou gravação implementa <xref:System.Dynamic.IDynamicMetaObjectProvider> e não implementa <xref:System.Xml.Serialization.IXmlSerializable>.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">Usando conjuntos de dados no ADO.NET</related>
      </Docs>
    </Member>
    <Member MemberName="WriteXml">
      <MemberSignature Language="C#" Value="public void WriteXml (System.IO.Stream stream, System.Data.XmlWriteMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXml(class System.IO.Stream stream, valuetype System.Data.XmlWriteMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.WriteXml(System.IO.Stream,System.Data.XmlWriteMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXml(System::IO::Stream ^ stream, System::Data::XmlWriteMode mode);" />
      <MemberSignature Language="F#" Value="member this.WriteXml : System.IO.Stream * System.Data.XmlWriteMode -&gt; unit" Usage="dataSet.WriteXml (stream, mode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
        <Parameter Name="mode" Type="System.Data.XmlWriteMode" />
      </Parameters>
      <Docs>
        <param name="stream">Um objeto <see cref="T:System.IO.Stream" /> usado para gravar em um arquivo.</param>
        <param name="mode">Um dos valores de <see cref="T:System.Data.XmlWriteMode" />.</param>
        <summary>Grava os dados atuais e, opcionalmente, o esquema do <see cref="T:System.Data.DataSet" /> usando o <see cref="T:System.IO.Stream" /> e o <see cref="T:System.Data.XmlWriteMode" /> especificados. Para gravar o esquema, defina o valor do parâmetro <paramref name="mode" /> como <see langword="WriteSchema" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O método `WriteXml` fornece uma maneira de gravar apenas dados ou dados e esquema em um <xref:System.Data.DataSet> a partir de um documento XML, e o método <xref:System.Data.DataSet.WriteXmlSchema%2A> grava apenas o esquema. Para gravar dados e esquema, defina o parâmetro `mode` como `WriteSchema`.  
  
 Observe que o mesmo é verdadeiro para os métodos <xref:System.Data.DataSet.ReadXml%2A> e <xref:System.Data.DataSet.ReadXmlSchema%2A>, respectivamente. Para ler dados XML, ou o esquema e os dados no `DataSet`, use o método `ReadXml`. Para ler apenas o esquema, use o método `ReadXmlSchema`.  
  
> [!NOTE]
>  Um <xref:System.InvalidOperationException> será lançado se um tipo de coluna no `DataRow` de leitura ou gravação implementa <xref:System.Dynamic.IDynamicMetaObjectProvider> e não implementa <xref:System.Xml.Serialization.IXmlSerializable>.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">Usando conjuntos de dados no ADO.NET</related>
      </Docs>
    </Member>
    <Member MemberName="WriteXml">
      <MemberSignature Language="C#" Value="public void WriteXml (System.IO.TextWriter writer, System.Data.XmlWriteMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXml(class System.IO.TextWriter writer, valuetype System.Data.XmlWriteMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.WriteXml(System.IO.TextWriter,System.Data.XmlWriteMode)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteXml (writer As TextWriter, mode As XmlWriteMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXml(System::IO::TextWriter ^ writer, System::Data::XmlWriteMode mode);" />
      <MemberSignature Language="F#" Value="member this.WriteXml : System.IO.TextWriter * System.Data.XmlWriteMode -&gt; unit" Usage="dataSet.WriteXml (writer, mode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.IO.TextWriter" />
        <Parameter Name="mode" Type="System.Data.XmlWriteMode" />
      </Parameters>
      <Docs>
        <param name="writer">Um objeto <see cref="T:System.IO.TextWriter" /> usado para gravar o documento.</param>
        <param name="mode">Um dos valores de <see cref="T:System.Data.XmlWriteMode" />.</param>
        <summary>Grava os dados atuais e, opcionalmente, o esquema do <see cref="T:System.Data.DataSet" /> usando o <see cref="T:System.IO.TextWriter" /> e o <see cref="T:System.Data.XmlWriteMode" /> especificados. Para gravar o esquema, defina o valor do parâmetro <paramref name="mode" /> como <see langword="WriteSchema" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O método `WriteXml` fornece uma maneira de gravar apenas dados ou dados e esquema em um <xref:System.Data.DataSet> a partir de um documento XML, e o método <xref:System.Data.DataSet.WriteXmlSchema%2A> grava apenas o esquema. Para gravar dados e esquema, defina o parâmetro `mode` como `WriteSchema`.  
  
 Observe que o mesmo é verdadeiro para os métodos <xref:System.Data.DataSet.ReadXml%2A> e <xref:System.Data.DataSet.ReadXmlSchema%2A>, respectivamente. Para ler dados XML, ou o esquema e os dados no `DataSet`, use o método `ReadXml`. Para ler apenas o esquema, use o método `ReadXmlSchema`.  
  
> [!NOTE]
>  Um <xref:System.InvalidOperationException> será lançado se um tipo de coluna no `DataRow` de leitura ou gravação implementa <xref:System.Dynamic.IDynamicMetaObjectProvider> e não implementa <xref:System.Xml.Serialization.IXmlSerializable>.  
  
   
  
## Examples  
 O exemplo a seguir primeiramente cria um <xref:System.Data.DataSet> simples com um <xref:System.Data.DataTable>, duas colunas e dez linhas. O esquema <xref:System.Data.DataSet> e os dados são gravados em disco invocando o método <xref:System.Data.DataSet.WriteXml%2A>. Um segundo <xref:System.Data.DataSet> é criado e o método <xref:System.Data.DataSet.ReadXml%2A> é usado para preenchê-lo com esquema e dados.  
  
 [!code-csharp[Classic WebData DataSet.ReadXml2 Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.ReadXml2 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.ReadXml2 Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.ReadXml2 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">Usando conjuntos de dados no ADO.NET</related>
      </Docs>
    </Member>
    <Member MemberName="WriteXml">
      <MemberSignature Language="C#" Value="public void WriteXml (string fileName, System.Data.XmlWriteMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXml(string fileName, valuetype System.Data.XmlWriteMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.WriteXml(System.String,System.Data.XmlWriteMode)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteXml (fileName As String, mode As XmlWriteMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXml(System::String ^ fileName, System::Data::XmlWriteMode mode);" />
      <MemberSignature Language="F#" Value="member this.WriteXml : string * System.Data.XmlWriteMode -&gt; unit" Usage="dataSet.WriteXml (fileName, mode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
        <Parameter Name="mode" Type="System.Data.XmlWriteMode" />
      </Parameters>
      <Docs>
        <param name="fileName">O nome do arquivo (incluindo o caminho) no qual gravar.</param>
        <param name="mode">Um dos valores de <see cref="T:System.Data.XmlWriteMode" />.</param>
        <summary>Grava os dados atuais e, opcionalmente, o esquema do <see cref="T:System.Data.DataSet" /> no arquivo especificado usando o <see cref="T:System.Data.XmlWriteMode" /> especificado. Para gravar o esquema, defina o valor do parâmetro <paramref name="mode" /> como <see langword="WriteSchema" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O método `WriteXml` fornece uma maneira de gravar apenas dados ou dados e esquema em um <xref:System.Data.DataSet> a partir de um documento XML, e o método <xref:System.Data.DataSet.WriteXmlSchema%2A> grava apenas o esquema. Para gravar dados e esquema, defina o parâmetro `mode` como `WriteSchema`.  
  
 Observe que o mesmo é verdadeiro para os métodos <xref:System.Data.DataSet.ReadXml%2A> e <xref:System.Data.DataSet.ReadXmlSchema%2A>, respectivamente. Para ler dados XML, ou o esquema e os dados no `DataSet`, use o método `ReadXml`. Para ler apenas o esquema, use o método `ReadXmlSchema`.  
  
> [!NOTE]
>  Um <xref:System.InvalidOperationException> será lançado se um tipo de coluna no `DataRow` de leitura ou gravação implementa <xref:System.Dynamic.IDynamicMetaObjectProvider> e não implementa <xref:System.Xml.Serialization.IXmlSerializable>.  
  
   
  
## Examples  
 O exemplo a seguir usa o <xref:System.Data.DataSet.WriteXml%2A> método para gravar um documento XML.  
  
 [!code-csharp[Classic WebData DataSet.WriteXml7 Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.WriteXml7 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.WriteXml7 Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.WriteXml7 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException"><see cref="T:System.Security.Permissions.FileIOPermission" /> não é definido como <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" />.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">para ler e gravar arquivos. Enumeração associada: <see cref="T:System.Security.Permissions.FileIOPermissionAccess" /></permission>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">Usando conjuntos de dados no ADO.NET</related>
      </Docs>
    </Member>
    <Member MemberName="WriteXml">
      <MemberSignature Language="C#" Value="public void WriteXml (System.Xml.XmlWriter writer, System.Data.XmlWriteMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXml(class System.Xml.XmlWriter writer, valuetype System.Data.XmlWriteMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.WriteXml(System.Xml.XmlWriter,System.Data.XmlWriteMode)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteXml (writer As XmlWriter, mode As XmlWriteMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXml(System::Xml::XmlWriter ^ writer, System::Data::XmlWriteMode mode);" />
      <MemberSignature Language="F#" Value="member this.WriteXml : System.Xml.XmlWriter * System.Data.XmlWriteMode -&gt; unit" Usage="dataSet.WriteXml (writer, mode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Xml.XmlWriter" />
        <Parameter Name="mode" Type="System.Data.XmlWriteMode" />
      </Parameters>
      <Docs>
        <param name="writer">O <see cref="T:System.Xml.XmlWriter" /> com o qual gravar.</param>
        <param name="mode">Um dos valores de <see cref="T:System.Data.XmlWriteMode" />.</param>
        <summary>Grava os dados atuais e, opcionalmente, o esquema do <see cref="T:System.Data.DataSet" /> usando o <see cref="T:System.Xml.XmlWriter" /> e o <see cref="T:System.Data.XmlWriteMode" /> especificados. Para gravar o esquema, defina o valor do parâmetro <paramref name="mode" /> como <see langword="WriteSchema" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O método `WriteXml` fornece uma maneira de gravar apenas dados ou dados e esquema em um <xref:System.Data.DataSet> a partir de um documento XML, e o método <xref:System.Data.DataSet.WriteXmlSchema%2A> grava apenas o esquema. Para gravar dados e esquema, defina o parâmetro `mode` como `WriteSchema`.  
  
 Observe que o mesmo é verdadeiro para os métodos <xref:System.Data.DataSet.ReadXml%2A> e <xref:System.Data.DataSet.ReadXmlSchema%2A>, respectivamente. Para ler dados XML, ou o esquema e os dados no `DataSet`, use o método `ReadXml`. Para ler apenas o esquema, use o método `ReadXmlSchema`.  
  
> [!NOTE]
>  Um <xref:System.InvalidOperationException> será lançado se um tipo de coluna no `DataRow` de leitura ou gravação implementa <xref:System.Dynamic.IDynamicMetaObjectProvider> e não implementa <xref:System.Xml.Serialization.IXmlSerializable>.  
  
   
  
## Examples  
 O exemplo a seguir cria uma <xref:System.IO.FileStream?displayProperty=nameWithType> objeto que é usado para criar um novo <xref:System.Xml.XmlTextWriter>. O <xref:System.Xml.XmlTextWriter> objeto é usado com o <xref:System.Data.DataSet.WriteXml%2A> método para gravar um documento XML.  
  
 [!code-csharp[Classic WebData DataSet.WriteXml6 Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.WriteXml6 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.WriteXml6 Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.WriteXml6 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">Usando conjuntos de dados no ADO.NET</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="WriteXmlSchema">
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Grava a estrutura <see cref="T:System.Data.DataSet" /> como um esquema XML.</summary>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">Usando conjuntos de dados no ADO.NET</related>
      </Docs>
    </MemberGroup>
    <Member MemberName="WriteXmlSchema">
      <MemberSignature Language="C#" Value="public void WriteXmlSchema (System.IO.Stream stream);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXmlSchema(class System.IO.Stream stream) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.WriteXmlSchema(System.IO.Stream)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXmlSchema(System::IO::Stream ^ stream);" />
      <MemberSignature Language="F#" Value="member this.WriteXmlSchema : System.IO.Stream -&gt; unit" Usage="dataSet.WriteXmlSchema stream" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
      </Parameters>
      <Docs>
        <param name="stream">Um objeto <see cref="T:System.IO.Stream" /> usado para gravar em um arquivo.</param>
        <summary>Grava a estrutura <see cref="T:System.Data.DataSet" /> como um esquema XML no objeto <see cref="T:System.IO.Stream" /> especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use o método <xref:System.Data.DataSet.WriteXmlSchema%2A> para gravar o esquema de um <xref:System.Data.DataSet> em um documento XML. O esquema inclui tabela, relação e definições de restrição. Para gravar um esquema em um documento XML, use o método <xref:System.Data.DataSet.WriteXmlSchema%2A>.  
  
 O esquema XML é gravado usando o padrão XSD.  
  
 Para gravar os dados em um documento XML, use o método <xref:System.Data.DataSet.WriteXml%2A>.  
  
 Classes que derivam de <xref:System.IO.Stream> classe incluir <xref:System.IO.BufferedStream>, <xref:System.IO.FileStream>, <xref:System.IO.MemoryStream>, e <xref:System.Net.Sockets.NetworkStream>.  
  
   
  
## Examples  
 O exemplo a seguir cria um novo <xref:System.IO.FileStream> objeto que é passado para o <xref:System.Data.DataSet.WriteXmlSchema%2A> método para gravar o esquema no disco.  
  
 [!code-csharp[Classic WebData DataSet.WriteXmlSchema Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.WriteXmlSchema Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.WriteXmlSchema Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.WriteXmlSchema Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">Usando conjuntos de dados no ADO.NET</related>
      </Docs>
    </Member>
    <Member MemberName="WriteXmlSchema">
      <MemberSignature Language="C#" Value="public void WriteXmlSchema (System.IO.TextWriter writer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXmlSchema(class System.IO.TextWriter writer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.WriteXmlSchema(System.IO.TextWriter)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteXmlSchema (writer As TextWriter)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXmlSchema(System::IO::TextWriter ^ writer);" />
      <MemberSignature Language="F#" Value="member this.WriteXmlSchema : System.IO.TextWriter -&gt; unit" Usage="dataSet.WriteXmlSchema writer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.IO.TextWriter" />
      </Parameters>
      <Docs>
        <param name="writer">O objeto <see cref="T:System.IO.TextWriter" /> com o qual gravar.</param>
        <summary>Grava a estrutura <see cref="T:System.Data.DataSet" /> como um esquema XML no objeto <see cref="T:System.IO.TextWriter" /> especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use o método <xref:System.Data.DataSet.WriteXmlSchema%2A> para gravar o esquema de um <xref:System.Data.DataSet> em um documento XML. O esquema inclui tabela, relação e definições de restrição. Para gravar um esquema em um documento XML, use o método <xref:System.Data.DataSet.WriteXmlSchema%2A>.  
  
 O esquema XML é gravado usando o padrão XSD.  
  
 Para gravar os dados em um documento XML, use o método <xref:System.Data.DataSet.WriteXml%2A>.  
  
 Classes de derivar do <xref:System.IO.TextWriter?displayProperty=nameWithType> classe incluem o <xref:System.Web.HttpWriter?displayProperty=nameWithType>, <xref:System.CodeDom.Compiler.IndentedTextWriter?displayProperty=nameWithType>, <xref:System.Web.UI.HtmlTextWriter?displayProperty=nameWithType>, <xref:System.IO.StreamWriter?displayProperty=nameWithType>, e <xref:System.IO.StringWriter?displayProperty=nameWithType>.  
  
   
  
## Examples  
 O exemplo a seguir cria uma <xref:System.Text.StringBuilder?displayProperty=nameWithType> objeto que é usado para criar um novo <xref:System.IO.StringWriter?displayProperty=nameWithType>. O <xref:System.IO.StringWriter> é passado para o <xref:System.Data.DataSet.WriteXmlSchema%2A> método e a cadeia de caracteres resultante é impresso na janela do console.  
  
 [!code-csharp[Classic WebData DataSet.WriteXmlSchema1 Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.WriteXmlSchema1 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.WriteXmlSchema1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.WriteXmlSchema1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">Usando conjuntos de dados no ADO.NET</related>
      </Docs>
    </Member>
    <Member MemberName="WriteXmlSchema">
      <MemberSignature Language="C#" Value="public void WriteXmlSchema (string fileName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXmlSchema(string fileName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.WriteXmlSchema(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteXmlSchema (fileName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXmlSchema(System::String ^ fileName);" />
      <MemberSignature Language="F#" Value="member this.WriteXmlSchema : string -&gt; unit" Usage="dataSet.WriteXmlSchema fileName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="fileName">O nome do arquivo (incluindo o caminho) no qual gravar.</param>
        <summary>Grava a estrutura <see cref="T:System.Data.DataSet" /> como um esquema XML em um arquivo.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use o método <xref:System.Data.DataSet.WriteXmlSchema%2A> para gravar o esquema de um <xref:System.Data.DataSet> em um documento XML. O esquema inclui tabela, relação e definições de restrição. Para gravar um esquema em um documento XML, use o método <xref:System.Data.DataSet.WriteXmlSchema%2A>.  
  
 O esquema XML é gravado usando o padrão XSD.  
  
 Para gravar os dados em um documento XML, use o método <xref:System.Data.DataSet.WriteXml%2A>.  
  
   
  
## Examples  
 [!code-csharp[Classic WebData DataSet.WriteXmlSchema3 Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.WriteXmlSchema3 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.WriteXmlSchema3 Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.WriteXmlSchema3 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException"><see cref="T:System.Security.Permissions.FileIOPermission" /> não é definido como <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" />.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">para ler e gravar arquivos. Enumeração associada: <see cref="T:System.Security.Permissions.FileIOPermissionAccess" /></permission>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">Usando conjuntos de dados no ADO.NET</related>
      </Docs>
    </Member>
    <Member MemberName="WriteXmlSchema">
      <MemberSignature Language="C#" Value="public void WriteXmlSchema (System.Xml.XmlWriter writer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXmlSchema(class System.Xml.XmlWriter writer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.WriteXmlSchema(System.Xml.XmlWriter)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteXmlSchema (writer As XmlWriter)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXmlSchema(System::Xml::XmlWriter ^ writer);" />
      <MemberSignature Language="F#" Value="member this.WriteXmlSchema : System.Xml.XmlWriter -&gt; unit" Usage="dataSet.WriteXmlSchema writer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Xml.XmlWriter" />
      </Parameters>
      <Docs>
        <param name="writer">O <see cref="T:System.Xml.XmlWriter" /> no qual ocorrerá a gravação.</param>
        <summary>Grava a estrutura <see cref="T:System.Data.DataSet" /> como um esquema XML em um objeto <see cref="T:System.Xml.XmlWriter" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use o método <xref:System.Data.DataSet.WriteXmlSchema%2A> para gravar o esquema de um <xref:System.Data.DataSet> em um documento XML. O esquema inclui tabela, relação e definições de restrição. Para gravar um esquema em um documento XML, use o método <xref:System.Data.DataSet.WriteXmlSchema%2A>.  
  
 O esquema XML é gravado usando o padrão XSD.  
  
 Para gravar os dados em um documento XML, use o método <xref:System.Data.DataSet.WriteXml%2A>.  
  
 Uma classe que herda de <xref:System.Xml.XmlWriter?displayProperty=nameWithType> classe é o <xref:System.Xml.XmlTextWriter> classe.  
  
   
  
## Examples  
 O exemplo a seguir cria um novo <xref:System.IO.FileStream?displayProperty=nameWithType> objeto com o caminho especificado. O <xref:System.IO.FileStream> objeto é usado para criar um <xref:System.Xml.XmlTextWriter> objeto. O <xref:System.Data.DataSet.WriteXmlSchema%2A> método é invocado, em seguida, com o <xref:System.Xml.XmlTextWriter> objeto a gravar o esquema para o disco.  
  
 [!code-csharp[Classic WebData DataSet.WriteXmlSchema2 Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.WriteXmlSchema2 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.WriteXmlSchema2 Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.WriteXmlSchema2 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">Usando conjuntos de dados no ADO.NET</related>
      </Docs>
    </Member>
    <Member MemberName="WriteXmlSchema">
      <MemberSignature Language="C#" Value="public void WriteXmlSchema (System.IO.Stream stream, Converter&lt;Type,string&gt; multipleTargetConverter);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXmlSchema(class System.IO.Stream stream, class System.Converter`2&lt;class System.Type, string&gt; multipleTargetConverter) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.WriteXmlSchema(System.IO.Stream,System.Converter{System.Type,System.String})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXmlSchema(System::IO::Stream ^ stream, Converter&lt;Type ^, System::String ^&gt; ^ multipleTargetConverter);" />
      <MemberSignature Language="F#" Value="member this.WriteXmlSchema : System.IO.Stream * Converter&lt;Type, string&gt; -&gt; unit" Usage="dataSet.WriteXmlSchema (stream, multipleTargetConverter)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
        <Parameter Name="multipleTargetConverter" Type="System.Converter&lt;System.Type,System.String&gt;" />
      </Parameters>
      <Docs>
        <param name="stream">O objeto <see cref="T:System.IO.Stream" /> no qual gravar.</param>
        <param name="multipleTargetConverter">Um representante usado para converter <see cref="T:System.Type" /> na cadeia de caracteres.</param>
        <summary>Grava a estrutura <see cref="T:System.Data.DataSet" /> como um esquema XML no objeto <see cref="T:System.IO.Stream" /> especificado.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteXmlSchema">
      <MemberSignature Language="C#" Value="public void WriteXmlSchema (System.IO.TextWriter writer, Converter&lt;Type,string&gt; multipleTargetConverter);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXmlSchema(class System.IO.TextWriter writer, class System.Converter`2&lt;class System.Type, string&gt; multipleTargetConverter) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.WriteXmlSchema(System.IO.TextWriter,System.Converter{System.Type,System.String})" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteXmlSchema (writer As TextWriter, multipleTargetConverter As Converter(Of Type, String))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXmlSchema(System::IO::TextWriter ^ writer, Converter&lt;Type ^, System::String ^&gt; ^ multipleTargetConverter);" />
      <MemberSignature Language="F#" Value="member this.WriteXmlSchema : System.IO.TextWriter * Converter&lt;Type, string&gt; -&gt; unit" Usage="dataSet.WriteXmlSchema (writer, multipleTargetConverter)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.IO.TextWriter" />
        <Parameter Name="multipleTargetConverter" Type="System.Converter&lt;System.Type,System.String&gt;" />
      </Parameters>
      <Docs>
        <param name="writer">O objeto <see cref="T:System.IO.TextWriter" /> no qual gravar.</param>
        <param name="multipleTargetConverter">Um representante usado para converter <see cref="T:System.Type" /> na cadeia de caracteres.</param>
        <summary>Grava a estrutura <see cref="T:System.Data.DataSet" /> como um esquema XML no <see cref="T:System.IO.TextWriter" /> especificado.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteXmlSchema">
      <MemberSignature Language="C#" Value="public void WriteXmlSchema (string fileName, Converter&lt;Type,string&gt; multipleTargetConverter);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXmlSchema(string fileName, class System.Converter`2&lt;class System.Type, string&gt; multipleTargetConverter) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.WriteXmlSchema(System.String,System.Converter{System.Type,System.String})" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteXmlSchema (fileName As String, multipleTargetConverter As Converter(Of Type, String))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXmlSchema(System::String ^ fileName, Converter&lt;Type ^, System::String ^&gt; ^ multipleTargetConverter);" />
      <MemberSignature Language="F#" Value="member this.WriteXmlSchema : string * Converter&lt;Type, string&gt; -&gt; unit" Usage="dataSet.WriteXmlSchema (fileName, multipleTargetConverter)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
        <Parameter Name="multipleTargetConverter" Type="System.Converter&lt;System.Type,System.String&gt;" />
      </Parameters>
      <Docs>
        <param name="fileName">O nome do arquivo no qual gravar.</param>
        <param name="multipleTargetConverter">Um representante usado para converter <see cref="T:System.Type" /> na cadeia de caracteres.</param>
        <summary>Grava a estrutura <see cref="T:System.Data.DataSet" /> como um esquema XML em um arquivo.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteXmlSchema">
      <MemberSignature Language="C#" Value="public void WriteXmlSchema (System.Xml.XmlWriter writer, Converter&lt;Type,string&gt; multipleTargetConverter);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXmlSchema(class System.Xml.XmlWriter writer, class System.Converter`2&lt;class System.Type, string&gt; multipleTargetConverter) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.WriteXmlSchema(System.Xml.XmlWriter,System.Converter{System.Type,System.String})" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteXmlSchema (writer As XmlWriter, multipleTargetConverter As Converter(Of Type, String))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXmlSchema(System::Xml::XmlWriter ^ writer, Converter&lt;Type ^, System::String ^&gt; ^ multipleTargetConverter);" />
      <MemberSignature Language="F#" Value="member this.WriteXmlSchema : System.Xml.XmlWriter * Converter&lt;Type, string&gt; -&gt; unit" Usage="dataSet.WriteXmlSchema (writer, multipleTargetConverter)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Xml.XmlWriter" />
        <Parameter Name="multipleTargetConverter" Type="System.Converter&lt;System.Type,System.String&gt;" />
      </Parameters>
      <Docs>
        <param name="writer">O objeto <see cref="T:System.Xml.XmlWriter" /> no qual gravar.</param>
        <param name="multipleTargetConverter">Um representante usado para converter <see cref="T:System.Type" /> na cadeia de caracteres.</param>
        <summary>Grava a estrutura <see cref="T:System.Data.DataSet" /> como um esquema XML no <see cref="T:System.Xml.XmlWriter" /> especificado.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>