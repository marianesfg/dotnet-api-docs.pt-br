<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="RegistryAccessRule.xml" source-language="en-US" target-language="pt-BR">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-15c36f0" tool-company="Microsoft" />
      <xliffext:skl_file_name xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">02cd5861-7ce2-4a82-b358-31f8435a0ac562c3253705ce2579586fdcfa198c3e0977ef242d.skl</xliffext:skl_file_name>
      <xliffext:version xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">1.2</xliffext:version>
      <xliffext:ms.openlocfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">62c3253705ce2579586fdcfa198c3e0977ef242d</xliffext:ms.openlocfilehash>
      <xliffext:ms.sourcegitcommit xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b</xliffext:ms.sourcegitcommit>
      <xliffext:ms.lasthandoff xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">04/03/2018</xliffext:ms.lasthandoff>
      <xliffext:moniker_ids xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">netcore-1.0,netcore-1.1,netcore-2.0,netframework-4.5.1,netframework-4.5.2,netframework-4.5,netframework-4.6.1,netframework-4.6.2,netframework-4.6,netframework-4.7.1,netframework-4.7,xamarinandroid-7.1,xamarinios-10.8,xamarinmac-3.0</xliffext:moniker_ids>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve" uid="T:System.Security.AccessControl.RegistryAccessRule">
          <source>Represents a set of access rights allowed or denied for a user or group.</source>
          <target state="translated">Representa um conjunto de direitos de acesso permitidos ou negados para um usuário ou grupo.</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve" uid="T:System.Security.AccessControl.RegistryAccessRule">
          <source>This class cannot be inherited.</source>
          <target state="translated">Essa classe não pode ser herdada.</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Security.AccessControl.RegistryAccessRule">
          <source>The <ph id="ph1">&lt;xref:System.Security.AccessControl.RegistryAccessRule&gt;</ph> class is one of a set of classes that the .NET Framework provides for managing Windows access control security on registry keys.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Security.AccessControl.RegistryAccessRule&gt;</ph> classe é parte de um conjunto de classes do .NET Framework fornece para gerenciar a segurança de controle de acesso do Windows em chaves do registro.</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Security.AccessControl.RegistryAccessRule">
          <source>For an overview of these classes, and their relationship to the underlying Windows access control structures, see <ph id="ph1">&lt;xref:System.Security.AccessControl.RegistrySecurity&gt;</ph>.</source>
          <target state="translated">Para obter uma visão geral dessas classes e suas relações com as estruturas de controle de acesso subjacentes do Windows, consulte <ph id="ph1">&lt;xref:System.Security.AccessControl.RegistrySecurity&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Security.AccessControl.RegistryAccessRule">
          <source>Windows access control security can only be applied to registry keys.</source>
          <target state="translated">Segurança de controle de acesso do Windows só pode ser aplicada às chaves do registro.</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Security.AccessControl.RegistryAccessRule">
          <source>It cannot be applied to individual key/value pairs stored in a key.</source>
          <target state="translated">Ele não pode ser aplicado para pares de chave/valor individuais armazenados em uma chave.</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Security.AccessControl.RegistryAccessRule">
          <source>To get a list of the rules currently applied to a registry key, use the <ph id="ph1">&lt;xref:Microsoft.Win32.RegistryKey.GetAccessControl%2A?displayProperty=nameWithType&gt;</ph> method to get a <ph id="ph2">&lt;xref:System.Security.AccessControl.RegistrySecurity&gt;</ph> object, and then use its <ph id="ph3">&lt;xref:System.Security.AccessControl.CommonObjectSecurity.GetAccessRules%2A&gt;</ph> method to obtain a collection of <ph id="ph4">&lt;xref:System.Security.AccessControl.RegistryAccessRule&gt;</ph> objects.</source>
          <target state="translated">Para obter uma lista das regras aplicadas a uma chave do registro, use o <ph id="ph1">&lt;xref:Microsoft.Win32.RegistryKey.GetAccessControl%2A?displayProperty=nameWithType&gt;</ph> método para obter um <ph id="ph2">&lt;xref:System.Security.AccessControl.RegistrySecurity&gt;</ph> objeto e, em seguida, use seu <ph id="ph3">&lt;xref:System.Security.AccessControl.CommonObjectSecurity.GetAccessRules%2A&gt;</ph> método para obter uma coleção de <ph id="ph4">&lt;xref:System.Security.AccessControl.RegistryAccessRule&gt;</ph> objetos.</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Security.AccessControl.RegistryAccessRule">
          <source><ph id="ph1">&lt;xref:System.Security.AccessControl.RegistryAccessRule&gt;</ph> objects do not map one-to-one with access control entries in the underlying discretionary control access list (DACL).</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Security.AccessControl.RegistryAccessRule&gt;</ph> objetos não mapeiam um para um com entradas de controle de acesso na lista de acesso de controle discricionário (DACL) subjacente.</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Security.AccessControl.RegistryAccessRule">
          <source>When you get the set of all access rules for a registry key, the set contains the minimum number of rules currently required to express all the access control entries.</source>
          <target state="translated">Quando você obter o conjunto de todas as regras de acesso para uma chave do registro, o conjunto contém o número mínimo de regras necessárias no momento para expressar todas as entradas de controle de acesso.</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Security.AccessControl.RegistryAccessRule">
          <source>The underlying access control entries change as you apply and remove rules.</source>
          <target state="translated">As entradas de controle de acesso subjacente alterar como aplicar e remover regras.</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Security.AccessControl.RegistryAccessRule">
          <source>The information in rules is merged if possible, to maintain the smallest number of access control entries.</source>
          <target state="translated">As informações nas regras são mescladas se possível, para manter o menor número de entradas de controle de acesso.</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Security.AccessControl.RegistryAccessRule">
          <source>Thus, when you read the current list of rules, it might not look exactly like the list of all the rules you have added.</source>
          <target state="translated">Assim, ao ler a lista atual de regras, ele pode não ser exatamente igual a lista de todas as regras que você adicionou.</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Security.AccessControl.RegistryAccessRule">
          <source>Use <ph id="ph1">&lt;xref:System.Security.AccessControl.RegistryAccessRule&gt;</ph> objects to specify access rights to allow or deny to a user or group.</source>
          <target state="translated">Use <ph id="ph1">&lt;xref:System.Security.AccessControl.RegistryAccessRule&gt;</ph> objetos para especificar os direitos de acesso para permitir ou negar a um usuário ou grupo.</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Security.AccessControl.RegistryAccessRule">
          <source>A <ph id="ph1">&lt;xref:System.Security.AccessControl.RegistryAccessRule&gt;</ph> object always represents either allowed access or denied access, never both.</source>
          <target state="translated">Um <ph id="ph1">&lt;xref:System.Security.AccessControl.RegistryAccessRule&gt;</ph> objeto sempre representa o acesso permitido ou negado acesso, nunca ambos.</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Security.AccessControl.RegistryAccessRule">
          <source>To apply a rule to a registry key, use the <ph id="ph1">&lt;xref:Microsoft.Win32.RegistryKey.GetAccessControl%2A?displayProperty=nameWithType&gt;</ph> method to get the <ph id="ph2">&lt;xref:System.Security.AccessControl.RegistrySecurity&gt;</ph> object.</source>
          <target state="translated">Para aplicar uma regra a uma chave do registro, use o <ph id="ph1">&lt;xref:Microsoft.Win32.RegistryKey.GetAccessControl%2A?displayProperty=nameWithType&gt;</ph> método para obter o <ph id="ph2">&lt;xref:System.Security.AccessControl.RegistrySecurity&gt;</ph> objeto.</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Security.AccessControl.RegistryAccessRule">
          <source>Modify the <ph id="ph1">&lt;xref:System.Security.AccessControl.RegistrySecurity&gt;</ph> object by using its methods to add the rule, and then use the <ph id="ph2">&lt;xref:Microsoft.Win32.RegistryKey.SetAccessControl%2A?displayProperty=nameWithType&gt;</ph> method to reattach the security object.</source>
          <target state="translated">Modificar o <ph id="ph1">&lt;xref:System.Security.AccessControl.RegistrySecurity&gt;</ph> objeto por meio de seus métodos para adicionar a regra e, em seguida, use o <ph id="ph2">&lt;xref:Microsoft.Win32.RegistryKey.SetAccessControl%2A?displayProperty=nameWithType&gt;</ph> método para anexar novamente o objeto de segurança.</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Security.AccessControl.RegistryAccessRule">
          <source>Changes you make to a <ph id="ph1">&lt;xref:System.Security.AccessControl.RegistrySecurity&gt;</ph> object do not affect the access levels of the registry key until you call the <ph id="ph2">&lt;xref:Microsoft.Win32.RegistryKey.SetAccessControl%2A?displayProperty=nameWithType&gt;</ph> method to assign the altered security object to the registry key.</source>
          <target state="translated">Alterações feitas em um <ph id="ph1">&lt;xref:System.Security.AccessControl.RegistrySecurity&gt;</ph> objeto não afetam os níveis de acesso da chave do registro até que você chamar o <ph id="ph2">&lt;xref:Microsoft.Win32.RegistryKey.SetAccessControl%2A?displayProperty=nameWithType&gt;</ph> método para atribuir o objeto alterado de segurança para a chave do registro.</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Security.AccessControl.RegistryAccessRule">
          <source><ph id="ph1">&lt;xref:System.Security.AccessControl.RegistryAccessRule&gt;</ph> objects are immutable.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Security.AccessControl.RegistryAccessRule&gt;</ph> os objetos são imutáveis.</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Security.AccessControl.RegistryAccessRule">
          <source>Security for a registry key is modified using the methods of the <ph id="ph1">&lt;xref:System.Security.AccessControl.RegistrySecurity&gt;</ph> class to add or remove rules; as you do this, the underlying access control entries are modified.</source>
          <target state="translated">Segurança para uma chave do registro é modificada usando os métodos do <ph id="ph1">&lt;xref:System.Security.AccessControl.RegistrySecurity&gt;</ph> classe para adicionar ou remover regras; como você faz isso, as entradas de controle de acesso subjacentes são modificadas.</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Security.AccessControl.RegistryAccessRule">
          <source>The following code example demonstrates access rules with inheritance and propagation.</source>
          <target state="translated">O exemplo de código a seguir demonstra as regras de acesso com herança e propagação.</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Security.AccessControl.RegistryAccessRule">
          <source>The example creates a <ph id="ph1">&lt;xref:System.Security.AccessControl.RegistrySecurity&gt;</ph> object, then creates and adds two rules that have the <ph id="ph2">&lt;xref:System.Security.AccessControl.InheritanceFlags.ContainerInherit&gt;</ph> flag.</source>
          <target state="translated">O exemplo cria um <ph id="ph1">&lt;xref:System.Security.AccessControl.RegistrySecurity&gt;</ph> do objeto, em seguida, cria e adiciona duas regras que têm o <ph id="ph2">&lt;xref:System.Security.AccessControl.InheritanceFlags.ContainerInherit&gt;</ph> sinalizador.</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Security.AccessControl.RegistryAccessRule">
          <source>The first rule has no propagation flags, while the second has <ph id="ph1">&lt;xref:System.Security.AccessControl.PropagationFlags.NoPropagateInherit&gt;</ph> and <ph id="ph2">&lt;xref:System.Security.AccessControl.PropagationFlags.InheritOnly&gt;</ph>.</source>
          <target state="translated">A primeira regra não tem nenhum sinalizador de propagação, enquanto o segundo tem <ph id="ph1">&lt;xref:System.Security.AccessControl.PropagationFlags.NoPropagateInherit&gt;</ph> e <ph id="ph2">&lt;xref:System.Security.AccessControl.PropagationFlags.InheritOnly&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Security.AccessControl.RegistryAccessRule">
          <source>The program displays the rules in the <ph id="ph1">&lt;xref:System.Security.AccessControl.RegistrySecurity&gt;</ph> object, and then uses the object to create a subkey.</source>
          <target state="translated">O programa exibe as regras de <ph id="ph1">&lt;xref:System.Security.AccessControl.RegistrySecurity&gt;</ph> de objeto e, em seguida, usa o objeto para criar uma subchave.</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Security.AccessControl.RegistryAccessRule">
          <source>The program creates a child subkey and a grandchild subkey, and then displays the security for each subkey.</source>
          <target state="translated">O programa cria um filho subchave e uma subchave neto e, em seguida, exibe a segurança para cada subchave.</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Security.AccessControl.RegistryAccessRule">
          <source>Finally, the program deletes the test keys.</source>
          <target state="translated">Por fim, o programa exclui as chaves de teste.</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve" uid="T:System.Security.AccessControl.RegistryAccessRule">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Security.AccessControl.RegistryAccessRule" /&gt;</ph> class.</source>
          <target state="translated">Inicializa uma nova instância da classe <ph id="ph1">&lt;see cref="T:System.Security.AccessControl.RegistryAccessRule" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve" uid="M:System.Security.AccessControl.RegistryAccessRule.#ctor(System.Security.Principal.IdentityReference,System.Security.AccessControl.RegistryRights,System.Security.AccessControl.AccessControlType)">
          <source>The user or group the rule applies to.</source>
          <target state="translated">O usuário ou grupo ao qual a regra se aplica.</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve" uid="M:System.Security.AccessControl.RegistryAccessRule.#ctor(System.Security.Principal.IdentityReference,System.Security.AccessControl.RegistryRights,System.Security.AccessControl.AccessControlType)">
          <source>Must be of type <ph id="ph1">&lt;see cref="T:System.Security.Principal.SecurityIdentifier" /&gt;</ph> or a type such as <ph id="ph2">&lt;see cref="T:System.Security.Principal.NTAccount" /&gt;</ph> that can be converted to type <ph id="ph3">&lt;see cref="T:System.Security.Principal.SecurityIdentifier" /&gt;</ph>.</source>
          <target state="translated">Deve ser do tipo <ph id="ph1">&lt;see cref="T:System.Security.Principal.SecurityIdentifier" /&gt;</ph> ou um tipo como <ph id="ph2">&lt;see cref="T:System.Security.Principal.NTAccount" /&gt;</ph> que pode ser convertido para o tipo <ph id="ph3">&lt;see cref="T:System.Security.Principal.SecurityIdentifier" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve" uid="M:System.Security.AccessControl.RegistryAccessRule.#ctor(System.Security.Principal.IdentityReference,System.Security.AccessControl.RegistryRights,System.Security.AccessControl.AccessControlType)">
          <source>A bitwise combination of <ph id="ph1">&lt;see cref="T:System.Security.AccessControl.RegistryRights" /&gt;</ph> values indicating the rights allowed or denied.</source>
          <target state="translated">Uma combinação bit a bit de valores <ph id="ph1">&lt;see cref="T:System.Security.AccessControl.RegistryRights" /&gt;</ph> que indicam os direitos permitidos ou negados.</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve" uid="M:System.Security.AccessControl.RegistryAccessRule.#ctor(System.Security.Principal.IdentityReference,System.Security.AccessControl.RegistryRights,System.Security.AccessControl.AccessControlType)">
          <source>One of the <ph id="ph1">&lt;see cref="T:System.Security.AccessControl.AccessControlType" /&gt;</ph> values indicating whether the rights are allowed or denied.</source>
          <target state="translated">Um dos valores <ph id="ph1">&lt;see cref="T:System.Security.AccessControl.AccessControlType" /&gt;</ph> que indicam se os direitos são permitidos ou negados.</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve" uid="M:System.Security.AccessControl.RegistryAccessRule.#ctor(System.Security.Principal.IdentityReference,System.Security.AccessControl.RegistryRights,System.Security.AccessControl.AccessControlType)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Security.AccessControl.RegistryAccessRule" /&gt;</ph> class, specifying the user or group the rule applies to, the access rights, and whether the specified access rights are allowed or denied.</source>
          <target state="translated">Inicializa uma nova instância da classe <ph id="ph1">&lt;see cref="T:System.Security.AccessControl.RegistryAccessRule" /&gt;</ph>, especificando o usuário ou grupo ao qual a regra se aplica, os direitos de acesso e se estes são permitidos ou negados.</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.AccessControl.RegistryAccessRule.#ctor(System.Security.Principal.IdentityReference,System.Security.AccessControl.RegistryRights,System.Security.AccessControl.AccessControlType)">
          <source>This constructor specifies default propagation and inheritance.</source>
          <target state="translated">Este construtor Especifica herança e propagação padrão.</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.AccessControl.RegistryAccessRule.#ctor(System.Security.Principal.IdentityReference,System.Security.AccessControl.RegistryRights,System.Security.AccessControl.AccessControlType)">
          <source>That is, <ph id="ph1">&lt;xref:System.Security.AccessControl.InheritanceFlags.None?displayProperty=nameWithType&gt;</ph> and <ph id="ph2">&lt;xref:System.Security.AccessControl.PropagationFlags.None?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Ou seja, <ph id="ph1">&lt;xref:System.Security.AccessControl.InheritanceFlags.None?displayProperty=nameWithType&gt;</ph> e <ph id="ph2">&lt;xref:System.Security.AccessControl.PropagationFlags.None?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve" uid="M:System.Security.AccessControl.RegistryAccessRule.#ctor(System.Security.Principal.IdentityReference,System.Security.AccessControl.RegistryRights,System.Security.AccessControl.AccessControlType)">
          <source><ph id="ph1">&lt;paramref name="registryRights" /&gt;</ph> specifies an invalid value.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="registryRights" /&gt;</ph> especifica um valor inválido.</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve" uid="M:System.Security.AccessControl.RegistryAccessRule.#ctor(System.Security.Principal.IdentityReference,System.Security.AccessControl.RegistryRights,System.Security.AccessControl.AccessControlType)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve" uid="M:System.Security.AccessControl.RegistryAccessRule.#ctor(System.Security.Principal.IdentityReference,System.Security.AccessControl.RegistryRights,System.Security.AccessControl.AccessControlType)">
          <source><ph id="ph1">&lt;paramref name="type" /&gt;</ph> specifies an invalid value.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="type" /&gt;</ph> especifica um valor inválido.</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve" uid="M:System.Security.AccessControl.RegistryAccessRule.#ctor(System.Security.Principal.IdentityReference,System.Security.AccessControl.RegistryRights,System.Security.AccessControl.AccessControlType)">
          <source><ph id="ph1">&lt;paramref name="identity" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="identity" /&gt;</ph> é <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve" uid="M:System.Security.AccessControl.RegistryAccessRule.#ctor(System.Security.Principal.IdentityReference,System.Security.AccessControl.RegistryRights,System.Security.AccessControl.AccessControlType)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve" uid="M:System.Security.AccessControl.RegistryAccessRule.#ctor(System.Security.Principal.IdentityReference,System.Security.AccessControl.RegistryRights,System.Security.AccessControl.AccessControlType)">
          <source><ph id="ph1">&lt;paramref name="eventRights" /&gt;</ph> is zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="eventRights" /&gt;</ph> é zero.</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve" uid="M:System.Security.AccessControl.RegistryAccessRule.#ctor(System.Security.Principal.IdentityReference,System.Security.AccessControl.RegistryRights,System.Security.AccessControl.AccessControlType)">
          <source><ph id="ph1">&lt;paramref name="identity" /&gt;</ph> is neither of type <ph id="ph2">&lt;see cref="T:System.Security.Principal.SecurityIdentifier" /&gt;</ph> nor of a type such as <ph id="ph3">&lt;see cref="T:System.Security.Principal.NTAccount" /&gt;</ph> that can be converted to type <ph id="ph4">&lt;see cref="T:System.Security.Principal.SecurityIdentifier" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="identity" /&gt;</ph> não é do tipo <ph id="ph2">&lt;see cref="T:System.Security.Principal.SecurityIdentifier" /&gt;</ph> nem de um tipo como <ph id="ph3">&lt;see cref="T:System.Security.Principal.NTAccount" /&gt;</ph> que pode ser convertido para o tipo <ph id="ph4">&lt;see cref="T:System.Security.Principal.SecurityIdentifier" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve" uid="M:System.Security.AccessControl.RegistryAccessRule.#ctor(System.String,System.Security.AccessControl.RegistryRights,System.Security.AccessControl.AccessControlType)">
          <source>The name of the user or group the rule applies to.</source>
          <target state="translated">O nome do usuário ou grupo ao qual a regra se aplica.</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve" uid="M:System.Security.AccessControl.RegistryAccessRule.#ctor(System.String,System.Security.AccessControl.RegistryRights,System.Security.AccessControl.AccessControlType)">
          <source>A bitwise combination of <ph id="ph1">&lt;see cref="T:System.Security.AccessControl.RegistryRights" /&gt;</ph> values indicating the rights allowed or denied.</source>
          <target state="translated">Uma combinação bit a bit de valores <ph id="ph1">&lt;see cref="T:System.Security.AccessControl.RegistryRights" /&gt;</ph> que indicam os direitos permitidos ou negados.</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve" uid="M:System.Security.AccessControl.RegistryAccessRule.#ctor(System.String,System.Security.AccessControl.RegistryRights,System.Security.AccessControl.AccessControlType)">
          <source>One of the <ph id="ph1">&lt;see cref="T:System.Security.AccessControl.AccessControlType" /&gt;</ph> values indicating whether the rights are allowed or denied.</source>
          <target state="translated">Um dos valores <ph id="ph1">&lt;see cref="T:System.Security.AccessControl.AccessControlType" /&gt;</ph> que indicam se os direitos são permitidos ou negados.</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve" uid="M:System.Security.AccessControl.RegistryAccessRule.#ctor(System.String,System.Security.AccessControl.RegistryRights,System.Security.AccessControl.AccessControlType)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Security.AccessControl.RegistryAccessRule" /&gt;</ph> class, specifying the name of the user or group the rule applies to, the access rights, and whether the specified access rights are allowed or denied.</source>
          <target state="translated">Inicializa uma nova instância da classe <ph id="ph1">&lt;see cref="T:System.Security.AccessControl.RegistryAccessRule" /&gt;</ph>, especificando o nome do usuário ou do grupo ao qual a regra se aplica, os direitos de acesso e se eles são permitidos ou negados.</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.AccessControl.RegistryAccessRule.#ctor(System.String,System.Security.AccessControl.RegistryRights,System.Security.AccessControl.AccessControlType)">
          <source>This constructor specifies default propagation and inheritance.</source>
          <target state="translated">Este construtor Especifica herança e propagação padrão.</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.AccessControl.RegistryAccessRule.#ctor(System.String,System.Security.AccessControl.RegistryRights,System.Security.AccessControl.AccessControlType)">
          <source>That is, <ph id="ph1">&lt;xref:System.Security.AccessControl.InheritanceFlags.None?displayProperty=nameWithType&gt;</ph> and <ph id="ph2">&lt;xref:System.Security.AccessControl.PropagationFlags.None?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Ou seja, <ph id="ph1">&lt;xref:System.Security.AccessControl.InheritanceFlags.None?displayProperty=nameWithType&gt;</ph> e <ph id="ph2">&lt;xref:System.Security.AccessControl.PropagationFlags.None?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.AccessControl.RegistryAccessRule.#ctor(System.String,System.Security.AccessControl.RegistryRights,System.Security.AccessControl.AccessControlType)">
          <source>This constructor is equivalent to creating an <ph id="ph1">&lt;xref:System.Security.Principal.NTAccount&gt;</ph> object, by passing <ph id="ph2">`identity`</ph> to the <ph id="ph3">&lt;xref:System.Security.Principal.NTAccount.%23ctor%28System.String%29?displayProperty=nameWithType&gt;</ph> constructor, and passing the newly created <ph id="ph4">&lt;xref:System.Security.Principal.NTAccount&gt;</ph> object to the <ph id="ph5">&lt;xref:System.Security.AccessControl.RegistryAccessRule.%23ctor%28System.Security.Principal.IdentityReference%2CSystem.Security.AccessControl.RegistryRights%2CSystem.Security.AccessControl.AccessControlType%29&gt;</ph> constructor.</source>
          <target state="translated">Este construtor é equivalente à criação de um <ph id="ph1">&lt;xref:System.Security.Principal.NTAccount&gt;</ph> objeto, passando <ph id="ph2">`identity`</ph> para o <ph id="ph3">&lt;xref:System.Security.Principal.NTAccount.%23ctor%28System.String%29?displayProperty=nameWithType&gt;</ph> construtor e passando recém-criado <ph id="ph4">&lt;xref:System.Security.Principal.NTAccount&gt;</ph> o objeto para o <ph id="ph5">&lt;xref:System.Security.AccessControl.RegistryAccessRule.%23ctor%28System.Security.Principal.IdentityReference%2CSystem.Security.AccessControl.RegistryRights%2CSystem.Security.AccessControl.AccessControlType%29&gt;</ph> construtor.</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.AccessControl.RegistryAccessRule.#ctor(System.String,System.Security.AccessControl.RegistryRights,System.Security.AccessControl.AccessControlType)">
          <source>The following code example creates registry access rules and adds them to a <ph id="ph1">&lt;xref:System.Security.AccessControl.RegistrySecurity&gt;</ph> object, showing how rules that allow and deny rights remain separate, while compatible rules of the same kind are merged.</source>
          <target state="translated">O exemplo de código a seguir cria regras de acesso do registro e os adiciona a um <ph id="ph1">&lt;xref:System.Security.AccessControl.RegistrySecurity&gt;</ph> objeto, mostrando como regras que permitirem e negar direitos permanecem separadas, enquanto as regras compatíveis do mesmo tipo é mesclado.</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve" uid="M:System.Security.AccessControl.RegistryAccessRule.#ctor(System.String,System.Security.AccessControl.RegistryRights,System.Security.AccessControl.AccessControlType)">
          <source><ph id="ph1">&lt;paramref name="registryRights" /&gt;</ph> specifies an invalid value.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="registryRights" /&gt;</ph> especifica um valor inválido.</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve" uid="M:System.Security.AccessControl.RegistryAccessRule.#ctor(System.String,System.Security.AccessControl.RegistryRights,System.Security.AccessControl.AccessControlType)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve" uid="M:System.Security.AccessControl.RegistryAccessRule.#ctor(System.String,System.Security.AccessControl.RegistryRights,System.Security.AccessControl.AccessControlType)">
          <source><ph id="ph1">&lt;paramref name="type" /&gt;</ph> specifies an invalid value.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="type" /&gt;</ph> especifica um valor inválido.</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve" uid="M:System.Security.AccessControl.RegistryAccessRule.#ctor(System.String,System.Security.AccessControl.RegistryRights,System.Security.AccessControl.AccessControlType)">
          <source><ph id="ph1">&lt;paramref name="registryRights" /&gt;</ph> is zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="registryRights" /&gt;</ph> é zero.</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve" uid="M:System.Security.AccessControl.RegistryAccessRule.#ctor(System.String,System.Security.AccessControl.RegistryRights,System.Security.AccessControl.AccessControlType)">
          <source><ph id="ph1">&lt;paramref name="identity" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="identity" /&gt;</ph> é <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve" uid="M:System.Security.AccessControl.RegistryAccessRule.#ctor(System.String,System.Security.AccessControl.RegistryRights,System.Security.AccessControl.AccessControlType)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve" uid="M:System.Security.AccessControl.RegistryAccessRule.#ctor(System.String,System.Security.AccessControl.RegistryRights,System.Security.AccessControl.AccessControlType)">
          <source><ph id="ph1">&lt;paramref name="identity" /&gt;</ph> is a zero-length string.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="identity" /&gt;</ph> é uma cadeia de comprimento zero.</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve" uid="M:System.Security.AccessControl.RegistryAccessRule.#ctor(System.String,System.Security.AccessControl.RegistryRights,System.Security.AccessControl.AccessControlType)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve" uid="M:System.Security.AccessControl.RegistryAccessRule.#ctor(System.String,System.Security.AccessControl.RegistryRights,System.Security.AccessControl.AccessControlType)">
          <source><ph id="ph1">&lt;paramref name="identity" /&gt;</ph> is longer than 512 characters.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="identity" /&gt;</ph> tem mais de 512 caracteres.</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve" uid="M:System.Security.AccessControl.RegistryAccessRule.#ctor(System.Security.Principal.IdentityReference,System.Security.AccessControl.RegistryRights,System.Security.AccessControl.InheritanceFlags,System.Security.AccessControl.PropagationFlags,System.Security.AccessControl.AccessControlType)">
          <source>The user or group the rule applies to.</source>
          <target state="translated">O usuário ou grupo ao qual a regra se aplica.</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve" uid="M:System.Security.AccessControl.RegistryAccessRule.#ctor(System.Security.Principal.IdentityReference,System.Security.AccessControl.RegistryRights,System.Security.AccessControl.InheritanceFlags,System.Security.AccessControl.PropagationFlags,System.Security.AccessControl.AccessControlType)">
          <source>Must be of type <ph id="ph1">&lt;see cref="T:System.Security.Principal.SecurityIdentifier" /&gt;</ph> or a type such as <ph id="ph2">&lt;see cref="T:System.Security.Principal.NTAccount" /&gt;</ph> that can be converted to type <ph id="ph3">&lt;see cref="T:System.Security.Principal.SecurityIdentifier" /&gt;</ph>.</source>
          <target state="translated">Deve ser do tipo <ph id="ph1">&lt;see cref="T:System.Security.Principal.SecurityIdentifier" /&gt;</ph> ou um tipo como <ph id="ph2">&lt;see cref="T:System.Security.Principal.NTAccount" /&gt;</ph> que pode ser convertido para o tipo <ph id="ph3">&lt;see cref="T:System.Security.Principal.SecurityIdentifier" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve" uid="M:System.Security.AccessControl.RegistryAccessRule.#ctor(System.Security.Principal.IdentityReference,System.Security.AccessControl.RegistryRights,System.Security.AccessControl.InheritanceFlags,System.Security.AccessControl.PropagationFlags,System.Security.AccessControl.AccessControlType)">
          <source>A bitwise combination of <ph id="ph1">&lt;see cref="T:System.Security.AccessControl.RegistryRights" /&gt;</ph> values specifying the rights allowed or denied.</source>
          <target state="translated">Uma combinação bit a bit de valores <ph id="ph1">&lt;see cref="T:System.Security.AccessControl.RegistryRights" /&gt;</ph> que especificam os direitos permitidos ou negados.</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve" uid="M:System.Security.AccessControl.RegistryAccessRule.#ctor(System.Security.Principal.IdentityReference,System.Security.AccessControl.RegistryRights,System.Security.AccessControl.InheritanceFlags,System.Security.AccessControl.PropagationFlags,System.Security.AccessControl.AccessControlType)">
          <source>A bitwise combination of <ph id="ph1">&lt;see cref="T:System.Security.AccessControl.InheritanceFlags" /&gt;</ph> flags specifying how access rights are inherited from other objects.</source>
          <target state="translated">Uma combinação bit a bit de sinalizadores <ph id="ph1">&lt;see cref="T:System.Security.AccessControl.InheritanceFlags" /&gt;</ph> que especificam como os direitos de acesso são herdados de outros objetos.</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve" uid="M:System.Security.AccessControl.RegistryAccessRule.#ctor(System.Security.Principal.IdentityReference,System.Security.AccessControl.RegistryRights,System.Security.AccessControl.InheritanceFlags,System.Security.AccessControl.PropagationFlags,System.Security.AccessControl.AccessControlType)">
          <source>A bitwise combination of <ph id="ph1">&lt;see cref="T:System.Security.AccessControl.PropagationFlags" /&gt;</ph> flags specifying how access rights are propagated to other objects.</source>
          <target state="translated">Uma combinação bit a bit de sinalizadores <ph id="ph1">&lt;see cref="T:System.Security.AccessControl.PropagationFlags" /&gt;</ph> que especificam como os direitos de acesso são propagados para outros objetos.</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve" uid="M:System.Security.AccessControl.RegistryAccessRule.#ctor(System.Security.Principal.IdentityReference,System.Security.AccessControl.RegistryRights,System.Security.AccessControl.InheritanceFlags,System.Security.AccessControl.PropagationFlags,System.Security.AccessControl.AccessControlType)">
          <source>One of the <ph id="ph1">&lt;see cref="T:System.Security.AccessControl.AccessControlType" /&gt;</ph> values specifying whether the rights are allowed or denied.</source>
          <target state="translated">Um dos valores <ph id="ph1">&lt;see cref="T:System.Security.AccessControl.AccessControlType" /&gt;</ph> que especificam se os direitos são permitidos ou negados.</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve" uid="M:System.Security.AccessControl.RegistryAccessRule.#ctor(System.Security.Principal.IdentityReference,System.Security.AccessControl.RegistryRights,System.Security.AccessControl.InheritanceFlags,System.Security.AccessControl.PropagationFlags,System.Security.AccessControl.AccessControlType)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Security.AccessControl.RegistryAccessRule" /&gt;</ph> class, specifying the user or group the rule applies to, the access rights, the inheritance flags, the propagation flags, and whether the specified access rights are allowed or denied.</source>
          <target state="translated">Inicializa uma nova instância da classe <ph id="ph1">&lt;see cref="T:System.Security.AccessControl.RegistryAccessRule" /&gt;</ph>, especificando o usuário ou grupo ao qual a regra se aplica, os direitos de acesso, os sinalizadores de herança, os sinalizadores de propagação e se os direitos de acesso especificados são permitidos ou negados.</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.AccessControl.RegistryAccessRule.#ctor(System.Security.Principal.IdentityReference,System.Security.AccessControl.RegistryRights,System.Security.AccessControl.InheritanceFlags,System.Security.AccessControl.PropagationFlags,System.Security.AccessControl.AccessControlType)">
          <source>All registry keys are containers, so the only inheritance flag that is meaningful for registry keys is the <ph id="ph1">&lt;xref:System.Security.AccessControl.InheritanceFlags.ContainerInherit?displayProperty=nameWithType&gt;</ph> flag.</source>
          <target state="translated">Todas as chaves do registro são contêineres, portanto, o único sinalizador de herança que seja significativo para as chaves do registro é o <ph id="ph1">&lt;xref:System.Security.AccessControl.InheritanceFlags.ContainerInherit?displayProperty=nameWithType&gt;</ph> sinalizador.</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.AccessControl.RegistryAccessRule.#ctor(System.Security.Principal.IdentityReference,System.Security.AccessControl.RegistryRights,System.Security.AccessControl.InheritanceFlags,System.Security.AccessControl.PropagationFlags,System.Security.AccessControl.AccessControlType)">
          <source>If this flag is not specified, the propagation flags are ignored, and only the immediate key is affected.</source>
          <target state="translated">Se este sinalizador não for especificado, os sinalizadores de propagação são ignorados e apenas a chave de imediata é afetada.</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.AccessControl.RegistryAccessRule.#ctor(System.Security.Principal.IdentityReference,System.Security.AccessControl.RegistryRights,System.Security.AccessControl.InheritanceFlags,System.Security.AccessControl.PropagationFlags,System.Security.AccessControl.AccessControlType)">
          <source>If the flag is present, the rule is propagated as shown in the following table.</source>
          <target state="translated">Se o sinalizador estiver presente, a regra será propagada conforme mostrado na tabela a seguir.</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.AccessControl.RegistryAccessRule.#ctor(System.Security.Principal.IdentityReference,System.Security.AccessControl.RegistryRights,System.Security.AccessControl.InheritanceFlags,System.Security.AccessControl.PropagationFlags,System.Security.AccessControl.AccessControlType)">
          <source>The table assumes there is a subkey S with child subkey CS and grandchild subkey GS.</source>
          <target state="translated">A tabela assume que há uma subchave S com subchave filho CS e subchave neto GS.</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.AccessControl.RegistryAccessRule.#ctor(System.Security.Principal.IdentityReference,System.Security.AccessControl.RegistryRights,System.Security.AccessControl.InheritanceFlags,System.Security.AccessControl.PropagationFlags,System.Security.AccessControl.AccessControlType)">
          <source>That is, the path for the grandchild subkey is S\CS\GS.</source>
          <target state="translated">Ou seja, o caminho para a subchave neto é S\CS\GS.</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.AccessControl.RegistryAccessRule.#ctor(System.Security.Principal.IdentityReference,System.Security.AccessControl.RegistryRights,System.Security.AccessControl.InheritanceFlags,System.Security.AccessControl.PropagationFlags,System.Security.AccessControl.AccessControlType)">
          <source>Propagation flags</source>
          <target state="translated">Sinalizadores de propagação</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.AccessControl.RegistryAccessRule.#ctor(System.Security.Principal.IdentityReference,System.Security.AccessControl.RegistryRights,System.Security.AccessControl.InheritanceFlags,System.Security.AccessControl.PropagationFlags,System.Security.AccessControl.AccessControlType)">
          <source>S</source>
          <target state="translated">S</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.AccessControl.RegistryAccessRule.#ctor(System.Security.Principal.IdentityReference,System.Security.AccessControl.RegistryRights,System.Security.AccessControl.InheritanceFlags,System.Security.AccessControl.PropagationFlags,System.Security.AccessControl.AccessControlType)">
          <source>CS</source>
          <target state="translated">CS</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.AccessControl.RegistryAccessRule.#ctor(System.Security.Principal.IdentityReference,System.Security.AccessControl.RegistryRights,System.Security.AccessControl.InheritanceFlags,System.Security.AccessControl.PropagationFlags,System.Security.AccessControl.AccessControlType)">
          <source>GS</source>
          <target state="translated">GS</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.AccessControl.RegistryAccessRule.#ctor(System.Security.Principal.IdentityReference,System.Security.AccessControl.RegistryRights,System.Security.AccessControl.InheritanceFlags,System.Security.AccessControl.PropagationFlags,System.Security.AccessControl.AccessControlType)">
          <source>X</source>
          <target state="translated">X</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.AccessControl.RegistryAccessRule.#ctor(System.Security.Principal.IdentityReference,System.Security.AccessControl.RegistryRights,System.Security.AccessControl.InheritanceFlags,System.Security.AccessControl.PropagationFlags,System.Security.AccessControl.AccessControlType)">
          <source>X</source>
          <target state="translated">X</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.AccessControl.RegistryAccessRule.#ctor(System.Security.Principal.IdentityReference,System.Security.AccessControl.RegistryRights,System.Security.AccessControl.InheritanceFlags,System.Security.AccessControl.PropagationFlags,System.Security.AccessControl.AccessControlType)">
          <source>X</source>
          <target state="translated">X</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.AccessControl.RegistryAccessRule.#ctor(System.Security.Principal.IdentityReference,System.Security.AccessControl.RegistryRights,System.Security.AccessControl.InheritanceFlags,System.Security.AccessControl.PropagationFlags,System.Security.AccessControl.AccessControlType)">
          <source>X</source>
          <target state="translated">X</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.AccessControl.RegistryAccessRule.#ctor(System.Security.Principal.IdentityReference,System.Security.AccessControl.RegistryRights,System.Security.AccessControl.InheritanceFlags,System.Security.AccessControl.PropagationFlags,System.Security.AccessControl.AccessControlType)">
          <source>X</source>
          <target state="translated">X</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.AccessControl.RegistryAccessRule.#ctor(System.Security.Principal.IdentityReference,System.Security.AccessControl.RegistryRights,System.Security.AccessControl.InheritanceFlags,System.Security.AccessControl.PropagationFlags,System.Security.AccessControl.AccessControlType)">
          <source>X</source>
          <target state="translated">X</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.AccessControl.RegistryAccessRule.#ctor(System.Security.Principal.IdentityReference,System.Security.AccessControl.RegistryRights,System.Security.AccessControl.InheritanceFlags,System.Security.AccessControl.PropagationFlags,System.Security.AccessControl.AccessControlType)">
          <source>X</source>
          <target state="translated">X</target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.AccessControl.RegistryAccessRule.#ctor(System.Security.Principal.IdentityReference,System.Security.AccessControl.RegistryRights,System.Security.AccessControl.InheritanceFlags,System.Security.AccessControl.PropagationFlags,System.Security.AccessControl.AccessControlType)">
          <source><ph id="ph1">&lt;xref:System.Security.AccessControl.PropagationFlags.NoPropagateInherit&gt;</ph>, <ph id="ph2">&lt;xref:System.Security.AccessControl.PropagationFlags.InheritOnly&gt;</ph></source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Security.AccessControl.PropagationFlags.NoPropagateInherit&gt;</ph>, <ph id="ph2">&lt;xref:System.Security.AccessControl.PropagationFlags.InheritOnly&gt;</ph></target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.AccessControl.RegistryAccessRule.#ctor(System.Security.Principal.IdentityReference,System.Security.AccessControl.RegistryRights,System.Security.AccessControl.InheritanceFlags,System.Security.AccessControl.PropagationFlags,System.Security.AccessControl.AccessControlType)">
          <source>X</source>
          <target state="translated">X</target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.AccessControl.RegistryAccessRule.#ctor(System.Security.Principal.IdentityReference,System.Security.AccessControl.RegistryRights,System.Security.AccessControl.InheritanceFlags,System.Security.AccessControl.PropagationFlags,System.Security.AccessControl.AccessControlType)">
          <source>The pattern for the grandchild subkey governs all subkeys contained by the grandchild subkey.</source>
          <target state="translated">O padrão para a subchave neto rege todas as subchaves contidas na subchave neto.</target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.AccessControl.RegistryAccessRule.#ctor(System.Security.Principal.IdentityReference,System.Security.AccessControl.RegistryRights,System.Security.AccessControl.InheritanceFlags,System.Security.AccessControl.PropagationFlags,System.Security.AccessControl.AccessControlType)">
          <source>For example, if the <ph id="ph1">&lt;xref:System.Security.AccessControl.InheritanceFlags.ContainerInherit&gt;</ph> flag is specified for <ph id="ph2">`inheritanceFlags`</ph> and the <ph id="ph3">&lt;xref:System.Security.AccessControl.PropagationFlags.InheritOnly&gt;</ph> propagation flag is specified for <ph id="ph4">`propagationFlags`</ph>, this rule does not apply to the immediate subkey, but does apply to all its immediate child subkeys and to all subkeys they contain.</source>
          <target state="translated">Por exemplo, se o <ph id="ph1">&lt;xref:System.Security.AccessControl.InheritanceFlags.ContainerInherit&gt;</ph> sinalizador é especificado para <ph id="ph2">`inheritanceFlags`</ph> e <ph id="ph3">&lt;xref:System.Security.AccessControl.PropagationFlags.InheritOnly&gt;</ph> sinalizador de propagação é especificado para <ph id="ph4">`propagationFlags`</ph>, essa regra não se aplica a subchave imediata, mas se aplicam a todas as suas subchaves filho imediato e para todas as subchaves que eles contêm.</target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.AccessControl.RegistryAccessRule.#ctor(System.Security.Principal.IdentityReference,System.Security.AccessControl.RegistryRights,System.Security.AccessControl.InheritanceFlags,System.Security.AccessControl.PropagationFlags,System.Security.AccessControl.AccessControlType)">
          <source>Although you can specify the <ph id="ph1">&lt;xref:System.Security.AccessControl.InheritanceFlags.ObjectInherit?displayProperty=nameWithType&gt;</ph> flag for <ph id="ph2">`inheritanceFlags`</ph>, there is no point in doing so.</source>
          <target state="translated">Embora você possa especificar o <ph id="ph1">&lt;xref:System.Security.AccessControl.InheritanceFlags.ObjectInherit?displayProperty=nameWithType&gt;</ph> sinalizador para <ph id="ph2">`inheritanceFlags`</ph>, não há nenhum ponto de fazer isso.</target>       </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.AccessControl.RegistryAccessRule.#ctor(System.Security.Principal.IdentityReference,System.Security.AccessControl.RegistryRights,System.Security.AccessControl.InheritanceFlags,System.Security.AccessControl.PropagationFlags,System.Security.AccessControl.AccessControlType)">
          <source>For the purposes of access control, the name/value pairs in a subkey are not separate objects.</source>
          <target state="translated">Para fins de controle de acesso, os pares de nome/valor em uma subchave não são objetos separados.</target>       </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.AccessControl.RegistryAccessRule.#ctor(System.Security.Principal.IdentityReference,System.Security.AccessControl.RegistryRights,System.Security.AccessControl.InheritanceFlags,System.Security.AccessControl.PropagationFlags,System.Security.AccessControl.AccessControlType)">
          <source>The access rights to name/value pairs are controlled by the rights of the subkey.</source>
          <target state="translated">Os direitos de acesso para pares de nome/valor são controlados por direitos da subchave.</target>       </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.AccessControl.RegistryAccessRule.#ctor(System.Security.Principal.IdentityReference,System.Security.AccessControl.RegistryRights,System.Security.AccessControl.InheritanceFlags,System.Security.AccessControl.PropagationFlags,System.Security.AccessControl.AccessControlType)">
          <source>Furthermore, since all subkeys are containers (that is, they can contain other subkeys), they are not affected by the <ph id="ph1">&lt;xref:System.Security.AccessControl.InheritanceFlags.ObjectInherit&gt;</ph> flag.</source>
          <target state="translated">Além disso, uma vez que todas as subchaves são contêineres (isto é, podem conter outras subchaves), eles não são afetados pelo <ph id="ph1">&lt;xref:System.Security.AccessControl.InheritanceFlags.ObjectInherit&gt;</ph> sinalizador.</target>       </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.AccessControl.RegistryAccessRule.#ctor(System.Security.Principal.IdentityReference,System.Security.AccessControl.RegistryRights,System.Security.AccessControl.InheritanceFlags,System.Security.AccessControl.PropagationFlags,System.Security.AccessControl.AccessControlType)">
          <source>Finally, specifying the <ph id="ph1">&lt;xref:System.Security.AccessControl.InheritanceFlags.ObjectInherit&gt;</ph> flag needlessly complicates the maintenance of rules, because it interferes with the combination of otherwise compatible rules.</source>
          <target state="translated">Por fim, especificando o <ph id="ph1">&lt;xref:System.Security.AccessControl.InheritanceFlags.ObjectInherit&gt;</ph> sinalizador desnecessariamente complica a manutenção de regras, pois ele interfere com a combinação de regras de outra forma compatíveis.</target>       </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve" uid="M:System.Security.AccessControl.RegistryAccessRule.#ctor(System.Security.Principal.IdentityReference,System.Security.AccessControl.RegistryRights,System.Security.AccessControl.InheritanceFlags,System.Security.AccessControl.PropagationFlags,System.Security.AccessControl.AccessControlType)">
          <source><ph id="ph1">&lt;paramref name="registryRights" /&gt;</ph> specifies an invalid value.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="registryRights" /&gt;</ph> especifica um valor inválido.</target>       </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve" uid="M:System.Security.AccessControl.RegistryAccessRule.#ctor(System.Security.Principal.IdentityReference,System.Security.AccessControl.RegistryRights,System.Security.AccessControl.InheritanceFlags,System.Security.AccessControl.PropagationFlags,System.Security.AccessControl.AccessControlType)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve" uid="M:System.Security.AccessControl.RegistryAccessRule.#ctor(System.Security.Principal.IdentityReference,System.Security.AccessControl.RegistryRights,System.Security.AccessControl.InheritanceFlags,System.Security.AccessControl.PropagationFlags,System.Security.AccessControl.AccessControlType)">
          <source><ph id="ph1">&lt;paramref name="type" /&gt;</ph> specifies an invalid value.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="type" /&gt;</ph> especifica um valor inválido.</target>       </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve" uid="M:System.Security.AccessControl.RegistryAccessRule.#ctor(System.Security.Principal.IdentityReference,System.Security.AccessControl.RegistryRights,System.Security.AccessControl.InheritanceFlags,System.Security.AccessControl.PropagationFlags,System.Security.AccessControl.AccessControlType)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve" uid="M:System.Security.AccessControl.RegistryAccessRule.#ctor(System.Security.Principal.IdentityReference,System.Security.AccessControl.RegistryRights,System.Security.AccessControl.InheritanceFlags,System.Security.AccessControl.PropagationFlags,System.Security.AccessControl.AccessControlType)">
          <source><ph id="ph1">&lt;paramref name="inheritanceFlags" /&gt;</ph> specifies an invalid value.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="inheritanceFlags" /&gt;</ph> especifica um valor inválido.</target>       </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve" uid="M:System.Security.AccessControl.RegistryAccessRule.#ctor(System.Security.Principal.IdentityReference,System.Security.AccessControl.RegistryRights,System.Security.AccessControl.InheritanceFlags,System.Security.AccessControl.PropagationFlags,System.Security.AccessControl.AccessControlType)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve" uid="M:System.Security.AccessControl.RegistryAccessRule.#ctor(System.Security.Principal.IdentityReference,System.Security.AccessControl.RegistryRights,System.Security.AccessControl.InheritanceFlags,System.Security.AccessControl.PropagationFlags,System.Security.AccessControl.AccessControlType)">
          <source><ph id="ph1">&lt;paramref name="propagationFlags" /&gt;</ph> specifies an invalid value.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="propagationFlags" /&gt;</ph> especifica um valor inválido.</target>       </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve" uid="M:System.Security.AccessControl.RegistryAccessRule.#ctor(System.Security.Principal.IdentityReference,System.Security.AccessControl.RegistryRights,System.Security.AccessControl.InheritanceFlags,System.Security.AccessControl.PropagationFlags,System.Security.AccessControl.AccessControlType)">
          <source><ph id="ph1">&lt;paramref name="identity" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="identity" /&gt;</ph> é <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve" uid="M:System.Security.AccessControl.RegistryAccessRule.#ctor(System.Security.Principal.IdentityReference,System.Security.AccessControl.RegistryRights,System.Security.AccessControl.InheritanceFlags,System.Security.AccessControl.PropagationFlags,System.Security.AccessControl.AccessControlType)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve" uid="M:System.Security.AccessControl.RegistryAccessRule.#ctor(System.Security.Principal.IdentityReference,System.Security.AccessControl.RegistryRights,System.Security.AccessControl.InheritanceFlags,System.Security.AccessControl.PropagationFlags,System.Security.AccessControl.AccessControlType)">
          <source><ph id="ph1">&lt;paramref name="registryRights" /&gt;</ph> is zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="registryRights" /&gt;</ph> é zero.</target>       </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve" uid="M:System.Security.AccessControl.RegistryAccessRule.#ctor(System.Security.Principal.IdentityReference,System.Security.AccessControl.RegistryRights,System.Security.AccessControl.InheritanceFlags,System.Security.AccessControl.PropagationFlags,System.Security.AccessControl.AccessControlType)">
          <source><ph id="ph1">&lt;paramref name="identity" /&gt;</ph> is neither of type <ph id="ph2">&lt;see cref="T:System.Security.Principal.SecurityIdentifier" /&gt;</ph>, nor of a type such as <ph id="ph3">&lt;see cref="T:System.Security.Principal.NTAccount" /&gt;</ph> that can be converted to type <ph id="ph4">&lt;see cref="T:System.Security.Principal.SecurityIdentifier" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="identity" /&gt;</ph> não e do tipo <ph id="ph2">&lt;see cref="T:System.Security.Principal.SecurityIdentifier" /&gt;</ph> nem de um tipo como <ph id="ph3">&lt;see cref="T:System.Security.Principal.NTAccount" /&gt;</ph> que pode ser convertido para o tipo <ph id="ph4">&lt;see cref="T:System.Security.Principal.SecurityIdentifier" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve" uid="M:System.Security.AccessControl.RegistryAccessRule.#ctor(System.String,System.Security.AccessControl.RegistryRights,System.Security.AccessControl.InheritanceFlags,System.Security.AccessControl.PropagationFlags,System.Security.AccessControl.AccessControlType)">
          <source>The name of the user or group the rule applies to.</source>
          <target state="translated">O nome do usuário ou grupo ao qual a regra se aplica.</target>       </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve" uid="M:System.Security.AccessControl.RegistryAccessRule.#ctor(System.String,System.Security.AccessControl.RegistryRights,System.Security.AccessControl.InheritanceFlags,System.Security.AccessControl.PropagationFlags,System.Security.AccessControl.AccessControlType)">
          <source>A bitwise combination of <ph id="ph1">&lt;see cref="T:System.Security.AccessControl.RegistryRights" /&gt;</ph> values indicating the rights allowed or denied.</source>
          <target state="translated">Uma combinação bit a bit de valores <ph id="ph1">&lt;see cref="T:System.Security.AccessControl.RegistryRights" /&gt;</ph> que indicam os direitos permitidos ou negados.</target>       </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve" uid="M:System.Security.AccessControl.RegistryAccessRule.#ctor(System.String,System.Security.AccessControl.RegistryRights,System.Security.AccessControl.InheritanceFlags,System.Security.AccessControl.PropagationFlags,System.Security.AccessControl.AccessControlType)">
          <source>A bitwise combination of <ph id="ph1">&lt;see cref="T:System.Security.AccessControl.InheritanceFlags" /&gt;</ph> flags specifying how access rights are inherited from other objects.</source>
          <target state="translated">Uma combinação bit a bit de sinalizadores <ph id="ph1">&lt;see cref="T:System.Security.AccessControl.InheritanceFlags" /&gt;</ph> que especificam como os direitos de acesso são herdados de outros objetos.</target>       </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve" uid="M:System.Security.AccessControl.RegistryAccessRule.#ctor(System.String,System.Security.AccessControl.RegistryRights,System.Security.AccessControl.InheritanceFlags,System.Security.AccessControl.PropagationFlags,System.Security.AccessControl.AccessControlType)">
          <source>A bitwise combination of <ph id="ph1">&lt;see cref="T:System.Security.AccessControl.PropagationFlags" /&gt;</ph> flags specifying how access rights are propagated to other objects.</source>
          <target state="translated">Uma combinação bit a bit de sinalizadores <ph id="ph1">&lt;see cref="T:System.Security.AccessControl.PropagationFlags" /&gt;</ph> que especificam como os direitos de acesso são propagados para outros objetos.</target>       </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve" uid="M:System.Security.AccessControl.RegistryAccessRule.#ctor(System.String,System.Security.AccessControl.RegistryRights,System.Security.AccessControl.InheritanceFlags,System.Security.AccessControl.PropagationFlags,System.Security.AccessControl.AccessControlType)">
          <source>One of the <ph id="ph1">&lt;see cref="T:System.Security.AccessControl.AccessControlType" /&gt;</ph> values specifying whether the rights are allowed or denied.</source>
          <target state="translated">Um dos valores <ph id="ph1">&lt;see cref="T:System.Security.AccessControl.AccessControlType" /&gt;</ph> que especificam se os direitos são permitidos ou negados.</target>       </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve" uid="M:System.Security.AccessControl.RegistryAccessRule.#ctor(System.String,System.Security.AccessControl.RegistryRights,System.Security.AccessControl.InheritanceFlags,System.Security.AccessControl.PropagationFlags,System.Security.AccessControl.AccessControlType)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Security.AccessControl.RegistryAccessRule" /&gt;</ph> class, specifying the name of the user or group the rule applies to, the access rights, the inheritance flags, the propagation flags, and whether the specified access rights are allowed or denied.</source>
          <target state="translated">Inicializa uma nova instância da classe <ph id="ph1">&lt;see cref="T:System.Security.AccessControl.RegistryAccessRule" /&gt;</ph>, especificando o nome do usuário ou grupo ao qual a regra se aplica, os direitos de acesso, os sinalizadores de herança, os sinalizadores de propagação e se os direitos de acesso especificados são permitidos ou negados.</target>       </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.AccessControl.RegistryAccessRule.#ctor(System.String,System.Security.AccessControl.RegistryRights,System.Security.AccessControl.InheritanceFlags,System.Security.AccessControl.PropagationFlags,System.Security.AccessControl.AccessControlType)">
          <source>All registry keys are containers, so the only inheritance flag that is meaningful for registry keys is the <ph id="ph1">&lt;xref:System.Security.AccessControl.InheritanceFlags.ContainerInherit?displayProperty=nameWithType&gt;</ph> flag.</source>
          <target state="translated">Todas as chaves do registro são contêineres, portanto, o único sinalizador de herança que seja significativo para as chaves do registro é o <ph id="ph1">&lt;xref:System.Security.AccessControl.InheritanceFlags.ContainerInherit?displayProperty=nameWithType&gt;</ph> sinalizador.</target>       </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.AccessControl.RegistryAccessRule.#ctor(System.String,System.Security.AccessControl.RegistryRights,System.Security.AccessControl.InheritanceFlags,System.Security.AccessControl.PropagationFlags,System.Security.AccessControl.AccessControlType)">
          <source>If this flag is not specified, the propagation flags are ignored, and only the immediate key is affected.</source>
          <target state="translated">Se este sinalizador não for especificado, os sinalizadores de propagação são ignorados e apenas a chave de imediata é afetada.</target>       </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.AccessControl.RegistryAccessRule.#ctor(System.String,System.Security.AccessControl.RegistryRights,System.Security.AccessControl.InheritanceFlags,System.Security.AccessControl.PropagationFlags,System.Security.AccessControl.AccessControlType)">
          <source>If the flag is present, the rule is propagated as shown in the following table.</source>
          <target state="translated">Se o sinalizador estiver presente, a regra será propagada conforme mostrado na tabela a seguir.</target>       </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.AccessControl.RegistryAccessRule.#ctor(System.String,System.Security.AccessControl.RegistryRights,System.Security.AccessControl.InheritanceFlags,System.Security.AccessControl.PropagationFlags,System.Security.AccessControl.AccessControlType)">
          <source>The table assumes there is a subkey S with child subkey CS and grandchild subkey GS.</source>
          <target state="translated">A tabela assume que há uma subchave S com subchave filho CS e subchave neto GS.</target>       </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.AccessControl.RegistryAccessRule.#ctor(System.String,System.Security.AccessControl.RegistryRights,System.Security.AccessControl.InheritanceFlags,System.Security.AccessControl.PropagationFlags,System.Security.AccessControl.AccessControlType)">
          <source>That is, the path for the grandchild subkey is S\CS\GS.</source>
          <target state="translated">Ou seja, o caminho para a subchave neto é S\CS\GS.</target>       </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.AccessControl.RegistryAccessRule.#ctor(System.String,System.Security.AccessControl.RegistryRights,System.Security.AccessControl.InheritanceFlags,System.Security.AccessControl.PropagationFlags,System.Security.AccessControl.AccessControlType)">
          <source>Propagation flags</source>
          <target state="translated">Sinalizadores de propagação</target>       </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.AccessControl.RegistryAccessRule.#ctor(System.String,System.Security.AccessControl.RegistryRights,System.Security.AccessControl.InheritanceFlags,System.Security.AccessControl.PropagationFlags,System.Security.AccessControl.AccessControlType)">
          <source>S</source>
          <target state="translated">S</target>       </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.AccessControl.RegistryAccessRule.#ctor(System.String,System.Security.AccessControl.RegistryRights,System.Security.AccessControl.InheritanceFlags,System.Security.AccessControl.PropagationFlags,System.Security.AccessControl.AccessControlType)">
          <source>CS</source>
          <target state="translated">CS</target>       </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.AccessControl.RegistryAccessRule.#ctor(System.String,System.Security.AccessControl.RegistryRights,System.Security.AccessControl.InheritanceFlags,System.Security.AccessControl.PropagationFlags,System.Security.AccessControl.AccessControlType)">
          <source>GS</source>
          <target state="translated">GS</target>       </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.AccessControl.RegistryAccessRule.#ctor(System.String,System.Security.AccessControl.RegistryRights,System.Security.AccessControl.InheritanceFlags,System.Security.AccessControl.PropagationFlags,System.Security.AccessControl.AccessControlType)">
          <source>X</source>
          <target state="translated">X</target>       </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.AccessControl.RegistryAccessRule.#ctor(System.String,System.Security.AccessControl.RegistryRights,System.Security.AccessControl.InheritanceFlags,System.Security.AccessControl.PropagationFlags,System.Security.AccessControl.AccessControlType)">
          <source>X</source>
          <target state="translated">X</target>       </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.AccessControl.RegistryAccessRule.#ctor(System.String,System.Security.AccessControl.RegistryRights,System.Security.AccessControl.InheritanceFlags,System.Security.AccessControl.PropagationFlags,System.Security.AccessControl.AccessControlType)">
          <source>X</source>
          <target state="translated">X</target>       </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.AccessControl.RegistryAccessRule.#ctor(System.String,System.Security.AccessControl.RegistryRights,System.Security.AccessControl.InheritanceFlags,System.Security.AccessControl.PropagationFlags,System.Security.AccessControl.AccessControlType)">
          <source>X</source>
          <target state="translated">X</target>       </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.AccessControl.RegistryAccessRule.#ctor(System.String,System.Security.AccessControl.RegistryRights,System.Security.AccessControl.InheritanceFlags,System.Security.AccessControl.PropagationFlags,System.Security.AccessControl.AccessControlType)">
          <source>X</source>
          <target state="translated">X</target>       </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.AccessControl.RegistryAccessRule.#ctor(System.String,System.Security.AccessControl.RegistryRights,System.Security.AccessControl.InheritanceFlags,System.Security.AccessControl.PropagationFlags,System.Security.AccessControl.AccessControlType)">
          <source>X</source>
          <target state="translated">X</target>       </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.AccessControl.RegistryAccessRule.#ctor(System.String,System.Security.AccessControl.RegistryRights,System.Security.AccessControl.InheritanceFlags,System.Security.AccessControl.PropagationFlags,System.Security.AccessControl.AccessControlType)">
          <source>X</source>
          <target state="translated">X</target>       </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.AccessControl.RegistryAccessRule.#ctor(System.String,System.Security.AccessControl.RegistryRights,System.Security.AccessControl.InheritanceFlags,System.Security.AccessControl.PropagationFlags,System.Security.AccessControl.AccessControlType)">
          <source><ph id="ph1">&lt;xref:System.Security.AccessControl.PropagationFlags.NoPropagateInherit&gt;</ph>, <ph id="ph2">&lt;xref:System.Security.AccessControl.PropagationFlags.InheritOnly&gt;</ph></source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Security.AccessControl.PropagationFlags.NoPropagateInherit&gt;</ph>, <ph id="ph2">&lt;xref:System.Security.AccessControl.PropagationFlags.InheritOnly&gt;</ph></target>       </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.AccessControl.RegistryAccessRule.#ctor(System.String,System.Security.AccessControl.RegistryRights,System.Security.AccessControl.InheritanceFlags,System.Security.AccessControl.PropagationFlags,System.Security.AccessControl.AccessControlType)">
          <source>X</source>
          <target state="translated">X</target>       </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.AccessControl.RegistryAccessRule.#ctor(System.String,System.Security.AccessControl.RegistryRights,System.Security.AccessControl.InheritanceFlags,System.Security.AccessControl.PropagationFlags,System.Security.AccessControl.AccessControlType)">
          <source>The pattern for the grandchild subkey governs all subkeys contained by the grandchild subkey.</source>
          <target state="translated">O padrão para a subchave neto rege todas as subchaves contidas na subchave neto.</target>       </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.AccessControl.RegistryAccessRule.#ctor(System.String,System.Security.AccessControl.RegistryRights,System.Security.AccessControl.InheritanceFlags,System.Security.AccessControl.PropagationFlags,System.Security.AccessControl.AccessControlType)">
          <source>For example, if the <ph id="ph1">&lt;xref:System.Security.AccessControl.InheritanceFlags.ContainerInherit&gt;</ph> flag is specified for <ph id="ph2">`inheritanceFlags`</ph> and the <ph id="ph3">&lt;xref:System.Security.AccessControl.PropagationFlags.InheritOnly&gt;</ph> propagation flag is specified for <ph id="ph4">`propagationFlags`</ph>, this rule does not apply to the immediate subkey, but does apply to all its immediate child subkeys and to all subkeys they contain.</source>
          <target state="translated">Por exemplo, se o <ph id="ph1">&lt;xref:System.Security.AccessControl.InheritanceFlags.ContainerInherit&gt;</ph> sinalizador é especificado para <ph id="ph2">`inheritanceFlags`</ph> e <ph id="ph3">&lt;xref:System.Security.AccessControl.PropagationFlags.InheritOnly&gt;</ph> sinalizador de propagação é especificado para <ph id="ph4">`propagationFlags`</ph>, essa regra não se aplica a subchave imediata, mas se aplicam a todas as suas subchaves filho imediato e para todas as subchaves que eles contêm.</target>       </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.AccessControl.RegistryAccessRule.#ctor(System.String,System.Security.AccessControl.RegistryRights,System.Security.AccessControl.InheritanceFlags,System.Security.AccessControl.PropagationFlags,System.Security.AccessControl.AccessControlType)">
          <source>Although you can specify the <ph id="ph1">&lt;xref:System.Security.AccessControl.InheritanceFlags.ObjectInherit?displayProperty=nameWithType&gt;</ph> flag for <ph id="ph2">`inheritanceFlags`</ph>, there is no point in doing so.</source>
          <target state="translated">Embora você possa especificar o <ph id="ph1">&lt;xref:System.Security.AccessControl.InheritanceFlags.ObjectInherit?displayProperty=nameWithType&gt;</ph> sinalizador para <ph id="ph2">`inheritanceFlags`</ph>, não há nenhum ponto de fazer isso.</target>       </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.AccessControl.RegistryAccessRule.#ctor(System.String,System.Security.AccessControl.RegistryRights,System.Security.AccessControl.InheritanceFlags,System.Security.AccessControl.PropagationFlags,System.Security.AccessControl.AccessControlType)">
          <source>For the purposes of access control, the name/value pairs in a subkey are not separate objects.</source>
          <target state="translated">Para fins de controle de acesso, os pares de nome/valor em uma subchave não são objetos separados.</target>       </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.AccessControl.RegistryAccessRule.#ctor(System.String,System.Security.AccessControl.RegistryRights,System.Security.AccessControl.InheritanceFlags,System.Security.AccessControl.PropagationFlags,System.Security.AccessControl.AccessControlType)">
          <source>The access rights to name/value pairs are controlled by the rights of the subkey.</source>
          <target state="translated">Os direitos de acesso para pares de nome/valor são controlados por direitos da subchave.</target>       </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.AccessControl.RegistryAccessRule.#ctor(System.String,System.Security.AccessControl.RegistryRights,System.Security.AccessControl.InheritanceFlags,System.Security.AccessControl.PropagationFlags,System.Security.AccessControl.AccessControlType)">
          <source>Furthermore, since all subkeys are containers (that is, they can contain other subkeys), they are not affected by the <ph id="ph1">&lt;xref:System.Security.AccessControl.InheritanceFlags.ObjectInherit&gt;</ph> flag.</source>
          <target state="translated">Além disso, uma vez que todas as subchaves são contêineres (isto é, podem conter outras subchaves), eles não são afetados pelo <ph id="ph1">&lt;xref:System.Security.AccessControl.InheritanceFlags.ObjectInherit&gt;</ph> sinalizador.</target>       </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.AccessControl.RegistryAccessRule.#ctor(System.String,System.Security.AccessControl.RegistryRights,System.Security.AccessControl.InheritanceFlags,System.Security.AccessControl.PropagationFlags,System.Security.AccessControl.AccessControlType)">
          <source>Finally, specifying the <ph id="ph1">&lt;xref:System.Security.AccessControl.InheritanceFlags.ObjectInherit&gt;</ph> flag needlessly complicates the maintenance of rules, because it interferes with the combination of otherwise compatible rules.</source>
          <target state="translated">Por fim, especificando o <ph id="ph1">&lt;xref:System.Security.AccessControl.InheritanceFlags.ObjectInherit&gt;</ph> sinalizador desnecessariamente complica a manutenção de regras, pois ele interfere com a combinação de regras de outra forma compatíveis.</target>       </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.AccessControl.RegistryAccessRule.#ctor(System.String,System.Security.AccessControl.RegistryRights,System.Security.AccessControl.InheritanceFlags,System.Security.AccessControl.PropagationFlags,System.Security.AccessControl.AccessControlType)">
          <source>This constructor is equivalent to creating an <ph id="ph1">&lt;xref:System.Security.Principal.NTAccount&gt;</ph> object, by passing <ph id="ph2">`identity`</ph> to the <ph id="ph3">&lt;xref:System.Security.Principal.NTAccount.%23ctor%28System.String%29?displayProperty=nameWithType&gt;</ph> constructor, and passing the newly created <ph id="ph4">&lt;xref:System.Security.Principal.NTAccount&gt;</ph> object to the <ph id="ph5">&lt;xref:System.Security.AccessControl.RegistryAccessRule.%23ctor%28System.Security.Principal.IdentityReference%2CSystem.Security.AccessControl.RegistryRights%2CSystem.Security.AccessControl.InheritanceFlags%2CSystem.Security.AccessControl.PropagationFlags%2CSystem.Security.AccessControl.AccessControlType%29&gt;</ph> constructor.</source>
          <target state="translated">Este construtor é equivalente à criação de um <ph id="ph1">&lt;xref:System.Security.Principal.NTAccount&gt;</ph> objeto, passando <ph id="ph2">`identity`</ph> para o <ph id="ph3">&lt;xref:System.Security.Principal.NTAccount.%23ctor%28System.String%29?displayProperty=nameWithType&gt;</ph> construtor e passando recém-criado <ph id="ph4">&lt;xref:System.Security.Principal.NTAccount&gt;</ph> o objeto para o <ph id="ph5">&lt;xref:System.Security.AccessControl.RegistryAccessRule.%23ctor%28System.Security.Principal.IdentityReference%2CSystem.Security.AccessControl.RegistryRights%2CSystem.Security.AccessControl.InheritanceFlags%2CSystem.Security.AccessControl.PropagationFlags%2CSystem.Security.AccessControl.AccessControlType%29&gt;</ph> construtor.</target>       </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.AccessControl.RegistryAccessRule.#ctor(System.String,System.Security.AccessControl.RegistryRights,System.Security.AccessControl.InheritanceFlags,System.Security.AccessControl.PropagationFlags,System.Security.AccessControl.AccessControlType)">
          <source>The following code example demonstrates access rules with inheritance and propagation.</source>
          <target state="translated">O exemplo de código a seguir demonstra as regras de acesso com herança e propagação.</target>       </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.AccessControl.RegistryAccessRule.#ctor(System.String,System.Security.AccessControl.RegistryRights,System.Security.AccessControl.InheritanceFlags,System.Security.AccessControl.PropagationFlags,System.Security.AccessControl.AccessControlType)">
          <source>The example creates a <ph id="ph1">&lt;xref:System.Security.AccessControl.RegistrySecurity&gt;</ph> object, and then creates and adds two rules that have the <ph id="ph2">&lt;xref:System.Security.AccessControl.InheritanceFlags.ContainerInherit&gt;</ph> flag.</source>
          <target state="translated">O exemplo cria um <ph id="ph1">&lt;xref:System.Security.AccessControl.RegistrySecurity&gt;</ph> do objeto e, em seguida, cria e adiciona duas regras que têm o <ph id="ph2">&lt;xref:System.Security.AccessControl.InheritanceFlags.ContainerInherit&gt;</ph> sinalizador.</target>       </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.AccessControl.RegistryAccessRule.#ctor(System.String,System.Security.AccessControl.RegistryRights,System.Security.AccessControl.InheritanceFlags,System.Security.AccessControl.PropagationFlags,System.Security.AccessControl.AccessControlType)">
          <source>The first rule has no propagation flags, while the second has <ph id="ph1">&lt;xref:System.Security.AccessControl.PropagationFlags.NoPropagateInherit&gt;</ph> and <ph id="ph2">&lt;xref:System.Security.AccessControl.PropagationFlags.InheritOnly&gt;</ph>.</source>
          <target state="translated">A primeira regra não tem nenhum sinalizador de propagação, enquanto o segundo tem <ph id="ph1">&lt;xref:System.Security.AccessControl.PropagationFlags.NoPropagateInherit&gt;</ph> e <ph id="ph2">&lt;xref:System.Security.AccessControl.PropagationFlags.InheritOnly&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.AccessControl.RegistryAccessRule.#ctor(System.String,System.Security.AccessControl.RegistryRights,System.Security.AccessControl.InheritanceFlags,System.Security.AccessControl.PropagationFlags,System.Security.AccessControl.AccessControlType)">
          <source>The program displays the rules in the <ph id="ph1">&lt;xref:System.Security.AccessControl.RegistrySecurity&gt;</ph> object, and then uses the <ph id="ph2">&lt;xref:System.Security.AccessControl.RegistrySecurity&gt;</ph> object to create a subkey.</source>
          <target state="translated">O programa exibe as regras de <ph id="ph1">&lt;xref:System.Security.AccessControl.RegistrySecurity&gt;</ph> objeto e, em seguida, usa o <ph id="ph2">&lt;xref:System.Security.AccessControl.RegistrySecurity&gt;</ph> objeto para criar uma subchave.</target>       </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.AccessControl.RegistryAccessRule.#ctor(System.String,System.Security.AccessControl.RegistryRights,System.Security.AccessControl.InheritanceFlags,System.Security.AccessControl.PropagationFlags,System.Security.AccessControl.AccessControlType)">
          <source>The program creates a child subkey and a grandchild subkey, and then displays the rules for each subkey.</source>
          <target state="translated">O programa cria um filho subchave e uma subchave neto e, em seguida, exibe as regras para cada subchave.</target>       </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.AccessControl.RegistryAccessRule.#ctor(System.String,System.Security.AccessControl.RegistryRights,System.Security.AccessControl.InheritanceFlags,System.Security.AccessControl.PropagationFlags,System.Security.AccessControl.AccessControlType)">
          <source>Finally, the program deletes the test keys.</source>
          <target state="translated">Por fim, o programa exclui as chaves de teste.</target>       </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve" uid="M:System.Security.AccessControl.RegistryAccessRule.#ctor(System.String,System.Security.AccessControl.RegistryRights,System.Security.AccessControl.InheritanceFlags,System.Security.AccessControl.PropagationFlags,System.Security.AccessControl.AccessControlType)">
          <source><ph id="ph1">&lt;paramref name="registryRights" /&gt;</ph> specifies an invalid value.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="registryRights" /&gt;</ph> especifica um valor inválido.</target>       </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve" uid="M:System.Security.AccessControl.RegistryAccessRule.#ctor(System.String,System.Security.AccessControl.RegistryRights,System.Security.AccessControl.InheritanceFlags,System.Security.AccessControl.PropagationFlags,System.Security.AccessControl.AccessControlType)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve" uid="M:System.Security.AccessControl.RegistryAccessRule.#ctor(System.String,System.Security.AccessControl.RegistryRights,System.Security.AccessControl.InheritanceFlags,System.Security.AccessControl.PropagationFlags,System.Security.AccessControl.AccessControlType)">
          <source><ph id="ph1">&lt;paramref name="type" /&gt;</ph> specifies an invalid value.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="type" /&gt;</ph> especifica um valor inválido.</target>       </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve" uid="M:System.Security.AccessControl.RegistryAccessRule.#ctor(System.String,System.Security.AccessControl.RegistryRights,System.Security.AccessControl.InheritanceFlags,System.Security.AccessControl.PropagationFlags,System.Security.AccessControl.AccessControlType)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve" uid="M:System.Security.AccessControl.RegistryAccessRule.#ctor(System.String,System.Security.AccessControl.RegistryRights,System.Security.AccessControl.InheritanceFlags,System.Security.AccessControl.PropagationFlags,System.Security.AccessControl.AccessControlType)">
          <source><ph id="ph1">&lt;paramref name="inheritanceFlags" /&gt;</ph> specifies an invalid value.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="inheritanceFlags" /&gt;</ph> especifica um valor inválido.</target>       </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve" uid="M:System.Security.AccessControl.RegistryAccessRule.#ctor(System.String,System.Security.AccessControl.RegistryRights,System.Security.AccessControl.InheritanceFlags,System.Security.AccessControl.PropagationFlags,System.Security.AccessControl.AccessControlType)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve" uid="M:System.Security.AccessControl.RegistryAccessRule.#ctor(System.String,System.Security.AccessControl.RegistryRights,System.Security.AccessControl.InheritanceFlags,System.Security.AccessControl.PropagationFlags,System.Security.AccessControl.AccessControlType)">
          <source><ph id="ph1">&lt;paramref name="propagationFlags" /&gt;</ph> specifies an invalid value.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="propagationFlags" /&gt;</ph> especifica um valor inválido.</target>       </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve" uid="M:System.Security.AccessControl.RegistryAccessRule.#ctor(System.String,System.Security.AccessControl.RegistryRights,System.Security.AccessControl.InheritanceFlags,System.Security.AccessControl.PropagationFlags,System.Security.AccessControl.AccessControlType)">
          <source><ph id="ph1">&lt;paramref name="eventRights" /&gt;</ph> is zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="eventRights" /&gt;</ph> é zero.</target>       </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve" uid="M:System.Security.AccessControl.RegistryAccessRule.#ctor(System.String,System.Security.AccessControl.RegistryRights,System.Security.AccessControl.InheritanceFlags,System.Security.AccessControl.PropagationFlags,System.Security.AccessControl.AccessControlType)">
          <source><ph id="ph1">&lt;paramref name="identity" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="identity" /&gt;</ph> é <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve" uid="M:System.Security.AccessControl.RegistryAccessRule.#ctor(System.String,System.Security.AccessControl.RegistryRights,System.Security.AccessControl.InheritanceFlags,System.Security.AccessControl.PropagationFlags,System.Security.AccessControl.AccessControlType)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve" uid="M:System.Security.AccessControl.RegistryAccessRule.#ctor(System.String,System.Security.AccessControl.RegistryRights,System.Security.AccessControl.InheritanceFlags,System.Security.AccessControl.PropagationFlags,System.Security.AccessControl.AccessControlType)">
          <source><ph id="ph1">&lt;paramref name="identity" /&gt;</ph> is a zero-length string.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="identity" /&gt;</ph> é uma cadeia de comprimento zero.</target>       </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve" uid="M:System.Security.AccessControl.RegistryAccessRule.#ctor(System.String,System.Security.AccessControl.RegistryRights,System.Security.AccessControl.InheritanceFlags,System.Security.AccessControl.PropagationFlags,System.Security.AccessControl.AccessControlType)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve" uid="M:System.Security.AccessControl.RegistryAccessRule.#ctor(System.String,System.Security.AccessControl.RegistryRights,System.Security.AccessControl.InheritanceFlags,System.Security.AccessControl.PropagationFlags,System.Security.AccessControl.AccessControlType)">
          <source><ph id="ph1">&lt;paramref name="identity" /&gt;</ph> is longer than 512 characters.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="identity" /&gt;</ph> tem mais de 512 caracteres.</target>       </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve" uid="P:System.Security.AccessControl.RegistryAccessRule.RegistryRights">
          <source>Gets the rights allowed or denied by the access rule.</source>
          <target state="translated">Obtém os direitos permitidos ou negados pela regra de acesso.</target>       </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Security.AccessControl.RegistryAccessRule.RegistryRights">
          <source>A bitwise combination of <ph id="ph1">&lt;see cref="T:System.Security.AccessControl.RegistryRights" /&gt;</ph> values indicating the rights allowed or denied by the access rule.</source>
          <target state="translated">Uma combinação bit a bit de valores <ph id="ph1">&lt;see cref="T:System.Security.AccessControl.RegistryRights" /&gt;</ph> que indicam os direitos permitidos ou negados pela regra de acesso.</target>       </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Security.AccessControl.RegistryAccessRule.RegistryRights">
          <source><ph id="ph1">&lt;xref:System.Security.AccessControl.RegistryAccessRule&gt;</ph> objects are immutable.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Security.AccessControl.RegistryAccessRule&gt;</ph> os objetos são imutáveis.</target>       </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Security.AccessControl.RegistryAccessRule.RegistryRights">
          <source>You can create a new access rule representing a different user, different rights, or a different <ph id="ph1">&lt;xref:System.Security.AccessControl.AccessControlType&gt;</ph>, but you cannot modify an existing access rule.</source>
          <target state="translated">Você pode criar uma nova regra de acesso que representa um usuário diferente, direitos diferentes ou outro <ph id="ph1">&lt;xref:System.Security.AccessControl.AccessControlType&gt;</ph>, mas você não pode modificar uma regra de acesso existentes.</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>