<Type Name="FileSystem" FullName="Microsoft.VisualBasic.FileIO.FileSystem">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="8704d769078ae0f066a62217691b00687993a085" />
    <Meta Name="ms.sourcegitcommit" Value="9dda17222b9f7d3edf130133bfb1370d5b410a4b" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="pt-BR" />
    <Meta Name="ms.lasthandoff" Value="09/22/2018" />
    <Meta Name="ms.locfileid" Value="46618885" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class FileSystem" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit FileSystem extends System.Object" />
  <TypeSignature Language="DocId" Value="T:Microsoft.VisualBasic.FileIO.FileSystem" />
  <TypeSignature Language="VB.NET" Value="Public Class FileSystem" />
  <TypeSignature Language="C++ CLI" Value="public ref class FileSystem" />
  <TypeSignature Language="F#" Value="type FileSystem = class" />
  <AssemblyInfo>
    <AssemblyName>Microsoft.VisualBasic</AssemblyName>
    <AssemblyVersion>8.0.0.0</AssemblyVersion>
    <AssemblyVersion>10.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Fornece propriedades e métodos para trabalhar com unidades, arquivos e diretórios.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista exemplos de tarefas que envolvem o `My.Computer.FileSystem` objeto.  
  
|Para|Consulte|  
|-|-|  
|Ler de um arquivo de texto|[Como ler em arquivos de texto](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-from-text-files.md)|  
|Ler um arquivo de texto delimitado|[Como ler a partir de arquivos de texto separados por vírgulas](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-from-comma-delimited-text-files.md)|  
|Ler um arquivo de texto de largura fixa|[Como ler a partir de arquivos de texto de largura fixa](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-from-fixed-width-text-files.md)|  
|Ler um arquivo de texto com vários formatos|[Como ler a partir de arquivos de texto com vários formatos](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-from-text-files-with-multiple-formats.md)|  
|Ler de um arquivo binário|[Como ler a partir de arquivos binários](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-from-binary-files.md)|  
|Ler um arquivo de texto com um <xref:System.IO.StreamReader>|[Como ler texto a partir de arquivos com um StreamReader](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-text-from-files-with-a-streamreader.md)|  
|Gravar em um arquivo de texto|[Como gravar texto em arquivos](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files.md)|  
|Anexar a um arquivo de texto|[Como anexar a arquivos de texto](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-append-to-text-files.md)|  
|Gravar em um arquivo binário|[Como gravar em arquivos binários](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-to-binary-files.md)|  
|Gravar em arquivos de texto na **MyDocuments** diretório|[Como gravar texto em arquivos no diretório Meus Documentos](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files-in-the-my-documents-directory.md)|  
|Gravar em um arquivo de texto com um `StreamWriter`|[Como gravar texto em arquivos com um StreamWriter](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files-with-a-streamwriter.md)|  
|Copiar arquivos com um padrão específico|[Como copiar arquivos com um padrão específico para um diretório](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-copy-files-with-a-specific-pattern-to-a-directory.md)|  
|Copiar um arquivo no mesmo diretório|[Como criar uma cópia de um arquivo no mesmo diretório](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-create-a-copy-of-a-file-in-the-same-directory.md)|  
|Copiar um arquivo para um diretório diferente|[Como criar uma cópia de um arquivo em um diretório diferente](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-create-a-copy-of-a-file-in-a-different-directory.md)|  
|Crie um arquivo|[Como criar um arquivo](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-create-a-file.md)|  
|Excluir um arquivo|[Como excluir um arquivo](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-delete-a-file.md)|  
|Localizar arquivos com um padrão específico|[Como localizar arquivos com um padrão específico](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-find-files-with-a-specific-pattern.md)|  
|Mover um arquivo|[Como mover um arquivo](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-move-a-file.md)|  
|Renomear um arquivo|[Como renomear um arquivo](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-rename-a-file.md)|  
|Copiar um diretório para outro diretório|[Como copiar um diretório para outro diretório](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-copy-a-directory-to-another-directory.md)|  
|Criar um diretório|[Como criar um diretório](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-create-a-directory.md)|  
|Localizar subdiretórios com um padrão específico|[Como localizar subdiretórios com um padrão específico](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-find-subdirectories-with-a-specific-pattern.md)|  
|Obtenha a coleção de arquivos em um diretório|[Como obter a coleção de arquivos em um diretório](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-get-the-collection-of-files-in-a-directory.md)|  
|Ler a partir de **MyDocuments** diretório|[Como recuperar o conteúdo do diretório Meus Documentos](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-retrieve-the-contents-of-the-my-documents-directory.md)|  
|Analisar um caminho de arquivo|[Como analisar demarcadores de arquivo](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-parse-file-paths.md)|  
  
   
  
## Examples  
 Este exemplo verifica para determinar se a pasta `C:\backup\logs` existe e verifica suas propriedades.  
  
 [!code-vb[VbVbcnMyFileSystem#23](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#23)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:Microsoft.VisualBasic.FileIO.SpecialDirectories" />
    <related type="Article" href="~/docs/visual-basic/language-reference/objects/index.md">Objetos (Visual Basic)</related>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FileSystem ();" />
      <MemberSignature Language="ILAsm" Value=".method public specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FileSystem();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>Inicializa uma nova instância da classe <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 [Objetos (Visual Basic)](~/docs/visual-basic/language-reference/objects/index.md)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CombinePath">
      <MemberSignature Language="C#" Value="public static string CombinePath (string baseDirectory, string relativePath);" />
      <MemberSignature Language="ILAsm" Value=".method public static string CombinePath(string baseDirectory, string relativePath) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.CombinePath(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CombinePath (baseDirectory As String, relativePath As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ CombinePath(System::String ^ baseDirectory, System::String ^ relativePath);" />
      <MemberSignature Language="F#" Value="static member CombinePath : string * string -&gt; string" Usage="Microsoft.VisualBasic.FileIO.FileSystem.CombinePath (baseDirectory, relativePath)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="baseDirectory" Type="System.String" />
        <Parameter Name="relativePath" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="baseDirectory">
          <see langword="String" />. Primeiro caminho a ser combinado.</param>
        <param name="relativePath">
          <see langword="String" />. Segundo caminho a ser combinado.</param>
        <summary>Combina dois caminhos e retorna um caminho formatado corretamente.</summary>
        <returns>A combinação dos caminhos especificados.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método Remove caracteres de barra em excesso para criar um caminho formatado corretamente.  
  
 A tabela a seguir lista um exemplo de uma tarefa que envolvem o `My.Computer.FileSystem.CombinePath` método.  
  
|Para|Consulte|  
|-|-|  
|Combinar um nome de arquivo e caminho do diretório|[Como: analisar demarcadores de arquivo no Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-parse-file-paths.md)|  
  
   
  
## Examples  
 Este exemplo combina um nome de arquivo e caminho do diretório para criar um caminho formatado corretamente.  
  
 [!code-vb[VbRefFile#3](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#3)]  
  
 Este exemplo combina dois caminhos para criar um caminho formatado corretamente.  
  
 [!code-vb[VbRefFile#4](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#4)]  
  
 Este exemplo retorna `C:\Dir1\Dir2\Dir4\Dir5\File.txt`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="baseDirectory" /> ou <paramref name="relativePath" /> são caminhos malformados.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Controla a capacidade de acessar arquivos e pastas. Enumeração associada: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <altmember cref="M:Microsoft.VisualBasic.FileIO.FileSystem.GetParentPath(System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CopyDirectory">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Copia o conteúdo de um diretório para outro diretório.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CopyDirectory">
      <MemberSignature Language="C#" Value="public static void CopyDirectory (string sourceDirectoryName, string destinationDirectoryName);" />
      <MemberSignature Language="ILAsm" Value=".method public static void CopyDirectory(string sourceDirectoryName, string destinationDirectoryName) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.CopyDirectory(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub CopyDirectory (sourceDirectoryName As String, destinationDirectoryName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void CopyDirectory(System::String ^ sourceDirectoryName, System::String ^ destinationDirectoryName);" />
      <MemberSignature Language="F#" Value="static member CopyDirectory : string * string -&gt; unit" Usage="Microsoft.VisualBasic.FileIO.FileSystem.CopyDirectory (sourceDirectoryName, destinationDirectoryName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceDirectoryName" Type="System.String" />
        <Parameter Name="destinationDirectoryName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="sourceDirectoryName">O diretório a ser copiado.</param>
        <param name="destinationDirectoryName">O local para o qual o conteúdo do diretório deve ser copiado.</param>
        <summary>Copia o conteúdo de um diretório para outro diretório.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método copia o conteúdo do diretório de origem para o diretório de destino. Se o diretório de destino não existir, ele é criado. Se um diretório com o mesmo nome existir no local de destino, o conteúdo dos dois diretórios é mesclado. Você pode especificar um novo nome para o diretório durante a operação.  
  
 Ao copiar arquivos em um diretório, exceções podem ser geradas que são causados por um arquivo específico. Quando essas exceções são lançadas, elas são consolidadas em uma única exceção cuja `Data` propriedade contém as entradas na forma de um <xref:System.Collections.IDictionary> no qual o caminho de arquivo ou diretório é a chave e a mensagem de exceção específica está contida no valor correspondente. Use `For…Each` para enumerar as entradas.  
  
 A tabela a seguir lista um exemplo de uma tarefa que envolvem o `My.Computer.FileSystem.CopyDirectory` método.  
  
|Para|Consulte|  
|-|-|  
|Copiar um diretório|[Como: copiar um diretório para outro diretório no Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-copy-a-directory-to-another-directory.md)|  
  
   
  
## Examples  
 O exemplo a seguir copia o conteúdo do diretório `TestDirectory1` em `TestDirectory2`, substituindo arquivos existentes.  
  
 [!code-vb[VbVbcnMyFileSystem#49](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#49)]  
  
 Substitua `C:\TestDirectory1` e `C:\TestDirectory2` com o caminho e nome do diretório que você deseja copiar e o local ao qual você deseja copiá-lo.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">O caminho não é válido por um dos seguintes motivos: é uma cadeia de tamanho zero, contém apenas espaços em branco, contém caracteres inválidos ou é um caminho de dispositivo (começa com \\\\.\\).</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="destinationDirectoryName" /> ou <paramref name="sourceDirectoryName" /> é <see langword="Nothing" /> ou uma cadeia de caracteres vazia.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">O diretório de origem não existe.</exception>
        <exception cref="T:System.IO.IOException">O caminho de origem e o caminho de destino são os mesmos.</exception>
        <exception cref="T:System.InvalidOperationException">A operação é cíclica.</exception>
        <exception cref="T:System.IO.PathTooLongException">O caminho excede o tamanho máximo definido pelo sistema.</exception>
        <exception cref="T:System.NotSupportedException">Um nome de pasta no caminho contém dois pontos (:) ou está em um formato inválido.</exception>
        <exception cref="T:System.Security.SecurityException">O usuário não tem as permissões necessárias para exibir o caminho.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Um arquivo de destino existe, mas não pode ser acessado.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Controla a capacidade de acessar arquivos e pastas. Enumeração associada: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <altmember cref="T:Microsoft.VisualBasic.FileIO.UICancelOption" />
      </Docs>
    </Member>
    <Member MemberName="CopyDirectory">
      <MemberSignature Language="C#" Value="public static void CopyDirectory (string sourceDirectoryName, string destinationDirectoryName, Microsoft.VisualBasic.FileIO.UIOption showUI);" />
      <MemberSignature Language="ILAsm" Value=".method public static void CopyDirectory(string sourceDirectoryName, string destinationDirectoryName, valuetype Microsoft.VisualBasic.FileIO.UIOption showUI) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.CopyDirectory(System.String,System.String,Microsoft.VisualBasic.FileIO.UIOption)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub CopyDirectory (sourceDirectoryName As String, destinationDirectoryName As String, showUI As UIOption)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void CopyDirectory(System::String ^ sourceDirectoryName, System::String ^ destinationDirectoryName, Microsoft::VisualBasic::FileIO::UIOption showUI);" />
      <MemberSignature Language="F#" Value="static member CopyDirectory : string * string * Microsoft.VisualBasic.FileIO.UIOption -&gt; unit" Usage="Microsoft.VisualBasic.FileIO.FileSystem.CopyDirectory (sourceDirectoryName, destinationDirectoryName, showUI)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceDirectoryName" Type="System.String" />
        <Parameter Name="destinationDirectoryName" Type="System.String" />
        <Parameter Name="showUI" Type="Microsoft.VisualBasic.FileIO.UIOption" />
      </Parameters>
      <Docs>
        <param name="sourceDirectoryName">O diretório a ser copiado.</param>
        <param name="destinationDirectoryName">O local para o qual o conteúdo do diretório deve ser copiado.</param>
        <param name="showUI">Se o progresso da operação deve ser acompanhado visualmente. O padrão é <see langword="UIOption.OnlyErrorDialogs" />.</param>
        <summary>Copia o conteúdo de um diretório para outro diretório.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método copia o conteúdo do diretório de origem para o diretório de destino. Se o diretório de destino não existir, ele é criado. Se um diretório com o mesmo nome existir no local de destino, o conteúdo dos dois diretórios é mesclado. Você pode especificar um novo nome para o diretório durante a operação.  
  
 Ao copiar arquivos em um diretório, exceções podem ser geradas que são causados por um arquivo específico. Quando essas exceções são lançadas, elas são consolidadas em uma única exceção cuja `Data` propriedade contém as entradas na forma de um <xref:System.Collections.IDictionary> no qual o caminho de arquivo ou diretório é a chave e a mensagem de exceção específica está contida no valor correspondente. Use `For…Each` para enumerar as entradas.  
  
 A tabela a seguir lista um exemplo de uma tarefa que envolvem o `My.Computer.FileSystem.CopyDirectory` método.  
  
|Para|Consulte|  
|-|-|  
|Copiar um diretório|[Como: copiar um diretório para outro diretório no Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-copy-a-directory-to-another-directory.md)|  
  
   
  
## Examples  
 O exemplo a seguir copia o conteúdo do diretório `TestDirectory1` em `TestDirectory2`, substituindo arquivos existentes.  
  
 [!code-vb[VbVbcnMyFileSystem#49](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#49)]  
  
 Substitua `C:\TestDirectory1` e `C:\TestDirectory2` com o caminho e nome do diretório que você deseja copiar e o local ao qual você deseja copiá-lo.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">O caminho não é válido por um dos seguintes motivos: é uma cadeia de tamanho zero, contém apenas espaços em branco, contém caracteres inválidos ou é um caminho de dispositivo (começa com \\\\.\\).</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="destinationDirectoryName" /> ou <paramref name="sourceDirectoryName" /> é <see langword="Nothing" /> ou uma cadeia de caracteres vazia.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">O diretório de origem não existe.</exception>
        <exception cref="T:System.IO.IOException">O caminho de origem e o caminho de destino são os mesmos.</exception>
        <exception cref="T:System.InvalidOperationException">A operação é cíclica.</exception>
        <exception cref="T:System.IO.PathTooLongException">O caminho excede o tamanho máximo definido pelo sistema.</exception>
        <exception cref="T:System.NotSupportedException">Um nome de pasta no caminho contém dois pontos (:) ou está em um formato inválido.</exception>
        <exception cref="T:System.Security.SecurityException">O usuário não tem as permissões necessárias para exibir o caminho.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Um arquivo de destino existe, mas não pode ser acessado.</exception>
        <exception cref="T:System.OperationCanceledException">
          <paramref name="ShowUI" /> está definido como <see langword="UIOption.AllDialogs" /> e o usuário cancelou a operação ou um ou mais arquivos no diretório não podem ser copiados.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Controla a capacidade de acessar arquivos e pastas. Enumeração associada: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <permission cref="T:System.Security.Permissions.UIPermission">Controla as permissões relacionadas às interfaces de usuário e a área de transferência. Enumeração associada: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeSubWindows" />.</permission>
        <altmember cref="T:Microsoft.VisualBasic.FileIO.UICancelOption" />
      </Docs>
    </Member>
    <Member MemberName="CopyDirectory">
      <MemberSignature Language="C#" Value="public static void CopyDirectory (string sourceDirectoryName, string destinationDirectoryName, bool overwrite);" />
      <MemberSignature Language="ILAsm" Value=".method public static void CopyDirectory(string sourceDirectoryName, string destinationDirectoryName, bool overwrite) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.CopyDirectory(System.String,System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub CopyDirectory (sourceDirectoryName As String, destinationDirectoryName As String, overwrite As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void CopyDirectory(System::String ^ sourceDirectoryName, System::String ^ destinationDirectoryName, bool overwrite);" />
      <MemberSignature Language="F#" Value="static member CopyDirectory : string * string * bool -&gt; unit" Usage="Microsoft.VisualBasic.FileIO.FileSystem.CopyDirectory (sourceDirectoryName, destinationDirectoryName, overwrite)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceDirectoryName" Type="System.String" />
        <Parameter Name="destinationDirectoryName" Type="System.String" />
        <Parameter Name="overwrite" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="sourceDirectoryName">O diretório a ser copiado.</param>
        <param name="destinationDirectoryName">O local para o qual o conteúdo do diretório deve ser copiado.</param>
        <param name="overwrite">
          <see langword="True" /> para substituir arquivos existentes; caso contrário, <see langword="False" />. O padrão é <see langword="False" />.</param>
        <summary>Copia o conteúdo de um diretório para outro diretório.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método copia o conteúdo do diretório de origem para o diretório de destino. Se o diretório de destino não existir, ele é criado. Se um diretório com o mesmo nome existir no local de destino, o conteúdo dos dois diretórios é mesclado. Você pode especificar um novo nome para o diretório durante a operação.  
  
 Ao copiar arquivos em um diretório, exceções podem ser geradas que são causados por um arquivo específico, como um arquivo existente durante a mesclagem enquanto `overwrite` é definido como `False`. Quando essas exceções são lançadas, elas são consolidadas em uma única exceção cuja `Data` propriedade contém as entradas na forma de um <xref:System.Collections.IDictionary> no qual o caminho de arquivo ou diretório é a chave e a mensagem de exceção específica está contida no valor correspondente. Use `For…Each` para enumerar as entradas.  
  
 A tabela a seguir lista um exemplo de uma tarefa que envolvem o `My.Computer.FileSystem.CopyDirectory` método.  
  
|Para|Consulte|  
|-|-|  
|Copiar um diretório|[Como: copiar um diretório para outro diretório no Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-copy-a-directory-to-another-directory.md)|  
  
   
  
## Examples  
 O exemplo a seguir copia o conteúdo do diretório `TestDirectory1` em `TestDirectory2`, substituindo arquivos existentes.  
  
 [!code-vb[VbVbcnMyFileSystem#49](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#49)]  
  
 Substitua `C:\TestDirectory1` e `C:\TestDirectory2` com o caminho e nome do diretório que você deseja copiar e o local ao qual você deseja copiá-lo.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">O caminho não é válido por um dos seguintes motivos: é uma cadeia de tamanho zero, contém apenas espaços em branco, contém caracteres inválidos ou é um caminho de dispositivo (começa com \\\\.\\).</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="destinationDirectoryName" /> ou <paramref name="sourceDirectoryName" /> é <see langword="Nothing" /> ou uma cadeia de caracteres vazia.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">O diretório de origem não existe.</exception>
        <exception cref="T:System.IO.IOException">O caminho de origem e o caminho de destino são os mesmos.</exception>
        <exception cref="T:System.InvalidOperationException">A operação é cíclica.</exception>
        <exception cref="T:System.IO.PathTooLongException">O caminho excede o tamanho máximo definido pelo sistema.</exception>
        <exception cref="T:System.NotSupportedException">Um nome de pasta no caminho contém dois pontos (:) ou está em um formato inválido.</exception>
        <exception cref="T:System.Security.SecurityException">O usuário não tem as permissões necessárias para exibir o caminho.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Um arquivo de destino existe, mas não pode ser acessado.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Controla a capacidade de acessar arquivos e pastas. Enumeração associada: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <altmember cref="T:Microsoft.VisualBasic.FileIO.UICancelOption" />
      </Docs>
    </Member>
    <Member MemberName="CopyDirectory">
      <MemberSignature Language="C#" Value="public static void CopyDirectory (string sourceDirectoryName, string destinationDirectoryName, Microsoft.VisualBasic.FileIO.UIOption showUI, Microsoft.VisualBasic.FileIO.UICancelOption onUserCancel);" />
      <MemberSignature Language="ILAsm" Value=".method public static void CopyDirectory(string sourceDirectoryName, string destinationDirectoryName, valuetype Microsoft.VisualBasic.FileIO.UIOption showUI, valuetype Microsoft.VisualBasic.FileIO.UICancelOption onUserCancel) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.CopyDirectory(System.String,System.String,Microsoft.VisualBasic.FileIO.UIOption,Microsoft.VisualBasic.FileIO.UICancelOption)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub CopyDirectory (sourceDirectoryName As String, destinationDirectoryName As String, showUI As UIOption, onUserCancel As UICancelOption)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void CopyDirectory(System::String ^ sourceDirectoryName, System::String ^ destinationDirectoryName, Microsoft::VisualBasic::FileIO::UIOption showUI, Microsoft::VisualBasic::FileIO::UICancelOption onUserCancel);" />
      <MemberSignature Language="F#" Value="static member CopyDirectory : string * string * Microsoft.VisualBasic.FileIO.UIOption * Microsoft.VisualBasic.FileIO.UICancelOption -&gt; unit" Usage="Microsoft.VisualBasic.FileIO.FileSystem.CopyDirectory (sourceDirectoryName, destinationDirectoryName, showUI, onUserCancel)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceDirectoryName" Type="System.String" />
        <Parameter Name="destinationDirectoryName" Type="System.String" />
        <Parameter Name="showUI" Type="Microsoft.VisualBasic.FileIO.UIOption" />
        <Parameter Name="onUserCancel" Type="Microsoft.VisualBasic.FileIO.UICancelOption" />
      </Parameters>
      <Docs>
        <param name="sourceDirectoryName">O diretório a ser copiado.</param>
        <param name="destinationDirectoryName">O local para o qual o conteúdo do diretório deve ser copiado.</param>
        <param name="showUI">Se o progresso da operação deve ser acompanhado visualmente. O padrão é <see langword="UIOption.OnlyErrorDialogs" />.</param>
        <param name="onUserCancel">Especifica o que deverá ser feito, se o usuário clicar em **Cancelar** durante a operação. O padrão é <see cref="F:Microsoft.VisualBasic.FileIO.UICancelOption.ThrowException" />.</param>
        <summary>Copia o conteúdo de um diretório para outro diretório.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método copia o conteúdo do diretório de origem para o diretório de destino. Se o diretório de destino não existir, ele é criado. Se um diretório com o mesmo nome existir no local de destino, o conteúdo dos dois diretórios é mesclado. Você pode especificar um novo nome para o diretório durante a operação.  
  
 Ao copiar arquivos em um diretório, exceções podem ser geradas que são causados por um arquivo específico. Quando essas exceções são lançadas, elas são consolidadas em uma única exceção cuja `Data` propriedade contém as entradas na forma de um <xref:System.Collections.IDictionary> no qual o caminho de arquivo ou diretório é a chave e a mensagem de exceção específica está contida no valor correspondente. Use `For…Each` para enumerar as entradas.  
  
 A tabela a seguir lista um exemplo de uma tarefa que envolvem o `My.Computer.FileSystem.CopyDirectory` método.  
  
|Para|Consulte|  
|-|-|  
|Copiar um diretório|[Como: copiar um diretório para outro diretório no Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-copy-a-directory-to-another-directory.md)|  
  
   
  
## Examples  
 O exemplo a seguir copia o conteúdo do diretório `TestDirectory1` em `TestDirectory2`, substituindo arquivos existentes.  
  
 [!code-vb[VbVbcnMyFileSystem#49](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#49)]  
  
 Substitua `C:\TestDirectory1` e `C:\TestDirectory2` com o caminho e nome do diretório que você deseja copiar e o local ao qual você deseja copiá-lo.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">O caminho não é válido por um dos seguintes motivos: é uma cadeia de tamanho zero, contém apenas espaços em branco, contém caracteres inválidos ou é um caminho de dispositivo (começa com \\\\.\\).</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="destinationDirectoryName" /> ou <paramref name="sourceDirectoryName" /> é <see langword="Nothing" /> ou uma cadeia de caracteres vazia.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">O diretório de origem não existe.</exception>
        <exception cref="T:System.IO.IOException">O caminho de origem e o caminho de destino são os mesmos.</exception>
        <exception cref="T:System.InvalidOperationException">A operação é cíclica.</exception>
        <exception cref="T:System.IO.PathTooLongException">O caminho excede o tamanho máximo definido pelo sistema.</exception>
        <exception cref="T:System.NotSupportedException">Um nome de pasta no caminho contém dois pontos (:) ou está em um formato inválido.</exception>
        <exception cref="T:System.Security.SecurityException">O usuário não tem as permissões necessárias para exibir o caminho.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Um arquivo de destino existe, mas não pode ser acessado.</exception>
        <exception cref="T:System.OperationCanceledException">
          <paramref name="ShowUI" /> está definido como <see langword="UIOption.AllDialogs" /> e o usuário cancelou a operação ou um ou mais arquivos no diretório não podem ser copiados.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Controla a capacidade de acessar arquivos e pastas. Enumeração associada: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <permission cref="T:System.Security.Permissions.UIPermission">Controla as permissões relacionadas às interfaces de usuário e a área de transferência. Enumeração associada: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeSubWindows" />.</permission>
        <altmember cref="T:Microsoft.VisualBasic.FileIO.UICancelOption" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CopyFile">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Copia um arquivo para um novo local.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CopyFile">
      <MemberSignature Language="C#" Value="public static void CopyFile (string sourceFileName, string destinationFileName);" />
      <MemberSignature Language="ILAsm" Value=".method public static void CopyFile(string sourceFileName, string destinationFileName) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.CopyFile(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub CopyFile (sourceFileName As String, destinationFileName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void CopyFile(System::String ^ sourceFileName, System::String ^ destinationFileName);" />
      <MemberSignature Language="F#" Value="static member CopyFile : string * string -&gt; unit" Usage="Microsoft.VisualBasic.FileIO.FileSystem.CopyFile (sourceFileName, destinationFileName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceFileName" Type="System.String" />
        <Parameter Name="destinationFileName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="sourceFileName">O arquivo a ser copiado.</param>
        <param name="destinationFileName">O local para o qual o arquivo deve ser copiado.</param>
        <summary>Copia um arquivo para um novo local.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `CopyFile` não preserva as ACEs (entradas de controle de acesso). O arquivo recém-criado herda ACEs padrão do diretório no qual ele é criado.  
  
 A tabela a seguir lista exemplos de tarefas que envolvem o `My.Computer.FileSystem.CopyFile` método.  
  
|Para|Consulte|  
|-|-|  
|Copie um arquivo no mesmo diretório.|[Como: criar uma cópia de um arquivo no mesmo diretório no Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-create-a-copy-of-a-file-in-the-same-directory.md)|  
|Copie um arquivo para um diretório diferente.|[Como: criar uma cópia de um arquivo em um diretório diferente no Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-create-a-copy-of-a-file-in-a-different-directory.md)|  
  
   
  
## Examples  
 Este exemplo copia o arquivo `Test.txt` para o diretório `TestFiles2` sem substituir arquivos existentes.  
  
 [!code-vb[VbRefFile#15](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#15)]  
  
 Substitua os caminhos de arquivo com os caminhos que você deseja usar em seu código.  
  
 Este exemplo copia o arquivo `Test.txt` para o diretório `TestFiles2` e o renomeia `NewFile.txt`.  
  
 [!code-vb[VbRefFile#16](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#16)]  
  
 Substitua os caminhos de arquivo com os caminhos que você deseja usar em seu código.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="destinationFileName" /> contém informações de caminho.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="destinationFileName" /> ou <paramref name="sourceFileName" /> é <see langword="Nothing" /> ou uma cadeia de caracteres vazia.</exception>
        <exception cref="T:System.IO.FileNotFoundException">O arquivo de origem não é válido ou não existe.</exception>
        <exception cref="T:System.IO.IOException">Um arquivo no diretório de destino com o mesmo nome está sendo usado.</exception>
        <exception cref="T:System.NotSupportedException">Um nome de arquivo ou de diretório no caminho contém dois-pontos (:) ou está em um formato inválido.</exception>
        <exception cref="T:System.IO.PathTooLongException">O caminho excede o tamanho máximo definido pelo sistema.</exception>
        <exception cref="T:System.UnauthorizedAccessException">O usuário não tem a permissão necessária.</exception>
        <exception cref="T:System.Security.SecurityException">O usuário não tem as permissões necessárias para exibir o caminho.</exception>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">Controla a capacidade de acessar todas as variáveis de ambiente. Enumeração associada: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Controla a capacidade de acessar arquivos e pastas. Enumeração associada: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <permission cref="T:System.Security.Permissions.RegistryPermission">Controla a capacidade de acessar variáveis de Registro. Enumeração associada: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <altmember cref="T:Microsoft.VisualBasic.FileIO.UICancelOption" />
      </Docs>
    </Member>
    <Member MemberName="CopyFile">
      <MemberSignature Language="C#" Value="public static void CopyFile (string sourceFileName, string destinationFileName, Microsoft.VisualBasic.FileIO.UIOption showUI);" />
      <MemberSignature Language="ILAsm" Value=".method public static void CopyFile(string sourceFileName, string destinationFileName, valuetype Microsoft.VisualBasic.FileIO.UIOption showUI) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.CopyFile(System.String,System.String,Microsoft.VisualBasic.FileIO.UIOption)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub CopyFile (sourceFileName As String, destinationFileName As String, showUI As UIOption)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void CopyFile(System::String ^ sourceFileName, System::String ^ destinationFileName, Microsoft::VisualBasic::FileIO::UIOption showUI);" />
      <MemberSignature Language="F#" Value="static member CopyFile : string * string * Microsoft.VisualBasic.FileIO.UIOption -&gt; unit" Usage="Microsoft.VisualBasic.FileIO.FileSystem.CopyFile (sourceFileName, destinationFileName, showUI)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceFileName" Type="System.String" />
        <Parameter Name="destinationFileName" Type="System.String" />
        <Parameter Name="showUI" Type="Microsoft.VisualBasic.FileIO.UIOption" />
      </Parameters>
      <Docs>
        <param name="sourceFileName">O arquivo a ser copiado.</param>
        <param name="destinationFileName">O local para o qual o arquivo deve ser copiado.</param>
        <param name="showUI">Se o progresso da operação deve ser acompanhado visualmente. O padrão é <see langword="UIOption.OnlyErrorDialogs" />.</param>
        <summary>Copia um arquivo para um novo local.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `CopyFile` não preserva as ACEs (entradas de controle de acesso). O arquivo recém-criado herda ACEs padrão do diretório no qual ele é criado.  
  
 A tabela a seguir lista exemplos de tarefas que envolvem o `My.Computer.FileSystem.CopyFile` método.  
  
|Para|Consulte|  
|-|-|  
|Copie um arquivo no mesmo diretório.|[Como: criar uma cópia de um arquivo no mesmo diretório no Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-create-a-copy-of-a-file-in-the-same-directory.md)|  
|Copie um arquivo para um diretório diferente.|[Como: criar uma cópia de um arquivo em um diretório diferente no Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-create-a-copy-of-a-file-in-a-different-directory.md)|  
  
   
  
## Examples  
 Este exemplo copia o arquivo `Test.txt` para o diretório `TestFiles2` sem substituir arquivos existentes.  
  
 [!code-vb[VbRefFile#15](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#15)]  
  
 Substitua os caminhos de arquivo com os caminhos que você deseja usar em seu código.  
  
 Este exemplo copia o arquivo `Test.txt` para o diretório `TestFiles2` e o renomeia `NewFile.txt`.  
  
 [!code-vb[VbRefFile#16](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#16)]  
  
 Substitua os caminhos de arquivo com os caminhos que você deseja usar em seu código.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="destinationFileName" /> contém informações de caminho.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="destinationFileName" /> ou <paramref name="sourceFileName" /> é <see langword="Nothing" /> ou uma cadeia de caracteres vazia.</exception>
        <exception cref="T:System.IO.FileNotFoundException">O arquivo de origem não é válido ou não existe.</exception>
        <exception cref="T:System.IO.IOException">O arquivo de destino já existe e <paramref name="overwrite" /> é definido como <see langword="False" />.</exception>
        <exception cref="T:System.NotSupportedException">Um nome de arquivo ou de diretório no caminho contém dois-pontos (:) ou está em um formato inválido.</exception>
        <exception cref="T:System.IO.PathTooLongException">O caminho excede o tamanho máximo definido pelo sistema.</exception>
        <exception cref="T:System.UnauthorizedAccessException">O usuário não tem a permissão necessária.</exception>
        <exception cref="T:System.Security.SecurityException">O usuário não tem as permissões necessárias para exibir o caminho.</exception>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">Controla a capacidade de acessar todas as variáveis de ambiente. Enumeração associada: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Controla a capacidade de acessar arquivos e pastas. Enumeração associada: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <permission cref="T:System.Security.Permissions.RegistryPermission">Controla a capacidade de acessar variáveis de Registro. Enumeração associada: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <permission cref="T:System.Security.Permissions.UIPermission">Controla as permissões relacionadas às interfaces de usuário e a área de transferência. Enumeração associada: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeSubWindows" />.</permission>
        <altmember cref="T:Microsoft.VisualBasic.FileIO.UICancelOption" />
      </Docs>
    </Member>
    <Member MemberName="CopyFile">
      <MemberSignature Language="C#" Value="public static void CopyFile (string sourceFileName, string destinationFileName, bool overwrite);" />
      <MemberSignature Language="ILAsm" Value=".method public static void CopyFile(string sourceFileName, string destinationFileName, bool overwrite) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.CopyFile(System.String,System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub CopyFile (sourceFileName As String, destinationFileName As String, overwrite As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void CopyFile(System::String ^ sourceFileName, System::String ^ destinationFileName, bool overwrite);" />
      <MemberSignature Language="F#" Value="static member CopyFile : string * string * bool -&gt; unit" Usage="Microsoft.VisualBasic.FileIO.FileSystem.CopyFile (sourceFileName, destinationFileName, overwrite)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceFileName" Type="System.String" />
        <Parameter Name="destinationFileName" Type="System.String" />
        <Parameter Name="overwrite" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="sourceFileName">O arquivo a ser copiado.</param>
        <param name="destinationFileName">O local para o qual o arquivo deve ser copiado.</param>
        <param name="overwrite">
          <see langword="True" /> se os arquivos existentes devem ser substituídos; caso contrário, <see langword="False" />. O padrão é <see langword="False" />.</param>
        <summary>Copia um arquivo para um novo local.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `CopyFile` não preserva as ACEs (entradas de controle de acesso). O arquivo recém-criado herda ACEs padrão do diretório no qual ele é criado.  
  
 A tabela a seguir lista exemplos de tarefas que envolvem o `My.Computer.FileSystem.CopyFile` método.  
  
|Para|Consulte|  
|-|-|  
|Copie um arquivo no mesmo diretório.|[Como: criar uma cópia de um arquivo no mesmo diretório no Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-create-a-copy-of-a-file-in-the-same-directory.md)|  
|Copie um arquivo para um diretório diferente.|[Como: criar uma cópia de um arquivo em um diretório diferente no Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-create-a-copy-of-a-file-in-a-different-directory.md)|  
  
   
  
## Examples  
 Este exemplo copia o arquivo `Test.txt` para o diretório `TestFiles2` sem substituir arquivos existentes.  
  
 [!code-vb[VbRefFile#15](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#15)]  
  
 Substitua os caminhos de arquivo com os caminhos que você deseja usar em seu código.  
  
 Este exemplo copia o arquivo `Test.txt` para o diretório `TestFiles2` e o renomeia `NewFile.txt`.  
  
 [!code-vb[VbRefFile#16](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#16)]  
  
 Substitua os caminhos de arquivo com os caminhos que você deseja usar em seu código.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="destinationFileName" /> contém informações de caminho.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="destinationFileName" /> ou <paramref name="sourceFileName" /> é <see langword="Nothing" /> ou uma cadeia de caracteres vazia.</exception>
        <exception cref="T:System.IO.FileNotFoundException">O arquivo de origem não é válido ou não existe.</exception>
        <exception cref="T:System.IO.IOException">O arquivo de destino já existe e <paramref name="overwrite" /> é definido como <see langword="False" />.</exception>
        <exception cref="T:System.NotSupportedException">Um nome de arquivo ou de diretório no caminho contém dois-pontos (:) ou está em um formato inválido.</exception>
        <exception cref="T:System.IO.PathTooLongException">O caminho excede o tamanho máximo definido pelo sistema.</exception>
        <exception cref="T:System.UnauthorizedAccessException">O usuário não tem a permissão necessária.</exception>
        <exception cref="T:System.Security.SecurityException">O usuário não tem as permissões necessárias para exibir o caminho.</exception>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">Controla a capacidade de acessar todas as variáveis de ambiente. Enumeração associada: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Controla a capacidade de acessar arquivos e pastas. Enumeração associada: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <permission cref="T:System.Security.Permissions.RegistryPermission">Controla a capacidade de acessar variáveis de Registro. Enumeração associada: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <altmember cref="T:Microsoft.VisualBasic.FileIO.UICancelOption" />
      </Docs>
    </Member>
    <Member MemberName="CopyFile">
      <MemberSignature Language="C#" Value="public static void CopyFile (string sourceFileName, string destinationFileName, Microsoft.VisualBasic.FileIO.UIOption showUI, Microsoft.VisualBasic.FileIO.UICancelOption onUserCancel);" />
      <MemberSignature Language="ILAsm" Value=".method public static void CopyFile(string sourceFileName, string destinationFileName, valuetype Microsoft.VisualBasic.FileIO.UIOption showUI, valuetype Microsoft.VisualBasic.FileIO.UICancelOption onUserCancel) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.CopyFile(System.String,System.String,Microsoft.VisualBasic.FileIO.UIOption,Microsoft.VisualBasic.FileIO.UICancelOption)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub CopyFile (sourceFileName As String, destinationFileName As String, showUI As UIOption, onUserCancel As UICancelOption)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void CopyFile(System::String ^ sourceFileName, System::String ^ destinationFileName, Microsoft::VisualBasic::FileIO::UIOption showUI, Microsoft::VisualBasic::FileIO::UICancelOption onUserCancel);" />
      <MemberSignature Language="F#" Value="static member CopyFile : string * string * Microsoft.VisualBasic.FileIO.UIOption * Microsoft.VisualBasic.FileIO.UICancelOption -&gt; unit" Usage="Microsoft.VisualBasic.FileIO.FileSystem.CopyFile (sourceFileName, destinationFileName, showUI, onUserCancel)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceFileName" Type="System.String" />
        <Parameter Name="destinationFileName" Type="System.String" />
        <Parameter Name="showUI" Type="Microsoft.VisualBasic.FileIO.UIOption" />
        <Parameter Name="onUserCancel" Type="Microsoft.VisualBasic.FileIO.UICancelOption" />
      </Parameters>
      <Docs>
        <param name="sourceFileName">O arquivo a ser copiado.</param>
        <param name="destinationFileName">O local para o qual o arquivo deve ser copiado.</param>
        <param name="showUI">Se o progresso da operação deve ser acompanhado visualmente. O padrão é <see langword="UIOption.OnlyErrorDialogs" />.</param>
        <param name="onUserCancel">Especifica o que deverá ser feito, se o usuário clicar em **Cancelar** durante a operação. O padrão é <see cref="F:Microsoft.VisualBasic.FileIO.UICancelOption.ThrowException" />.</param>
        <summary>Copia um arquivo para um novo local.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `CopyFile` não preserva as ACEs (entradas de controle de acesso). O arquivo recém-criado herda ACEs padrão do diretório no qual ele é criado.  
  
 A tabela a seguir lista exemplos de tarefas que envolvem o `My.Computer.FileSystem.CopyFile` método.  
  
|Para|Consulte|  
|-|-|  
|Copie um arquivo no mesmo diretório.|[Como: criar uma cópia de um arquivo no mesmo diretório no Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-create-a-copy-of-a-file-in-the-same-directory.md)|  
|Copie um arquivo para um diretório diferente.|[Como: criar uma cópia de um arquivo em um diretório diferente no Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-create-a-copy-of-a-file-in-a-different-directory.md)|  
  
   
  
## Examples  
 Este exemplo copia o arquivo `Test.txt` para o diretório `TestFiles2` sem substituir arquivos existentes.  
  
 [!code-vb[VbRefFile#15](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#15)]  
  
 Substitua os caminhos de arquivo com os caminhos que você deseja usar em seu código.  
  
 Este exemplo copia o arquivo `Test.txt` para o diretório `TestFiles2` e o renomeia `NewFile.txt`.  
  
 [!code-vb[VbRefFile#16](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#16)]  
  
 Substitua os caminhos de arquivo com os caminhos que você deseja usar em seu código.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="destinationFileName" /> contém informações de caminho.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="destinationFileName" /> ou <paramref name="sourceFileName" /> é <see langword="Nothing" /> ou uma cadeia de caracteres vazia.</exception>
        <exception cref="T:System.IO.FileNotFoundException">O arquivo de origem não é válido ou não existe.</exception>
        <exception cref="T:System.IO.IOException">O arquivo de destino já existe e <paramref name="overwrite" /> é definido como <see langword="False" />.</exception>
        <exception cref="T:System.NotSupportedException">Um nome de arquivo ou de diretório no caminho contém dois-pontos (:) ou está em um formato inválido.</exception>
        <exception cref="T:System.IO.PathTooLongException">O caminho excede o tamanho máximo definido pelo sistema.</exception>
        <exception cref="T:System.UnauthorizedAccessException">O usuário não tem a permissão necessária.</exception>
        <exception cref="T:System.Security.SecurityException">O usuário não tem as permissões necessárias para exibir o caminho.</exception>
        <exception cref="T:System.OperationCanceledException">
          <paramref name="UICancelOption" /> é definido como <see langword="ThrowException" /> e o usuário cancelou a operação ou ocorre um erro de E/S não especificado.</exception>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">Controla a capacidade de acessar todas as variáveis de ambiente. Enumeração associada: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Controla a capacidade de acessar arquivos e pastas. Enumeração associada: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <permission cref="T:System.Security.Permissions.RegistryPermission">Controla a capacidade de acessar variáveis de Registro. Enumeração associada: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <permission cref="T:System.Security.Permissions.UIPermission">Controla as permissões relacionadas às interfaces de usuário e a área de transferência. Enumeração associada: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeSubWindows" />.</permission>
        <altmember cref="T:Microsoft.VisualBasic.FileIO.UICancelOption" />
      </Docs>
    </Member>
    <Member MemberName="CreateDirectory">
      <MemberSignature Language="C#" Value="public static void CreateDirectory (string directory);" />
      <MemberSignature Language="ILAsm" Value=".method public static void CreateDirectory(string directory) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.CreateDirectory(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub CreateDirectory (directory As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void CreateDirectory(System::String ^ directory);" />
      <MemberSignature Language="F#" Value="static member CreateDirectory : string -&gt; unit" Usage="Microsoft.VisualBasic.FileIO.FileSystem.CreateDirectory directory" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="directory" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="directory">Nome e local do diretório.</param>
        <summary>Cria um diretório.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se o diretório já existir, nenhuma exceção será lançada.  
  
 A tabela a seguir lista um exemplo de uma tarefa que envolvem o `My.Computer.FileSystem.CreateDirectory` método.  
  
|Para|Consulte|  
|-|-|  
|Criar um diretório|[Como: criar um diretório no Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-create-a-directory.md)|  
  
   
  
## Examples  
 Este exemplo cria o diretório `NewDirectory`, no `C:\Documents and Settings\All Users\Documents`.  
  
 [!code-vb[VbVbcnMyFileSystem#17](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#17)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">O nome do diretório está malformado. Por exemplo, ele contém caracteres inválidos ou é somente um espaço em branco.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="directory" /> é <see langword="Nothing" /> ou é uma cadeia de caracteres vazia.</exception>
        <exception cref="T:System.IO.PathTooLongException">O nome do diretório é muito longo.</exception>
        <exception cref="T:System.NotSupportedException">O nome do diretório é apenas um dois-pontos (:).</exception>
        <exception cref="T:System.IO.IOException">O diretório pai do diretório a ser criado é somente leitura</exception>
        <exception cref="T:System.UnauthorizedAccessException">O usuário não tem permissão para criar o diretório.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Controla a capacidade de acessar arquivos e pastas. Enumeração associada: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <altmember cref="M:System.IO.Directory.CreateDirectory(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="CurrentDirectory">
      <MemberSignature Language="C#" Value="public static string CurrentDirectory { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property string CurrentDirectory" />
      <MemberSignature Language="DocId" Value="P:Microsoft.VisualBasic.FileIO.FileSystem.CurrentDirectory" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property CurrentDirectory As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::String ^ CurrentDirectory { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.CurrentDirectory : string with get, set" Usage="Microsoft.VisualBasic.FileIO.FileSystem.CurrentDirectory" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define o diretório atual.</summary>
        <value>O diretório atual para operações de E/S de arquivo.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `CurrentDirectory` é uma variável de ambiente de todo o sistema.  
  
   
  
## Examples  
 Este exemplo retorna o diretório atual e o exibe em uma caixa de mensagem.  
  
 [!code-vb[VbVbcnMyFileSystem#18](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#18)]  
  
 Este exemplo define o diretório atual para `C:\TestDirectory`.  
  
 [!code-vb[VbVbcnMyFileSystem#19](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#19)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.DirectoryNotFoundException">O caminho não é válido.</exception>
        <exception cref="T:System.UnauthorizedAccessException">O usuário não tem as permissões necessárias.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Controla a capacidade de acessar arquivos e pastas. Enumeração associada: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="DeleteDirectory">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Exclui um diretório.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="DeleteDirectory">
      <MemberSignature Language="C#" Value="public static void DeleteDirectory (string directory, Microsoft.VisualBasic.FileIO.DeleteDirectoryOption onDirectoryNotEmpty);" />
      <MemberSignature Language="ILAsm" Value=".method public static void DeleteDirectory(string directory, valuetype Microsoft.VisualBasic.FileIO.DeleteDirectoryOption onDirectoryNotEmpty) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.DeleteDirectory(System.String,Microsoft.VisualBasic.FileIO.DeleteDirectoryOption)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub DeleteDirectory (directory As String, onDirectoryNotEmpty As DeleteDirectoryOption)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void DeleteDirectory(System::String ^ directory, Microsoft::VisualBasic::FileIO::DeleteDirectoryOption onDirectoryNotEmpty);" />
      <MemberSignature Language="F#" Value="static member DeleteDirectory : string * Microsoft.VisualBasic.FileIO.DeleteDirectoryOption -&gt; unit" Usage="Microsoft.VisualBasic.FileIO.FileSystem.DeleteDirectory (directory, onDirectoryNotEmpty)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="directory" Type="System.String" />
        <Parameter Name="onDirectoryNotEmpty" Type="Microsoft.VisualBasic.FileIO.DeleteDirectoryOption" />
      </Parameters>
      <Docs>
        <param name="directory">O diretório a ser excluído.</param>
        <param name="onDirectoryNotEmpty">Especifica o que deve ser feito quando um diretório que deve ser excluído contém arquivos ou diretórios. O padrão é <see langword="DeleteDirectoryOption.DeleteAllContents" />.</param>
        <summary>Exclui um diretório.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O exemplo exclui o diretório `OldDirectory` somente se ele estiver vazio.  
  
 [!code-vb[VbVbcnMyFileSystem#56](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#56)]  
  
 Este exemplo exclui o diretório `OldDirectory` e todo seu conteúdo.  
  
 [!code-vb[VbVbcnMyFileSystem#57](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#57)]  
  
 Este exemplo exclui o diretório `OldDirectory` e todo seu conteúdo, solicitando que o usuário confirme a exclusão, mas não envia o conteúdo para o **Lixeira**.  
  
 [!code-vb[VbVbcnMyFileSystem#58](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#58)]  
  
 Este exemplo exclui o diretório `OldDirectory` e todo seu conteúdo, enviá-los para o **Lixeira**, mas não mostra o progresso da operação.  
  
 [!code-vb[VbVbcnMyFileSystem#59](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#59)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">O caminho é uma cadeia de caracteres de tamanho zero, está malformado, contém somente espaços em branco ou caracteres inválidos (incluindo caracteres curinga). O caminho é um caminho de dispositivo (começa com \\\\.\\).</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="directory" /> é <see langword="Nothing" /> ou é uma cadeia de caracteres vazia.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">O diretório não existe ou é um arquivo.</exception>
        <exception cref="T:System.IO.IOException">Um arquivo do diretório ou subdiretório está em uso.</exception>
        <exception cref="T:System.NotSupportedException">O nome do diretório contém dois-pontos (:).</exception>
        <exception cref="T:System.IO.PathTooLongException">O caminho excede o tamanho máximo definido pelo sistema.</exception>
        <exception cref="T:System.Security.SecurityException">O usuário não tem as permissões necessárias.</exception>
        <exception cref="T:System.OperationCanceledException">O usuário cancelou a operação ou o diretório não pode ser excluído.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Controla a capacidade de acessar arquivos e pastas. Enumeração associada: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <altmember cref="T:Microsoft.VisualBasic.FileIO.DeleteDirectoryOption" />
      </Docs>
    </Member>
    <Member MemberName="DeleteDirectory">
      <MemberSignature Language="C#" Value="public static void DeleteDirectory (string directory, Microsoft.VisualBasic.FileIO.UIOption showUI, Microsoft.VisualBasic.FileIO.RecycleOption recycle);" />
      <MemberSignature Language="ILAsm" Value=".method public static void DeleteDirectory(string directory, valuetype Microsoft.VisualBasic.FileIO.UIOption showUI, valuetype Microsoft.VisualBasic.FileIO.RecycleOption recycle) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.DeleteDirectory(System.String,Microsoft.VisualBasic.FileIO.UIOption,Microsoft.VisualBasic.FileIO.RecycleOption)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub DeleteDirectory (directory As String, showUI As UIOption, recycle As RecycleOption)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void DeleteDirectory(System::String ^ directory, Microsoft::VisualBasic::FileIO::UIOption showUI, Microsoft::VisualBasic::FileIO::RecycleOption recycle);" />
      <MemberSignature Language="F#" Value="static member DeleteDirectory : string * Microsoft.VisualBasic.FileIO.UIOption * Microsoft.VisualBasic.FileIO.RecycleOption -&gt; unit" Usage="Microsoft.VisualBasic.FileIO.FileSystem.DeleteDirectory (directory, showUI, recycle)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="directory" Type="System.String" />
        <Parameter Name="showUI" Type="Microsoft.VisualBasic.FileIO.UIOption" />
        <Parameter Name="recycle" Type="Microsoft.VisualBasic.FileIO.RecycleOption" />
      </Parameters>
      <Docs>
        <param name="directory">O diretório a ser excluído.</param>
        <param name="showUI">Especifica se o progresso da operação deve ser acompanhado visualmente. O padrão é <see langword="UIOption.OnlyErrorDialogs" />.</param>
        <param name="recycle">Especifica se o arquivo excluído deve ou não ser enviado para a **Lixeira**. O padrão é <see langword="RecycleOption.DeletePermanently" />.</param>
        <summary>Exclui um diretório.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O `showUI` e `recycle` parâmetros não têm suporte em aplicativos que não são interativo, como os serviços do Windows do usuário.  
  
   
  
## Examples  
 O exemplo exclui o diretório `OldDirectory` somente se ele estiver vazio.  
  
 [!code-vb[VbVbcnMyFileSystem#56](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#56)]  
  
 Este exemplo exclui o diretório `OldDirectory` e todo seu conteúdo.  
  
 [!code-vb[VbVbcnMyFileSystem#57](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#57)]  
  
 Este exemplo exclui o diretório `OldDirectory` e todo seu conteúdo, solicitando que o usuário confirme a exclusão, mas não envia o conteúdo para o **Lixeira**.  
  
 [!code-vb[VbVbcnMyFileSystem#58](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#58)]  
  
 Este exemplo exclui o diretório `OldDirectory` e todo seu conteúdo, enviá-los para o **Lixeira**, mas não mostra o progresso da operação.  
  
 [!code-vb[VbVbcnMyFileSystem#59](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#59)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">O caminho é uma cadeia de caracteres de tamanho zero, está malformado, contém somente espaços em branco ou caracteres inválidos (incluindo caracteres curinga). O caminho é um caminho de dispositivo (começa com \\\\.\\).</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="directory" /> é <see langword="Nothing" /> ou é uma cadeia de caracteres vazia.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">O diretório não existe ou é um arquivo.</exception>
        <exception cref="T:System.IO.IOException">Um arquivo do diretório ou subdiretório está em uso.</exception>
        <exception cref="T:System.NotSupportedException">O nome do diretório contém dois-pontos (:).</exception>
        <exception cref="T:System.IO.PathTooLongException">O caminho excede o tamanho máximo definido pelo sistema.</exception>
        <exception cref="T:System.Security.SecurityException">O usuário não tem as permissões necessárias.</exception>
        <exception cref="T:System.OperationCanceledException">O usuário cancelou a operação ou o diretório não pode ser excluído.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Controla a capacidade de acessar arquivos e pastas. Enumeração associada: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <permission cref="T:System.Security.Permissions.UIPermission">Controla as permissões relacionadas às interfaces de usuário e a área de transferência. Enumeração associada: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeSubWindows" />.</permission>
        <altmember cref="T:Microsoft.VisualBasic.FileIO.RecycleOption" />
        <altmember cref="T:Microsoft.VisualBasic.FileIO.UIOption" />
      </Docs>
    </Member>
    <Member MemberName="DeleteDirectory">
      <MemberSignature Language="C#" Value="public static void DeleteDirectory (string directory, Microsoft.VisualBasic.FileIO.UIOption showUI, Microsoft.VisualBasic.FileIO.RecycleOption recycle, Microsoft.VisualBasic.FileIO.UICancelOption onUserCancel);" />
      <MemberSignature Language="ILAsm" Value=".method public static void DeleteDirectory(string directory, valuetype Microsoft.VisualBasic.FileIO.UIOption showUI, valuetype Microsoft.VisualBasic.FileIO.RecycleOption recycle, valuetype Microsoft.VisualBasic.FileIO.UICancelOption onUserCancel) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.DeleteDirectory(System.String,Microsoft.VisualBasic.FileIO.UIOption,Microsoft.VisualBasic.FileIO.RecycleOption,Microsoft.VisualBasic.FileIO.UICancelOption)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub DeleteDirectory (directory As String, showUI As UIOption, recycle As RecycleOption, onUserCancel As UICancelOption)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void DeleteDirectory(System::String ^ directory, Microsoft::VisualBasic::FileIO::UIOption showUI, Microsoft::VisualBasic::FileIO::RecycleOption recycle, Microsoft::VisualBasic::FileIO::UICancelOption onUserCancel);" />
      <MemberSignature Language="F#" Value="static member DeleteDirectory : string * Microsoft.VisualBasic.FileIO.UIOption * Microsoft.VisualBasic.FileIO.RecycleOption * Microsoft.VisualBasic.FileIO.UICancelOption -&gt; unit" Usage="Microsoft.VisualBasic.FileIO.FileSystem.DeleteDirectory (directory, showUI, recycle, onUserCancel)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="directory" Type="System.String" />
        <Parameter Name="showUI" Type="Microsoft.VisualBasic.FileIO.UIOption" />
        <Parameter Name="recycle" Type="Microsoft.VisualBasic.FileIO.RecycleOption" />
        <Parameter Name="onUserCancel" Type="Microsoft.VisualBasic.FileIO.UICancelOption" />
      </Parameters>
      <Docs>
        <param name="directory">O diretório a ser excluído.</param>
        <param name="showUI">Especifica se o progresso da operação deve ser acompanhado visualmente. O padrão é <see langword="UIOption.OnlyErrorDialogs" />.</param>
        <param name="recycle">Especifica se o arquivo excluído deve ou não ser enviado para a **Lixeira**. O padrão é <see langword="RecycleOption.DeletePermanently" />.</param>
        <param name="onUserCancel">Especifica se deve gerar uma exceção se o usuário clicar em **Cancelar**.</param>
        <summary>Exclui um diretório.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O `showUI`, `recycle`, e `onUserCancel` parâmetros não têm suporte em aplicativos que não são interativo, como os serviços do Windows do usuário.  
  
   
  
## Examples  
 O exemplo exclui o diretório `OldDirectory` somente se ele estiver vazio.  
  
 [!code-vb[VbVbcnMyFileSystem#56](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#56)]  
  
 Este exemplo exclui o diretório `OldDirectory` e todo seu conteúdo.  
  
 [!code-vb[VbVbcnMyFileSystem#57](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#57)]  
  
 Este exemplo exclui o diretório `OldDirectory` e todo seu conteúdo, solicitando que o usuário confirme a exclusão, mas não envia o conteúdo para o **Lixeira**.  
  
 [!code-vb[VbVbcnMyFileSystem#58](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#58)]  
  
 Este exemplo exclui o diretório `OldDirectory` e todo seu conteúdo, enviá-los para o **Lixeira**, mas não mostra o progresso da operação.  
  
 [!code-vb[VbVbcnMyFileSystem#59](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#59)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">O caminho é uma cadeia de caracteres de tamanho zero, está malformado, contém somente espaços em branco ou caracteres inválidos (incluindo caracteres curinga). O caminho é um caminho de dispositivo (começa com \\\\.\\).</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="directory" /> é <see langword="Nothing" /> ou é uma cadeia de caracteres vazia.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">O diretório não existe ou é um arquivo.</exception>
        <exception cref="T:System.IO.IOException">Um arquivo do diretório ou subdiretório está em uso.</exception>
        <exception cref="T:System.NotSupportedException">O nome do diretório contém dois-pontos (:).</exception>
        <exception cref="T:System.IO.PathTooLongException">O caminho excede o tamanho máximo definido pelo sistema.</exception>
        <exception cref="T:System.Security.SecurityException">O usuário não tem as permissões necessárias.</exception>
        <exception cref="T:System.OperationCanceledException">O usuário cancelou a operação ou o diretório não pode ser excluído.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Controla a capacidade de acessar arquivos e pastas. Enumeração associada: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <permission cref="T:System.Security.Permissions.UIPermission">Controla as permissões relacionadas às interfaces de usuário e a área de transferência. Enumeração associada: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeSubWindows" />.</permission>
        <altmember cref="T:Microsoft.VisualBasic.FileIO.UICancelOption" />
        <altmember cref="T:Microsoft.VisualBasic.FileIO.RecycleOption" />
        <altmember cref="T:Microsoft.VisualBasic.FileIO.UIOption" />
      </Docs>
    </Member>
    <MemberGroup MemberName="DeleteFile">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Exclui um arquivo.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="DeleteFile">
      <MemberSignature Language="C#" Value="public static void DeleteFile (string file);" />
      <MemberSignature Language="ILAsm" Value=".method public static void DeleteFile(string file) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.DeleteFile(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub DeleteFile (file As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void DeleteFile(System::String ^ file);" />
      <MemberSignature Language="F#" Value="static member DeleteFile : string -&gt; unit" Usage="Microsoft.VisualBasic.FileIO.FileSystem.DeleteFile file" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="file" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="file">O nome e o caminho do arquivo a ser excluído.</param>
        <summary>Exclui um arquivo.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista um exemplo de uma tarefa que envolvem o `My.Computer.FileSystem.DeleteFile` método.  
  
|Para|Consulte|  
|-|-|  
|Para excluir um arquivo|[Como: excluir um arquivo no Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-delete-a-file.md)|  
  
   
  
## Examples  
 Este exemplo exclui o arquivo `Test.txt`.  
  
 [!code-vb[VbVbcnMyFileSystem#3](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#3)]  
  
 Este exemplo exclui o arquivo `Test.txt` e permite que o usuário confirme se o arquivo deve ser excluído.  
  
 [!code-vb[VbVbcnMyFileSystem#4](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#4)]  
  
 Este exemplo exclui o arquivo `Test.txt` e o envia para o **Lixeira**.  
  
 [!code-vb[VbVbcnMyFileSystem#5](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">O caminho não é válido por um dos seguintes motivos: é uma cadeia de caracteres de tamanho zero, contém somente espaço em branco, contém caracteres inválidos, tem uma barra à direita na qual um arquivo deve ser especificado ou é um caminho de dispositivo (começa com \\\\.\\).</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="file" /> é <see langword="Nothing" /> ou é uma cadeia de caracteres vazia.</exception>
        <exception cref="T:System.IO.PathTooLongException">O caminho excede o tamanho máximo definido pelo sistema.</exception>
        <exception cref="T:System.NotSupportedException">Um nome de arquivo ou de diretório no caminho contém dois-pontos (:) ou está em um formato inválido.</exception>
        <exception cref="T:System.IO.IOException">O arquivo está em uso.</exception>
        <exception cref="T:System.Security.SecurityException">O usuário não tem as permissões necessárias para exibir o caminho.</exception>
        <exception cref="T:System.IO.FileNotFoundException">O arquivo não existe.</exception>
        <exception cref="T:System.UnauthorizedAccessException">O usuário não tem permissão para excluir o arquivo ou o arquivo é somente leitura.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Controla a capacidade de acessar arquivos e pastas. Enumeração associada: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="DeleteFile">
      <MemberSignature Language="C#" Value="public static void DeleteFile (string file, Microsoft.VisualBasic.FileIO.UIOption showUI, Microsoft.VisualBasic.FileIO.RecycleOption recycle);" />
      <MemberSignature Language="ILAsm" Value=".method public static void DeleteFile(string file, valuetype Microsoft.VisualBasic.FileIO.UIOption showUI, valuetype Microsoft.VisualBasic.FileIO.RecycleOption recycle) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.DeleteFile(System.String,Microsoft.VisualBasic.FileIO.UIOption,Microsoft.VisualBasic.FileIO.RecycleOption)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub DeleteFile (file As String, showUI As UIOption, recycle As RecycleOption)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void DeleteFile(System::String ^ file, Microsoft::VisualBasic::FileIO::UIOption showUI, Microsoft::VisualBasic::FileIO::RecycleOption recycle);" />
      <MemberSignature Language="F#" Value="static member DeleteFile : string * Microsoft.VisualBasic.FileIO.UIOption * Microsoft.VisualBasic.FileIO.RecycleOption -&gt; unit" Usage="Microsoft.VisualBasic.FileIO.FileSystem.DeleteFile (file, showUI, recycle)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="file" Type="System.String" />
        <Parameter Name="showUI" Type="Microsoft.VisualBasic.FileIO.UIOption" />
        <Parameter Name="recycle" Type="Microsoft.VisualBasic.FileIO.RecycleOption" />
      </Parameters>
      <Docs>
        <param name="file">O nome e o caminho do arquivo a ser excluído.</param>
        <param name="showUI">Se o progresso da operação deve ser acompanhado visualmente. O padrão é <see langword="UIOption.OnlyErrorDialogs" />.</param>
        <param name="recycle">Se o arquivo excluído deve ou não ser enviado para a **Lixeira**. O padrão é <see langword="RecycleOption.DeletePermanently" />.</param>
        <summary>Exclui um arquivo.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O `showUI` e `recycle` parâmetros não têm suporte em aplicativos que não são interativo, como os serviços do Windows do usuário.  
  
 A tabela a seguir lista um exemplo de uma tarefa que envolvem o `My.Computer.FileSystem.DeleteFile` método.  
  
|Para|Consulte|  
|-|-|  
|Para excluir um arquivo|[Como: excluir um arquivo no Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-delete-a-file.md)|  
  
   
  
## Examples  
 Este exemplo exclui o arquivo `Test.txt`.  
  
 [!code-vb[VbVbcnMyFileSystem#3](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#3)]  
  
 Este exemplo exclui o arquivo `Test.txt` e permite que o usuário confirme se o arquivo deve ser excluído.  
  
 [!code-vb[VbVbcnMyFileSystem#4](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#4)]  
  
 Este exemplo exclui o arquivo `Test.txt` e o envia para o **Lixeira**.  
  
 [!code-vb[VbVbcnMyFileSystem#5](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">O caminho não é válido por um dos seguintes motivos: é uma cadeia de caracteres de tamanho zero, contém somente espaço em branco, contém caracteres inválidos, tem uma barra à direita na qual um arquivo deve ser especificado ou é um caminho de dispositivo (começa com \\\\.\\).</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="file" /> é <see langword="Nothing" /> ou é uma cadeia de caracteres vazia.</exception>
        <exception cref="T:System.IO.PathTooLongException">O caminho excede o tamanho máximo definido pelo sistema.</exception>
        <exception cref="T:System.NotSupportedException">Um nome de arquivo ou de diretório no caminho contém dois-pontos (:) ou está em um formato inválido.</exception>
        <exception cref="T:System.IO.IOException">O arquivo está em uso.</exception>
        <exception cref="T:System.Security.SecurityException">O usuário não tem as permissões necessárias para exibir o caminho.</exception>
        <exception cref="T:System.IO.FileNotFoundException">O arquivo não existe.</exception>
        <exception cref="T:System.UnauthorizedAccessException">O usuário não tem permissão para excluir o arquivo ou o arquivo é somente leitura.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Controla a capacidade de acessar arquivos e pastas. Enumeração associada: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <permission cref="T:System.Security.Permissions.UIPermission">Controla as permissões relacionadas às interfaces de usuário e a área de transferência. Enumeração associada: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeSubWindows" />.</permission>
        <altmember cref="T:Microsoft.VisualBasic.FileIO.RecycleOption" />
        <altmember cref="T:Microsoft.VisualBasic.FileIO.UIOption" />
      </Docs>
    </Member>
    <Member MemberName="DeleteFile">
      <MemberSignature Language="C#" Value="public static void DeleteFile (string file, Microsoft.VisualBasic.FileIO.UIOption showUI, Microsoft.VisualBasic.FileIO.RecycleOption recycle, Microsoft.VisualBasic.FileIO.UICancelOption onUserCancel);" />
      <MemberSignature Language="ILAsm" Value=".method public static void DeleteFile(string file, valuetype Microsoft.VisualBasic.FileIO.UIOption showUI, valuetype Microsoft.VisualBasic.FileIO.RecycleOption recycle, valuetype Microsoft.VisualBasic.FileIO.UICancelOption onUserCancel) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.DeleteFile(System.String,Microsoft.VisualBasic.FileIO.UIOption,Microsoft.VisualBasic.FileIO.RecycleOption,Microsoft.VisualBasic.FileIO.UICancelOption)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub DeleteFile (file As String, showUI As UIOption, recycle As RecycleOption, onUserCancel As UICancelOption)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void DeleteFile(System::String ^ file, Microsoft::VisualBasic::FileIO::UIOption showUI, Microsoft::VisualBasic::FileIO::RecycleOption recycle, Microsoft::VisualBasic::FileIO::UICancelOption onUserCancel);" />
      <MemberSignature Language="F#" Value="static member DeleteFile : string * Microsoft.VisualBasic.FileIO.UIOption * Microsoft.VisualBasic.FileIO.RecycleOption * Microsoft.VisualBasic.FileIO.UICancelOption -&gt; unit" Usage="Microsoft.VisualBasic.FileIO.FileSystem.DeleteFile (file, showUI, recycle, onUserCancel)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="file" Type="System.String" />
        <Parameter Name="showUI" Type="Microsoft.VisualBasic.FileIO.UIOption" />
        <Parameter Name="recycle" Type="Microsoft.VisualBasic.FileIO.RecycleOption" />
        <Parameter Name="onUserCancel" Type="Microsoft.VisualBasic.FileIO.UICancelOption" />
      </Parameters>
      <Docs>
        <param name="file">O nome e o caminho do arquivo a ser excluído.</param>
        <param name="showUI">Se o progresso da operação deve ser acompanhado visualmente. O padrão é <see langword="UIOption.OnlyErrorDialogs" />.</param>
        <param name="recycle">Se o arquivo excluído deve ou não ser enviado para a **Lixeira**. O padrão é <see langword="RecycleOption.DeletePermanently" />.</param>
        <param name="onUserCancel">Especifica se uma exceção é lançada ou não quando o usuário cancela a operação. O padrão é <see langword="UICancelOption.ThrowException" />.</param>
        <summary>Exclui um arquivo.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O `showUI`, `recycle`, e `onUserCancel` parâmetros não têm suporte em aplicativos que não são interativo, como os serviços do Windows do usuário.  
  
 A tabela a seguir lista um exemplo de uma tarefa que envolvem o `My.Computer.FileSystem.DeleteFile` método.  
  
|Para|Consulte|  
|-|-|  
|Para excluir um arquivo|[Como: excluir um arquivo no Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-delete-a-file.md)|  
  
   
  
## Examples  
 Este exemplo exclui o arquivo `Test.txt`.  
  
 [!code-vb[VbVbcnMyFileSystem#3](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#3)]  
  
 Este exemplo exclui o arquivo `Test.txt` e permite que o usuário confirme se o arquivo deve ser excluído.  
  
 [!code-vb[VbVbcnMyFileSystem#4](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#4)]  
  
 Este exemplo exclui o arquivo `Test.txt` e o envia para o **Lixeira**.  
  
 [!code-vb[VbVbcnMyFileSystem#5](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">O caminho não é válido por um dos seguintes motivos: é uma cadeia de caracteres de tamanho zero, contém somente espaço em branco, contém caracteres inválidos, tem uma barra à direita na qual um arquivo deve ser especificado ou é um caminho de dispositivo (começa com \\\\.\\).</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="file" /> é <see langword="Nothing" /> ou é uma cadeia de caracteres vazia.</exception>
        <exception cref="T:System.IO.PathTooLongException">O caminho excede o tamanho máximo definido pelo sistema.</exception>
        <exception cref="T:System.NotSupportedException">Um nome de arquivo ou de diretório no caminho contém dois-pontos (:) ou está em um formato inválido.</exception>
        <exception cref="T:System.IO.IOException">O arquivo está em uso.</exception>
        <exception cref="T:System.Security.SecurityException">O usuário não tem as permissões necessárias para exibir o caminho.</exception>
        <exception cref="T:System.IO.FileNotFoundException">O arquivo não existe.</exception>
        <exception cref="T:System.UnauthorizedAccessException">O usuário não tem permissão para excluir o arquivo ou o arquivo é somente leitura.</exception>
        <exception cref="T:System.OperationCanceledException">O usuário cancelou a operação e <paramref name="onUserCancel" /> está definido para <see cref="F:Microsoft.VisualBasic.FileIO.UICancelOption.ThrowException" />.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Controla a capacidade de acessar arquivos e pastas. Enumeração associada: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <permission cref="T:System.Security.Permissions.UIPermission">Controla as permissões relacionadas às interfaces de usuário e a área de transferência. Enumeração associada: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeSubWindows" />.</permission>
        <altmember cref="T:Microsoft.VisualBasic.FileIO.UICancelOption" />
        <altmember cref="T:Microsoft.VisualBasic.FileIO.RecycleOption" />
        <altmember cref="T:Microsoft.VisualBasic.FileIO.UIOption" />
      </Docs>
    </Member>
    <Member MemberName="DirectoryExists">
      <MemberSignature Language="C#" Value="public static bool DirectoryExists (string directory);" />
      <MemberSignature Language="ILAsm" Value=".method public static bool DirectoryExists(string directory) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.DirectoryExists(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function DirectoryExists (directory As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool DirectoryExists(System::String ^ directory);" />
      <MemberSignature Language="F#" Value="static member DirectoryExists : string -&gt; bool" Usage="Microsoft.VisualBasic.FileIO.FileSystem.DirectoryExists directory" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="directory" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="directory">O caminho do diretório.</param>
        <summary>Retornará <see langword="True" /> se o diretório especificado existir.</summary>
        <returns>
          <see langword="True" /> se o diretório existir; caso contrário, <see langword="False" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Este exemplo determina se o diretório `C:\backup\logs` existe e verifica suas propriedades.  
  
 [!code-vb[VbRefFile#13](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#13)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Controla a capacidade de acessar arquivos e pastas. Enumeração associada: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="Drives">
      <MemberSignature Language="C#" Value="public static System.Collections.ObjectModel.ReadOnlyCollection&lt;System.IO.DriveInfo&gt; Drives { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Collections.ObjectModel.ReadOnlyCollection`1&lt;class System.IO.DriveInfo&gt; Drives" />
      <MemberSignature Language="DocId" Value="P:Microsoft.VisualBasic.FileIO.FileSystem.Drives" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property Drives As ReadOnlyCollection(Of DriveInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Collections::ObjectModel::ReadOnlyCollection&lt;System::IO::DriveInfo ^&gt; ^ Drives { System::Collections::ObjectModel::ReadOnlyCollection&lt;System::IO::DriveInfo ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Drives : System.Collections.ObjectModel.ReadOnlyCollection&lt;System.IO.DriveInfo&gt;" Usage="Microsoft.VisualBasic.FileIO.FileSystem.Drives" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ObjectModel.ReadOnlyCollection&lt;System.IO.DriveInfo&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Retorna uma coleção somente leitura de todos os nomes de unidade disponíveis.</summary>
        <value>Uma coleção somente leitura de todas as unidades disponíveis como objetos <see cref="T:System.IO.DriveInfo" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Essa propriedade retorna todas as unidades lógicas.  
  
   
  
## Examples  
 Este exemplo exibe os nomes de unidade disponível em uma caixa de mensagem.  
  
 [!code-vb[VbRefFile#19](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#19)]  
  
 ]]></format>
        </remarks>
        <altCompliant cref="None" />
        <permission cref="T:System.Security.Permissions.FileIOPermission">Controla a capacidade de acessar arquivos e pastas. Enumeração associada: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <altmember cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" />
        <altmember cref="T:System.IO.DriveInfo" />
      </Docs>
    </Member>
    <Member MemberName="FileExists">
      <MemberSignature Language="C#" Value="public static bool FileExists (string file);" />
      <MemberSignature Language="ILAsm" Value=".method public static bool FileExists(string file) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.FileExists(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FileExists (file As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool FileExists(System::String ^ file);" />
      <MemberSignature Language="F#" Value="static member FileExists : string -&gt; bool" Usage="Microsoft.VisualBasic.FileIO.FileSystem.FileExists file" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="file" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="file">Nome e caminho do arquivo.</param>
        <summary>Retornará <see langword="True" /> se o arquivo especificado existir.</summary>
        <returns>Retornará <see langword="True" /> se o arquivo existir; caso contrário, esse método retornará <see langword="False" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se o aplicativo não tem permissões suficientes para ler o arquivo especificado, o `FileExists` método retorna `False`, independentemente da existência do caminho; o método não lança uma exceção.  
  
   
  
## Examples  
 Este exemplo verifica se o arquivo `Check.txt` existe e fornece as informações em uma caixa de mensagem.  
  
 [!code-vb[VbRefFile#20](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#20)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">O nome do arquivo termina com uma barra invertida (\\).</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Controla a capacidade de acessar arquivos e pastas. Enumeração associada: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="FindInFiles">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Retorna uma coleção somente leitura de cadeias de caracteres que representam os nomes de arquivos que contêm o texto especificado.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="FindInFiles">
      <MemberSignature Language="C#" Value="public static System.Collections.ObjectModel.ReadOnlyCollection&lt;string&gt; FindInFiles (string directory, string containsText, bool ignoreCase, Microsoft.VisualBasic.FileIO.SearchOption searchType);" />
      <MemberSignature Language="ILAsm" Value=".method public static class System.Collections.ObjectModel.ReadOnlyCollection`1&lt;string&gt; FindInFiles(string directory, string containsText, bool ignoreCase, valuetype Microsoft.VisualBasic.FileIO.SearchOption searchType) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.FindInFiles(System.String,System.String,System.Boolean,Microsoft.VisualBasic.FileIO.SearchOption)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FindInFiles (directory As String, containsText As String, ignoreCase As Boolean, searchType As SearchOption) As ReadOnlyCollection(Of String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Collections::ObjectModel::ReadOnlyCollection&lt;System::String ^&gt; ^ FindInFiles(System::String ^ directory, System::String ^ containsText, bool ignoreCase, Microsoft::VisualBasic::FileIO::SearchOption searchType);" />
      <MemberSignature Language="F#" Value="static member FindInFiles : string * string * bool * Microsoft.VisualBasic.FileIO.SearchOption -&gt; System.Collections.ObjectModel.ReadOnlyCollection&lt;string&gt;" Usage="Microsoft.VisualBasic.FileIO.FileSystem.FindInFiles (directory, containsText, ignoreCase, searchType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.ObjectModel.ReadOnlyCollection&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="directory" Type="System.String" />
        <Parameter Name="containsText" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="searchType" Type="Microsoft.VisualBasic.FileIO.SearchOption" />
      </Parameters>
      <Docs>
        <param name="directory">O diretório a ser pesquisado.</param>
        <param name="containsText">O texto de pesquisa.</param>
        <param name="ignoreCase">
          <see langword="True" /> se a pesquisa deve diferenciar maiúsculas de minúsculas; Caso contrário, <see langword="False" />. O padrão é <see langword="True" />.</param>
        <param name="searchType">Indica se subpastas devem ser incluídas. O padrão é <see langword="SearchOption.SearchTopLevelOnly" />.</param>
        <summary>Retorna uma coleção somente leitura de cadeias de caracteres que representam os nomes de arquivos que contêm o texto especificado.</summary>
        <returns>Coleção somente leitura dos nomes de arquivos que contêm o texto especificado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Uma coleção vazia é retornada se nenhum arquivo correspondente ao padrão especificado for encontrado.  
  
 A tabela a seguir lista um exemplo de uma tarefa que envolvem o `My.Computer.FileSystem.FindInFiles` método.  
  
|Para|Consulte|  
|-|-|  
|Pesquisar um diretório para arquivos que contém uma cadeia de caracteres específica|[Passo a passo: manipulando arquivos e diretórios no Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/walkthrough-manipulating-files-and-directories.md)|  
  
   
  
## Examples  
 Este exemplo procura no diretório `C:\TestDir` para todos os arquivos que contém a cadeia de caracteres `"sample string"` e exibe os resultados em `ListBox1`.  
  
 [!code-vb[VbRefFile#12](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#12)]  
  
 Para trabalhar, o projeto deve conter um `ListBox` chamado `ListBox1`.  
  
 ]]></format>
        </remarks>
        <altCompliant cref="None." />
        <exception cref="T:System.ArgumentException">O caminho não é válido por um dos seguintes motivos: é uma cadeia de comprimento zero, contém apenas espaços em branco, contém caracteres inválidos ou é um caminho de dispositivo (começa com <c>\\.\</c>).</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="directory" /> é <see langword="Nothing" /> ou é uma cadeia de caracteres vazia.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">O diretório especificado não existe.</exception>
        <exception cref="T:System.IO.IOException">O diretório especificado aponta para um arquivo existente.</exception>
        <exception cref="T:System.IO.PathTooLongException">O caminho excede o tamanho máximo definido pelo sistema.</exception>
        <exception cref="T:System.NotSupportedException">O diretório especificado no caminho contém dois-pontos (:) ou está em um formato inválido.</exception>
        <exception cref="T:System.Security.SecurityException">O usuário não tem as permissões necessárias para exibir o caminho.</exception>
        <exception cref="T:System.UnauthorizedAccessException">O usuário não tem as permissões necessárias.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Controla a capacidade de acessar arquivos e pastas. Enumeração associada: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <altmember cref="T:Microsoft.VisualBasic.FileIO.SearchOption" />
        <altmember cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" />
      </Docs>
    </Member>
    <Member MemberName="FindInFiles">
      <MemberSignature Language="C#" Value="public static System.Collections.ObjectModel.ReadOnlyCollection&lt;string&gt; FindInFiles (string directory, string containsText, bool ignoreCase, Microsoft.VisualBasic.FileIO.SearchOption searchType, params string[] fileWildcards);" />
      <MemberSignature Language="ILAsm" Value=".method public static class System.Collections.ObjectModel.ReadOnlyCollection`1&lt;string&gt; FindInFiles(string directory, string containsText, bool ignoreCase, valuetype Microsoft.VisualBasic.FileIO.SearchOption searchType, string[] fileWildcards) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.FindInFiles(System.String,System.String,System.Boolean,Microsoft.VisualBasic.FileIO.SearchOption,System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FindInFiles (directory As String, containsText As String, ignoreCase As Boolean, searchType As SearchOption, ParamArray fileWildcards As String()) As ReadOnlyCollection(Of String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Collections::ObjectModel::ReadOnlyCollection&lt;System::String ^&gt; ^ FindInFiles(System::String ^ directory, System::String ^ containsText, bool ignoreCase, Microsoft::VisualBasic::FileIO::SearchOption searchType, ... cli::array &lt;System::String ^&gt; ^ fileWildcards);" />
      <MemberSignature Language="F#" Value="static member FindInFiles : string * string * bool * Microsoft.VisualBasic.FileIO.SearchOption * string[] -&gt; System.Collections.ObjectModel.ReadOnlyCollection&lt;string&gt;" Usage="Microsoft.VisualBasic.FileIO.FileSystem.FindInFiles (directory, containsText, ignoreCase, searchType, fileWildcards)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ObjectModel.ReadOnlyCollection&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="directory" Type="System.String" />
        <Parameter Name="containsText" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="searchType" Type="Microsoft.VisualBasic.FileIO.SearchOption" />
        <Parameter Name="fileWildcards" Type="System.String[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="directory">O diretório a ser pesquisado.</param>
        <param name="containsText">O texto de pesquisa.</param>
        <param name="ignoreCase">
          <see langword="True" /> se a pesquisa deve diferenciar maiúsculas de minúsculas; Caso contrário, <see langword="False" />. O padrão é <see langword="True" />.</param>
        <param name="searchType">Indica se subpastas devem ser incluídas. O padrão é <see langword="SearchOption.SearchTopLevelOnly" />.</param>
        <param name="fileWildcards">Padrão para correspondência.</param>
        <summary>Retorna uma coleção somente leitura de cadeias de caracteres que representam os nomes de arquivos que contêm o texto especificado.</summary>
        <returns>Coleção somente leitura dos nomes de arquivos que contêm o texto especificado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Uma coleção vazia é retornada se nenhum arquivo correspondente ao padrão especificado for encontrado.  
  
 A tabela a seguir lista um exemplo de uma tarefa que envolvem o `My.Computer.FileSystem.FindInFiles` método.  
  
|Para|Consulte|  
|-|-|  
|Pesquisar um diretório para arquivos que contém uma cadeia de caracteres específica|[Passo a passo: manipulando arquivos e diretórios no Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/walkthrough-manipulating-files-and-directories.md)|  
  
   
  
## Examples  
 Este exemplo procura no diretório `C:\TestDir` para todos os arquivos que contém a cadeia de caracteres `"sample string"` e exibe os resultados em `ListBox1`.  
  
 [!code-vb[VbRefFile#12](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#12)]  
  
 Para trabalhar, o projeto deve conter um `ListBox` chamado `ListBox1`.  
  
 ]]></format>
        </remarks>
        <altCompliant cref="None." />
        <exception cref="T:System.ArgumentException">O caminho não é válido por um dos seguintes motivos: é uma cadeia de comprimento zero, contém apenas espaços em branco, contém caracteres inválidos ou é um caminho de dispositivo (começa com <c>\\.\</c>).</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="directory" /> é <see langword="Nothing" /> ou é uma cadeia de caracteres vazia.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">O diretório especificado não existe.</exception>
        <exception cref="T:System.IO.IOException">O diretório especificado aponta para um arquivo existente.</exception>
        <exception cref="T:System.IO.PathTooLongException">O caminho excede o tamanho máximo definido pelo sistema.</exception>
        <exception cref="T:System.NotSupportedException">O diretório especificado no caminho contém dois-pontos (:) ou está em um formato inválido.</exception>
        <exception cref="T:System.Security.SecurityException">O usuário não tem as permissões necessárias para exibir o caminho.</exception>
        <exception cref="T:System.UnauthorizedAccessException">O usuário não tem as permissões necessárias.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Controla a capacidade de acessar arquivos e pastas. Enumeração associada: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <altmember cref="T:Microsoft.VisualBasic.FileIO.SearchOption" />
        <altmember cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetDirectories">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Retorna uma coleção de cadeias de caracteres que representam os nomes dos caminhos dos subdiretórios de um diretório.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetDirectories">
      <MemberSignature Language="C#" Value="public static System.Collections.ObjectModel.ReadOnlyCollection&lt;string&gt; GetDirectories (string directory);" />
      <MemberSignature Language="ILAsm" Value=".method public static class System.Collections.ObjectModel.ReadOnlyCollection`1&lt;string&gt; GetDirectories(string directory) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.GetDirectories(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetDirectories (directory As String) As ReadOnlyCollection(Of String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Collections::ObjectModel::ReadOnlyCollection&lt;System::String ^&gt; ^ GetDirectories(System::String ^ directory);" />
      <MemberSignature Language="F#" Value="static member GetDirectories : string -&gt; System.Collections.ObjectModel.ReadOnlyCollection&lt;string&gt;" Usage="Microsoft.VisualBasic.FileIO.FileSystem.GetDirectories directory" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.ObjectModel.ReadOnlyCollection&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="directory" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="directory">Nome e caminho do diretório.</param>
        <summary>Retorna uma coleção de cadeias de caracteres que representam os nomes dos caminhos dos subdiretórios de um diretório.</summary>
        <returns>Coleção somente leitura dos nomes dos caminhos dos subdiretórios dentro do diretório especificado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista um exemplo de uma tarefa que envolvem o `My.Computer.FileSystem.GetDirectories` método.  
  
|Para|Consulte|  
|-|-|  
|Lista de subdiretórios com um padrão específico|[Como: localizar subdiretórios com um padrão específico no Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-find-subdirectories-with-a-specific-pattern.md)|  
  
   
  
## Examples  
 O exemplo a seguir retorna todas as pastas na estrutura de diretórios que contêm a palavra `Logs` em seus nomes e os adiciona ao `ListBox1`.  
  
 [!code-vb[VbRefFile#10](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#10)]  
  
 Este exemplo requer que você tenha um `ListBox` denominado `ListBox1` em seu formulário.  
  
 ]]></format>
        </remarks>
        <altCompliant cref="None." />
        <exception cref="T:System.ArgumentException">O caminho não é válido por um dos seguintes motivos: é uma cadeia de tamanho zero, contém apenas espaços em branco, contém caracteres inválidos ou é um caminho de dispositivo (começa com \\\\.\\).</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="directory" /> é <see langword="Nothing" /> ou é uma cadeia de caracteres vazia.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">O diretório especificado não existe.</exception>
        <exception cref="T:System.IO.IOException">O diretório especificado aponta para um arquivo existente.</exception>
        <exception cref="T:System.IO.PathTooLongException">O caminho excede o tamanho máximo definido pelo sistema.</exception>
        <exception cref="T:System.NotSupportedException">Um nome de arquivo ou de diretório no caminho contém dois-pontos (:) ou está em um formato inválido.</exception>
        <exception cref="T:System.Security.SecurityException">O usuário não tem as permissões necessárias para exibir o caminho.</exception>
        <exception cref="T:System.UnauthorizedAccessException">O usuário não tem as permissões necessárias.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Controla a capacidade de acessar arquivos e pastas. Enumeração associada: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <altmember cref="T:Microsoft.VisualBasic.FileIO.SearchOption" />
        <altmember cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" />
      </Docs>
    </Member>
    <Member MemberName="GetDirectories">
      <MemberSignature Language="C#" Value="public static System.Collections.ObjectModel.ReadOnlyCollection&lt;string&gt; GetDirectories (string directory, Microsoft.VisualBasic.FileIO.SearchOption searchType, params string[] wildcards);" />
      <MemberSignature Language="ILAsm" Value=".method public static class System.Collections.ObjectModel.ReadOnlyCollection`1&lt;string&gt; GetDirectories(string directory, valuetype Microsoft.VisualBasic.FileIO.SearchOption searchType, string[] wildcards) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.GetDirectories(System.String,Microsoft.VisualBasic.FileIO.SearchOption,System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetDirectories (directory As String, searchType As SearchOption, ParamArray wildcards As String()) As ReadOnlyCollection(Of String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Collections::ObjectModel::ReadOnlyCollection&lt;System::String ^&gt; ^ GetDirectories(System::String ^ directory, Microsoft::VisualBasic::FileIO::SearchOption searchType, ... cli::array &lt;System::String ^&gt; ^ wildcards);" />
      <MemberSignature Language="F#" Value="static member GetDirectories : string * Microsoft.VisualBasic.FileIO.SearchOption * string[] -&gt; System.Collections.ObjectModel.ReadOnlyCollection&lt;string&gt;" Usage="Microsoft.VisualBasic.FileIO.FileSystem.GetDirectories (directory, searchType, wildcards)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.ObjectModel.ReadOnlyCollection&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="directory" Type="System.String" />
        <Parameter Name="searchType" Type="Microsoft.VisualBasic.FileIO.SearchOption" />
        <Parameter Name="wildcards" Type="System.String[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="directory">Nome e caminho do diretório.</param>
        <param name="searchType">Indica se subpastas devem ser incluídas. O padrão é <see langword="SearchOption.SearchTopLevelOnly" />.</param>
        <param name="wildcards">O padrão ao qual os nomes serão correspondidos.</param>
        <summary>Retorna uma coleção de cadeias de caracteres que representam os nomes dos caminhos dos subdiretórios de um diretório.</summary>
        <returns>Coleção somente leitura dos nomes dos caminhos dos subdiretórios dentro do diretório especificado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 É possível usar o parâmetro `wildcards` para especificar um padrão específico. Caso deseje incluir os conteúdos dos subdiretórios na pesquisa, defina o parâmetro `searchType` para `SearchAllSubDirectories`.  
  
 Uma coleção vazia será retornada se nenhum diretório correspondente ao padrão especificado for encontrado.  
  
 A tabela a seguir lista um exemplo de uma tarefa que envolvem o `My.Computer.FileSystem.GetDirectories` método.  
  
|Para|Consulte|  
|-|-|  
|Lista de subdiretórios com um padrão específico|[Como: localizar subdiretórios com um padrão específico no Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-find-subdirectories-with-a-specific-pattern.md)|  
  
   
  
## Examples  
 O exemplo a seguir retorna todas as pastas na estrutura de diretórios que contêm a palavra `Logs` em seus nomes e os adiciona ao `ListBox1`.  
  
 [!code-vb[VbRefFile#10](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#10)]  
  
 Este exemplo requer que você tenha um `ListBox` denominado `ListBox1` em seu formulário.  
  
 ]]></format>
        </remarks>
        <altCompliant cref="None." />
        <exception cref="T:System.ArgumentException">O caminho não é válido por um dos seguintes motivos: é uma cadeia de tamanho zero, contém apenas espaços em branco, contém caracteres inválidos ou é um caminho de dispositivo (começa com \\\\.\\).</exception>
        <exception cref="T:System.ArgumentNullException">Um ou mais dos caracteres curinga especificados é <see langword="Nothing" />, uma cadeia de caracteres vazia ou contém somente espaços.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">O diretório especificado não existe.</exception>
        <exception cref="T:System.IO.IOException">O diretório especificado aponta para um arquivo existente.</exception>
        <exception cref="T:System.IO.PathTooLongException">O caminho excede o tamanho máximo definido pelo sistema.</exception>
        <exception cref="T:System.NotSupportedException">Um nome de arquivo ou de diretório no caminho contém dois-pontos (:) ou está em um formato inválido.</exception>
        <exception cref="T:System.Security.SecurityException">O usuário não tem as permissões necessárias para exibir o caminho.</exception>
        <exception cref="T:System.UnauthorizedAccessException">O usuário não tem as permissões necessárias.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Controla a capacidade de acessar arquivos e pastas. Enumeração associada: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <altmember cref="T:Microsoft.VisualBasic.FileIO.SearchOption" />
        <altmember cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" />
      </Docs>
    </Member>
    <Member MemberName="GetDirectoryInfo">
      <MemberSignature Language="C#" Value="public static System.IO.DirectoryInfo GetDirectoryInfo (string directory);" />
      <MemberSignature Language="ILAsm" Value=".method public static class System.IO.DirectoryInfo GetDirectoryInfo(string directory) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.GetDirectoryInfo(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetDirectoryInfo (directory As String) As DirectoryInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::DirectoryInfo ^ GetDirectoryInfo(System::String ^ directory);" />
      <MemberSignature Language="F#" Value="static member GetDirectoryInfo : string -&gt; System.IO.DirectoryInfo" Usage="Microsoft.VisualBasic.FileIO.FileSystem.GetDirectoryInfo directory" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.DirectoryInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="directory" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="directory">
          <see langword="String" />. Caminho do diretório.</param>
        <summary>Retorna um objeto <see cref="T:System.IO.DirectoryInfo" /> para o arquivo especificado.</summary>
        <returns>Objeto <see cref="T:System.IO.DirectoryInfo" /> do caminho especificado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se o diretório não existir, uma exceção não é lançada até que a primeira vez que uma propriedade <xref:System.IO.DirectoryInfo> objeto é acessado.  
  
   
  
## Examples  
 Este exemplo obtém uma <xref:System.IO.DirectoryInfo> objeto para o diretório `C:\Documents and Settings` e exibe o diretório hora de criação, último tempo de acesso e última hora de gravação.  
  
 [!code-vb[VbRefFile#7](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">O caminho não é válido por um dos seguintes motivos: é uma cadeia de tamanho zero, contém apenas espaços em branco, contém caracteres inválidos ou é um caminho de dispositivo (começa com \\\\.\\).</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="directory" /> é <see langword="Nothing" /> ou é uma cadeia de caracteres vazia.</exception>
        <exception cref="T:System.IO.PathTooLongException">O caminho excede o tamanho máximo definido pelo sistema.</exception>
        <exception cref="T:System.NotSupportedException">O caminho do diretório contém dois-pontos (:) ou está em um formato inválido.</exception>
        <exception cref="T:System.Security.SecurityException">O usuário não tem as permissões necessárias para exibir o caminho</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Controla a capacidade de acessar arquivos e pastas. Enumeração associada: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <altmember cref="T:System.IO.DirectoryInfo" />
      </Docs>
    </Member>
    <Member MemberName="GetDriveInfo">
      <MemberSignature Language="C#" Value="public static System.IO.DriveInfo GetDriveInfo (string drive);" />
      <MemberSignature Language="ILAsm" Value=".method public static class System.IO.DriveInfo GetDriveInfo(string drive) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.GetDriveInfo(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetDriveInfo (drive As String) As DriveInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::DriveInfo ^ GetDriveInfo(System::String ^ drive);" />
      <MemberSignature Language="F#" Value="static member GetDriveInfo : string -&gt; System.IO.DriveInfo" Usage="Microsoft.VisualBasic.FileIO.FileSystem.GetDriveInfo drive" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.DriveInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="drive" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="drive">Unidade a ser examinada.</param>
        <summary>Retorna um objeto <see cref="T:System.IO.DriveInfo" /> para a unidade especificada.</summary>
        <returns>Objeto <see cref="T:System.IO.DriveInfo" /> da unidade especificada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.IO.DriveInfo> classe modela uma unidade e fornece métodos e propriedades para consultar informações da unidade. Use <xref:System.IO.DriveInfo> para determinar quais unidades estão disponíveis e o tipo de unidades que eles estão. Você também pode consultar a propriedade para determinar a capacidade e o espaço livre disponível na unidade.  
  
   
  
## Examples  
 Este exemplo obtém uma <xref:System.IO.DriveInfo> objeto para a unidade C e usa-o para exibir informações sobre a unidade.  
  
 [!code-vb[VbRefFile#11](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#11)]  
  
 Para obter informações sobre os tipos de unidade diferente, consulte <xref:System.IO.DriveType>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">O caminho não é válido por um dos seguintes motivos: é uma cadeia de tamanho zero, contém apenas espaços em branco, contém caracteres inválidos ou é um caminho de dispositivo (começa com \\\\.\\).</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="drive" /> é <see langword="Nothing" /> ou é uma cadeia de caracteres vazia.</exception>
        <exception cref="T:System.IO.PathTooLongException">O caminho excede o tamanho máximo definido pelo sistema.</exception>
        <exception cref="T:System.Security.SecurityException">O usuário não tem as permissões necessárias para exibir o caminho</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Controla a capacidade de acessar arquivos e pastas. Enumeração associada: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <altmember cref="T:System.IO.DriveInfo" />
        <altmember cref="T:System.IO.DriveType" />
      </Docs>
    </Member>
    <Member MemberName="GetFileInfo">
      <MemberSignature Language="C#" Value="public static System.IO.FileInfo GetFileInfo (string file);" />
      <MemberSignature Language="ILAsm" Value=".method public static class System.IO.FileInfo GetFileInfo(string file) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.GetFileInfo(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetFileInfo (file As String) As FileInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::FileInfo ^ GetFileInfo(System::String ^ file);" />
      <MemberSignature Language="F#" Value="static member GetFileInfo : string -&gt; System.IO.FileInfo" Usage="Microsoft.VisualBasic.FileIO.FileSystem.GetFileInfo file" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.FileInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="file" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="file">Nome e caminho do arquivo.</param>
        <summary>Retorna um objeto <see cref="T:System.IO.FileInfo" /> para o arquivo especificado.</summary>
        <returns>Objeto <see cref="T:System.IO.FileInfo" /> do arquivo especificado</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Uma exceção não é lançada se o arquivo não existe; em vez disso, ela será lançada na primeira vez em que as propriedades do objeto são acessadas.  
  
 A tabela a seguir lista um exemplo de uma tarefa que envolvem o `My.Computer.FileSystem.GetFileInfo` método.  
  
|Para|Consulte|  
|-|-|  
|Determinar o nome e o caminho do arquivo|[Como: analisar demarcadores de arquivo no Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-parse-file-paths.md)|  
  
   
  
## Examples  
 Este exemplo recupera uma <xref:System.IO.FileInfo?displayProperty=nameWithType> objeto para o arquivo `MyLogFile.log` e o utiliza para relatar o nome completo do arquivo, hora do último acesso e comprimento.  
  
 [!code-vb[VbRefFile#1](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">O nome do caminho está malformado. Por exemplo, ele contém caracteres inválidos ou é somente um espaço em branco. O nome de arquivo tem uma barra “/” à direita.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="file" /> é <see langword="Nothing" /> ou é uma cadeia de caracteres vazia.</exception>
        <exception cref="T:System.NotSupportedException">O caminho contém dois-pontos no meio da cadeia de caracteres.</exception>
        <exception cref="T:System.IO.PathTooLongException">O caminho é muito longo.</exception>
        <exception cref="T:System.Security.SecurityException">O usuário não tem as permissões necessárias.</exception>
        <exception cref="T:System.UnauthorizedAccessException">O usuário não tem acesso à ACL (lista de controle de acesso) do arquivo.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Controla a capacidade de acessar arquivos e pastas. Enumeração associada: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <altmember cref="T:System.IO.FileInfo" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetFiles">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Retorna uma coleção somente leitura de cadeias de caracteres que representam os nomes de arquivos de um diretório.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetFiles">
      <MemberSignature Language="C#" Value="public static System.Collections.ObjectModel.ReadOnlyCollection&lt;string&gt; GetFiles (string directory);" />
      <MemberSignature Language="ILAsm" Value=".method public static class System.Collections.ObjectModel.ReadOnlyCollection`1&lt;string&gt; GetFiles(string directory) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.GetFiles(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetFiles (directory As String) As ReadOnlyCollection(Of String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Collections::ObjectModel::ReadOnlyCollection&lt;System::String ^&gt; ^ GetFiles(System::String ^ directory);" />
      <MemberSignature Language="F#" Value="static member GetFiles : string -&gt; System.Collections.ObjectModel.ReadOnlyCollection&lt;string&gt;" Usage="Microsoft.VisualBasic.FileIO.FileSystem.GetFiles directory" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.ObjectModel.ReadOnlyCollection&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="directory" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="directory">Diretório a ser pesquisado.</param>
        <summary>Retorna uma coleção somente leitura de cadeias de caracteres que representam os nomes de arquivos de um diretório.</summary>
        <returns>Coleção somente leitura de nomes de arquivos do diretório especificado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Uma coleção vazia é retornada se nenhum arquivo correspondente ao padrão especificado for encontrado.  
  
 A tabela a seguir lista exemplos de tarefas que envolvem o `My.Computer.FileSystem.GetFiles` método.  
  
|Para|Consulte|  
|-|-|  
|Obtenha a coleção de arquivos em um diretório|[Como: obter a coleção de arquivos em um diretório no Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-get-the-collection-of-files-in-a-directory.md)|  
|Localizar arquivos com um padrão específico em um diretório|[Como: localizar arquivos com um padrão específico no Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-find-files-with-a-specific-pattern.md)|  
  
   
  
## Examples  
 O exemplo a seguir retorna todos os arquivos no diretório e os inclui na `ListBox1`.  
  
 [!code-vb[VbRefFile#5](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#5)]  
  
 Este exemplo requer que você tenha um `ListBox` denominado `ListBox1` em seu formulário.  
  
 Este exemplo retorna todos os arquivos no diretório com a extensão `.txt` e adiciona a `ListBox1`.  
  
 [!code-vb[VbRefFile#6](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#6)]  
  
 Este exemplo requer que você tenha um `ListBox` denominado `ListBox1` em seu formulário.  
  
 ]]></format>
        </remarks>
        <altCompliant cref="None." />
        <exception cref="T:System.ArgumentException">O caminho não é válido por um dos seguintes motivos: é uma cadeia de tamanho zero, contém apenas espaços em branco, contém caracteres inválidos ou é um caminho de dispositivo (começa com \\\\.\\).</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="directory" /> é <see langword="Nothing" />.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">O diretório a ser pesquisado não existe.</exception>
        <exception cref="T:System.IO.IOException">
          <paramref name="directory" /> aponta para um arquivo existente.</exception>
        <exception cref="T:System.IO.PathTooLongException">O caminho excede o tamanho máximo definido pelo sistema.</exception>
        <exception cref="T:System.NotSupportedException">Um nome de arquivo ou de diretório no caminho contém dois-pontos (:) ou está em um formato inválido.</exception>
        <exception cref="T:System.Security.SecurityException">O usuário não tem as permissões necessárias para exibir o caminho.</exception>
        <exception cref="T:System.UnauthorizedAccessException">O usuário não tem as permissões necessárias.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Controla a capacidade de acessar arquivos e pastas. Enumeração associada: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <altmember cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" />
      </Docs>
    </Member>
    <Member MemberName="GetFiles">
      <MemberSignature Language="C#" Value="public static System.Collections.ObjectModel.ReadOnlyCollection&lt;string&gt; GetFiles (string directory, Microsoft.VisualBasic.FileIO.SearchOption searchType, params string[] wildcards);" />
      <MemberSignature Language="ILAsm" Value=".method public static class System.Collections.ObjectModel.ReadOnlyCollection`1&lt;string&gt; GetFiles(string directory, valuetype Microsoft.VisualBasic.FileIO.SearchOption searchType, string[] wildcards) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.GetFiles(System.String,Microsoft.VisualBasic.FileIO.SearchOption,System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetFiles (directory As String, searchType As SearchOption, ParamArray wildcards As String()) As ReadOnlyCollection(Of String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Collections::ObjectModel::ReadOnlyCollection&lt;System::String ^&gt; ^ GetFiles(System::String ^ directory, Microsoft::VisualBasic::FileIO::SearchOption searchType, ... cli::array &lt;System::String ^&gt; ^ wildcards);" />
      <MemberSignature Language="F#" Value="static member GetFiles : string * Microsoft.VisualBasic.FileIO.SearchOption * string[] -&gt; System.Collections.ObjectModel.ReadOnlyCollection&lt;string&gt;" Usage="Microsoft.VisualBasic.FileIO.FileSystem.GetFiles (directory, searchType, wildcards)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.ObjectModel.ReadOnlyCollection&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="directory" Type="System.String" />
        <Parameter Name="searchType" Type="Microsoft.VisualBasic.FileIO.SearchOption" />
        <Parameter Name="wildcards" Type="System.String[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="directory">Diretório a ser pesquisado.</param>
        <param name="searchType">Indica se subpastas devem ser incluídas. O padrão é <see langword="SearchOption.SearchTopLevelOnly" />.</param>
        <param name="wildcards">Padrão para correspondência.</param>
        <summary>Retorna uma coleção somente leitura de cadeias de caracteres que representam os nomes de arquivos de um diretório.</summary>
        <returns>Coleção somente leitura de nomes de arquivos do diretório especificado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Uma coleção vazia é retornada se nenhum arquivo correspondente ao padrão especificado for encontrado.  
  
 A tabela a seguir lista exemplos de tarefas que envolvem o `My.Computer.FileSystem.GetFiles` método.  
  
|Para|Consulte|  
|-|-|  
|Obtenha a coleção de arquivos em um diretório|[Como: obter a coleção de arquivos em um diretório no Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-get-the-collection-of-files-in-a-directory.md)|  
|Localizar arquivos com um padrão específico em um diretório|[Como: localizar arquivos com um padrão específico no Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-find-files-with-a-specific-pattern.md)|  
  
   
  
## Examples  
 O exemplo a seguir retorna todos os arquivos no diretório e os inclui na `ListBox1`.  
  
 [!code-vb[VbRefFile#5](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#5)]  
  
 Este exemplo requer que você tenha um `ListBox` denominado `ListBox1` em seu formulário.  
  
 Este exemplo retorna todos os arquivos no diretório com a extensão `.txt` e adiciona a `ListBox1`.  
  
 [!code-vb[VbRefFile#6](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#6)]  
  
 Este exemplo requer que você tenha um `ListBox` denominado `ListBox1` em seu formulário.  
  
 ]]></format>
        </remarks>
        <altCompliant cref="None." />
        <exception cref="T:System.ArgumentException">O caminho não é válido por um dos seguintes motivos: é uma cadeia de tamanho zero, contém apenas espaços em branco, contém caracteres inválidos ou é um caminho de dispositivo (começa com \\\\.\\).</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="directory" /> é <see langword="Nothing" />.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">O diretório a ser pesquisado não existe.</exception>
        <exception cref="T:System.IO.IOException">
          <paramref name="directory" /> aponta para um arquivo existente.</exception>
        <exception cref="T:System.IO.PathTooLongException">O caminho excede o tamanho máximo definido pelo sistema.</exception>
        <exception cref="T:System.NotSupportedException">Um nome de arquivo ou de diretório no caminho contém dois-pontos (:) ou está em um formato inválido.</exception>
        <exception cref="T:System.Security.SecurityException">O usuário não tem as permissões necessárias para exibir o caminho.</exception>
        <exception cref="T:System.UnauthorizedAccessException">O usuário não tem as permissões necessárias.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Controla a capacidade de acessar arquivos e pastas. Enumeração associada: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <altmember cref="T:Microsoft.VisualBasic.FileIO.SearchOption" />
        <altmember cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" />
      </Docs>
    </Member>
    <Member MemberName="GetName">
      <MemberSignature Language="C#" Value="public static string GetName (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static string GetName(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.GetName(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetName (path As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetName(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member GetName : string -&gt; string" Usage="Microsoft.VisualBasic.FileIO.FileSystem.GetName path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Necessário. Caminho a ser analisado. <see langword="String" />.</param>
        <summary>Analisa o nome de arquivo do caminho fornecido.</summary>
        <returns>O nome de arquivo do caminho especificado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Essa é uma operação de cadeia de caracteres; o `FileSystem` não é examinado.  
  
 O `GetName` método ignora uma barra no final do caminho.  
  
 A tabela a seguir lista um exemplo de uma tarefa que envolvem o `My.Computer.FileSystem.GetFileName` método.  
  
|Para|Consulte|  
|-|-|  
|Analisar um caminho de arquivo|[Como: analisar demarcadores de arquivo no Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-parse-file-paths.md)|  
  
   
  
## Examples  
 O exemplo a seguir analisa um caminho de arquivo e retorna o nome do arquivo.  
  
 [!code-vb[VbVbcnMyFileSystem#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#21)]  
  
 Substitua o caminho `C:\Testdirectory\Testfile` com o caminho que você deseja analisar.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetParentPath">
      <MemberSignature Language="C#" Value="public static string GetParentPath (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static string GetParentPath(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.GetParentPath(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetParentPath (path As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetParentPath(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member GetParentPath : string -&gt; string" Usage="Microsoft.VisualBasic.FileIO.FileSystem.GetParentPath path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Caminho a ser examinado.</param>
        <summary>Retorna o caminho pai do caminho fornecido.</summary>
        <returns>O caminho pai do caminho fornecido.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Essa é uma operação de cadeia de caracteres; o sistema de arquivos não é examinado.  
  
   
  
## Examples  
 Este exemplo obtém o caminho pai de `C:\Backups\Tmp\Test`.  
  
 [!code-vb[VbRefFile#17](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#17)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">O caminho não tem um caminho pai porque é um caminho raiz.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> é <see langword="Nothing" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">O caminho excede o tamanho máximo definido pelo sistema.</exception>
        <exception cref="T:System.NotSupportedException">Um nome de arquivo ou de diretório no caminho contém dois-pontos (:) ou está em um formato inválido.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetTempFileName">
      <MemberSignature Language="C#" Value="public static string GetTempFileName ();" />
      <MemberSignature Language="ILAsm" Value=".method public static string GetTempFileName() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.GetTempFileName" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTempFileName () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetTempFileName();" />
      <MemberSignature Language="F#" Value="static member GetTempFileName : unit -&gt; string" Usage="Microsoft.VisualBasic.FileIO.FileSystem.GetTempFileName " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Cria um arquivo temporário de zero byte nomeado exclusivamente no disco e retorna o caminho completo do arquivo.</summary>
        <returns>
          <see langword="String" /> que contém o caminho completo do arquivo temporário.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método pode ser usado para criar um arquivo temporário.  
  
   
  
## Examples  
 Este exemplo cria um arquivo temporário e retorna seu caminho.  
  
 [!code-vb[VbVbcnMyFileSystem#12](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#12)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Controla a capacidade de acessar arquivos e pastas. Enumeração associada: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="MoveDirectory">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Move um diretório de um local para outro.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="MoveDirectory">
      <MemberSignature Language="C#" Value="public static void MoveDirectory (string sourceDirectoryName, string destinationDirectoryName);" />
      <MemberSignature Language="ILAsm" Value=".method public static void MoveDirectory(string sourceDirectoryName, string destinationDirectoryName) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.MoveDirectory(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub MoveDirectory (sourceDirectoryName As String, destinationDirectoryName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void MoveDirectory(System::String ^ sourceDirectoryName, System::String ^ destinationDirectoryName);" />
      <MemberSignature Language="F#" Value="static member MoveDirectory : string * string -&gt; unit" Usage="Microsoft.VisualBasic.FileIO.FileSystem.MoveDirectory (sourceDirectoryName, destinationDirectoryName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceDirectoryName" Type="System.String" />
        <Parameter Name="destinationDirectoryName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="sourceDirectoryName">O caminho do diretório a ser movido.</param>
        <param name="destinationDirectoryName">O caminho do diretório para o qual o diretório de origem está sendo movido.</param>
        <summary>Move um diretório de um local para outro.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se for feita uma tentativa para mover um diretório dentro de um diretório que não existe, a estrutura de destino será criada.  
  
   
  
## Examples  
 Este exemplo move `Directory1` dentro de `Directory2`.  
  
 [!code-vb[VbVbcnMyFileSystem#81](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#81)]  
  
 Este exemplo move `Directory1` dentro de `Directory2`, substituindo o diretório se ele já existe.  
  
 [!code-vb[VbVbcnMyFileSystem#82](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#82)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">O caminho não é válido por um dos seguintes motivos: é uma cadeia de tamanho zero, contém apenas espaços em branco, contém caracteres inválidos ou é um caminho de dispositivo (começa com \\\\.\\).</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="sourceDirectoryName" /> ou <paramref name="destinationDirectoryName" /> é <see langword="Nothing" /> ou uma cadeia de caracteres vazia.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">O diretório não existe.</exception>
        <exception cref="T:System.IO.IOException">A origem é um diretório raiz ou o caminho de origem e o caminho de destino são os mesmos.</exception>
        <exception cref="T:System.IO.PathTooLongException">O caminho excede o tamanho máximo definido pelo sistema.</exception>
        <exception cref="T:System.InvalidOperationException">A operação é cíclica.</exception>
        <exception cref="T:System.NotSupportedException">Um nome de arquivo ou de diretório no caminho contém dois-pontos (:) ou está em um formato inválido.</exception>
        <exception cref="T:System.Security.SecurityException">O usuário não tem as permissões necessárias para exibir o caminho.</exception>
        <exception cref="T:System.UnauthorizedAccessException">O usuário não tem a permissão necessária.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Controla a capacidade de acessar arquivos e pastas. Enumeração associada: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <altmember cref="Overload:Microsoft.VisualBasic.FileIO.FileSystem.MoveFile" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileIO.FileSystem.CopyDirectory" />
      </Docs>
    </Member>
    <Member MemberName="MoveDirectory">
      <MemberSignature Language="C#" Value="public static void MoveDirectory (string sourceDirectoryName, string destinationDirectoryName, Microsoft.VisualBasic.FileIO.UIOption showUI);" />
      <MemberSignature Language="ILAsm" Value=".method public static void MoveDirectory(string sourceDirectoryName, string destinationDirectoryName, valuetype Microsoft.VisualBasic.FileIO.UIOption showUI) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.MoveDirectory(System.String,System.String,Microsoft.VisualBasic.FileIO.UIOption)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub MoveDirectory (sourceDirectoryName As String, destinationDirectoryName As String, showUI As UIOption)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void MoveDirectory(System::String ^ sourceDirectoryName, System::String ^ destinationDirectoryName, Microsoft::VisualBasic::FileIO::UIOption showUI);" />
      <MemberSignature Language="F#" Value="static member MoveDirectory : string * string * Microsoft.VisualBasic.FileIO.UIOption -&gt; unit" Usage="Microsoft.VisualBasic.FileIO.FileSystem.MoveDirectory (sourceDirectoryName, destinationDirectoryName, showUI)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceDirectoryName" Type="System.String" />
        <Parameter Name="destinationDirectoryName" Type="System.String" />
        <Parameter Name="showUI" Type="Microsoft.VisualBasic.FileIO.UIOption" />
      </Parameters>
      <Docs>
        <param name="sourceDirectoryName">O caminho do diretório a ser movido.</param>
        <param name="destinationDirectoryName">O caminho do diretório para o qual o diretório de origem está sendo movido.</param>
        <param name="showUI">Especifica se o progresso da operação deve ser acompanhado visualmente. O padrão é <see langword="UIOption.OnlyErrorDialogs" />.</param>
        <summary>Move um diretório de um local para outro.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se for feita uma tentativa para mover um diretório dentro de um diretório que não existe, a estrutura de destino será criada.  
  
   
  
## Examples  
 Este exemplo move `Directory1` dentro de `Directory2`.  
  
 [!code-vb[VbVbcnMyFileSystem#81](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#81)]  
  
 Este exemplo move `Directory1` dentro de `Directory2`, substituindo o diretório se ele já existe.  
  
 [!code-vb[VbVbcnMyFileSystem#82](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#82)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">O caminho não é válido por um dos seguintes motivos: é uma cadeia de tamanho zero, contém apenas espaços em branco, contém caracteres inválidos ou é um caminho de dispositivo (começa com \\\\.\\).</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="sourceDirectoryName" /> ou <paramref name="destinationDirectoryName" /> é <see langword="Nothing" /> ou uma cadeia de caracteres vazia.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">O diretório não existe.</exception>
        <exception cref="T:System.IO.IOException">O diretório de destino já existe e <paramref name="overwrite" /> está definido como <see langword="False" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">O caminho excede o tamanho máximo definido pelo sistema.</exception>
        <exception cref="T:System.InvalidOperationException">A operação é cíclica.</exception>
        <exception cref="T:System.NotSupportedException">Um nome de arquivo ou de diretório no caminho contém dois-pontos (:) ou está em um formato inválido.</exception>
        <exception cref="T:System.Security.SecurityException">O usuário não tem as permissões necessárias para exibir o caminho.</exception>
        <exception cref="T:System.UnauthorizedAccessException">O usuário não tem a permissão necessária.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Controla a capacidade de acessar arquivos e pastas. Enumeração associada: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <permission cref="T:System.Security.Permissions.UIPermission">Controla as permissões relacionadas às interfaces de usuário e a área de transferência. Enumeração associada: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeSubWindows" />.</permission>
        <altmember cref="Overload:Microsoft.VisualBasic.FileIO.FileSystem.MoveFile" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileIO.FileSystem.CopyDirectory" />
        <altmember cref="T:Microsoft.VisualBasic.FileIO.UIOption" />
      </Docs>
    </Member>
    <Member MemberName="MoveDirectory">
      <MemberSignature Language="C#" Value="public static void MoveDirectory (string sourceDirectoryName, string destinationDirectoryName, bool overwrite);" />
      <MemberSignature Language="ILAsm" Value=".method public static void MoveDirectory(string sourceDirectoryName, string destinationDirectoryName, bool overwrite) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.MoveDirectory(System.String,System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub MoveDirectory (sourceDirectoryName As String, destinationDirectoryName As String, overwrite As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void MoveDirectory(System::String ^ sourceDirectoryName, System::String ^ destinationDirectoryName, bool overwrite);" />
      <MemberSignature Language="F#" Value="static member MoveDirectory : string * string * bool -&gt; unit" Usage="Microsoft.VisualBasic.FileIO.FileSystem.MoveDirectory (sourceDirectoryName, destinationDirectoryName, overwrite)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceDirectoryName" Type="System.String" />
        <Parameter Name="destinationDirectoryName" Type="System.String" />
        <Parameter Name="overwrite" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="sourceDirectoryName">O caminho do diretório a ser movido.</param>
        <param name="destinationDirectoryName">O caminho do diretório para o qual o diretório de origem está sendo movido.</param>
        <param name="overwrite">
          <see langword="True" /> se os diretórios existentes devem ser substituídos; caso contrário, <see langword="False" />. O padrão é <see langword="False" />.</param>
        <summary>Move um diretório de um local para outro.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se for feita uma tentativa para mover um diretório dentro de um diretório que não existe, a estrutura de destino será criada.  
  
   
  
## Examples  
 Este exemplo move `Directory1` dentro de `Directory2`.  
  
 [!code-vb[VbVbcnMyFileSystem#81](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#81)]  
  
 Este exemplo move `Directory1` dentro de `Directory2`, substituindo o diretório se ele já existe.  
  
 [!code-vb[VbVbcnMyFileSystem#82](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#82)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">O caminho não é válido por um dos seguintes motivos: é uma cadeia de tamanho zero, contém apenas espaços em branco, contém caracteres inválidos ou é um caminho de dispositivo (começa com \\\\.\\).</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="sourceDirectoryName" /> ou <paramref name="destinationDirectoryName" /> é <see langword="Nothing" /> ou uma cadeia de caracteres vazia.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">O diretório não existe.</exception>
        <exception cref="T:System.IO.IOException">O diretório de destino já existe e <paramref name="overwrite" /> está definido como <see langword="False" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">O caminho excede o tamanho máximo definido pelo sistema.</exception>
        <exception cref="T:System.InvalidOperationException">A operação é cíclica.</exception>
        <exception cref="T:System.NotSupportedException">Um nome de arquivo ou de diretório no caminho contém dois-pontos (:) ou está em um formato inválido.</exception>
        <exception cref="T:System.Security.SecurityException">O usuário não tem as permissões necessárias para exibir o caminho.</exception>
        <exception cref="T:System.UnauthorizedAccessException">O usuário não tem a permissão necessária.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Controla a capacidade de acessar arquivos e pastas. Enumeração associada: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <altmember cref="Overload:Microsoft.VisualBasic.FileIO.FileSystem.MoveFile" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileIO.FileSystem.CopyDirectory" />
      </Docs>
    </Member>
    <Member MemberName="MoveDirectory">
      <MemberSignature Language="C#" Value="public static void MoveDirectory (string sourceDirectoryName, string destinationDirectoryName, Microsoft.VisualBasic.FileIO.UIOption showUI, Microsoft.VisualBasic.FileIO.UICancelOption onUserCancel);" />
      <MemberSignature Language="ILAsm" Value=".method public static void MoveDirectory(string sourceDirectoryName, string destinationDirectoryName, valuetype Microsoft.VisualBasic.FileIO.UIOption showUI, valuetype Microsoft.VisualBasic.FileIO.UICancelOption onUserCancel) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.MoveDirectory(System.String,System.String,Microsoft.VisualBasic.FileIO.UIOption,Microsoft.VisualBasic.FileIO.UICancelOption)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub MoveDirectory (sourceDirectoryName As String, destinationDirectoryName As String, showUI As UIOption, onUserCancel As UICancelOption)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void MoveDirectory(System::String ^ sourceDirectoryName, System::String ^ destinationDirectoryName, Microsoft::VisualBasic::FileIO::UIOption showUI, Microsoft::VisualBasic::FileIO::UICancelOption onUserCancel);" />
      <MemberSignature Language="F#" Value="static member MoveDirectory : string * string * Microsoft.VisualBasic.FileIO.UIOption * Microsoft.VisualBasic.FileIO.UICancelOption -&gt; unit" Usage="Microsoft.VisualBasic.FileIO.FileSystem.MoveDirectory (sourceDirectoryName, destinationDirectoryName, showUI, onUserCancel)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceDirectoryName" Type="System.String" />
        <Parameter Name="destinationDirectoryName" Type="System.String" />
        <Parameter Name="showUI" Type="Microsoft.VisualBasic.FileIO.UIOption" />
        <Parameter Name="onUserCancel" Type="Microsoft.VisualBasic.FileIO.UICancelOption" />
      </Parameters>
      <Docs>
        <param name="sourceDirectoryName">O caminho do diretório a ser movido.</param>
        <param name="destinationDirectoryName">O caminho do diretório para o qual o diretório de origem está sendo movido.</param>
        <param name="showUI">Especifica se o progresso da operação deve ser acompanhado visualmente. O padrão é <see langword="UIOption.OnlyErrorDialogs" />.</param>
        <param name="onUserCancel">Especifica se uma exceção é lançada ou não quando o usuário cancela a operação. O padrão é <see langword="UICancelOption.ThrowException" />.</param>
        <summary>Move um diretório de um local para outro.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se for feita uma tentativa para mover um diretório dentro de um diretório que não existe, a estrutura de destino será criada.  
  
   
  
## Examples  
 Este exemplo move `Directory1` dentro de `Directory2`.  
  
 [!code-vb[VbVbcnMyFileSystem#81](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#81)]  
  
 Este exemplo move `Directory1` dentro de `Directory2`, substituindo o diretório se ele já existe.  
  
 [!code-vb[VbVbcnMyFileSystem#82](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#82)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">O caminho não é válido por um dos seguintes motivos: é uma cadeia de tamanho zero, contém apenas espaços em branco, contém caracteres inválidos ou é um caminho de dispositivo (começa com \\\\.\\).</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="sourceDirectoryName" /> ou <paramref name="destinationDirectoryName" /> é <see langword="Nothing" /> ou uma cadeia de caracteres vazia.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">O diretório não existe.</exception>
        <exception cref="T:System.IO.IOException">
          <paramref name="onUserCancel" /> é definido como <see langword="ThrowException" /> e um subdiretório do arquivo não pode ser copiado.</exception>
        <exception cref="T:System.OperationCanceledException">
          <paramref name="onUserCancel" /> é definido como <see langword="ThrowException" /> e o usuário cancela a operação ou a operação não pode ser concluída.</exception>
        <exception cref="T:System.Security.SecurityException">O usuário não tem as permissões necessárias para exibir o caminho.</exception>
        <exception cref="T:System.IO.PathTooLongException">O caminho excede o tamanho máximo definido pelo sistema.</exception>
        <exception cref="T:System.InvalidOperationException">A operação é cíclica.</exception>
        <exception cref="T:System.NotSupportedException">Um nome de arquivo ou de diretório no caminho contém dois-pontos (:) ou está em um formato inválido.</exception>
        <exception cref="T:System.UnauthorizedAccessException">O usuário não tem a permissão necessária.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Controla a capacidade de acessar arquivos e pastas. Enumeração associada: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <permission cref="T:System.Security.Permissions.UIPermission">Controla as permissões relacionadas às interfaces de usuário e a área de transferência. Enumeração associada: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeSubWindows" />.</permission>
        <altmember cref="Overload:Microsoft.VisualBasic.FileIO.FileSystem.MoveFile" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileIO.FileSystem.CopyDirectory" />
        <altmember cref="T:Microsoft.VisualBasic.FileIO.UIOption" />
        <altmember cref="T:Microsoft.VisualBasic.FileIO.UICancelOption" />
      </Docs>
    </Member>
    <MemberGroup MemberName="MoveFile">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Move um arquivo para um novo local.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="MoveFile">
      <MemberSignature Language="C#" Value="public static void MoveFile (string sourceFileName, string destinationFileName);" />
      <MemberSignature Language="ILAsm" Value=".method public static void MoveFile(string sourceFileName, string destinationFileName) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.MoveFile(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub MoveFile (sourceFileName As String, destinationFileName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void MoveFile(System::String ^ sourceFileName, System::String ^ destinationFileName);" />
      <MemberSignature Language="F#" Value="static member MoveFile : string * string -&gt; unit" Usage="Microsoft.VisualBasic.FileIO.FileSystem.MoveFile (sourceFileName, destinationFileName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceFileName" Type="System.String" />
        <Parameter Name="destinationFileName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="sourceFileName">Caminho do arquivo a ser movido.</param>
        <param name="destinationFileName">Caminho do diretório para o qual o arquivo deve ser movido.</param>
        <summary>Move um arquivo para um novo local.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se a estrutura de destino não existir, ele é criado.  
  
 O `MoveFile` método preserva as ACEs (entradas de controle de acesso) apenas ao mover o arquivo dentro do mesmo volume. Isso inclui ACEs herdadas, que se tornam ACEs diretas quando movido (direto ACEs têm precedência sobre as ACEs herdadas). Se um arquivo for movido entre volumes, as ACEs não serão copiadas.  
  
 A tabela a seguir lista um exemplo de uma tarefa que envolvem o `My.Computer.FileSystem.MoveFile` método.  
  
|Para|Consulte|  
|-|-|  
|Mover um arquivo|[Como: mover um arquivo no Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-move-a-file.md)|  
  
   
  
## Examples  
 Este exemplo move o arquivo `Test.txt` partir `TestDir1` para `TestDir2`.  
  
 [!code-vb[VbVbcnMyFileSystem#86](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#86)]  
  
 Este exemplo move o arquivo `Test.txt` partir `TestDir1` para `TestDir2` e o renomeia `Test2.txt`.  
  
 [!code-vb[VbVbcnMyFileSystem#87](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#87)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">O caminho não é válido por um dos seguintes motivos: é uma cadeia de tamanho zero, contém apenas espaços em branco, contém caracteres inválidos ou é um caminho de dispositivo (começa com \\\\.\\); ele termina com uma barra à direita.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="destinationFileName" /> é <see langword="Nothing" /> ou é uma cadeia de caracteres vazia.</exception>
        <exception cref="T:System.IO.FileNotFoundException">O arquivo de origem não é válido ou não existe.</exception>
        <exception cref="T:System.IO.IOException">O arquivo está sendo usado por outro processo, ou ocorre um erro de E/S.</exception>
        <exception cref="T:System.IO.PathTooLongException">O caminho excede o tamanho máximo definido pelo sistema.</exception>
        <exception cref="T:System.NotSupportedException">Um nome de arquivo ou de diretório no caminho contém dois-pontos (:) ou está em um formato inválido.</exception>
        <exception cref="T:System.Security.SecurityException">O usuário não tem as permissões necessárias para exibir o caminho.</exception>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">Controla a capacidade de acessar todas as variáveis de ambiente. Enumeração associada: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Controla a capacidade de acessar arquivos e pastas. Enumeração associada: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <permission cref="T:System.Security.Permissions.RegistryPermission">Controla a capacidade de acessar variáveis de Registro. Enumeração associada: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="MoveFile">
      <MemberSignature Language="C#" Value="public static void MoveFile (string sourceFileName, string destinationFileName, Microsoft.VisualBasic.FileIO.UIOption showUI);" />
      <MemberSignature Language="ILAsm" Value=".method public static void MoveFile(string sourceFileName, string destinationFileName, valuetype Microsoft.VisualBasic.FileIO.UIOption showUI) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.MoveFile(System.String,System.String,Microsoft.VisualBasic.FileIO.UIOption)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub MoveFile (sourceFileName As String, destinationFileName As String, showUI As UIOption)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void MoveFile(System::String ^ sourceFileName, System::String ^ destinationFileName, Microsoft::VisualBasic::FileIO::UIOption showUI);" />
      <MemberSignature Language="F#" Value="static member MoveFile : string * string * Microsoft.VisualBasic.FileIO.UIOption -&gt; unit" Usage="Microsoft.VisualBasic.FileIO.FileSystem.MoveFile (sourceFileName, destinationFileName, showUI)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceFileName" Type="System.String" />
        <Parameter Name="destinationFileName" Type="System.String" />
        <Parameter Name="showUI" Type="Microsoft.VisualBasic.FileIO.UIOption" />
      </Parameters>
      <Docs>
        <param name="sourceFileName">Caminho do arquivo a ser movido.</param>
        <param name="destinationFileName">Caminho do diretório para o qual o arquivo deve ser movido.</param>
        <param name="showUI">Especifica se o progresso da operação deve ser acompanhado visualmente. O padrão é <see langword="UIOption.OnlyErrorDialogs" />.</param>
        <summary>Move um arquivo para um novo local.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se a estrutura de destino não existir, ele é criado.  
  
 O `MoveFile` método preserva as ACEs (entradas de controle de acesso) apenas ao mover o arquivo dentro do mesmo volume. Isso inclui ACEs herdadas, que se tornam ACEs diretas quando movido (direto ACEs têm precedência sobre as ACEs herdadas). Se um arquivo for movido entre volumes, as ACEs não serão copiadas.  
  
 A tabela a seguir lista um exemplo de uma tarefa que envolvem o `My.Computer.FileSystem.MoveFile` método.  
  
|Para|Consulte|  
|-|-|  
|Mover um arquivo|[Como: mover um arquivo no Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-move-a-file.md)|  
  
   
  
## Examples  
 Este exemplo move o arquivo `Test.txt` partir `TestDir1` para `TestDir2`.  
  
 [!code-vb[VbVbcnMyFileSystem#86](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#86)]  
  
 Este exemplo move o arquivo `Test.txt` partir `TestDir1` para `TestDir2` e o renomeia `Test2.txt`.  
  
 [!code-vb[VbVbcnMyFileSystem#87](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#87)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">O caminho não é válido por um dos seguintes motivos: é uma cadeia de tamanho zero, contém apenas espaços em branco, contém caracteres inválidos ou é um caminho de dispositivo (começa com \\\\.\\); ele termina com uma barra à direita.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="destinationFileName" /> é <see langword="Nothing" /> ou é uma cadeia de caracteres vazia.</exception>
        <exception cref="T:System.IO.FileNotFoundException">O arquivo de origem não é válido ou não existe.</exception>
        <exception cref="T:System.IO.IOException">O arquivo está sendo usado por outro processo, ou ocorre um erro de E/S.</exception>
        <exception cref="T:System.IO.PathTooLongException">O caminho excede o tamanho máximo definido pelo sistema.</exception>
        <exception cref="T:System.NotSupportedException">Um nome de arquivo ou de diretório no caminho contém dois-pontos (:) ou está em um formato inválido.</exception>
        <exception cref="T:System.Security.SecurityException">O usuário não tem as permissões necessárias para exibir o caminho.</exception>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">Controla a capacidade de acessar todas as variáveis de ambiente. Enumeração associada: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Controla a capacidade de acessar arquivos e pastas. Enumeração associada: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <permission cref="T:System.Security.Permissions.RegistryPermission">Controla a capacidade de acessar variáveis de Registro. Enumeração associada: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <permission cref="T:System.Security.Permissions.UIPermission">Controla as permissões relacionadas às interfaces de usuário e a área de transferência. Enumeração associada: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeSubWindows" />.</permission>
        <altmember cref="T:Microsoft.VisualBasic.FileIO.UIOption" />
      </Docs>
    </Member>
    <Member MemberName="MoveFile">
      <MemberSignature Language="C#" Value="public static void MoveFile (string sourceFileName, string destinationFileName, bool overwrite);" />
      <MemberSignature Language="ILAsm" Value=".method public static void MoveFile(string sourceFileName, string destinationFileName, bool overwrite) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.MoveFile(System.String,System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub MoveFile (sourceFileName As String, destinationFileName As String, overwrite As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void MoveFile(System::String ^ sourceFileName, System::String ^ destinationFileName, bool overwrite);" />
      <MemberSignature Language="F#" Value="static member MoveFile : string * string * bool -&gt; unit" Usage="Microsoft.VisualBasic.FileIO.FileSystem.MoveFile (sourceFileName, destinationFileName, overwrite)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceFileName" Type="System.String" />
        <Parameter Name="destinationFileName" Type="System.String" />
        <Parameter Name="overwrite" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="sourceFileName">Caminho do arquivo a ser movido.</param>
        <param name="destinationFileName">Caminho do diretório para o qual o arquivo deve ser movido.</param>
        <param name="overwrite">
          <see langword="True" /> para substituir arquivos existentes; caso contrário, <see langword="False" />. O padrão é <see langword="False" />.</param>
        <summary>Move um arquivo para um novo local.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se a estrutura de destino não existir, ele é criado.  
  
 O `MoveFile` método preserva as ACEs (entradas de controle de acesso) apenas ao mover o arquivo dentro do mesmo volume. Isso inclui ACEs herdadas, que se tornam ACEs diretas quando movido (direto ACEs têm precedência sobre as ACEs herdadas). Se um arquivo for movido entre volumes, as ACEs não serão copiadas.  
  
 A tabela a seguir lista um exemplo de uma tarefa que envolvem o `My.Computer.FileSystem.MoveFile` método.  
  
|Para|Consulte|  
|-|-|  
|Mover um arquivo|[Como: mover um arquivo no Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-move-a-file.md)|  
  
   
  
## Examples  
 Este exemplo move o arquivo `Test.txt` partir `TestDir1` para `TestDir2`.  
  
 [!code-vb[VbVbcnMyFileSystem#86](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#86)]  
  
 Este exemplo move o arquivo `Test.txt` partir `TestDir1` para `TestDir2` e o renomeia `Test2.txt`.  
  
 [!code-vb[VbVbcnMyFileSystem#87](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#87)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">O caminho não é válido por um dos seguintes motivos: é uma cadeia de tamanho zero, contém apenas espaços em branco, contém caracteres inválidos ou é um caminho de dispositivo (começa com \\\\.\\); ele termina com uma barra à direita.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="destinationFileName" /> é <see langword="Nothing" /> ou é uma cadeia de caracteres vazia.</exception>
        <exception cref="T:System.IO.FileNotFoundException">O arquivo de origem não é válido ou não existe.</exception>
        <exception cref="T:System.IO.IOException">O arquivo está sendo usado por outro processo, ou ocorre um erro de E/S.</exception>
        <exception cref="T:System.IO.PathTooLongException">O caminho excede o tamanho máximo definido pelo sistema.</exception>
        <exception cref="T:System.NotSupportedException">Um nome de arquivo ou de diretório no caminho contém dois-pontos (:) ou está em um formato inválido.</exception>
        <exception cref="T:System.Security.SecurityException">O usuário não tem as permissões necessárias para exibir o caminho.</exception>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">Controla a capacidade de acessar todas as variáveis de ambiente. Enumeração associada: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Controla a capacidade de acessar arquivos e pastas. Enumeração associada: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <permission cref="T:System.Security.Permissions.RegistryPermission">Controla a capacidade de acessar variáveis de Registro. Enumeração associada: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="MoveFile">
      <MemberSignature Language="C#" Value="public static void MoveFile (string sourceFileName, string destinationFileName, Microsoft.VisualBasic.FileIO.UIOption showUI, Microsoft.VisualBasic.FileIO.UICancelOption onUserCancel);" />
      <MemberSignature Language="ILAsm" Value=".method public static void MoveFile(string sourceFileName, string destinationFileName, valuetype Microsoft.VisualBasic.FileIO.UIOption showUI, valuetype Microsoft.VisualBasic.FileIO.UICancelOption onUserCancel) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.MoveFile(System.String,System.String,Microsoft.VisualBasic.FileIO.UIOption,Microsoft.VisualBasic.FileIO.UICancelOption)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub MoveFile (sourceFileName As String, destinationFileName As String, showUI As UIOption, onUserCancel As UICancelOption)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void MoveFile(System::String ^ sourceFileName, System::String ^ destinationFileName, Microsoft::VisualBasic::FileIO::UIOption showUI, Microsoft::VisualBasic::FileIO::UICancelOption onUserCancel);" />
      <MemberSignature Language="F#" Value="static member MoveFile : string * string * Microsoft.VisualBasic.FileIO.UIOption * Microsoft.VisualBasic.FileIO.UICancelOption -&gt; unit" Usage="Microsoft.VisualBasic.FileIO.FileSystem.MoveFile (sourceFileName, destinationFileName, showUI, onUserCancel)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceFileName" Type="System.String" />
        <Parameter Name="destinationFileName" Type="System.String" />
        <Parameter Name="showUI" Type="Microsoft.VisualBasic.FileIO.UIOption" />
        <Parameter Name="onUserCancel" Type="Microsoft.VisualBasic.FileIO.UICancelOption" />
      </Parameters>
      <Docs>
        <param name="sourceFileName">Caminho do arquivo a ser movido.</param>
        <param name="destinationFileName">Caminho do diretório para o qual o arquivo deve ser movido.</param>
        <param name="showUI">Especifica se o progresso da operação deve ser acompanhado visualmente. O padrão é <see langword="UIOption.OnlyErrorDialogs" />.</param>
        <param name="onUserCancel">Especifica se uma exceção é lançada ou não quando o usuário cancela a operação. O padrão é <see langword="UICancelOption.ThrowException" />.</param>
        <summary>Move um arquivo para um novo local.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se a estrutura de destino não existir, ele é criado.  
  
 O `MoveFile` método preserva as ACEs (entradas de controle de acesso) apenas ao mover o arquivo dentro do mesmo volume. Isso inclui ACEs herdadas, que se tornam ACEs diretas quando movido (direto ACEs têm precedência sobre as ACEs herdadas). Se um arquivo for movido entre volumes, as ACEs não serão copiadas.  
  
 A tabela a seguir lista um exemplo de uma tarefa que envolvem o `My.Computer.FileSystem.MoveFile` método.  
  
|Para|Consulte|  
|-|-|  
|Mover um arquivo|[Como: mover um arquivo no Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-move-a-file.md)|  
  
   
  
## Examples  
 Este exemplo move o arquivo `Test.txt` partir `TestDir1` para `TestDir2`.  
  
 [!code-vb[VbVbcnMyFileSystem#86](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#86)]  
  
 Este exemplo move o arquivo `Test.txt` partir `TestDir1` para `TestDir2` e o renomeia `Test2.txt`.  
  
 [!code-vb[VbVbcnMyFileSystem#87](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#87)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">O caminho não é válido por um dos seguintes motivos: é uma cadeia de tamanho zero, contém apenas espaços em branco, contém caracteres inválidos ou é um caminho de dispositivo (começa com \\\\.\\); ele termina com uma barra à direita.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="destinationFileName" /> é <see langword="Nothing" /> ou é uma cadeia de caracteres vazia.</exception>
        <exception cref="T:System.IO.FileNotFoundException">O arquivo de origem não é válido ou não existe.</exception>
        <exception cref="T:System.IO.IOException">O arquivo está sendo usado por outro processo, ou ocorre um erro de E/S.</exception>
        <exception cref="T:System.OperationCanceledException">
          <paramref name="onUserCancel" /> é definido como <see langword="ThrowException" /> e o usuário cancelou a operação ou ocorreu um erro de E/S não especificado.</exception>
        <exception cref="T:System.IO.PathTooLongException">O caminho excede o tamanho máximo definido pelo sistema.</exception>
        <exception cref="T:System.NotSupportedException">Um nome de arquivo ou de diretório no caminho contém dois-pontos (:) ou está em um formato inválido.</exception>
        <exception cref="T:System.Security.SecurityException">O usuário não tem as permissões necessárias para exibir o caminho.</exception>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">Controla a capacidade de acessar todas as variáveis de ambiente. Enumeração associada: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Controla a capacidade de acessar arquivos e pastas. Enumeração associada: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <permission cref="T:System.Security.Permissions.RegistryPermission">Controla a capacidade de acessar variáveis de Registro. Enumeração associada: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <permission cref="T:System.Security.Permissions.UIPermission">Controla as permissões relacionadas às interfaces de usuário e a área de transferência. Enumeração associada: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeSubWindows" />.</permission>
        <altmember cref="T:Microsoft.VisualBasic.FileIO.UIOption" />
        <altmember cref="T:Microsoft.VisualBasic.FileIO.UICancelOption" />
      </Docs>
    </Member>
    <MemberGroup MemberName="OpenTextFieldParser">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>O método <see langword="OpenTextFieldParser" /> permite criar um objeto <see cref="T:Microsoft.VisualBasic.FileIO.TextFieldParser" />, que fornece uma maneira fácil e eficiente de analisar os arquivos de texto estruturados, como logs. O objeto <see langword="TextFieldParser" /> pode ser usado para ler arquivos delimitados e de largura fixa.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="OpenTextFieldParser">
      <MemberSignature Language="C#" Value="public static Microsoft.VisualBasic.FileIO.TextFieldParser OpenTextFieldParser (string file);" />
      <MemberSignature Language="ILAsm" Value=".method public static class Microsoft.VisualBasic.FileIO.TextFieldParser OpenTextFieldParser(string file) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.OpenTextFieldParser(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OpenTextFieldParser (file As String) As TextFieldParser" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Microsoft::VisualBasic::FileIO::TextFieldParser ^ OpenTextFieldParser(System::String ^ file);" />
      <MemberSignature Language="F#" Value="static member OpenTextFieldParser : string -&gt; Microsoft.VisualBasic.FileIO.TextFieldParser" Usage="Microsoft.VisualBasic.FileIO.FileSystem.OpenTextFieldParser file" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.VisualBasic.FileIO.TextFieldParser</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="file" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="file">O arquivo a ser aberto com o <see langword="TextFieldParser" />.</param>
        <summary>O método <see langword="OpenTextFieldParser" /> permite que você crie um objeto <see cref="T:Microsoft.VisualBasic.FileIO.TextFieldParser" />, que fornece uma maneira de analisar fácil e eficientemente os arquivos de texto estruturado, como logs. O objeto <see langword="TextFieldParser" /> pode ser usado para ler arquivos delimitados e de largura fixa.</summary>
        <returns>
          <see cref="T:Microsoft.VisualBasic.FileIO.TextFieldParser" /> para ler o arquivo especificado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista exemplos de tarefas que envolvem o `My.Computer.FileSystem.OpenTextFieldParser` método.  
  
|Para|Consulte|  
|-|-|  
|Ler um arquivo de texto delimitado|[Como: ler de arquivos de texto delimitado por vírgulas no Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-from-comma-delimited-text-files.md)|  
|Ler um arquivo de texto de largura fixa|[Como: ler de arquivos de texto de largura fixa no Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-from-fixed-width-text-files.md)|  
|Ler um arquivo de texto com vários formatos|[Como: ler arquivos de texto com vários formatos no Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-from-text-files-with-multiple-formats.md)|  
  
   
  
## Examples  
 Este exemplo abre o `TextFieldParser.reader` e o usa para ler de `C:\TestFolder1\Test1.txt`.  
  
 [!code-vb[VbRefFile#18](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#18)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">O caminho não é válido por um dos seguintes motivos: é uma cadeia de tamanho zero, contém apenas espaços em branco, contém caracteres inválidos ou é um caminho de dispositivo (começa com \\\\.\\); ele termina com uma barra à direita.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="file" /> é <see langword="Nothing" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">O arquivo não existe.</exception>
        <exception cref="T:System.IO.IOException">O arquivo está sendo usado por outro processo, ou ocorre um erro de E/S.</exception>
        <exception cref="T:System.IO.PathTooLongException">O caminho excede o tamanho máximo definido pelo sistema.</exception>
        <exception cref="T:System.NotSupportedException">Um nome de arquivo ou de diretório no caminho contém dois-pontos (:) ou está em um formato inválido.</exception>
        <exception cref="T:Microsoft.VisualBasic.FileIO.MalformedLineException">Não é possível analisar uma linha usando o formato especificado. A mensagem de exceção especifica a linha causando a exceção, enquanto a propriedade <see cref="P:Microsoft.VisualBasic.FileIO.TextFieldParser.ErrorLine" /> é atribuída ao texto contido na linha.</exception>
        <exception cref="T:System.Security.SecurityException">O usuário não tem as permissões necessárias para exibir o caminho.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Controla a capacidade de acessar arquivos e pastas. Enumeração associada: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Descreve um conjunto de permissões de segurança aplicadas ao código. Enumeração associada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</permission>
        <altmember cref="T:Microsoft.VisualBasic.FileIO.TextFieldParser" />
      </Docs>
    </Member>
    <Member MemberName="OpenTextFieldParser">
      <MemberSignature Language="C#" Value="public static Microsoft.VisualBasic.FileIO.TextFieldParser OpenTextFieldParser (string file, params int[] fieldWidths);" />
      <MemberSignature Language="ILAsm" Value=".method public static class Microsoft.VisualBasic.FileIO.TextFieldParser OpenTextFieldParser(string file, int32[] fieldWidths) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.OpenTextFieldParser(System.String,System.Int32[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OpenTextFieldParser (file As String, ParamArray fieldWidths As Integer()) As TextFieldParser" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Microsoft::VisualBasic::FileIO::TextFieldParser ^ OpenTextFieldParser(System::String ^ file, ... cli::array &lt;int&gt; ^ fieldWidths);" />
      <MemberSignature Language="F#" Value="static member OpenTextFieldParser : string * int[] -&gt; Microsoft.VisualBasic.FileIO.TextFieldParser" Usage="Microsoft.VisualBasic.FileIO.FileSystem.OpenTextFieldParser (file, fieldWidths)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.VisualBasic.FileIO.TextFieldParser</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="file" Type="System.String" />
        <Parameter Name="fieldWidths" Type="System.Int32[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="file">O arquivo a ser aberto com o <see langword="TextFieldParser" />.</param>
        <param name="fieldWidths">Larguras dos campos.</param>
        <summary>O método <see langword="OpenTextFieldParser" /> permite criar um objeto <see cref="T:Microsoft.VisualBasic.FileIO.TextFieldParser" />, que fornece uma maneira fácil e eficiente de analisar os arquivos de texto estruturados, como logs. O objeto <see langword="TextFieldParser" /> pode ser usado para ler arquivos delimitados e de largura fixa.</summary>
        <returns>
          <see cref="T:Microsoft.VisualBasic.FileIO.TextFieldParser" /> para ler o arquivo especificado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista exemplos de tarefas que envolvem o `My.Computer.FileSystem.OpenTextFieldParser` método.  
  
|Para|Consulte|  
|-|-|  
|Ler um arquivo de texto delimitado|[Como: ler de arquivos de texto delimitado por vírgulas no Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-from-comma-delimited-text-files.md)|  
|Ler um arquivo de texto de largura fixa|[Como: ler de arquivos de texto de largura fixa no Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-from-fixed-width-text-files.md)|  
|Ler um arquivo de texto com vários formatos|[Como: ler arquivos de texto com vários formatos no Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-from-text-files-with-multiple-formats.md)|  
  
   
  
## Examples  
 Este exemplo abre o `TextFieldParser.reader` e o usa para ler de `C:\TestFolder1\Test1.txt`.  
  
 [!code-vb[VbRefFile#18](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#18)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">O caminho não é válido por um dos seguintes motivos: é uma cadeia de tamanho zero, contém apenas espaços em branco, contém caracteres inválidos ou é um caminho de dispositivo (começa com \\\\.\\); ele termina com uma barra à direita.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="file" /> é <see langword="Nothing" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">O arquivo não existe.</exception>
        <exception cref="T:System.IO.IOException">O arquivo está sendo usado por outro processo, ou ocorre um erro de E/S.</exception>
        <exception cref="T:System.IO.PathTooLongException">O caminho excede o tamanho máximo definido pelo sistema.</exception>
        <exception cref="T:System.NotSupportedException">Um nome de arquivo ou de diretório no caminho contém dois-pontos (:) ou está em um formato inválido.</exception>
        <exception cref="T:Microsoft.VisualBasic.FileIO.MalformedLineException">Não é possível analisar uma linha usando o formato especificado. A mensagem de exceção especifica a linha causando a exceção, enquanto a propriedade <see cref="P:Microsoft.VisualBasic.FileIO.TextFieldParser.ErrorLine" /> é atribuída ao texto contido na linha.</exception>
        <exception cref="T:System.Security.SecurityException">O usuário não tem as permissões necessárias para exibir o caminho.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Controla a capacidade de acessar arquivos e pastas. Enumeração associada: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Descreve um conjunto de permissões de segurança aplicadas ao código. Enumeração associada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</permission>
        <altmember cref="T:Microsoft.VisualBasic.FileIO.TextFieldParser" />
      </Docs>
    </Member>
    <Member MemberName="OpenTextFieldParser">
      <MemberSignature Language="C#" Value="public static Microsoft.VisualBasic.FileIO.TextFieldParser OpenTextFieldParser (string file, params string[] delimiters);" />
      <MemberSignature Language="ILAsm" Value=".method public static class Microsoft.VisualBasic.FileIO.TextFieldParser OpenTextFieldParser(string file, string[] delimiters) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.OpenTextFieldParser(System.String,System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OpenTextFieldParser (file As String, ParamArray delimiters As String()) As TextFieldParser" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Microsoft::VisualBasic::FileIO::TextFieldParser ^ OpenTextFieldParser(System::String ^ file, ... cli::array &lt;System::String ^&gt; ^ delimiters);" />
      <MemberSignature Language="F#" Value="static member OpenTextFieldParser : string * string[] -&gt; Microsoft.VisualBasic.FileIO.TextFieldParser" Usage="Microsoft.VisualBasic.FileIO.FileSystem.OpenTextFieldParser (file, delimiters)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.VisualBasic.FileIO.TextFieldParser</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="file" Type="System.String" />
        <Parameter Name="delimiters" Type="System.String[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="file">O arquivo a ser aberto com o <see langword="TextFieldParser" />.</param>
        <param name="delimiters">Delimitadores para os campos.</param>
        <summary>O método <see langword="OpenTextFieldParser" /> permite criar um objeto <see cref="T:Microsoft.VisualBasic.FileIO.TextFieldParser" />, que fornece uma maneira fácil e eficiente de analisar os arquivos de texto estruturados, como logs. O objeto <see langword="TextFieldParser" /> pode ser usado para ler arquivos delimitados e de largura fixa.</summary>
        <returns>
          <see cref="T:Microsoft.VisualBasic.FileIO.TextFieldParser" /> para ler o arquivo especificado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista exemplos de tarefas que envolvem o `My.Computer.FileSystem.OpenTextFieldParser` método.  
  
|Para|Consulte|  
|-|-|  
|Ler um arquivo de texto delimitado|[Como: ler de arquivos de texto delimitado por vírgulas no Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-from-comma-delimited-text-files.md)|  
|Ler um arquivo de texto de largura fixa|[Como: ler de arquivos de texto de largura fixa no Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-from-fixed-width-text-files.md)|  
|Ler um arquivo de texto com vários formatos|[Como: ler arquivos de texto com vários formatos no Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-from-text-files-with-multiple-formats.md)|  
  
   
  
## Examples  
 Este exemplo abre o `TextFieldParser.reader` e o usa para ler de `C:\TestFolder1\Test1.txt`.  
  
 [!code-vb[VbRefFile#18](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#18)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">O caminho não é válido por um dos seguintes motivos: é uma cadeia de tamanho zero, contém apenas espaços em branco, contém caracteres inválidos ou é um caminho de dispositivo (começa com \\\\.\\); ele termina com uma barra à direita.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="file" /> é <see langword="Nothing" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">O arquivo não existe.</exception>
        <exception cref="T:System.IO.IOException">O arquivo está sendo usado por outro processo, ou ocorre um erro de E/S.</exception>
        <exception cref="T:System.IO.PathTooLongException">O caminho excede o tamanho máximo definido pelo sistema.</exception>
        <exception cref="T:System.NotSupportedException">Um nome de arquivo ou de diretório no caminho contém dois-pontos (:) ou está em um formato inválido.</exception>
        <exception cref="T:Microsoft.VisualBasic.FileIO.MalformedLineException">Não é possível analisar uma linha usando o formato especificado. A mensagem de exceção especifica a linha causando a exceção, enquanto a propriedade <see cref="P:Microsoft.VisualBasic.FileIO.TextFieldParser.ErrorLine" /> é atribuída ao texto contido na linha.</exception>
        <exception cref="T:System.Security.SecurityException">O usuário não tem as permissões necessárias para exibir o caminho.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Controla a capacidade de acessar arquivos e pastas. Enumeração associada: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Descreve um conjunto de permissões de segurança aplicadas ao código. Enumeração associada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</permission>
        <altmember cref="T:Microsoft.VisualBasic.FileIO.TextFieldParser" />
      </Docs>
    </Member>
    <MemberGroup MemberName="OpenTextFileReader">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Abre um objeto <see cref="T:System.IO.StreamReader" /> para ser lido de um arquivo.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="OpenTextFileReader">
      <MemberSignature Language="C#" Value="public static System.IO.StreamReader OpenTextFileReader (string file);" />
      <MemberSignature Language="ILAsm" Value=".method public static class System.IO.StreamReader OpenTextFileReader(string file) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.OpenTextFileReader(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OpenTextFileReader (file As String) As StreamReader" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::StreamReader ^ OpenTextFileReader(System::String ^ file);" />
      <MemberSignature Language="F#" Value="static member OpenTextFileReader : string -&gt; System.IO.StreamReader" Usage="Microsoft.VisualBasic.FileIO.FileSystem.OpenTextFileReader file" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.StreamReader</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="file" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="file">O arquivo a ser lido.</param>
        <summary>Abre um objeto <see cref="T:System.IO.StreamReader" /> para ser lido de um arquivo.</summary>
        <returns>O objeto <see cref="T:System.IO.StreamReader" /> a ser lido do arquivo</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Somente arquivos de texto podem ser lidos com um <xref:System.IO.StreamReader>.  
  
 A tabela a seguir lista um exemplo de uma tarefa que envolvem o `My.Computer.FileSystem.OpenTextFileReader` método.  
  
|Para|Consulte|  
|-|-|  
|Abrir um arquivo com um <xref:System.IO.StreamReader>|[Como: ler texto de arquivos com um StreamReader (Visual Basic)](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-text-from-files-with-a-streamreader.md)|  
  
   
  
## Examples  
 Este exemplo abre o arquivo `Testfile.txt`, lê uma linha a partir dele e exibe a linha em um `MessageBox`.  
  
 [!code-vb[VbRefFile#2](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">O nome do arquivo termina com uma barra invertida (\\).</exception>
        <exception cref="T:System.IO.FileNotFoundException">Não foi possível localizar o arquivo especificado.</exception>
        <exception cref="T:System.Security.SecurityException">O usuário não tem as permissões necessárias para ler o arquivo.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Controla a capacidade de acessar arquivos e pastas. Enumeração associada: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <altmember cref="T:System.Text.Encoding" />
        <altmember cref="T:System.IO.StreamReader" />
      </Docs>
    </Member>
    <Member MemberName="OpenTextFileReader">
      <MemberSignature Language="C#" Value="public static System.IO.StreamReader OpenTextFileReader (string file, System.Text.Encoding encoding);" />
      <MemberSignature Language="ILAsm" Value=".method public static class System.IO.StreamReader OpenTextFileReader(string file, class System.Text.Encoding encoding) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.OpenTextFileReader(System.String,System.Text.Encoding)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::StreamReader ^ OpenTextFileReader(System::String ^ file, System::Text::Encoding ^ encoding);" />
      <MemberSignature Language="F#" Value="static member OpenTextFileReader : string * System.Text.Encoding -&gt; System.IO.StreamReader" Usage="Microsoft.VisualBasic.FileIO.FileSystem.OpenTextFileReader (file, encoding)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.StreamReader</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="file" Type="System.String" />
        <Parameter Name="encoding" Type="System.Text.Encoding" />
      </Parameters>
      <Docs>
        <param name="file">O arquivo a ser lido.</param>
        <param name="encoding">A codificação a ser usada nos conteúdos de arquivo. O padrão é ASCII.</param>
        <summary>Abre um objeto <see cref="T:System.IO.StreamReader" /> para ser lido de um arquivo.</summary>
        <returns>O objeto <see cref="T:System.IO.StreamReader" /> a ser lido do arquivo</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Somente arquivos de texto podem ser lidos com um <xref:System.IO.StreamReader>.  
  
 A tabela a seguir lista um exemplo de uma tarefa que envolvem o `My.Computer.FileSystem.OpenTextFileReader` método.  
  
|Para|Consulte|  
|-|-|  
|Abrir um arquivo com um <xref:System.IO.StreamReader>|[Como: ler texto de arquivos com um StreamReader (Visual Basic)](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-text-from-files-with-a-streamreader.md)|  
  
   
  
## Examples  
 Este exemplo abre o arquivo `Testfile.txt`, lê uma linha a partir dele e exibe a linha em um `MessageBox`.  
  
 [!code-vb[VbRefFile#2](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">O nome do arquivo termina com uma barra invertida (\\).</exception>
        <exception cref="T:System.IO.FileNotFoundException">Não foi possível localizar o arquivo especificado.</exception>
        <exception cref="T:System.Security.SecurityException">O usuário não tem as permissões necessárias para ler o arquivo.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Controla a capacidade de acessar arquivos e pastas. Enumeração associada: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <altmember cref="T:System.Text.Encoding" />
        <altmember cref="T:System.IO.StreamReader" />
      </Docs>
    </Member>
    <MemberGroup MemberName="OpenTextFileWriter">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Abre um objeto <see cref="T:System.IO.StreamWriter" /> no qual o arquivo especificado será gravado.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="OpenTextFileWriter">
      <MemberSignature Language="C#" Value="public static System.IO.StreamWriter OpenTextFileWriter (string file, bool append);" />
      <MemberSignature Language="ILAsm" Value=".method public static class System.IO.StreamWriter OpenTextFileWriter(string file, bool append) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.OpenTextFileWriter(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OpenTextFileWriter (file As String, append As Boolean) As StreamWriter" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::StreamWriter ^ OpenTextFileWriter(System::String ^ file, bool append);" />
      <MemberSignature Language="F#" Value="static member OpenTextFileWriter : string * bool -&gt; System.IO.StreamWriter" Usage="Microsoft.VisualBasic.FileIO.FileSystem.OpenTextFileWriter (file, append)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.StreamWriter</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="file" Type="System.String" />
        <Parameter Name="append" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="file">Arquivo para gravação.</param>
        <param name="append">
          <see langword="True" /> para acrescentar ao conteúdo do arquivo; <see langword="False" /> para substituir o conteúdo do arquivo. O padrão é <see langword="False" />.</param>
        <summary>Abre um objeto <see cref="T:System.IO.StreamWriter" /> no qual o arquivo especificado será gravado.</summary>
        <returns>Objeto <see cref="T:System.IO.StreamWriter" /> no qual o arquivo especificado será gravado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O `OpenTextFileWriter` método abre e inicializa um fluxo de um arquivo e, em seguida, retorna o <xref:System.IO.StreamWriter> objeto para esse fluxo. Você pode gravar no fluxo quantas vezes forem necessárias e, em seguida, feche-o quando tiver terminado.  
  
> [!NOTE]
>  Você deve chamar o <xref:System.IO.StreamWriter.Close%2A> método no <xref:System.IO.StreamWriter> objeto para certificar-se de que todos os dados são gravados corretamente no fluxo subjacente.  
  
 Se você estiver escrevendo apenas algumas cadeias de caracteres em um arquivo, talvez seja mais simples de usar o <xref:Microsoft.VisualBasic.FileIO.FileSystem.WriteAllText%2A> método.  
  
 A tabela a seguir lista um exemplo de uma tarefa que envolvem o `My.Computer.FileSystem.OpenTextFileWriter` método.  
  
|Para|Consulte|  
|-|-|  
|Gravar texto em um arquivo com um `StreamWriter`|[Como: gravar texto em arquivos com um StreamWriter no Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files-with-a-streamwriter.md)|  
  
   
  
## Examples  
 Este exemplo abre um <xref:System.IO.StreamWriter> com o `My.Computer.FileSystem.OpenTextFileWriter` método e o usa para gravar uma cadeia de caracteres em um arquivo de texto com o `WriteLine` método da `StreamWriter` classe.  
  
 [!code-vb[VbRefFile#14](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#14)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">O nome do arquivo termina com uma barra.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Controla a capacidade de acessar arquivos e pastas. Enumeração associada: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <altmember cref="T:System.Text.Encoding" />
        <altmember cref="T:System.IO.StreamWriter" />
      </Docs>
    </Member>
    <Member MemberName="OpenTextFileWriter">
      <MemberSignature Language="C#" Value="public static System.IO.StreamWriter OpenTextFileWriter (string file, bool append, System.Text.Encoding encoding);" />
      <MemberSignature Language="ILAsm" Value=".method public static class System.IO.StreamWriter OpenTextFileWriter(string file, bool append, class System.Text.Encoding encoding) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.OpenTextFileWriter(System.String,System.Boolean,System.Text.Encoding)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::StreamWriter ^ OpenTextFileWriter(System::String ^ file, bool append, System::Text::Encoding ^ encoding);" />
      <MemberSignature Language="F#" Value="static member OpenTextFileWriter : string * bool * System.Text.Encoding -&gt; System.IO.StreamWriter" Usage="Microsoft.VisualBasic.FileIO.FileSystem.OpenTextFileWriter (file, append, encoding)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.StreamWriter</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="file" Type="System.String" />
        <Parameter Name="append" Type="System.Boolean" />
        <Parameter Name="encoding" Type="System.Text.Encoding" />
      </Parameters>
      <Docs>
        <param name="file">Arquivo para gravação.</param>
        <param name="append">
          <see langword="True" /> para acrescentar ao conteúdo do arquivo; <see langword="False" /> para substituir o conteúdo do arquivo. O padrão é <see langword="False" />.</param>
        <param name="encoding">Codificação a ser usada na gravação no arquivo. O padrão é ASCII.</param>
        <summary>Abre um <see cref="T:System.IO.StreamWriter" /> para gravar no arquivo especificado.</summary>
        <returns>Objeto <see cref="T:System.IO.StreamWriter" /> no qual o arquivo especificado será gravado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O `OpenTextFileWriter` método abre e inicializa um fluxo de um arquivo e, em seguida, retorna o <xref:System.IO.StreamWriter> objeto para esse fluxo. Você pode gravar no fluxo quantas vezes forem necessárias e, em seguida, feche-o quando tiver terminado.  
  
> [!NOTE]
>  Você deve chamar o <xref:System.IO.StreamWriter.Close%2A> método no <xref:System.IO.StreamWriter> objeto para certificar-se de que todos os dados são gravados corretamente no fluxo subjacente.  
  
 Se você estiver escrevendo apenas algumas cadeias de caracteres em um arquivo, talvez seja mais simples de usar o <xref:Microsoft.VisualBasic.FileIO.FileSystem.WriteAllText%2A> método.  
  
 A tabela a seguir lista um exemplo de uma tarefa que envolvem o `My.Computer.FileSystem.OpenTextFileWriter` método.  
  
|Para|Consulte|  
|-|-|  
|Gravar texto em um arquivo com um `StreamWriter`|[Como: gravar texto em arquivos com um StreamWriter no Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files-with-a-streamwriter.md)|  
  
   
  
## Examples  
 Este exemplo abre um <xref:System.IO.StreamWriter> com o `My.Computer.FileSystem.OpenTextFileWriter` método e o usa para gravar uma cadeia de caracteres em um arquivo de texto com o `WriteLine` método da `StreamWriter` classe.  
  
 [!code-vb[VbRefFile#14](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#14)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">O nome do arquivo termina com uma barra.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Controla a capacidade de acessar arquivos e pastas. Enumeração associada: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <altmember cref="T:System.Text.Encoding" />
        <altmember cref="T:System.IO.StreamWriter" />
      </Docs>
    </Member>
    <Member MemberName="ReadAllBytes">
      <MemberSignature Language="C#" Value="public static byte[] ReadAllBytes (string file);" />
      <MemberSignature Language="ILAsm" Value=".method public static unsigned int8[] ReadAllBytes(string file) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.ReadAllBytes(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReadAllBytes (file As String) As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Byte&gt; ^ ReadAllBytes(System::String ^ file);" />
      <MemberSignature Language="F#" Value="static member ReadAllBytes : string -&gt; byte[]" Usage="Microsoft.VisualBasic.FileIO.FileSystem.ReadAllBytes file" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="file" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="file">O arquivo a ser lido.</param>
        <summary>Retorna o conteúdo de um arquivo como uma matriz de bytes.</summary>
        <returns>Uma matriz <see langword="Byte" /> que contém o conteúdo do arquivo.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O `ReadAllBytes` método da `My.Computer.FileSystem` objeto permite que você leia de um arquivo binário. O conteúdo do arquivo é retornado como uma matriz de bytes.  
  
 Não tome decisões sobre o conteúdo do arquivo com base no nome do arquivo. Por exemplo, o arquivo Form1.vb pode não ser um arquivo de código-fonte do Visual Basic. Verifique todas as entradas antes de usar os dados no seu aplicativo.  
  
 A tabela a seguir lista um exemplo de uma tarefa que envolvem o `My.Computer.FileSystem.ReadAllBytes` método.  
  
|Para|Consulte|  
|-|-|  
|Ler de um arquivo binário|[Como: ler em arquivos binários no Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-from-binary-files.md)|  
  
   
  
## Examples  
 Este exemplo lê do arquivo `C:/Documents and Settings/selfportrait.jpg.`  
  
 [!code-vb[VbVbcnMyFileSystem#33](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#33)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">O caminho não é válido por um dos seguintes motivos: é uma cadeia de tamanho zero, contém apenas espaços em branco, contém caracteres inválidos ou é um caminho de dispositivo (começa com \\\\.\\); ele termina com uma barra à direita.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="file" /> é <see langword="Nothing" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">O arquivo não existe.</exception>
        <exception cref="T:System.IO.IOException">O arquivo está sendo usado por outro processo, ou ocorre um erro de E/S.</exception>
        <exception cref="T:System.IO.PathTooLongException">O caminho excede o tamanho máximo definido pelo sistema.</exception>
        <exception cref="T:System.NotSupportedException">Um nome de arquivo ou de diretório no caminho contém dois-pontos (:) ou está em um formato inválido.</exception>
        <exception cref="T:System.OutOfMemoryException">Não há memória suficiente para gravar a cadeia de caracteres no buffer.</exception>
        <exception cref="T:System.Security.SecurityException">O usuário não tem as permissões necessárias para exibir o caminho.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Controla a capacidade de acessar arquivos e pastas. Enumeração associada: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="ReadAllText">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Retorna o conteúdo de um arquivo de texto como um <see langword="String" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReadAllText">
      <MemberSignature Language="C#" Value="public static string ReadAllText (string file);" />
      <MemberSignature Language="ILAsm" Value=".method public static string ReadAllText(string file) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.ReadAllText(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReadAllText (file As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ ReadAllText(System::String ^ file);" />
      <MemberSignature Language="F#" Value="static member ReadAllText : string -&gt; string" Usage="Microsoft.VisualBasic.FileIO.FileSystem.ReadAllText file" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="file" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="file">Nome e caminho do arquivo que será lido.</param>
        <summary>Retorna o conteúdo de um arquivo de texto como um <see langword="String" />.</summary>
        <returns>
          <see langword="String" /> que contém o conteúdo do arquivo.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O método `ReadAllText` do objeto `My.Computer.FileSystem` permite que você leia um arquivo de texto. O conteúdo do arquivo é retornado como uma cadeia de caracteres.  
  
 A codificação do arquivo pode ser especificado se o conteúdo do arquivo está em uma codificação, como ASCII ou UTF-8. Se você estiver lendo de um arquivo com caracteres estendidos, você precisa especificar a codificação do arquivo usando outra sobrecarga da <xref:Microsoft.VisualBasic.FileIO.FileSystem.ReadAllText%2A> método.  
  
 Não tome decisões sobre o conteúdo do arquivo com base no nome do arquivo. Por exemplo, o arquivo Form1.vb pode não ser um arquivo de código-fonte do Visual Basic. Verifique todas as entradas antes de usar os dados no seu aplicativo.  
  
 A tabela a seguir lista um exemplo de uma tarefa que envolvem o `My.Computer.FileSystem.ReadAllText` método.  
  
|Para|Consulte|  
|-|-|  
|Ler de um arquivo de texto|[Como: ler arquivos de texto no Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-from-text-files.md)|  
  
   
  
## Examples  
 Este exemplo lê o conteúdo de `Test.txt` em uma cadeia de caracteres e depois o exibe em uma caixa de mensagem.  
  
 [!code-vb[VbRefFile#8](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#8)]  
  
 Este exemplo lê o conteúdo de um arquivo ASCII `Test.txt` em uma cadeia de caracteres e depois o exibe em uma caixa de mensagem.  
  
 [!code-vb[VbRefFile#9](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#9)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">O caminho não é válido por um dos seguintes motivos: é uma cadeia de tamanho zero, contém apenas espaços em branco, contém caracteres inválidos ou é um caminho de dispositivo (começa com \\\\.\\); ele termina com uma barra à direita.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="file" /> é <see langword="Nothing" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">O arquivo não existe.</exception>
        <exception cref="T:System.IO.IOException">O arquivo está sendo usado por outro processo, ou ocorre um erro de E/S.</exception>
        <exception cref="T:System.IO.PathTooLongException">O caminho excede o tamanho máximo definido pelo sistema.</exception>
        <exception cref="T:System.NotSupportedException">Um nome de arquivo ou de diretório no caminho contém dois-pontos (:) ou está em um formato inválido.</exception>
        <exception cref="T:System.OutOfMemoryException">Não há memória suficiente para gravar a cadeia de caracteres no buffer.</exception>
        <exception cref="T:System.Security.SecurityException">O usuário não tem as permissões necessárias para exibir o caminho.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Controla a capacidade de acessar arquivos e pastas. Enumeração associada: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <altmember cref="T:System.Text.Encoding" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileIO.FileSystem.ReadAllText" />
        <altmember cref="M:System.IO.StreamReader.#ctor(System.IO.Stream,System.Text.Encoding)" />
      </Docs>
    </Member>
    <Member MemberName="ReadAllText">
      <MemberSignature Language="C#" Value="public static string ReadAllText (string file, System.Text.Encoding encoding);" />
      <MemberSignature Language="ILAsm" Value=".method public static string ReadAllText(string file, class System.Text.Encoding encoding) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.ReadAllText(System.String,System.Text.Encoding)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ ReadAllText(System::String ^ file, System::Text::Encoding ^ encoding);" />
      <MemberSignature Language="F#" Value="static member ReadAllText : string * System.Text.Encoding -&gt; string" Usage="Microsoft.VisualBasic.FileIO.FileSystem.ReadAllText (file, encoding)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="file" Type="System.String" />
        <Parameter Name="encoding" Type="System.Text.Encoding" />
      </Parameters>
      <Docs>
        <param name="file">Nome e caminho do arquivo que será lido.</param>
        <param name="encoding">A codificação de caracteres a ser usada na leitura do arquivo. O padrão é UTF-8.</param>
        <summary>Retorna o conteúdo de um arquivo de texto como um <see langword="String" />.</summary>
        <returns>
          <see langword="String" /> que contém o conteúdo do arquivo.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O método `ReadAllText` do objeto `My.Computer.FileSystem` permite que você leia um arquivo de texto. O conteúdo do arquivo é retornado como uma cadeia de caracteres.  
  
 A codificação do arquivo pode ser especificado se o conteúdo do arquivo está em uma codificação, como ASCII ou UTF-8. Se você estiver lendo de um arquivo com caracteres estendidos, você precisará especificar a codificação do arquivo.  
  
 Não tome decisões sobre o conteúdo do arquivo com base no nome do arquivo. Por exemplo, o arquivo Form1.vb pode não ser um arquivo de código-fonte do Visual Basic. Verifique todas as entradas antes de usar os dados no seu aplicativo.  
  
 A tabela a seguir lista um exemplo de uma tarefa que envolvem o `My.Computer.FileSystem.ReadAllText` método.  
  
|Para|Consulte|  
|-|-|  
|Ler de um arquivo de texto|[Como: ler arquivos de texto no Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-from-text-files.md)|  
  
   
  
## Examples  
 Este exemplo lê o conteúdo de `Test.txt` em uma cadeia de caracteres e depois o exibe em uma caixa de mensagem.  
  
 [!code-vb[VbRefFile#8](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#8)]  
  
 Este exemplo lê o conteúdo de um arquivo ASCII `Test.txt` em uma cadeia de caracteres e depois o exibe em uma caixa de mensagem.  
  
 [!code-vb[VbRefFile#9](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#9)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">O caminho não é válido por um dos seguintes motivos: é uma cadeia de tamanho zero, contém apenas espaços em branco, contém caracteres inválidos ou é um caminho de dispositivo (começa com \\\\.\\); ele termina com uma barra à direita.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="file" /> é <see langword="Nothing" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">O arquivo não existe.</exception>
        <exception cref="T:System.IO.IOException">O arquivo está sendo usado por outro processo, ou ocorre um erro de E/S.</exception>
        <exception cref="T:System.IO.PathTooLongException">O caminho excede o tamanho máximo definido pelo sistema.</exception>
        <exception cref="T:System.NotSupportedException">Um nome de arquivo ou de diretório no caminho contém dois-pontos (:) ou está em um formato inválido.</exception>
        <exception cref="T:System.OutOfMemoryException">Não há memória suficiente para gravar a cadeia de caracteres no buffer.</exception>
        <exception cref="T:System.Security.SecurityException">O usuário não tem as permissões necessárias para exibir o caminho.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Controla a capacidade de acessar arquivos e pastas. Enumeração associada: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <altmember cref="T:System.Text.Encoding" />
        <altmember cref="M:System.IO.StreamReader.#ctor(System.IO.Stream,System.Text.Encoding)" />
      </Docs>
    </Member>
    <Member MemberName="RenameDirectory">
      <MemberSignature Language="C#" Value="public static void RenameDirectory (string directory, string newName);" />
      <MemberSignature Language="ILAsm" Value=".method public static void RenameDirectory(string directory, string newName) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.RenameDirectory(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RenameDirectory (directory As String, newName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RenameDirectory(System::String ^ directory, System::String ^ newName);" />
      <MemberSignature Language="F#" Value="static member RenameDirectory : string * string -&gt; unit" Usage="Microsoft.VisualBasic.FileIO.FileSystem.RenameDirectory (directory, newName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="directory" Type="System.String" />
        <Parameter Name="newName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="directory">O caminho e nome do diretório a ser renomeado.</param>
        <param name="newName">Novo nome do diretório.</param>
        <summary>Renomeia um diretório.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método não pode ser usado para mover um diretório; Use o `MoveDirectory` método para mover e renomear o diretório.  
  
   
  
## Examples  
 Este exemplo renomeia o `Test` diretório `SecondTest`.  
  
 [!code-vb[VbVbcnMyFileSystem#13](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#13)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="newName" /> contém informações de caminho.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="directory" /> é <see langword="Nothing" />.  
  
- ou - 
 <paramref name="newName" /> é <see langword="Nothing" /> ou é uma cadeia de caracteres vazia.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">O diretório não existe.</exception>
        <exception cref="T:System.IO.IOException">Há um arquivo ou diretório existente com o nome especificado em <paramref name="newName" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">O caminho excede o tamanho máximo definido pelo sistema.</exception>
        <exception cref="T:System.NotSupportedException">Um nome de arquivo ou de diretório no caminho contém dois-pontos (:) ou está em um formato inválido.</exception>
        <exception cref="T:System.Security.SecurityException">O usuário não tem as permissões necessárias para exibir o caminho.</exception>
        <exception cref="T:System.UnauthorizedAccessException">O usuário não tem a permissão necessária.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Controla a capacidade de acessar arquivos e pastas. Enumeração associada: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <altmember cref="Overload:Microsoft.VisualBasic.FileIO.FileSystem.MoveDirectory" />
      </Docs>
    </Member>
    <Member MemberName="RenameFile">
      <MemberSignature Language="C#" Value="public static void RenameFile (string file, string newName);" />
      <MemberSignature Language="ILAsm" Value=".method public static void RenameFile(string file, string newName) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.RenameFile(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RenameFile (file As String, newName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RenameFile(System::String ^ file, System::String ^ newName);" />
      <MemberSignature Language="F#" Value="static member RenameFile : string * string -&gt; unit" Usage="Microsoft.VisualBasic.FileIO.FileSystem.RenameFile (file, newName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="file" Type="System.String" />
        <Parameter Name="newName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="file">Arquivo a ser renomeado.</param>
        <param name="newName">Novo nome do arquivo.</param>
        <summary>Renomeia um arquivo.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método não pode ser usado para mover um arquivo. Use o método <xref:Microsoft.VisualBasic.FileIO.FileSystem.MoveFile%2A> para mover e renomear o arquivo.  
  
 A tabela a seguir lista um exemplo de uma tarefa que envolvem o `My.Computer.FileSystem.RenameFile` método.  
  
|Para|Consulte|  
|-|-|  
|Renomear um arquivo|[Como: renomear um arquivo no Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-rename-a-file.md)|  
  
   
  
## Examples  
 Este exemplo renomeia o arquivo `Test.txt` para `SecondTest.txt`.  
  
 [!code-vb[VbVbcnMyFileSystem#1](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#1)]  
  
 Altere "`C:\Test.txt`" para o nome de arquivo e caminho do arquivo que você deseja renomear.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="newName" /> contém informações de caminho ou termina com uma barra invertida (\\).</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="file" /> é <see langword="Nothing" />.  
  
- ou - 
 <paramref name="newName" /> é <see langword="Nothing" /> ou é uma cadeia de caracteres vazia.</exception>
        <exception cref="T:System.IO.FileNotFoundException">O diretório não existe.</exception>
        <exception cref="T:System.IO.IOException">Há um arquivo ou diretório existente com o nome especificado em <paramref name="newName" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">O caminho excede o tamanho máximo definido pelo sistema.</exception>
        <exception cref="T:System.NotSupportedException">Um nome de arquivo ou de diretório no caminho contém dois-pontos (:) ou está em um formato inválido.</exception>
        <exception cref="T:System.Security.SecurityException">O usuário não tem as permissões necessárias para exibir o caminho.</exception>
        <exception cref="T:System.UnauthorizedAccessException">O usuário não tem a permissão necessária.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Controla a capacidade de acessar arquivos e pastas. Enumeração associada: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="WriteAllBytes">
      <MemberSignature Language="C#" Value="public static void WriteAllBytes (string file, byte[] data, bool append);" />
      <MemberSignature Language="ILAsm" Value=".method public static void WriteAllBytes(string file, unsigned int8[] data, bool append) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.WriteAllBytes(System.String,System.Byte[],System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteAllBytes (file As String, data As Byte(), append As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteAllBytes(System::String ^ file, cli::array &lt;System::Byte&gt; ^ data, bool append);" />
      <MemberSignature Language="F#" Value="static member WriteAllBytes : string * byte[] * bool -&gt; unit" Usage="Microsoft.VisualBasic.FileIO.FileSystem.WriteAllBytes (file, data, append)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="file" Type="System.String" />
        <Parameter Name="data" Type="System.Byte[]" />
        <Parameter Name="append" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="file">O caminho e o nome do arquivo no qual gravar.</param>
        <param name="data">Os dados a serem gravados no arquivo.</param>
        <param name="append">
          <see langword="True" /> para acrescentar ao conteúdo do arquivo, <see langword="False" /> para substituir o conteúdo do arquivo. O padrão é <see langword="False" />.</param>
        <summary>Grava dados em um arquivo binário.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se o caminho especificado, exceto o nome do arquivo não for válido, um <xref:System.IO.DirectoryNotFoundException> exceção será lançada. Se o caminho é válido, mas o arquivo não existir, o arquivo é criado.  
  
> [!NOTE]
>  O `WriteAllBytes` método abre um arquivo, grava a ele e, em seguida, fecha-lo. O código que usa o `WriteAllBytes` método é mais simples do que o código que usa um <xref:System.IO.BinaryWriter> objeto. No entanto, se você estiver adicionando dados a um arquivo usando um loop, uma <xref:System.IO.BinaryWriter> objeto pode fornecer um desempenho melhor porque você só precisa abrir e fechar o arquivo uma vez.  
  
 A tabela a seguir lista um exemplo de uma tarefa que envolvem o `My.Computer.FileSystem.WriteAllBytes` método.  
  
|Para|Consulte|  
|-|-|  
|Gravar em um arquivo binário|[Como: gravar em arquivos binários no Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-to-binary-files.md)|  
  
   
  
## Examples  
 Este exemplo acrescenta a matriz de dados `CustomerData` no arquivo `CollectedData`.  
  
 [!code-vb[VbVbcnMyFileSystem#50](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#50)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">O caminho não é válido por um dos seguintes motivos: é uma cadeia de tamanho zero, contém apenas espaços em branco, contém caracteres inválidos ou é um caminho de dispositivo (começa com \\\\.\\); ele termina com uma barra à direita.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="file" /> é <see langword="Nothing" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">O arquivo não existe.</exception>
        <exception cref="T:System.IO.IOException">O arquivo está sendo usado por outro processo, ou ocorre um erro de E/S.</exception>
        <exception cref="T:System.IO.PathTooLongException">O caminho excede o tamanho máximo definido pelo sistema.</exception>
        <exception cref="T:System.NotSupportedException">Um nome de arquivo ou de diretório no caminho contém dois-pontos (:) ou está em um formato inválido.</exception>
        <exception cref="T:System.OutOfMemoryException">Não há memória suficiente para gravar a cadeia de caracteres no buffer.</exception>
        <exception cref="T:System.Security.SecurityException">O usuário não tem as permissões necessárias para exibir o caminho.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Controla a capacidade de acessar arquivos e pastas. Enumeração associada: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="WriteAllText">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Grava um texto em um arquivo.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WriteAllText">
      <MemberSignature Language="C#" Value="public static void WriteAllText (string file, string text, bool append);" />
      <MemberSignature Language="ILAsm" Value=".method public static void WriteAllText(string file, string text, bool append) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.WriteAllText(System.String,System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteAllText (file As String, text As String, append As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteAllText(System::String ^ file, System::String ^ text, bool append);" />
      <MemberSignature Language="F#" Value="static member WriteAllText : string * string * bool -&gt; unit" Usage="Microsoft.VisualBasic.FileIO.FileSystem.WriteAllText (file, text, append)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="file" Type="System.String" />
        <Parameter Name="text" Type="System.String" />
        <Parameter Name="append" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="file">Arquivo para gravação.</param>
        <param name="text">O texto a ser gravado no arquivo.</param>
        <param name="append">
          <see langword="True" /> para acrescentar ao conteúdo do arquivo; <see langword="False" /> para substituir o conteúdo do arquivo.</param>
        <summary>Grava um texto em um arquivo.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A codificação UTF-8 é usada para gravar no arquivo. Para especificar uma codificação diferente, use uma sobrecarga diferente do <xref:Microsoft.VisualBasic.FileIO.FileSystem.WriteAllText%2A> método.  
  
 Se o arquivo especificado não existir, ele será criado.  
  
 Se a codificação especificada não coincide com a codificação existente do arquivo, a codificação especificada será ignorada.  
  
> [!NOTE]
>  O `WriteAllText` método abre um arquivo, grava a ele e, em seguida, fecha-lo. O código que usa o `WriteAllText` método é mais simples do que o código que usa um <xref:System.IO.StreamWriter> objeto. No entanto, se você estiver adicionando cadeias de caracteres em um arquivo usando um loop, uma <xref:System.IO.StreamWriter> objeto pode fornecer um desempenho melhor porque você só precisa abrir e fechar o arquivo uma vez. Para obter mais informações, consulte o método <xref:Microsoft.VisualBasic.FileIO.FileSystem.OpenTextFileWriter%2A>.  
  
 A tabela a seguir lista exemplos de tarefas que envolvem o `My.Computer.FileSystem.WriteAllText` método.  
  
|Para|Consulte|  
|-|-|  
|Gravar texto em um arquivo|[Como: gravar texto em arquivos no Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files.md)|  
|Anexar texto em um arquivo|[Como: anexar a arquivos de texto no Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-append-to-text-files.md)|  
  
   
  
## Examples  
 Este exemplo grava a linha `"This is new text to be added."` no arquivo `Test.txt`, substituindo qualquer texto existente no arquivo.  
  
 [!code-vb[VbRefFile#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#21)]  
  
 Este exemplo grava os nomes dos arquivos na `Documents and Settings` pasta para `FileList.txt`, inserindo um carro de retorno entre cada um para melhorar a legibilidade.  
  
 [!code-vb[VbRefFile#22](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#22)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">O caminho não é válido por um dos seguintes motivos: é uma cadeia de tamanho zero, contém apenas espaços em branco, contém caracteres inválidos ou é um caminho de dispositivo (começa com \\\\.\\); ele termina com uma barra à direita.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="file" /> é <see langword="Nothing" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">O arquivo não existe.</exception>
        <exception cref="T:System.IO.IOException">O arquivo está sendo usado por outro processo, ou ocorre um erro de E/S.</exception>
        <exception cref="T:System.IO.PathTooLongException">O caminho excede o tamanho máximo definido pelo sistema.</exception>
        <exception cref="T:System.NotSupportedException">Um nome de arquivo ou de diretório no caminho contém dois-pontos (:) ou está em um formato inválido.</exception>
        <exception cref="T:System.OutOfMemoryException">Não há memória suficiente para gravar a cadeia de caracteres no buffer.</exception>
        <exception cref="T:System.Security.SecurityException">O usuário não tem as permissões necessárias para exibir o caminho.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Controla a capacidade de acessar arquivos e pastas. Enumeração associada: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <altmember cref="T:System.Text.Encoding" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileIO.FileSystem.WriteAllText" />
      </Docs>
    </Member>
    <Member MemberName="WriteAllText">
      <MemberSignature Language="C#" Value="public static void WriteAllText (string file, string text, bool append, System.Text.Encoding encoding);" />
      <MemberSignature Language="ILAsm" Value=".method public static void WriteAllText(string file, string text, bool append, class System.Text.Encoding encoding) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.WriteAllText(System.String,System.String,System.Boolean,System.Text.Encoding)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteAllText(System::String ^ file, System::String ^ text, bool append, System::Text::Encoding ^ encoding);" />
      <MemberSignature Language="F#" Value="static member WriteAllText : string * string * bool * System.Text.Encoding -&gt; unit" Usage="Microsoft.VisualBasic.FileIO.FileSystem.WriteAllText (file, text, append, encoding)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="file" Type="System.String" />
        <Parameter Name="text" Type="System.String" />
        <Parameter Name="append" Type="System.Boolean" />
        <Parameter Name="encoding" Type="System.Text.Encoding" />
      </Parameters>
      <Docs>
        <param name="file">Arquivo para gravação.</param>
        <param name="text">O texto a ser gravado no arquivo.</param>
        <param name="append">
          <see langword="True" /> para acrescentar ao conteúdo do arquivo; <see langword="False" /> para substituir o conteúdo do arquivo.</param>
        <param name="encoding">A codificação a ser utilizada ao gravar um arquivo.</param>
        <summary>Grava um texto em um arquivo.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se o arquivo especificado não existir, ele será criado.  
  
 Se a codificação especificada não coincide com a codificação existente do arquivo, a codificação especificada será ignorada.  
  
> [!NOTE]
>  O `WriteAllText` método abre um arquivo, grava a ele e, em seguida, fecha-lo. O código que usa o `WriteAllText` método é mais simples do que o código que usa um <xref:System.IO.StreamWriter> objeto. No entanto, se você estiver adicionando cadeias de caracteres em um arquivo usando um loop, uma <xref:System.IO.StreamWriter> objeto pode fornecer um desempenho melhor porque você só precisa abrir e fechar o arquivo uma vez. Para obter mais informações, consulte o método <xref:Microsoft.VisualBasic.FileIO.FileSystem.OpenTextFileWriter%2A>.  
  
 A tabela a seguir lista exemplos de tarefas que envolvem o `My.Computer.FileSystem.WriteAllText` método.  
  
|Para|Consulte|  
|-|-|  
|Gravar texto em um arquivo|[Como: gravar texto em arquivos no Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files.md)|  
|Anexar texto em um arquivo|[Como: anexar a arquivos de texto no Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-append-to-text-files.md)|  
  
   
  
## Examples  
 Este exemplo grava a linha `"This is new text to be added."` no arquivo `Test.txt`, substituindo qualquer texto existente no arquivo.  
  
 [!code-vb[VbRefFile#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#21)]  
  
 Este exemplo grava os nomes dos arquivos na `Documents and Settings` pasta para `FileList.txt`, inserindo um carro de retorno entre cada um para melhorar a legibilidade.  
  
 [!code-vb[VbRefFile#22](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#22)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">O caminho não é válido por um dos seguintes motivos: é uma cadeia de tamanho zero, contém apenas espaços em branco, contém caracteres inválidos ou é um caminho de dispositivo (começa com \\\\.\\); ele termina com uma barra à direita.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="file" /> é <see langword="Nothing" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">O arquivo não existe.</exception>
        <exception cref="T:System.IO.IOException">O arquivo está sendo usado por outro processo, ou ocorre um erro de E/S.</exception>
        <exception cref="T:System.IO.PathTooLongException">O caminho excede o tamanho máximo definido pelo sistema.</exception>
        <exception cref="T:System.NotSupportedException">Um nome de arquivo ou de diretório no caminho contém dois-pontos (:) ou está em um formato inválido.</exception>
        <exception cref="T:System.OutOfMemoryException">Não há memória suficiente para gravar a cadeia de caracteres no buffer.</exception>
        <exception cref="T:System.Security.SecurityException">O usuário não tem as permissões necessárias para exibir o caminho.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Controla a capacidade de acessar arquivos e pastas. Enumeração associada: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <altmember cref="T:System.Text.Encoding" />
      </Docs>
    </Member>
  </Members>
</Type>