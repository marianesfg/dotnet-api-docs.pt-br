<Type Name="TextFieldParser" FullName="Microsoft.VisualBasic.FileIO.TextFieldParser">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="013d626bb8bc81d9eb4e03b891788c9c26fbc2a6" />
    <Meta Name="ms.sourcegitcommit" Value="6a0b904069161bbaec4ffd02aa7d9cf38c61e72e" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="pt-BR" />
    <Meta Name="ms.lasthandoff" Value="06/24/2018" />
    <Meta Name="ms.locfileid" Value="36659057" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class TextFieldParser : IDisposable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi TextFieldParser extends System.Object implements class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:Microsoft.VisualBasic.FileIO.TextFieldParser" />
  <TypeSignature Language="VB.NET" Value="Public Class TextFieldParser&#xA;Implements IDisposable" />
  <TypeSignature Language="C++ CLI" Value="public ref class TextFieldParser : IDisposable" />
  <TypeSignature Language="F#" Value="type TextFieldParser = class&#xA;    interface IDisposable" />
  <AssemblyInfo>
    <AssemblyName>Microsoft.VisualBasic</AssemblyName>
    <AssemblyVersion>10.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Fornece métodos e propriedades para analisar arquivos de texto estruturado.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O `TextFieldParser` objeto fornece métodos e propriedades para análise estruturada de arquivos de texto. Analisar um arquivo de texto com o `TextFieldParser` é semelhante a iterar em um arquivo de texto, enquanto o `ReadFields` método para extrair campos de texto é semelhante ao dividir as cadeias de caracteres.  
  
 O `TextFieldParser` pode analisar os dois tipos de arquivos: delimitada ou largura fixa. Algumas propriedades, como `Delimiters` e `HasFieldsEnclosedInQuotes` são significativos apenas ao trabalhar com arquivos delimitados, enquanto o `FieldWidths` propriedade é significativa apenas ao trabalhar com arquivos de largura fixa.  
  
 A tabela a seguir lista exemplos de tarefas que envolvem o `Microsoft.VisualBasic.FileIO.TextFieldParser` objeto.  
  
|Para|Consulte|  
|--------|---------|  
|Ler um arquivo de texto delimitado|[Como ler a partir de arquivos de texto separados por vírgulas](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-from-comma-delimited-text-files.md)|  
|Ler um arquivo de texto de largura fixa|[Como ler a partir de arquivos de texto de largura fixa](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-from-fixed-width-text-files.md)|  
|Ler um arquivo de texto com vários formatos|[Como ler a partir de arquivos de texto com vários formatos](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-from-text-files-with-multiple-formats.md)|  
  
   
  
## Examples  
 Este exemplo analisa através de um arquivo de texto delimitado por tabulação, `Bigfile`.  
  
 [!code-vb[VbVbalrTextFieldParser#17](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrTextFieldParser/VB/Class1.vb#17)]  
  
 ]]></format>
    </remarks>
    <altmember cref="M:Microsoft.VisualBasic.FileIO.FileSystem.OpenTextFieldParser(System.String)" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicializa uma nova instância da classe <see langword="TextFieldParser" />.</summary>
        <altmember cref="M:Microsoft.VisualBasic.FileIO.FileSystem.OpenTextFieldParser(System.String)" />
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public TextFieldParser (System.IO.Stream stream);" />
      <MemberSignature Language="ILAsm" Value=".method public specialname rtspecialname instance void .ctor(class System.IO.Stream stream) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.TextFieldParser.#ctor(System.IO.Stream)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; TextFieldParser(System::IO::Stream ^ stream);" />
      <MemberSignature Language="F#" Value="new Microsoft.VisualBasic.FileIO.TextFieldParser : System.IO.Stream -&gt; Microsoft.VisualBasic.FileIO.TextFieldParser" Usage="new Microsoft.VisualBasic.FileIO.TextFieldParser stream" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
      </Parameters>
      <Docs>
        <param name="stream">
          <see cref="T:System.IO.Stream" />. O fluxo a ser analisado.</param>
        <summary>Inicializa uma nova instância da classe <see langword="TextFieldParser" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cria um novo objeto `TextFieldParser` para analisar o arquivo ou stream que é representado pelo parâmetro `stream`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="stream" /> é <see langword="Nothing" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="stream" /> não pode ser lido.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileIO.FileSystem.OpenTextFieldParser(System.String)" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public TextFieldParser (System.IO.TextReader reader);" />
      <MemberSignature Language="ILAsm" Value=".method public specialname rtspecialname instance void .ctor(class System.IO.TextReader reader) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.TextFieldParser.#ctor(System.IO.TextReader)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (reader As TextReader)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; TextFieldParser(System::IO::TextReader ^ reader);" />
      <MemberSignature Language="F#" Value="new Microsoft.VisualBasic.FileIO.TextFieldParser : System.IO.TextReader -&gt; Microsoft.VisualBasic.FileIO.TextFieldParser" Usage="new Microsoft.VisualBasic.FileIO.TextFieldParser reader" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="reader" Type="System.IO.TextReader" />
      </Parameters>
      <Docs>
        <param name="reader">
          <see cref="T:System.IO.TextReader" />. O fluxo <see cref="T:System.IO.TextReader" /> a ser analisado.</param>
        <summary>Inicializa uma nova instância da classe <see langword="TextFieldParser" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cria um novo objeto `TextFieldParser` para analisar o arquivo ou stream que é representado pelo parâmetro `reader`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="reader" /> é <see langword="Nothing" />.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileIO.FileSystem.OpenTextFieldParser(System.String)" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public TextFieldParser (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public specialname rtspecialname instance void .ctor(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.TextFieldParser.#ctor(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; TextFieldParser(System::String ^ path);" />
      <MemberSignature Language="F#" Value="new Microsoft.VisualBasic.FileIO.TextFieldParser : string -&gt; Microsoft.VisualBasic.FileIO.TextFieldParser" Usage="new Microsoft.VisualBasic.FileIO.TextFieldParser path" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">
          <see langword="String" />. O caminho completo do arquivo a ser analisado.</param>
        <summary>Inicializa uma nova instância da classe <see langword="TextFieldParser" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cria um novo `TextFieldParser` objeto ao analisar o arquivo especificado pelo `path` parâmetro.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> é uma cadeia de caracteres vazia.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileIO.FileSystem.OpenTextFieldParser(System.String)" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public TextFieldParser (System.IO.Stream stream, System.Text.Encoding defaultEncoding);" />
      <MemberSignature Language="ILAsm" Value=".method public specialname rtspecialname instance void .ctor(class System.IO.Stream stream, class System.Text.Encoding defaultEncoding) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.TextFieldParser.#ctor(System.IO.Stream,System.Text.Encoding)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; TextFieldParser(System::IO::Stream ^ stream, System::Text::Encoding ^ defaultEncoding);" />
      <MemberSignature Language="F#" Value="new Microsoft.VisualBasic.FileIO.TextFieldParser : System.IO.Stream * System.Text.Encoding -&gt; Microsoft.VisualBasic.FileIO.TextFieldParser" Usage="new Microsoft.VisualBasic.FileIO.TextFieldParser (stream, defaultEncoding)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
        <Parameter Name="defaultEncoding" Type="System.Text.Encoding" />
      </Parameters>
      <Docs>
        <param name="stream">
          <see cref="T:System.IO.Stream" />. O fluxo a ser analisado.</param>
        <param name="defaultEncoding">
          <see cref="T:System.Text.Encoding" />. A codificação de caractere a ser usada caso a codificação não seja determinada pelo arquivo. O padrão é <see cref="P:System.Text.Encoding.UTF8" />.</param>
        <summary>Inicializa uma nova instância da classe <see langword="TextFieldParser" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cria um novo objeto `TextFieldParser` para analisar o arquivo ou stream que é representado pelo parâmetro `stream`.  
  
> [!CAUTION]
>  Quando você compila um conjunto de caracteres com uma configuração cultural específica e recupera os mesmos caracteres com uma configuração cultural diferente, os caracteres talvez não sejam interpretáveis e poderiam causar uma exceção a ser lançada.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="stream" /> ou <paramref name="defaultEncoding" /> é <see langword="Nothing" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="stream" /> não pode ser lido.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileIO.FileSystem.OpenTextFieldParser(System.String)" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public TextFieldParser (string path, System.Text.Encoding defaultEncoding);" />
      <MemberSignature Language="ILAsm" Value=".method public specialname rtspecialname instance void .ctor(string path, class System.Text.Encoding defaultEncoding) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.TextFieldParser.#ctor(System.String,System.Text.Encoding)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String, defaultEncoding As Encoding)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; TextFieldParser(System::String ^ path, System::Text::Encoding ^ defaultEncoding);" />
      <MemberSignature Language="F#" Value="new Microsoft.VisualBasic.FileIO.TextFieldParser : string * System.Text.Encoding -&gt; Microsoft.VisualBasic.FileIO.TextFieldParser" Usage="new Microsoft.VisualBasic.FileIO.TextFieldParser (path, defaultEncoding)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="defaultEncoding" Type="System.Text.Encoding" />
      </Parameters>
      <Docs>
        <param name="path">
          <see langword="String" />. O caminho completo do arquivo a ser analisado.</param>
        <param name="defaultEncoding">
          <see cref="T:System.Text.Encoding" />. A codificação de caractere a ser usada caso a codificação não seja determinada pelo arquivo. O padrão é <see cref="P:System.Text.Encoding.UTF8" />.</param>
        <summary>Inicializa uma nova instância da classe <see langword="TextFieldParser" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cria um novo `TextFieldParser` objeto ao analisar o arquivo especificado pelo `path` parâmetro.  
  
> [!CAUTION]
>  Quando você compila um conjunto de caracteres com uma configuração cultural específica e recupera os mesmos caracteres com uma configuração cultural diferente, os caracteres talvez não sejam interpretáveis e poderiam causar uma exceção a ser lançada.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> é uma cadeia de caracteres vazia ou <paramref name="defaultEncoding" /> é <see langword="Nothing" />.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileIO.FileSystem.OpenTextFieldParser(System.String)" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public TextFieldParser (System.IO.Stream stream, System.Text.Encoding defaultEncoding, bool detectEncoding);" />
      <MemberSignature Language="ILAsm" Value=".method public specialname rtspecialname instance void .ctor(class System.IO.Stream stream, class System.Text.Encoding defaultEncoding, bool detectEncoding) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.TextFieldParser.#ctor(System.IO.Stream,System.Text.Encoding,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; TextFieldParser(System::IO::Stream ^ stream, System::Text::Encoding ^ defaultEncoding, bool detectEncoding);" />
      <MemberSignature Language="F#" Value="new Microsoft.VisualBasic.FileIO.TextFieldParser : System.IO.Stream * System.Text.Encoding * bool -&gt; Microsoft.VisualBasic.FileIO.TextFieldParser" Usage="new Microsoft.VisualBasic.FileIO.TextFieldParser (stream, defaultEncoding, detectEncoding)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
        <Parameter Name="defaultEncoding" Type="System.Text.Encoding" />
        <Parameter Name="detectEncoding" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="stream">
          <see cref="T:System.IO.Stream" />. O fluxo a ser analisado.</param>
        <param name="defaultEncoding">
          <see cref="T:System.Text.Encoding" />. A codificação de caractere a ser usada caso a codificação não seja determinada pelo arquivo. O padrão é <see cref="P:System.Text.Encoding.UTF8" />.</param>
        <param name="detectEncoding">
          <see langword="Boolean" />. Indica se é necessário procurar marcas de ordem de byte no início do arquivo. O padrão é <see langword="True" />.</param>
        <summary>Inicializa uma nova instância da classe <see langword="TextFieldParser" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cria um novo objeto `TextFieldParser` para analisar o arquivo ou stream que é representado pelo parâmetro `stream`.  
  
 Se o `detectEncoding` parâmetro é `True`, este construtor tenta detectar a codificação, observando os três primeiros bytes do arquivo ou fluxo. Ele reconhece automaticamente Unicode UTF-8, little endian e texto Unicode big-endian se o arquivo começa com as marcas de ordem de byte apropriado. Caso contrário, a codificação especificada por `defaultEncoding` é usado.  
  
> [!CAUTION]
>  Quando você compila um conjunto de caracteres com uma configuração cultural específica e recupera os mesmos caracteres com uma configuração cultural diferente, os caracteres talvez não sejam interpretáveis e poderiam causar uma exceção a ser lançada.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="stream" /> ou <paramref name="defaultEncoding" /> é <see langword="Nothing" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="stream" /> não pode ser lido.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileIO.FileSystem.OpenTextFieldParser(System.String)" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public TextFieldParser (string path, System.Text.Encoding defaultEncoding, bool detectEncoding);" />
      <MemberSignature Language="ILAsm" Value=".method public specialname rtspecialname instance void .ctor(string path, class System.Text.Encoding defaultEncoding, bool detectEncoding) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.TextFieldParser.#ctor(System.String,System.Text.Encoding,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String, defaultEncoding As Encoding, detectEncoding As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; TextFieldParser(System::String ^ path, System::Text::Encoding ^ defaultEncoding, bool detectEncoding);" />
      <MemberSignature Language="F#" Value="new Microsoft.VisualBasic.FileIO.TextFieldParser : string * System.Text.Encoding * bool -&gt; Microsoft.VisualBasic.FileIO.TextFieldParser" Usage="new Microsoft.VisualBasic.FileIO.TextFieldParser (path, defaultEncoding, detectEncoding)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="defaultEncoding" Type="System.Text.Encoding" />
        <Parameter Name="detectEncoding" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="path">
          <see langword="String" />. O caminho completo do arquivo a ser analisado.</param>
        <param name="defaultEncoding">
          <see cref="T:System.Text.Encoding" />. A codificação de caractere a ser usada caso a codificação não seja determinada pelo arquivo. O padrão é <see cref="P:System.Text.Encoding.UTF8" />.</param>
        <param name="detectEncoding">
          <see langword="Boolean" />. Indica se é necessário procurar marcas de ordem de byte no início do arquivo. O padrão é <see langword="True" />.</param>
        <summary>Inicializa uma nova instância da classe <see langword="TextFieldParser" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cria um novo `TextFieldParser` objeto ao analisar o arquivo especificado pelo `path` parâmetro.  
  
 Se o `detectEncoding` parâmetro é `True`, este construtor tenta detectar a codificação, observando os três primeiros bytes do arquivo ou fluxo. Ele reconhece automaticamente Unicode UTF-8, little endian e texto Unicode big-endian se o arquivo começa com as marcas de ordem de byte apropriado. Caso contrário, a codificação especificada por `defaultEncoding` é usado.  
  
> [!CAUTION]
>  Quando você compila um conjunto de caracteres com uma configuração cultural específica e recupera os mesmos caracteres com uma configuração cultural diferente, os caracteres talvez não sejam interpretáveis e poderiam causar uma exceção a ser lançada.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> é uma cadeia de caracteres vazia ou <paramref name="defaultEncoding" /> é <see langword="Nothing" />.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileIO.FileSystem.OpenTextFieldParser(System.String)" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public TextFieldParser (System.IO.Stream stream, System.Text.Encoding defaultEncoding, bool detectEncoding, bool leaveOpen);" />
      <MemberSignature Language="ILAsm" Value=".method public specialname rtspecialname instance void .ctor(class System.IO.Stream stream, class System.Text.Encoding defaultEncoding, bool detectEncoding, bool leaveOpen) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.TextFieldParser.#ctor(System.IO.Stream,System.Text.Encoding,System.Boolean,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; TextFieldParser(System::IO::Stream ^ stream, System::Text::Encoding ^ defaultEncoding, bool detectEncoding, bool leaveOpen);" />
      <MemberSignature Language="F#" Value="new Microsoft.VisualBasic.FileIO.TextFieldParser : System.IO.Stream * System.Text.Encoding * bool * bool -&gt; Microsoft.VisualBasic.FileIO.TextFieldParser" Usage="new Microsoft.VisualBasic.FileIO.TextFieldParser (stream, defaultEncoding, detectEncoding, leaveOpen)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
        <Parameter Name="defaultEncoding" Type="System.Text.Encoding" />
        <Parameter Name="detectEncoding" Type="System.Boolean" />
        <Parameter Name="leaveOpen" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="stream">
          <see cref="T:System.IO.Stream" />. O fluxo a ser analisado.</param>
        <param name="defaultEncoding">
          <see cref="T:System.Text.Encoding" />. A codificação de caractere a ser usada caso a codificação não seja determinada pelo arquivo. O padrão é <see cref="P:System.Text.Encoding.UTF8" />.</param>
        <param name="detectEncoding">
          <see langword="Boolean" />. Indica se é necessário procurar marcas de ordem de byte no início do arquivo. O padrão é <see langword="True" />.</param>
        <param name="leaveOpen">
          <see langword="Boolean" />. Indica se deve deixar <c>fluxo</c> aberto quando o objeto <see langword="TextFieldParser" /> está fechado. O padrão é <see langword="False" />.</param>
        <summary>Inicializa uma nova instância da classe <see langword="TextFieldParser" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cria um novo objeto `TextFieldParser` para analisar o arquivo ou stream que é representado pelo parâmetro `stream`.  
  
 Se o `detectEncoding` parâmetro é `True`, este construtor tenta detectar a codificação, observando os três primeiros bytes do arquivo ou fluxo. Ele reconhece automaticamente Unicode UTF-8, little endian e texto Unicode big-endian se o arquivo começa com as marcas de ordem de byte apropriado. Caso contrário, a codificação especificada por `defaultEncoding` é usado.  
  
> [!CAUTION]
>  Quando você compila um conjunto de caracteres com uma configuração cultural específica e recupera os mesmos caracteres com uma configuração cultural diferente, os caracteres talvez não sejam interpretáveis e poderiam causar uma exceção a ser lançada.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="stream" /> ou <paramref name="defaultEncoding" /> é <see langword="Nothing" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="stream" /> não pode ser lido.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileIO.FileSystem.OpenTextFieldParser(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.TextFieldParser.Close" />
      <MemberSignature Language="VB.NET" Value="Public Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Close();" />
      <MemberSignature Language="F#" Value="member this.Close : unit -&gt; unit" Usage="textFieldParser.Close " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Fecha o objeto <see langword="TextFieldParser" /> atual.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Este exemplo fecha o `TextFieldParser.FileReader`.  
  
 [!code-vb[VbVbalrTextFieldParser#14](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrTextFieldParser/VB/Class1.vb#14)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.FileIO.FileSystem.OpenTextFieldParser(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="CommentTokens">
      <MemberSignature Language="C#" Value="public string[] CommentTokens { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string[] CommentTokens" />
      <MemberSignature Language="DocId" Value="P:Microsoft.VisualBasic.FileIO.TextFieldParser.CommentTokens" />
      <MemberSignature Language="VB.NET" Value="Public Property CommentTokens As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property cli::array &lt;System::String ^&gt; ^ CommentTokens { cli::array &lt;System::String ^&gt; ^ get(); void set(cli::array &lt;System::String ^&gt; ^ value); };" />
      <MemberSignature Language="F#" Value="member this.CommentTokens : string[] with get, set" Usage="Microsoft.VisualBasic.FileIO.TextFieldParser.CommentTokens" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Define tokens de comentário. Um token de comentário é uma cadeia de caracteres que, quando colocada no início de uma linha, indica que a linha é um comentário e deve ser ignorada pelo analisador.</summary>
        <value>Uma matriz de cadeia de caracteres que contém todos os tokens de comentário para o objeto <see cref="T:Microsoft.VisualBasic.FileIO.TextFieldParser" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este é um membro avançado; ele não aparece no IntelliSense, a menos que você clique no **todas as** guia.  
  
 Tokens de comentário de comprimento zero são ignorados.  
  
   
  
## Examples  
 Este exemplo especifica que para o `TextFieldParser`, `FileReader` linhas que começam com uma aspa simples (') devem ser ignoradas.  
  
 [!code-vb[VbVbalrTextFieldParser#5](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrTextFieldParser/VB/Class1.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Um token de comentário inclui espaço em branco.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileIO.FileSystem.OpenTextFieldParser(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="Delimiters">
      <MemberSignature Language="C#" Value="public string[] Delimiters { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string[] Delimiters" />
      <MemberSignature Language="DocId" Value="P:Microsoft.VisualBasic.FileIO.TextFieldParser.Delimiters" />
      <MemberSignature Language="VB.NET" Value="Public Property Delimiters As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property cli::array &lt;System::String ^&gt; ^ Delimiters { cli::array &lt;System::String ^&gt; ^ get(); void set(cli::array &lt;System::String ^&gt; ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Delimiters : string[] with get, set" Usage="Microsoft.VisualBasic.FileIO.TextFieldParser.Delimiters" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Define os delimitadores para um arquivo de texto.</summary>
        <value>Uma matriz de cadeia de caracteres que contém todos os delimitadores de campo para o objeto <see cref="T:Microsoft.VisualBasic.FileIO.TextFieldParser" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esta propriedade é significativa somente se o <xref:Microsoft.VisualBasic.FileIO.TextFieldParser.TextFieldType%2A> está definida como `FieldType.Delimited`.  
  
 Definir os delimitadores para um arquivo de texto também pode ser realizado com o <xref:Microsoft.VisualBasic.FileIO.TextFieldParser.SetDelimiters%2A> método.  
  
 A tabela a seguir lista um exemplo de tarefa envolvendo o `Delimiters` propriedade.  
  
|Para|Consulte|  
|--------|---------|  
|Ler um arquivo de texto delimitado|[Como ler a partir de arquivos de texto separados por vírgulas](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-from-comma-delimited-text-files.md)|  
  
   
  
## Examples  
 Este exemplo especifica que o delimitador para a `TextFieldParser` objeto, `FileReader`, é uma vírgula (,).  
  
 [!code-vb[VbVbalrTextFieldParser#9](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrTextFieldParser/VB/Class1.vb#9)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Um valor de delimitador é definido como um caractere de newline, uma cadeia de caracteres vazia ou <see langword="Nothing" />.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileIO.FileSystem.OpenTextFieldParser(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileIO.TextFieldParser.SetDelimiters(System.String[])" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Dispose">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Libera recursos usados pelo objeto <see cref="T:Microsoft.VisualBasic.FileIO.TextFieldParser" />.</summary>
        <altmember cref="M:Microsoft.VisualBasic.FileIO.FileSystem.OpenTextFieldParser(System.String)" />
      </Docs>
    </MemberGroup>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.TextFieldParser.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose() = IDisposable::Dispose;" />
      <MemberSignature Language="F#" Value="abstract member Dispose : unit -&gt; unit&#xA;override this.Dispose : unit -&gt; unit" Usage="textFieldParser.Dispose " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Libera recursos usados pelo objeto <see cref="T:Microsoft.VisualBasic.FileIO.TextFieldParser" />.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="M:Microsoft.VisualBasic.FileIO.FileSystem.OpenTextFieldParser(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected virtual void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familynewslot virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.TextFieldParser.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void Dispose(bool disposing);" />
      <MemberSignature Language="F#" Value="abstract member Dispose : bool -&gt; unit&#xA;override this.Dispose : bool -&gt; unit" Usage="textFieldParser.Dispose disposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">Booliano. <see langword="True" /> libera os recursos gerenciados e não gerenciados; <see langword="False" /> libera apenas os recursos não gerenciados.</param>
        <summary>Libera recursos usados pelo objeto <see cref="T:Microsoft.VisualBasic.FileIO.TextFieldParser" />.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="M:Microsoft.VisualBasic.FileIO.FileSystem.OpenTextFieldParser(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="EndOfData">
      <MemberSignature Language="C#" Value="public bool EndOfData { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool EndOfData" />
      <MemberSignature Language="DocId" Value="P:Microsoft.VisualBasic.FileIO.TextFieldParser.EndOfData" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property EndOfData As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool EndOfData { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.EndOfData : bool" Usage="Microsoft.VisualBasic.FileIO.TextFieldParser.EndOfData" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Retorna <see langword="True" /> se não houver linha que não está em branco ou linha não comentada entre a posição atual do cursor e o fim do arquivo.</summary>
        <value>
          <see langword="True" /> se não houver mais dados para ler; caso contrário, <see langword="False" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Essa propriedade pode ser usada durante a leitura de arquivos para determinar o final dos dados que está sendo lidos.  
  
 A tabela a seguir lista exemplos de tarefas que envolvem o `EndOfData` propriedade.  
  
|Para|Consulte|  
|--------|---------|  
|Ler um arquivo delimitado|[Como ler a partir de arquivos de texto separados por vírgulas](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-from-comma-delimited-text-files.md)|  
|Ler um arquivo de largura fixa|[Como ler a partir de arquivos de texto de largura fixa](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-from-fixed-width-text-files.md)|  
  
   
  
## Examples  
 Este exemplo usa o `EndofData` propriedade para executar um loop através de todos os campos no arquivo com o `TextFieldReader`, `FileReader`.  
  
 [!code-vb[VbVbalrTextFieldParser#6](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrTextFieldParser/VB/Class1.vb#6)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.FileIO.FileSystem.OpenTextFieldParser(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="ErrorLine">
      <MemberSignature Language="C#" Value="public string ErrorLine { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ErrorLine" />
      <MemberSignature Language="DocId" Value="P:Microsoft.VisualBasic.FileIO.TextFieldParser.ErrorLine" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ErrorLine As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ ErrorLine { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ErrorLine : string" Usage="Microsoft.VisualBasic.FileIO.TextFieldParser.ErrorLine" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Retorna a linha que causou a mais recente exceção <see cref="T:Microsoft.VisualBasic.FileIO.MalformedLineException" />.</summary>
        <value>A linha que causou o mais recente <see cref="T:Microsoft.VisualBasic.FileIO.MalformedLineException" /> exceção.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se nenhum <xref:Microsoft.VisualBasic.FileIO.MalformedLineException> exceções tem sido lançadas, uma cadeia de caracteres vazia é retornada.  
  
 O <xref:Microsoft.VisualBasic.FileIO.TextFieldParser.ErrorLineNumber%2A> propriedade pode ser usada para exibir o número da linha que causou a exceção.  
  
 A tabela a seguir lista exemplos de tarefas que envolvem o `ErrorLine` propriedade.  
  
|Para|Consulte|  
|--------|---------|  
|Ler um arquivo delimitado|[Como ler a partir de arquivos de texto separados por vírgulas](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-from-comma-delimited-text-files.md)|  
|Ler um arquivo de largura fixa|[Como ler a partir de arquivos de texto de largura fixa](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-from-fixed-width-text-files.md)|  
  
   
  
## Examples  
 Este exemplo usa o `ErrorLine` propriedade para exibir a linha que causou a atual <xref:Microsoft.VisualBasic.FileIO.MalformedLineException> exceção.  
  
 [!code-vb[VbVbalrTextFieldParser#1](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrTextFieldParser/VB/Class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.FileIO.FileSystem.OpenTextFieldParser(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="ErrorLineNumber">
      <MemberSignature Language="C#" Value="public long ErrorLineNumber { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 ErrorLineNumber" />
      <MemberSignature Language="DocId" Value="P:Microsoft.VisualBasic.FileIO.TextFieldParser.ErrorLineNumber" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ErrorLineNumber As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long ErrorLineNumber { long get(); };" />
      <MemberSignature Language="F#" Value="member this.ErrorLineNumber : int64" Usage="Microsoft.VisualBasic.FileIO.TextFieldParser.ErrorLineNumber" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Retorna o número da linha que causou a mais recente exceção <see cref="T:Microsoft.VisualBasic.FileIO.MalformedLineException" />.</summary>
        <value>O número da linha que causou o mais recente <see cref="T:Microsoft.VisualBasic.FileIO.MalformedLineException" /> exceção.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se nenhum <xref:Microsoft.VisualBasic.FileIO.MalformedLineException> exceções foi lançadas, -1 será retornado.  
  
 O <xref:Microsoft.VisualBasic.FileIO.TextFieldParser.ErrorLine%2A> propriedade pode ser usada para exibir o número da linha que causou a exceção. Linhas em branco e comentários não são ignorados ao determinar o número da linha.  
  
 A tabela a seguir lista exemplos de tarefas que envolvem o `ErrorLineNumber` propriedade.  
  
|Para|Consulte|  
|--------|---------|  
|Ler um arquivo delimitado|[Como ler a partir de arquivos de texto separados por vírgulas](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-from-comma-delimited-text-files.md)|  
|Ler um arquivo de largura fixa|[Como ler a partir de arquivos de texto de largura fixa](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-from-fixed-width-text-files.md)|  
  
   
  
## Examples  
 Este exemplo usa o `ErrorLineNumber` propriedade para exibir o local da linha que causou a atual <xref:Microsoft.VisualBasic.FileIO.MalformedLineException> exceção.  
  
 [!code-vb[VbVbalrTextFieldParser#3](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrTextFieldParser/VB/Class1.vb#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.FileIO.FileSystem.OpenTextFieldParser(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="FieldWidths">
      <MemberSignature Language="C#" Value="public int[] FieldWidths { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32[] FieldWidths" />
      <MemberSignature Language="DocId" Value="P:Microsoft.VisualBasic.FileIO.TextFieldParser.FieldWidths" />
      <MemberSignature Language="VB.NET" Value="Public Property FieldWidths As Integer()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property cli::array &lt;int&gt; ^ FieldWidths { cli::array &lt;int&gt; ^ get(); void set(cli::array &lt;int&gt; ^ value); };" />
      <MemberSignature Language="F#" Value="member this.FieldWidths : int[] with get, set" Usage="Microsoft.VisualBasic.FileIO.TextFieldParser.FieldWidths" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Indica a largura de cada coluna no arquivo de texto que está sendo analisado.</summary>
        <value>Uma matriz de inteiros que contém a largura de cada coluna no arquivo de texto que está sendo analisado.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esta propriedade é significativa somente se o <xref:Microsoft.VisualBasic.FileIO.TextFieldParser.TextFieldType%2A> está definida como `FieldType.FixedWidth`. Se a última entrada na matriz é menor que ou igual a zero, o campo deve para ser de largura variável.  
  
 O <xref:Microsoft.VisualBasic.FileIO.TextFieldParser.SetFieldWidths%2A> método também pode ser usado para definir as larguras de campo.  
  
 A tabela a seguir lista exemplos de tarefas que envolvem o `FieldWidths` propriedade.  
  
|Para|Consulte|  
|--------|---------|  
|Ler um arquivo de texto de largura fixa|[Como ler a partir de arquivos de texto de largura fixa](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-from-fixed-width-text-files.md)|  
  
   
  
## Examples  
 Este exemplo lê o arquivo `ParserText.txt`, especificando as larguras; a primeira coluna é de 5 caracteres de largura, a segunda tem 10, a terceira é 11 e a quarta é de largura variável  
  
 [!code-vb[VbVbalrTextFieldParser#16](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrTextFieldParser/VB/Class1.vb#16)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Um valor de largura em qualquer local que não seja a última entrada da matriz é menor que ou igual a zero.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileIO.FileSystem.OpenTextFieldParser(System.String)" />
        <altmember cref="T:Microsoft.VisualBasic.FileIO.FieldType" />
      </Docs>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="C#" Value="~TextFieldParser ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Finalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.TextFieldParser.Finalize" />
      <MemberSignature Language="VB.NET" Value="Finalize ()" />
      <MemberSignature Language="C++ CLI" Value="!TextFieldParser ()" />
      <MemberSignature Language="F#" Value="override this.Finalize : unit -&gt; unit" Usage="textFieldParser.Finalize " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Permite que o objeto <see cref="T:Microsoft.VisualBasic.FileIO.TextFieldParser" /> tente liberar recursos e realizar outras operações de limpeza antes que ela é recuperada pela coleta de lixo.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="M:Microsoft.VisualBasic.FileIO.FileSystem.OpenTextFieldParser(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="HasFieldsEnclosedInQuotes">
      <MemberSignature Language="C#" Value="public bool HasFieldsEnclosedInQuotes { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool HasFieldsEnclosedInQuotes" />
      <MemberSignature Language="DocId" Value="P:Microsoft.VisualBasic.FileIO.TextFieldParser.HasFieldsEnclosedInQuotes" />
      <MemberSignature Language="VB.NET" Value="Public Property HasFieldsEnclosedInQuotes As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool HasFieldsEnclosedInQuotes { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.HasFieldsEnclosedInQuotes : bool with get, set" Usage="Microsoft.VisualBasic.FileIO.TextFieldParser.HasFieldsEnclosedInQuotes" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Indica se os campos serão colocados entre aspas quando um arquivo delimitado está sendo analisado.</summary>
        <value>
          <see langword="True" /> se os campos forem incluídos entre aspas; caso contrário, <see langword="False" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este é um membro avançado; ele não aparece no IntelliSense, a menos que você clique no **todas as** guia.  
  
 Se a propriedade for `True`, o analisador pressupõe que os campos são colocados entre aspas ("") e pode conter terminações de linha.  
  
 Se um campo é colocado entre aspas, por exemplo, `abc, "field2a,field2b", field3` e essa propriedade é `True`, em seguida, todo o texto entre aspas será retornado como é; este exemplo retornaria `abc|field2a,field2b|field3`. Definir essa propriedade como `False` tornaria neste exemplo retorno `abc|"field2a|field2b"|field3`.  
  
   
  
## Examples  
 Este exemplo define o `HasFieldsEnclosedInQuotes` propriedade `True` para `myReader`.  
  
 [!code-vb[VbVbalrTextFieldParser#18](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrTextFieldParser/VB/Class1.vb#18)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.FileIO.FileSystem.OpenTextFieldParser(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="LineNumber">
      <MemberSignature Language="C#" Value="public long LineNumber { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 LineNumber" />
      <MemberSignature Language="DocId" Value="P:Microsoft.VisualBasic.FileIO.TextFieldParser.LineNumber" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property LineNumber As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long LineNumber { long get(); };" />
      <MemberSignature Language="F#" Value="member this.LineNumber : int64" Usage="Microsoft.VisualBasic.FileIO.TextFieldParser.LineNumber" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Retorna o número de linha atual ou -1 se não houver mais nenhum caractere disponível no fluxo.</summary>
        <value>O número de linha atual.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este é um membro avançado; ele não aparece no IntelliSense, a menos que você clique no **todas as** guia.  
  
 Linhas em branco e comentários não são ignorados ao determinar o número da linha.  
  
   
  
## Examples  
 Este exemplo procura o nome "Jones" no arquivo de texto e relatórios que linha ele ocorre.  
  
 [!code-vb[VbVbalrTextFieldParser#11](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrTextFieldParser/VB/Class1.vb#11)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.FileIO.FileSystem.OpenTextFieldParser(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="PeekChars">
      <MemberSignature Language="C#" Value="public string PeekChars (int numberOfChars);" />
      <MemberSignature Language="ILAsm" Value=".method public instance string PeekChars(int32 numberOfChars) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.TextFieldParser.PeekChars(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function PeekChars (numberOfChars As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ PeekChars(int numberOfChars);" />
      <MemberSignature Language="F#" Value="member this.PeekChars : int -&gt; string" Usage="textFieldParser.PeekChars numberOfChars" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="numberOfChars" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="numberOfChars">
          <see langword="Int32" />. O número de caracteres a serem lidos. Necessário.</param>
        <summary>Lê o número especificado de caracteres sem avançar o cursor.</summary>
        <returns>Uma cadeia de caracteres que contém o número especificado de caracteres lidos.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O `numberOfChars` valor deve ser menor que o número total de caracteres na linha. Se não estiver, a cadeia de caracteres retornada por `PeekChars` será truncado para o comprimento da linha.  
  
 Linhas em branco são ignoradas.  
  
 Caracteres de final de linha não são retornados.  
  
 O `PeekChars` método não realiza nenhuma análise; um caractere de final de linha dentro de um campo delimitado é interpretado como o próprio fim da linha.  
  
 A tabela a seguir lista exemplos de tarefas que envolvem o `PeekChars` método.  
  
|Para|Consulte|  
|--------|---------|  
|Determinar o formato de um campo antes de analisá-lo|[Como ler a partir de arquivos de texto com vários formatos](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-from-text-files-with-multiple-formats.md)|  
  
   
  
## Examples  
 Este exemplo usa `PeekChars` para achar o fim dos dados e parar de analisar o arquivo nesse momento.  
  
 [!code-vb[VbVbalrTextFieldParser#8](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrTextFieldParser/VB/Class1.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="numberOfChars" /> é menor que 0.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileIO.FileSystem.OpenTextFieldParser(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="ReadFields">
      <MemberSignature Language="C#" Value="public string[] ReadFields ();" />
      <MemberSignature Language="ILAsm" Value=".method public instance string[] ReadFields() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.TextFieldParser.ReadFields" />
      <MemberSignature Language="VB.NET" Value="Public Function ReadFields () As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::String ^&gt; ^ ReadFields();" />
      <MemberSignature Language="F#" Value="member this.ReadFields : unit -&gt; string[]" Usage="textFieldParser.ReadFields " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Lê todos os campos na linha atual, retorna-os como uma matriz de cadeias de caracteres e avança o cursor para a próxima linha contendo dados.</summary>
        <returns>Uma matriz de cadeias de caracteres que contém os valores de campo para a linha atual.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para permitir que os usuários a analisar arquivos de texto em vários formatos, o `ReadFields` método examina os valores de `TextFieldType`, `Delimiters`, e `FieldWidths`, se eles forem especificados, cada vez que ele é chamado. Os usuários precisam configurar corretamente o `TextFieldType` e `FieldWidths` ou `Delimiters` propriedades, conforme apropriado. Se `TextFieldType` é definido como `Delimited`, e `Delimiters` não for definido, ou se `TextFieldType` é definido como `FixedWidth` e `FieldWidths`, uma exceção será lançada.  
  
 Se `ReadFields` encontra linhas em branco, elas são ignoradas e a próxima linha não vazia é retornada.  
  
 Se o `ReadFields` método não é possível analisar a linha atual, ele gera uma exceção e não move para a próxima linha. Isso permite que seu aplicativo tentar analisar a linha novamente.  
  
 A tabela a seguir lista exemplos de tarefas que envolvem o `ReadFields` método.  
  
|Para|Consulte|  
|--------|---------|  
|Ler um arquivo delimitado|[Como ler a partir de arquivos de texto separados por vírgulas](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-from-comma-delimited-text-files.md)|  
|Ler um arquivo de largura fixa|[Como ler a partir de arquivos de texto de largura fixa](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-from-fixed-width-text-files.md)|  
  
   
  
## Examples  
 Este exemplo usa o `ReadFields` método para ler o arquivo delimitado por vírgula `ParserText.txt`. O exemplo grava os campos a serem `Testfile.txt`.  
  
 [!code-vb[VbVbalrTextFieldParser#2](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrTextFieldParser/VB/Class1.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:Microsoft.VisualBasic.FileIO.MalformedLineException">Um campo não pode ser analisado usando o formato especificado.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Enumeração associada: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Enumeração associada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</permission>
        <altmember cref="M:Microsoft.VisualBasic.FileIO.FileSystem.OpenTextFieldParser(System.String)" />
        <altmember cref="P:Microsoft.VisualBasic.FileIO.TextFieldParser.TextFieldType" />
        <altmember cref="P:Microsoft.VisualBasic.FileIO.TextFieldParser.FieldWidths" />
        <altmember cref="P:Microsoft.VisualBasic.FileIO.TextFieldParser.Delimiters" />
        <altmember cref="M:Microsoft.VisualBasic.FileIO.TextFieldParser.ReadLine" />
      </Docs>
    </Member>
    <Member MemberName="ReadLine">
      <MemberSignature Language="C#" Value="public string ReadLine ();" />
      <MemberSignature Language="ILAsm" Value=".method public instance string ReadLine() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.TextFieldParser.ReadLine" />
      <MemberSignature Language="VB.NET" Value="Public Function ReadLine () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ReadLine();" />
      <MemberSignature Language="F#" Value="member this.ReadLine : unit -&gt; string" Usage="textFieldParser.ReadLine " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retorna a linha atual como uma cadeia de caracteres e avança o cursor para a próxima linha.</summary>
        <returns>A linha atual do arquivo ou fluxo.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O `ReadLine` método não realiza nenhuma análise; um caractere de final de linha dentro de um campo delimitado é interpretado como o próprio fim da linha.  
  
 `Nothing` será retornado se o final do arquivo for atingido.  
  
   
  
## Examples  
 Este exemplo lê o arquivo `ParserText.txt` e grava-o para `Testfile.txt`.  
  
 [!code-vb[VbVbalrTextFieldParser#15](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrTextFieldParser/VB/Class1.vb#15)]  
  
 Se `Testfile.txt` não existir, ela é criada pelo `WriteAllText` método.  
  
 Este exemplo grava os campos como uma única cadeia de caracteres; Para fazer com que cada linha exiba em sua própria linha no arquivo de destino, um `VbCrLf` caractere deve ser acrescentado ao final de cada linha.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.FileIO.FileSystem.OpenTextFieldParser(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileIO.TextFieldParser.ReadFields" />
        <altmember cref="M:Microsoft.VisualBasic.FileIO.TextFieldParser.ReadToEnd" />
      </Docs>
    </Member>
    <Member MemberName="ReadToEnd">
      <MemberSignature Language="C#" Value="public string ReadToEnd ();" />
      <MemberSignature Language="ILAsm" Value=".method public instance string ReadToEnd() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.TextFieldParser.ReadToEnd" />
      <MemberSignature Language="VB.NET" Value="Public Function ReadToEnd () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ReadToEnd();" />
      <MemberSignature Language="F#" Value="member this.ReadToEnd : unit -&gt; string" Usage="textFieldParser.ReadToEnd " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Lê o restante do arquivo de texto e retorna-o como uma cadeia de caracteres.</summary>
        <returns>O texto restante do arquivo ou fluxo.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este é um membro avançado; ele não aparece no IntelliSense, a menos que você clique no **todas as** guia.  
  
 Se não houver mais nada para ler porque foi atingido o final do arquivo, `Nothing` será retornado.  
  
 O `ReadToEnd` método não ignora linhas em branco e comentários.  
  
   
  
## Examples  
 Este exemplo usa o `ReadToEnd` método para ler o arquivo inteiro `ParserText.txt` e gravá-la para o arquivo `Testfile.txt`.  
  
 [!code-vb[VbVbalrTextFieldParser#10](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrTextFieldParser/VB/Class1.vb#10)]  
  
 Se `Testfile.txt` não existir, ela é criada pelo `WriteAllText` método.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.FileIO.FileSystem.OpenTextFieldParser(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileIO.TextFieldParser.ReadFields" />
        <altmember cref="M:Microsoft.VisualBasic.FileIO.TextFieldParser.ReadLine" />
      </Docs>
    </Member>
    <Member MemberName="SetDelimiters">
      <MemberSignature Language="C#" Value="public void SetDelimiters (params string[] delimiters);" />
      <MemberSignature Language="ILAsm" Value=".method public instance void SetDelimiters(string[] delimiters) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.TextFieldParser.SetDelimiters(System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetDelimiters (ParamArray delimiters As String())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetDelimiters(... cli::array &lt;System::String ^&gt; ^ delimiters);" />
      <MemberSignature Language="F#" Value="member this.SetDelimiters : string[] -&gt; unit" Usage="textFieldParser.SetDelimiters delimiters" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="delimiters" Type="System.String[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="delimiters">Matriz do tipo <see langword="String" />.</param>
        <summary>Define os delimitadores do leitor para os valores especificados e define o tipo de campo como <see langword="Delimited" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O conteúdo existente de `Delimiters` propriedade é limpo quando esse método é definido.  
  
 Esse método fornece uma maneira de definir delimitadores sem criar uma matriz.  
  
 A tabela a seguir lista um exemplo de tarefa envolvendo o `SetDelimiters` método.  
  
|Para|Consulte|  
|--------|---------|  
|Analisar um arquivo de texto|[Analisando arquivos de texto com o objeto TextFieldParser](~/docs/visual-basic/developing-apps/programming/drives-directories-files/parsing-text-files-with-the-textfieldparser-object.md)|  
  
   
  
## Examples  
 Este exemplo abre um analisador de campo de texto e define o delimitador como `vbTab`.  
  
 [!code-vb[VbVbalrTextFieldParser#4](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrTextFieldParser/VB/Class1.vb#4)]  
  
 Substitua o caminho `C:\logs\test.log` com o caminho e o nome do arquivo que você deseja analisar.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Um delimitador tem tamanho zero.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileIO.FileSystem.OpenTextFieldParser(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileIO.TextFieldParser.SetFieldWidths(System.Int32[])" />
      </Docs>
    </Member>
    <Member MemberName="SetFieldWidths">
      <MemberSignature Language="C#" Value="public void SetFieldWidths (params int[] fieldWidths);" />
      <MemberSignature Language="ILAsm" Value=".method public instance void SetFieldWidths(int32[] fieldWidths) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.TextFieldParser.SetFieldWidths(System.Int32[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetFieldWidths (ParamArray fieldWidths As Integer())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetFieldWidths(... cli::array &lt;int&gt; ^ fieldWidths);" />
      <MemberSignature Language="F#" Value="member this.SetFieldWidths : int[] -&gt; unit" Usage="textFieldParser.SetFieldWidths fieldWidths" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fieldWidths" Type="System.Int32[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="fieldWidths">Matriz de <see langword="Integer" />.</param>
        <summary>Define os delimitadores do leitor para os valores especificados.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O conteúdo existente de `Delimiters` propriedade é limpo quando isso é definido.  
  
 Esse método fornece uma maneira de definir delimitadores sem criar uma matriz.  
  
 A tabela a seguir lista exemplo de tarefas que envolvem o `SetFieldWidths` método.  
  
|Para|Consulte|  
|--------|---------|  
|Analise um arquivo de texto.|[Analisando arquivos de texto com o objeto TextFieldParser](~/docs/visual-basic/developing-apps/programming/drives-directories-files/parsing-text-files-with-the-textfieldparser-object.md)|  
  
   
  
## Examples  
 Este exemplo abre um analisador de campo de texto e define a largura do campo como `5`.  
  
 [!code-vb[VbVbalrTextFieldParser#12](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrTextFieldParser/VB/Class1.vb#12)]  
  
 Substitua o caminho `C:\logs\test.log` com o caminho e o nome do arquivo que você deseja analisar.  
  
 O exemplo a seguir abre um analisador de campo de texto e define a largura do campo como `5`, `10`e a variável.  
  
 [!code-vb[VbVbalrTextFieldParser#13](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrTextFieldParser/VB/Class1.vb#13)]  
  
 Substitua o caminho `C:\logs\test.log` com o caminho e o nome do arquivo que você deseja analisar.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.FileIO.FileSystem.OpenTextFieldParser(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileIO.TextFieldParser.SetDelimiters(System.String[])" />
      </Docs>
    </Member>
    <Member MemberName="TextFieldType">
      <MemberSignature Language="C#" Value="public Microsoft.VisualBasic.FileIO.FieldType TextFieldType { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype Microsoft.VisualBasic.FileIO.FieldType TextFieldType" />
      <MemberSignature Language="DocId" Value="P:Microsoft.VisualBasic.FileIO.TextFieldParser.TextFieldType" />
      <MemberSignature Language="VB.NET" Value="Public Property TextFieldType As FieldType" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Microsoft::VisualBasic::FileIO::FieldType TextFieldType { Microsoft::VisualBasic::FileIO::FieldType get(); void set(Microsoft::VisualBasic::FileIO::FieldType value); };" />
      <MemberSignature Language="F#" Value="member this.TextFieldType : Microsoft.VisualBasic.FileIO.FieldType with get, set" Usage="Microsoft.VisualBasic.FileIO.TextFieldParser.TextFieldType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.VisualBasic.FileIO.FieldType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Indica se o arquivo a ser analisado é delimitado ou com uma largura fixa.</summary>
        <value>Um valor <see cref="P:Microsoft.VisualBasic.FileIO.TextFieldParser.TextFieldType" /> que indica se o arquivo a ser analisado é delimitado ou tem uma largura fixa.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O valor padrão dessa propriedade é delimitado.  
  
 A tabela a seguir lista exemplos de tarefas que envolvem o `TextFieldType` propriedade.  
  
|Para|Consulte|  
|--------|---------|  
|Ler um arquivo de texto delimitado|[Como ler a partir de arquivos de texto separados por vírgulas](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-from-comma-delimited-text-files.md)|  
|Ler um arquivo de texto de largura fixa|[Como ler a partir de arquivos de texto de largura fixa](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-from-fixed-width-text-files.md)|  
|Ler um arquivo de texto com vários formatos|[Como ler a partir de arquivos de texto com vários formatos](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-from-text-files-with-multiple-formats.md)|  
  
   
  
## Examples  
 Este exemplo cria um `TextFieldParser`, `FileReader`e especifica que ele é delimitado.  
  
 [!code-vb[VbVbalrTextFieldParser#19](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrTextFieldParser/VB/Class1.vb#19)]  
  
 Este exemplo cria um `TextFieldParser`, `FileReader`e especifica que se trata de largura fixa.  
  
 [!code-vb[VbVbalrTextFieldParser#20](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrTextFieldParser/VB/Class1.vb#20)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.FileIO.FileSystem.OpenTextFieldParser(System.String)" />
        <altmember cref="T:Microsoft.VisualBasic.FileIO.FieldType" />
      </Docs>
    </Member>
    <Member MemberName="TrimWhiteSpace">
      <MemberSignature Language="C#" Value="public bool TrimWhiteSpace { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool TrimWhiteSpace" />
      <MemberSignature Language="DocId" Value="P:Microsoft.VisualBasic.FileIO.TextFieldParser.TrimWhiteSpace" />
      <MemberSignature Language="VB.NET" Value="Public Property TrimWhiteSpace As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool TrimWhiteSpace { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.TrimWhiteSpace : bool with get, set" Usage="Microsoft.VisualBasic.FileIO.TextFieldParser.TrimWhiteSpace" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Indica se espaços em branco à esquerda e à direita devem ser removidos dos valores de campo.</summary>
        <value>
          <see langword="True" /> caso espaços em branco à direita e à esquerda devam ser removidos dos valores de campo; caso contrário, <see langword="False" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O valor padrão dessa propriedade é `True`.  
  
   
  
## Examples  
 Este exemplo cria um `TextFieldParser`, `FileReader`e define o `TrimWhiteSpace` propriedade `True`.  
  
 [!code-vb[VbVbalrTextFieldParser#7](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrTextFieldParser/VB/Class1.vb#7)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.FileIO.FileSystem.OpenTextFieldParser(System.String)" />
      </Docs>
    </Member>
  </Members>
</Type>