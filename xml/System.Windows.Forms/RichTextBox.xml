<Type Name="RichTextBox" FullName="System.Windows.Forms.RichTextBox">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="f6bc4582e825296fa306e1a8f5b9ad0a64930707" />
    <Meta Name="ms.sourcegitcommit" Value="6a0b904069161bbaec4ffd02aa7d9cf38c61e72e" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="pt-BR" />
    <Meta Name="ms.lasthandoff" Value="06/24/2018" />
    <Meta Name="ms.locfileid" Value="36516147" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class RichTextBox : System.Windows.Forms.TextBoxBase" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit RichTextBox extends System.Windows.Forms.TextBoxBase" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Forms.RichTextBox" />
  <TypeSignature Language="VB.NET" Value="Public Class RichTextBox&#xA;Inherits TextBoxBase" />
  <TypeSignature Language="C++ CLI" Value="public ref class RichTextBox : System::Windows::Forms::TextBoxBase" />
  <TypeSignature Language="F#" Value="type RichTextBox = class&#xA;    inherit TextBoxBase" />
  <AssemblyInfo>
    <AssemblyName>System.Windows.Forms</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Windows.Forms.TextBoxBase</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.ComponentModel.Designer("System.Windows.Forms.Design.RichTextBoxDesigner, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ClassInterface</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Windows.Forms.Docking(System.Windows.Forms.DockingBehavior.Ask)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Representa um controle de caixa RTF do Windows.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Com o <xref:System.Windows.Forms.RichTextBox> controle, o usuário pode inserir e editar texto. O controle também fornece recursos de formatação mais avançados que o padrão de <xref:System.Windows.Forms.TextBox> controle. Texto pode ser atribuído diretamente para o controle, ou pode ser carregado de um formato rich text (RTF) ou arquivo de texto sem formatação. O texto dentro do controle pode ser atribuído a formatação de parágrafo e caracteres.  
  
 O <xref:System.Windows.Forms.RichTextBox> controle oferece uma série de propriedades que você pode usar para aplicar formatação a qualquer parte do texto dentro do controle. Para alterar a formatação de texto, ele deve primeiro ser selecionado. Somente o texto selecionado pode ser atribuído a formatação de parágrafo e caracteres. Quando uma configuração é feita para uma seção selecionada do texto, todo o texto inserido após a seleção também é formatada com as mesmas configurações até que seja feita uma alteração de configuração ou outra seção do documento do controle é selecionada. O <xref:System.Windows.Forms.RichTextBox.SelectionFont%2A> propriedade permite que você faça o texto em negrito ou itálico. Você também pode usar essa propriedade para alterar o tamanho e o tipo de fonte do texto. O <xref:System.Windows.Forms.RichTextBox.SelectionColor%2A> propriedade permite que você altere a cor do texto. Para criar listas com marcadores, você pode usar o <xref:System.Windows.Forms.RichTextBox.SelectionBullet%2A> propriedade. Você também pode ajustar o parágrafo formatação definindo o <xref:System.Windows.Forms.RichTextBox.SelectionIndent%2A>, <xref:System.Windows.Forms.RichTextBox.SelectionRightIndent%2A>, e <xref:System.Windows.Forms.RichTextBox.SelectionHangingIndent%2A> propriedades.  
  
 O <xref:System.Windows.Forms.RichTextBox> controle fornece métodos que fornecem funcionalidade para abrir e salvar arquivos. O <xref:System.Windows.Forms.RichTextBox.LoadFile%2A> método permite que você carregar um arquivo de texto RTF ou ASCII existente no controle. Você também pode carregar dados de um fluxo de dados já aberto. O <xref:System.Windows.Forms.RichTextBox.SaveFile%2A> permite que você salve um arquivo de texto RTF ou ASCII. Como o <xref:System.Windows.Forms.RichTextBox.LoadFile%2A> método, você também pode usar o <xref:System.Windows.Forms.RichTextBox.SaveFile%2A> método para salvar um fluxo de dados. O <xref:System.Windows.Forms.RichTextBox> controle também fornece recursos para localizar cadeias de caracteres de texto. O <xref:System.Windows.Forms.RichTextBox.Find%2A> método é sobrecarregado para localizar as duas cadeias de caracteres de texto específicos, bem como caracteres dentro do texto do controle.  
  
 Você também pode inicializar o <xref:System.Windows.Forms.RichTextBox> controle aos dados armazenados na memória. Por exemplo, você pode inicializar o <xref:System.Windows.Forms.RichTextBox.Rtf%2A> propriedade como uma cadeia de caracteres que contém o texto a ser exibido, incluindo os códigos RTF que determinam como o texto deve ser formatado.  
  
 Se o texto dentro do controle contém links, como um link para um site da Web, você pode usar o <xref:System.Windows.Forms.RichTextBox.DetectUrls%2A> propriedade para exibir o link adequadamente no texto do controle. Você pode manipular o <xref:System.Windows.Forms.RichTextBox.LinkClicked> evento para executar as tarefas associadas com o link. O <xref:System.Windows.Forms.RichTextBox.SelectionProtected%2A> propriedade permite que você proteja o texto dentro do controle de manipulação pelo usuário. Com texto protegido no seu controle, você pode manipular o <xref:System.Windows.Forms.RichTextBox.Protected> evento para determinar quando o usuário tentou modificar texto protegido e alerta o usuário que o texto está protegida ou fornecer ao usuário uma forma padrão de manipulação de texto protegido.  
  
 Aplicativos que já usam <xref:System.Windows.Forms.TextBox> controles podem ser facilmente adaptados para tornar o uso de <xref:System.Windows.Forms.RichTextBox> controles. No entanto, o <xref:System.Windows.Forms.RichTextBox> controle não tem o mesmo limite de capacidade de caractere de 64K do <xref:System.Windows.Forms.TextBox> controle. O <xref:System.Windows.Forms.RichTextBox> normalmente é usado para fornecer manipulação de texto e exibir recursos semelhantes para aplicativos de processamento de texto como o Microsoft Word.  
  
> [!NOTE]
>  O <xref:System.Windows.Forms.TextBoxBase.Undo%2A?displayProperty=nameWithType> método não funciona com o <xref:System.Windows.Forms.Control.KeyPress> ou <xref:System.Windows.Forms.Control.TextChanged> eventos.  
  
   
  
## Examples  
 O exemplo de código a seguir cria um <xref:System.Windows.Forms.RichTextBox> controle que carrega um arquivo RTF em controle e procura a primeira ocorrência da palavra "Texto". O código, em seguida, altera o estilo da fonte, tamanho da fonte e cor da fonte do texto selecionado e salva as alterações para o arquivo original. O código de exemplo terminar, adicionando o controle para seu <xref:System.Windows.Forms.Form>. Este exemplo requer que o método criado no exemplo de código é adicionado a um <xref:System.Windows.Forms.Form> classe e chamado a partir do construtor do formulário. O exemplo também requer que um arquivo RTF é criado na raiz da unidade C, que contém a palavra "Texto".  
  
 [!code-cpp[Classic RichTextBox Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic RichTextBox Example/CPP/source.cpp#1)]
 [!code-csharp[Classic RichTextBox Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic RichTextBox Example/CS/source.cs#1)]
 [!code-vb[Classic RichTextBox Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic RichTextBox Example/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Windows.Forms.TextBoxBase" />
    <altmember cref="T:System.Windows.Forms.TextBox" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public RichTextBox ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.RichTextBox.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; RichTextBox();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inicializa uma nova instância da classe <see cref="T:System.Windows.Forms.RichTextBox" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Por padrão, o <xref:System.Windows.Forms.TextBoxBase.Multiline%2A> propriedade do controle é definida como `true`.  
  
   
  
## Examples  
 O exemplo de código a seguir cria um <xref:System.Windows.Forms.RichTextBox> controle que carrega um arquivo RTF em controle e procura a primeira ocorrência da palavra "Texto". O código, em seguida, altera o estilo da fonte, tamanho da fonte e cor da fonte do texto selecionado e salva as alterações para o arquivo original. O código de exemplo terminar, adicionando o controle para seu <xref:System.Windows.Forms.Form>. Este exemplo requer que o método criado no exemplo de código é adicionado a um <xref:System.Windows.Forms.Form> classe e chamado a partir do construtor do formulário. O exemplo também requer que um arquivo RTF é criado na raiz da unidade C, que contém a palavra "Texto".  
  
 [!code-cpp[Classic RichTextBox Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic RichTextBox Example/CPP/source.cpp#1)]
 [!code-csharp[Classic RichTextBox Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic RichTextBox Example/CS/source.cs#1)]
 [!code-vb[Classic RichTextBox Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic RichTextBox Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.TextBoxBase.Multiline" />
      </Docs>
    </Member>
    <Member MemberName="AllowDrop">
      <MemberSignature Language="C#" Value="public override bool AllowDrop { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AllowDrop" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.RichTextBox.AllowDrop" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property AllowDrop As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool AllowDrop { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.AllowDrop : bool with get, set" Usage="System.Windows.Forms.RichTextBox.AllowDrop" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define um valor que indica se o controle habilitará operações do tipo "arrastar e soltar".</summary>
        <value>
          <see langword="true" /> se a operação do tipo "arrastar e soltar" estiver habilitada no controle; caso contrário, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O exemplo de código a seguir demonstra como executar operações de arrastar e soltar usando um <xref:System.Windows.Forms.ListBox> controle que contém itens para descartar em um <xref:System.Windows.Forms.RichTextBox> controle. O construtor de conjuntos de forma a <xref:System.Windows.Forms.RichTextBox.AllowDrop%2A> propriedade `true` para permitir operações de arrastar e soltar ocorrer no <xref:System.Windows.Forms.RichTextBox>. O exemplo usa o <xref:System.Windows.Forms.Control.MouseDown> evento o <xref:System.Windows.Forms.ListBox> para iniciar a operação de arrastar, chamando o <xref:System.Windows.Forms.Control.DoDragDrop%2A> método. O exemplo usa o <xref:System.Windows.Forms.Control.DragEnter> evento para determinar se um item que está sendo arrastado para o <xref:System.Windows.Forms.RichTextBox> é um tipo de dados válido. O <xref:System.Windows.Forms.Control.DragDrop> evento executa descartar real de um item arrastado para o <xref:System.Windows.Forms.RichTextBox> controle no local do cursor atual dentro de <xref:System.Windows.Forms.RichTextBox>. Este exemplo requer que o <xref:System.Windows.Forms.Control.DragDrop> e <xref:System.Windows.Forms.Control.DragEnter> eventos foram conectados aos manipuladores de eventos definidos no exemplo.  
  
 [!code-cpp[RichTextBox.AllowDrop#1](~/samples/snippets/cpp/VS_Snippets_Winforms/RichTextBox.AllowDrop/CPP/form1.cpp#1)]
 [!code-csharp[RichTextBox.AllowDrop#1](~/samples/snippets/csharp/VS_Snippets_Winforms/RichTextBox.AllowDrop/CS/form1.cs#1)]
 [!code-vb[RichTextBox.AllowDrop#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/RichTextBox.AllowDrop/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AutoSize">
      <MemberSignature Language="C#" Value="public override bool AutoSize { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AutoSize" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.RichTextBox.AutoSize" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property AutoSize As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool AutoSize { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.AutoSize : bool with get, set" Usage="System.Windows.Forms.RichTextBox.AutoSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.RefreshProperties</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Essa propriedade não é relevante para essa classe.</summary>
        <value>
          <see langword="true" /> se habilitado; caso contrário, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
-   Essa propriedade não é relevante para essa classe.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AutoWordSelection">
      <MemberSignature Language="C#" Value="public bool AutoWordSelection { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AutoWordSelection" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.RichTextBox.AutoWordSelection" />
      <MemberSignature Language="VB.NET" Value="Public Property AutoWordSelection As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool AutoWordSelection { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.AutoWordSelection : bool with get, set" Usage="System.Windows.Forms.RichTextBox.AutoWordSelection" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define um valor que indica se a seleção automática de palavras está habilitada.</summary>
        <value>
          <see langword="true" /> se a seleção automática de palavras estiver habilitada; caso contrário, <see langword="false" />. O padrão é <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se essa propriedade é definida como `true`, a seleção de qualquer parte do texto no controle seleciona a palavra inteira.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como criar um <xref:System.Windows.Forms.RichTextBox> que amplia texto, seleciona automaticamente palavras no texto do controle quando uma palavra é clicado duas vezes e tem uma margem no lado direito da área cliente do controle. Se o <xref:System.Windows.Forms.RichTextBox> controle tem uma largura pequena, usar esse código cria um <xref:System.Windows.Forms.RichTextBox> onde cada caractere de texto é exibido em sua própria linha. Enquanto nesta posição de exibição vertical, clicando em qualquer parte de uma palavra para selecionar todos os caracteres da palavra, independentemente do fato de que o texto é exibido na vertical. Este exemplo requer que você tenha um formulário que contém um <xref:System.Windows.Forms.RichTextBox> controle chamado `richTextBox1`.  
  
 [!code-cpp[RichTextBox.ZoomFactor#1](~/samples/snippets/cpp/VS_Snippets_Winforms/RichTextBox.ZoomFactor/CPP/form1.cpp#1)]
 [!code-csharp[RichTextBox.ZoomFactor#1](~/samples/snippets/csharp/VS_Snippets_Winforms/RichTextBox.ZoomFactor/CS/form1.cs#1)]
 [!code-vb[RichTextBox.ZoomFactor#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/RichTextBox.ZoomFactor/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BackgroundImage">
      <MemberSignature Language="C#" Value="public override System.Drawing.Image BackgroundImage { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Drawing.Image BackgroundImage" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.RichTextBox.BackgroundImage" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property BackgroundImage As Image" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Drawing::Image ^ BackgroundImage { System::Drawing::Image ^ get(); void set(System::Drawing::Image ^ value); };" />
      <MemberSignature Language="F#" Value="member this.BackgroundImage : System.Drawing.Image with get, set" Usage="System.Windows.Forms.RichTextBox.BackgroundImage" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.Image</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Essa propriedade não é relevante para essa classe.</summary>
        <value>A imagem de tela de fundo exibida no controle.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Essa propriedade não é relevante para essa classe.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BackgroundImageChanged">
      <MemberSignature Language="C#" Value="public event EventHandler BackgroundImageChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler BackgroundImageChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.RichTextBox.BackgroundImageChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event BackgroundImageChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ BackgroundImageChanged;" />
      <MemberSignature Language="F#" Value="member this.BackgroundImageChanged : EventHandler " Usage="member this.BackgroundImageChanged : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ocorre quando o valor da propriedade <see cref="P:System.Windows.Forms.RichTextBox.BackgroundImage" /> muda.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para obter mais informações sobre a manipulação de eventos, consulte [NIB: consumindo eventos](http://msdn.microsoft.com/library/01e4f1bc-e55e-413f-98c7-6588493e5f67).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BackgroundImageLayout">
      <MemberSignature Language="C#" Value="public override System.Windows.Forms.ImageLayout BackgroundImageLayout { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Forms.ImageLayout BackgroundImageLayout" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.RichTextBox.BackgroundImageLayout" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property BackgroundImageLayout As ImageLayout" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Windows::Forms::ImageLayout BackgroundImageLayout { System::Windows::Forms::ImageLayout get(); void set(System::Windows::Forms::ImageLayout value); };" />
      <MemberSignature Language="F#" Value="member this.BackgroundImageLayout : System.Windows.Forms.ImageLayout with get, set" Usage="System.Windows.Forms.RichTextBox.BackgroundImageLayout" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.ImageLayout</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Essa propriedade não é relevante para essa classe.</summary>
        <value>O layout da imagem de plano de fundo exibida no controle.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Essa propriedade não é relevante para essa classe.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BackgroundImageLayoutChanged">
      <MemberSignature Language="C#" Value="public event EventHandler BackgroundImageLayoutChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler BackgroundImageLayoutChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.RichTextBox.BackgroundImageLayoutChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event BackgroundImageLayoutChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ BackgroundImageLayoutChanged;" />
      <MemberSignature Language="F#" Value="member this.BackgroundImageLayoutChanged : EventHandler " Usage="member this.BackgroundImageLayoutChanged : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ocorre quando o valor da propriedade <see cref="P:System.Windows.Forms.RichTextBox.BackgroundImageLayout" /> muda.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse evento não é relevante para essa classe.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BulletIndent">
      <MemberSignature Language="C#" Value="public int BulletIndent { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 BulletIndent" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.RichTextBox.BulletIndent" />
      <MemberSignature Language="VB.NET" Value="Public Property BulletIndent As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int BulletIndent { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.BulletIndent : int with get, set" Usage="System.Windows.Forms.RichTextBox.BulletIndent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(0)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define o recuo usado no controle de <see cref="T:System.Windows.Forms.RichTextBox" /> quando o estilo de marcador é aplicado ao texto.</summary>
        <value>O número de pixels inseridos como o recuo após um marcador. O padrão é zero.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para aplicar o estilo de marcador para um parágrafo de texto, defina o <xref:System.Windows.Forms.RichTextBox.SelectionBullet%2A> propriedade `true` e, em seguida, defina o <xref:System.Windows.Forms.RichTextBox.BulletIndent%2A> propriedade para o número de pixels que o texto deve ser recuado. O parágrafo terá o estilo de marcador aplicado a ele com a quantidade especificada de recuo após o marcador. Essa propriedade só afeta o parágrafo atual no texto do controle e o marcador selecionado em uma lista de itens com marcadores. Para aplicar um nível de recuo diferente para uma lista completa dos itens com marcadores, todo o texto dos itens com marcadores deve ser selecionado antes de definir o <xref:System.Windows.Forms.RichTextBox.BulletIndent%2A> propriedade.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como usar o <xref:System.Windows.Forms.RichTextBox.SelectionBullet%2A> propriedade com o <xref:System.Windows.Forms.RichTextBox.BulletIndent%2A>, <xref:System.Windows.Forms.RichTextBox.SelectionFont%2A>, <xref:System.Windows.Forms.RichTextBox.SelectedText%2A>, e <xref:System.Windows.Forms.RichTextBox.SelectionColor%2A> propriedades para criar uma lista com marcadores em um <xref:System.Windows.Forms.RichTextBox> controle. Este exemplo requer que um <xref:System.Windows.Forms.RichTextBox> controle chamado `richTextBox1` é criado em um formulário.  
  
 [!code-cpp[RichTextBox.BulletIndent#1](~/samples/snippets/cpp/VS_Snippets_Winforms/RichTextBox.BulletIndent/CPP/form1.cpp#1)]
 [!code-csharp[RichTextBox.BulletIndent#1](~/samples/snippets/csharp/VS_Snippets_Winforms/RichTextBox.BulletIndent/CS/form1.cs#1)]
 [!code-vb[RichTextBox.BulletIndent#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/RichTextBox.BulletIndent/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">O recuo especificado era menor que zero.</exception>
        <altmember cref="P:System.Windows.Forms.RichTextBox.SelectionBullet" />
      </Docs>
    </Member>
    <Member MemberName="CanPaste">
      <MemberSignature Language="C#" Value="public bool CanPaste (System.Windows.Forms.DataFormats.Format clipFormat);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool CanPaste(class System.Windows.Forms.DataFormats/Format clipFormat) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.RichTextBox.CanPaste(System.Windows.Forms.DataFormats.Format)" />
      <MemberSignature Language="VB.NET" Value="Public Function CanPaste (clipFormat As DataFormats.Format) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool CanPaste(System::Windows::Forms::DataFormats::Format ^ clipFormat);" />
      <MemberSignature Language="F#" Value="member this.CanPaste : System.Windows.Forms.DataFormats.Format -&gt; bool" Usage="richTextBox.CanPaste clipFormat" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="clipFormat" Type="System.Windows.Forms.DataFormats+Format" />
      </Parameters>
      <Docs>
        <param name="clipFormat">Um dos valores de <see cref="T:System.Windows.Forms.DataFormats.Format" />.</param>
        <summary>Determina se você pode colar informações da Área de Transferência no formato de dados especificado.</summary>
        <returns>
          <see langword="true" /> se você puder colar dados da Área de Transferência no formato de dados especificado. Caso contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Você pode usar esse método para determinar se o conteúdo atual da área de transferência em um formato de dados de área de transferência especificado antes de habilitar o usuário colar as informações para o <xref:System.Windows.Forms.RichTextBox> controle. Por exemplo, você pode criar um manipulador de eventos para um <xref:System.Windows.Forms.MenuItem.Popup> eventos de um comando Colar <xref:System.Windows.Forms.MenuItem> e usar esse método para determinar se a colagem <xref:System.Windows.Forms.MenuItem> devem ser habilitadas com base no tipo de dados na área de transferência.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como usar o <xref:System.Windows.Forms.RichTextBox.Paste%2A> método para colar um bitmap para o <xref:System.Windows.Forms.RichTextBox> controle. Depois de abrir um bitmap de arquivo, o exemplo usa o <xref:System.Windows.Forms.Clipboard.SetDataObject%2A> método para copiar o bitmap para a área de transferência do Windows. Por fim, o exemplo recupera o formato para o <xref:System.Drawing.Bitmap> objeto, usa o <xref:System.Windows.Forms.RichTextBox.CanPaste%2A> método para verificar se o formato pode ser colado no <xref:System.Windows.Forms.RichTextBox> controle e, em seguida, usa o <xref:System.Windows.Forms.RichTextBox.Paste%2A> método para colar os dados.  
  
 [!code-cpp[RichText_Paste#1](~/samples/snippets/cpp/VS_Snippets_Winforms/RichText_Paste/CPP/form1.cpp#1)]
 [!code-csharp[RichText_Paste#1](~/samples/snippets/csharp/VS_Snippets_Winforms/RichText_Paste/CS/form1.cs#1)]
 [!code-vb[RichText_Paste#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/RichText_Paste/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.RichTextBox.Paste(System.Windows.Forms.DataFormats.Format)" />
        <altmember cref="T:System.Windows.Forms.DataFormats.Format" />
      </Docs>
    </Member>
    <Member MemberName="CanRedo">
      <MemberSignature Language="C#" Value="public bool CanRedo { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanRedo" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.RichTextBox.CanRedo" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CanRedo As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool CanRedo { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanRedo : bool" Usage="System.Windows.Forms.RichTextBox.CanRedo" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém um valor que indica se há ações que ocorreram dentro de <see cref="T:System.Windows.Forms.RichTextBox" /> que pode ser reaplicadas.</summary>
        <value>
          <see langword="true" /> Se não houver operações que foram desfeitas que podem ser reaplicadas ao conteúdo do controle; Caso contrário, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Você pode usar essa propriedade para determinar se a última operação desfeita no <xref:System.Windows.Forms.RichTextBox> pode ser reaplicada usando o <xref:System.Windows.Forms.RichTextBox.Redo%2A> método.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como usar o <xref:System.Windows.Forms.RichTextBox.CanRedo%2A> e <xref:System.Windows.Forms.RichTextBox.RedoActionName%2A> propriedades e o <xref:System.Windows.Forms.RichTextBox.Redo%2A> método para restringir uma operação de restauração para qualquer ação exceto a exclusão de texto. Este exemplo requer que você tenha um formulário que contém um <xref:System.Windows.Forms.RichTextBox> controle e que uma operação no <xref:System.Windows.Forms.RichTextBox> foi executada e desfeita antes do código neste exemplo é chamado.  
  
 [!code-cpp[RichTextBox.RedoAction#1](~/samples/snippets/cpp/VS_Snippets_Winforms/RichTextBox.RedoAction/CPP/form1.cpp#1)]
 [!code-csharp[RichTextBox.RedoAction#1](~/samples/snippets/csharp/VS_Snippets_Winforms/RichTextBox.RedoAction/CS/form1.cs#1)]
 [!code-vb[RichTextBox.RedoAction#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/RichTextBox.RedoAction/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.RichTextBox.Redo" />
      </Docs>
    </Member>
    <Member MemberName="ContentsResized">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.ContentsResizedEventHandler ContentsResized;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.ContentsResizedEventHandler ContentsResized" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.RichTextBox.ContentsResized" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ContentsResized As ContentsResizedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::ContentsResizedEventHandler ^ ContentsResized;" />
      <MemberSignature Language="F#" Value="member this.ContentsResized : System.Windows.Forms.ContentsResizedEventHandler " Usage="member this.ContentsResized : System.Windows.Forms.ContentsResizedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.ContentsResizedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ocorre quando o conteúdo dentro do controle é redimensionado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para obter mais informações sobre a manipulação de eventos, consulte [NIB: consumindo eventos](http://msdn.microsoft.com/library/01e4f1bc-e55e-413f-98c7-6588493e5f67).  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra o uso desse membro. No exemplo, um manipulador de eventos relatórios sobre a ocorrência da <xref:System.Windows.Forms.RichTextBox.ContentsResized> eventos. Este relatório ajuda você a saber quando o evento ocorre e pode ajudá-lo na depuração. Para gerar relatórios sobre vários eventos ou eventos que ocorrem com frequência, considere substituir <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> com <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> ou anexar a mensagem como um multiline <xref:System.Windows.Forms.TextBox>.  
  
 Para executar o código de exemplo, cole-o em um projeto que contém uma instância do tipo <xref:System.Windows.Forms.RichTextBox> chamado `RichTextBox1`. Certifique-se de que o manipulador de eventos está associado com o <xref:System.Windows.Forms.RichTextBox.ContentsResized> evento.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#537](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#537)]
 [!code-vb[System.Windows.Forms.EventExamples#537](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#537)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Forms.ContentsResizedEventHandler" />
      </Docs>
    </Member>
    <Member MemberName="CreateParams">
      <MemberSignature Language="C#" Value="protected override System.Windows.Forms.CreateParams CreateParams { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.CreateParams CreateParams" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.RichTextBox.CreateParams" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides ReadOnly Property CreateParams As CreateParams" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual property System::Windows::Forms::CreateParams ^ CreateParams { System::Windows::Forms::CreateParams ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.CreateParams : System.Windows.Forms.CreateParams" Usage="System.Windows.Forms.RichTextBox.CreateParams" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.CreateParams</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém os parâmetros de criação necessários quando a alça de controle é criada.</summary>
        <value>Um <see cref="T:System.Windows.Forms.CreateParams" /> que contém os parâmetros de criação necessários quando a alça de controle é criada.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateRichEditOleCallback">
      <MemberSignature Language="C#" Value="protected virtual object CreateRichEditOleCallback ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance object CreateRichEditOleCallback() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.RichTextBox.CreateRichEditOleCallback" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function CreateRichEditOleCallback () As Object" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Object ^ CreateRichEditOleCallback();" />
      <MemberSignature Language="F#" Value="abstract member CreateRichEditOleCallback : unit -&gt; obj&#xA;override this.CreateRichEditOleCallback : unit -&gt; obj" Usage="richTextBox.CreateRichEditOleCallback " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Cria um objeto compatível com <see langword="IRichEditOleCallback" /> para lidar com operações de retorno de chamada de edição avançada.</summary>
        <returns>Um objeto que implementa a interface do <see langword="IRichEditOleCallback" />.</returns>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">para o chamador imediato chamar código não gerenciado. Enumeração associada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <block subset="none" type="overrides">
          <para>Você pode substituir esse método em sua classe derivada para habilitar o acesso a recursos de edição avançada base. Se você substituir esse método, todos os eventos de arrastar e soltar não serão gerados. Como resultado, você precisará fornecer seu próprio suporte para operações de arrastar e soltar. Para obter mais informações sobre o <see langword="IRichEditOleCallback" /> interface, consulte a documentação do SDK da plataforma em http://msdn.microsoft.com.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="DefaultSize">
      <MemberSignature Language="C#" Value="protected override System.Drawing.Size DefaultSize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Size DefaultSize" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.RichTextBox.DefaultSize" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides ReadOnly Property DefaultSize As Size" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual property System::Drawing::Size DefaultSize { System::Drawing::Size get(); };" />
      <MemberSignature Language="F#" Value="member this.DefaultSize : System.Drawing.Size" Usage="System.Windows.Forms.RichTextBox.DefaultSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.Size</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém o tamanho padrão do controle.</summary>
        <value>Um valor <see cref="T:System.Drawing.Size" />.</value>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Windows.Forms.TextBoxBase.DefaultSize" />
      </Docs>
    </Member>
    <Member MemberName="DetectUrls">
      <MemberSignature Language="C#" Value="public bool DetectUrls { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool DetectUrls" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.RichTextBox.DetectUrls" />
      <MemberSignature Language="VB.NET" Value="Public Property DetectUrls As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool DetectUrls { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.DetectUrls : bool with get, set" Usage="System.Windows.Forms.RichTextBox.DetectUrls" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define um valor que indica se o <see cref="T:System.Windows.Forms.RichTextBox" /> formatará automaticamente ou não uma URL (Uniform Resource Locator) quando ela for digitada no controle.</summary>
        <value>
          <see langword="true" /> se o <see cref="T:System.Windows.Forms.RichTextBox" /> formatará automaticamente URLs que são digitadas no controle como um link; caso contrário, <see langword="false" />. O padrão é <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se essa propriedade é definida como `true`, qualquer texto inserido no controle que é determinado pelo <xref:System.Windows.Forms.RichTextBox> para ser uma URL é formatada automaticamente como um link. Você pode criar um manipulador de eventos para o <xref:System.Windows.Forms.RichTextBox.LinkClicked> eventos para lidar com todos os links clicado no controle. O <xref:System.Windows.Forms.LinkClickedEventArgs> que é fornecido para o manipulador de eventos para o <xref:System.Windows.Forms.RichTextBox.LinkClicked> evento fornece dados que permite que você determine qual link foi clicado no controle para processar o link.  
  
   
  
## Examples  
 O exemplo de código a seguir contém um manipulador de eventos para o <xref:System.Windows.Forms.RichTextBox.LinkClicked> evento. O manipulador de eventos processa os cliques de link dentro do documento de um <xref:System.Windows.Forms.RichTextBox> controlar e inicia uma instância do navegador padrão (usando o <xref:System.Diagnostics.Process.Start%2A?displayProperty=nameWithType> método), exibindo a página para o link foi clicado. Este exemplo requer que o manipulador de eventos está conectado para o <xref:System.Windows.Forms.RichTextBox.LinkClicked> evento para um <xref:System.Windows.Forms.RichTextBox>.  
  
 [!code-cpp[Classic RichTextBox.LinkClicked Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic RichTextBox.LinkClicked Example/CPP/source.cpp#1)]
 [!code-csharp[Classic RichTextBox.LinkClicked Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic RichTextBox.LinkClicked Example/CS/source.cs#1)]
 [!code-vb[Classic RichTextBox.LinkClicked Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic RichTextBox.LinkClicked Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Forms.RichTextBox.LinkClicked" />
        <altmember cref="T:System.Windows.Forms.LinkClickedEventArgs" />
      </Docs>
    </Member>
    <Member MemberName="DragDrop">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.DragEventHandler DragDrop;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.DragEventHandler DragDrop" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.RichTextBox.DragDrop" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event DragDrop As DragEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::DragEventHandler ^ DragDrop;" />
      <MemberSignature Language="F#" Value="member this.DragDrop : System.Windows.Forms.DragEventHandler " Usage="member this.DragDrop : System.Windows.Forms.DragEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.DragEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ocorre quando o usuário conclui uma operação do tipo "arrastar e soltar"</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DragEnter">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.DragEventHandler DragEnter;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.DragEventHandler DragEnter" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.RichTextBox.DragEnter" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event DragEnter As DragEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::DragEventHandler ^ DragEnter;" />
      <MemberSignature Language="F#" Value="member this.DragEnter : System.Windows.Forms.DragEventHandler " Usage="member this.DragEnter : System.Windows.Forms.DragEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.DragEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ocorre quando um objeto é arrastado para os limites do controle.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para obter mais informações sobre a manipulação de eventos, consulte [NIB: consumindo eventos](http://msdn.microsoft.com/library/01e4f1bc-e55e-413f-98c7-6588493e5f67).  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra o uso desse membro. No exemplo, um manipulador de eventos relatórios sobre a ocorrência da <xref:System.Windows.Forms.RichTextBox.DragEnter> eventos. Este relatório ajuda você a saber quando o evento ocorre e pode ajudá-lo na depuração. Para gerar relatórios sobre vários eventos ou eventos que ocorrem com frequência, considere substituir <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> com <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> ou anexar a mensagem como um multiline <xref:System.Windows.Forms.TextBox>.  
  
 Para executar o código de exemplo, cole-o em um projeto que contém uma instância do tipo <xref:System.Windows.Forms.RichTextBox> chamado `RichTextBox1`. Certifique-se de que o manipulador de eventos está associado com o <xref:System.Windows.Forms.RichTextBox.DragEnter> evento.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#539](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#539)]
 [!code-vb[System.Windows.Forms.EventExamples#539](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#539)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DragLeave">
      <MemberSignature Language="C#" Value="public event EventHandler DragLeave;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler DragLeave" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.RichTextBox.DragLeave" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event DragLeave As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ DragLeave;" />
      <MemberSignature Language="F#" Value="member this.DragLeave : EventHandler " Usage="member this.DragLeave : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ocorre quando um objeto é arrastado para fora dos limites do controle.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse evento não é relevante para essa classe. Para obter mais informações sobre a manipulação de eventos, consulte [NIB: consumindo eventos](http://msdn.microsoft.com/library/01e4f1bc-e55e-413f-98c7-6588493e5f67).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DragOver">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.DragEventHandler DragOver;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.DragEventHandler DragOver" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.RichTextBox.DragOver" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event DragOver As DragEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::DragEventHandler ^ DragOver;" />
      <MemberSignature Language="F#" Value="member this.DragOver : System.Windows.Forms.DragEventHandler " Usage="member this.DragOver : System.Windows.Forms.DragEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.DragEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ocorre quando um objeto é arrastado sobre os limites do controle.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse evento não é relevante para essa classe. Para obter mais informações sobre a manipulação de eventos, consulte [NIB: consumindo eventos](http://msdn.microsoft.com/library/01e4f1bc-e55e-413f-98c7-6588493e5f67).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DrawToBitmap">
      <MemberSignature Language="C#" Value="public void DrawToBitmap (System.Drawing.Bitmap bitmap, System.Drawing.Rectangle targetBounds);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawToBitmap(class System.Drawing.Bitmap bitmap, valuetype System.Drawing.Rectangle targetBounds) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.RichTextBox.DrawToBitmap(System.Drawing.Bitmap,System.Drawing.Rectangle)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawToBitmap(System::Drawing::Bitmap ^ bitmap, System::Drawing::Rectangle targetBounds);" />
      <MemberSignature Language="F#" Value="override this.DrawToBitmap : System.Drawing.Bitmap * System.Drawing.Rectangle -&gt; unit" Usage="richTextBox.DrawToBitmap (bitmap, targetBounds)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bitmap" Type="System.Drawing.Bitmap" />
        <Parameter Name="targetBounds" Type="System.Drawing.Rectangle" />
      </Parameters>
      <Docs>
        <param name="bitmap">Um <see cref="T:System.Drawing.Bitmap" />.</param>
        <param name="targetBounds">Um <see cref="T:System.Drawing.Rectangle" />.</param>
        <summary>Esse método não é relevante para essa classe.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método não é relevante para essa classe.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EnableAutoDragDrop">
      <MemberSignature Language="C#" Value="public bool EnableAutoDragDrop { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool EnableAutoDragDrop" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.RichTextBox.EnableAutoDragDrop" />
      <MemberSignature Language="VB.NET" Value="Public Property EnableAutoDragDrop As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool EnableAutoDragDrop { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.EnableAutoDragDrop : bool with get, set" Usage="System.Windows.Forms.RichTextBox.EnableAutoDragDrop" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define um valor que habilita operações do tipo "arrastar e soltar" em texto, imagens e outros dados.</summary>
        <value>
          <see langword="true" /> para permitir operações de arrastar e soltar; Caso contrário, <see langword="false" />. O padrão é <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Find">
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Pesquisa texto no conteúdo do <see cref="T:System.Windows.Forms.RichTextBox" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Find">
      <MemberSignature Language="C#" Value="public int Find (char[] characterSet);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Find(char[] characterSet) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.RichTextBox.Find(System.Char[])" />
      <MemberSignature Language="VB.NET" Value="Public Function Find (characterSet As Char()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Find(cli::array &lt;char&gt; ^ characterSet);" />
      <MemberSignature Language="F#" Value="member this.Find : char[] -&gt; int" Usage="richTextBox.Find characterSet" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="characterSet" Type="System.Char[]" />
      </Parameters>
      <Docs>
        <param name="characterSet">A matriz de caracteres a ser pesquisada.</param>
        <summary>Pesquisa o texto de um <see cref="T:System.Windows.Forms.RichTextBox" /> controle para a primeira instância de um caractere em uma lista de caracteres.</summary>
        <returns>O local no controle, em que os caracteres da pesquisa foram encontrados ou -1 se os caracteres da pesquisa não foram encontrados ou se um conjunto de caracteres de pesquisa vazio foi especificado no parâmetro <paramref name="char" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esta versão do <xref:System.Windows.Forms.RichTextBox.Find%2A> método procura a primeira instância de um caractere em uma lista de caracteres especificada no `characterSet` parâmetro e retorna o local do caractere. Por exemplo, você pode passar uma matriz de caracteres que contém o caractere 'Q'. Se o controle contiver o texto "A Brown raposa", o <xref:System.Windows.Forms.RichTextBox.Find%2A> método retornará o valor de quatro. Um caractere em letra maiuscula e um caractere minúsculo são considerados valores diferentes na pesquisa.  
  
 Se a propriedade retorna um valor negativo, os caracteres que está sendo pesquisados não foram encontrados no conteúdo do controle. Você pode usar esse método para pesquisar um grupo de caracteres dentro do controle. Esta versão do <xref:System.Windows.Forms.RichTextBox.Find%2A> método requer que o documento inteiro contido no controle é procurado os caracteres. Se um caractere na lista de caracteres fornecida no método de `characterSet` parâmetro for encontrado, o valor retornado por esse método é um índice com base em zero da posição do caractere no controle. Um espaço é considerado um caractere pelo método ao determinar o local de um caractere.  
  
   
  
## Examples  
 O exemplo de código a seguir pesquisa o conteúdo de um <xref:System.Windows.Forms.RichTextBox> para os caracteres que são passados para o método de `text` parâmetro. Se o conteúdo do `text` matriz são encontrados no <xref:System.Windows.Forms.RichTextBox>, o método retorna o índice do valor que for encontrado; caso contrário, retornará -1. O exemplo requer que esse método é colocado na classe de um <xref:System.Windows.Forms.Form> que contém um <xref:System.Windows.Forms.RichTextBox> controle chamado `richTextBox1` e um <xref:System.Windows.Forms.Button> controle, chamado `button1`, que é conectado ao `Click` manipulador de eventos definido em o exemplo.  
  
 [!code-cpp[RichTextBox.FindChar1#1](~/samples/snippets/cpp/VS_Snippets_Winforms/RichTextBox.FindChar1/CPP/form1.cpp#1)]
 [!code-csharp[RichTextBox.FindChar1#1](~/samples/snippets/csharp/VS_Snippets_Winforms/RichTextBox.FindChar1/CS/form1.cs#1)]
 [!code-vb[RichTextBox.FindChar1#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/RichTextBox.FindChar1/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Find">
      <MemberSignature Language="C#" Value="public int Find (string str);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Find(string str) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.RichTextBox.Find(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Find (str As String) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Find(System::String ^ str);" />
      <MemberSignature Language="F#" Value="member this.Find : string -&gt; int" Usage="richTextBox.Find str" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="str" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="str">O texto a ser localizado no controle.</param>
        <summary>Pesquisa uma cadeia de caracteres no texto em um controle <see cref="T:System.Windows.Forms.RichTextBox" />.</summary>
        <returns>O local no controle, em que o texto da pesquisa foi encontrado ou -1 se o texto da pesquisa não foi encontrado ou se uma cadeia de caracteres vazia foi especificada no parâmetro <paramref name="str" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Windows.Forms.RichTextBox.Find%2A> método pesquisa o texto especificado no `str` parâmetro e retorna o local do primeiro caractere dentro do controle. Se a propriedade retorna um valor negativo, a cadeia de caracteres de texto que está sendo pesquisada não foi encontrada dentro do conteúdo do controle. Você pode usar esse método para criar a funcionalidade de pesquisa que pode ser fornecida para o usuário do controle. Você também pode usar esse método para pesquisar texto a ser substituído com um formato específico. Por exemplo, se o usuário inseriu datas no controle, você pode usar o <xref:System.Windows.Forms.RichTextBox.Find%2A> método para pesquisar todas as datas no documento e substituí-los com o formato apropriado antes de usar o <xref:System.Windows.Forms.RichTextBox.SaveFile%2A> método do controle.  
  
> [!NOTE]
>  O <xref:System.Windows.Forms.RichTextBox.Find%2A> métodos que aceitam um `string` como um parâmetro não é possível localizar o texto que está contido em mais de uma linha de texto dentro de <xref:System.Windows.Forms.RichTextBox>. Executar essa pesquisa retornará um valor negativo um (-1).  
  
   
  
## Examples  
 O exemplo de código a seguir pesquisa todo o conteúdo de um <xref:System.Windows.Forms.RichTextBox> para a primeira instância de uma cadeia de caracteres de pesquisa passado para o parâmetro de texto do método. Se a cadeia de caracteres for encontrada no <xref:System.Windows.Forms.RichTextBox>, o método retorna um valor de `true` e realça o texto de pesquisa, caso contrário ele retornará `false`. O exemplo requer que esse método é colocado na classe de um <xref:System.Windows.Forms.Form> que contém um <xref:System.Windows.Forms.RichTextBox> chamado `richTextBox1`.  
  
 [!code-cpp[Classic RichTextBox.Find Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic RichTextBox.Find Example/CPP/source.cpp#1)]
 [!code-csharp[Classic RichTextBox.Find Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic RichTextBox.Find Example/CS/source.cs#1)]
 [!code-vb[Classic RichTextBox.Find Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic RichTextBox.Find Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Find">
      <MemberSignature Language="C#" Value="public int Find (char[] characterSet, int start);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Find(char[] characterSet, int32 start) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.RichTextBox.Find(System.Char[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Find (characterSet As Char(), start As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Find(cli::array &lt;char&gt; ^ characterSet, int start);" />
      <MemberSignature Language="F#" Value="member this.Find : char[] * int -&gt; int" Usage="richTextBox.Find (characterSet, start)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="characterSet" Type="System.Char[]" />
        <Parameter Name="start" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="characterSet">A matriz de caracteres a ser pesquisada.</param>
        <param name="start">O local dentro do texto do controle no qual iniciar a pesquisa.</param>
        <summary>Pesquisa em um ponto inicial específico, a primeira instância de um caractere em uma lista de caracteres no texto de um controle <see cref="T:System.Windows.Forms.RichTextBox" />.</summary>
        <returns>O local no controle em que os caracteres de pesquisa foram encontrados.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esta versão do <xref:System.Windows.Forms.RichTextBox.Find%2A> método procura a primeira instância de um caractere em uma lista de caracteres especificada no `characterSet` parâmetro e retorna o local do caractere. Por exemplo, você pode passar uma matriz de caracteres que contém o caractere 'Q'. Se o controle contiver o texto "A Brown raposa", o <xref:System.Windows.Forms.RichTextBox.Find%2A> método retornará o valor de quatro. Um caractere em letra maiuscula e um caractere minúsculo são considerados valores diferentes na pesquisa.  
  
 Se a propriedade retorna um valor negativo, os caracteres que está sendo pesquisados não foram encontrados no conteúdo do controle. Você pode usar esse método para pesquisar um grupo de caracteres dentro do controle. Se um caractere na lista de caracteres fornecida no método de `characterSet` parâmetro for encontrado, o valor retornado por esse método é um índice com base em zero da posição do caractere no controle. Um espaço é considerado um caractere pelo método ao determinar o local de um caractere.  
  
 Esta versão do <xref:System.Windows.Forms.RichTextBox.Find%2A> método permite que você procure um conjunto de caracteres de uma posição inicial especificada dentro do texto do controle, especificando um valor para o `start` parâmetro. Um valor de zero indica que a pesquisa deve começar do início do documento do controle. Você pode usar esta versão do <xref:System.Windows.Forms.RichTextBox.Find%2A> método para restringir sua pesquisa para evitar o texto que você já sabe que não contém os caracteres especificados, você está procurando ou não é importantes para sua pesquisa.  
  
   
  
## Examples  
 O exemplo de código a seguir pesquisa o conteúdo de um <xref:System.Windows.Forms.RichTextBox> para os caracteres que são passados para o método de `text` parâmetro. A pesquisa começa no local dentro a <xref:System.Windows.Forms.RichTextBox> especificado pelo `start` parâmetro do `FindMyText` método. Se o conteúdo da matriz de texto for encontrado na <xref:System.Windows.Forms.RichTextBox>, o método retorna o índice do valor que for encontrado; caso contrário, retornará -1. O exemplo requer que esse método é colocado na classe de um <xref:System.Windows.Forms.Form> que contém um <xref:System.Windows.Forms.RichTextBox> controle chamado `richTextBox1` e um <xref:System.Windows.Forms.Button> controle chamado `button1` que esteja conectado ao <xref:System.Windows.Forms.Control.Click> manipulador de eventos definido no exemplo.  
  
 [!code-cpp[RichTextBox.FindChar2#1](~/samples/snippets/cpp/VS_Snippets_Winforms/RichTextBox.FindChar2/CPP/form1.cpp#1)]
 [!code-csharp[RichTextBox.FindChar2#1](~/samples/snippets/csharp/VS_Snippets_Winforms/RichTextBox.FindChar2/CS/form1.cs#1)]
 [!code-vb[RichTextBox.FindChar2#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/RichTextBox.FindChar2/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Find">
      <MemberSignature Language="C#" Value="public int Find (string str, System.Windows.Forms.RichTextBoxFinds options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Find(string str, valuetype System.Windows.Forms.RichTextBoxFinds options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.RichTextBox.Find(System.String,System.Windows.Forms.RichTextBoxFinds)" />
      <MemberSignature Language="VB.NET" Value="Public Function Find (str As String, options As RichTextBoxFinds) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Find(System::String ^ str, System::Windows::Forms::RichTextBoxFinds options);" />
      <MemberSignature Language="F#" Value="member this.Find : string * System.Windows.Forms.RichTextBoxFinds -&gt; int" Usage="richTextBox.Find (str, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="str" Type="System.String" />
        <Parameter Name="options" Type="System.Windows.Forms.RichTextBoxFinds" />
      </Parameters>
      <Docs>
        <param name="str">O texto a ser localizado no controle.</param>
        <param name="options">Uma combinação bit a bit dos valores <see cref="T:System.Windows.Forms.RichTextBoxFinds" />.</param>
        <summary>Pesquisa o texto em um controle <see cref="T:System.Windows.Forms.RichTextBox" /> para uma cadeia de caracteres com opções específicas aplicadas à pesquisa.</summary>
        <returns>O local no controle em que o texto de pesquisa foi encontrado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Windows.Forms.RichTextBox.Find%2A> método pesquisa o texto especificado no `str` parâmetro e retorna o local do primeiro caractere dentro do controle. Se a propriedade retorna um valor negativo, a cadeia de caracteres de texto que está sendo pesquisada não foi encontrada dentro do conteúdo do controle. Você pode usar esse método para criar a funcionalidade de pesquisa que pode ser fornecida para o usuário do controle. Você também pode usar esse método para pesquisar texto a ser substituído com um formato específico. Por exemplo, se o usuário inseriu datas no controle, você pode usar o <xref:System.Windows.Forms.RichTextBox.Find%2A> método para pesquisar todas as datas no documento e substituí-los com o formato apropriado antes de usar o <xref:System.Windows.Forms.RichTextBox.SaveFile%2A> método do controle.  
  
 Com esta versão do <xref:System.Windows.Forms.RichTextBox.Find%2A> método, você pode especificar opções que permitem que você expandir ou restringir sua pesquisa. Você pode especificar opções que permitem que você para coincidir com o uso de maiusculas e minúsculas de palavra de pesquisa ou para pesquisar por palavras inteiras em vez de palavras parciais. Especificando o `RichTextBoxFinds.Reverse` enumeração no `options` parâmetro, você pode procurar texto na parte inferior do documento na parte superior, em vez de parte superior de padrão para o método de pesquisa da parte inferior.  
  
> [!NOTE]
>  O <xref:System.Windows.Forms.RichTextBox.Find%2A> métodos que aceitam um `string` como um parâmetro não é possível localizar o texto que está contido em mais de uma linha de texto dentro de <xref:System.Windows.Forms.RichTextBox>. Executar essa pesquisa retornará um valor negativo um (-1).  
  
   
  
## Examples  
 O exemplo de código a seguir pesquisa todo o conteúdo de um <xref:System.Windows.Forms.RichTextBox> para a primeira instância de uma cadeia de caracteres de pesquisa passado para o parâmetro de texto do método. Se a cadeia de caracteres for encontrada no <xref:System.Windows.Forms.RichTextBox>, o método retorna um valor de `true` e realça o texto; caso contrário, retornará `false`. O exemplo também especifica opções na pesquisa para diferenciar maiusculas de minúsculas da cadeia de caracteres de pesquisa especificada. O exemplo requer que esse método é colocado na classe de um <xref:System.Windows.Forms.Form> que contém um <xref:System.Windows.Forms.RichTextBox> chamado `richTextBox1`.  
  
 [!code-cpp[Classic RichTextBox.Find1 Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic RichTextBox.Find1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic RichTextBox.Find1 Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic RichTextBox.Find1 Example/CS/source.cs#1)]
 [!code-vb[Classic RichTextBox.Find1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic RichTextBox.Find1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Find">
      <MemberSignature Language="C#" Value="public int Find (char[] characterSet, int start, int end);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Find(char[] characterSet, int32 start, int32 end) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.RichTextBox.Find(System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Find (characterSet As Char(), start As Integer, end As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Find(cli::array &lt;char&gt; ^ characterSet, int start, int end);" />
      <MemberSignature Language="F#" Value="member this.Find : char[] * int * int -&gt; int" Usage="richTextBox.Find (characterSet, start, end)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="characterSet" Type="System.Char[]" />
        <Parameter Name="start" Type="System.Int32" />
        <Parameter Name="end" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="characterSet">A matriz de caracteres a ser pesquisada.</param>
        <param name="start">O local dentro do texto do controle no qual iniciar a pesquisa.</param>
        <param name="end">A localização no texto do controle no qual a pesquisa será finalizada.</param>
        <summary>Pesquisa o intervalo de texto em um controle <see cref="T:System.Windows.Forms.RichTextBox" /> para a primeira instância de um caractere em uma lista de caracteres.</summary>
        <returns>O local no controle em que os caracteres de pesquisa foram encontrados.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esta versão do <xref:System.Windows.Forms.RichTextBox.Find%2A> método procura a primeira instância de um caractere em uma lista de caracteres especificada no `characterSet` parâmetro e retorna o local do caractere. Por exemplo, você pode passar uma matriz de caracteres que contém o caractere 'Q'. Se o controle contiver o texto "A Brown raposa", o <xref:System.Windows.Forms.RichTextBox.Find%2A> método retornará o valor de quatro. Um caractere em letra maiuscula e um caractere minúsculo são considerados valores diferentes na pesquisa.  
  
 Se a propriedade retorna um valor negativo, os caracteres que está sendo pesquisados não foram encontrados no conteúdo do controle. Você pode usar esse método para pesquisar um grupo de caracteres dentro do controle. Se um caractere na lista de caracteres fornecida no método de `characterSet` parâmetro for encontrado, o valor retornado por esse método é baseado em um zero índice de posição do caractere no controle. Um espaço é considerado um caractere pelo método ao determinar o local de um caractere.  
  
 Esta versão do <xref:System.Windows.Forms.RichTextBox.Find%2A> método permite que você procure um conjunto de caracteres de um intervalo de texto no controle, especificando um valor para o `start` e `end` parâmetros. Um valor de zero para o `start` parâmetro indica que a pesquisa deve começar do início do documento do controle. Um valor de-1 para o `end` parâmetro indica que a pesquisa deve terminar no final do texto dentro do controle. Você pode usar esta versão do <xref:System.Windows.Forms.RichTextBox.Find%2A> método para restringir sua pesquisa a um intervalo específico de texto dentro do controle para evitar a busca áreas do documento que não são importantes para as necessidades do seu aplicativo.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="characterSet" /> é nulo.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="start" /> é menor que 0 ou maior que o tamanho do texto no controle.</exception>
      </Docs>
    </Member>
    <Member MemberName="Find">
      <MemberSignature Language="C#" Value="public int Find (string str, int start, System.Windows.Forms.RichTextBoxFinds options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Find(string str, int32 start, valuetype System.Windows.Forms.RichTextBoxFinds options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.RichTextBox.Find(System.String,System.Int32,System.Windows.Forms.RichTextBoxFinds)" />
      <MemberSignature Language="VB.NET" Value="Public Function Find (str As String, start As Integer, options As RichTextBoxFinds) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Find(System::String ^ str, int start, System::Windows::Forms::RichTextBoxFinds options);" />
      <MemberSignature Language="F#" Value="member this.Find : string * int * System.Windows.Forms.RichTextBoxFinds -&gt; int" Usage="richTextBox.Find (str, start, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="str" Type="System.String" />
        <Parameter Name="start" Type="System.Int32" />
        <Parameter Name="options" Type="System.Windows.Forms.RichTextBoxFinds" />
      </Parameters>
      <Docs>
        <param name="str">O texto a ser localizado no controle.</param>
        <param name="start">O local dentro do texto do controle no qual iniciar a pesquisa.</param>
        <param name="options">Uma combinação bit a bit dos valores <see cref="T:System.Windows.Forms.RichTextBoxFinds" />.</param>
        <summary>Pesquisa o texto em um controle <see cref="T:System.Windows.Forms.RichTextBox" /> para uma cadeia de caracteres em um local específico dentro do controle e com opções específicas aplicadas à pesquisa.</summary>
        <returns>O local no controle em que o texto de pesquisa foi encontrado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Windows.Forms.RichTextBox.Find%2A> método pesquisa o texto especificado no `str` parâmetro e retorna o local do primeiro caractere da pesquisa de cadeia de caracteres dentro do controle. Se a propriedade retorna um valor negativo, a cadeia de caracteres de texto que está sendo pesquisada não foi encontrada dentro do conteúdo do controle. Você pode usar esse método para criar a funcionalidade de pesquisa que pode ser fornecida para o usuário do controle. Você também pode usar esse método para pesquisar texto a ser substituído com um formato específico. Por exemplo, se o usuário inseriu datas no controle, você pode usar o <xref:System.Windows.Forms.RichTextBox.Find%2A> método para pesquisar todas as datas no documento e substituí-los com o formato apropriado antes de usar o <xref:System.Windows.Forms.RichTextBox.SaveFile%2A> método do controle.  
  
 Com esta versão do <xref:System.Windows.Forms.RichTextBox.Find%2A> método, você pode especificar opções que permitem que você expandir ou restringir sua pesquisa. Você pode especificar opções que permitem que você para coincidir com o uso de maiusculas e minúsculas de palavra de pesquisa ou para pesquisar por palavras inteiras em vez de palavras parciais. Especificando o `RichTextBoxFinds.Reverse` enumeração no `options` parâmetro, você pode procurar texto na parte inferior do documento na parte superior, em vez de parte superior de padrão para o método de pesquisa da parte inferior. Esta versão do <xref:System.Windows.Forms.RichTextBox.Find%2A> método também permite que você restrinja a pesquisa de texto, selecionando uma posição inicial específica dentro do texto do controle. Esse recurso permite que você evite o texto que pode ter já foi pesquisado ou onde o texto específico que você está procurando é conhecido para não existe. Quando o `RichTextBoxFinds.Reverse` valor é especificado no `options` parâmetro, o valor do `start` parâmetro indica a posição onde a pesquisa inversa terminará desde que a pesquisa começará na parte inferior do documento ao usar esta versão das <xref:System.Windows.Forms.RichTextBox.Find%2A> método.  
  
> [!NOTE]
>  O <xref:System.Windows.Forms.RichTextBox.Find%2A> métodos que aceitam um `string` como um parâmetro não é possível localizar o texto que está contido em mais de uma linha de texto dentro de <xref:System.Windows.Forms.RichTextBox>. Executar essa pesquisa retornará um valor negativo um (-1).  
  
   
  
## Examples  
 O exemplo de código a seguir pesquisa todo o conteúdo de um <xref:System.Windows.Forms.RichTextBox> para a primeira instância de uma cadeia de caracteres de pesquisa passado para o parâmetro de texto do método. A pesquisa de ponto de partida é especificada pelo parâmetro de início do método. Se a cadeia de caracteres for encontrada no <xref:System.Windows.Forms.RichTextBox>, o método retorna o local do índice do primeiro caractere do texto localizado e realça o texto localizado; caso contrário, ele retorna um valor de -1. O exemplo também especifica opções na pesquisa para diferenciar maiusculas de minúsculas da cadeia de caracteres de pesquisa especificada. O exemplo requer que esse método é colocado na classe de um <xref:System.Windows.Forms.Form> que contém um <xref:System.Windows.Forms.RichTextBox> chamado `richTextBox1`. Você pode usar este exemplo para realizar um "Localizar próximo" tipo de operação. Depois que uma instância do texto de pesquisa foi encontrada, você pode encontrar outras instâncias do texto, alterando o valor da `start` parâmetro para pesquisar em um local além da posição da correspondência atual.  
  
 [!code-cpp[Classic RichTextBox.Find2 Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic RichTextBox.Find2 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic RichTextBox.Find2 Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic RichTextBox.Find2 Example/CS/source.cs#1)]
 [!code-vb[Classic RichTextBox.Find2 Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic RichTextBox.Find2 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Find">
      <MemberSignature Language="C#" Value="public int Find (string str, int start, int end, System.Windows.Forms.RichTextBoxFinds options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Find(string str, int32 start, int32 end, valuetype System.Windows.Forms.RichTextBoxFinds options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.RichTextBox.Find(System.String,System.Int32,System.Int32,System.Windows.Forms.RichTextBoxFinds)" />
      <MemberSignature Language="VB.NET" Value="Public Function Find (str As String, start As Integer, end As Integer, options As RichTextBoxFinds) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Find(System::String ^ str, int start, int end, System::Windows::Forms::RichTextBoxFinds options);" />
      <MemberSignature Language="F#" Value="member this.Find : string * int * int * System.Windows.Forms.RichTextBoxFinds -&gt; int" Usage="richTextBox.Find (str, start, end, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="str" Type="System.String" />
        <Parameter Name="start" Type="System.Int32" />
        <Parameter Name="end" Type="System.Int32" />
        <Parameter Name="options" Type="System.Windows.Forms.RichTextBoxFinds" />
      </Parameters>
      <Docs>
        <param name="str">O texto a ser localizado no controle.</param>
        <param name="start">O local dentro do texto do controle no qual iniciar a pesquisa.</param>
        <param name="end">A localização no texto do controle no qual a pesquisa será finalizada. Esse valor deve ser igual a um negativo (-1) ou maior ou igual ao parâmetro <c>start</c>.</param>
        <param name="options">Uma combinação bit a bit dos valores <see cref="T:System.Windows.Forms.RichTextBoxFinds" />.</param>
        <summary>Pesquisa o texto em um controle <see cref="T:System.Windows.Forms.RichTextBox" /> para uma cadeia de caracteres no controle e com opções específicas aplicadas à pesquisa.</summary>
        <returns>O local no controle em que o texto de pesquisa foi encontrado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Windows.Forms.RichTextBox.Find%2A> método pesquisa o texto especificado no `str` parâmetro e retorna o local do primeiro caractere da pesquisa de cadeia de caracteres dentro do controle. Se a propriedade retorna um valor negativo, a cadeia de caracteres de texto que está sendo pesquisada não foi encontrada dentro do conteúdo do controle. Você pode usar esse método para criar a funcionalidade de pesquisa que pode ser fornecida para o usuário do controle. Você também pode usar esse método para pesquisar texto a ser substituído com um formato específico. Por exemplo, se o usuário inseriu datas no controle, você pode usar o <xref:System.Windows.Forms.RichTextBox.Find%2A> método para pesquisar todas as datas no documento e substituí-los com o formato apropriado antes de usar o <xref:System.Windows.Forms.RichTextBox.SaveFile%2A> método do controle.  
  
 Com esta versão do <xref:System.Windows.Forms.RichTextBox.Find%2A> método, você pode especificar opções que permitem que você expandir ou restringir sua pesquisa. Você pode especificar opções que permitem que você para coincidir com o uso de maiusculas e minúsculas de palavra de pesquisa ou para pesquisar por palavras inteiras em vez de palavras parciais. Especificando o `RichTextBoxFinds.Reverse` enumeração no `options` parâmetro, você pode procurar texto na parte inferior do documento na parte superior, em vez de parte superior de padrão para o método de pesquisa da parte inferior. Esta versão do <xref:System.Windows.Forms.RichTextBox.Find%2A> método também permite que você restrinja a pesquisa de texto, selecionando uma posição de início e de término específica dentro do texto do controle. Esse recurso permite que você limitar o intervalo de pesquisa para uma seção específica do texto do controle. Se um valor negativo (-1) é atribuído para o `end` parâmetro, o método irá procurar até o fim do texto no <xref:System.Windows.Forms.RichTextBox> para pesquisas normais. Para pesquisas inversas, um valor de um negativo (-1) atribuído para o `end` parâmetro indica que texto será pesquisado do final do texto (inferior) para a posição definida pelo `start` parâmetro. Quando o `start` e `end` parâmetros são fornecidos para o mesmo valor de todo o controle é procurado pesquisas normais. Para uma pesquisa inversa, todo o controle é procurado, mas a pesquisa começa na parte inferior do documento e pesquisa para a parte superior do documento.  
  
> [!NOTE]
>  O <xref:System.Windows.Forms.RichTextBox.Find%2A> métodos que aceitam um `string` como um parâmetro não é possível localizar o texto que está contido em mais de uma linha de texto dentro de <xref:System.Windows.Forms.RichTextBox>. Executar essa pesquisa retornará um valor negativo um (-1).  
  
   
  
## Examples  
 O exemplo de código a seguir procura uma seção de texto em uma <xref:System.Windows.Forms.RichTextBox> para a primeira instância de uma cadeia de caracteres de pesquisa passado para o `searchText` parâmetro do método. O intervalo para procurar texto dentro do controle é especificado com o `searchStart` e `searchEnd` parâmetros do método. Se a cadeia de caracteres for encontrada no <xref:System.Windows.Forms.RichTextBox>, o método retorna o local do índice do primeiro caractere do texto localizado e realça o texto localizado; caso contrário, ele retorna um valor de -1. O exemplo também usa o `options` parâmetro o <xref:System.Windows.Forms.RichTextBox.Find%2A> método para especificar que o texto localizado deve corresponder a ocorrência da cadeia de caracteres de pesquisa. O exemplo requer que esse método é colocado na classe de um <xref:System.Windows.Forms.Form> que contém um <xref:System.Windows.Forms.RichTextBox> controle chamado `richTextBox1`. Após a primeira ocorrência da cadeia de caracteres de pesquisa, foi encontrada, você pode usar este exemplo para localizar outras ocorrências do texto.  
  
 [!code-cpp[RichTextBox.FindStringStartEnd#1](~/samples/snippets/cpp/VS_Snippets_Winforms/RichTextBox.FindStringStartEnd/CPP/form1.cpp#1)]
 [!code-csharp[RichTextBox.FindStringStartEnd#1](~/samples/snippets/csharp/VS_Snippets_Winforms/RichTextBox.FindStringStartEnd/CS/form1.cs#1)]
 [!code-vb[RichTextBox.FindStringStartEnd#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/RichTextBox.FindStringStartEnd/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">O parâmetro <paramref name="str" /> era <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">O parâmetro <paramref name="end" /> era menor que o <paramref name="start" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Font">
      <MemberSignature Language="C#" Value="public override System.Drawing.Font Font { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Drawing.Font Font" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.RichTextBox.Font" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property Font As Font" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Drawing::Font ^ Font { System::Drawing::Font ^ get(); void set(System::Drawing::Font ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Font : System.Drawing.Font with get, set" Usage="System.Windows.Forms.RichTextBox.Font" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.Font</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define a fonte do texto exibido pelo controle.</summary>
        <value>O <see cref="T:System.Drawing.Font" /> a ser aplicado ao texto exibido pelo controle. O padrão é o valor da propriedade <see cref="P:System.Windows.Forms.Control.DefaultFont" />.</value>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Windows.Forms.Control.Font" />
      </Docs>
    </Member>
    <Member MemberName="ForeColor">
      <MemberSignature Language="C#" Value="public override System.Drawing.Color ForeColor { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Color ForeColor" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.RichTextBox.ForeColor" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property ForeColor As Color" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Drawing::Color ForeColor { System::Drawing::Color get(); void set(System::Drawing::Color value); };" />
      <MemberSignature Language="F#" Value="member this.ForeColor : System.Drawing.Color with get, set" Usage="System.Windows.Forms.RichTextBox.ForeColor" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.Color</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define a cor de primeiro plano do controle.</summary>
        <value>Um <see cref="T:System.Drawing.Color" /> que representa a cor de primeiro plano do controle.</value>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Windows.Forms.TextBoxBase.ForeColor" />
      </Docs>
    </Member>
    <Member MemberName="GetCharIndexFromPosition">
      <MemberSignature Language="C#" Value="public override int GetCharIndexFromPosition (System.Drawing.Point pt);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetCharIndexFromPosition(valuetype System.Drawing.Point pt) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.RichTextBox.GetCharIndexFromPosition(System.Drawing.Point)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetCharIndexFromPosition (pt As Point) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetCharIndexFromPosition(System::Drawing::Point pt);" />
      <MemberSignature Language="F#" Value="override this.GetCharIndexFromPosition : System.Drawing.Point -&gt; int" Usage="richTextBox.GetCharIndexFromPosition pt" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pt" Type="System.Drawing.Point" />
      </Parameters>
      <Docs>
        <param name="pt">O local a ser pesquisado.</param>
        <summary>Recupera o índice do caractere mais próximo ao local especificado.</summary>
        <returns>O índice de caracteres baseado em zero no local especificado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método retorna o índice do caractere mais próximo à posição especificada no `pt` parâmetro. O índice de caracteres é um índice com base em zero do texto no controle, incluindo espaços. Você pode usar esse método para determinar onde o texto o usuário tem o mouse por passar o mouse coordenadas para esse método. Isso pode ser útil se você quiser executar tarefas quando o usuário posicionar o ponteiro do mouse sobre uma palavra no texto do controle.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como usar o <xref:System.Windows.Forms.RichTextBox.GetCharIndexFromPosition%2A> método com o <xref:System.Windows.Forms.RichTextBox.Find%2A> método para pesquisar uma cadeia de caracteres específica em um <xref:System.Windows.Forms.RichTextBox> controlar e exibir o índice de caracteres onde a cadeia de caracteres encontrada está localizada dentro de <xref:System.Windows.Forms.RichTextBox> controle. O exemplo procura a palavra "brown" dentro do conteúdo do controle e retorna a posição de índice de caracteres onde a cadeia de caracteres de pesquisa foi encontrada. Este exemplo requer que você tenha um formulário que contém um <xref:System.Windows.Forms.RichTextBox> controle chamado `richTextBox1` que contém texto. Ele também exige que o código de exemplo é conectado ao <xref:System.Windows.Forms.Control.MouseDown> eventos do <xref:System.Windows.Forms.RichTextBox>.  
  
 [!code-cpp[RichTextBox.GetCharIndexFromPosition#1](~/samples/snippets/cpp/VS_Snippets_Winforms/RichTextBox.GetCharIndexFromPosition/CPP/form1.cpp#1)]
 [!code-csharp[RichTextBox.GetCharIndexFromPosition#1](~/samples/snippets/csharp/VS_Snippets_Winforms/RichTextBox.GetCharIndexFromPosition/CS/form1.cs#1)]
 [!code-vb[RichTextBox.GetCharIndexFromPosition#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/RichTextBox.GetCharIndexFromPosition/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.RichTextBox.GetLineFromCharIndex(System.Int32)" />
        <altmember cref="M:System.Windows.Forms.RichTextBox.GetPositionFromCharIndex(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetLineFromCharIndex">
      <MemberSignature Language="C#" Value="public override int GetLineFromCharIndex (int index);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetLineFromCharIndex(int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.RichTextBox.GetLineFromCharIndex(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetLineFromCharIndex (index As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetLineFromCharIndex(int index);" />
      <MemberSignature Language="F#" Value="override this.GetLineFromCharIndex : int -&gt; int" Usage="richTextBox.GetLineFromCharIndex index" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">A posição de índice do caractere a ser pesquisada.</param>
        <summary>Recupera o número de linha da posição de caractere especificada dentro do texto do controle <see cref="T:System.Windows.Forms.RichTextBox" />.</summary>
        <returns>O número de linha de base zero no qual o índice do caractere está localizado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método permite que você determine o número de linha com base no índice de caractere especificado no `index` parâmetro do método. A primeira linha do texto no controle retorna o valor zero. O <xref:System.Windows.Forms.RichTextBox.GetLineFromCharIndex%2A> método retorna o número de linha física em que o caractere indexado está localizado dentro do controle. Por exemplo, se uma parte da primeira linha do texto na lógica de controle envolve para a próxima linha, o <xref:System.Windows.Forms.RichTextBox.GetLineFromCharIndex%2A> método retornará 1 se o caractere no índice de caractere especificado foi quebrada para a segunda linha física. Se <xref:System.Windows.Forms.TextBoxBase.WordWrap%2A> é definido como `false`, nenhuma parte da linha é quebrada para a próxima, e o método retorna 0 para o índice do caractere especificado. Você pode usar esse método para determinar qual linha um índice de caracteres específica está localizado em. Por exemplo, depois de chamar o <xref:System.Windows.Forms.RichTextBox.Find%2A> método para pesquisar texto, você pode obter o índice de caracteres onde os resultados da pesquisa são encontrados. Você pode chamar esse método com o índice de caracteres retornado pelo <xref:System.Windows.Forms.RichTextBox.Find%2A> método para determinar qual linha o word foi encontrado.  
  
 Em certos casos, <xref:System.Windows.Forms.RichTextBox.GetLineFromCharIndex%2A> não gerará uma exceção quando o `index` parâmetro é um valor inválido. Por exemplo:  
  
-   Se o `index` parâmetro é <xref:System.Int32.MinValue> ou -1, <xref:System.Windows.Forms.RichTextBox.GetLineFromCharIndex%2A> retornará 0.  
  
-   Se o `index` parâmetro é o comprimento do texto ou <xref:System.Int32.MaxValue>, <xref:System.Windows.Forms.RichTextBox.GetLineFromCharIndex%2A> retorna o número da última linha de texto, que não é necessariamente o mesmo como `Lines.Length-1`, dependendo do valor de <xref:System.Windows.Forms.TextBoxBase.WordWrap%2A> propriedade.  
  
 Nesses casos, validar a entrada antes de chamar <xref:System.Windows.Forms.RichTextBox.GetLineFromCharIndex%2A>.  
  
> [!NOTE]
>  Se o índice do caractere especificado no `index` parâmetro está além do número disponível de linhas contidas dentro do controle, o último número de linha é retornado.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como usar o <xref:System.Windows.Forms.RichTextBox.GetLineFromCharIndex%2A> método. Para executar o exemplo, cole o seguinte código em um formulário que contém um <xref:System.Windows.Forms.RichTextBox> controle chamado `RichTextBox1`, um botão chamado `Button1` e duas caixas de texto denominadas `TextBox1` e `TextBox2`. Quando o exemplo é executado, insira uma cadeia de caracteres de pesquisa no `TextBox2` e clique no botão para obter os resultados da pesquisa.  
  
 [!code-cpp[System.Windows.Forms.RichTextBoxGetLine#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.RichTextBoxGetLine/CPP/form1.cpp#1)]
 [!code-csharp[System.Windows.Forms.RichTextBoxGetLine#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.RichTextBoxGetLine/CS/form1.cs#1)]
 [!code-vb[System.Windows.Forms.RichTextBoxGetLine#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.RichTextBoxGetLine/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.RichTextBox.GetCharIndexFromPosition(System.Drawing.Point)" />
        <altmember cref="M:System.Windows.Forms.RichTextBox.GetPositionFromCharIndex(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetPositionFromCharIndex">
      <MemberSignature Language="C#" Value="public override System.Drawing.Point GetPositionFromCharIndex (int index);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance valuetype System.Drawing.Point GetPositionFromCharIndex(int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.RichTextBox.GetPositionFromCharIndex(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetPositionFromCharIndex (index As Integer) As Point" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Drawing::Point GetPositionFromCharIndex(int index);" />
      <MemberSignature Language="F#" Value="override this.GetPositionFromCharIndex : int -&gt; System.Drawing.Point" Usage="richTextBox.GetPositionFromCharIndex index" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.Point</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">O índice do caractere para o qual o local deve ser recuperado.</param>
        <summary>Recupera o local dentro do controle no índice de caractere especificado.</summary>
        <returns>O local do caractere especificado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método permite que você determine onde um índice de caracteres específica está localizado no controle. Você pode usar esse método para executar tarefas como exibir informações de itens ou a Ajuda de menu de atalho para uma palavra no controle. Por exemplo, se você quiser exibir um menu de opções para o usuário quando o usuário clica em uma palavra de controle, você pode usar esse método para determinar a posição do word para exibir corretamente um <xref:System.Windows.Forms.ContextMenu> controle.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.RichTextBox.GetCharIndexFromPosition(System.Drawing.Point)" />
        <altmember cref="M:System.Windows.Forms.RichTextBox.GetLineFromCharIndex(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GiveFeedback">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.GiveFeedbackEventHandler GiveFeedback;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.GiveFeedbackEventHandler GiveFeedback" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.RichTextBox.GiveFeedback" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event GiveFeedback As GiveFeedbackEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::GiveFeedbackEventHandler ^ GiveFeedback;" />
      <MemberSignature Language="F#" Value="member this.GiveFeedback : System.Windows.Forms.GiveFeedbackEventHandler " Usage="member this.GiveFeedback : System.Windows.Forms.GiveFeedbackEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.GiveFeedbackEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ocorre durante uma operação de arrastar.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse evento não é relevante para essa classe.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="HScroll">
      <MemberSignature Language="C#" Value="public event EventHandler HScroll;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler HScroll" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.RichTextBox.HScroll" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event HScroll As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ HScroll;" />
      <MemberSignature Language="F#" Value="member this.HScroll : EventHandler " Usage="member this.HScroll : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ocorre quando o usuário clica na barra de rolagem horizontal do controle.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para obter mais informações sobre a manipulação de eventos, consulte [NIB: consumindo eventos](http://msdn.microsoft.com/library/01e4f1bc-e55e-413f-98c7-6588493e5f67).  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra o uso desse membro. No exemplo, um manipulador de eventos relatórios sobre a ocorrência da <xref:System.Windows.Forms.RichTextBox.HScroll> eventos. Este relatório ajuda você a saber quando o evento ocorre e pode ajudá-lo na depuração. Para gerar relatórios sobre vários eventos ou eventos que ocorrem com frequência, considere substituir <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> com <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> ou anexar a mensagem como um multiline <xref:System.Windows.Forms.TextBox>.  
  
 Para executar o código de exemplo, cole-o em um projeto que contém uma instância do tipo <xref:System.Windows.Forms.RichTextBox> chamado `RichTextBox1`. Certifique-se de que o manipulador de eventos está associado com o <xref:System.Windows.Forms.RichTextBox.HScroll> evento.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#540](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#540)]
 [!code-vb[System.Windows.Forms.EventExamples#540](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#540)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ImeChange">
      <MemberSignature Language="C#" Value="public event EventHandler ImeChange;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler ImeChange" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.RichTextBox.ImeChange" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ImeChange As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ ImeChange;" />
      <MemberSignature Language="F#" Value="member this.ImeChange : EventHandler " Usage="member this.ImeChange : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ocorre quando o usuário alterna métodos de entrada em uma versão asiática do sistema operacional Windows.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para obter mais informações sobre a manipulação de eventos, consulte [NIB: consumindo eventos](http://msdn.microsoft.com/library/01e4f1bc-e55e-413f-98c7-6588493e5f67).  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra o uso desse membro. No exemplo, um manipulador de eventos relatórios sobre a ocorrência da <xref:System.Windows.Forms.RichTextBox.ImeChange> eventos. Este relatório ajuda você a saber quando o evento ocorre e pode ajudá-lo na depuração. Para gerar relatórios sobre vários eventos ou eventos que ocorrem com frequência, considere substituir <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> com <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> ou anexar a mensagem como um multiline <xref:System.Windows.Forms.TextBox>.  
  
 Para executar o código de exemplo, cole-o em um projeto que contém uma instância do tipo <xref:System.Windows.Forms.RichTextBox> chamado `RichTextBox1`. Certifique-se de que o manipulador de eventos está associado com o <xref:System.Windows.Forms.RichTextBox.ImeChange> evento.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#542](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#542)]
 [!code-vb[System.Windows.Forms.EventExamples#542](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#542)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LanguageOption">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.RichTextBoxLanguageOptions LanguageOption { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Forms.RichTextBoxLanguageOptions LanguageOption" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.RichTextBox.LanguageOption" />
      <MemberSignature Language="VB.NET" Value="Public Property LanguageOption As RichTextBoxLanguageOptions" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Forms::RichTextBoxLanguageOptions LanguageOption { System::Windows::Forms::RichTextBoxLanguageOptions get(); void set(System::Windows::Forms::RichTextBoxLanguageOptions value); };" />
      <MemberSignature Language="F#" Value="member this.LanguageOption : System.Windows.Forms.RichTextBoxLanguageOptions with get, set" Usage="System.Windows.Forms.RichTextBox.LanguageOption" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.RichTextBoxLanguageOptions</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define um valor que indica as configurações do <see cref="T:System.Windows.Forms.RichTextBox" /> para IME e suporte a idiomas asiáticos.</summary>
        <value>Um dos valores de <see cref="T:System.Windows.Forms.RichTextBoxLanguageOptions" />. O padrão é <see cref="F:System.Windows.Forms.RichTextBoxLanguageOptions.AutoFontSizeAdjust" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="LinkClicked">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.LinkClickedEventHandler LinkClicked;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.LinkClickedEventHandler LinkClicked" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.RichTextBox.LinkClicked" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event LinkClicked As LinkClickedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::LinkClickedEventHandler ^ LinkClicked;" />
      <MemberSignature Language="F#" Value="member this.LinkClicked : System.Windows.Forms.LinkClickedEventHandler " Usage="member this.LinkClicked : System.Windows.Forms.LinkClickedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.LinkClickedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ocorre quando o usuário clica em um link dentro do texto do controle.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Você pode criar um manipulador de eventos para esse evento processar um link que foi clicado dentro do controle. Usando as informações fornecidas para o manipulador de eventos, você pode determinar qual link foi clicado no documento.  
  
> [!IMPORTANT]
>  Por padrão, os links são exibidos como texto e não são clicáveis. Para torná-los em conjunto clicável o <xref:System.Windows.Forms.RichTextBox.DetectUrls%2A> propriedade `true`.  
  
 Para obter mais informações sobre a manipulação de eventos, consulte [NIB: consumindo eventos](http://msdn.microsoft.com/library/01e4f1bc-e55e-413f-98c7-6588493e5f67).  
  
   
  
## Examples  
 O exemplo de código a seguir contém um manipulador de eventos para o <xref:System.Windows.Forms.RichTextBox.LinkClicked> evento. O manipulador de eventos processa os cliques de link dentro do documento de um <xref:System.Windows.Forms.RichTextBox> controlar e inicia uma instância do navegador padrão (usando o <xref:System.Diagnostics.Process.Start%2A?displayProperty=nameWithType> método), exibindo a página para o link foi clicado. Este exemplo requer que o manipulador de eventos está conectado para o <xref:System.Windows.Forms.RichTextBox.LinkClicked> evento para um <xref:System.Windows.Forms.RichTextBox>.  
  
 [!code-cpp[Classic RichTextBox.LinkClicked Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic RichTextBox.LinkClicked Example/CPP/source.cpp#1)]
 [!code-csharp[Classic RichTextBox.LinkClicked Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic RichTextBox.LinkClicked Example/CS/source.cs#1)]
 [!code-vb[Classic RichTextBox.LinkClicked Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic RichTextBox.LinkClicked Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.RichTextBox.DetectUrls" />
      </Docs>
    </Member>
    <MemberGroup MemberName="LoadFile">
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Carrega o conteúdo de um arquivo no controle <see cref="T:System.Windows.Forms.RichTextBox" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="LoadFile">
      <MemberSignature Language="C#" Value="public void LoadFile (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void LoadFile(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.RichTextBox.LoadFile(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub LoadFile (path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void LoadFile(System::String ^ path);" />
      <MemberSignature Language="F#" Value="member this.LoadFile : string -&gt; unit" Usage="richTextBox.LoadFile path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">O nome e o local do arquivo a ser carregado no controle.</param>
        <summary>Carrega um arquivo de texto RTF ou ASCII padrão no controle <see cref="T:System.Windows.Forms.RichTextBox" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ao carregar um arquivo com o <xref:System.Windows.Forms.RichTextBox.LoadFile%2A> método, o conteúdo do arquivo que está sendo carregado substitua todo o conteúdo do <xref:System.Windows.Forms.RichTextBox> controle. Isso fará com que os valores de <xref:System.Windows.Forms.TextBoxBase.Text%2A> e <xref:System.Windows.Forms.RichTextBox.Rtf%2A> propriedades para alterar. Você pode usar esse método para carregar um texto criado anteriormente ou documento RTF para o controle para manipulação. Se você deseja salvar o arquivo, você pode usar o <xref:System.Windows.Forms.RichTextBox.SaveFile%2A> método.  
  
> [!NOTE]
>  Com esta versão do <xref:System.Windows.Forms.RichTextBox.LoadFile%2A> método, se o arquivo que está sendo carregado não é um documento RTF, ocorrerá uma exceção. Para carregar um tipo diferente de arquivo, como um arquivo de texto ASCII, use as outras versões desse método que aceite um valor da <xref:System.Windows.Forms.RichTextBoxStreamType> enumeração como um parâmetro.  
  
> [!NOTE]
>  O <xref:System.Windows.Forms.RichTextBox.LoadFile%2A> método não abrirá um arquivo até que um identificador é criado para o <xref:System.Windows.Forms.RichTextBox>. Certifique-se de que o identificador do controle é criado antes de chamar o <xref:System.Windows.Forms.RichTextBox.LoadFile%2A> método.  
  
   
  
## Examples  
 O exemplo de código a seguir abre um arquivo RTF no <xref:System.Windows.Forms.RichTextBox> controle. O exemplo usa o <xref:System.Windows.Forms.OpenFileDialog> classe para exibir uma caixa de diálogo para solicitar o arquivo do usuário. Arquivo de documento de código e os carrega esse arquivo supondo que é um arquivo RTF. Se o arquivo não for, o código de exemplo lançará uma exceção. Este exemplo requer que o código é colocado em uma <xref:System.Windows.Forms.Form> classe que tem um <xref:System.Windows.Forms.RichTextBox> controle chamado `richTextBox1`.  
  
 [!code-cpp[Classic RichTextBox.LoadFile Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic RichTextBox.LoadFile Example/CPP/source.cpp#1)]
 [!code-csharp[Classic RichTextBox.LoadFile Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic RichTextBox.LoadFile Example/CS/source.cs#1)]
 [!code-vb[Classic RichTextBox.LoadFile Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic RichTextBox.LoadFile Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Ocorreu um erro ao carregar o arquivo no controle.</exception>
        <exception cref="T:System.ArgumentException">O arquivo que está sendo carregado não é um documento RTF.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Para abrir um arquivo. Enumeração associada: O <see langword="Read" /> valor <see cref="T:System.Security.Permissions.FileIOPermissionAccess" />.</permission>
        <altmember cref="M:System.Windows.Forms.RichTextBox.SaveFile(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="LoadFile">
      <MemberSignature Language="C#" Value="public void LoadFile (System.IO.Stream data, System.Windows.Forms.RichTextBoxStreamType fileType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void LoadFile(class System.IO.Stream data, valuetype System.Windows.Forms.RichTextBoxStreamType fileType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.RichTextBox.LoadFile(System.IO.Stream,System.Windows.Forms.RichTextBoxStreamType)" />
      <MemberSignature Language="VB.NET" Value="Public Sub LoadFile (data As Stream, fileType As RichTextBoxStreamType)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void LoadFile(System::IO::Stream ^ data, System::Windows::Forms::RichTextBoxStreamType fileType);" />
      <MemberSignature Language="F#" Value="member this.LoadFile : System.IO.Stream * System.Windows.Forms.RichTextBoxStreamType -&gt; unit" Usage="richTextBox.LoadFile (data, fileType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.IO.Stream" />
        <Parameter Name="fileType" Type="System.Windows.Forms.RichTextBoxStreamType" />
      </Parameters>
      <Docs>
        <param name="data">Um fluxo de dados a se carregar no controle <see cref="T:System.Windows.Forms.RichTextBox" />.</param>
        <param name="fileType">Um dos valores de <see cref="T:System.Windows.Forms.RichTextBoxStreamType" />.</param>
        <summary>Carrega os conteúdos de um fluxo de dados existente no controle <see cref="T:System.Windows.Forms.RichTextBox" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Você pode usar esta versão do <xref:System.Windows.Forms.RichTextBox.LoadFile%2A> método ao carregar o <xref:System.Windows.Forms.RichTextBox> com dados de um fluxo existente de dados. Os dados que são carregados no controle substituem todo o conteúdo do <xref:System.Windows.Forms.RichTextBox> controle. Isso fará com que os valores de <xref:System.Windows.Forms.TextBoxBase.Text%2A> e <xref:System.Windows.Forms.RichTextBox.Rtf%2A> propriedades para alterar. Você pode usar esse método para carregar um arquivo que foi aberto anteriormente em um fluxo de dados para o controle para manipulação. Se você deseja salvar o conteúdo do controle novamente no fluxo, você pode usar o <xref:System.Windows.Forms.RichTextBox.SaveFile%2A> método aceita um <xref:System.IO.Stream> objeto como um parâmetro.  
  
 Esta versão do <xref:System.Windows.Forms.RichTextBox.LoadFile%2A> método também permite que você especifique o tipo de dados que está sendo carregados no controle. Esse recurso permite que você use fluxos de dados que contêm dados que não seja de documentos de formato RTF RTF no controle.  
  
> [!NOTE]
>  O <xref:System.Windows.Forms.RichTextBox.LoadFile%2A> método não abrirá um arquivo até que um identificador é criado para o <xref:System.Windows.Forms.RichTextBox>. Certifique-se de que o identificador do controle é criado antes de chamar o <xref:System.Windows.Forms.RichTextBox.LoadFile%2A> método.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como usar o <xref:System.Windows.Forms.RichTextBox.SaveFile%2A> e <xref:System.Windows.Forms.RichTextBox.LoadFile%2A> métodos com fluxos. Ele também demonstra como usar o <xref:System.Windows.Forms.FileDialog.FileName%2A?displayProperty=nameWithType>, <xref:System.Windows.Forms.FileDialog.DefaultExt%2A?displayProperty=nameWithType>, <xref:System.Windows.Forms.SaveFileDialog.CreatePrompt%2A?displayProperty=nameWithType>, e <xref:System.Windows.Forms.SaveFileDialog.OverwritePrompt%2A?displayProperty=nameWithType> membros.  
  
 Este é um exemplo completo que está pronto para ser executado quando você copiá-lo ao seu projeto.  
  
 [!code-cpp[System.Windows.Forms.RichTextBoxSaveFile#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.RichTextBoxSaveFile/CPP/form1.cpp#1)]
 [!code-csharp[System.Windows.Forms.RichTextBoxSaveFile#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.RichTextBoxSaveFile/CS/form1.cs#1)]
 [!code-vb[System.Windows.Forms.RichTextBoxSaveFile#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.RichTextBoxSaveFile/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Ocorreu um erro ao carregar o arquivo no controle.</exception>
        <exception cref="T:System.ArgumentException">O arquivo que está sendo carregado não é um documento RTF.</exception>
        <altmember cref="M:System.Windows.Forms.RichTextBox.SaveFile(System.String)" />
        <altmember cref="T:System.IO.Stream" />
        <altmember cref="T:System.Windows.Forms.RichTextBoxStreamType" />
      </Docs>
    </Member>
    <Member MemberName="LoadFile">
      <MemberSignature Language="C#" Value="public void LoadFile (string path, System.Windows.Forms.RichTextBoxStreamType fileType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void LoadFile(string path, valuetype System.Windows.Forms.RichTextBoxStreamType fileType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.RichTextBox.LoadFile(System.String,System.Windows.Forms.RichTextBoxStreamType)" />
      <MemberSignature Language="VB.NET" Value="Public Sub LoadFile (path As String, fileType As RichTextBoxStreamType)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void LoadFile(System::String ^ path, System::Windows::Forms::RichTextBoxStreamType fileType);" />
      <MemberSignature Language="F#" Value="member this.LoadFile : string * System.Windows.Forms.RichTextBoxStreamType -&gt; unit" Usage="richTextBox.LoadFile (path, fileType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="fileType" Type="System.Windows.Forms.RichTextBoxStreamType" />
      </Parameters>
      <Docs>
        <param name="path">O nome e o local do arquivo a ser carregado no controle.</param>
        <param name="fileType">Um dos valores de <see cref="T:System.Windows.Forms.RichTextBoxStreamType" />.</param>
        <summary>Carrega um tipo específico de arquivo no controle <see cref="T:System.Windows.Forms.RichTextBox" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ao carregar um arquivo com o <xref:System.Windows.Forms.RichTextBox.LoadFile%2A> método, o conteúdo do arquivo que está sendo carregado substitua todo o conteúdo do <xref:System.Windows.Forms.RichTextBox> controle. Isso fará com que os valores de <xref:System.Windows.Forms.TextBoxBase.Text%2A> e <xref:System.Windows.Forms.RichTextBox.Rtf%2A> propriedades para alterar. Você pode usar esse método para carregar um texto criado anteriormente ou documento RTF (RTF) para o controle para manipulação. Se você deseja salvar o arquivo, você pode usar o <xref:System.Windows.Forms.RichTextBox.SaveFile%2A> método.  
  
 Você pode usar esta versão do <xref:System.Windows.Forms.RichTextBox.LoadFile%2A> método para especificar o tipo de arquivo do arquivo que está sendo carregado. Esse recurso permite que você carregar os arquivos que não sejam documentos RTF no controle.  
  
> [!NOTE]
>  O <xref:System.Windows.Forms.RichTextBox.LoadFile%2A> método não abrirá um arquivo até que um identificador é criado para o <xref:System.Windows.Forms.RichTextBox>. Certifique-se de que o identificador do controle é criado antes de chamar o <xref:System.Windows.Forms.RichTextBox.LoadFile%2A> método.  
  
   
  
## Examples  
 O exemplo de código a seguir abre um arquivo de texto para o <xref:System.Windows.Forms.RichTextBox> controle. O exemplo usa o <xref:System.Windows.Forms.OpenFileDialog> classe para exibir uma caixa de diálogo para solicitar o arquivo do usuário. O código, em seguida, carrega esse arquivo para o <xref:System.Windows.Forms.RichTextBox> controle. O exemplo usa esta versão do <xref:System.Windows.Forms.RichTextBox.LoadFile%2A> método para especificar que o arquivo ser aberto como um arquivo de texto ASCII em vez do formato RTF padrão. Este exemplo requer que o código é colocado em uma <xref:System.Windows.Forms.Form> classe que tem um <xref:System.Windows.Forms.RichTextBox> controle chamado `richTextBox1`.  
  
 [!code-cpp[Classic RichTextBox.LoadFile1 Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic RichTextBox.LoadFile1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic RichTextBox.LoadFile1 Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic RichTextBox.LoadFile1 Example/CS/source.cs#1)]
 [!code-vb[Classic RichTextBox.LoadFile1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic RichTextBox.LoadFile1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Ocorreu um erro ao carregar o arquivo no controle.</exception>
        <exception cref="T:System.ArgumentException">O arquivo que está sendo carregado não é um documento RTF.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Para abrir um arquivo. Enumeração associada: O <see langword="Read" /> valor <see cref="T:System.Security.Permissions.FileIOPermissionAccess" />.</permission>
        <altmember cref="M:System.Windows.Forms.RichTextBox.SaveFile(System.String)" />
        <altmember cref="T:System.Windows.Forms.RichTextBoxStreamType" />
      </Docs>
    </Member>
    <Member MemberName="MaxLength">
      <MemberSignature Language="C#" Value="public override int MaxLength { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 MaxLength" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.RichTextBox.MaxLength" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property MaxLength As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int MaxLength { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.MaxLength : int with get, set" Usage="System.Windows.Forms.RichTextBox.MaxLength" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(2147483647)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define o número máximo de caracteres que o usuário pode digitar ou colar no controle da caixa RTF.</summary>
        <value>O número de caracteres que podem ser inseridos no controle. O padrão é <see cref="F:System.Int32.MaxValue" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando essa propriedade é definida como 0, o comprimento máximo do texto que pode ser inserido no controle é 64 KB de caracteres. Essa propriedade normalmente é usado quando o <xref:System.Windows.Forms.RichTextBox> é usado para exibir uma única linha de texto de formato RTF RTF. Você pode usar essa propriedade para restringir o comprimento do texto inserido no controle de valores como códigos postais e números de telefone ou restringir o comprimento do texto inserido quando os dados sejam inseridos em um banco de dados. Você pode limitar o texto inserido no controle para o comprimento máximo do campo correspondente no banco de dados.  
  
> [!NOTE]
>  No código, você pode definir o valor da <xref:System.Windows.Forms.TextBoxBase.Text%2A> propriedade para um valor que tem um comprimento maior que o valor especificado pelo <xref:System.Windows.Forms.TextBoxBase.MaxLength%2A> propriedade. Essa propriedade afeta apenas o texto inserido no controle em tempo de execução.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como usar o <xref:System.Windows.Forms.RichTextBox.MaxLength%2A> para determinar se o texto que está sendo atribuído a uma <xref:System.Windows.Forms.RichTextBox> controle é maior do que o valor atribuído ao <xref:System.Windows.Forms.RichTextBox.MaxLength%2A> propriedade. Se o texto não for maior, o exemplo usa o <xref:System.Windows.Forms.RichTextBox.SelectedText%2A> propriedade para atribuir o texto para o controle. Este exemplo requer que um <xref:System.Windows.Forms.RichTextBox> controle, chamado `richTextBox1`, foi adicionado a um formulário e que o método no exemplo é chamado com o texto fornecido para o parâmetro a ser colado no controle. O exemplo também requer que o <xref:System.Windows.Forms.TextBoxBase.MaxLength%2A> propriedade foi definida como um valor para limitar a entrada de texto para o <xref:System.Windows.Forms.RichTextBox>.  
  
 [!code-cpp[RichTextBox.MaxLength#1](~/samples/snippets/cpp/VS_Snippets_Winforms/RichTextBox.MaxLength/CPP/form1.cpp#1)]
 [!code-csharp[RichTextBox.MaxLength#1](~/samples/snippets/csharp/VS_Snippets_Winforms/RichTextBox.MaxLength/CS/form1.cs#1)]
 [!code-vb[RichTextBox.MaxLength#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/RichTextBox.MaxLength/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">O valor atribuído à propriedade é menor que 0.</exception>
        <altmember cref="P:System.Windows.Forms.TextBoxBase.MaxLength" />
      </Docs>
    </Member>
    <Member MemberName="Multiline">
      <MemberSignature Language="C#" Value="public override bool Multiline { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Multiline" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.RichTextBox.Multiline" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property Multiline As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool Multiline { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.Multiline : bool with get, set" Usage="System.Windows.Forms.RichTextBox.Multiline" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define um valor que indica se esse é um controle de <see cref="T:System.Windows.Forms.RichTextBox" /> de várias linhas.</summary>
        <value>
          <see langword="true" /> Se o controle for um multiline <see cref="T:System.Windows.Forms.RichTextBox" /> controle; caso contrário, <see langword="false" />. O padrão é <see langword="true" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnBackColorChanged">
      <MemberSignature Language="C#" Value="protected override void OnBackColorChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnBackColorChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.RichTextBox.OnBackColorChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnBackColorChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnBackColorChanged(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="override this.OnBackColorChanged : EventArgs -&gt; unit" Usage="richTextBox.OnBackColorChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Um <see cref="T:System.EventArgs" /> que contém os dados do evento.</param>
        <summary>Aciona o evento <see cref="E:System.Windows.Forms.Control.BackColorChanged" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnContentsResized">
      <MemberSignature Language="C#" Value="protected virtual void OnContentsResized (System.Windows.Forms.ContentsResizedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnContentsResized(class System.Windows.Forms.ContentsResizedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.RichTextBox.OnContentsResized(System.Windows.Forms.ContentsResizedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnContentsResized (e As ContentsResizedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnContentsResized(System::Windows::Forms::ContentsResizedEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnContentsResized : System.Windows.Forms.ContentsResizedEventArgs -&gt; unit&#xA;override this.OnContentsResized : System.Windows.Forms.ContentsResizedEventArgs -&gt; unit" Usage="richTextBox.OnContentsResized e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Forms.ContentsResizedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Um <see cref="T:System.Windows.Forms.ContentsResizedEventArgs" /> que contém os dados do evento.</param>
        <summary>Aciona o evento <see cref="E:System.Windows.Forms.RichTextBox.ContentsResized" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A geração de um evento invoca o manipulador de eventos por meio de um delegado. Para obter mais informações, consulte [tratamento e gerando eventos](~/docs/standard/events/index.md).  
  
 O <xref:System.Windows.Forms.RichTextBox.OnContentsResized%2A> método também permite que classes derivadas manipular o evento sem anexar um representante. Isso é a técnica preferida para manipular o evento em uma classe derivada.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Ao substituir <see cref="M:System.Windows.Forms.RichTextBox.OnContentsResized(System.Windows.Forms.ContentsResizedEventArgs)" /> em uma classe derivada, certifique-se de chamar a classe base <see cref="M:System.Windows.Forms.RichTextBox.OnContentsResized(System.Windows.Forms.ContentsResizedEventArgs)" /> método para que registrado delegados receber o evento.</para>
        </block>
        <altmember cref="E:System.Windows.Forms.RichTextBox.ContentsResized" />
      </Docs>
    </Member>
    <Member MemberName="OnContextMenuChanged">
      <MemberSignature Language="C#" Value="protected override void OnContextMenuChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnContextMenuChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.RichTextBox.OnContextMenuChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnContextMenuChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnContextMenuChanged(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="override this.OnContextMenuChanged : EventArgs -&gt; unit" Usage="richTextBox.OnContextMenuChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Um <see cref="T:System.EventArgs" /> que contém os dados do evento.</param>
        <summary>Aciona o evento <see cref="E:System.Windows.Forms.Control.ContextMenuChanged" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnHandleCreated">
      <MemberSignature Language="C#" Value="protected override void OnHandleCreated (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnHandleCreated(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.RichTextBox.OnHandleCreated(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnHandleCreated (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnHandleCreated(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="override this.OnHandleCreated : EventArgs -&gt; unit" Usage="richTextBox.OnHandleCreated e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Um <see cref="T:System.EventArgs" /> que contém os dados do evento.</param>
        <summary>Aciona o evento <see cref="E:System.Windows.Forms.Control.HandleCreated" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnHandleDestroyed">
      <MemberSignature Language="C#" Value="protected override void OnHandleDestroyed (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnHandleDestroyed(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.RichTextBox.OnHandleDestroyed(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnHandleDestroyed (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnHandleDestroyed(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="override this.OnHandleDestroyed : EventArgs -&gt; unit" Usage="richTextBox.OnHandleDestroyed e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Um <see cref="T:System.EventArgs" /> que contém os dados do evento.</param>
        <summary>Aciona o evento <see cref="E:System.Windows.Forms.Control.HandleDestroyed" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnHScroll">
      <MemberSignature Language="C#" Value="protected virtual void OnHScroll (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnHScroll(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.RichTextBox.OnHScroll(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnHScroll (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnHScroll(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnHScroll : EventArgs -&gt; unit&#xA;override this.OnHScroll : EventArgs -&gt; unit" Usage="richTextBox.OnHScroll e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Um <see cref="T:System.EventArgs" /> que contém os dados do evento.</param>
        <summary>Aciona o evento <see cref="E:System.Windows.Forms.RichTextBox.HScroll" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A geração de um evento invoca o manipulador de eventos por meio de um delegado. Para obter mais informações, consulte [tratamento e gerando eventos](~/docs/standard/events/index.md).  
  
 O <xref:System.Windows.Forms.RichTextBox.OnHScroll%2A> método também permite que classes derivadas manipular o evento sem anexar um representante. Isso é a técnica preferida para manipular o evento em uma classe derivada.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Ao substituir <see cref="M:System.Windows.Forms.RichTextBox.OnHScroll(System.EventArgs)" /> em uma classe derivada, certifique-se de chamar a classe base <see cref="M:System.Windows.Forms.RichTextBox.OnHScroll(System.EventArgs)" /> método para que registrado delegados receber o evento.</para>
        </block>
        <altmember cref="E:System.Windows.Forms.RichTextBox.HScroll" />
      </Docs>
    </Member>
    <Member MemberName="OnImeChange">
      <MemberSignature Language="C#" Value="protected virtual void OnImeChange (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnImeChange(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.RichTextBox.OnImeChange(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnImeChange (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnImeChange(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnImeChange : EventArgs -&gt; unit&#xA;override this.OnImeChange : EventArgs -&gt; unit" Usage="richTextBox.OnImeChange e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Um <see cref="T:System.EventArgs" /> que contém os dados do evento.</param>
        <summary>Aciona o evento <see cref="E:System.Windows.Forms.RichTextBox.ImeChange" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A geração de um evento invoca o manipulador de eventos por meio de um delegado. Para obter mais informações, consulte [tratamento e gerando eventos](~/docs/standard/events/index.md).  
  
 O <xref:System.Windows.Forms.RichTextBox.OnImeChange%2A> método também permite que classes derivadas manipular o evento sem anexar um representante. Isso é a técnica preferida para manipular o evento em uma classe derivada.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Ao substituir <see cref="M:System.Windows.Forms.RichTextBox.OnImeChange(System.EventArgs)" /> em uma classe derivada, certifique-se de chamar a classe base <see cref="M:System.Windows.Forms.RichTextBox.OnImeChange(System.EventArgs)" /> método para que registrado delegados receber o evento.</para>
        </block>
        <altmember cref="E:System.Windows.Forms.RichTextBox.ImeChange" />
      </Docs>
    </Member>
    <Member MemberName="OnLinkClicked">
      <MemberSignature Language="C#" Value="protected virtual void OnLinkClicked (System.Windows.Forms.LinkClickedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnLinkClicked(class System.Windows.Forms.LinkClickedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.RichTextBox.OnLinkClicked(System.Windows.Forms.LinkClickedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnLinkClicked (e As LinkClickedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnLinkClicked(System::Windows::Forms::LinkClickedEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnLinkClicked : System.Windows.Forms.LinkClickedEventArgs -&gt; unit&#xA;override this.OnLinkClicked : System.Windows.Forms.LinkClickedEventArgs -&gt; unit" Usage="richTextBox.OnLinkClicked e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Forms.LinkClickedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Um <see cref="T:System.Windows.Forms.LinkClickedEventArgs" /> que contém os dados do evento.</param>
        <summary>Aciona o evento <see cref="E:System.Windows.Forms.RichTextBox.LinkClicked" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A geração de um evento invoca o manipulador de eventos por meio de um delegado. Para obter mais informações, consulte [tratamento e gerando eventos](~/docs/standard/events/index.md).  
  
 O <xref:System.Windows.Forms.RichTextBox.OnLinkClicked%2A> método também permite que classes derivadas manipular o evento sem anexar um representante. Isso é a técnica preferida para manipular o evento em uma classe derivada.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Ao substituir <see cref="M:System.Windows.Forms.RichTextBox.OnLinkClicked(System.Windows.Forms.LinkClickedEventArgs)" /> em uma classe derivada, certifique-se de chamar a classe base <see cref="M:System.Windows.Forms.RichTextBox.OnLinkClicked(System.Windows.Forms.LinkClickedEventArgs)" /> método para que registrado delegados receber o evento.</para>
        </block>
        <altmember cref="E:System.Windows.Forms.RichTextBox.LinkClicked" />
      </Docs>
    </Member>
    <Member MemberName="OnProtected">
      <MemberSignature Language="C#" Value="protected virtual void OnProtected (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnProtected(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.RichTextBox.OnProtected(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnProtected (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnProtected(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnProtected : EventArgs -&gt; unit&#xA;override this.OnProtected : EventArgs -&gt; unit" Usage="richTextBox.OnProtected e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Um <see cref="T:System.EventArgs" /> que contém os dados do evento.</param>
        <summary>Aciona o evento <see cref="E:System.Windows.Forms.RichTextBox.Protected" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A geração de um evento invoca o manipulador de eventos por meio de um delegado. Para obter mais informações, consulte [tratamento e gerando eventos](~/docs/standard/events/index.md).  
  
 O <xref:System.Windows.Forms.RichTextBox.OnProtected%2A> método também permite que classes derivadas manipular o evento sem anexar um representante. Isso é a técnica preferida para manipular o evento em uma classe derivada.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Ao substituir <see cref="M:System.Windows.Forms.RichTextBox.OnProtected(System.EventArgs)" /> em uma classe derivada, certifique-se de chamar a classe base <see cref="M:System.Windows.Forms.RichTextBox.OnProtected(System.EventArgs)" /> método para que registrado delegados receber o evento.</para>
        </block>
        <altmember cref="E:System.Windows.Forms.RichTextBox.Protected" />
      </Docs>
    </Member>
    <Member MemberName="OnRightToLeftChanged">
      <MemberSignature Language="C#" Value="protected override void OnRightToLeftChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnRightToLeftChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.RichTextBox.OnRightToLeftChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnRightToLeftChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnRightToLeftChanged(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="override this.OnRightToLeftChanged : EventArgs -&gt; unit" Usage="richTextBox.OnRightToLeftChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Um <see cref="T:System.EventArgs" /> que contém os dados do evento.</param>
        <summary>Aciona o evento <see cref="E:System.Windows.Forms.Control.RightToLeftChanged" />.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnRightToLeftChanged(System.EventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnSelectionChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnSelectionChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnSelectionChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.RichTextBox.OnSelectionChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnSelectionChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnSelectionChanged(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnSelectionChanged : EventArgs -&gt; unit&#xA;override this.OnSelectionChanged : EventArgs -&gt; unit" Usage="richTextBox.OnSelectionChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Um <see cref="T:System.EventArgs" /> que contém os dados do evento.</param>
        <summary>Aciona o evento <see cref="E:System.Windows.Forms.RichTextBox.SelectionChanged" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A geração de um evento invoca o manipulador de eventos por meio de um delegado. Para obter mais informações, consulte [tratamento e gerando eventos](~/docs/standard/events/index.md).  
  
 O <xref:System.Windows.Forms.RichTextBox.OnSelectionChanged%2A> método também permite que classes derivadas manipular o evento sem anexar um representante. Isso é a técnica preferida para manipular o evento em uma classe derivada.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Ao substituir <see cref="M:System.Windows.Forms.RichTextBox.OnSelectionChanged(System.EventArgs)" /> em uma classe derivada, certifique-se de chamar a classe base <see cref="M:System.Windows.Forms.RichTextBox.OnSelectionChanged(System.EventArgs)" /> método para que registrado delegados receber o evento.</para>
        </block>
        <altmember cref="E:System.Windows.Forms.RichTextBox.SelectionChanged" />
      </Docs>
    </Member>
    <Member MemberName="OnVScroll">
      <MemberSignature Language="C#" Value="protected virtual void OnVScroll (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnVScroll(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.RichTextBox.OnVScroll(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnVScroll (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnVScroll(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnVScroll : EventArgs -&gt; unit&#xA;override this.OnVScroll : EventArgs -&gt; unit" Usage="richTextBox.OnVScroll e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Um <see cref="T:System.EventArgs" /> que contém os dados do evento.</param>
        <summary>Aciona o evento <see cref="E:System.Windows.Forms.RichTextBox.VScroll" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A geração de um evento invoca o manipulador de eventos por meio de um delegado. Para obter mais informações, consulte [tratamento e gerando eventos](~/docs/standard/events/index.md).  
  
 O <xref:System.Windows.Forms.RichTextBox.OnVScroll%2A> método também permite que classes derivadas manipular o evento sem anexar um representante. Isso é a técnica preferida para manipular o evento em uma classe derivada.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Ao substituir <see cref="M:System.Windows.Forms.RichTextBox.OnVScroll(System.EventArgs)" /> em uma classe derivada, certifique-se de chamar a classe base <see cref="M:System.Windows.Forms.RichTextBox.OnVScroll(System.EventArgs)" /> método para que registrado delegados receber o evento.</para>
        </block>
        <altmember cref="E:System.Windows.Forms.RichTextBox.VScroll" />
      </Docs>
    </Member>
    <Member MemberName="Paste">
      <MemberSignature Language="C#" Value="public void Paste (System.Windows.Forms.DataFormats.Format clipFormat);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Paste(class System.Windows.Forms.DataFormats/Format clipFormat) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.RichTextBox.Paste(System.Windows.Forms.DataFormats.Format)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Paste (clipFormat As DataFormats.Format)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Paste(System::Windows::Forms::DataFormats::Format ^ clipFormat);" />
      <MemberSignature Language="F#" Value="override this.Paste : System.Windows.Forms.DataFormats.Format -&gt; unit" Usage="richTextBox.Paste clipFormat" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="clipFormat" Type="System.Windows.Forms.DataFormats+Format" />
      </Parameters>
      <Docs>
        <param name="clipFormat">O formato da Área de Transferência no qual os dados devem ser obtidos da Área de Transferência.</param>
        <summary>Cola o conteúdo da Área de Transferência no formato de Área de Transferência especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Você pode usar esse método para colar os dados da área de transferência no controle. Esta versão do <xref:System.Windows.Forms.RichTextBox.Paste%2A> método é diferente de <xref:System.Windows.Forms.TextBoxBase.Paste%2A?displayProperty=nameWithType> método que permite que você colar somente texto em um formato de área de transferência especificado. Você pode usar o <xref:System.Windows.Forms.RichTextBox.CanPaste%2A> método para determinar se os dados na área de transferência estão no formato de área de transferência especificado. Em seguida, você pode chamar esta versão do <xref:System.Windows.Forms.RichTextBox.Paste%2A> método para garantir que a operação de colagem é feita com o formato de dados apropriado.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como usar o <xref:System.Windows.Forms.RichTextBox.Paste%2A> método para colar um bitmap para o <xref:System.Windows.Forms.RichTextBox> controle. Depois de abrir um bitmap de arquivo, o exemplo usa o <xref:System.Windows.Forms.Clipboard.SetDataObject%2A> método para copiar o bitmap para a área de transferência do Windows. Por fim, o exemplo recupera o formato para o <xref:System.Drawing.Bitmap> de objeto, verifica se o formato pode ser colado no <xref:System.Windows.Forms.RichTextBox> controle e usa o <xref:System.Windows.Forms.RichTextBox.Paste%2A> método para colar os dados.  
  
 [!code-cpp[RichText_Paste#1](~/samples/snippets/cpp/VS_Snippets_Winforms/RichText_Paste/CPP/form1.cpp#1)]
 [!code-csharp[RichText_Paste#1](~/samples/snippets/csharp/VS_Snippets_Winforms/RichText_Paste/CS/form1.cs#1)]
 [!code-vb[RichText_Paste#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/RichText_Paste/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">para a leitura da área de transferência. Enumeração associada: o <see langword="AllClipboard" /> valor <see cref="T:System.Security.Permissions.UIPermissionClipboard" />.</permission>
        <altmember cref="M:System.Windows.Forms.RichTextBox.CanPaste(System.Windows.Forms.DataFormats.Format)" />
        <altmember cref="M:System.Windows.Forms.TextBoxBase.Paste" />
        <altmember cref="T:System.Windows.Forms.DataFormats.Format" />
      </Docs>
    </Member>
    <Member MemberName="ProcessCmdKey">
      <MemberSignature Language="C#" Value="protected override bool ProcessCmdKey (ref System.Windows.Forms.Message m, System.Windows.Forms.Keys keyData);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance bool ProcessCmdKey(valuetype System.Windows.Forms.Message&amp; m, valuetype System.Windows.Forms.Keys keyData) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.RichTextBox.ProcessCmdKey(System.Windows.Forms.Message@,System.Windows.Forms.Keys)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function ProcessCmdKey (ByRef m As Message, keyData As Keys) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override bool ProcessCmdKey(System::Windows::Forms::Message % m, System::Windows::Forms::Keys keyData);" />
      <MemberSignature Language="F#" Value="override this.ProcessCmdKey :  * System.Windows.Forms.Keys -&gt; bool" Usage="richTextBox.ProcessCmdKey (m, keyData)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="m" Type="System.Windows.Forms.Message&amp;" RefType="ref" />
        <Parameter Name="keyData" Type="System.Windows.Forms.Keys" />
      </Parameters>
      <Docs>
        <param name="m">Um <see cref="T:System.Windows.Forms.Message" />, passado por referência, que representa a mensagem de janela a ser processada.</param>
        <param name="keyData">Um dos valores <see cref="T:System.Windows.Forms.Keys" /> que representa a chave a ser processada.</param>
        <summary>Processa uma chave de comando.</summary>
        <returns>
          <see langword="true" /> se o caractere foi processado pelo controle; caso contrário, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Windows.Forms.TextBoxBase.ProcessCmdKey(System.Windows.Forms.Message@,System.Windows.Forms.Keys)" />
      </Docs>
    </Member>
    <Member MemberName="Protected">
      <MemberSignature Language="C#" Value="public event EventHandler Protected;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Protected" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.RichTextBox.Protected" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Protected As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ Protected;" />
      <MemberSignature Language="F#" Value="member this.Protected : EventHandler " Usage="member this.Protected : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ocorre quando o usuário tenta modificar texto protegido no controle.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Você pode criar um manipulador de eventos para esse evento em seus aplicativos para determinar quando o usuário tentou modificar o texto que foi marcado como protegido no controle. O manipulador de eventos pode ser usado para notificar o usuário que o texto que o usuário está tentando modificar está protegido ou para exibir uma caixa de diálogo que permite ao usuário fazer as alterações apropriadas no texto. Por exemplo, se a área protegida for uma data, você pode exibir uma caixa de diálogo que permite que o usuário escolha uma data que pode então ser aplicada ao texto do controle.  
  
 Para obter mais informações sobre a manipulação de eventos, consulte [NIB: consumindo eventos](http://msdn.microsoft.com/library/01e4f1bc-e55e-413f-98c7-6588493e5f67).  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra o uso desse membro. No exemplo, um manipulador de eventos relatórios sobre a ocorrência da <xref:System.Windows.Forms.RichTextBox.Protected> eventos. Este relatório ajuda você a saber quando o evento ocorre e pode ajudá-lo na depuração. Para gerar relatórios sobre vários eventos ou eventos que ocorrem com frequência, considere substituir <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> com <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> ou anexar a mensagem como um multiline <xref:System.Windows.Forms.TextBox>.  
  
 Para executar o código de exemplo, cole-o em um projeto que contém uma instância do tipo <xref:System.Windows.Forms.RichTextBox> chamado `RichTextBox1`. Certifique-se de que o manipulador de eventos está associado com o <xref:System.Windows.Forms.RichTextBox.Protected> evento.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#543](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#543)]
 [!code-vb[System.Windows.Forms.EventExamples#543](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#543)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="QueryContinueDrag">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.QueryContinueDragEventHandler QueryContinueDrag;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.QueryContinueDragEventHandler QueryContinueDrag" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.RichTextBox.QueryContinueDrag" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event QueryContinueDrag As QueryContinueDragEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::QueryContinueDragEventHandler ^ QueryContinueDrag;" />
      <MemberSignature Language="F#" Value="member this.QueryContinueDrag : System.Windows.Forms.QueryContinueDragEventHandler " Usage="member this.QueryContinueDrag : System.Windows.Forms.QueryContinueDragEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.QueryContinueDragEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Esse evento não é relevante para essa classe.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse evento não é relevante para essa classe.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Redo">
      <MemberSignature Language="C#" Value="public void Redo ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Redo() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.RichTextBox.Redo" />
      <MemberSignature Language="VB.NET" Value="Public Sub Redo ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Redo();" />
      <MemberSignature Language="F#" Value="member this.Redo : unit -&gt; unit" Usage="richTextBox.Redo " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Reaplica a última operação desfeita no controle.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Você pode usar o <xref:System.Windows.Forms.RichTextBox.Redo%2A> método para reaplicar a última operação de desfazer para o controle. O <xref:System.Windows.Forms.RichTextBox.CanRedo%2A> método permite que você determine se a última operação desfez o usuário pode ser reaplicada ao controle.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como usar o <xref:System.Windows.Forms.RichTextBox.CanRedo%2A> e <xref:System.Windows.Forms.RichTextBox.RedoActionName%2A> propriedades e o <xref:System.Windows.Forms.RichTextBox.Redo%2A> método para restringir uma operação de restauração para qualquer ação exceto a exclusão de texto. Este exemplo requer que você tenha um formulário que contém um <xref:System.Windows.Forms.RichTextBox> controle e que uma operação no <xref:System.Windows.Forms.RichTextBox> foi executada e desfeita antes do código neste exemplo é chamado.  
  
 [!code-cpp[RichTextBox.RedoAction#1](~/samples/snippets/cpp/VS_Snippets_Winforms/RichTextBox.RedoAction/CPP/form1.cpp#1)]
 [!code-csharp[RichTextBox.RedoAction#1](~/samples/snippets/csharp/VS_Snippets_Winforms/RichTextBox.RedoAction/CS/form1.cs#1)]
 [!code-vb[RichTextBox.RedoAction#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/RichTextBox.RedoAction/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.RichTextBox.CanRedo" />
      </Docs>
    </Member>
    <Member MemberName="RedoActionName">
      <MemberSignature Language="C#" Value="public string RedoActionName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string RedoActionName" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.RichTextBox.RedoActionName" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property RedoActionName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ RedoActionName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.RedoActionName : string" Usage="System.Windows.Forms.RichTextBox.RedoActionName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém o nome da ação que pode ser reaplicada ao controle quando o método <see cref="M:System.Windows.Forms.RichTextBox.Redo" /> é chamado.</summary>
        <value>Uma cadeia de caracteres que representa o nome da ação que será executada quando uma chamada para o <see cref="M:System.Windows.Forms.RichTextBox.Redo" /> método é feito.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se essa propriedade retorna uma cadeia de caracteres vazia (""), não há nenhuma operação disponível para reaplicar o controle. Você pode usar esse método para determinar a última ação desfeita no <xref:System.Windows.Forms.RichTextBox> controle que pode então ser reaplicada ao controle quando uma chamada para o <xref:System.Windows.Forms.RichTextBox.Redo%2A> método é feito. Você pode determinar se há quaisquer operações para o controle usando o <xref:System.Windows.Forms.RichTextBox.CanRedo%2A> propriedade.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como usar o <xref:System.Windows.Forms.RichTextBox.CanRedo%2A> e <xref:System.Windows.Forms.RichTextBox.RedoActionName%2A> propriedades e o <xref:System.Windows.Forms.RichTextBox.Redo%2A> método para restringir uma operação de restauração para qualquer ação exceto a exclusão de texto. Este exemplo requer que você tenha um formulário que contém um <xref:System.Windows.Forms.RichTextBox> controle e que uma operação no <xref:System.Windows.Forms.RichTextBox> foi executada e desfeita antes do código neste exemplo é chamado.  
  
 [!code-cpp[RichTextBox.RedoAction#1](~/samples/snippets/cpp/VS_Snippets_Winforms/RichTextBox.RedoAction/CPP/form1.cpp#1)]
 [!code-csharp[RichTextBox.RedoAction#1](~/samples/snippets/csharp/VS_Snippets_Winforms/RichTextBox.RedoAction/CS/form1.cs#1)]
 [!code-vb[RichTextBox.RedoAction#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/RichTextBox.RedoAction/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.RichTextBox.CanRedo" />
        <altmember cref="M:System.Windows.Forms.RichTextBox.Redo" />
      </Docs>
    </Member>
    <Member MemberName="RichTextShortcutsEnabled">
      <MemberSignature Language="C#" Value="public bool RichTextShortcutsEnabled { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool RichTextShortcutsEnabled" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.RichTextBox.RichTextShortcutsEnabled" />
      <MemberSignature Language="VB.NET" Value="Public Property RichTextShortcutsEnabled As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool RichTextShortcutsEnabled { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.RichTextShortcutsEnabled : bool with get, set" Usage="System.Windows.Forms.RichTextBox.RichTextShortcutsEnabled" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Essa propriedade não é relevante para essa classe.</summary>
        <value>
          <see langword="true" /> Se as teclas de atalho estão habilitadas; Caso contrário, <see langword="false" />. O padrão é <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Essa propriedade não é relevante para essa classe.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RightMargin">
      <MemberSignature Language="C#" Value="public int RightMargin { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 RightMargin" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.RichTextBox.RightMargin" />
      <MemberSignature Language="VB.NET" Value="Public Property RightMargin As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int RightMargin { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.RightMargin : int with get, set" Usage="System.Windows.Forms.RichTextBox.RightMargin" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(0)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define o tamanho de uma única linha de texto dentro do controle <see cref="T:System.Windows.Forms.RichTextBox" />.</summary>
        <value>O tamanho, em pixels, de uma única linha de texto no controle. O padrão é zero.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando um valor maior que zero é inserido no controle, uma margem invisível é colocada no controle o número especificado de pixels do lado esquerdo do controle. Qualquer texto inserido que ultrapassa a essa margem é colocado na próxima linha do texto no controle. Essa propriedade afeta todo o texto inserido atualmente no controle, bem como qualquer texto adicional inseridos no controle depois que a propriedade é definida. Você pode usar essa propriedade para especificar uma largura de linha máximo de todo o texto inserido em um <xref:System.Windows.Forms.RichTextBox> controle.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como criar um <xref:System.Windows.Forms.RichTextBox> que amplia texto, seleciona automaticamente palavras no texto do controle quando uma palavra é clicado duas vezes e tem uma margem no lado direito da área cliente do controle. Se o <xref:System.Windows.Forms.RichTextBox> controle tem uma largura pequena, usar esse código cria um <xref:System.Windows.Forms.RichTextBox> onde cada caractere de texto é exibido em sua própria linha. Enquanto nesta posição de exibição vertical, clicando em qualquer parte de uma palavra para selecionar todos os caracteres da palavra, independentemente do fato de que o texto é exibido na vertical. Este exemplo requer que você tenha um formulário que contém um <xref:System.Windows.Forms.RichTextBox> controle chamado `richTextBox1`.  
  
 [!code-cpp[RichTextBox.ZoomFactor#1](~/samples/snippets/cpp/VS_Snippets_Winforms/RichTextBox.ZoomFactor/CPP/form1.cpp#1)]
 [!code-csharp[RichTextBox.ZoomFactor#1](~/samples/snippets/csharp/VS_Snippets_Winforms/RichTextBox.ZoomFactor/CS/form1.cs#1)]
 [!code-vb[RichTextBox.ZoomFactor#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/RichTextBox.ZoomFactor/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">O valor especificado era menor que zero.</exception>
      </Docs>
    </Member>
    <Member MemberName="Rtf">
      <MemberSignature Language="C#" Value="public string Rtf { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Rtf" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.RichTextBox.Rtf" />
      <MemberSignature Language="VB.NET" Value="Public Property Rtf As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Rtf { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Rtf : string with get, set" Usage="System.Windows.Forms.RichTextBox.Rtf" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.RefreshProperties</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define o texto do controle <see cref="T:System.Windows.Forms.RichTextBox" />, incluindo todos os códigos de formato Rich Text.</summary>
        <value>O texto do controle em formato Rich Text.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Você pode usar essa propriedade como Insira o texto RTF formatado no controle para exibir ou extrair o texto do controle com a formatação de RTF especificado, definido no texto do controle. Essa propriedade normalmente é usada quando você estiver atribuindo texto RTF de outra origem RTF, como Microsoft Word ou WordPad do Windows, o controle.  
  
 Se você alterar o <xref:System.Windows.Forms.Control.RightToLeft%2A> propriedade em tempo de execução, somente bruto texto sem formatação é preservada.  
  
 Para os códigos RTF, consulte "especificação (RTF), versão 1.6 do formato de rich text" na biblioteca MSDN em http://msdn.microsoft.com/library.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.TextBoxBase.Text" />
      </Docs>
    </Member>
    <MemberGroup MemberName="SaveFile">
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Salva o conteúdo do <see cref="T:System.Windows.Forms.RichTextBox" /> em um arquivo.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SaveFile">
      <MemberSignature Language="C#" Value="public void SaveFile (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SaveFile(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.RichTextBox.SaveFile(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SaveFile (path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SaveFile(System::String ^ path);" />
      <MemberSignature Language="F#" Value="member this.SaveFile : string -&gt; unit" Usage="richTextBox.SaveFile path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">O nome e o local do arquivo a ser salvo.</param>
        <summary>Salva o conteúdo do <see cref="T:System.Windows.Forms.RichTextBox" /> em um arquivo RTF (Formato Rich Text).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Windows.Forms.RichTextBox.SaveFile%2A> método permite que você salve todo o conteúdo do controle em um arquivo RTF que pode ser usado por outros programas, como Microsoft Word e o WordPad do Windows. Se o nome do arquivo que é passado para o `path` parâmetro já existe no diretório especificado, o arquivo será substituído sem aviso prévio. Você pode usar o <xref:System.Windows.Forms.RichTextBox.LoadFile%2A> método para carregar o conteúdo de um arquivo para o <xref:System.Windows.Forms.RichTextBox>.  
  
> [!NOTE]
>  Para salvar o conteúdo do controle para um tipo diferente de formato de arquivo como texto ASCII, use as outras versões desse método que aceite um valor da <xref:System.Windows.Forms.RichTextBoxStreamType> enumeração como um parâmetro.  
  
   
  
## Examples  
 O exemplo de código a seguir salva o conteúdo de um <xref:System.Windows.Forms.RichTextBox> controle em um arquivo RTF. O exemplo usa o <xref:System.Windows.Forms.SaveFileDialog> classe para exibir uma caixa de diálogo de solicitação do usuário, o caminho e nome do arquivo para salvar. O código, em seguida, salva o arquivo supondo que o conteúdo está no formato rich text. Se o arquivo já existir, ele será substituído automaticamente. Este exemplo requer que o código é colocado em uma <xref:System.Windows.Forms.Form> classe que tem um <xref:System.Windows.Forms.RichTextBox> controle chamado `richTextBox1`.  
  
 [!code-cpp[Classic RichTextBox.SaveFile Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic RichTextBox.SaveFile Example/CPP/source.cpp#1)]
 [!code-csharp[Classic RichTextBox.SaveFile Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic RichTextBox.SaveFile Example/CS/source.cs#1)]
 [!code-vb[Classic RichTextBox.SaveFile Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic RichTextBox.SaveFile Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Ocorre um erro ao salvar o conteúdo do controle em um arquivo.</exception>
        <altmember cref="M:System.Windows.Forms.RichTextBox.LoadFile(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="SaveFile">
      <MemberSignature Language="C#" Value="public void SaveFile (System.IO.Stream data, System.Windows.Forms.RichTextBoxStreamType fileType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SaveFile(class System.IO.Stream data, valuetype System.Windows.Forms.RichTextBoxStreamType fileType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.RichTextBox.SaveFile(System.IO.Stream,System.Windows.Forms.RichTextBoxStreamType)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SaveFile (data As Stream, fileType As RichTextBoxStreamType)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SaveFile(System::IO::Stream ^ data, System::Windows::Forms::RichTextBoxStreamType fileType);" />
      <MemberSignature Language="F#" Value="member this.SaveFile : System.IO.Stream * System.Windows.Forms.RichTextBoxStreamType -&gt; unit" Usage="richTextBox.SaveFile (data, fileType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.IO.Stream" />
        <Parameter Name="fileType" Type="System.Windows.Forms.RichTextBoxStreamType" />
      </Parameters>
      <Docs>
        <param name="data">O fluxo de dados que contém o arquivo que será salvo.</param>
        <param name="fileType">Um dos valores de <see cref="T:System.Windows.Forms.RichTextBoxStreamType" />.</param>
        <summary>Salva o conteúdo de um controle <see cref="T:System.Windows.Forms.RichTextBox" /> em um fluxo de dados aberto.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esta versão do <xref:System.Windows.Forms.RichTextBox.SaveFile%2A> método permite que você salve todo o conteúdo do controle para o fluxo de dados que já está aberto. O fluxo de dados, em seguida, pode salvar as informações em um arquivo. Você pode usar o <xref:System.Windows.Forms.RichTextBox.LoadFile%2A> método para carregar o conteúdo de um arquivo para o <xref:System.Windows.Forms.RichTextBox>.  
  
 Esta versão do <xref:System.Windows.Forms.RichTextBox.SaveFile%2A> método também permite que você especifique um formato de dados das informações que serão enviadas para o <xref:System.IO.Stream> objeto.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como usar o <xref:System.Windows.Forms.RichTextBox.SaveFile%2A> e <xref:System.Windows.Forms.RichTextBox.LoadFile%2A> métodos com fluxos. Ele também demonstra como usar o <xref:System.Windows.Forms.FileDialog.FileName%2A?displayProperty=nameWithType>, <xref:System.Windows.Forms.FileDialog.DefaultExt%2A?displayProperty=nameWithType>, <xref:System.Windows.Forms.SaveFileDialog.CreatePrompt%2A?displayProperty=nameWithType>, e <xref:System.Windows.Forms.SaveFileDialog.OverwritePrompt%2A?displayProperty=nameWithType> membros.  
  
 Este é um exemplo completo que está pronto para ser executado quando você copiá-lo ao seu projeto.  
  
 [!code-cpp[System.Windows.Forms.RichTextBoxSaveFile#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.RichTextBoxSaveFile/CPP/form1.cpp#1)]
 [!code-csharp[System.Windows.Forms.RichTextBoxSaveFile#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.RichTextBoxSaveFile/CS/form1.cs#1)]
 [!code-vb[System.Windows.Forms.RichTextBoxSaveFile#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.RichTextBoxSaveFile/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Um tipo de arquivo inválido foi especificado no parâmetro <paramref name="fileType" />.</exception>
        <exception cref="T:System.IO.IOException">Ocorre um erro ao salvar o conteúdo do controle em um arquivo.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">para criar ou modificar um arquivo. Enumeração associada: O <see langword="Write" /> valor <see cref="T:System.Security.Permissions.FileIOPermissionAccess" />.</permission>
        <altmember cref="T:System.IO.Stream" />
        <altmember cref="M:System.Windows.Forms.RichTextBox.LoadFile(System.String)" />
        <altmember cref="T:System.Windows.Forms.RichTextBoxStreamType" />
      </Docs>
    </Member>
    <Member MemberName="SaveFile">
      <MemberSignature Language="C#" Value="public void SaveFile (string path, System.Windows.Forms.RichTextBoxStreamType fileType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SaveFile(string path, valuetype System.Windows.Forms.RichTextBoxStreamType fileType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.RichTextBox.SaveFile(System.String,System.Windows.Forms.RichTextBoxStreamType)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SaveFile (path As String, fileType As RichTextBoxStreamType)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SaveFile(System::String ^ path, System::Windows::Forms::RichTextBoxStreamType fileType);" />
      <MemberSignature Language="F#" Value="member this.SaveFile : string * System.Windows.Forms.RichTextBoxStreamType -&gt; unit" Usage="richTextBox.SaveFile (path, fileType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="fileType" Type="System.Windows.Forms.RichTextBoxStreamType" />
      </Parameters>
      <Docs>
        <param name="path">O nome e o local do arquivo a ser salvo.</param>
        <param name="fileType">Um dos valores de <see cref="T:System.Windows.Forms.RichTextBoxStreamType" />.</param>
        <summary>Salva o conteúdo de <see cref="T:System.Windows.Forms.RichTextBox" /> para um tipo específico de arquivo.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Windows.Forms.RichTextBox.SaveFile%2A> método permite que você salve todo o conteúdo do controle em um arquivo RTF que pode ser usado por outros programas, como Microsoft Word e o WordPad do Windows. Se o nome do arquivo que é passado para o `path` parâmetro já existe no diretório especificado, o arquivo será substituído sem aviso prévio. Você pode usar o <xref:System.Windows.Forms.RichTextBox.LoadFile%2A> método para carregar o conteúdo de um arquivo para o <xref:System.Windows.Forms.RichTextBox>.  
  
 Esta versão do <xref:System.Windows.Forms.RichTextBox.SaveFile%2A> método permite que você especifique um tipo de arquivo para salvar o conteúdo do controle. Você pode usar esse recurso para garantir que o arquivo é salvo no formato apropriado com base no conteúdo do controle. Por exemplo, se o documento não tem nenhuma diferença no estilo de fonte ou cores, você pode salvar o arquivo como um arquivo de texto ASCII, definindo o `fileType` parâmetro `RichTextBoxStreamType.PlainText`.  
  
   
  
## Examples  
 O exemplo de código a seguir salva o conteúdo do <xref:System.Windows.Forms.RichTextBox> em um arquivo de texto ASCII. O exemplo usa o <xref:System.Windows.Forms.SaveFileDialog> classe para exibir uma caixa de diálogo para solicitar o caminho e o nome do usuário. O código, em seguida, salva o conteúdo do controle no arquivo. O exemplo usa esta versão do <xref:System.Windows.Forms.RichTextBox.SaveFile%2A> método para especificar que o arquivo seja salvo como um arquivo de texto ASCII em vez do formato RTF padrão. Este exemplo requer que o código é colocado em uma <xref:System.Windows.Forms.Form> classe que tem um <xref:System.Windows.Forms.RichTextBox> controle chamado `richTextBox1`.  
  
 [!code-cpp[Classic RichTextBox.SaveFile1 Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic RichTextBox.SaveFile1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic RichTextBox.SaveFile1 Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic RichTextBox.SaveFile1 Example/CS/source.cs#1)]
 [!code-vb[Classic RichTextBox.SaveFile1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic RichTextBox.SaveFile1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Um tipo de arquivo inválido foi especificado no parâmetro <paramref name="fileType" />.</exception>
        <exception cref="T:System.IO.IOException">Ocorre um erro ao salvar o conteúdo do controle em um arquivo.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">para criar ou modificar um arquivo. Enumeração associada: O <see langword="Write" /> valor <see cref="T:System.Security.Permissions.FileIOPermissionAccess" />.</permission>
        <altmember cref="M:System.Windows.Forms.RichTextBox.LoadFile(System.String)" />
        <altmember cref="T:System.Windows.Forms.RichTextBoxStreamType" />
      </Docs>
    </Member>
    <Member MemberName="ScrollBars">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.RichTextBoxScrollBars ScrollBars { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Forms.RichTextBoxScrollBars ScrollBars" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.RichTextBox.ScrollBars" />
      <MemberSignature Language="VB.NET" Value="Public Property ScrollBars As RichTextBoxScrollBars" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Forms::RichTextBoxScrollBars ScrollBars { System::Windows::Forms::RichTextBoxScrollBars get(); void set(System::Windows::Forms::RichTextBoxScrollBars value); };" />
      <MemberSignature Language="F#" Value="member this.ScrollBars : System.Windows.Forms.RichTextBoxScrollBars with get, set" Usage="System.Windows.Forms.RichTextBox.ScrollBars" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.RichTextBoxScrollBars</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define o tipo de barras de rolagem a ser exibido no controle de <see cref="T:System.Windows.Forms.RichTextBox" />.</summary>
        <value>Um dos valores de <see cref="T:System.Windows.Forms.RichTextBoxScrollBars" />. O padrão é <see langword="RichTextBoxScrollBars.Both" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Essa propriedade permite que você forneça as barras de rolagem horizontal e vertical para o usuário da <xref:System.Windows.Forms.RichTextBox> controle para habilitar rolagem texto dentro do controle que está fora de dimensões físicas do controle. Você também pode usar essa propriedade para remover barras de rolagem do controle para restringir o conteúdo do controle de rolagem.  
  
> [!NOTE]
>  Barras de rolagem horizontal não serão exibidas se o <xref:System.Windows.Forms.TextBoxBase.WordWrap%2A> é `true`, independentemente do valor da <xref:System.Windows.Forms.RichTextBox.ScrollBars%2A> propriedade.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">O valor especificado não está definido na enumeração <see cref="T:System.Windows.Forms.RichTextBoxScrollBars" />.</exception>
        <altmember cref="T:System.Windows.Forms.RichTextBoxScrollBars" />
      </Docs>
    </Member>
    <Member MemberName="SelectedRtf">
      <MemberSignature Language="C#" Value="public string SelectedRtf { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string SelectedRtf" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.RichTextBox.SelectedRtf" />
      <MemberSignature Language="VB.NET" Value="Public Property SelectedRtf As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ SelectedRtf { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.SelectedRtf : string with get, set" Usage="System.Windows.Forms.RichTextBox.SelectedRtf" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue("")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define o texto de formato RTF (Formato Rich Text) atualmente selecionado no controle.</summary>
        <value>O texto RTF selecionado no controle.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Essa propriedade permite que você obtenha o texto selecionado no controle, incluindo o RTF códigos de formatação. Você pode usar essa propriedade para copiar o texto de seu controle, completa com formatação e colar o texto em outros aplicativos que aceitam RTF formatado de texto, como Microsoft Word e o WordPad do Windows. Para obter o texto selecionado, sem RTF códigos de formatação, use o <xref:System.Windows.Forms.TextBoxBase.SelectedText%2A> propriedade.  
  
 Se nenhum texto atualmente selecionado, o texto especificado por esta propriedade é inserido no ponto de inserção. Se o texto for selecionado, qualquer texto atribuído a essa propriedade substitui o texto selecionado.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.RichTextBox.Rtf" />
        <altmember cref="P:System.Windows.Forms.TextBoxBase.SelectedText" />
        <altmember cref="P:System.Windows.Forms.TextBoxBase.Text" />
      </Docs>
    </Member>
    <Member MemberName="SelectedText">
      <MemberSignature Language="C#" Value="public override string SelectedText { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string SelectedText" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.RichTextBox.SelectedText" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property SelectedText As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ SelectedText { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.SelectedText : string with get, set" Usage="System.Windows.Forms.RichTextBox.SelectedText" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue("")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define o texto selecionado no <see cref="T:System.Windows.Forms.RichTextBox" />.</summary>
        <value>Uma cadeia de caracteres que representa o texto selecionado no controle.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O exemplo de código a seguir demonstra como usar o <xref:System.Windows.Forms.RichTextBox.SelectionBullet%2A> propriedade com o <xref:System.Windows.Forms.RichTextBox.SelectionFont%2A>, <xref:System.Windows.Forms.RichTextBox.SelectedText%2A>, e <xref:System.Windows.Forms.RichTextBox.SelectionColor%2A> propriedades para criar uma lista com marcadores em um <xref:System.Windows.Forms.RichTextBox> controle. Este exemplo requer que um <xref:System.Windows.Forms.RichTextBox> controle chamado `richTextBox1` é criado em um formulário.  
  
 [!code-cpp[RichTextBox.SelectionBullet#1](~/samples/snippets/cpp/VS_Snippets_Winforms/RichTextBox.SelectionBullet/CPP/form1.cpp#1)]
 [!code-csharp[RichTextBox.SelectionBullet#1](~/samples/snippets/csharp/VS_Snippets_Winforms/RichTextBox.SelectionBullet/CS/form1.cs#1)]
 [!code-vb[RichTextBox.SelectionBullet#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/RichTextBox.SelectionBullet/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SelectionAlignment">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.HorizontalAlignment SelectionAlignment { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Forms.HorizontalAlignment SelectionAlignment" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.RichTextBox.SelectionAlignment" />
      <MemberSignature Language="VB.NET" Value="Public Property SelectionAlignment As HorizontalAlignment" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Forms::HorizontalAlignment SelectionAlignment { System::Windows::Forms::HorizontalAlignment get(); void set(System::Windows::Forms::HorizontalAlignment value); };" />
      <MemberSignature Language="F#" Value="member this.SelectionAlignment : System.Windows.Forms.HorizontalAlignment with get, set" Usage="System.Windows.Forms.RichTextBox.SelectionAlignment" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HorizontalAlignment</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define o alinhamento a ser aplicado ao ponto de inserção ou seleção atual.</summary>
        <value>Um dos valores de <see cref="T:System.Windows.Forms.HorizontalAlignment" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se nenhum parágrafo for selecionado no controle, a definição dessa propriedade se aplica a configuração de alinhamento para o parágrafo em que o ponto de inserção também aparece como parágrafos criados após o parágrafo que contém a configuração de propriedade de alinhamento. Por exemplo, se houver dois parágrafos em uma <xref:System.Windows.Forms.RichTextBox> controle e o ponto de inserção está localizado no segundo parágrafo. Se você definir o <xref:System.Windows.Forms.RichTextBox.SelectionAlignment%2A> propriedade `HorizontalAlignment.Center`, parágrafo no ponto de inserção será centralizado dentro do controle. Se um terceiro parágrafo for criado após o segundo parágrafo, ele também será alinhado ao centro do controle.  
  
 Se uma seleção for feita dentro do controle quando a propriedade é definida, todos os parágrafos selecionados são alinhados com base na configuração dessa propriedade. Você pode usar essa propriedade para alinhar os parágrafos em um documento que está sendo criado no <xref:System.Windows.Forms.RichTextBox>. Por exemplo, se desejar que todos os parágrafos em um documento centralizado, você pode selecionar todos os parágrafos no controle e defina o <xref:System.Windows.Forms.RichTextBox.SelectionAlignment%2A> propriedade `HorizontalAlignment.Center`.  
  
> [!NOTE]
>  <xref:System.Windows.Forms.RichTextBox.SelectionAlignment%2A> Retorna `SelectionAlignment.Left` quando a seleção de texto contém vários parágrafos com alinhamento misto.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como alinhar o texto dentro de <xref:System.Windows.Forms.RichTextBox>. Este exemplo requer que um <xref:System.Windows.Forms.RichTextBox> controle, chamado `richTextBox1`, foi adicionado ao formulário.  
  
 [!code-cpp[RichTextBox.SelectionAlignment#1](~/samples/snippets/cpp/VS_Snippets_Winforms/RichTextBox.SelectionAlignment/CPP/form1.cpp#1)]
 [!code-csharp[RichTextBox.SelectionAlignment#1](~/samples/snippets/csharp/VS_Snippets_Winforms/RichTextBox.SelectionAlignment/CS/form1.cs#1)]
 [!code-vb[RichTextBox.SelectionAlignment#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/RichTextBox.SelectionAlignment/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">O valor especificado não é um dos valores definidos na classe <see cref="T:System.Windows.Forms.HorizontalAlignment" />.</exception>
        <altmember cref="T:System.Windows.Forms.HorizontalAlignment" />
      </Docs>
    </Member>
    <Member MemberName="SelectionBackColor">
      <MemberSignature Language="C#" Value="public System.Drawing.Color SelectionBackColor { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Color SelectionBackColor" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.RichTextBox.SelectionBackColor" />
      <MemberSignature Language="VB.NET" Value="Public Property SelectionBackColor As Color" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Drawing::Color SelectionBackColor { System::Drawing::Color get(); void set(System::Drawing::Color value); };" />
      <MemberSignature Language="F#" Value="member this.SelectionBackColor : System.Drawing.Color with get, set" Usage="System.Windows.Forms.RichTextBox.SelectionBackColor" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.Color</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define a cor do texto quando o texto é selecionado em um controle <see cref="T:System.Windows.Forms.RichTextBox" />.</summary>
        <value>Uma <see cref="T:System.Drawing.Color" /> que representa a cor do texto quando o texto é selecionado. O padrão é o valor da propriedade <see cref="P:System.Windows.Forms.Control.DefaultBackColor" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use <xref:System.Windows.Forms.RichTextBox.SelectionBackColor%2A> para obter ou definir a cor do texto selecionado no <xref:System.Windows.Forms.RichTextBox>. Se nenhum texto selecionado no momento, o <xref:System.Windows.Forms.RichTextBox.SelectionBackColor%2A> propriedade aplica-se à posição atual do cursor. Caracteres que são inseridos nessa posição tem especificado <xref:System.Windows.Forms.RichTextBox.SelectionBackColor%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SelectionBullet">
      <MemberSignature Language="C#" Value="public bool SelectionBullet { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool SelectionBullet" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.RichTextBox.SelectionBullet" />
      <MemberSignature Language="VB.NET" Value="Public Property SelectionBullet As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool SelectionBullet { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.SelectionBullet : bool with get, set" Usage="System.Windows.Forms.RichTextBox.SelectionBullet" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define um valor que indica se o estilo de marcador é aplicado ao ponto de inserção ou de seleção atual.</summary>
        <value>
          <see langword="true" /> se o ponto de inserção ou de seleção atual tiver o estilo de marcador aplicado, caso contrário, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se nenhum texto for selecionado, o estilo de marcador é aplicado ao ponto de inserção atual e a todos os parágrafos que o usuário insere após o ponto de inserção. O estilo do marcador é aplicado ao texto do controle até que o ponto de inserção é movido ou quando o usuário pressiona a tecla Enter em um item de marcador vazio.  
  
 Se o texto selecionado dentro do controle quando essa propriedade for definida, todos os parágrafos dentro do texto selecionado são convertidos em itens com marcadores na lista com marcadores. Você pode usar essa propriedade para criar uma lista com marcadores dentro dos documentos que você criar no <xref:System.Windows.Forms.RichTextBox> controle.  
  
 O <xref:System.Windows.Forms.RichTextBox.BulletIndent%2A> propriedade permite que você especifique a quantidade de recuo para aplicar entre o marcador e o texto do item com marcadores.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como usar o <xref:System.Windows.Forms.RichTextBox.SelectionBullet%2A> propriedade com o <xref:System.Windows.Forms.RichTextBox.SelectionFont%2A>, <xref:System.Windows.Forms.RichTextBox.SelectedText%2A>, e <xref:System.Windows.Forms.RichTextBox.SelectionColor%2A> propriedades para criar uma lista com marcadores em um <xref:System.Windows.Forms.RichTextBox> controle. Este exemplo requer que um <xref:System.Windows.Forms.RichTextBox> controle chamado `richTextBox1` é criado em um formulário.  
  
 [!code-cpp[RichTextBox.SelectionBullet#1](~/samples/snippets/cpp/VS_Snippets_Winforms/RichTextBox.SelectionBullet/CPP/form1.cpp#1)]
 [!code-csharp[RichTextBox.SelectionBullet#1](~/samples/snippets/csharp/VS_Snippets_Winforms/RichTextBox.SelectionBullet/CS/form1.cs#1)]
 [!code-vb[RichTextBox.SelectionBullet#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/RichTextBox.SelectionBullet/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.RichTextBox.BulletIndent" />
      </Docs>
    </Member>
    <Member MemberName="SelectionChanged">
      <MemberSignature Language="C#" Value="public event EventHandler SelectionChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler SelectionChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.RichTextBox.SelectionChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event SelectionChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ SelectionChanged;" />
      <MemberSignature Language="F#" Value="member this.SelectionChanged : EventHandler " Usage="member this.SelectionChanged : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ocorre quando a seleção de texto dentro do controle for alterada.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Você pode criar um manipulador de eventos para esse evento determinar quando o usuário alterou a seleção de texto dentro do controle. Um manipulador de eventos para esse evento pode ser usado para manter o texto selecionado até que o usuário tiver concluído uma tarefa dentro do aplicativo.  
  
 Para obter mais informações sobre a manipulação de eventos, consulte [NIB: consumindo eventos](http://msdn.microsoft.com/library/01e4f1bc-e55e-413f-98c7-6588493e5f67).  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra o uso desse membro. No exemplo, um manipulador de eventos relatórios sobre a ocorrência da <xref:System.Windows.Forms.RichTextBox.SelectionChanged> eventos. Este relatório ajuda você a saber quando o evento ocorre e pode ajudá-lo na depuração. Para gerar relatórios sobre vários eventos ou eventos que ocorrem com frequência, considere substituir <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> com <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> ou anexar a mensagem como um multiline <xref:System.Windows.Forms.TextBox>.  
  
 Para executar o código de exemplo, cole-o em um projeto que contém uma instância do tipo <xref:System.Windows.Forms.RichTextBox> chamado `RichTextBox1`. Certifique-se de que o manipulador de eventos está associado com o <xref:System.Windows.Forms.RichTextBox.SelectionChanged> evento.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#544](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#544)]
 [!code-vb[System.Windows.Forms.EventExamples#544](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#544)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SelectionCharOffset">
      <MemberSignature Language="C#" Value="public int SelectionCharOffset { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 SelectionCharOffset" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.RichTextBox.SelectionCharOffset" />
      <MemberSignature Language="VB.NET" Value="Public Property SelectionCharOffset As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int SelectionCharOffset { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.SelectionCharOffset : int with get, set" Usage="System.Windows.Forms.RichTextBox.SelectionCharOffset" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(0)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define se o texto no controle aparece na linha de base, como um sobrescrito ou como uma subscrito abaixo da linha de base.</summary>
        <value>Um número que especifica o deslocamento de caractere.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O valor dessa propriedade deve ser entre -2000 e 2000.  
  
 Se essa propriedade é definida como zero, o texto aparece na linha de base. Se for um número positivo, o número Especifica o número de pixels por qual elevar a seleção de texto acima da linha de base. Se for um número negativo, esse número Especifica o número de pixels pelo qual a seleção de texto de subscrito. Você pode usar essa propriedade para especificar o texto como sobrescrito ou subscrito.  
  
 Se nenhum texto for selecionado, o deslocamento é aplicado ao ponto de inserção atual e a todo o texto que o usuário digita após o ponto de inserção. O deslocamento de caractere se aplica até que a propriedade é alterada para um valor diferente, ou até que o ponto de inserção é movido para outra seção dentro do controle.  
  
 Se o texto selecionado dentro do controle, o texto selecionado e qualquer texto inserido após a seleção de texto terá o valor dessa propriedade aplicado a ele. Você pode usar essa propriedade para criar texto sobrescrito e subscrito para aplicativos como expressões matemáticas.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como especificar texto sobrescrito e subscrito dentro de <xref:System.Windows.Forms.RichTextBox> usando o <xref:System.Windows.Forms.RichTextBox.SelectionCharOffset%2A> propriedade. Este exemplo requer que um <xref:System.Windows.Forms.RichTextBox> controle, chamado `richTextBox1`, foi adicionado ao formulário.  
  
 [!code-cpp[RichTextBox.SelectionCharOffset#1](~/samples/snippets/cpp/VS_Snippets_Winforms/RichTextBox.SelectionCharOffset/CPP/form1.cpp#1)]
 [!code-csharp[RichTextBox.SelectionCharOffset#1](~/samples/snippets/csharp/VS_Snippets_Winforms/RichTextBox.SelectionCharOffset/CS/form1.cs#1)]
 [!code-vb[RichTextBox.SelectionCharOffset#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/RichTextBox.SelectionCharOffset/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">O valor especificado era menor que -2000 ou maior que 2000.</exception>
      </Docs>
    </Member>
    <Member MemberName="SelectionColor">
      <MemberSignature Language="C#" Value="public System.Drawing.Color SelectionColor { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Color SelectionColor" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.RichTextBox.SelectionColor" />
      <MemberSignature Language="VB.NET" Value="Public Property SelectionColor As Color" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Drawing::Color SelectionColor { System::Drawing::Color get(); void set(System::Drawing::Color value); };" />
      <MemberSignature Language="F#" Value="member this.SelectionColor : System.Drawing.Color with get, set" Usage="System.Windows.Forms.RichTextBox.SelectionColor" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.Color</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define a cor do texto do ponto de inserção ou seleção de texto atual.</summary>
        <value>Um <see cref="T:System.Drawing.Color" /> que representa a cor a ser aplicada à seleção de texto atual ou ao texto inserido após o ponto de inserção.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se a seleção de texto atual tiver mais de uma cor especificada, essa propriedade retornará `Color.Empty`. Se nenhum texto selecionado no momento, a cor do texto especificada por esta propriedade é aplicada ao ponto de inserção atual e a todo o texto digitado no controle após o ponto de inserção. A configuração de cor de texto se aplica até que a propriedade é alterada para uma cor diferente ou até que o ponto de inserção é movido para outra seção dentro do controle.  
  
 Se o texto selecionado dentro do controle, o texto selecionado e qualquer texto inserido após a seleção de texto terá o valor dessa propriedade aplicado a ele. Você pode usar essa propriedade para alterar a cor do texto no <xref:System.Windows.Forms.RichTextBox>.  
  
 Para tornar o texto em negrito no controle, use o <xref:System.Windows.Forms.RichTextBox.SelectionFont%2A> propriedade para atribuir uma nova fonte que tenha o estilo de fonte em negrito especificado.  
  
   
  
## Examples  
 O código a seguir exemplo exibe um <xref:System.Windows.Forms.ColorDialog> ao usuário para especificar uma cor para a seleção de texto atual ou o texto inserido após a inserção atual ponto em um <xref:System.Windows.Forms.RichTextBox> controle. Este exemplo requer que o método definido no exemplo é adicionado a um <xref:System.Windows.Forms.Form> classe que contém um <xref:System.Windows.Forms.RichTextBox> controle chamado `richTextBox1`.  
  
 [!code-cpp[Classic RichTextBox.SelectionColor Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic RichTextBox.SelectionColor Example/CPP/source.cpp#1)]
 [!code-csharp[Classic RichTextBox.SelectionColor Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic RichTextBox.SelectionColor Example/CS/source.cs#1)]
 [!code-vb[Classic RichTextBox.SelectionColor Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic RichTextBox.SelectionColor Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.RichTextBox.SelectionFont" />
        <altmember cref="M:System.Windows.Forms.TextBoxBase.Select(System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="SelectionFont">
      <MemberSignature Language="C#" Value="public System.Drawing.Font SelectionFont { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Drawing.Font SelectionFont" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.RichTextBox.SelectionFont" />
      <MemberSignature Language="VB.NET" Value="Public Property SelectionFont As Font" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Drawing::Font ^ SelectionFont { System::Drawing::Font ^ get(); void set(System::Drawing::Font ^ value); };" />
      <MemberSignature Language="F#" Value="member this.SelectionFont : System.Drawing.Font with get, set" Usage="System.Windows.Forms.RichTextBox.SelectionFont" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.Font</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define a fonte do ponto de inserção ou da seleção de texto atual.</summary>
        <value>Um <see cref="T:System.Drawing.Font" /> que representa a fonte a ser aplicada à seleção de texto atual ou ao texto inserido após o ponto de inserção.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se a seleção de texto atual tiver mais de uma fonte especificada, essa propriedade é `null`. Se nenhum texto selecionado no momento, a fonte especificada nesta propriedade é aplicada ao ponto de inserção atual e a todo o texto digitado no controle após o ponto de inserção. A configuração de fonte se aplica até que a propriedade é alterada para uma fonte diferente ou até que o ponto de inserção é movido para outra seção dentro do controle.  
  
 Se o texto selecionado dentro do controle, o texto selecionado e qualquer texto inserido após a seleção de texto terá o valor dessa propriedade aplicado a ele. Você pode usar essa propriedade para alterar o estilo da fonte do texto no <xref:System.Windows.Forms.RichTextBox>. Você pode tornar o texto no controle em negrito, itálico e sublinhado. Você também pode alterar o tamanho do texto e a fonte aplicada ao texto.  
  
 Para alterar a cor do texto no controle, use o <xref:System.Windows.Forms.RichTextBox.SelectionColor%2A> propriedade.  
  
   
  
## Examples  
 O exemplo de código a seguir altera o estilo de negrito fonte atual configuração para a seleção de texto ou texto inserido após o ponto de inserção dentro de <xref:System.Windows.Forms.RichTextBox> controle. Este exemplo requer que o código está contido dentro de um método em um <xref:System.Windows.Forms.Form>. O exemplo também requer que um <xref:System.Windows.Forms.RichTextBox>, denominado `richTextBox1`, foi adicionado para o <xref:System.Windows.Forms.Form>.  
  
 [!code-cpp[Classic RichTextBox.SelectionFont Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic RichTextBox.SelectionFont Example/CPP/source.cpp#1)]
 [!code-csharp[Classic RichTextBox.SelectionFont Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic RichTextBox.SelectionFont Example/CS/source.cs#1)]
 [!code-vb[Classic RichTextBox.SelectionFont Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic RichTextBox.SelectionFont Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.RichTextBox.SelectionColor" />
        <altmember cref="M:System.Windows.Forms.TextBoxBase.Select(System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="SelectionHangingIndent">
      <MemberSignature Language="C#" Value="public int SelectionHangingIndent { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 SelectionHangingIndent" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.RichTextBox.SelectionHangingIndent" />
      <MemberSignature Language="VB.NET" Value="Public Property SelectionHangingIndent As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int SelectionHangingIndent { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.SelectionHangingIndent : int with get, set" Usage="System.Windows.Forms.RichTextBox.SelectionHangingIndent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(0)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define a distância entre a borda esquerda da primeira linha do texto do parágrafo selecionado e a borda esquerda das linhas subsequentes do mesmo parágrafo.</summary>
        <value>A distância, em pixels, do recuo deslocado aplicado a seleção de texto atual ou ao ponto de inserção.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se nenhum texto selecionado no momento, o recuo deslocado é aplicado para o parágrafo em que o ponto de inserção aparece e todo o texto digitado no controle após o ponto de inserção. Aplica-se a configuração de recuo deslocada até que a propriedade é alterada para um valor diferente, ou até que o ponto de inserção é movido para um parágrafo diferente dentro do controle.  
  
 Se o texto selecionado dentro do controle, o texto selecionado e qualquer texto inserido após a seleção de texto terá o valor dessa propriedade aplicado a ele. Você pode usar essa propriedade para aplicar um recuo para os parágrafos.  
  
 Para definir o recuo da primeira linha de uma seleção de parágrafo, use o <xref:System.Windows.Forms.RichTextBox.SelectionIndent%2A> propriedade.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como especificar recuos deslocados dentro de <xref:System.Windows.Forms.RichTextBox> usando o <xref:System.Windows.Forms.RichTextBox.SelectionHangingIndent%2A> propriedade. Este exemplo requer que um <xref:System.Windows.Forms.RichTextBox> controle, chamado `richTextBox1`, foi adicionado ao formulário.  
  
 [!code-cpp[RichTextBox.SelectionHangingIndent#1](~/samples/snippets/cpp/VS_Snippets_Winforms/RichTextBox.SelectionHangingIndent/CPP/form1.cpp#1)]
 [!code-csharp[RichTextBox.SelectionHangingIndent#1](~/samples/snippets/csharp/VS_Snippets_Winforms/RichTextBox.SelectionHangingIndent/CS/form1.cs#1)]
 [!code-vb[RichTextBox.SelectionHangingIndent#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/RichTextBox.SelectionHangingIndent/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.RichTextBox.SelectionIndent" />
      </Docs>
    </Member>
    <Member MemberName="SelectionIndent">
      <MemberSignature Language="C#" Value="public int SelectionIndent { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 SelectionIndent" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.RichTextBox.SelectionIndent" />
      <MemberSignature Language="VB.NET" Value="Public Property SelectionIndent As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int SelectionIndent { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.SelectionIndent : int with get, set" Usage="System.Windows.Forms.RichTextBox.SelectionIndent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(0)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define o comprimento em pixels, o recuo da linha em que começa a seleção.</summary>
        <value>A distância atual, em pixels, do recuo aplicado à esquerda da seleção de texto atual ou do ponto de inserção.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se nenhum texto selecionado no momento, a configuração de recuo é aplicada para o parágrafo em que o ponto de inserção aparece e todo o texto digitado no controle após o ponto de inserção. Aplica-se a configuração de recuo, até que a propriedade é alterada para um valor diferente, ou até que o ponto de inserção é movido para um parágrafo diferente dentro do controle.  
  
 Se o texto selecionado dentro do controle, o texto selecionado e qualquer texto inserido após a seleção de texto terá o valor dessa propriedade aplicado a ele. Você pode usar essa propriedade para recuar parágrafos contidos no documento de <xref:System.Windows.Forms.RichTextBox>. Você pode usar essa propriedade em conjunto com o <xref:System.Windows.Forms.RichTextBox.SelectionRightIndent%2A> criar parágrafos exibidos nos parágrafos.  
  
 Para criar um recuo deslocado para parágrafos no controle, use o <xref:System.Windows.Forms.RichTextBox.SelectionHangingIndent%2A> propriedade.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como especificar texto recuada dentro de <xref:System.Windows.Forms.RichTextBox> usando o <xref:System.Windows.Forms.RichTextBox.SelectionIndent%2A> propriedade. Este exemplo requer que um <xref:System.Windows.Forms.RichTextBox> controle, chamado `richTextBox1`, foi adicionado ao formulário.  
  
 [!code-cpp[RichTextBox.SelectionIndent#1](~/samples/snippets/cpp/VS_Snippets_Winforms/RichTextBox.SelectionIndent/CPP/form1.cpp#1)]
 [!code-csharp[RichTextBox.SelectionIndent#1](~/samples/snippets/csharp/VS_Snippets_Winforms/RichTextBox.SelectionIndent/CS/form1.cs#1)]
 [!code-vb[RichTextBox.SelectionIndent#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/RichTextBox.SelectionIndent/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.RichTextBox.SelectionRightIndent" />
        <altmember cref="P:System.Windows.Forms.RichTextBox.SelectionHangingIndent" />
      </Docs>
    </Member>
    <Member MemberName="SelectionLength">
      <MemberSignature Language="C#" Value="public override int SelectionLength { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 SelectionLength" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.RichTextBox.SelectionLength" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property SelectionLength As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int SelectionLength { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.SelectionLength : int with get, set" Usage="System.Windows.Forms.RichTextBox.SelectionLength" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define o número de caracteres selecionados no controle.</summary>
        <value>O número de caracteres selecionados na caixa de texto.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Você pode usar essa propriedade para determinar se todos os caracteres estão selecionados atualmente no controle de caixa de texto antes de executar operações no texto selecionado. Você também pode usar essa propriedade para determinar o número total de caracteres (incluindo espaços) que são selecionadas ao executar um único caractere tarefas em um `for` loop.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como usar o <xref:System.Windows.Forms.RichTextBox.SelectionLength%2A> propriedade para determinar se o texto selecionado dentro de <xref:System.Windows.Forms.RichTextBox>. Este exemplo requer que um <xref:System.Windows.Forms.RichTextBox> controle, chamado `richTextBox1`, foi adicionado ao formulário. O exemplo também requer que `richTextBox1` contém o texto selecionado no controle.  
  
 [!code-cpp[RichTextBox.SelectionLength#1](~/samples/snippets/cpp/VS_Snippets_Winforms/RichTextBox.SelectionLength/CPP/form1.cpp#1)]
 [!code-csharp[RichTextBox.SelectionLength#1](~/samples/snippets/csharp/VS_Snippets_Winforms/RichTextBox.SelectionLength/CS/form1.cs#1)]
 [!code-vb[RichTextBox.SelectionLength#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/RichTextBox.SelectionLength/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.TextBoxBase.SelectionStart" />
        <altmember cref="P:System.Windows.Forms.TextBoxBase.SelectedText" />
      </Docs>
    </Member>
    <Member MemberName="SelectionProtected">
      <MemberSignature Language="C#" Value="public bool SelectionProtected { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool SelectionProtected" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.RichTextBox.SelectionProtected" />
      <MemberSignature Language="VB.NET" Value="Public Property SelectionProtected As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool SelectionProtected { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.SelectionProtected : bool with get, set" Usage="System.Windows.Forms.RichTextBox.SelectionProtected" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define um valor que indica se a seleção de texto atual está protegida.</summary>
        <value>
          <see langword="true" /> se a seleção atual impede as alterações ao seu conteúdo; caso contrário, <see langword="false" />. O padrão é <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se nenhum texto selecionado no momento, a configuração de proteção é aplicada para o parágrafo em que o ponto de inserção aparece e todo o texto digitado no controle após o ponto de inserção. Aplica-se a configuração de proteção até que a propriedade é alterada para um valor diferente, ou até que o ponto de inserção é movido para um parágrafo diferente dentro do controle.  
  
 Se o texto selecionado dentro do controle, o texto selecionado e qualquer texto inserido após a seleção de texto terá o valor dessa propriedade aplicado a ele. Você pode usar essa propriedade para impedir que o usuário modificando seções de texto dentro do controle.  
  
 Se essa propriedade é definida como `true`, o <xref:System.Windows.Forms.RichTextBox.Protected> é gerado quando o usuário tentou alterar a seleção de texto atual.  
  
> [!NOTE]
>  Esta propriedade retornará `true` apenas se toda a seleção dentro do controle contém conteúdo protegido.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como especificar texto protegido dentro de <xref:System.Windows.Forms.RichTextBox> usando o <xref:System.Windows.Forms.RichTextBox.SelectionProtected%2A> propriedade. Este exemplo requer que um <xref:System.Windows.Forms.RichTextBox> controle, chamado `richTextBox1`, foi adicionado ao formulário e que o <xref:System.Windows.Forms.RichTextBox> controle tem o texto adicionado a ele que contém a palavra "RichTextBox".  
  
 [!code-cpp[RichTextBox.SelectionProtected#1](~/samples/snippets/cpp/VS_Snippets_Winforms/RichTextBox.SelectionProtected/CPP/form1.cpp#1)]
 [!code-csharp[RichTextBox.SelectionProtected#1](~/samples/snippets/csharp/VS_Snippets_Winforms/RichTextBox.SelectionProtected/CS/form1.cs#1)]
 [!code-vb[RichTextBox.SelectionProtected#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/RichTextBox.SelectionProtected/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Forms.RichTextBox.Protected" />
      </Docs>
    </Member>
    <Member MemberName="SelectionRightIndent">
      <MemberSignature Language="C#" Value="public int SelectionRightIndent { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 SelectionRightIndent" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.RichTextBox.SelectionRightIndent" />
      <MemberSignature Language="VB.NET" Value="Public Property SelectionRightIndent As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int SelectionRightIndent { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.SelectionRightIndent : int with get, set" Usage="System.Windows.Forms.RichTextBox.SelectionRightIndent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(0)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>A distância (em pixels) entre a borda direita do controle <see cref="T:System.Windows.Forms.RichTextBox" /> e a borda direita do texto selecionado ou adicionado no ponto de inserção atual.</summary>
        <value>O espaço de recuo, em pixels, à direita da seleção ou do ponto de inserção atual.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se nenhum texto selecionado no momento, a configuração de recuo é aplicada para o parágrafo em que o ponto de inserção aparece e todo o texto digitado no controle após o ponto de inserção. Aplica-se a configuração de recuo, até que a propriedade é alterada para um valor diferente, ou até que o ponto de inserção é movido para um parágrafo diferente dentro do controle.  
  
 Se o texto selecionado dentro do controle, o texto selecionado e qualquer texto inserido após a seleção de texto terá o valor dessa propriedade aplicado a ele. Você pode usar essa propriedade para recuar parágrafos contidos no documento de <xref:System.Windows.Forms.RichTextBox>. Você pode usar essa propriedade em conjunto com o <xref:System.Windows.Forms.RichTextBox.SelectionIndent%2A> criar parágrafos exibidos nos parágrafos.  
  
 Para criar um recuo deslocado para parágrafos no controle, use o <xref:System.Windows.Forms.RichTextBox.SelectionHangingIndent%2A> propriedade.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como criar uma margem direita em um <xref:System.Windows.Forms.RichTextBox> usando o <xref:System.Windows.Forms.RichTextBox.SelectionRightIndent%2A> propriedade. O exemplo requer que você tenha um formulário que contém um <xref:System.Windows.Forms.RichTextBox> controle chamado `richTextBox1`, e que o código de exemplo é chamado de um evento na classe do formulário.  
  
 [!code-cpp[RichTextBox.SelectionRightIndent#1](~/samples/snippets/cpp/VS_Snippets_Winforms/RichTextBox.SelectionRightIndent/CPP/form1.cpp#1)]
 [!code-csharp[RichTextBox.SelectionRightIndent#1](~/samples/snippets/csharp/VS_Snippets_Winforms/RichTextBox.SelectionRightIndent/CS/form1.cs#1)]
 [!code-vb[RichTextBox.SelectionRightIndent#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/RichTextBox.SelectionRightIndent/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SelectionTabs">
      <MemberSignature Language="C#" Value="public int[] SelectionTabs { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32[] SelectionTabs" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.RichTextBox.SelectionTabs" />
      <MemberSignature Language="VB.NET" Value="Public Property SelectionTabs As Integer()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property cli::array &lt;int&gt; ^ SelectionTabs { cli::array &lt;int&gt; ^ get(); void set(cli::array &lt;int&gt; ^ value); };" />
      <MemberSignature Language="F#" Value="member this.SelectionTabs : int[] with get, set" Usage="System.Windows.Forms.RichTextBox.SelectionTabs" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define as posições de parada de tabulação absoluta em um controle <see cref="T:System.Windows.Forms.RichTextBox" />.</summary>
        <value>Uma matriz na qual cada membro especifica um deslocamento de guia, em pixels.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Essa propriedade permite que você obtenha uma matriz que contém o espaçamento para cada guia na seleção atual do texto dentro de <xref:System.Windows.Forms.RichTextBox> controle. Em seguida, você pode usar essa propriedade para ajustar o tamanho de cada guia dentro da seleção de texto. Por exemplo, se você deseja ajustar o espaço de guia no documento, você pode selecionar todo o documento e obter a lista de espaços de guia usando o <xref:System.Windows.Forms.RichTextBox.SelectionTabs%2A> propriedade. Você pode ajustá-las para novos valores e reatribuí-las a esta propriedade.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">A matriz tem mais do que o máximo de 32 elementos.</exception>
      </Docs>
    </Member>
    <Member MemberName="SelectionType">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.RichTextBoxSelectionTypes SelectionType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Forms.RichTextBoxSelectionTypes SelectionType" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.RichTextBox.SelectionType" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SelectionType As RichTextBoxSelectionTypes" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Forms::RichTextBoxSelectionTypes SelectionType { System::Windows::Forms::RichTextBoxSelectionTypes get(); };" />
      <MemberSignature Language="F#" Value="member this.SelectionType : System.Windows.Forms.RichTextBoxSelectionTypes" Usage="System.Windows.Forms.RichTextBox.SelectionType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.RichTextBoxSelectionTypes</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém o tipo de seleção no controle.</summary>
        <value>Uma combinação bit a bit dos valores <see cref="T:System.Windows.Forms.RichTextBoxSelectionTypes" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Você pode usar essa propriedade para determinar o tipo de dados que estão selecionados no momento no controle para lidar com a seleção corretamente ao desenvolver tarefas dentro do controle na seleção atual. A propriedade pode representar qualquer combinação de valores da <xref:System.Windows.Forms.RichTextBoxSelectionTypes> enumeração que representa os vários tipos de objetos na seleção atual.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.RichTextBox.SelectedRtf" />
      </Docs>
    </Member>
    <Member MemberName="ShowSelectionMargin">
      <MemberSignature Language="C#" Value="public bool ShowSelectionMargin { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ShowSelectionMargin" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.RichTextBox.ShowSelectionMargin" />
      <MemberSignature Language="VB.NET" Value="Public Property ShowSelectionMargin As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool ShowSelectionMargin { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.ShowSelectionMargin : bool with get, set" Usage="System.Windows.Forms.RichTextBox.ShowSelectionMargin" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define um valor que indica se uma margem de seleção é exibida em <see cref="T:System.Windows.Forms.RichTextBox" />.</summary>
        <value>
          <see langword="true" /> se uma margem de seleção estiver habilitada no controle; caso contrário, <see langword="false" />. O padrão é <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Você pode usar essa propriedade para habilitar o usuário a selecionar facilmente as linhas do texto no <xref:System.Windows.Forms.RichTextBox>. A margem de seleção é adicionada à esquerda do <xref:System.Windows.Forms.RichTextBox>. Essa margem torna mais fácil para o usuário selecionar o texto que começa no lado esquerdo do controle. O usuário pode clique na margem de seleção para selecionar uma única linha de texto ou clique duas vezes para selecionar todo o parágrafo que está dentro de linha de duas vezes.  
  
> [!NOTE]
>  Se o <xref:System.Windows.Forms.RichTextBox.ShowSelectionMargin%2A> está definida como `true`, a definição de <xref:System.Windows.Forms.RichTextBox.ScrollBars%2A> propriedade para `RichTextBoxScrollBars.Horizontal`, `RichTextBoxScrollBars.Vertical`, ou `RichTextBoxScrollBars.Both` não fará com que as barras de rolagem a serem exibidos. Para exibir as barras de rolagem ao <xref:System.Windows.Forms.RichTextBox.ShowSelectionMargin%2A> está definida como `true`, defina o <xref:System.Windows.Forms.RichTextBox.ScrollBars%2A> propriedade `RichTextBoxScrollBars.ForcedHorizontal`, `RichTextBoxScrollBars.ForcedVertical`, ou `RichTextBoxScrollBars.ForcedBoth`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Text">
      <MemberSignature Language="C#" Value="public override string Text { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Text" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.RichTextBox.Text" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property Text As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ Text { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Text : string with get, set" Usage="System.Windows.Forms.RichTextBox.Text" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.RefreshProperties</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define o texto atual na caixa RTF.</summary>
        <value>O texto exibido no controle.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para exibir várias linhas de texto em uma <xref:System.Windows.Forms.RichTextBox>, defina o <xref:System.Windows.Forms.TextBoxBase.Multiline%2A> propriedade `true`. Para ler ou definir o texto de uma caixa de texto de várias linhas, use o <xref:System.Windows.Forms.TextBoxBase.Lines%2A> propriedade. O <xref:System.Windows.Forms.RichTextBox.Text%2A> propriedade não retorna informações sobre a formatação aplicada ao conteúdo do <xref:System.Windows.Forms.RichTextBox>. Para obter o rich text (RTF) códigos de formatação, use o <xref:System.Windows.Forms.RichTextBox.Rtf%2A> propriedade. A quantidade de texto que pode ser inserido o <xref:System.Windows.Forms.RichTextBox> controle é limitado apenas pela memória disponível no sistema.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.TextBoxBase.Lines" />
        <altmember cref="P:System.Windows.Forms.TextBoxBase.Multiline" />
      </Docs>
    </Member>
    <Member MemberName="TextLength">
      <MemberSignature Language="C#" Value="public override int TextLength { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 TextLength" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.RichTextBox.TextLength" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property TextLength As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int TextLength { int get(); };" />
      <MemberSignature Language="F#" Value="member this.TextLength : int" Usage="System.Windows.Forms.RichTextBox.TextLength" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém o comprimento do texto no controle.</summary>
        <value>O número de caracteres contidos no texto do controle.</value>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Windows.Forms.TextBoxBase.TextLength" />
      </Docs>
    </Member>
    <Member MemberName="UndoActionName">
      <MemberSignature Language="C#" Value="public string UndoActionName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string UndoActionName" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.RichTextBox.UndoActionName" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property UndoActionName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ UndoActionName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.UndoActionName : string" Usage="System.Windows.Forms.RichTextBox.UndoActionName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém o nome da ação que pode ser desfeita no controle quando o método <see cref="M:System.Windows.Forms.TextBoxBase.Undo" /> é chamado.</summary>
        <value>O nome de texto da ação que pode ser desfeita.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Essa propriedade permite que você determine a última ação que foi executada dentro do controle que pode ser desfeito. Você pode usar essa propriedade para limitar as operações disponíveis para ser desfeita pelo usuário do controle.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.TextBoxBase.Undo" />
      </Docs>
    </Member>
    <Member MemberName="VScroll">
      <MemberSignature Language="C#" Value="public event EventHandler VScroll;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler VScroll" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.RichTextBox.VScroll" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event VScroll As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ VScroll;" />
      <MemberSignature Language="F#" Value="member this.VScroll : EventHandler " Usage="member this.VScroll : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ocorre quando o usuário clica nas barras de rolagem verticais do controle.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para obter mais informações sobre a manipulação de eventos, consulte [NIB: consumindo eventos](http://msdn.microsoft.com/library/01e4f1bc-e55e-413f-98c7-6588493e5f67).  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra o uso desse membro. No exemplo, um manipulador de eventos relatórios sobre a ocorrência da <xref:System.Windows.Forms.RichTextBox.VScroll> eventos. Este relatório ajuda você a saber quando o evento ocorre e pode ajudá-lo na depuração. Para gerar relatórios sobre vários eventos ou eventos que ocorrem com frequência, considere substituir <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> com <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> ou anexar a mensagem como um multiline <xref:System.Windows.Forms.TextBox>.  
  
 Para executar o código de exemplo, cole-o em um projeto que contém uma instância do tipo <xref:System.Windows.Forms.RichTextBox> chamado `RichTextBox1`. Certifique-se de que o manipulador de eventos está associado com o <xref:System.Windows.Forms.RichTextBox.VScroll> evento.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#545](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#545)]
 [!code-vb[System.Windows.Forms.EventExamples#545](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#545)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WndProc">
      <MemberSignature Language="C#" Value="protected override void WndProc (ref System.Windows.Forms.Message m);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void WndProc(valuetype System.Windows.Forms.Message&amp; m) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.RichTextBox.WndProc(System.Windows.Forms.Message@)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub WndProc (ByRef m As Message)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void WndProc(System::Windows::Forms::Message % m);" />
      <MemberSignature Language="F#" Value="override this.WndProc :  -&gt; unit" Usage="richTextBox.WndProc m" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="m" Type="System.Windows.Forms.Message&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="m">Um objeto de Mensagem do Windows.</param>
        <summary>Processa mensagens do Windows.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ZoomFactor">
      <MemberSignature Language="C#" Value="public float ZoomFactor { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float32 ZoomFactor" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.RichTextBox.ZoomFactor" />
      <MemberSignature Language="VB.NET" Value="Public Property ZoomFactor As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property float ZoomFactor { float get(); void set(float value); };" />
      <MemberSignature Language="F#" Value="member this.ZoomFactor : single with get, set" Usage="System.Windows.Forms.RichTextBox.ZoomFactor" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(1)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define o nível de zoom atual do <see cref="T:System.Windows.Forms.RichTextBox" />.</summary>
        <value>O fator pelo qual os conteúdos do controle são ampliados.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O valor dessa propriedade pode ser entre 1/64 (0.015625) e 64.0, inclusive não. Um valor de 1,0 indica que nenhum zoom é aplicado ao controle. O recurso de zoom apresente quando o documento contém fontes TrueType. Quando uma fonte que não é TrueType é usada dentro do documento do controle, o <xref:System.Windows.Forms.RichTextBox.ZoomFactor%2A> propriedade usará o valor de número inteiro mais próximo. Você pode usar essa propriedade para permitir que o usuário da <xref:System.Windows.Forms.RichTextBox> controle de zoom em seções da documentação que são muito pequenas para exibir ou para condensar a exibição para permitir que mais o documento seja exibido na tela.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como criar um <xref:System.Windows.Forms.RichTextBox> que amplia texto, seleciona automaticamente palavras no texto do controle quando uma palavra é clicado duas vezes e tem uma margem no lado direito da área cliente do controle. Se o <xref:System.Windows.Forms.RichTextBox> controle tem uma largura pequena, usar esse código cria um <xref:System.Windows.Forms.RichTextBox> onde cada caractere de texto é exibido em sua própria linha. Enquanto nesta posição de exibição vertical, clicando em qualquer parte de uma palavra para selecionar todos os caracteres da palavra, independentemente do fato de que o texto é exibido na vertical. Este exemplo requer que você tenha um formulário que contém um <xref:System.Windows.Forms.RichTextBox> controle chamado `richTextBox1`.  
  
 [!code-cpp[RichTextBox.ZoomFactor#1](~/samples/snippets/cpp/VS_Snippets_Winforms/RichTextBox.ZoomFactor/CPP/form1.cpp#1)]
 [!code-csharp[RichTextBox.ZoomFactor#1](~/samples/snippets/csharp/VS_Snippets_Winforms/RichTextBox.ZoomFactor/CS/form1.cs#1)]
 [!code-vb[RichTextBox.ZoomFactor#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/RichTextBox.ZoomFactor/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">O fator de zoom especificado não ficou dentro do intervalo permitido.</exception>
      </Docs>
    </Member>
  </Members>
</Type>