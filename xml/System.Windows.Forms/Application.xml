<Type Name="Application" FullName="System.Windows.Forms.Application">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="fb5a42730ceec2161b81c946cda56d790062bd5d" />
    <Meta Name="ms.sourcegitcommit" Value="5a49536d99d2d0b54e4cb7280870903e043272df" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="pt-BR" />
    <Meta Name="ms.lasthandoff" Value="07/03/2018" />
    <Meta Name="ms.locfileid" Value="37516303" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class Application" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit Application extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Forms.Application" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class Application" />
  <TypeSignature Language="C++ CLI" Value="public ref class Application sealed" />
  <TypeSignature Language="F#" Value="type Application = class" />
  <AssemblyInfo>
    <AssemblyName>System.Windows.Forms</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Provides <see langword="static" /> methods and properties to manage an application, such as methods to start and stop an application, to process Windows messages, and properties to get information about an application. This class cannot be inherited.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Windows.Forms.Application> classe tem métodos para iniciar e parar os aplicativos e threads e processar mensagens do Windows, da seguinte maneira:  
  
-   <xref:System.Windows.Forms.Application.Run%2A> inicia um loop de mensagem do aplicativo no thread atual e, opcionalmente, faz com que um formulário visível.  
  
-   <xref:System.Windows.Forms.Application.Exit%2A> ou <xref:System.Windows.Forms.Application.ExitThread%2A> interrompe um loop de mensagem.  
  
-   <xref:System.Windows.Forms.Application.DoEvents%2A> processa as mensagens, enquanto o programa está em um loop.  
  
-   <xref:System.Windows.Forms.Application.AddMessageFilter%2A> Adiciona um filtro de mensagem para a bomba de mensagens do aplicativo para monitorar mensagens do Windows.  
  
-   <xref:System.Windows.Forms.IMessageFilter> permite que você pare um evento seja gerado ou executar operações especiais antes de invocar um manipulador de eventos.  
  
 Essa classe tem <xref:System.Windows.Forms.Application.CurrentCulture%2A> e <xref:System.Windows.Forms.Application.CurrentInputLanguage%2A> propriedades para obter ou definir informações de cultura para o thread atual.  
  
 Você não pode criar uma instância dessa classe.  
  
   
  
## Examples  
 O exemplo de código a seguir lista os números em uma caixa de listagem em um formulário. Cada vez que você clicar `button1`, o aplicativo adiciona outro número à lista.  
  
 O `Main` chamadas de método <xref:System.Windows.Forms.Application.Run%2A> para iniciar o aplicativo, que cria o formulário, `listBox1` e `button1`. Quando o usuário clica `button1`, o `button1_Click` método exibe uma <xref:System.Windows.Forms.MessageBox>. Se o usuário clica `No` sobre o <xref:System.Windows.Forms.MessageBox>, o `button1_Click` método adiciona um número à lista. Se o usuário clica `Yes`, o aplicativo chama <xref:System.Windows.Forms.Application.Exit%2A> para processar todas as mensagens restantes na fila e, em seguida, para sair.  
  
> [!NOTE]
>  A chamada para <xref:System.Windows.Forms.Application.Exit%2A> falhará em confiança parcial.  
  
 [!code-cpp[Classic Application Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Application Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Application Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Application Example/CS/source.cs#1)]
 [!code-vb[Classic Application Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Application Example/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName="AddMessageFilter">
      <MemberSignature Language="C#" Value="public static void AddMessageFilter (System.Windows.Forms.IMessageFilter value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void AddMessageFilter(class System.Windows.Forms.IMessageFilter value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.AddMessageFilter(System.Windows.Forms.IMessageFilter)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub AddMessageFilter (value As IMessageFilter)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void AddMessageFilter(System::Windows::Forms::IMessageFilter ^ value);" />
      <MemberSignature Language="F#" Value="static member AddMessageFilter : System.Windows.Forms.IMessageFilter -&gt; unit" Usage="System.Windows.Forms.Application.AddMessageFilter value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Windows.Forms.IMessageFilter" />
      </Parameters>
      <Docs>
        <param name="value">The implementation of the <see cref="T:System.Windows.Forms.IMessageFilter" /> interface you want to install.</param>
        <summary>Adds a message filter to monitor Windows messages as they are routed to their destinations.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use um filtro de mensagem para impedir que eventos específicos que está sendo gerado ou executar operações especiais para um evento antes de ser passado para um manipulador de eventos. Filtros de mensagem são exclusivos de um thread específico.  
  
 Para impedir que uma mensagem que está sendo enviado, o `value` instância de parâmetro que você passa para esse método deve substituir o <xref:System.Windows.Forms.IMessageFilter.PreFilterMessage%2A> método com o código para manipular a mensagem. O método deve retornar `false`.  
  
> [!CAUTION]
>  Adicionar filtros de mensagem para a bomba de mensagens para um aplicativo pode degradar o desempenho.  
  
   
  
## Examples  
 O exemplo de código a seguir cria um filtro de mensagem chamado `TestMessageFilter`. Esse filtro bloqueia todas as mensagens relacionadas ao botão esquerdo do mouse. Antes de usar um filtro de mensagem, você deve fornecer uma implementação para o <xref:System.Windows.Forms.IMessageFilter> interface.  
  
 [!code-cpp[Classic Application.RemoveMessageFilter Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Application.RemoveMessageFilter Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Application.RemoveMessageFilter Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Application.RemoveMessageFilter Example/CS/source.cs#1)]
 [!code-vb[Classic Application.RemoveMessageFilter Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Application.RemoveMessageFilter Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">para o chamador imediato chamar código não gerenciado. Enumeração associada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
    <Member MemberName="AllowQuit">
      <MemberSignature Language="C#" Value="public static bool AllowQuit { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool AllowQuit" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.AllowQuit" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property AllowQuit As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool AllowQuit { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.AllowQuit : bool" Usage="System.Windows.Forms.Application.AllowQuit" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets a value indicating whether the caller can quit this application.</summary>
        <value>
          <see langword="true" /> se o chamador puder sair desse aplicativo; caso contrário, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Essa propriedade retornará `false` se ele é chamado de um <xref:System.Windows.Forms.Control> sendo hospedado dentro de um navegador da Web. Portanto, o <xref:System.Windows.Forms.Control> não é possível encerrar o <xref:System.Windows.Forms.Application>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ApplicationExit">
      <MemberSignature Language="C#" Value="public static event EventHandler ApplicationExit;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler ApplicationExit" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Application.ApplicationExit" />
      <MemberSignature Language="VB.NET" Value="Public Shared Custom Event ApplicationExit As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static event EventHandler ^ ApplicationExit;" />
      <MemberSignature Language="F#" Value="member this.ApplicationExit : EventHandler " Usage="member this.ApplicationExit : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Occurs when the application is about to shut down.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Você deve anexar os manipuladores de eventos para o <xref:System.Windows.Forms.Application.Exit%2A> evento para executar sem tratamento, tarefas necessárias antes do aplicativo será interrompido. Você pode fechar arquivos abertos por esse aplicativo, ou descarte de objetos que não recuperou a coleta de lixo.  
  
 Como esse é um evento estático, você deve desanexar quaisquer manipuladores de evento anexados a esse evento no <xref:System.Windows.Forms.Application.ApplicationExit> próprio manipulador de eventos. Se você não desanexar esses manipuladores, eles permanecerão anexados ao evento e continuam a consumir memória.  
  
   
  
## Examples  
 O exemplo de código a seguir exibe duas formas e sai do aplicativo quando ambas as formas são fechadas. Quando o aplicativo é iniciado e é encerrado, a posição de cada formulário será lembrada. Este exemplo demonstra como usar o <xref:System.Windows.Forms.Application.ApplicationExit> evento saber quando as posições de formulário devem ser persistidas para o arquivo e quando o `FileStream` devem ser fechados.  
  
 A classe `MyApplicationContext` herda de <xref:System.Windows.Forms.ApplicationContext> e mantém o controle de quando cada formulário é fechado e sai do thread atual quando ambos estiverem. A classe lembra a posição de cada formulário quando ele é fechado. Quando o <xref:System.Windows.Forms.Application.ApplicationExit> evento ocorre, a classe grava as posições de cada para o usuário no arquivo. Os dados de posição do formulário são armazenados em um arquivo intitulado `appdata.txt` que é criado no local determinado pelo <xref:System.Windows.Forms.Application.UserAppDataPath%2A>. O `Main` chamadas de método `Application.Run(context)` para iniciar o aplicativo, dado o <xref:System.Windows.Forms.ApplicationContext>.  
  
 Esse código é um trecho do exemplo mostrado o <xref:System.Windows.Forms.ApplicationContext> visão geral da classe. Consulte <xref:System.Windows.Forms.ApplicationContext> para a listagem de código inteiro.  
  
 [!code-cpp[Application#5](~/samples/snippets/cpp/VS_Snippets_Winforms/Application/CPP/source.cpp#5)]
 [!code-csharp[Application#5](~/samples/snippets/csharp/VS_Snippets_Winforms/Application/CS/source.cs#5)]
 [!code-vb[Application#5](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Application/VB/source.vb#5)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Application.Exit" />
      </Docs>
    </Member>
    <Member MemberName="CommonAppDataPath">
      <MemberSignature Language="C#" Value="public static string CommonAppDataPath { get; }" />
      <MemberSignature Language="ILAsm" Value=".property string CommonAppDataPath" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.CommonAppDataPath" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property CommonAppDataPath As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::String ^ CommonAppDataPath { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.CommonAppDataPath : string" Usage="System.Windows.Forms.Application.CommonAppDataPath" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the path for the application data that is shared among all users.</summary>
        <value>O caminho para os dados de aplicativo compartilhados entre todos os usuários.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se um caminho não existir, um será criado no seguinte formato:  
  
 *Caminho base*\\<xref:System.Windows.Forms.Application.CompanyName%2A>\\<xref:System.Windows.Forms.Application.ProductName%2A>\\<xref:System.Windows.Forms.Application.ProductVersion%2A>  
  
 <xref:System.Windows.Forms.Application.ProductVersion%2A> procura primeiro para ver se o assembly que contém o executável principal tem a `AssemblyInformationalVersion` atributo nele. Se esse atributo existir, ele é usado para ambos <xref:System.Windows.Forms.Application.ProductVersion%2A> e <xref:System.Windows.Forms.Application.CommonAppDataPath%2A>. Se esse atributo não existir, ambas as propriedades de usam a versão do arquivo executável em vez disso.  
  
 O caminho será diferente dependendo se o aplicativo de formulários do Windows é implantado usando [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)]. [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)] aplicativos são armazenados em um cache de aplicativo por usuário no C:\Documents and Settings\\*nome de usuário* directory. Para obter mais informações, confira [Acessando dados locais e remotos em aplicativos ClickOnce](http://msdn.microsoft.com/library/be5cbe12-6cb6-49c9-aa59-a1624e1eef3d).  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Application.CommonAppDataRegistry" />
      </Docs>
    </Member>
    <Member MemberName="CommonAppDataRegistry">
      <MemberSignature Language="C#" Value="public static Microsoft.Win32.RegistryKey CommonAppDataRegistry { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class Microsoft.Win32.RegistryKey CommonAppDataRegistry" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.CommonAppDataRegistry" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property CommonAppDataRegistry As RegistryKey" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property Microsoft::Win32::RegistryKey ^ CommonAppDataRegistry { Microsoft::Win32::RegistryKey ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.CommonAppDataRegistry : Microsoft.Win32.RegistryKey" Usage="System.Windows.Forms.Application.CommonAppDataRegistry" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.RegistryKey</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the registry key for the application data that is shared among all users.</summary>
        <value>Um <see cref="T:Microsoft.Win32.RegistryKey" /> que representa a chave do Registro dos dados de aplicativos compartilhados entre todos os usuários.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se a chave não existir, ele é criado no seguinte formato:  
  
 LocalMachine\Software\\<xref:System.Windows.Forms.Application.CompanyName%2A>\\<xref:System.Windows.Forms.Application.ProductName%2A>\\<xref:System.Windows.Forms.Application.ProductVersion%2A>   
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CompanyName">
      <MemberSignature Language="C#" Value="public static string CompanyName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property string CompanyName" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.CompanyName" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property CompanyName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::String ^ CompanyName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.CompanyName : string" Usage="System.Windows.Forms.Application.CompanyName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the company name associated with the application.</summary>
        <value>O nome da empresa.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O exemplo de código a seguir obtém essa propriedade e exibe seu valor em uma caixa de texto. O exemplo requer que `textBox1` foi colocado em um formulário.  
  
 [!code-cpp[Classic Application.CompanyName Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Application.CompanyName Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Application.CompanyName Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Application.CompanyName Example/CS/source.cs#1)]
 [!code-vb[Classic Application.CompanyName Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Application.CompanyName Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Application.ProductName" />
        <altmember cref="P:System.Windows.Forms.Application.ProductVersion" />
        <altmember cref="T:System.Reflection.AssemblyCompanyAttribute" />
      </Docs>
    </Member>
    <Member MemberName="CurrentCulture">
      <MemberSignature Language="C#" Value="public static System.Globalization.CultureInfo CurrentCulture { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Globalization.CultureInfo CurrentCulture" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.CurrentCulture" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property CurrentCulture As CultureInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Globalization::CultureInfo ^ CurrentCulture { System::Globalization::CultureInfo ^ get(); void set(System::Globalization::CultureInfo ^ value); };" />
      <MemberSignature Language="F#" Value="member this.CurrentCulture : System.Globalization.CultureInfo with get, set" Usage="System.Windows.Forms.Application.CurrentCulture" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Globalization.CultureInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the culture information for the current thread.</summary>
        <value>Um <see cref="T:System.Globalization.CultureInfo" /> que representa as informações de cultura do thread atual.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O exemplo de código a seguir obtém essa propriedade e exibe seu valor em uma caixa de texto. O exemplo requer que `textBox1` foi colocado em um formulário.  
  
 [!code-cpp[Classic Application.CurrentCulture Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Application.CurrentCulture Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Application.CurrentCulture Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Application.CurrentCulture Example/CS/source.cs#1)]
 [!code-vb[Classic Application.CurrentCulture Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Application.CurrentCulture Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">para todas as janelas definir essa propriedade. Enumeração associada: <see cref="F:System.Security.Permissions.UIPermissionWindow.AllWindows" /></permission>
        <altmember cref="T:System.Windows.Forms.InputLanguage" />
      </Docs>
    </Member>
    <Member MemberName="CurrentInputLanguage">
      <MemberSignature Language="C#" Value="public static System.Windows.Forms.InputLanguage CurrentInputLanguage { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Forms.InputLanguage CurrentInputLanguage" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.CurrentInputLanguage" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property CurrentInputLanguage As InputLanguage" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Forms::InputLanguage ^ CurrentInputLanguage { System::Windows::Forms::InputLanguage ^ get(); void set(System::Windows::Forms::InputLanguage ^ value); };" />
      <MemberSignature Language="F#" Value="member this.CurrentInputLanguage : System.Windows.Forms.InputLanguage with get, set" Usage="System.Windows.Forms.Application.CurrentInputLanguage" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.InputLanguage</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the current input language for the current thread.</summary>
        <value>Um <see cref="T:System.Windows.Forms.InputLanguage" /> que representa o idioma de entrada atual para o thread atual.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O exemplo de código a seguir obtém essa propriedade e exibe seu valor em uma caixa de texto. O exemplo requer que `textBox1` foi colocado em um formulário.  
  
 [!code-cpp[Classic Application.CurrentInputLanguage Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Application.CurrentInputLanguage Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Application.CurrentInputLanguage Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Application.CurrentInputLanguage Example/CS/source.cs#1)]
 [!code-vb[Classic Application.CurrentInputLanguage Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Application.CurrentInputLanguage Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">para o chamador imediato chamar código não gerenciado. Enumeração associada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="T:System.Globalization.CultureInfo" />
        <altmember cref="T:System.Windows.Forms.InputLanguage" />
      </Docs>
    </Member>
    <Member MemberName="DoEvents">
      <MemberSignature Language="C#" Value="public static void DoEvents ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void DoEvents() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.DoEvents" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub DoEvents ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void DoEvents();" />
      <MemberSignature Language="F#" Value="static member DoEvents : unit -&gt; unit" Usage="System.Windows.Forms.Application.DoEvents " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Processes all Windows messages currently in the message queue.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando você executa um formulário do Windows, ele cria o novo formulário, em seguida, aguarda eventos manipular. Cada vez que o formulário manipula um evento, ele processa todo o código associado com esse evento. Todos os outros eventos esperar na fila. Enquanto seu código manipula o evento, seu aplicativo não responde. Por exemplo, a janela não redesenha se outra janela é arrastada na parte superior.  
  
 Se você chamar <xref:System.Windows.Forms.Application.DoEvents%2A> em seu código, seu aplicativo pode manipular os outros eventos. Por exemplo, se você tiver um formulário que adiciona dados a um <xref:System.Windows.Forms.ListBox> e adicione <xref:System.Windows.Forms.Application.DoEvents%2A> ao seu código, seu formulário redesenha quando outra janela é arrastada sobre ele. Se você remover <xref:System.Windows.Forms.Application.DoEvents%2A> do seu código, seu formulário não será redesenhada até que o manipulador de eventos de clique do botão é concluído em execução. Para obter mais informações sobre mensagens, consulte [entrada do usuário nos Windows Forms](~/docs/framework/winforms/user-input-in-windows-forms.md).  
  
 Ao contrário do Visual Basic 6.0, o <xref:System.Windows.Forms.Application.DoEvents%2A> método não chama o <xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType> método.  
  
 Normalmente, você deve usar esse método em um loop para processar mensagens.  
  
> [!CAUTION]
>  Chamar esse método faz com que o thread atual a ser suspensa enquanto todas as mensagens de janela de espera são processadas. Se uma mensagem faz com que um evento seja disparado, outras áreas do código do aplicativo podem executar. Isso pode causar apresentam comportamentos inesperados que são difíceis de depurar seu aplicativo. Se você executar operações ou cálculos que levam muito tempo, geralmente é preferível executar essas operações em um novo thread. Para obter mais informações sobre a programação assíncrona, consulte [modelo de programação assíncrona (APM)](~/docs/standard/asynchronous-programming-patterns/asynchronous-programming-model-apm.md).  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como usar o <xref:System.Windows.Forms.Application.DoEvents%2A> método. Quando o exemplo for executado, um usuário pode selecionar arquivos gráficos de um <xref:System.Windows.Forms.OpenFileDialog>. Os arquivos selecionados são exibidos no formulário. O <xref:System.Windows.Forms.Application.DoEvents%2A> método força um redesenho do formulário para cada arquivo de gráficos aberto. Para executar este exemplo, cole o código a seguir em um formulário que contém um <xref:System.Windows.Forms.PictureBox> nomeado `PictureBox1`, um <xref:System.Windows.Forms.OpenFileDialog> denominada `OpenFileDialog1`e um botão chamado `fileButton`. Chame o `InitializePictureBox` e `InitializeOpenFileDialog` métodos do construtor do formulário ou `Load` método.  
  
> [!NOTE]
>  No Visual Studio, se você adicionar um <xref:System.Windows.Forms.OpenFileDialog> ao seu formulário usando uma operação de arrastar, você precisará modificar o seguinte `InitializeOpenFileDialog` método removendo a linha que cria uma nova instância da <xref:System.Windows.Forms.OpenFileDialog>.  
  
 O exemplo também requer que o <xref:System.Windows.Forms.Control.Click?displayProperty=nameWithType> eventos do <xref:System.Windows.Forms.Button> controle e o <xref:System.Windows.Forms.FileDialog.FileOk> evento do <xref:System.Windows.Forms.OpenFileDialog> estão conectados aos manipuladores de eventos definidos no exemplo. Quando o exemplo está em execução, exiba a caixa de diálogo clicando no botão.  
  
 [!code-cpp[System.Windows.Forms.FileDialog#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.FileDialog/CPP/filedialogform.cpp#1)]
 [!code-csharp[System.Windows.Forms.FileDialog#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.FileDialog/CS/filedialogform.cs#1)]
 [!code-vb[System.Windows.Forms.FileDialog#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.FileDialog/VB/filedialogform.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Application.Exit" />
        <altmember cref="M:System.Windows.Forms.Application.ExitThread" />
        <altmember cref="M:System.Windows.Forms.Application.Run" />
      </Docs>
    </Member>
    <Member MemberName="EnableVisualStyles">
      <MemberSignature Language="C#" Value="public static void EnableVisualStyles ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void EnableVisualStyles() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.EnableVisualStyles" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub EnableVisualStyles ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void EnableVisualStyles();" />
      <MemberSignature Language="F#" Value="static member EnableVisualStyles : unit -&gt; unit" Usage="System.Windows.Forms.Application.EnableVisualStyles " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Enables visual styles for the application.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método permite que os estilos visuais para o aplicativo. Estilos visuais são as cores, fontes e outros elementos visuais que formam um tema do sistema operacional. Controles serão desenhado com estilos visuais se o controle e o sistema operacional dão suporte a ele. Para ter um efeito <xref:System.Windows.Forms.Application.EnableVisualStyles> deve ser chamado antes de criar todos os controles no aplicativo; normalmente, <xref:System.Windows.Forms.Application.EnableVisualStyles> é a primeira linha no `Main` função. Um manifesto separado não é necessário para habilitar estilos visuais ao chamar <xref:System.Windows.Forms.Application.EnableVisualStyles>.  
  
> [!NOTE]
>  Antes do .NET Framework 2.0, o `FlatStyle` propriedade de alguns controles, como controles que derivam <xref:System.Windows.Forms.ButtonBase>, tinha que ser definida como <xref:System.Windows.Forms.FlatStyle.System?displayProperty=nameWithType> para que os controles a ser desenhado com estilos visuais. Em aplicativos escritos com o .NET Framework 2.0, isso não é necessário.  
  
> [!NOTE]
>  Esse método não terá efeito para controles hospedados no Internet Explorer.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra a chamada <xref:System.Windows.Forms.Application.EnableVisualStyles%2A> no `Main` função para habilitar estilos visuais para o aplicativo.  
  
 [!code-cpp[System.Windows.Forms.Application.EnableVisualStyles#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.Application.EnableVisualStyles/CPP/form1.cpp#1)]
 [!code-csharp[System.Windows.Forms.Application.EnableVisualStyles#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.Application.EnableVisualStyles/CS/form1.cs#1)]
 [!code-vb[System.Windows.Forms.Application.EnableVisualStyles#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.Application.EnableVisualStyles/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Application.RenderWithVisualStyles" />
        <altmember cref="P:System.Windows.Forms.Application.VisualStyleState" />
        <altmember cref="T:System.Windows.Forms.FlatStyle" />
      </Docs>
    </Member>
    <Member MemberName="EnterThreadModal">
      <MemberSignature Language="C#" Value="public static event EventHandler EnterThreadModal;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler EnterThreadModal" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Application.EnterThreadModal" />
      <MemberSignature Language="VB.NET" Value="Public Shared Custom Event EnterThreadModal As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static event EventHandler ^ EnterThreadModal;" />
      <MemberSignature Language="F#" Value="member this.EnterThreadModal : EventHandler " Usage="member this.EnterThreadModal : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Occurs when the application is about to enter a modal state.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!CAUTION]
>  Como esse é um evento estático, você deve desanexar seus manipuladores de eventos quando seu aplicativo é descartado ou o resultado serão vazamentos de memória.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra o uso desse membro. No exemplo, um manipulador de eventos relata a ocorrência da <xref:System.Windows.Forms.Application.EnterThreadModal> eventos. Este relatório ajuda você a saber quando o evento ocorre e pode ajudar na depuração. Para relatar em vários eventos ou em eventos que ocorrem com frequência, considere substituir <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> com <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> ou acrescentar a mensagem como um multiline <xref:System.Windows.Forms.TextBox>.  
  
 Para executar o exemplo de código, cole-o em um Windows Forms e certifique-se de que o manipulador de eventos está associado com o <xref:System.Windows.Forms.Application.EnterThreadModal> eventos.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#3](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#3)]
 [!code-vb[System.Windows.Forms.EventExamples#3](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#3)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Requer <see cref="P:System.Security.Permissions.SecurityPermissionAttribute.UnmanagedCode" /> permissão para ouvir o evento.</permission>
      </Docs>
    </Member>
    <Member MemberName="ExecutablePath">
      <MemberSignature Language="C#" Value="public static string ExecutablePath { get; }" />
      <MemberSignature Language="ILAsm" Value=".property string ExecutablePath" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.ExecutablePath" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property ExecutablePath As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::String ^ ExecutablePath { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ExecutablePath : string" Usage="System.Windows.Forms.Application.ExecutablePath" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the path for the executable file that started the application, including the executable name.</summary>
        <value>O caminho e o nome de executável para o arquivo executável que iniciou o aplicativo.  Esse caminho será diferente dependendo se o aplicativo de formulários do Windows é implantado usando o [! INCLUDE[ndptecclick](~/Includes/ndptecclick-MD.MD)]. [! Aplicativos de include[ndptecclick](~/Includes/ndptecclick-MD.MD)] são armazenados em um cache de aplicativo por usuário no C:\Documents and Settings\\* * nome de usuário de diretório. Para obter mais informações, consulte [acessando dados locais e remotos em aplicativos ClickOnce] (http://msdn.microsoft.com/library/be5cbe12-6cb6-49c9-aa59-a1624e1eef3d).</value>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Para obter o caminho. Enumeração associada: <see cref="T:System.Security.Permissions.FileIOPermissionAccess" /></permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="Exit">
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Informs all message pumps that they must terminate, and then closes all application windows after the messages have been processed.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Exit">
      <MemberSignature Language="C#" Value="public static void Exit ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Exit() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.Exit" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Exit ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Exit();" />
      <MemberSignature Language="F#" Value="static member Exit : unit -&gt; unit" Usage="System.Windows.Forms.Application.Exit " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Informs all message pumps that they must terminate, and then closes all application windows after the messages have been processed.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Windows.Forms.Application.Exit%2A> método interrompe a execução de todos os loops de mensagem em todos os threads e fecha todas as janelas do aplicativo. Esse método não necessariamente força o aplicativo seja encerrado. O <xref:System.Windows.Forms.Application.Exit%2A> método normalmente é chamado de dentro de um loop de mensagem e força <xref:System.Windows.Forms.Application.Run%2A> para retornar. Para sair de um loop de mensagens do thread atual, chame <xref:System.Windows.Forms.Application.ExitThread%2A>.  
  
 <xref:System.Windows.Forms.Application.Exit%2A> gera os seguintes eventos e executa as ações associadas a condicionais:  
  
-   Um <xref:System.Windows.Forms.Form.FormClosing> é gerado para cada formulário representado pelo <xref:System.Windows.Forms.Application.OpenForms%2A> propriedade. Esse evento pode ser cancelado, definindo a <xref:System.ComponentModel.CancelEventArgs.Cancel%2A> propriedade de seus <xref:System.Windows.Forms.FormClosingEventArgs> parâmetro `true`.  
  
-   Se um ou mais dos manipuladores cancelará o evento, em seguida, <xref:System.Windows.Forms.Application.Exit%2A> retornará sem fazer mais nada. Caso contrário, um <xref:System.Windows.Forms.Form.FormClosed> é gerado para cada formulário aberto e, em seguida, todos os loops de mensagem e formulários em execução são fechados.  
  
> [!NOTE]
>  O <xref:System.Windows.Forms.Application.Exit%2A> método não gera a <xref:System.Windows.Forms.Form.Closed> e <xref:System.Windows.Forms.Form.Closing> eventos, que estão obsoletos desde [!INCLUDE[dnprdnlong](~/includes/dnprdnlong-md.md)].  
  
   
  
## Examples  
 O exemplo de código a seguir lista os números em uma caixa de listagem em um formulário. Cada vez que você clicar `button1`, o aplicativo adiciona outro número à lista.  
  
 O `Main` chamadas de método <xref:System.Windows.Forms.Application.Run%2A> para iniciar o aplicativo, que cria o formulário, `listBox1`, e `button1`. Quando o usuário clica `button1`, o `button1_Click` método adiciona um a três à caixa de listagem de números e exibe um <xref:System.Windows.Forms.MessageBox>. Se o usuário clica **não** sobre o <xref:System.Windows.Forms.MessageBox>, o `button1_Click` método adiciona outro número para a lista. Se o usuário clica **Sim**, o aplicativo chama <xref:System.Windows.Forms.Application.Exit%2A>, para processar todas as mensagens restantes na fila e, em seguida, para sair.  
  
 O exemplo requer que `listBox1` e `button1` instanciado e colocado em um formulário.  
  
 [!code-cpp[Classic Application.Exit Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Application.Exit Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Application.Exit Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Application.Exit Example/CS/source.cs#1)]
 [!code-vb[Classic Application.Exit Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Application.Exit Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">para o chamador imediato chamar código não gerenciado. Enumeração associada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="M:System.Windows.Forms.Application.ExitThread" />
        <altmember cref="M:System.Windows.Forms.Application.Run" />
        <altmember cref="P:System.Windows.Forms.Application.OpenForms" />
        <altmember cref="E:System.Windows.Forms.Form.Closed" />
        <altmember cref="E:System.Windows.Forms.Form.Closing" />
      </Docs>
    </Member>
    <Member MemberName="Exit">
      <MemberSignature Language="C#" Value="public static void Exit (System.ComponentModel.CancelEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Exit(class System.ComponentModel.CancelEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.Exit(System.ComponentModel.CancelEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Exit (e As CancelEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Exit(System::ComponentModel::CancelEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="static member Exit : System.ComponentModel.CancelEventArgs -&gt; unit" Usage="System.Windows.Forms.Application.Exit e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.ComponentModel.CancelEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Returns whether any <see cref="T:System.Windows.Forms.Form" /> within the application cancelled the exit.</param>
        <summary>Informs all message pumps that they must terminate, and then closes all application windows after the messages have been processed.</summary>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.SecurityException">Permissão encerrar um execução de thread do aplicativo. Enumeração associada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="M:System.Windows.Forms.Application.Exit" />
      </Docs>
    </Member>
    <Member MemberName="ExitThread">
      <MemberSignature Language="C#" Value="public static void ExitThread ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ExitThread() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.ExitThread" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub ExitThread ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void ExitThread();" />
      <MemberSignature Language="F#" Value="static member ExitThread : unit -&gt; unit" Usage="System.Windows.Forms.Application.ExitThread " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Exits the message loop on the current thread and closes all windows on the thread.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use esse método para sair do loop de mensagem do thread atual. Esse método faz com que a chamada para <xref:System.Windows.Forms.Application.Run%2A> para o thread atual retornar. Para sair do aplicativo inteiro, chame <xref:System.Windows.Forms.Application.Exit%2A>.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">para o chamador imediato chamar código não gerenciado. Enumeração associada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="M:System.Windows.Forms.Application.Exit" />
      </Docs>
    </Member>
    <Member MemberName="FilterMessage">
      <MemberSignature Language="C#" Value="public static bool FilterMessage (ref System.Windows.Forms.Message message);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool FilterMessage(valuetype System.Windows.Forms.Message&amp; message) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.FilterMessage(System.Windows.Forms.Message@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FilterMessage (ByRef message As Message) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool FilterMessage(System::Windows::Forms::Message % message);" />
      <MemberSignature Language="F#" Value="static member FilterMessage :  -&gt; bool" Usage="System.Windows.Forms.Application.FilterMessage message" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="message" Type="System.Windows.Forms.Message&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="message">The Windows event message to filter.</param>
        <summary>Runs any filters against a window message, and returns a copy of the modified message.</summary>
        <returns>
          <see langword="True" /> if the filters were processed; otherwise, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Idle">
      <MemberSignature Language="C#" Value="public static event EventHandler Idle;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Idle" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Application.Idle" />
      <MemberSignature Language="VB.NET" Value="Public Shared Custom Event Idle As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static event EventHandler ^ Idle;" />
      <MemberSignature Language="F#" Value="member this.Idle : EventHandler " Usage="member this.Idle : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Occurs when the application finishes processing and is about to enter the idle state.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se você tiver tarefas que você deve executar antes do thread fica ocioso, anexá-los a este evento.  
  
> [!CAUTION]
>  Como esse é um evento estático, você deve desanexar seus manipuladores de eventos quando seu aplicativo é descartado ou o resultado serão vazamentos de memória.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra o uso desse membro. No exemplo, um manipulador de eventos relata a ocorrência da <xref:System.Windows.Forms.Application.Idle> eventos. Este relatório ajuda você a saber quando o evento ocorre e pode ajudar na depuração. Para relatar em vários eventos ou em eventos que ocorrem com frequência, considere substituir <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> com <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> ou acrescentar a mensagem como um multiline <xref:System.Windows.Forms.TextBox>.  
  
 Para executar o exemplo de código, cole-o em um formulário do Windows e certifique-se de que o manipulador de eventos está associado com o <xref:System.Windows.Forms.Application.Idle> eventos.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#2](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#2)]
 [!code-vb[System.Windows.Forms.EventExamples#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LeaveThreadModal">
      <MemberSignature Language="C#" Value="public static event EventHandler LeaveThreadModal;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler LeaveThreadModal" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Application.LeaveThreadModal" />
      <MemberSignature Language="VB.NET" Value="Public Shared Custom Event LeaveThreadModal As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static event EventHandler ^ LeaveThreadModal;" />
      <MemberSignature Language="F#" Value="member this.LeaveThreadModal : EventHandler " Usage="member this.LeaveThreadModal : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Occurs when the application is about to leave a modal state.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!CAUTION]
>  Como esse é um evento estático, você deve desanexar seus manipuladores de eventos quando seu aplicativo é descartado ou o resultado serão vazamentos de memória.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra o uso desse membro. No exemplo, um manipulador de eventos relata a ocorrência da <xref:System.Windows.Forms.Application.LeaveThreadModal> eventos. Este relatório ajuda você a saber quando o evento ocorre e pode ajudar na depuração. Para relatar em vários eventos ou em eventos que ocorrem com frequência, considere substituir <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> com <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> ou acrescentar a mensagem como um multiline <xref:System.Windows.Forms.TextBox>.  
  
 Para executar o exemplo de código, cole-o em um Windows Forms e certifique-se de que o manipulador de eventos está associado com o <xref:System.Windows.Forms.Application.LeaveThreadModal> eventos.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#4](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#4)]
 [!code-vb[System.Windows.Forms.EventExamples#4](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#4)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LocalUserAppDataPath">
      <MemberSignature Language="C#" Value="public static string LocalUserAppDataPath { get; }" />
      <MemberSignature Language="ILAsm" Value=".property string LocalUserAppDataPath" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.LocalUserAppDataPath" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property LocalUserAppDataPath As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::String ^ LocalUserAppDataPath { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.LocalUserAppDataPath : string" Usage="System.Windows.Forms.Application.LocalUserAppDataPath" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the path for the application data of a local, non-roaming user.</summary>
        <value>O caminho para os dados de aplicativo de um usuário local, não roaming.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Um usuário local é uma cujo perfil do usuário é armazenado no sistema em que o usuário fez logon. Se um caminho não existir, um será criado no seguinte formato:  
  
 *Caminho base*\\<xref:System.Windows.Forms.Application.CompanyName%2A>\\<xref:System.Windows.Forms.Application.ProductName%2A>\\<xref:System.Windows.Forms.Application.ProductVersion%2A>   
  
 Um caminho base típico é C:\Documents and Settings\\*nome de usuário*\Local dados. Esse caminho será diferente, no entanto, se o aplicativo de formulários do Windows é implantado usando [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)]. [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)] cria seu próprio diretório de dados de aplicativo que é isolado de todos os outros aplicativos. Para obter mais informações, confira [Acessando dados locais e remotos em aplicativos ClickOnce](http://msdn.microsoft.com/library/be5cbe12-6cb6-49c9-aa59-a1624e1eef3d).  
  
   
  
## Examples  
 O exemplo de código a seguir exibe duas formas e sai do aplicativo quando ambas as formas são fechadas. Quando o aplicativo é iniciado e é encerrado, a posição de cada formulário será lembrada. Embora este exemplo demonstra como usar o <xref:System.Windows.Forms.Application.UserAppDataPath%2A> propriedade para armazenar dados de aplicativo para o usuário, o <xref:System.Windows.Forms.Application.LocalUserAppDataPath%2A> pode ser usado em vez disso.  
  
 O `MyApplicationContext` classe herda de <xref:System.Windows.Forms.ApplicationContext> e mantém o controle quando cada formulário é fechado e sai do thread atual quando ambos estiverem. A classe armazena as posições de cada formulário do usuário. Os dados de posição do formulário são armazenados em um arquivo intitulado `Appdata.txt` que é criado no local determinado pelo <xref:System.Windows.Forms.Application.UserAppDataPath%2A>. O `Main` chamadas de método `Application.Run(context)` para iniciar o aplicativo, dado o <xref:System.Windows.Forms.ApplicationContext>.  
  
 Esse código é um trecho do exemplo mostrado o <xref:System.Windows.Forms.ApplicationContext> visão geral da classe. Algum código não é mostrado para fins de brevidade. Consulte <xref:System.Windows.Forms.ApplicationContext> para a listagem de código inteiro.  
  
 [!code-cpp[Application#5](~/samples/snippets/cpp/VS_Snippets_Winforms/Application/CPP/source.cpp#5)]
 [!code-csharp[Application#5](~/samples/snippets/csharp/VS_Snippets_Winforms/Application/CS/source.cs#5)]
 [!code-vb[Application#5](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Application/VB/source.vb#5)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MessageLoop">
      <MemberSignature Language="C#" Value="public static bool MessageLoop { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool MessageLoop" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.MessageLoop" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property MessageLoop As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool MessageLoop { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.MessageLoop : bool" Usage="System.Windows.Forms.Application.MessageLoop" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets a value indicating whether a message loop exists on this thread.</summary>
        <value>
          <see langword="true" /> se existir um loop de mensagem; caso contrário, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando a hospedagem dos formulários do Windows em outros ambientes, como aplicativos não gerenciados, essa propriedade sempre retornará `false`. Use <xref:System.Windows.Forms.Application.RegisterMessageLoop%2A> para instruir o Windows Forms se o ambiente de hospedagem ainda tem um loop de mensagem ativa.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OleRequired">
      <MemberSignature Language="C#" Value="public static System.Threading.ApartmentState OleRequired ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.ApartmentState OleRequired() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.OleRequired" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OleRequired () As ApartmentState" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::ApartmentState OleRequired();" />
      <MemberSignature Language="F#" Value="static member OleRequired : unit -&gt; System.Threading.ApartmentState" Usage="System.Windows.Forms.Application.OleRequired " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.ApartmentState</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Initializes OLE on the current thread.</summary>
        <returns>One of the <see cref="T:System.Threading.ApartmentState" /> values.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Chame esse método antes de chamar qualquer `Microsoft.Win32` método que exige OLE. <xref:System.Windows.Forms.Application.OleRequired%2A> primeiro verifica para ver se OLE foi inicializado no thread atual. Caso contrário, ele inicializa o thread para OLE.  
  
> [!NOTE]
>  A menos que um thread chama métodos OLE diretamente, você não precisa chamar esse método.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnThreadException">
      <MemberSignature Language="C#" Value="public static void OnThreadException (Exception t);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void OnThreadException(class System.Exception t) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.OnThreadException(System.Exception)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub OnThreadException (t As Exception)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void OnThreadException(Exception ^ t);" />
      <MemberSignature Language="F#" Value="static member OnThreadException : Exception -&gt; unit" Usage="System.Windows.Forms.Application.OnThreadException t" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="t" Type="System.Exception" />
      </Parameters>
      <Docs>
        <param name="t">An <see cref="T:System.Exception" /> that represents the exception that was thrown.</param>
        <summary>Raises the <see cref="E:System.Windows.Forms.Application.ThreadException" /> event.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Chamar <xref:System.Windows.Forms.Application.OnThreadException%2A> para gerar uma exceção que interromperá o processamento do aplicativo.  
  
 O <xref:System.Windows.Forms.Application> classe tem um <xref:System.Windows.Forms.Application.ThreadException> eventos. Você pode anexar um manipulador de eventos para esse evento para fazer qualquer processamento personalizado que você precisa para exceções sem tratamento. Se você anexar um manipulador de eventos, <xref:System.Windows.Forms.Application.OnThreadException%2A> executará o comportamento padrão, que envolve a exibir uma caixa de diálogo para informar ao usuário que houve um erro.  
  
 <xref:System.Windows.Forms.Application.OnThreadException%2A> apenas implementa o comportamento de exceção padrão para exceções sem tratamento que ocorrem em threads pertencentes a formulários do Windows. Exceções sem tratamento em outros threads são manipuladas pelo <xref:System.AppDomain.UnhandledException> eventos.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OpenForms">
      <MemberSignature Language="C#" Value="public static System.Windows.Forms.FormCollection OpenForms { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Forms.FormCollection OpenForms" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.OpenForms" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property OpenForms As FormCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Forms::FormCollection ^ OpenForms { System::Windows::Forms::FormCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.OpenForms : System.Windows.Forms.FormCollection" Usage="System.Windows.Forms.Application.OpenForms" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.FormCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets a collection of open forms owned by the application.</summary>
        <value>Um <see cref="T:System.Windows.Forms.FormCollection" /> que contém todos os formulários abertos no momento pertencentes a este aplicativo.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Windows.Forms.Application.OpenForms%2A> propriedade representa uma coleção somente leitura de formulários pertencentes ao aplicativo. Essa coleção pode ser pesquisada pela posição de índice ou pelo <xref:System.Windows.Forms.Control.Name%2A> do <xref:System.Windows.Forms.Form>.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">Chamador deve ter permissão para acessar todas as janelas, conforme definido pela <see cref="F:System.Security.Permissions.UIPermissionWindow.AllWindows" /> valor da <see cref="T:System.Security.Permissions.UIPermissionWindow" /> enumeração.</permission>
        <altmember cref="M:System.Windows.Forms.Application.Exit" />
        <altmember cref="T:System.Windows.Forms.FormCollection" />
      </Docs>
    </Member>
    <Member MemberName="ProductName">
      <MemberSignature Language="C#" Value="public static string ProductName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property string ProductName" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.ProductName" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property ProductName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::String ^ ProductName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ProductName : string" Usage="System.Windows.Forms.Application.ProductName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the product name associated with this application.</summary>
        <value>O Nome do produto.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `ProductName` é obtido dos metadados do assembly que contém o formulário principal do aplicativo atual. Você pode defini-lo definindo <xref:System.Reflection.AssemblyProductAttribute> dentro de seu manifesto do assembly. Para obter mais informações, consulte [manifesto do Assembly](~/docs/framework/app-domains/assembly-manifest.md).  
  
   
  
## Examples  
 O exemplo de código a seguir obtém essa propriedade e exibe seu valor em uma caixa de texto. O exemplo requer que `textBox1` foi colocado em um formulário.  
  
 [!code-cpp[Classic Application.ProductName Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Application.ProductName Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Application.ProductName Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Application.ProductName Example/CS/source.cs#1)]
 [!code-vb[Classic Application.ProductName Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Application.ProductName Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Application.ProductVersion" />
        <altmember cref="P:System.Windows.Forms.Application.CompanyName" />
        <altmember cref="T:System.Reflection.AssemblyProductAttribute" />
      </Docs>
    </Member>
    <Member MemberName="ProductVersion">
      <MemberSignature Language="C#" Value="public static string ProductVersion { get; }" />
      <MemberSignature Language="ILAsm" Value=".property string ProductVersion" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.ProductVersion" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property ProductVersion As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::String ^ ProductVersion { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ProductVersion : string" Usage="System.Windows.Forms.Application.ProductVersion" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the product version associated with this application.</summary>
        <value>A versão do produto.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Normalmente, um número de versão é exibida como *a maior parte do número*.* número de secundária*.* número de Build*.* número de peça particular*. Você pode definir explicitamente definindo a versão do assembly em seu manifesto do assembly. Para obter mais informações, consulte [manifesto do Assembly](~/docs/framework/app-domains/assembly-manifest.md).  
  
 <xref:System.Windows.Forms.Application.ProductVersion%2A> procura primeiro para ver se o assembly que contém o executável principal tem a `AssemblyInformationalVersion` atributo nele. Se esse atributo existir, ele é usado para ambos <xref:System.Windows.Forms.Application.ProductVersion%2A> e <xref:System.Windows.Forms.Application.CommonAppDataPath%2A>. Se esse atributo não existir, ambas as propriedades de usam a versão do arquivo executável em vez disso.  
  
   
  
## Examples  
 O exemplo de código a seguir obtém essa propriedade e exibe seu valor em uma caixa de texto. O exemplo requer que `textBox1` foi colocado em um formulário.  
  
 [!code-cpp[Classic Application.ProductVersion Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Application.ProductVersion Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Application.ProductVersion Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Application.ProductVersion Example/CS/source.cs#1)]
 [!code-vb[Classic Application.ProductVersion Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Application.ProductVersion Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Application.ProductName" />
        <altmember cref="P:System.Windows.Forms.Application.CompanyName" />
        <altmember cref="T:System.Reflection.AssemblyVersionAttribute" />
      </Docs>
    </Member>
    <Member MemberName="RaiseIdle">
      <MemberSignature Language="C#" Value="public static void RaiseIdle (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RaiseIdle(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.RaiseIdle(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RaiseIdle (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RaiseIdle(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="static member RaiseIdle : EventArgs -&gt; unit" Usage="System.Windows.Forms.Application.RaiseIdle e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">The <see cref="T:System.EventArgs" /> objects to pass to the <see cref="E:System.Windows.Forms.Application.Idle" /> event.</param>
        <summary>Raises the <see cref="E:System.Windows.Forms.Application.Idle" /> event in hosted scenarios.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método é usado quando a hospedagem dos formulários do Windows em outro ambiente, como um aplicativo não gerenciado. Você deve chamar <xref:System.Windows.Forms.Application.RaiseIdle%2A> quando o aplicativo de hospedagem entra em um estado ocioso. Isso permite que alguns controles dos Windows Forms e componentes para fazer o trabalho importante em segundo plano enquanto o usuário não está interagindo com o aplicativo.  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Forms.Application.Idle" />
      </Docs>
    </Member>
    <Member MemberName="RegisterMessageLoop">
      <MemberSignature Language="C#" Value="public static void RegisterMessageLoop (System.Windows.Forms.Application.MessageLoopCallback callback);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RegisterMessageLoop(class System.Windows.Forms.Application/MessageLoopCallback callback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.RegisterMessageLoop(System.Windows.Forms.Application.MessageLoopCallback)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RegisterMessageLoop (callback As Application.MessageLoopCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RegisterMessageLoop(System::Windows::Forms::Application::MessageLoopCallback ^ callback);" />
      <MemberSignature Language="F#" Value="static member RegisterMessageLoop : System.Windows.Forms.Application.MessageLoopCallback -&gt; unit" Usage="System.Windows.Forms.Application.RegisterMessageLoop callback" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callback" Type="System.Windows.Forms.Application+MessageLoopCallback" />
      </Parameters>
      <Docs>
        <param name="callback">The method to call when Windows Forms needs to check if the hosting environment is still sending messages.</param>
        <summary>Registers a callback for checking whether the message loop is running in hosted environments.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método é usado quando a hospedagem dos formulários do Windows em outro ambiente, como um aplicativo não gerenciado. Em ambientes hospedados, o <xref:System.Windows.Forms.Application.MessageLoop%2A> propriedade sempre retornará false se os formulários do Windows não está processando mensagens. Use esse retorno de chamada para informar ao Windows Forms se o ambiente de hospedagem ainda está processando as mensagens.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Forms.Application.MessageLoopCallback" />
      </Docs>
    </Member>
    <Member MemberName="RemoveMessageFilter">
      <MemberSignature Language="C#" Value="public static void RemoveMessageFilter (System.Windows.Forms.IMessageFilter value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RemoveMessageFilter(class System.Windows.Forms.IMessageFilter value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.RemoveMessageFilter(System.Windows.Forms.IMessageFilter)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RemoveMessageFilter (value As IMessageFilter)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RemoveMessageFilter(System::Windows::Forms::IMessageFilter ^ value);" />
      <MemberSignature Language="F#" Value="static member RemoveMessageFilter : System.Windows.Forms.IMessageFilter -&gt; unit" Usage="System.Windows.Forms.Application.RemoveMessageFilter value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Windows.Forms.IMessageFilter" />
      </Parameters>
      <Docs>
        <param name="value">The implementation of the <see cref="T:System.Windows.Forms.IMessageFilter" /> to remove from the application.</param>
        <summary>Removes a message filter from the message pump of the application.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Você pode remover um filtro de mensagem quando você não deseja capturar mensagens do Windows antes de serem expedidas.  
  
   
  
## Examples  
 Antes de usar um filtro de mensagem, você deve fornecer uma implementação para o <xref:System.Windows.Forms.IMessageFilter> interface. A classe a seguir cria um filtro de mensagem chamado `TestMessageFilter`. Esse filtro bloqueia todas as mensagens relacionadas ao botão esquerdo do mouse.  
  
 [!code-cpp[Classic Application.RemoveMessageFilter Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Application.RemoveMessageFilter Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Application.RemoveMessageFilter Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Application.RemoveMessageFilter Example/CS/source.cs#1)]
 [!code-vb[Classic Application.RemoveMessageFilter Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Application.RemoveMessageFilter Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Application.AddMessageFilter(System.Windows.Forms.IMessageFilter)" />
      </Docs>
    </Member>
    <Member MemberName="RenderWithVisualStyles">
      <MemberSignature Language="C#" Value="public static bool RenderWithVisualStyles { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool RenderWithVisualStyles" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.RenderWithVisualStyles" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property RenderWithVisualStyles As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool RenderWithVisualStyles { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.RenderWithVisualStyles : bool" Usage="System.Windows.Forms.Application.RenderWithVisualStyles" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets a value specifying whether the current application is drawing controls with visual styles.</summary>
        <value>
          <see langword="true" /> se os estilos visuais estiverem habilitados para controles na área de cliente das janelas do aplicativo. Caso contrário, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se você está desenhando um controle personalizado, use essa propriedade para decidir se é desenhar o controle com ou sem estilos visuais, para que sua aparência seja consistente com outros controles no aplicativo.  
  
 A tabela a seguir mostra as quatro condições que devem existir para <xref:System.Windows.Forms.Application.RenderWithVisualStyles%2A> para retornar `true`.  
  
|Condição|Descrição|  
|---------------|-----------------|  
|O sistema operacional dá suporte a estilos visuais|Para verificar essa condição separadamente, use o <xref:System.Windows.Forms.VisualStyles.VisualStyleInformation.IsSupportedByOS%2A> propriedade do <xref:System.Windows.Forms.VisualStyles.VisualStyleInformation> classe.|  
|O usuário habilitou estilos visuais no sistema operacional|Para verificar essa condição separadamente, use o <xref:System.Windows.Forms.VisualStyles.VisualStyleInformation.IsEnabledByUser%2A> propriedade do <xref:System.Windows.Forms.VisualStyles.VisualStyleInformation> classe.|  
|Estilos visuais estiverem habilitados no aplicativo|Estilos visuais podem ser habilitados em um aplicativo chamando o <xref:System.Windows.Forms.Application.EnableVisualStyles> método ou usando um aplicativo de manifesto que especifique que ComCtl32.dll versão 6 ou posterior será usado para desenhar controles.|  
|Estilos visuais estão sendo usados para desenhar a área de cliente do windows do aplicativo|Para verificar essa condição separadamente, use o <xref:System.Windows.Forms.Application.VisualStyleState%2A> propriedade do <xref:System.Windows.Forms.Application> classe e verificar se ele tem o valor <xref:System.Windows.Forms.VisualStyles.VisualStyleState.ClientAreaEnabled?displayProperty=nameWithType> ou <xref:System.Windows.Forms.VisualStyles.VisualStyleState.ClientAndNonClientAreasEnabled?displayProperty=nameWithType>.|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Restart">
      <MemberSignature Language="C#" Value="public static void Restart ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Restart() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.Restart" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Restart ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Restart();" />
      <MemberSignature Language="F#" Value="static member Restart : unit -&gt; unit" Usage="System.Windows.Forms.Application.Restart " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Shuts down the application and starts a new instance immediately.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O motivo mais comum para chamar `Restart` é iniciar uma nova versão do aplicativo que você baixou por meio [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)] usando o `Update` ou `UpdateAsync` método.  
  
 Aplicativos são reiniciados no contexto no qual eles foram inicialmente executados. Se seu aplicativo foi iniciado usando uma URL que aponta diretamente para o arquivo executável principal do aplicativo, ele será reiniciado usando a mesma URL. Se seu aplicativo for um [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)] aplicativo, ele será reiniciado usando [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)].  
  
 Se seu aplicativo tiver sido fornecidas originalmente opções de linha de comando quando executada pela primeira vez, <xref:System.Windows.Forms.Application.Restart%2A> iniciará o aplicativo novamente com as mesmas opções.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Your code is not a Windows Forms application. You cannot call this method in this context.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Requer <see cref="M:System.Security.Permissions.SecurityPermission.IsUnrestricted" /> permissão.</permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="Run">
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Begins running a standard application message loop on the current thread.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Run">
      <MemberSignature Language="C#" Value="public static void Run ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Run() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.Run" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Run ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Run();" />
      <MemberSignature Language="F#" Value="static member Run : unit -&gt; unit" Usage="System.Windows.Forms.Application.Run " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Begins running a standard application message loop on the current thread, without a form.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Em um baseado em Win32 ou formulários do Windows é de um loop de mensagem de aplicativo, uma rotina no código que processa eventos de usuário, como cliques do mouse e teclas digitadas. Todos os aplicativos em execução com base em Windows requer um loop de mensagens ativas, chamado do loop de mensagem principal. Quando o loop de mensagem principal for fechado, o aplicativo é encerrado. No Windows Forms, este loop é fechado quando o <xref:System.Windows.Forms.Application.Exit%2A> método é chamado, ou quando o <xref:System.Windows.Forms.Application.ExitThread%2A> método é chamado no thread que está executando o loop de mensagem principal.  
  
 A maioria dos desenvolvedores de formulários do Windows não precisará usar essa versão do método. Você deve usar o <xref:System.Windows.Forms.Application.Run%28System.Windows.Forms.Form%29> sobrecarga para iniciar um aplicativo com um formulário principal, para que o aplicativo é encerrado quando o formulário principal é fechado. Para todas as outras situações, use o <xref:System.Windows.Forms.Application.Run%28System.Windows.Forms.ApplicationContext%29> sobrecarregar, que dá suporte ao fornecimento de um <xref:System.Windows.Forms.ApplicationContext> objeto para um melhor controle sobre o tempo de vida do aplicativo.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">A main message loop is already running on this thread.</exception>
        <altmember cref="M:System.Windows.Forms.Application.Exit" />
        <altmember cref="M:System.Windows.Forms.Application.ExitThread" />
        <altmember cref="M:System.Windows.Forms.Application.DoEvents" />
      </Docs>
    </Member>
    <Member MemberName="Run">
      <MemberSignature Language="C#" Value="public static void Run (System.Windows.Forms.ApplicationContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Run(class System.Windows.Forms.ApplicationContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.Run(System.Windows.Forms.ApplicationContext)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Run (context As ApplicationContext)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Run(System::Windows::Forms::ApplicationContext ^ context);" />
      <MemberSignature Language="F#" Value="static member Run : System.Windows.Forms.ApplicationContext -&gt; unit" Usage="System.Windows.Forms.Application.Run context" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="context" Type="System.Windows.Forms.ApplicationContext" />
      </Parameters>
      <Docs>
        <param name="context">An <see cref="T:System.Windows.Forms.ApplicationContext" /> in which the application is run.</param>
        <summary>Begins running a standard application message loop on the current thread, with an <see cref="T:System.Windows.Forms.ApplicationContext" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O loop de mensagens é executado até <xref:System.Windows.Forms.Application.Exit%2A> ou <xref:System.Windows.Forms.Application.ExitThread%2A> é chamado ou o <xref:System.Windows.Forms.Application.ThreadExit> é gerado no objeto de contexto.  
  
   
  
## Examples  
 O exemplo exibe dois formulários e sai do aplicativo quando ambas as formas são fechadas. Quando o aplicativo é iniciado e é encerrado, a posição de cada formulário será lembrada. Este exemplo demonstra como usar um <xref:System.Windows.Forms.ApplicationContext>, juntamente com o `Application.Run(context)` método para exibir vários formulários, quando o aplicativo é iniciado.  
  
 A classe `MyApplicationContext` herda de <xref:System.Windows.Forms.ApplicationContext> e mantém o controle quando cada formulário é fechado e sai do thread atual quando ambos estiverem. A classe armazena as posições de cada formulário do usuário. Os dados de posição do formulário são armazenados em um arquivo intitulado `Appdata.txt` que é criado no local determinado pelo <xref:System.Windows.Forms.Application.UserAppDataPath%2A>. O `Main` chamadas de método `Application.Run(context)` para iniciar o aplicativo, dado o <xref:System.Windows.Forms.ApplicationContext>.  
  
 O código para o `AppForm1` e `AppForm2` formulários não é mostrada para fins de brevidade. Consulte o <xref:System.Windows.Forms.ApplicationContext> visão geral da classe para a listagem de código inteiro.  
  
 [!code-cpp[Application#2](~/samples/snippets/cpp/VS_Snippets_Winforms/Application/CPP/source.cpp#2)]
 [!code-csharp[Application#2](~/samples/snippets/csharp/VS_Snippets_Winforms/Application/CS/source.cs#2)]
 [!code-vb[Application#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Application/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">A main message loop is already running on this thread.</exception>
        <altmember cref="M:System.Windows.Forms.Application.Exit" />
        <altmember cref="M:System.Windows.Forms.Application.ExitThread" />
        <altmember cref="M:System.Windows.Forms.Application.DoEvents" />
      </Docs>
    </Member>
    <Member MemberName="Run">
      <MemberSignature Language="C#" Value="public static void Run (System.Windows.Forms.Form mainForm);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Run(class System.Windows.Forms.Form mainForm) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.Run(System.Windows.Forms.Form)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Run (mainForm As Form)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Run(System::Windows::Forms::Form ^ mainForm);" />
      <MemberSignature Language="F#" Value="static member Run : System.Windows.Forms.Form -&gt; unit" Usage="System.Windows.Forms.Application.Run mainForm" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="mainForm" Type="System.Windows.Forms.Form" />
      </Parameters>
      <Docs>
        <param name="mainForm">A <see cref="T:System.Windows.Forms.Form" /> that represents the form to make visible.</param>
        <summary>Begins running a standard application message loop on the current thread, and makes the specified form visible.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Normalmente, a função principal de um aplicativo chama esse método e passa para ele a janela principal do aplicativo.  
  
 Esse método adiciona um manipulador de eventos para o `mainForm` parâmetro para o <xref:System.Windows.Forms.Form.Closed> eventos. Chamadas do manipulador de eventos <xref:System.Windows.Forms.Application.ExitThread%2A> para limpar o aplicativo.  
  
> [!NOTE]
>  O <xref:System.Windows.Forms.Control.Dispose%2A> método da <xref:System.Windows.Forms.Form> classe será chamada antes do retorno desse método.  
  
   
  
## Examples  
 O exemplo de código a seguir lista os números em uma caixa de listagem em um formulário. Cada vez que você clicar `button1`, o aplicativo adiciona outro número à lista.  
  
 O `Main` chamadas de método <xref:System.Windows.Forms.Application.Run%2A> para iniciar o aplicativo, que cria o formulário, `listBox1`, e `button1`. Quando o usuário clica `button1`, o `button1_Click` método adiciona um a três à caixa de listagem de números e exibe um <xref:System.Windows.Forms.MessageBox>. Se o usuário clica **não** sobre o <xref:System.Windows.Forms.MessageBox>, o `button1_Click` método adiciona outro número para a lista. Se o usuário clica **Sim**, o aplicativo chama <xref:System.Windows.Forms.Application.Exit%2A> para processar todas as mensagens restantes na fila e, em seguida, para sair.  
  
 O exemplo requer que `listBox1` e `button1` foram criados e colocados em um formulário.  
  
 [!code-cpp[Classic Application.Exit Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Application.Exit Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Application.Exit Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Application.Exit Example/CS/source.cs#1)]
 [!code-vb[Classic Application.Exit Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Application.Exit Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">A main message loop is already running on the current thread.</exception>
        <altmember cref="M:System.Windows.Forms.Application.Exit" />
        <altmember cref="M:System.Windows.Forms.Application.ExitThread" />
        <altmember cref="M:System.Windows.Forms.Application.DoEvents" />
      </Docs>
    </Member>
    <Member MemberName="SafeTopLevelCaptionFormat">
      <MemberSignature Language="C#" Value="public static string SafeTopLevelCaptionFormat { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property string SafeTopLevelCaptionFormat" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.SafeTopLevelCaptionFormat" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property SafeTopLevelCaptionFormat As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::String ^ SafeTopLevelCaptionFormat { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.SafeTopLevelCaptionFormat : string with get, set" Usage="System.Windows.Forms.Application.SafeTopLevelCaptionFormat" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the format string to apply to top-level window captions when they are displayed with a warning banner.</summary>
        <value>A cadeia de caracteres de formato a ser aplicado às legendas da janela de nível superior.</value>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">para todas as janelas definir essa propriedade. Enumeração associada: <see cref="F:System.Security.Permissions.UIPermissionWindow.AllWindows" /></permission>
      </Docs>
    </Member>
    <Member MemberName="SetCompatibleTextRenderingDefault">
      <MemberSignature Language="C#" Value="public static void SetCompatibleTextRenderingDefault (bool defaultValue);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetCompatibleTextRenderingDefault(bool defaultValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.SetCompatibleTextRenderingDefault(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetCompatibleTextRenderingDefault (defaultValue As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetCompatibleTextRenderingDefault(bool defaultValue);" />
      <MemberSignature Language="F#" Value="static member SetCompatibleTextRenderingDefault : bool -&gt; unit" Usage="System.Windows.Forms.Application.SetCompatibleTextRenderingDefault defaultValue" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="defaultValue" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="defaultValue">The default value to use for new controls. If <see langword="true" />, new controls that support <c>UseCompatibleTextRendering</c> use the [!INCLUDE[ndptecgdiplus](~/includes/ndptecgdiplus-md.md)] based <see cref="T:System.Drawing.Graphics" /> class for text rendering; if <see langword="false" />, new controls use the [!INCLUDE[ndptecgdi](~/includes/ndptecgdi-md.md)] based <see cref="T:System.Windows.Forms.TextRenderer" /> class.</param>
        <summary>Sets the application-wide default for the <c>UseCompatibleTextRendering</c> property defined on certain controls.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Determinados controles de Windows Forms podem renderizar o texto utilizando qualquer um a <xref:System.Windows.Forms.TextRenderer> classe, que se baseia o [!INCLUDE[ndptecgdi](~/includes/ndptecgdi-md.md)] biblioteca de elementos gráficos, ou o <xref:System.Drawing.Graphics> classe, que se baseia o [!INCLUDE[ndptecgdiplus](~/includes/ndptecgdiplus-md.md)] biblioteca de elementos gráficos. Essa alteração foi feita na [!INCLUDE[dnprdnlong](~/includes/dnprdnlong-md.md)] devido a problemas de desempenho e a localização com [!INCLUDE[ndptecgdiplus](~/includes/ndptecgdiplus-md.md)]. Use <xref:System.Windows.Forms.Application.SetCompatibleTextRenderingDefault%2A> para definir o valor padrão de `UseCompatibleTextRendering` propriedade para controles que dão suporte a ele.  
  
 O `UseCompatibleTextRendering` propriedade destina-se a fornecer compatibilidade entre os controles de formulários do Windows com o visual esse texto de renderização usando o <xref:System.Windows.Forms.TextRenderer> classe e [!INCLUDE[net_v10_short](~/includes/net-v10-short-md.md)] e [!INCLUDE[net_v11_short](~/includes/net-v11-short-md.md)] aplicativos que realizam a renderização de texto personalizado usando o <xref:System.Drawing.Graphics>classe. Na maioria dos casos, se seu aplicativo não está sendo atualizado do [!INCLUDE[net_v10_short](~/includes/net-v10-short-md.md)] ou [!INCLUDE[net_v11_short](~/includes/net-v11-short-md.md)], é recomendável que você deixe `UseCompatibleTextRendering` definido como o valor padrão de `false`.  
  
 O [!INCLUDE[ndptecgdi](~/includes/ndptecgdi-md.md)] com base <xref:System.Windows.Forms.TextRenderer> classe foi introduzida no [!INCLUDE[dnprdnlong](~/includes/dnprdnlong-md.md)] para melhorar o desempenho, tornar o texto uma aparência melhor e melhorar o suporte a fontes internacionais. Em versões anteriores dos [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)], o [!INCLUDE[ndptecgdiplus](~/includes/ndptecgdiplus-md.md)] com base em <xref:System.Drawing.Graphics> classe foi usada para executar toda a renderização de texto. [!INCLUDE[ndptecgdi](~/includes/ndptecgdi-md.md)] calcula o espaçamento entre caracteres e quebra automática de maneira diferente de [!INCLUDE[ndptecgdiplus](~/includes/ndptecgdiplus-md.md)]. Em um aplicativo de formulários do Windows que usa o <xref:System.Drawing.Graphics> da classe para renderizar o texto, isso poderia fazer com que o texto para controles que usam <xref:System.Windows.Forms.TextRenderer> aparecer diferente do texto no aplicativo. Para resolver essa incompatibilidade, você pode definir as `UseCompatibleTextRendering` propriedade para `true`. Para definir `UseCompatibleTextRendering` à `true` para todos os controles com suporte no aplicativo, chame o <xref:System.Windows.Forms.Application.SetCompatibleTextRenderingDefault%2A> método com um parâmetro de `true`.  
  
 Você nunca deve chamar esse método se seu código Windows Forms estiver hospedado em outro aplicativo, como o Internet Explorer. Só chame esse método em aplicativos de formulários do Windows autônomos.  
  
   
  
## Examples  
  
> [!IMPORTANT]
>  Para definir o valor padrão para `UseCompatibleTextRendering` na [!INCLUDE[vbprvblong](~/includes/vbprvblong-md.md)] ou posterior, consulte <xref:Microsoft.VisualBasic.ApplicationServices.WindowsFormsApplicationBase.UseCompatibleTextRendering%2A?displayProperty=nameWithType>.  
  
 Na [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)] ou posterior, uma chamada para <xref:System.Windows.Forms.Application.SetCompatibleTextRenderingDefault%2A> é gerado automaticamente no arquivo Program.cs. Para alterar o padrão de renderização de texto, modifique o código gerado.  
  
```scr  
static class Program  
{  
    /// <summary>  
    /// The main entry point for the application.  
    /// </summary>  
    [STAThread]  
    static void Main()  
    {  
        Application.EnableVisualStyles();  
        Application.SetCompatibleTextRenderingDefault(false);  
        Application.Run(new Form1());  
    }  
}  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">You can only call this method before the first window is created by your Windows Forms application.</exception>
        <altmember cref="P:System.Windows.Forms.ButtonBase.UseCompatibleTextRendering" />
        <altmember cref="P:System.Windows.Forms.CheckedListBox.UseCompatibleTextRendering" />
        <altmember cref="P:System.Windows.Forms.GroupBox.UseCompatibleTextRendering" />
        <altmember cref="P:System.Windows.Forms.Label.UseCompatibleTextRendering" />
        <altmember cref="P:System.Windows.Forms.LinkLabel.UseCompatibleTextRendering" />
        <altmember cref="P:System.Windows.Forms.PropertyGrid.UseCompatibleTextRendering" />
        <altmember cref="P:Microsoft.VisualBasic.ApplicationServices.WindowsFormsApplicationBase.UseCompatibleTextRendering" />
        <altmember cref="M:System.Drawing.Text.PrivateFontCollection.AddMemoryFont(System.IntPtr,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="SetSuspendState">
      <MemberSignature Language="C#" Value="public static bool SetSuspendState (System.Windows.Forms.PowerState state, bool force, bool disableWakeEvent);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool SetSuspendState(valuetype System.Windows.Forms.PowerState state, bool force, bool disableWakeEvent) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.SetSuspendState(System.Windows.Forms.PowerState,System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SetSuspendState (state As PowerState, force As Boolean, disableWakeEvent As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool SetSuspendState(System::Windows::Forms::PowerState state, bool force, bool disableWakeEvent);" />
      <MemberSignature Language="F#" Value="static member SetSuspendState : System.Windows.Forms.PowerState * bool * bool -&gt; bool" Usage="System.Windows.Forms.Application.SetSuspendState (state, force, disableWakeEvent)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="state" Type="System.Windows.Forms.PowerState" />
        <Parameter Name="force" Type="System.Boolean" />
        <Parameter Name="disableWakeEvent" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="state">A <see cref="T:System.Windows.Forms.PowerState" /> indicating the power activity mode to which to transition.</param>
        <param name="force">
          <see langword="true" /> to force the suspended mode immediately; <see langword="false" /> to cause Windows to send a suspend request to every application.</param>
        <param name="disableWakeEvent">
          <see langword="true" /> to disable restoring the system's power status to active on a wake event, <see langword="false" /> to enable restoring the system's power status to active on a wake event.</param>
        <summary>Suspends or hibernates the system, or requests that the system be suspended or hibernated.</summary>
        <returns>
          <see langword="true" /> if the system is being suspended, otherwise, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se um aplicativo não responder a uma solicitação de suspensão em até 20 segundos, o Windows determina que ele está em um estado não responsivo e que o aplicativo pode ser colocado para dormir ou encerrado. Depois que um aplicativo responde a uma solicitação de suspensão, no entanto, pode levar qualquer tempo que ele precisa limpar os recursos e encerrar processos ativos.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Forms.PowerState" />
      </Docs>
    </Member>
    <MemberGroup MemberName="SetUnhandledExceptionMode">
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Instructs the application how to respond to unhandled exceptions.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O exemplo de código a seguir define manipuladores de eventos para exceções que ocorrem em threads do Windows Forms e as exceções que ocorrem em outros threads. Ele define <xref:System.Windows.Forms.Application.SetUnhandledExceptionMode%2A> para que todas as exceções sejam tratadas pelo aplicativo, independentemente das configurações no arquivo de configuração do usuário do aplicativo. Ele usa o <xref:System.Windows.Forms.Application.ThreadException> eventos para lidar com exceções de thread de interface do usuário e o <xref:System.AppDomain.UnhandledException> eventos para lidar com exceções de thread sem interface do usuário. Uma vez que <xref:System.AppDomain.UnhandledException> não é possível impedir que um aplicativo seja encerrado, o exemplo simplesmente registra o erro no log de eventos do aplicativo antes do encerramento.  
  
 Este exemplo pressupõe que você definiu duas <xref:System.Windows.Forms.Button> controles `button1` e `button2`, na sua <xref:System.Windows.Forms.Form> classe.  
  
 [!code-cpp[Classic Application.ThreadException Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Application.ThreadException Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Application.ThreadException Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Application.ThreadException Example/CS/source.cs#1)]
 [!code-vb[Classic Application.ThreadException Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Application.ThreadException Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="SetUnhandledExceptionMode">
      <MemberSignature Language="C#" Value="public static void SetUnhandledExceptionMode (System.Windows.Forms.UnhandledExceptionMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetUnhandledExceptionMode(valuetype System.Windows.Forms.UnhandledExceptionMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.SetUnhandledExceptionMode(System.Windows.Forms.UnhandledExceptionMode)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetUnhandledExceptionMode (mode As UnhandledExceptionMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetUnhandledExceptionMode(System::Windows::Forms::UnhandledExceptionMode mode);" />
      <MemberSignature Language="F#" Value="static member SetUnhandledExceptionMode : System.Windows.Forms.UnhandledExceptionMode -&gt; unit" Usage="System.Windows.Forms.Application.SetUnhandledExceptionMode mode" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="mode" Type="System.Windows.Forms.UnhandledExceptionMode" />
      </Parameters>
      <Docs>
        <param name="mode">An <see cref="T:System.Windows.Forms.UnhandledExceptionMode" /> value describing how the application should behave if an exception is thrown without being caught.</param>
        <summary>Instructs the application how to respond to unhandled exceptions.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nem sempre é viável para capturar todas as exceções lançadas pelo Windows Forms. Usando esse método, você pode instruir o seu aplicativo se deve capturar exceções sem tratamento geradas por componentes do Windows Forms e continuar a operar, ou se ele deverá expô-los para o usuário e interromper a execução.  
  
 Chame <xref:System.Windows.Forms.Application.SetUnhandledExceptionMode%2A> antes de criar uma instância do formulário principal do seu aplicativo usando o <xref:System.Windows.Forms.Application.Run%2A> método.  
  
 Para capturar exceções que ocorrem em threads não criados e pertencentes a formulários do Windows, use o <xref:System.AppDomain.UnhandledException> manipulador de eventos.  
  
   
  
## Examples  
 O exemplo de código a seguir define manipuladores de eventos para exceções que ocorrem em threads do Windows Forms e as exceções que ocorrem em outros threads. Ele define <xref:System.Windows.Forms.Application.SetUnhandledExceptionMode%2A> para que todas as exceções sejam tratadas pelo aplicativo, independentemente das configurações no arquivo de configuração do usuário do aplicativo. Ele usa o <xref:System.Windows.Forms.Application.ThreadException> eventos para lidar com exceções de thread de interface do usuário e o <xref:System.AppDomain.UnhandledException> eventos para lidar com exceções de thread sem interface do usuário. Uma vez que <xref:System.AppDomain.UnhandledException> não é possível impedir que um aplicativo seja encerrado, o exemplo simplesmente registra o erro no log de eventos do aplicativo antes do encerramento.  
  
 Este exemplo pressupõe que você definiu duas <xref:System.Windows.Forms.Button> controles `button1` e `button2`, na sua <xref:System.Windows.Forms.Form> classe.  
  
 [!code-cpp[Classic Application.ThreadException Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Application.ThreadException Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Application.ThreadException Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Application.ThreadException Example/CS/source.cs#1)]
 [!code-vb[Classic Application.ThreadException Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Application.ThreadException Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">You cannot set the exception mode after the application has created its first window.</exception>
        <altmember cref="T:System.Windows.Forms.UnhandledExceptionMode" />
      </Docs>
    </Member>
    <Member MemberName="SetUnhandledExceptionMode">
      <MemberSignature Language="C#" Value="public static void SetUnhandledExceptionMode (System.Windows.Forms.UnhandledExceptionMode mode, bool threadScope);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetUnhandledExceptionMode(valuetype System.Windows.Forms.UnhandledExceptionMode mode, bool threadScope) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.SetUnhandledExceptionMode(System.Windows.Forms.UnhandledExceptionMode,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetUnhandledExceptionMode (mode As UnhandledExceptionMode, threadScope As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetUnhandledExceptionMode(System::Windows::Forms::UnhandledExceptionMode mode, bool threadScope);" />
      <MemberSignature Language="F#" Value="static member SetUnhandledExceptionMode : System.Windows.Forms.UnhandledExceptionMode * bool -&gt; unit" Usage="System.Windows.Forms.Application.SetUnhandledExceptionMode (mode, threadScope)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="mode" Type="System.Windows.Forms.UnhandledExceptionMode" />
        <Parameter Name="threadScope" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="mode">An <see cref="T:System.Windows.Forms.UnhandledExceptionMode" /> value describing how the application should behave if an exception is thrown without being caught.</param>
        <param name="threadScope">
          <see langword="true" /> to set the thread exception mode; otherwise, <see langword="false" />.</param>
        <summary>Instructs the application how to respond to unhandled exceptions, optionally applying thread-specific behavior.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nem sempre é viável para capturar todas as exceções lançadas pelo Windows Forms. Usando esse método, você pode instruir o seu aplicativo se deve capturar exceções sem tratamento geradas por componentes do Windows Forms e continuar a operar, ou se ele deverá expô-los para o usuário e interromper a execução.  
  
 Chame <xref:System.Windows.Forms.Application.SetUnhandledExceptionMode%2A> antes de criar uma instância do formulário principal do seu aplicativo usando o <xref:System.Windows.Forms.Application.Run%2A> método.  
  
 Quando `threadScope` é `true`, o modo de exceção de thread é definido. O modo de exceção do thread substitui o modo de exceção de aplicativo se `mode` não está definido como <xref:System.Windows.Forms.UnhandledExceptionMode.Automatic>.  
  
 Quando `threadScope` é `false`, o modo de exceção do aplicativo está definido. O modo de exceção de aplicativo é usado para todos os threads que têm o <xref:System.Windows.Forms.UnhandledExceptionMode.Automatic> modo. Definindo o modo de exceção de aplicativo não afeta a configuração do thread atual.  
  
 Para capturar exceções que ocorrem em threads não criados e pertencentes a formulários do Windows, use o <xref:System.AppDomain.UnhandledException> manipulador de eventos.  
  
   
  
## Examples  
 O exemplo de código a seguir define manipuladores de eventos para exceções que ocorrem em threads do Windows Forms e as exceções que ocorrem em outros threads. Ele define <xref:System.Windows.Forms.Application.SetUnhandledExceptionMode%2A> para que todas as exceções sejam tratadas pelo aplicativo, independentemente das configurações no arquivo de configuração do usuário do aplicativo. Ele usa o <xref:System.Windows.Forms.Application.ThreadException> eventos para lidar com exceções de thread de interface do usuário e o <xref:System.AppDomain.UnhandledException> eventos para lidar com exceções de thread sem interface do usuário. Uma vez que <xref:System.AppDomain.UnhandledException> não é possível impedir que um aplicativo seja encerrado, o exemplo simplesmente registra o erro no log de eventos do aplicativo antes do encerramento.  
  
 Este exemplo pressupõe que você definiu duas <xref:System.Windows.Forms.Button> controles `button1` e `button2`, na sua <xref:System.Windows.Forms.Form> classe.  
  
 [!code-cpp[Classic Application.ThreadException Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Application.ThreadException Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Application.ThreadException Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Application.ThreadException Example/CS/source.cs#1)]
 [!code-vb[Classic Application.ThreadException Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Application.ThreadException Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">You cannot set the exception mode after the application has created its first window.</exception>
      </Docs>
    </Member>
    <Member MemberName="StartupPath">
      <MemberSignature Language="C#" Value="public static string StartupPath { get; }" />
      <MemberSignature Language="ILAsm" Value=".property string StartupPath" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.StartupPath" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property StartupPath As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::String ^ StartupPath { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.StartupPath : string" Usage="System.Windows.Forms.Application.StartupPath" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the path for the executable file that started the application, not including the executable name.</summary>
        <value>O caminho para o arquivo executável que iniciou o aplicativo.  Esse caminho será diferente dependendo se o aplicativo de formulários do Windows é implantado usando o [! INCLUDE[ndptecclick](~/Includes/ndptecclick-MD.MD)]. [! Aplicativos de include[ndptecclick](~/Includes/ndptecclick-MD.MD)] são armazenados em um cache de aplicativo por usuário no C:\Documents and Settings\\* * nome de usuário de diretório. Para obter mais informações, consulte [acessando dados locais e remotos em aplicativos ClickOnce] (http://msdn.microsoft.com/library/be5cbe12-6cb6-49c9-aa59-a1624e1eef3d).</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O exemplo de código a seguir obtém essa propriedade e exibe seu valor em uma caixa de texto. O exemplo requer que `textBox1` foi colocado em um formulário.  
  
 [!code-cpp[Classic Application.StartupPath Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Application.StartupPath Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Application.StartupPath Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Application.StartupPath Example/CS/source.cs#1)]
 [!code-vb[Classic Application.StartupPath Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Application.StartupPath Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Para obter o caminho. Enumeração associada: <see cref="T:System.Security.Permissions.FileIOPermissionAccess" /></permission>
      </Docs>
    </Member>
    <Member MemberName="ThreadException">
      <MemberSignature Language="C#" Value="public static event System.Threading.ThreadExceptionEventHandler ThreadException;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Threading.ThreadExceptionEventHandler ThreadException" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Application.ThreadException" />
      <MemberSignature Language="VB.NET" Value="Public Shared Custom Event ThreadException As ThreadExceptionEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static event System::Threading::ThreadExceptionEventHandler ^ ThreadException;" />
      <MemberSignature Language="F#" Value="member this.ThreadException : System.Threading.ThreadExceptionEventHandler " Usage="member this.ThreadException : System.Threading.ThreadExceptionEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.ThreadExceptionEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Occurs when an untrapped thread exception is thrown.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este evento permite que seu aplicativo do Windows Forms para exceções de qualquer outro identificador sem tratamento que ocorrem em threads do Windows Forms. Anexe seus manipuladores de eventos para o <xref:System.Windows.Forms.Application.ThreadException> evento para lidar com essas exceções, o que deixará seu aplicativo em um estado desconhecido. Sempre que possível, as exceções devem ser manipuladas por uma bloco de tratamento de exceções estruturado.  
  
 Você pode alterar se esse retorno de chamada é usado para exceções sem tratamento de segmento de Windows Forms, definindo <xref:System.Windows.Forms.Application.SetUnhandledExceptionMode%2A>. Para capturar exceções que ocorrem em threads não criados e pertencentes a formulários do Windows, use o <xref:System.AppDomain.UnhandledException> manipulador de eventos.  
  
> [!NOTE]
>  Para garantir que nenhum ativações desse evento seja perdidas, você deve anexar um manipulador antes de chamar <xref:System.Windows.Application.Run%2A?displayProperty=nameWithType>.  
  
> [!CAUTION]
>  Como esse é um evento estático, você deve desanexar seus manipuladores de eventos quando seu aplicativo é descartado ou o resultado serão vazamentos de memória.  
  
   
  
## Examples  
 O exemplo de código a seguir define manipuladores de eventos para exceções que ocorrem em threads do Windows Forms e as exceções que ocorrem em outros threads. Ele define <xref:System.Windows.Forms.Application.SetUnhandledExceptionMode%2A> para que todas as exceções sejam tratadas pelo aplicativo, independentemente das configurações no arquivo de configuração do usuário do aplicativo. Ele usa o <xref:System.Windows.Forms.Application.ThreadException> eventos para lidar com exceções de thread de interface do usuário e o <xref:System.AppDomain.UnhandledException> eventos para lidar com exceções de thread sem interface do usuário. Uma vez que <xref:System.AppDomain.UnhandledException> não é possível impedir que um aplicativo seja encerrado, o exemplo simplesmente registra o erro no log de eventos do aplicativo antes do encerramento.  
  
 Este exemplo pressupõe que você definiu duas <xref:System.Windows.Forms.Button> controles `button1` e `button2`, na sua <xref:System.Windows.Forms.Form> classe.  
  
 [!code-cpp[Classic Application.ThreadException Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Application.ThreadException Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Application.ThreadException Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Application.ThreadException Example/CS/source.cs#1)]
 [!code-vb[Classic Application.ThreadException Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Application.ThreadException Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">para o chamador imediato chamar código não gerenciado ao adicionar um manipulador para este evento. Enumeração associada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
    <Member MemberName="ThreadExit">
      <MemberSignature Language="C#" Value="public static event EventHandler ThreadExit;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler ThreadExit" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Application.ThreadExit" />
      <MemberSignature Language="VB.NET" Value="Public Shared Custom Event ThreadExit As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static event EventHandler ^ ThreadExit;" />
      <MemberSignature Language="F#" Value="member this.ThreadExit : EventHandler " Usage="member this.ThreadExit : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Occurs when a thread is about to shut down. When the main thread for an application is about to be shut down, this event is raised first, followed by an <see cref="E:System.Windows.Forms.Application.ApplicationExit" /> event.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Você deve anexar os manipuladores de eventos para o <xref:System.Windows.Forms.Application.ThreadExit> evento para realizar qualquer sem tratamento, tarefas necessárias antes do thread será interrompido. Fechar arquivos abertos por esse thread ou descarte de objetos que o coletor de lixo não recuperou.  
  
> [!CAUTION]
>  Como esse é um evento estático, você deve desanexar seus manipuladores de eventos quando seu aplicativo é descartado ou o resultado serão vazamentos de memória.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra o uso desse membro. No exemplo, um manipulador de eventos relata a ocorrência da <xref:System.Windows.Forms.Application.ThreadExit> eventos. Este relatório ajuda você a saber quando o evento ocorre e pode ajudar na depuração. Para relatar em vários eventos ou em eventos que ocorrem com frequência, considere substituir <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> com <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> ou acrescentar a mensagem como um multiline <xref:System.Windows.Forms.TextBox>.  
  
 Para executar o exemplo de código, cole-o em um Windows Forms e certifique-se de que o manipulador de eventos está associado com o <xref:System.Windows.Forms.Application.ThreadExit> eventos.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#6](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#6)]
 [!code-vb[System.Windows.Forms.EventExamples#6](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#6)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Application.ExitThread" />
      </Docs>
    </Member>
    <Member MemberName="UnregisterMessageLoop">
      <MemberSignature Language="C#" Value="public static void UnregisterMessageLoop ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void UnregisterMessageLoop() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.UnregisterMessageLoop" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub UnregisterMessageLoop ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void UnregisterMessageLoop();" />
      <MemberSignature Language="F#" Value="static member UnregisterMessageLoop : unit -&gt; unit" Usage="System.Windows.Forms.Application.UnregisterMessageLoop " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Unregisters the message loop callback made with <see cref="M:System.Windows.Forms.Application.RegisterMessageLoop(System.Windows.Forms.Application.MessageLoopCallback)" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="UserAppDataPath">
      <MemberSignature Language="C#" Value="public static string UserAppDataPath { get; }" />
      <MemberSignature Language="ILAsm" Value=".property string UserAppDataPath" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.UserAppDataPath" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property UserAppDataPath As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::String ^ UserAppDataPath { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.UserAppDataPath : string" Usage="System.Windows.Forms.Application.UserAppDataPath" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the path for the application data of a user.</summary>
        <value>O caminho para os dados de aplicativo de um usuário.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se um caminho não existir, um será criado no seguinte formato:  
  
 *Caminho base*\\<xref:System.Windows.Forms.Application.CompanyName%2A>\\<xref:System.Windows.Forms.Application.ProductName%2A>\\<xref:System.Windows.Forms.Application.ProductVersion%2A>  
  
 Dados armazenados nesse caminho são parte do perfil de usuário que está habilitado para roaming. Um usuário móvel funciona em mais de um computador em uma rede. O perfil do usuário para um usuário móvel é mantido em um servidor na rede e é carregado em um sistema quando o usuário fizer logon. Perfil do usuário a ser considerado para roaming, o sistema operacional deve dar suporte a perfis móveis e ele deve ser habilitado.  
  
 Um caminho base típico é C:\Documents and Settings\\*nome de usuário*\Application Data. Esse caminho será diferente, no entanto, se o aplicativo de formulários do Windows é implantado usando [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)]. [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)] cria seu próprio diretório de dados de aplicativo que é isolado de todos os outros aplicativos. Para obter mais informações, confira [Acessando dados locais e remotos em aplicativos ClickOnce](http://msdn.microsoft.com/library/be5cbe12-6cb6-49c9-aa59-a1624e1eef3d).  
  
   
  
## Examples  
 O exemplo de código a seguir exibe duas formas e sai do aplicativo quando ambas as formas são fechadas. Quando o aplicativo é iniciado e é encerrado, a posição de cada formulário será lembrada. Este exemplo demonstra como usar o <xref:System.Windows.Forms.Application.UserAppDataPath%2A> propriedade para armazenar dados de aplicativo para o usuário.  
  
 A classe `MyApplicationContext` herda de <xref:System.Windows.Forms.ApplicationContext> e mantém o controle quando cada formulário é fechado e sai do thread atual quando ambos estiverem. A classe armazena as posições de cada formulário do usuário. Os dados de posição do formulário são armazenados em um arquivo intitulado `Appdata.txt` que é criado no local determinado pelo <xref:System.Windows.Forms.Application.UserAppDataPath%2A>. O `Main` chamadas de método `Application.Run(context)` para iniciar o aplicativo, dado o <xref:System.Windows.Forms.ApplicationContext>.  
  
 Esse código é um trecho do exemplo mostrado o <xref:System.Windows.Forms.ApplicationContext> visão geral da classe. Algum código não é mostrado para fins de brevidade. Consulte <xref:System.Windows.Forms.ApplicationContext> para a listagem de código inteiro.  
  
 [!code-cpp[Application#5](~/samples/snippets/cpp/VS_Snippets_Winforms/Application/CPP/source.cpp#5)]
 [!code-csharp[Application#5](~/samples/snippets/csharp/VS_Snippets_Winforms/Application/CS/source.cs#5)]
 [!code-vb[Application#5](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Application/VB/source.vb#5)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Application.UserAppDataRegistry" />
      </Docs>
    </Member>
    <Member MemberName="UserAppDataRegistry">
      <MemberSignature Language="C#" Value="public static Microsoft.Win32.RegistryKey UserAppDataRegistry { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class Microsoft.Win32.RegistryKey UserAppDataRegistry" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.UserAppDataRegistry" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property UserAppDataRegistry As RegistryKey" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property Microsoft::Win32::RegistryKey ^ UserAppDataRegistry { Microsoft::Win32::RegistryKey ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.UserAppDataRegistry : Microsoft.Win32.RegistryKey" Usage="System.Windows.Forms.Application.UserAppDataRegistry" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.RegistryKey</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the registry key for the application data of a user.</summary>
        <value>Um <see cref="T:Microsoft.Win32.RegistryKey" /> que representa a chave do Registro dos dados de aplicativo específicos para o usuário.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se a chave não existir, ele é criado no seguinte formato:  
  
 CurrentUser\Software\\<xref:System.Windows.Forms.Application.CompanyName%2A>\\<xref:System.Windows.Forms.Application.ProductName%2A>\\<xref:System.Windows.Forms.Application.ProductVersion%2A>   
  
 Dados armazenados nesta chave faz parte do perfil de usuário que está habilitado para roaming. Um usuário móvel funciona em mais de um computador em uma rede. O perfil do usuário para um usuário móvel é mantido em um servidor na rede e é carregado em um sistema quando o usuário fizer logon. Perfil do usuário a ser considerado para roaming, o sistema operacional deve dar suporte a perfis móveis e ele deve ser habilitado.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Forms.SystemInformation" />
      </Docs>
    </Member>
    <Member MemberName="UseWaitCursor">
      <MemberSignature Language="C#" Value="public static bool UseWaitCursor { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property bool UseWaitCursor" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.UseWaitCursor" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property UseWaitCursor As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool UseWaitCursor { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.UseWaitCursor : bool with get, set" Usage="System.Windows.Forms.Application.UseWaitCursor" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets whether the wait cursor is used for all open forms of the application.</summary>
        <value>
          <see langword="true" /> é o cursor de espera usado para todos os formulários abertos; caso contrário, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando essa propriedade é definida como `true`, o <xref:System.Windows.Forms.Control.UseWaitCursor%2A> definirá a propriedade de todos os formulários abertos no aplicativo `true`. Essa chamada não retornará até que essa propriedade foi definida em todos os formulários. Use essa propriedade quando você tiver uma operação de longa execução e para indicar em todos os formulários de aplicativo que a operação ainda está processando.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VisualStyleState">
      <MemberSignature Language="C#" Value="public static System.Windows.Forms.VisualStyles.VisualStyleState VisualStyleState { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property valuetype System.Windows.Forms.VisualStyles.VisualStyleState VisualStyleState" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.VisualStyleState" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property VisualStyleState As VisualStyleState" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Forms::VisualStyles::VisualStyleState VisualStyleState { System::Windows::Forms::VisualStyles::VisualStyleState get(); void set(System::Windows::Forms::VisualStyles::VisualStyleState value); };" />
      <MemberSignature Language="F#" Value="member this.VisualStyleState : System.Windows.Forms.VisualStyles.VisualStyleState with get, set" Usage="System.Windows.Forms.Application.VisualStyleState" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.VisualStyles.VisualStyleState</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets a value that specifies how visual styles are applied to application windows.</summary>
        <value>Uma combinação bit a bit dos valores <see cref="T:System.Windows.Forms.VisualStyles.VisualStyleState" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Isso <xref:System.Windows.Forms.Application.VisualStyleState%2A> propriedade determina se os estilos visuais estão habilitados em áreas de cliente ou áreas não cliente das janelas do aplicativo. Em geral, essa propriedade deve ser definida dentro do construtor do formulário principal ou <xref:System.Windows.Forms.Form.Load> manipulador de eventos.  
  
   
  
## Examples  
 O seguinte exemplo de código define a <xref:System.Windows.Forms.Application.VisualStyleState%2A> propriedade para um dos <xref:System.Windows.Forms.VisualStyles.VisualStyleState?displayProperty=nameWithType> valores dentro a <xref:System.Windows.Forms.Control.Click> manipulador de eventos para um <xref:System.Windows.Forms.Button> controle. Este exemplo de código é parte de um exemplo maior fornecido para o <xref:System.Windows.Forms.VisualStyles.VisualStyleState?displayProperty=nameWithType> enumeração.  
  
 [!code-cpp[System.Windows.Forms.VisualStyles.VisualStyleState#10](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.VisualStyles.VisualStyleState/cpp/visualstylestate.cpp#10)]
 [!code-csharp[System.Windows.Forms.VisualStyles.VisualStyleState#10](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.VisualStyles.VisualStyleState/CS/visualstylestate.cs#10)]
 [!code-vb[System.Windows.Forms.VisualStyles.VisualStyleState#10](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.VisualStyles.VisualStyleState/VB/visualstylestate.vb#10)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>