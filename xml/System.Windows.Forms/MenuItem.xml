<Type Name="MenuItem" FullName="System.Windows.Forms.MenuItem">
  <Metadata><Meta Name="ms.openlocfilehash" Value="8e96b9a562587ce1b84c0314819619ffe1f760d2" /><Meta Name="ms.sourcegitcommit" Value="756d085f27705e86604f1bba5f2086ee23761acf" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="pt-BR" /><Meta Name="ms.lasthandoff" Value="01/30/2019" /><Meta Name="ms.locfileid" Value="55340279" /></Metadata><TypeSignature Language="C#" Value="public class MenuItem : System.Windows.Forms.Menu" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit MenuItem extends System.Windows.Forms.Menu" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Forms.MenuItem" />
  <TypeSignature Language="VB.NET" Value="Public Class MenuItem&#xA;Inherits Menu" />
  <TypeSignature Language="C++ CLI" Value="public ref class MenuItem : System::Windows::Forms::Menu" />
  <TypeSignature Language="F#" Value="type MenuItem = class&#xA;    inherit Menu" />
  <AssemblyInfo>
    <AssemblyName>System.Windows.Forms</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Windows.Forms.Menu</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.ComponentModel.DefaultEvent("Click")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.ComponentModel.DefaultProperty("Text")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.ComponentModel.DesignTimeVisible(false)</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.ComponentModel.ToolboxItem(false)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Representa um item individual que é exibido dentro de um <see cref="T:System.Windows.Forms.MainMenu" /> ou <see cref="T:System.Windows.Forms.ContextMenu" />. Embora <see cref="T:System.Windows.Forms.ToolStripMenuItem" /> substitua e adicione funcionalidade ao controle <see cref="T:System.Windows.Forms.MenuItem" /> de versões anteriores, <see cref="T:System.Windows.Forms.MenuItem" /> é mantido para compatibilidade com versões anteriores e uso futuro, se desejado.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para que um <xref:System.Windows.Forms.MenuItem> para serem exibidos, você deve adicioná-lo para um <xref:System.Windows.Forms.MainMenu> ou <xref:System.Windows.Forms.ContextMenu>. Para criar submenus, você pode adicionar <xref:System.Windows.Forms.MenuItem> objetos para o <xref:System.Windows.Forms.Menu.MenuItems%2A> propriedade do pai <xref:System.Windows.Forms.MenuItem>.  
  
 O <xref:System.Windows.Forms.MenuItem> classe fornece propriedades que permitem que você configure a aparência e funcionalidade de um item de menu. Para exibir uma marca de seleção ao lado de um item de menu, use o <xref:System.Windows.Forms.MenuItem.Checked%2A> propriedade. Você pode usar esse recurso para identificar um item de menu é selecionado em uma lista de itens de menu mutuamente exclusivos. Por exemplo, se você tiver um conjunto de itens de menu para definir a cor do texto em uma <xref:System.Windows.Forms.TextBox> controle, você pode usar o <xref:System.Windows.Forms.MenuItem.Checked%2A> propriedade para identificar qual cor está selecionado no momento. O <xref:System.Windows.Forms.MenuItem.Shortcut%2A> propriedade pode ser usada para definir uma combinação de teclado que pode ser pressionada para selecionar o item de menu.  
  
 Para <xref:System.Windows.Forms.MenuItem> objetos exibidos em um aplicativo de Interface de documentos múltiplos (MDI), você pode usar o <xref:System.Windows.Forms.MenuItem.MergeMenu%2A> método para mesclar os menus de um MDI pai para por um de seus formulários filho para criar uma estrutura de menu consolidado. Porque uma <xref:System.Windows.Forms.MenuItem> não pode ser reutilizado em vários locais ao mesmo tempo, como em um <xref:System.Windows.Forms.MainMenu> e uma <xref:System.Windows.Forms.ContextMenu>, você pode usar o <xref:System.Windows.Forms.MenuItem.CloneMenu%2A> método para criar uma cópia de um <xref:System.Windows.Forms.MenuItem> para uso em outro local.  
  
 O <xref:System.Windows.Forms.MenuItem.Popup> evento permite que você execute tarefas antes de um menu é exibido. Por exemplo, você pode criar um manipulador de eventos para esse evento exibir ou ocultar itens de menu com base no estado do seu código. O <xref:System.Windows.Forms.MenuItem.Select> evento permite que você execute tarefas como fornecer ajuda detalhada para itens de menu do seu aplicativo quando o usuário coloca o ponteiro do mouse sobre um item de menu.  
  
   
  
## Examples  
 O exemplo de código a seguir cria uma estrutura de menu para um formulário. O exemplo de código adiciona um <xref:System.Windows.Forms.MenuItem> para representar o item de menu de nível superior, adiciona um item de submenu para selecionar um tamanho de fonte e, em seguida, adiciona dois itens de submenu para esse item de menu que representam as opções de fonte pequeno e grande em um aplicativo. O exemplo requer que haja uma <xref:System.Windows.Forms.MainMenu> objeto nomeado `mainMenu1` e quatro <xref:System.Windows.Forms.MenuItem> objetos nomeados `menuItem1`, `menuItem2`, `menuItem3`, e `menuItem4`.  
  
 [!code-cpp[Classic Menu Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Menu Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Menu Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Menu Example/CS/source.cs#1)]
 [!code-vb[Classic Menu Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Menu Example/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Windows.Forms.MainMenu" />
    <altmember cref="T:System.Windows.Forms.Menu" />
    <altmember cref="T:System.Windows.Forms.MenuMerge" />
    <altmember cref="T:System.Windows.Forms.ContextMenu" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicializa uma nova instância da classe <see cref="T:System.Windows.Forms.MenuItem" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public MenuItem ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.MenuItem.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; MenuItem();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>Inicializa um <see cref="T:System.Windows.Forms.MenuItem" /> com uma legenda em branco.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Depois de criar um espaço em branco <xref:System.Windows.Forms.MenuItem> usar esse construtor, você pode usar as propriedades e métodos do <xref:System.Windows.Forms.MenuItem> classe para especificar a aparência e comportamento do seu <xref:System.Windows.Forms.MenuItem>.  
  
   
  
## Examples  
 O exemplo de código a seguir cria um <xref:System.Windows.Forms.MenuItem> usando esta versão do construtor.  
  
 [!code-cpp[Classic MenuItem.MenuItem Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic MenuItem.MenuItem Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MenuItem.MenuItem Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic MenuItem.MenuItem Example/CS/source.cs#1)]
 [!code-vb[Classic MenuItem.MenuItem Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic MenuItem.MenuItem Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public MenuItem (string text);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string text) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.MenuItem.#ctor(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (text As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; MenuItem(System::String ^ text);" />
      <MemberSignature Language="F#" Value="new System.Windows.Forms.MenuItem : string -&gt; System.Windows.Forms.MenuItem" Usage="new System.Windows.Forms.MenuItem text" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="text" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="text">A legenda do item de menu.</param>
        <summary>Inicializa uma nova instância da classe <see cref="T:System.Windows.Forms.MenuItem" /> com uma legenda especificada para o item de menu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando você especificar uma legenda para o item de menu com o `text` parâmetro, você também pode especificar uma chave de acesso, colocando um caractere '&' antes do caractere a ser usado como a chave de acesso. Por exemplo, para especificar o "F" em "Arquivo" como uma chave de acesso, você deve especificar a legenda do item de menu como "& arquivo". Você pode usar esse recurso para fornecer uma navegação de teclado para seus menus.  
  
 Definindo o `text` parâmetro para "`-`" faz com que o item de menu a ser exibido como um separador (uma linha horizontal) em vez de um item de menu padrão.  
  
   
  
## Examples  
 O exemplo de código a seguir cria um <xref:System.Windows.Forms.MenuItem> que especifica a legenda do item de menu no momento em que ele é construído.  
  
 [!code-cpp[Classic MenuItem.MenuItem1 Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic MenuItem.MenuItem1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MenuItem.MenuItem1 Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic MenuItem.MenuItem1 Example/CS/source.cs#1)]
 [!code-vb[Classic MenuItem.MenuItem1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic MenuItem.MenuItem1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public MenuItem (string text, EventHandler onClick);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string text, class System.EventHandler onClick) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.MenuItem.#ctor(System.String,System.EventHandler)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (text As String, onClick As EventHandler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; MenuItem(System::String ^ text, EventHandler ^ onClick);" />
      <MemberSignature Language="F#" Value="new System.Windows.Forms.MenuItem : string * EventHandler -&gt; System.Windows.Forms.MenuItem" Usage="new System.Windows.Forms.MenuItem (text, onClick)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="text" Type="System.String" />
        <Parameter Name="onClick" Type="System.EventHandler" />
      </Parameters>
      <Docs>
        <param name="text">A legenda do item de menu.</param>
        <param name="onClick">O <see cref="T:System.EventHandler" /> que manipula o evento <see cref="E:System.Windows.Forms.MenuItem.Click" /> deste item de menu.</param>
        <summary>Inicializa uma nova instância da classe com uma legenda e um manipulador de eventos especificados para o evento <see cref="E:System.Windows.Forms.MenuItem.Click" /> do item de menu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando você especificar uma legenda para o item de menu com o `text` parâmetro, você também pode especificar uma chave de acesso, colocando um '&' antes do caractere a ser usado como a chave de acesso. Por exemplo, para especificar o "F" em "Arquivo" como uma chave de acesso, você deve especificar a legenda do item de menu como "& arquivo". Você pode usar esse recurso para fornecer uma navegação de teclado para seus menus.  
  
 Definindo o `text` parâmetro para "`-`" faz com que o item de menu a ser exibido como um separador (uma linha horizontal) em vez de um item de menu padrão.  
  
 Além disso, você pode usar esse construtor para especificar um representante que manipulará o <xref:System.Windows.Forms.MenuItem.Click> evento para o item de menu que está sendo criado. O <xref:System.EventHandler> que você passe para esse construtor deve ser configurado para chamar um manipulador de eventos pode manipular o <xref:System.Windows.Forms.MenuItem.Click> eventos. Para obter mais informações sobre o tratamento de eventos, consulte [tratando e gerando eventos](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 O exemplo de código a seguir cria uma <xref:System.Windows.Forms.MenuItem> objeto com uma legenda especificada e uma <xref:System.EventHandler> delegado conectado a um manipulador de eventos que tratará o <xref:System.Windows.Forms.MenuItem.Click> evento para o item de menu.  
  
 [!code-cpp[Classic MenuItem.MenuItem2 Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic MenuItem.MenuItem2 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MenuItem.MenuItem2 Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic MenuItem.MenuItem2 Example/CS/source.cs#1)]
 [!code-vb[Classic MenuItem.MenuItem2 Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic MenuItem.MenuItem2 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public MenuItem (string text, System.Windows.Forms.MenuItem[] items);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string text, class System.Windows.Forms.MenuItem[] items) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.MenuItem.#ctor(System.String,System.Windows.Forms.MenuItem[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (text As String, items As MenuItem())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; MenuItem(System::String ^ text, cli::array &lt;System::Windows::Forms::MenuItem ^&gt; ^ items);" />
      <MemberSignature Language="F#" Value="new System.Windows.Forms.MenuItem : string * System.Windows.Forms.MenuItem[] -&gt; System.Windows.Forms.MenuItem" Usage="new System.Windows.Forms.MenuItem (text, items)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="text" Type="System.String" />
        <Parameter Name="items" Type="System.Windows.Forms.MenuItem[]" />
      </Parameters>
      <Docs>
        <param name="text">A legenda do item de menu.</param>
        <param name="items">Uma matriz de objetos <see cref="T:System.Windows.Forms.MenuItem" /> que contém os itens de submenu desse item de menu.</param>
        <summary>Inicializa uma nova instância da classe com uma legenda especificada e uma matriz de itens de submenu definida para o item de menu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando você especificar uma legenda para o item de menu com o `text` parâmetro, você também pode especificar uma chave de acesso, colocando um '&' antes do caractere a ser usado como a chave de acesso. Por exemplo, para especificar o "F" em "Arquivo" como uma chave de acesso, você deve especificar a legenda do item de menu como "& arquivo". Você pode usar esse recurso para fornecer uma navegação de teclado para seus menus.  
  
 Definindo o `text` parâmetro para "`-`" faz com que o item de menu a ser exibido como um separador (uma linha horizontal) em vez de um item de menu padrão.  
  
 O `items` parâmetro permite que você atribua uma matriz de itens de menu para definir um submenu desse item de menu. Cada item na matriz também pode ter uma matriz de itens de menu atribuído a ele. Isso permite que você crie estruturas de menu completa e atribuí-los para o construtor para o item de menu.  
  
 Para obter mais informações sobre o tratamento de eventos, consulte [tratando e gerando eventos](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 O exemplo de código a seguir cria um objeto com uma legenda especificada, um manipulador de eventos conectado a um método que manipulará o evento de cada item de menu em uma matriz de itens de submenu.  
  
 [!code-cpp[Classic MenuItem.MenuItem4 Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic MenuItem.MenuItem4 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MenuItem.MenuItem4 Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic MenuItem.MenuItem4 Example/CS/source.cs#1)]
 [!code-vb[Classic MenuItem.MenuItem4 Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic MenuItem.MenuItem4 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public MenuItem (string text, EventHandler onClick, System.Windows.Forms.Shortcut shortcut);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string text, class System.EventHandler onClick, valuetype System.Windows.Forms.Shortcut shortcut) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.MenuItem.#ctor(System.String,System.EventHandler,System.Windows.Forms.Shortcut)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; MenuItem(System::String ^ text, EventHandler ^ onClick, System::Windows::Forms::Shortcut shortcut);" />
      <MemberSignature Language="F#" Value="new System.Windows.Forms.MenuItem : string * EventHandler * System.Windows.Forms.Shortcut -&gt; System.Windows.Forms.MenuItem" Usage="new System.Windows.Forms.MenuItem (text, onClick, shortcut)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="text" Type="System.String" />
        <Parameter Name="onClick" Type="System.EventHandler" />
        <Parameter Name="shortcut" Type="System.Windows.Forms.Shortcut" />
      </Parameters>
      <Docs>
        <param name="text">A legenda do item de menu.</param>
        <param name="onClick">O <see cref="T:System.EventHandler" /> que manipula o evento <see cref="E:System.Windows.Forms.MenuItem.Click" /> deste item de menu.</param>
        <param name="shortcut">Um dos valores de <see cref="T:System.Windows.Forms.Shortcut" />.</param>
        <summary>Inicializa uma nova instância da classe com uma legenda, um manipulador de eventos e a tecla de atalho associada especificados para o item de menu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando você especificar uma legenda para o item de menu com o `text` parâmetro, você também pode especificar uma chave de acesso, colocando um '&' antes do caractere a ser usado como a chave de acesso. Por exemplo, para especificar o "F" em "Arquivo" como uma chave de acesso, você deve especificar a legenda do item de menu como "& arquivo". Você pode usar esse recurso para fornecer uma navegação de teclado para seus menus. Este construtor também permite que você especifique uma tecla de atalho, além de uma chave de acesso para fornecer uma navegação de teclado. Teclas de atalho permitem que você especifique uma combinação de teclas que podem ser usados para ativar o item de menu.  
  
 Definindo o `text` parâmetro para "`-`" faz com que o item de menu a ser exibido como um separador (uma linha horizontal) em vez de um item de menu padrão.  
  
 Além disso, você pode usar esse construtor para especificar um representante que manipulará o <xref:System.Windows.Forms.MenuItem.Click> evento para o item de menu que está sendo criado. O <xref:System.EventHandler> que você passe para esse construtor deve ser configurado para chamar um manipulador de eventos pode manipular o <xref:System.Windows.Forms.MenuItem.Click> eventos. Para obter mais informações sobre o tratamento de eventos, consulte [tratando e gerando eventos](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 O exemplo de código a seguir cria um objeto com uma legenda especificada, a tecla de atalho e um manipulador de eventos conectado a um método que manipulará o evento para o item de menu.  
  
 [!code-cpp[Classic MenuItem.MenuItem3 Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic MenuItem.MenuItem3 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MenuItem.MenuItem3 Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic MenuItem.MenuItem3 Example/CS/source.cs#1)]
 [!code-vb[Classic MenuItem.MenuItem3 Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic MenuItem.MenuItem3 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public MenuItem (System.Windows.Forms.MenuMerge mergeType, int mergeOrder, System.Windows.Forms.Shortcut shortcut, string text, EventHandler onClick, EventHandler onPopup, EventHandler onSelect, System.Windows.Forms.MenuItem[] items);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype System.Windows.Forms.MenuMerge mergeType, int32 mergeOrder, valuetype System.Windows.Forms.Shortcut shortcut, string text, class System.EventHandler onClick, class System.EventHandler onPopup, class System.EventHandler onSelect, class System.Windows.Forms.MenuItem[] items) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.MenuItem.#ctor(System.Windows.Forms.MenuMerge,System.Int32,System.Windows.Forms.Shortcut,System.String,System.EventHandler,System.EventHandler,System.EventHandler,System.Windows.Forms.MenuItem[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; MenuItem(System::Windows::Forms::MenuMerge mergeType, int mergeOrder, System::Windows::Forms::Shortcut shortcut, System::String ^ text, EventHandler ^ onClick, EventHandler ^ onPopup, EventHandler ^ onSelect, cli::array &lt;System::Windows::Forms::MenuItem ^&gt; ^ items);" />
      <MemberSignature Language="F#" Value="new System.Windows.Forms.MenuItem : System.Windows.Forms.MenuMerge * int * System.Windows.Forms.Shortcut * string * EventHandler * EventHandler * EventHandler * System.Windows.Forms.MenuItem[] -&gt; System.Windows.Forms.MenuItem" Usage="new System.Windows.Forms.MenuItem (mergeType, mergeOrder, shortcut, text, onClick, onPopup, onSelect, items)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="mergeType" Type="System.Windows.Forms.MenuMerge" />
        <Parameter Name="mergeOrder" Type="System.Int32" />
        <Parameter Name="shortcut" Type="System.Windows.Forms.Shortcut" />
        <Parameter Name="text" Type="System.String" />
        <Parameter Name="onClick" Type="System.EventHandler" />
        <Parameter Name="onPopup" Type="System.EventHandler" />
        <Parameter Name="onSelect" Type="System.EventHandler" />
        <Parameter Name="items" Type="System.Windows.Forms.MenuItem[]" />
      </Parameters>
      <Docs>
        <param name="mergeType">Um dos valores de <see cref="T:System.Windows.Forms.MenuMerge" />.</param>
        <param name="mergeOrder">A posição relativa que esse item de menu ocupará em um menu mesclado.</param>
        <param name="shortcut">Um dos valores de <see cref="T:System.Windows.Forms.Shortcut" />.</param>
        <param name="text">A legenda do item de menu.</param>
        <param name="onClick">O <see cref="T:System.EventHandler" /> que manipula o evento <see cref="E:System.Windows.Forms.MenuItem.Click" /> deste item de menu.</param>
        <param name="onPopup">O <see cref="T:System.EventHandler" /> que manipula o evento <see cref="E:System.Windows.Forms.MenuItem.Popup" /> deste item de menu.</param>
        <param name="onSelect">O <see cref="T:System.EventHandler" /> que manipula o evento <see cref="E:System.Windows.Forms.MenuItem.Select" /> deste item de menu.</param>
        <param name="items">Uma matriz de objetos <see cref="T:System.Windows.Forms.MenuItem" /> que contém os itens de submenu desse item de menu.</param>
        <summary>Inicializa uma nova instância da classe <see cref="T:System.Windows.Forms.MenuItem" /> com uma legenda especificada; manipuladores de eventos definidos para os eventos <see cref="E:System.Windows.Forms.MenuItem.Click" />, <see cref="E:System.Windows.Forms.MenuItem.Select" /> e <see cref="E:System.Windows.Forms.MenuItem.Popup" />; uma tecla de atalho; um tipo de mesclagem e, por fim, a ordem especificada para o item de menu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando você especificar uma legenda para o item de menu com o `text` parâmetro, você também pode especificar uma chave de acesso, colocando um '&' antes do caractere a ser usado como a chave de acesso. Por exemplo, para especificar o "F" em "Arquivo" como uma chave de acesso, você deve especificar a legenda do item de menu como "& arquivo". Você pode usar esse recurso para fornecer uma navegação de teclado para seus menus.  
  
 Definindo o `text` parâmetro para "`-`" faz com que o item de menu a ser exibido como um separador (uma linha horizontal) em vez de um item de menu padrão.  
  
 O `items` parâmetro permite que você atribua uma matriz de itens de menu para definir um submenu desse item de menu. Cada item na matriz também pode ter uma matriz de itens de menu atribuído a ele. Isso permite que você crie estruturas de menu completa e atribuí-los para o construtor para o item de menu.  
  
 O `mergeType` e `mergeOrder` parâmetros permitem que você determine como esse item de menu irá se comportar quando o item de menu é mesclado com outro menu. Dependendo do valor que você especificar para o `mergeType` parâmetro, você pode adicionar, remover, substituir ou mesclar o item de menu e seus itens de submenu no menu que está sendo mesclada com. O `mergeOrder` parâmetro determina onde o item de menu que está sendo criado será posicionado quando o menu é mesclado.  
  
 Além disso, você pode usar esse construtor para criar um <xref:System.Windows.Forms.MenuItem> e fazê-lo conectado a um manipulador de eventos em seu código que processará o clique do item de menu. O <xref:System.EventHandler> que você passe para esse construtor deve ser configurado para chamar um manipulador de eventos pode manipular o <xref:System.Windows.Forms.MenuItem.Click> eventos. Ao usar esta versão do construtor, você também pode se conectar a <xref:System.Windows.Forms.MenuItem.Popup> e <xref:System.Windows.Forms.MenuItem.Select> eventos para determinar quando esse item de menu é selecionado. Você pode usar esses eventos para tarefas como determinar se deseja ou não para exibir uma marca de seleção ao lado dos itens de submenu ou habilitar ou desabilitar itens de menu com base no estado do aplicativo. O <xref:System.Windows.Forms.MenuItem.Select> e <xref:System.Windows.Forms.MenuItem.Click> eventos são gerados somente para <xref:System.Windows.Forms.MenuItem> objetos que são não os itens de menu pai. Para obter mais informações sobre o tratamento de eventos, consulte [tratando e gerando eventos](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 O exemplo de código a seguir cria um item de menu que tem uma legenda e tecla de atalho. O item de menu também tem manipuladores de eventos definidos para o <xref:System.Windows.Forms.MenuItem.Popup>, <xref:System.Windows.Forms.MenuItem.Click>, e <xref:System.Windows.Forms.MenuItem.Select> eventos. Se este item de menu é mesclado, ele adicionará o item de menu ao menu com a ordem de mesclagem de zero.  
  
 [!code-cpp[Classic MenuItem.MenuItem5 Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic MenuItem.MenuItem5 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MenuItem.MenuItem5 Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic MenuItem.MenuItem5 Example/CS/source.cs#1)]
 [!code-vb[Classic MenuItem.MenuItem5 Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic MenuItem.MenuItem5 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Forms.MenuItem.Popup" />
        <altmember cref="E:System.Windows.Forms.MenuItem.Select" />
        <altmember cref="E:System.Windows.Forms.MenuItem.Click" />
        <altmember cref="P:System.Windows.Forms.MenuItem.MergeType" />
        <altmember cref="P:System.Windows.Forms.MenuItem.MergeOrder" />
      </Docs>
    </Member>
    <Member MemberName="BarBreak">
      <MemberSignature Language="C#" Value="public bool BarBreak { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool BarBreak" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.MenuItem.BarBreak" />
      <MemberSignature Language="VB.NET" Value="Public Property BarBreak As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool BarBreak { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.BarBreak : bool with get, set" Usage="System.Windows.Forms.MenuItem.BarBreak" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define um valor que indica se o <see cref="T:System.Windows.Forms.MenuItem" /> é colocado em uma nova linha (de um item de menu adicionado a um objeto <see cref="T:System.Windows.Forms.MainMenu" />) ou em uma nova coluna (para um item de submenu ou item de menu exibido em um <see cref="T:System.Windows.Forms.ContextMenu" />).</summary>
        <value><see langword="true" /> Se o item de menu é colocado em uma nova linha ou em uma nova coluna; <see langword="false" /> se o item de menu for deixado em seu posicionamento padrão. O padrão é <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Você pode usar o <xref:System.Windows.Forms.MenuItem.BarBreak%2A> propriedade para criar um menu no qual cada item de menu é colocado lado a lado horizontalmente em vez de em uma lista vertical. Você também pode usar essa propriedade para criar uma barra de menus que contém várias linhas de itens de menu de nível superior.  
  
 Essa propriedade é diferente do <xref:System.Windows.Forms.MenuItem.Break%2A> propriedade em que uma barra é exibida na borda esquerda de cada item de menu que tem o <xref:System.Windows.Forms.MenuItem.Break%2A> propriedade definida como `true`. A barra é exibida somente quando o item de menu não é um item de menu de nível superior.  
  
   
  
## Examples  
 O exemplo de código a seguir cria um <xref:System.Windows.Forms.MenuItem> com dois itens de submenu. Os itens de duas submenu são exibidos horizontalmente em vez de usar verticalmente o <xref:System.Windows.Forms.MenuItem.BarBreak%2A> propriedade.  
  
 [!code-cpp[Classic MenuItem.BarBreak Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic MenuItem.BarBreak Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MenuItem.BarBreak Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic MenuItem.BarBreak Example/CS/source.cs#1)]
 [!code-vb[Classic MenuItem.BarBreak Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic MenuItem.BarBreak Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.MenuItem.Break" />
      </Docs>
    </Member>
    <Member MemberName="Break">
      <MemberSignature Language="C#" Value="public bool Break { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Break" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.MenuItem.Break" />
      <MemberSignature Language="VB.NET" Value="Public Property Break As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Break { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.Break : bool with get, set" Usage="System.Windows.Forms.MenuItem.Break" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define um valor que indica se o item é colocado em uma nova linha (de um item de menu adicionado a um objeto <see cref="T:System.Windows.Forms.MainMenu" />) ou em uma nova coluna (para um item de menu ou item de submenu exibido em um <see cref="T:System.Windows.Forms.ContextMenu" />).</summary>
        <value><see langword="true" /> Se o item de menu é colocado em uma nova linha ou em uma nova coluna; <see langword="false" /> se o item de menu for deixado em seu posicionamento padrão. O padrão é <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Você pode usar o <xref:System.Windows.Forms.MenuItem.Break%2A> propriedade para criar um menu no qual cada menu é colocado lado a lado horizontalmente em vez de em uma lista vertical. Você também pode usar essa propriedade para criar uma barra de menus que contém várias linhas de itens de menu de nível superior.  
  
   
  
## Examples  
 O exemplo de código a seguir cria um menu com dois itens de menu de nível superior na linha superior e um item de menu na linha inferior.  
  
 [!code-cpp[Classic MenuItem.Break Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic MenuItem.Break Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MenuItem.Break Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic MenuItem.Break Example/CS/source.cs#1)]
 [!code-vb[Classic MenuItem.Break Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic MenuItem.Break Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.MenuItem.BarBreak" />
      </Docs>
    </Member>
    <Member MemberName="Checked">
      <MemberSignature Language="C#" Value="public bool Checked { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Checked" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.MenuItem.Checked" />
      <MemberSignature Language="VB.NET" Value="Public Property Checked As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Checked { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.Checked : bool with get, set" Usage="System.Windows.Forms.MenuItem.Checked" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define um valor que indica se uma marca de seleção aparece ao lado do texto do item de menu.</summary>
        <value><see langword="true" /> se houver uma marca de seleção ao lado do item de menu; caso contrário, <see langword="false" />. O padrão é <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Você pode usar o <xref:System.Windows.Forms.MenuItem.Checked%2A> propriedade em combinação com outros itens de menu em um menu para fornecer o estado de um aplicativo. Por exemplo, você pode colocar uma marca de seleção em um item de menu em um grupo de itens para identificar o tamanho da fonte a ser exibido para o texto em um aplicativo. Você também pode usar o <xref:System.Windows.Forms.MenuItem.Checked%2A> propriedade para identificar o item de menu selecionado em um grupo de itens de menu mutuamente exclusivos.  
  
> [!NOTE]
>  Essa propriedade não pode ser definida como `true` para itens de menu de nível superior.  
  
   
  
## Examples  
 O seguinte exemplo de código usa o <xref:System.Windows.Forms.MenuItem.Checked%2A> propriedade para fornecer o estado em um aplicativo. Neste exemplo, um grupo de itens de menu são usados para especificar a cor do texto em um <xref:System.Windows.Forms.TextBox> controle. O manipulador de eventos fornecido é usado pelo <xref:System.Windows.Forms.MenuItem.Click> eventos de três itens de menu. Cada item de menu Especifica uma cor de texto `menuItemRed` (vermelho), `menuItemGreen` (verde), ou `menuItemBlue` (azul). O manipulador de eventos determina qual item de menu foi clicado, coloca uma marca de seleção para o item de menu selecionado e altera a cor do texto no formato <xref:System.Windows.Forms.TextBox> controle. O exemplo requer que o <xref:System.Drawing> foi adicionado ao formulário que esse código é colocado no namespace. O exemplo também requer que um <xref:System.Windows.Forms.TextBox> foi adicionado ao formulário que esse código de exemplo está localizado na chamada `textBox1`.  
  
 [!code-cpp[Classic MenuItem.Checked Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic MenuItem.Checked Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MenuItem.Checked Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic MenuItem.Checked Example/CS/source.cs#1)]
 [!code-vb[Classic MenuItem.Checked Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic MenuItem.Checked Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">O <see cref="T:System.Windows.Forms.MenuItem" /> é um menu de nível superior ou tem filhos.</exception>
      </Docs>
    </Member>
    <Member MemberName="Click">
      <MemberSignature Language="C#" Value="public event EventHandler Click;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Click" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.MenuItem.Click" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Click As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ Click;" />
      <MemberSignature Language="F#" Value="member this.Click : EventHandler " Usage="member this.Click : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ocorre ao clicar ou selecionar o item de menu usando uma tecla de atalho ou tecla de acesso definida para o item de menu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Windows.Forms.MenuItem.Click> evento ocorre quando este <xref:System.Windows.Forms.MenuItem> é clicado pelo usuário. Esse evento também ocorre se o usuário seleciona o item de menu usando o teclado e pressiona a tecla Enter. Ele também pode ocorrer se uma chave de acesso ou a tecla de atalho foi pressionada que está associado com o <xref:System.Windows.Forms.MenuItem>. Para obter mais informações sobre como manipular eventos, consulte [tratando e gerando eventos](~/docs/standard/events/index.md).  
  
> [!NOTE]
>  Se o <xref:System.Windows.Forms.Menu.MenuItems%2A> propriedade para o <xref:System.Windows.Forms.MenuItem> contiver itens, esse evento não é gerado. Esse evento não é gerado para itens de menu pai.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como usar o <xref:System.Windows.Forms.MenuItem.Click> evento para executar tarefas quando um <xref:System.Windows.Forms.MenuItem> é clicado. O exemplo cria um <xref:System.Windows.Forms.MainMenu> chamado `mainMenu1` e adiciona dois <xref:System.Windows.Forms.MenuItem> objetos `topMenuItem` (`File`) e `menuItem1` (`Open`). Ele se conecta a `Click` eventos para o `menuItem1_Click` manipulador de eventos. Quando o usuário clica o `Open` item de menu, um <xref:System.Windows.Forms.OpenFileDialog> será inicializada e exibido. O exemplo requer que você tenha criado uma <xref:System.Windows.Forms.Form> chamado `Form1`.  
  
 [!code-cpp[MenuItemClick#1](~/samples/snippets/cpp/VS_Snippets_Winforms/MenuItemClick/CPP/form1.cpp#1)]
 [!code-csharp[MenuItemClick#1](~/samples/snippets/csharp/VS_Snippets_Winforms/MenuItemClick/CS/form1.cs#1)]
 [!code-vb[MenuItemClick#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/MenuItemClick/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="CloneMenu">
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Cria uma cópia de um <see cref="T:System.Windows.Forms.MenuItem" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CloneMenu">
      <MemberSignature Language="C#" Value="public virtual System.Windows.Forms.MenuItem CloneMenu ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Windows.Forms.MenuItem CloneMenu() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.MenuItem.CloneMenu" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function CloneMenu () As MenuItem" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Windows::Forms::MenuItem ^ CloneMenu();" />
      <MemberSignature Language="F#" Value="override this.CloneMenu : unit -&gt; System.Windows.Forms.MenuItem" Usage="menuItem.CloneMenu " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.MenuItem</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Cria uma cópia das <see cref="T:System.Windows.Forms.MenuItem" /> atuais.</summary>
        <returns>Um <see cref="T:System.Windows.Forms.MenuItem" /> que representa o item de menu duplicado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.MenuItem> objetos não podem ser usados em mais de um único lugar, a menos que você obtenha uma cópia do <xref:System.Windows.Forms.MenuItem>. Você pode chamar esse método para criar uma cópia deste item de menu para uso em um <xref:System.Windows.Forms.ContextMenu>, <xref:System.Windows.Forms.MainMenu>, ou outros <xref:System.Windows.Forms.MenuItem> dentro de seu aplicativo. Quando um item de menu é clonado, quaisquer manipuladores de evento especificadas no item de menu original continuarão a funcionar na versão do item de menu clonada. Por exemplo, se você tiver criado uma <xref:System.Windows.Forms.MenuItem> conectada e seu <xref:System.Windows.Forms.MenuItem.Click> eventos para um manipulador de eventos. Quando o item de menu é clonado, o item de menu clonado chamará o manipulador de eventos.  
  
   
  
## Examples  
 O código a seguir clones de exemplo uma <xref:System.Windows.Forms.MenuItem> e o exibe em um <xref:System.Windows.Forms.ContextMenu>. O exemplo requer que um <xref:System.Windows.Forms.MenuItem> existe em um <xref:System.Windows.Forms.MainMenu> em um formulário com o nome da `menuItem1` e que uma <xref:System.Windows.Forms.ContextMenu> objeto chamado `contextMenu1` também existe no formulário.  
  
 [!code-cpp[Classic MenuItem.CloneMenu Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic MenuItem.CloneMenu Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MenuItem.CloneMenu Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic MenuItem.CloneMenu Example/CS/source.cs#1)]
 [!code-vb[Classic MenuItem.CloneMenu Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic MenuItem.CloneMenu Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CloneMenu">
      <MemberSignature Language="C#" Value="protected void CloneMenu (System.Windows.Forms.MenuItem itemSrc);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void CloneMenu(class System.Windows.Forms.MenuItem itemSrc) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.MenuItem.CloneMenu(System.Windows.Forms.MenuItem)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub CloneMenu (itemSrc As MenuItem)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void CloneMenu(System::Windows::Forms::MenuItem ^ itemSrc);" />
      <MemberSignature Language="F#" Value="override this.CloneMenu : System.Windows.Forms.MenuItem -&gt; unit" Usage="menuItem.CloneMenu itemSrc" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="itemSrc" Type="System.Windows.Forms.MenuItem" />
      </Parameters>
      <Docs>
        <param name="itemSrc">O <see cref="T:System.Windows.Forms.MenuItem" /> que representa o item de menu a ser copiado.</param>
        <summary>Cria uma cópia do <see cref="T:System.Windows.Forms.MenuItem" /> especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Chame esse método para criar cópias dos itens de menu que você já tiver criado para uso em um menu de atalho ou outra estrutura de menu dentro de seu aplicativo. Esta versão do <xref:System.Windows.Forms.MenuItem.CloneMenu%2A> permite que você especifique um determinado <xref:System.Windows.Forms.MenuItem> para copiar em vez do item de menu que está chamando o método. Você pode usar esse método para inicializar uma nova <xref:System.Windows.Forms.MenuItem> objeto com uma cópia de outro <xref:System.Windows.Forms.MenuItem>. Quando um item de menu é clonado, quaisquer manipuladores de evento especificadas no item de menu original continuarão a funcionar na versão do item de menu clonada. Por exemplo, se você tiver criado uma <xref:System.Windows.Forms.MenuItem> conectada e seu <xref:System.Windows.Forms.MenuItem.Click> eventos para um manipulador de eventos. Quando o item de menu é clonado, o item de menu clonado chamará o manipulador de eventos.  
  
   
  
## Examples  
 O exemplo de código a seguir inicializa uma nova <xref:System.Windows.Forms.MenuItem> com uma cópia de um existente <xref:System.Windows.Forms.MenuItem> que é usado em um <xref:System.Windows.Forms.MainMenu> em um formulário. O código, em seguida, adiciona o clonado <xref:System.Windows.Forms.MenuItem> para um <xref:System.Windows.Forms.ContextMenu> no formulário. Este exemplo requer que um <xref:System.Windows.Forms.MenuItem> já foi criado e denominado `menuItem1` e que um <xref:System.Windows.Forms.ContextMenu> controle foi criado e denominado `contextMenu1`.  
  
 [!code-cpp[Classic MenuItem.CloneMenu1 Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic MenuItem.CloneMenu1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MenuItem.CloneMenu1 Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic MenuItem.CloneMenu1 Example/CS/source.cs#1)]
 [!code-vb[Classic MenuItem.CloneMenu1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic MenuItem.CloneMenu1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DefaultItem">
      <MemberSignature Language="C#" Value="public bool DefaultItem { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool DefaultItem" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.MenuItem.DefaultItem" />
      <MemberSignature Language="VB.NET" Value="Public Property DefaultItem As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool DefaultItem { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.DefaultItem : bool with get, set" Usage="System.Windows.Forms.MenuItem.DefaultItem" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define um valor que indica se o item de menu é o item de menu padrão.</summary>
        <value><see langword="true" /> Se o item de menu é o item padrão em um menu. Caso contrário, <see langword="false" />. O padrão é <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O item de menu padrão para um menu de negrito. Quando o usuário clica duas vezes em um submenu que contém um item padrão, o item padrão é selecionado e o submenu é fechado. Você pode usar o <xref:System.Windows.Forms.MenuItem.DefaultItem%2A> propriedade para indicar a ação padrão que é esperada em um menu ou menu de atalho.  
  
   
  
## Examples  
 O exemplo de código a seguir cria um item de menu com dois itens de submenu. O exemplo define `menuItem2` como o item de menu padrão usando o <xref:System.Windows.Forms.MenuItem.DefaultItem%2A> propriedade.  
  
 [!code-cpp[Classic MenuItem.DefaultItem Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic MenuItem.DefaultItem Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MenuItem.DefaultItem Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic MenuItem.DefaultItem Example/CS/source.cs#1)]
 [!code-vb[Classic MenuItem.DefaultItem Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic MenuItem.DefaultItem Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected override void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.MenuItem.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void Dispose(bool disposing);" />
      <MemberSignature Language="F#" Value="override this.Dispose : bool -&gt; unit" Usage="menuItem.Dispose disposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing"><see langword="true" /> para liberar recursos gerenciados e não gerenciados; <see langword="false" /> para liberar apenas recursos não gerenciados.</param>
        <summary>Descarta os recursos (exceto a memória) usados pelo <see cref="T:System.Windows.Forms.MenuItem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Chame <xref:System.Windows.Forms.MenuItem.Dispose%2A> quando tiver terminado de usar o <xref:System.Windows.Forms.MenuItem>. O <xref:System.Windows.Forms.MenuItem.Dispose%2A> método deixa o <xref:System.Windows.Forms.MenuItem> em um estado inutilizável. Depois de chamar <xref:System.Windows.Forms.MenuItem.Dispose%2A>, você deve liberar todas as referências para o <xref:System.Windows.Forms.MenuItem> para que a memória que ele estava ocupando pode ser recuperada pela coleta de lixo.  
  
> [!NOTE]
>  Sempre chamar <xref:System.Windows.Forms.MenuItem.Dispose%2A> antes de liberar sua última referência para o <xref:System.Windows.Forms.MenuItem>. Caso contrário, os recursos a <xref:System.Windows.Forms.MenuItem> está usando não será liberado até que as chamadas de coleta de lixo a <xref:System.Windows.Forms.MenuItem> destruidor do objeto.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DrawItem">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.DrawItemEventHandler DrawItem;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.DrawItemEventHandler DrawItem" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.MenuItem.DrawItem" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event DrawItem As DrawItemEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::DrawItemEventHandler ^ DrawItem;" />
      <MemberSignature Language="F#" Value="member this.DrawItem : System.Windows.Forms.DrawItemEventHandler " Usage="member this.DrawItem : System.Windows.Forms.DrawItemEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.DrawItemEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ocorre quando a propriedade <see cref="P:System.Windows.Forms.MenuItem.OwnerDraw" /> de um item de menu é definida como <see langword="true" /> e é feita uma solicitação para desenhar o item de menu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Windows.Forms.DrawItemEventArgs> argumento passado para um <xref:System.Windows.Forms.MenuItem.DrawItem> manipulador de eventos fornece um <xref:System.Drawing.Graphics> objeto que permite que você execute o desenho e outras operações gráficas na superfície do item de menu. Você pode usar este manipulador de eventos para criar menus personalizados que atendem às necessidades do seu aplicativo. Para obter mais informações sobre como manipular eventos, consulte [tratando e gerando eventos](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como manipular o <xref:System.Windows.Forms.MenuItem.DrawItem> eventos. Este exemplo desenha um menu de item usando um <xref:System.Drawing.Brush> e uma <xref:System.Drawing.Font>e, em seguida, desenha uma <xref:System.Drawing.Rectangle> ao redor do item de menu. O desenho é realizado por meio de <xref:System.Drawing.Graphics> objeto, que é passado para o manipulador de eventos no <xref:System.Windows.Forms.DrawItemEventArgs> parâmetro. Este exemplo requer que você inicializou o <xref:System.Windows.Forms.MenuItem.OwnerDraw%2A> propriedade para o item a ser `true`. Para obter o exemplo de C#, adicione o seguinte código no construtor do formulário, após `InitializeComponent`, para conectar o evento:  
  
 `this.menuItem1.DrawItem += new DrawItemEventHandler(menuItem1_DrawItem);`  
  
 [!code-cpp[OwnerDraw example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/OwnerDraw example/CPP/form1.cpp#1)]
 [!code-csharp[OwnerDraw example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/OwnerDraw example/CS/form1.cs#1)]
 [!code-vb[OwnerDraw example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/OwnerDraw example/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.MenuItem.OwnerDraw" />
        <altmember cref="E:System.Windows.Forms.MenuItem.MeasureItem" />
      </Docs>
    </Member>
    <Member MemberName="Enabled">
      <MemberSignature Language="C#" Value="public bool Enabled { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Enabled" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.MenuItem.Enabled" />
      <MemberSignature Language="VB.NET" Value="Public Property Enabled As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Enabled { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.Enabled : bool with get, set" Usage="System.Windows.Forms.MenuItem.Enabled" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define um valor que indica se o item de menu está habilitado.</summary>
        <value><see langword="true" /> se o item de menu estiver habilitado; caso contrário, <see langword="false" />. O padrão é <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Um <xref:System.Windows.Forms.MenuItem> que é desabilitado é exibido em uma cor cinza para indicar seu estado. Quando um item de menu pai estiver desabilitado, todos os itens de submenu não são exibidos.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como usar o <xref:System.Windows.Forms.MenuItem.Popup> evento para determinar se <xref:System.Windows.Forms.MenuItem> objetos que fornecem suporte para recortar, copiar e excluir operações estão ativados antes que eles são exibidos no menu é mostrado. O exemplo determina se `textBox1`, um <xref:System.Windows.Forms.TextBox> controle no formulário, está habilitado, tem o foco de entrada e tem texto selecionado antes de habilitar o <xref:System.Windows.Forms.MenuItem> objetos. Este exemplo requer que três <xref:System.Windows.Forms.MenuItem> os objetos são criados nomeados `menuCut`, `menuCopy`, e `menuDelete` foram criados.  
  
 [!code-cpp[MenuItem.Popup#1](~/samples/snippets/cpp/VS_Snippets_Winforms/MenuItem.Popup/CPP/form1.cpp#1)]
 [!code-csharp[MenuItem.Popup#1](~/samples/snippets/csharp/VS_Snippets_Winforms/MenuItem.Popup/CS/form1.cs#1)]
 [!code-vb[MenuItem.Popup#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/MenuItem.Popup/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Index">
      <MemberSignature Language="C#" Value="public int Index { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Index" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.MenuItem.Index" />
      <MemberSignature Language="VB.NET" Value="Public Property Index As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Index { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.Index : int with get, set" Usage="System.Windows.Forms.MenuItem.Index" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define um valor que indica a posição do item de menu em seu menu pai.</summary>
        <value>O índice baseado em zero que representa a posição do item de menu no seu menu pai.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esta propriedade fornece a posição indexada de um item de menu na coleção de itens de menu do seu menu pai. Você pode usar essa propriedade para reposicionar um item de menu para um local diferente dentro do seu menu. Você também pode usar essa propriedade ao criar um <xref:System.Windows.Forms.MenuItem> para especificar sua posição em uma estrutura de menu no momento da criação.  
  
   
  
## Examples  
 O exemplo de código a seguir alterna a posição de dois itens de menu em um menu. O exemplo de código a seguir requer que dois <xref:System.Windows.Forms.MenuItem> os objetos são criados nomeados `menuItem1` e `menuItem2`. O `menuItem1` item de menu move para baixo uma posição no menu, enquanto `menuItem2` move uma posição acima.  
  
 [!code-cpp[Classic MenuItem.Index Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic MenuItem.Index Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MenuItem.Index Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic MenuItem.Index Example/CS/source.cs#1)]
 [!code-vb[Classic MenuItem.Index Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic MenuItem.Index Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">O valor atribuído é menor que zero ou maior que contagem de itens.</exception>
      </Docs>
    </Member>
    <Member MemberName="IsParent">
      <MemberSignature Language="C#" Value="public override bool IsParent { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsParent" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.MenuItem.IsParent" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property IsParent As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsParent { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsParent : bool" Usage="System.Windows.Forms.MenuItem.IsParent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém um valor que indica se o item de menu contém itens de menu filho.</summary>
        <value><see langword="true" /> Se o item de menu contém itens de menu filho; <see langword="false" /> se o menu é um item de menu autônomo.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Você pode usar essa propriedade com o <xref:System.Windows.Forms.MenuItem.Parent%2A> propriedade navegar no código por meio de uma estrutura de menu inteiro.  
  
   
  
## Examples  
 O exemplo de código a seguir determina se há qualquer submenus associados com um <xref:System.Windows.Forms.MenuItem> chamado `menuItem1`. Se qualquer submenus existirem, ele desabilita definindo a <xref:System.Windows.Forms.MenuItem.Enabled%2A> propriedade para `false`. O exemplo requer que haja uma <xref:System.Windows.Forms.MenuItem> criado e denominado `menuItem1`.  
  
 [!code-cpp[Classic MenuItem.IsParent Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic MenuItem.IsParent Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MenuItem.IsParent Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic MenuItem.IsParent Example/CS/source.cs#1)]
 [!code-vb[Classic MenuItem.IsParent Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic MenuItem.IsParent Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MdiList">
      <MemberSignature Language="C#" Value="public bool MdiList { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool MdiList" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.MenuItem.MdiList" />
      <MemberSignature Language="VB.NET" Value="Public Property MdiList As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool MdiList { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.MdiList : bool with get, set" Usage="System.Windows.Forms.MenuItem.MdiList" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define um valor que indica se o item de menu será populado com uma lista das janelas filho de MDI (interface de documentos múltiplos) que são exibidas no formulário associado.</summary>
        <value><see langword="true" /> se uma lista de janelas filho MDI for exibida neste item de menu; caso contrário, <see langword="false" />. O padrão é <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando um item de menu é selecionado para exibir uma lista de janelas filho MDI, a lista é exibida como um submenu do item de menu. Somente os formulários que são definidos como formulários filho MDI são exibidos na lista de janela. Apenas nove janelas de filho podem ser exibidas por vez. Se houver mais de nove janelas filho exibidas, um item de menu "Mais Windows..." é exibido no final da lista de janela. Clicar neste item de menu exibe uma caixa de diálogo com uma lista completa das janelas filho que estão ativas no momento.  
  
   
  
## Examples  
 O exemplo de código a seguir cria um <xref:System.Windows.Forms.MenuItem> que é usado para exibir a lista de formulários filho MDI abertos no momento em um formulário MDI.  
  
 [!code-cpp[Classic MenuItem.MdiList Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic MenuItem.MdiList Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MenuItem.MdiList Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic MenuItem.MdiList Example/CS/source.cs#1)]
 [!code-vb[Classic MenuItem.MdiList Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic MenuItem.MdiList Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MeasureItem">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.MeasureItemEventHandler MeasureItem;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.MeasureItemEventHandler MeasureItem" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.MenuItem.MeasureItem" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event MeasureItem As MeasureItemEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::MeasureItemEventHandler ^ MeasureItem;" />
      <MemberSignature Language="F#" Value="member this.MeasureItem : System.Windows.Forms.MeasureItemEventHandler " Usage="member this.MeasureItem : System.Windows.Forms.MeasureItemEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.MeasureItemEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ocorre quando o menu precisa saber o tamanho de um item de menu antes de desenhá-lo.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para este evento a ser gerado, você deve ter o <xref:System.Windows.Forms.MenuItem.OwnerDraw%2A> propriedade do item de menu é definida como `true`. Esse evento é gerado antes de menus desenhados pelo proprietário são desenhadas para permitir o tamanho do item de menu a ser desenhado para ser especificado. Para obter mais informações sobre como manipular eventos, consulte [tratando e gerando eventos](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra o uso desse membro. No exemplo, um manipulador de eventos relata a ocorrência da <xref:System.Windows.Forms.MenuItem.MeasureItem> eventos. Este relatório ajuda você a saber quando o evento ocorre e pode ajudar na depuração.  
  
 Para executar o exemplo de código, cole-o em um projeto que contém uma instância do tipo <xref:System.Windows.Forms.MenuItem> chamado `MenuItem1`. Em seguida, certifique-se de que o manipulador de eventos está associado com o <xref:System.Windows.Forms.MenuItem.MeasureItem> eventos.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#499](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#499)]
 [!code-vb[System.Windows.Forms.EventExamples#499](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#499)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.MenuItem.OwnerDraw" />
        <altmember cref="E:System.Windows.Forms.MenuItem.DrawItem" />
      </Docs>
    </Member>
    <Member MemberName="MenuID">
      <MemberSignature Language="C#" Value="protected int MenuID { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 MenuID" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.MenuItem.MenuID" />
      <MemberSignature Language="VB.NET" Value="Protected ReadOnly Property MenuID As Integer" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property int MenuID { int get(); };" />
      <MemberSignature Language="F#" Value="member this.MenuID : int" Usage="System.Windows.Forms.MenuItem.MenuID" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém um valor que indica o identificador do Windows para este item de menu.</summary>
        <value>O identificador do Windows para este item de menu.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="MergeMenu">
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Mescla este <see cref="T:System.Windows.Forms.MenuItem" /> com outro <see cref="T:System.Windows.Forms.MenuItem" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="MergeMenu">
      <MemberSignature Language="C#" Value="public virtual System.Windows.Forms.MenuItem MergeMenu ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Windows.Forms.MenuItem MergeMenu() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.MenuItem.MergeMenu" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function MergeMenu () As MenuItem" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Windows::Forms::MenuItem ^ MergeMenu();" />
      <MemberSignature Language="F#" Value="override this.MergeMenu : unit -&gt; System.Windows.Forms.MenuItem" Usage="menuItem.MergeMenu " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.MenuItem</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Mescla este <see cref="T:System.Windows.Forms.MenuItem" /> com outro <see cref="T:System.Windows.Forms.MenuItem" /> e retorna o <see cref="T:System.Windows.Forms.MenuItem" /> mesclado resultante.</summary>
        <returns>Um <see cref="T:System.Windows.Forms.MenuItem" /> que representa o item de menu mesclado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando você chama essa versão do <xref:System.Windows.Forms.MenuItem.MergeMenu%2A>, o <xref:System.Windows.Forms.MenuItem> retornado é uma cópia do item de menu atual que pode ser mesclado com outro item de menu sem afetar a funcionalidade do item atual. Esta versão dos <xref:System.Windows.Forms.MenuItem.MergeMenu%2A> método é semelhante a chamar o <xref:System.Windows.Forms.MenuItem.CloneMenu%2A> método sem parâmetros.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MergeMenu">
      <MemberSignature Language="C#" Value="public void MergeMenu (System.Windows.Forms.MenuItem itemSrc);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void MergeMenu(class System.Windows.Forms.MenuItem itemSrc) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.MenuItem.MergeMenu(System.Windows.Forms.MenuItem)" />
      <MemberSignature Language="VB.NET" Value="Public Sub MergeMenu (itemSrc As MenuItem)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void MergeMenu(System::Windows::Forms::MenuItem ^ itemSrc);" />
      <MemberSignature Language="F#" Value="override this.MergeMenu : System.Windows.Forms.MenuItem -&gt; unit" Usage="menuItem.MergeMenu itemSrc" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="itemSrc" Type="System.Windows.Forms.MenuItem" />
      </Parameters>
      <Docs>
        <param name="itemSrc">Um <see cref="T:System.Windows.Forms.MenuItem" /> que especifica o item de menu a ser mesclado com este.</param>
        <summary>Mescla a outro item de menu com este item de menu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Itens de menu são mesclados de acordo com o valor do item de menu <xref:System.Windows.Forms.MenuItem.MergeType%2A> e <xref:System.Windows.Forms.MenuItem.MergeOrder%2A> propriedades. Esta versão dos <xref:System.Windows.Forms.MenuItem.MergeMenu%2A> método permite que você para mesclar dois <xref:System.Windows.Forms.MenuItem> objetos (e seus submenus) em um único menu. Mesclagem de menu é manipulado automaticamente quando um formulário pai de Interface de documentos múltiplos (MDI) e filho têm menus. Você pode usar essa versão do método para mesclar duas <xref:System.Windows.Forms.MenuItem> objetos (e seus itens de submenu) localizados em um <xref:System.Windows.Forms.MainMenu> controle em um único menu dentro de um <xref:System.Windows.Forms.ContextMenu>. Por exemplo, você pode chamar essa versão dos <xref:System.Windows.Forms.MenuItem.MergeMenu%2A> método para mesclar os itens de menu de um menu Arquivo e editar em um único <xref:System.Windows.Forms.MenuItem> que pode ser adicionado ao e exibido por um <xref:System.Windows.Forms.ContextMenu>.  
  
   
  
## Examples  
 O exemplo de código a seguir usa essa versão dos <xref:System.Windows.Forms.MenuItem.MergeMenu%2A> método para criar uma cópia de um <xref:System.Windows.Forms.MenuItem> e mesclá-la com outra. O mesclado <xref:System.Windows.Forms.MenuItem> é adicionado a um <xref:System.Windows.Forms.ContextMenu> controle. Este exemplo requer que há dois itens de menu chamados `menuItem1` e `menuItem2` que contêm itens de submenu dentro deles e um <xref:System.Windows.Forms.ContextMenu> denominada `contextMenu1` para exibir os itens de menu. `menuItem1` e `menuItem2` ter itens de menu diferentes contidos neles. Após a chamada para <xref:System.Windows.Forms.MenuItem.MergeMenu%2A> é feita, um consolidado menu é criado.  
  
 [!code-cpp[Classic MenuItem.MergeMenu1 Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic MenuItem.MergeMenu1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MenuItem.MergeMenu1 Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic MenuItem.MergeMenu1 Example/CS/source.cs#1)]
 [!code-vb[Classic MenuItem.MergeMenu1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic MenuItem.MergeMenu1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MergeOrder">
      <MemberSignature Language="C#" Value="public int MergeOrder { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 MergeOrder" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.MenuItem.MergeOrder" />
      <MemberSignature Language="VB.NET" Value="Public Property MergeOrder As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int MergeOrder { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.MergeOrder : int with get, set" Usage="System.Windows.Forms.MenuItem.MergeOrder" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(0)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define um valor que indica a posição relativa do item de menu quando ele é mesclado com outro.</summary>
        <value>Um índice baseado em zero que representa a posição deste item de menu na ordem de mesclagem. O padrão é 0.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A ordem de mesclagem de um item de menu Especifica a posição relativa que esse item de menu terá se o menu de estrutura que o <xref:System.Windows.Forms.MenuItem> está contida no é mesclado com outro.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como usar o <xref:System.Windows.Forms.MenuItem.MergeOrder%2A> propriedade para controlar o modo de exibição de um menu mesclado. Isso é um exemplo completo, pronto para ser executado depois de adicioná-lo ao seu projeto.  
  
 [!code-cpp[System.Windows.Forms.MenuItemMergeOrder#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.MenuItemMergeOrder/CPP/form1.cpp#1)]
 [!code-csharp[System.Windows.Forms.MenuItemMergeOrder#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.MenuItemMergeOrder/CS/form1.cs#1)]
 [!code-vb[System.Windows.Forms.MenuItemMergeOrder#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.MenuItemMergeOrder/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.MenuItem.MergeType" />
        <altmember cref="M:System.Windows.Forms.MenuItem.MergeMenu" />
      </Docs>
    </Member>
    <Member MemberName="MergeType">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.MenuMerge MergeType { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Forms.MenuMerge MergeType" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.MenuItem.MergeType" />
      <MemberSignature Language="VB.NET" Value="Public Property MergeType As MenuMerge" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Forms::MenuMerge MergeType { System::Windows::Forms::MenuMerge get(); void set(System::Windows::Forms::MenuMerge value); };" />
      <MemberSignature Language="F#" Value="member this.MergeType : System.Windows.Forms.MenuMerge with get, set" Usage="System.Windows.Forms.MenuItem.MergeType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.MenuMerge</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define um valor que indica o comportamento do item de menu quando o menu é mesclado com outro.</summary>
        <value>Um valor <see cref="T:System.Windows.Forms.MenuMerge" /> que representa o tipo de mesclagem do item de menu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O tipo de mesclagem de um item de menu indica como o item de menu se comporta quando ele tem a mesma ordem de mesclagem que outro item de menu que está sendo mesclado. Você pode usar os menus mescladas para criar um menu consolidado com base em dois ou mais menus existentes.  
  
   
  
## Examples  
 O exemplo de código a seguir cria uma <xref:System.Windows.Forms.MenuItem> com o <xref:System.Windows.Forms.MenuItem.MergeType%2A> e <xref:System.Windows.Forms.MenuItem.MergeOrder%2A> especificado para que o item de menu é adicionado ao menu mesclado na primeira posição.  
  
 [!code-cpp[Classic MenuItem.MergeType Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic MenuItem.MergeType Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MenuItem.MergeType Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic MenuItem.MergeType Example/CS/source.cs#1)]
 [!code-vb[Classic MenuItem.MergeType Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic MenuItem.MergeType Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">O valor atribuído não é um dos valores <see cref="T:System.Windows.Forms.MenuMerge" />.</exception>
        <altmember cref="T:System.Windows.Forms.MenuMerge" />
        <altmember cref="P:System.Windows.Forms.MenuItem.MergeOrder" />
      </Docs>
    </Member>
    <Member MemberName="Mnemonic">
      <MemberSignature Language="C#" Value="public char Mnemonic { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance char Mnemonic" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.MenuItem.Mnemonic" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Mnemonic As Char" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property char Mnemonic { char get(); };" />
      <MemberSignature Language="F#" Value="member this.Mnemonic : char" Usage="System.Windows.Forms.MenuItem.Mnemonic" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém um valor que indica o caractere mnemônico associado a esse item de menu.</summary>
        <value>Um caractere que representa o caractere mnemônico associado a este item de menu. Retorna o caractere NUL (valor ASCII 0) se nenhum caractere mnemônico é especificado no texto do <see cref="T:System.Windows.Forms.MenuItem" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O caractere mnemônico é o primeiro caractere após o caractere e comercial (&) no texto do <xref:System.Windows.Forms.MenuItem>. Essa propriedade não retornará um mnemônico se dois caracteres de e comercial forem colocados juntos, como o e comercial é usado para exibir um e comercial no texto do <xref:System.Windows.Forms.MenuItem> em vez de definir um caractere mnemônico.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.MenuItem.Text" />
      </Docs>
    </Member>
    <Member MemberName="OnClick">
      <MemberSignature Language="C#" Value="protected virtual void OnClick (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnClick(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.MenuItem.OnClick(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnClick (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnClick(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnClick : EventArgs -&gt; unit&#xA;override this.OnClick : EventArgs -&gt; unit" Usage="menuItem.OnClick e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Um <see cref="T:System.EventArgs" /> que contém os dados do evento.</param>
        <summary>Aciona o evento <see cref="E:System.Windows.Forms.MenuItem.Click" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A geração de um evento invoca o manipulador de eventos por meio de um delegado. Para obter mais informações, consulte [tratando e gerando eventos](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como usar o <xref:System.Windows.Forms.MenuItem.Click> evento para executar tarefas quando um <xref:System.Windows.Forms.MenuItem> é clicado. O exemplo cria um <xref:System.Windows.Forms.MainMenu> chamado `mainMenu1` e adiciona dois <xref:System.Windows.Forms.MenuItem> objetos `topMenuItem` (`File`) e `menuItem1` (`Open`). Ele se conecta a `Click` eventos para o `menuItem1_Click` manipulador de eventos. Quando o usuário clica o `Open` item de menu, um <xref:System.Windows.Forms.OpenFileDialog> será inicializada e exibido. O exemplo requer que você tenha criado uma <xref:System.Windows.Forms.Form> chamado `Form1`.  
  
 [!code-cpp[MenuItemClick#1](~/samples/snippets/cpp/VS_Snippets_Winforms/MenuItemClick/CPP/form1.cpp#1)]
 [!code-csharp[MenuItemClick#1](~/samples/snippets/csharp/VS_Snippets_Winforms/MenuItemClick/CS/form1.cs#1)]
 [!code-vb[MenuItemClick#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/MenuItemClick/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Ao substituir <see cref="M:System.Windows.Forms.MenuItem.OnClick(System.EventArgs)" /> em uma classe derivada, certifique-se de chamar a classe base <see cref="M:System.Windows.Forms.MenuItem.OnClick(System.EventArgs)" /> método.</para></block>
      </Docs>
    </Member>
    <Member MemberName="OnDrawItem">
      <MemberSignature Language="C#" Value="protected virtual void OnDrawItem (System.Windows.Forms.DrawItemEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnDrawItem(class System.Windows.Forms.DrawItemEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.MenuItem.OnDrawItem(System.Windows.Forms.DrawItemEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnDrawItem (e As DrawItemEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnDrawItem(System::Windows::Forms::DrawItemEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnDrawItem : System.Windows.Forms.DrawItemEventArgs -&gt; unit&#xA;override this.OnDrawItem : System.Windows.Forms.DrawItemEventArgs -&gt; unit" Usage="menuItem.OnDrawItem e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Forms.DrawItemEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Um <see cref="T:System.Windows.Forms.DrawItemEventArgs" /> que contém os dados do evento.</param>
        <summary>Aciona o evento <see cref="E:System.Windows.Forms.MenuItem.DrawItem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A geração de um evento invoca o manipulador de eventos por meio de um delegado. Para obter mais informações, consulte [tratando e gerando eventos](~/docs/standard/events/index.md).  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Ao substituir <see cref="M:System.Windows.Forms.MenuItem.OnDrawItem(System.Windows.Forms.DrawItemEventArgs)" /> em uma classe derivada, certifique-se de chamar a classe base <see cref="M:System.Windows.Forms.MenuItem.OnDrawItem(System.Windows.Forms.DrawItemEventArgs)" /> método.</para></block>
        <altmember cref="T:System.Windows.Forms.DrawItemEventArgs" />
      </Docs>
    </Member>
    <Member MemberName="OnInitMenuPopup">
      <MemberSignature Language="C#" Value="protected virtual void OnInitMenuPopup (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnInitMenuPopup(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.MenuItem.OnInitMenuPopup(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnInitMenuPopup (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnInitMenuPopup(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnInitMenuPopup : EventArgs -&gt; unit&#xA;override this.OnInitMenuPopup : EventArgs -&gt; unit" Usage="menuItem.OnInitMenuPopup e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Um <see cref="T:System.EventArgs" /> que contém os dados do evento.</param>
        <summary>Aciona o evento <see cref="E:System.Windows.Forms.MenuItem.Popup" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnMeasureItem">
      <MemberSignature Language="C#" Value="protected virtual void OnMeasureItem (System.Windows.Forms.MeasureItemEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnMeasureItem(class System.Windows.Forms.MeasureItemEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.MenuItem.OnMeasureItem(System.Windows.Forms.MeasureItemEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnMeasureItem (e As MeasureItemEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnMeasureItem(System::Windows::Forms::MeasureItemEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnMeasureItem : System.Windows.Forms.MeasureItemEventArgs -&gt; unit&#xA;override this.OnMeasureItem : System.Windows.Forms.MeasureItemEventArgs -&gt; unit" Usage="menuItem.OnMeasureItem e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Forms.MeasureItemEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Um <see cref="T:System.Windows.Forms.MeasureItemEventArgs" /> que contém os dados do evento.</param>
        <summary>Aciona o evento <see cref="E:System.Windows.Forms.MenuItem.MeasureItem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A geração de um evento invoca o manipulador de eventos por meio de um delegado. Para obter mais informações, consulte [tratando e gerando eventos](~/docs/standard/events/index.md).  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Ao substituir <see cref="M:System.Windows.Forms.MenuItem.OnMeasureItem(System.Windows.Forms.MeasureItemEventArgs)" /> em uma classe derivada, certifique-se de chamar a classe base <see cref="M:System.Windows.Forms.MenuItem.OnMeasureItem(System.Windows.Forms.MeasureItemEventArgs)" /> método.</para></block>
        <altmember cref="T:System.Windows.Forms.MeasureItemEventArgs" />
      </Docs>
    </Member>
    <Member MemberName="OnPopup">
      <MemberSignature Language="C#" Value="protected virtual void OnPopup (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnPopup(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.MenuItem.OnPopup(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnPopup (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnPopup(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnPopup : EventArgs -&gt; unit&#xA;override this.OnPopup : EventArgs -&gt; unit" Usage="menuItem.OnPopup e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Um <see cref="T:System.EventArgs" /> que contém os dados do evento.</param>
        <summary>Aciona o evento <see cref="E:System.Windows.Forms.MenuItem.Popup" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A geração de um evento invoca o manipulador de eventos por meio de um delegado. Para obter mais informações, consulte [tratando e gerando eventos](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como usar o <xref:System.Windows.Forms.MenuItem.Popup> evento para determinar se <xref:System.Windows.Forms.MenuItem> objetos que fornecem suporte para recortar, copiar e excluir operações estão ativados antes que eles são exibidos no menu é mostrado. O exemplo determina se `textBox1`, um <xref:System.Windows.Forms.TextBox> controle no formulário, está habilitado, tem o foco de entrada e tem texto selecionado antes de habilitar o <xref:System.Windows.Forms.MenuItem> objetos. Este exemplo requer que três <xref:System.Windows.Forms.MenuItem> os objetos são criados nomeados `menuCut`, `menuCopy`, e `menuDelete` foram criados.  
  
 [!code-cpp[MenuItem.Popup#1](~/samples/snippets/cpp/VS_Snippets_Winforms/MenuItem.Popup/CPP/form1.cpp#1)]
 [!code-csharp[MenuItem.Popup#1](~/samples/snippets/csharp/VS_Snippets_Winforms/MenuItem.Popup/CS/form1.cs#1)]
 [!code-vb[MenuItem.Popup#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/MenuItem.Popup/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Ao substituir <see cref="M:System.Windows.Forms.MenuItem.OnPopup(System.EventArgs)" /> em uma classe derivada, certifique-se de chamar a classe base <see cref="M:System.Windows.Forms.MenuItem.OnPopup(System.EventArgs)" /> método.</para></block>
      </Docs>
    </Member>
    <Member MemberName="OnSelect">
      <MemberSignature Language="C#" Value="protected virtual void OnSelect (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnSelect(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.MenuItem.OnSelect(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnSelect (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnSelect(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnSelect : EventArgs -&gt; unit&#xA;override this.OnSelect : EventArgs -&gt; unit" Usage="menuItem.OnSelect e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Um <see cref="T:System.EventArgs" /> que contém os dados do evento.</param>
        <summary>Aciona o evento <see cref="E:System.Windows.Forms.MenuItem.Select" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A geração de um evento invoca o manipulador de eventos por meio de um delegado. Para obter mais informações, consulte [tratando e gerando eventos](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como usar o <xref:System.Windows.Forms.MenuItem.Select> eventos do <xref:System.Windows.Forms.MenuItem> classe para atribuir texto de ajuda para um <xref:System.Windows.Forms.StatusBarPanel> de um <xref:System.Windows.Forms.StatusBar> controle. Este exemplo requer que <xref:System.Windows.Forms.MenuItem> objetos nomeados `menuOpen`, `menuSave`, e `menuExit` são adicionados a um <xref:System.Windows.Forms.MainMenu> controle em um formulário. O exemplo também requer que um <xref:System.Windows.Forms.StatusBar> controle, chamado `statusBar1` foi adicionado ao formulário. O <xref:System.Windows.Forms.StatusBar> controle deve conter um <xref:System.Windows.Forms.StatusBarPanel>.  
  
 [!code-cpp[MenuItem.Select#1](~/samples/snippets/cpp/VS_Snippets_Winforms/MenuItem.Select/CPP/form1.cpp#1)]
 [!code-csharp[MenuItem.Select#1](~/samples/snippets/csharp/VS_Snippets_Winforms/MenuItem.Select/CS/form1.cs#1)]
 [!code-vb[MenuItem.Select#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/MenuItem.Select/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Ao substituir <see cref="M:System.Windows.Forms.MenuItem.OnSelect(System.EventArgs)" /> em uma classe derivada, certifique-se de chamar a classe base <see cref="M:System.Windows.Forms.MenuItem.OnSelect(System.EventArgs)" /> método.</para></block>
      </Docs>
    </Member>
    <Member MemberName="OwnerDraw">
      <MemberSignature Language="C#" Value="public bool OwnerDraw { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool OwnerDraw" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.MenuItem.OwnerDraw" />
      <MemberSignature Language="VB.NET" Value="Public Property OwnerDraw As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool OwnerDraw { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.OwnerDraw : bool with get, set" Usage="System.Windows.Forms.MenuItem.OwnerDraw" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define um valor que indica se o código fornecido por você desenha o item de menu ou se o Windows desenha o item de menu.</summary>
        <value><see langword="true" /> se o item de menu deve ser desenhado usando código; <see langword="false" /> se o item de menu deve ser desenhado pelo Windows. O padrão é <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando o <xref:System.Windows.Forms.MenuItem.OwnerDraw%2A> estiver definida como `true`, você precisa lidar com todos os desenhos de item de menu. Você pode usar esse recurso para criar seu próprio menu especial exibe.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra um menu com um item de menu desenhados pelo proprietário. Este conjunto de exemplo o <xref:System.Windows.Forms.MenuItem.OwnerDraw%2A> propriedade e usa o `AddHandler` instrução e o `AddressOf` operador para designar um delegado para manipular o <xref:System.Windows.Forms.MenuItem.DrawItem> eventos. Para executar o exemplo, cole-o em um formulário que importa os <xref:System>, <xref:System.Windows.Forms>, e <xref:System.Drawing> namespaces. Chame `InitializeMenu` do construtor do formulário ou `Load` método.  
  
 [!code-cpp[System.Windows.Forms.MenuItemOwnerDraw#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.MenuItemOwnerDraw/CPP/form1.cpp#1)]
 [!code-csharp[System.Windows.Forms.MenuItemOwnerDraw#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.MenuItemOwnerDraw/CS/form1.cs#1)]
 [!code-vb[System.Windows.Forms.MenuItemOwnerDraw#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.MenuItemOwnerDraw/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Drawing.Graphics" />
        <altmember cref="T:System.Windows.Forms.Menu" />
      </Docs>
    </Member>
    <Member MemberName="Parent">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.Menu Parent { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.Menu Parent" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.MenuItem.Parent" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Parent As Menu" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Forms::Menu ^ Parent { System::Windows::Forms::Menu ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Parent : System.Windows.Forms.Menu" Usage="System.Windows.Forms.MenuItem.Parent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.Menu</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém um valor que indica o menu que contém esse item de menu.</summary>
        <value>Um <see cref="T:System.Windows.Forms.Menu" /> que representa o menu que contém esse item de menu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Você pode usar essa propriedade para obter o <xref:System.Windows.Forms.Menu> objeto para um submenu. Você pode converter o <xref:System.Windows.Forms.Menu> objeto retornado por essa propriedade para um <xref:System.Windows.Forms.MenuItem> objeto para manipulá-lo.  
  
   
  
## Examples  
 Neste exemplo, você cria um menu principal e um item de menu de nível superior `menuItem1` (`File`). Você também cria dois itens de menu `menuItem2` (`New`) e `menuItem3` (`Open`) e adicioná-los à lista de item de menu de `menuItem1`. Em seguida, verifique se `menuItem3` tem um pai menu, que é true e exibir as informações nesse menu pai na caixa de mensagem. Este exemplo requer que você tenha criado uma <xref:System.Windows.Forms.Form> chamado `Form1`.  
  
 [!code-cpp[ParentMenu#1](~/samples/snippets/cpp/VS_Snippets_Winforms/ParentMenu/CPP/form1.cpp#1)]
 [!code-csharp[ParentMenu#1](~/samples/snippets/csharp/VS_Snippets_Winforms/ParentMenu/CS/form1.cs#1)]
 [!code-vb[ParentMenu#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/ParentMenu/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PerformClick">
      <MemberSignature Language="C#" Value="public void PerformClick ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void PerformClick() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.MenuItem.PerformClick" />
      <MemberSignature Language="VB.NET" Value="Public Sub PerformClick ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void PerformClick();" />
      <MemberSignature Language="F#" Value="member this.PerformClick : unit -&gt; unit" Usage="menuItem.PerformClick " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gera um evento <see cref="E:System.Windows.Forms.Control.Click" /> para o <see cref="T:System.Windows.Forms.MenuItem" />, que simula um clique de um usuário.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Você pode usar esse menu para ativar um item de menu por meio de código sem passar qualquer informação de evento. Por exemplo, se você deseja ativar um menu de item com base em uma ação que ocorre em seu aplicativo, você pode chamar o <xref:System.Windows.Forms.MenuItem.PerformClick%2A> método para que <xref:System.Windows.Forms.MenuItem>.  
  
   
  
## Examples  
 Neste exemplo você clicar programaticamente um item de menu usando o `PerformClick` método. Primeiro, crie um menu principal (`mainMenu1`) e adicionar a ele dois itens de menu `menuItem1` (`File`) e `menuItem2` (`Edit`). Você também usar o <xref:System.Windows.Forms.MenuItem.Click> eventos para enviar dados para o manipulador de eventos quando um item de menu é clicado. Em seguida, você usa o `PerformClick` método clicar o `File` item de menu. Quando você inicia o aplicativo, o `File` item de menu é ativado, e uma caixa de mensagem que contém o texto "O arquivo de menu é clicado." é exibida na tela. O exemplo requer que você tenha criado uma <xref:System.Windows.Forms.Form> chamado `Form1`.  
  
 [!code-cpp[PerformClick#1](~/samples/snippets/cpp/VS_Snippets_Winforms/PerformClick/CPP/form1.cpp#1)]
 [!code-csharp[PerformClick#1](~/samples/snippets/csharp/VS_Snippets_Winforms/PerformClick/CS/form1.cs#1)]
 [!code-vb[PerformClick#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/PerformClick/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PerformSelect">
      <MemberSignature Language="C#" Value="public virtual void PerformSelect ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void PerformSelect() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.MenuItem.PerformSelect" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub PerformSelect ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void PerformSelect();" />
      <MemberSignature Language="F#" Value="abstract member PerformSelect : unit -&gt; unit&#xA;override this.PerformSelect : unit -&gt; unit" Usage="menuItem.PerformSelect " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Aciona o evento <see cref="E:System.Windows.Forms.MenuItem.Select" /> deste item de menu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método permite que você aumente o <xref:System.Windows.Forms.MenuItem.Select> evento sem transmitir qualquer informação de evento para o manipulador de eventos.  
  
   
  
## Examples  
 Neste exemplo, você seleciona um item de menu programaticamente usando o `PerformSelect` método. Primeiro, crie um menu principal (`mainMenu1`) e adicionar a ele dois itens de menu `menuItem1` (`File`) e `menuItem2` (`Edit`). Você também usar o <xref:System.Windows.Forms.MenuItem.Select> eventos para enviar dados para o manipulador de eventos quando um item de menu é selecionado. Em seguida, você usa o `PerformSelect` método para selecionar o `File` item de menu. Quando você inicia o aplicativo, o `File` item de menu é selecionado e uma caixa de mensagem que contém o texto "O arquivo de menu é selecionado." é exibida na tela. O exemplo requer que você tenha criado uma <xref:System.Windows.Forms.Form> chamado `Form1`.  
  
 [!code-cpp[PerformSelect#1](~/samples/snippets/cpp/VS_Snippets_Winforms/PerformSelect/CPP/form1.cpp#1)]
 [!code-csharp[PerformSelect#1](~/samples/snippets/csharp/VS_Snippets_Winforms/PerformSelect/CS/form1.cs#1)]
 [!code-vb[PerformSelect#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/PerformSelect/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.MenuItem.PerformClick" />
      </Docs>
    </Member>
    <Member MemberName="Popup">
      <MemberSignature Language="C#" Value="public event EventHandler Popup;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Popup" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.MenuItem.Popup" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Popup As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ Popup;" />
      <MemberSignature Language="F#" Value="member this.Popup : EventHandler " Usage="member this.Popup : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ocorre antes que a lista do item de menu seja exibida.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse evento ocorre somente quando um item de menu tem itens de submenu para exibir. Você pode usar este manipulador de eventos para adicionar, remover, habilitar, desabilitar, marque ou desmarque os itens de menu com base no estado do seu aplicativo antes que eles são exibidos. Para obter mais informações sobre como manipular eventos, consulte [tratando e gerando eventos](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como usar o <xref:System.Windows.Forms.MenuItem.Popup> evento para determinar se <xref:System.Windows.Forms.MenuItem> objetos que fornecem suporte para recortar, copiar e excluir operações estão ativados antes que eles são exibidos no menu é mostrado. O exemplo determina se `textBox1`, um <xref:System.Windows.Forms.TextBox> controle no formulário, está habilitado, tem o foco de entrada e tem texto selecionado antes de habilitar o <xref:System.Windows.Forms.MenuItem> objetos. Este exemplo requer que três <xref:System.Windows.Forms.MenuItem> os objetos são criados nomeados `menuCut`, `menuCopy`, e `menuDelete` foram criados.  
  
 [!code-cpp[MenuItem.Popup#1](~/samples/snippets/cpp/VS_Snippets_Winforms/MenuItem.Popup/CPP/form1.cpp#1)]
 [!code-csharp[MenuItem.Popup#1](~/samples/snippets/csharp/VS_Snippets_Winforms/MenuItem.Popup/CS/form1.cs#1)]
 [!code-vb[MenuItem.Popup#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/MenuItem.Popup/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RadioCheck">
      <MemberSignature Language="C#" Value="public bool RadioCheck { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool RadioCheck" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.MenuItem.RadioCheck" />
      <MemberSignature Language="VB.NET" Value="Public Property RadioCheck As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool RadioCheck { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.RadioCheck : bool with get, set" Usage="System.Windows.Forms.MenuItem.RadioCheck" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define um valor que indica se o <see cref="T:System.Windows.Forms.MenuItem" />, quando marcado, exibe um botão de opção em vez de uma marca de seleção.</summary>
        <value><see langword="true" /> se um botão de opção deve ser usado em vez de uma marca de seleção; <see langword="false" /> se a marca de seleção padrão deve ser exibida quando o item de menu está marcado. O padrão é <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Marcas de seleção não implicam, necessariamente, um estado mutuamente exclusivo para um grupo de itens de menu. Você pode usar essa propriedade para indicar ao usuário que a marca de seleção de um item de menu é mutuamente exclusiva.  
  
   
  
## Examples  
 O seguinte exemplo de código usa o <xref:System.Windows.Forms.MenuItem.Checked%2A> propriedade para alterar o estado de um aplicativo. No exemplo, um grupo de itens de menu são fornecidos para que são usados para especificar a cor do texto em um <xref:System.Windows.Forms.TextBox> controle. No exemplo, o manipulador de eventos fornecido é usado pelo <xref:System.Windows.Forms.MenuItem.Click> evento os três de itens de menu. Cada item de menu Especifica uma cor `menuItemRed`, `menuItemGreen`, ou `menuItemBlue`. O manipulador de eventos determina qual item de menu foi clicado, coloca uma marca de seleção para o item de menu selecionado e altera a cor do texto no formato <xref:System.Windows.Forms.TextBox> controle, chamado `textBox1`. O exemplo também usa o <xref:System.Windows.Forms.MenuItem.RadioCheck%2A> propriedade para demonstrar como uma verificação de botão de opção é usada para exibir itens de menu que são mutuamente exclusivos. Este exemplo requer que o <xref:System.Drawing?displayProperty=nameWithType> namespace foi adicionado ao formulário que contém esse código.  
  
 [!code-cpp[Classic MenuItem.RadioCheck Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic MenuItem.RadioCheck Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MenuItem.RadioCheck Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic MenuItem.RadioCheck Example/CS/source.cs#1)]
 [!code-vb[Classic MenuItem.RadioCheck Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic MenuItem.RadioCheck Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.MenuItem.Checked" />
      </Docs>
    </Member>
    <Member MemberName="Select">
      <MemberSignature Language="C#" Value="public event EventHandler Select;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Select" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.MenuItem.Select" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Select As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ Select;" />
      <MemberSignature Language="F#" Value="member this.Select : EventHandler " Usage="member this.Select : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ocorre quando o usuário coloca o ponteiro sobre um item de menu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse evento normalmente é gerado quando o usuário coloca o ponteiro do mouse sobre o item de menu. O evento também pode ser gerado quando o usuário realça um item de menu usando o teclado, rolando para o item de menu com as teclas de direção. Você pode usar esse evento para exibir uma cadeia de caracteres de ajuda detalhada que pertencem a este item de menu na barra de status do aplicativo. Para obter mais informações sobre como manipular eventos, consulte [tratando e gerando eventos](~/docs/standard/events/index.md).  
  
> [!NOTE]
>  Se o <xref:System.Windows.Forms.Menu.MenuItems%2A> propriedade para o <xref:System.Windows.Forms.MenuItem> contiver itens, esse evento não é gerado. Esse evento não é gerado para itens de menu pai.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como usar o <xref:System.Windows.Forms.MenuItem.Select> eventos do <xref:System.Windows.Forms.MenuItem> classe para atribuir texto de ajuda para um <xref:System.Windows.Forms.StatusBarPanel> de um <xref:System.Windows.Forms.StatusBar> controle. Este exemplo requer que <xref:System.Windows.Forms.MenuItem> objetos nomeados `menuOpen`, `menuSave`, e `menuExit` são adicionados a um <xref:System.Windows.Forms.MainMenu> controle em um formulário. O exemplo também requer que um <xref:System.Windows.Forms.StatusBar> controle, chamado `statusBar1` foi adicionado ao formulário. O <xref:System.Windows.Forms.StatusBar> controle deve conter um <xref:System.Windows.Forms.StatusBarPanel>.  
  
 [!code-cpp[MenuItem.Select#1](~/samples/snippets/cpp/VS_Snippets_Winforms/MenuItem.Select/CPP/form1.cpp#1)]
 [!code-csharp[MenuItem.Select#1](~/samples/snippets/csharp/VS_Snippets_Winforms/MenuItem.Select/CS/form1.cs#1)]
 [!code-vb[MenuItem.Select#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/MenuItem.Select/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Forms.MenuItem.Click" />
      </Docs>
    </Member>
    <Member MemberName="Shortcut">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.Shortcut Shortcut { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Forms.Shortcut Shortcut" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.MenuItem.Shortcut" />
      <MemberSignature Language="VB.NET" Value="Public Property Shortcut As Shortcut" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Forms::Shortcut Shortcut { System::Windows::Forms::Shortcut get(); void set(System::Windows::Forms::Shortcut value); };" />
      <MemberSignature Language="F#" Value="member this.Shortcut : System.Windows.Forms.Shortcut with get, set" Usage="System.Windows.Forms.MenuItem.Shortcut" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.Shortcut</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define um valor que indica a tecla de atalho associada ao item de menu.</summary>
        <value>Um dos valores de <see cref="T:System.Windows.Forms.Shortcut" />. O padrão é <see langword="Shortcut.None" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Teclas de atalho fornecem um método para que os usuários sejam ativados frequentemente usadas itens de menu em seu sistema de menu e fornecer acesso de teclado ao seu aplicativo para os usuários que não têm acesso a um mouse ou outro dispositivo de ponteiro.  
  
   
  
## Examples  
 O exemplo de código a seguir cria um item de menu, define a legenda, atribui uma tecla de atalho, torna o item de menu visível e mostra a exibição de chave de atalho para o item de menu. O exemplo requer que um <xref:System.Windows.Forms.MenuItem> tiver sido criado que é chamado `menuItem1`.  
  
 [!code-cpp[Classic MenuItem.Text Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic MenuItem.Text Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MenuItem.Text Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic MenuItem.Text Example/CS/source.cs#1)]
 [!code-vb[Classic MenuItem.Text Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic MenuItem.Text Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">O valor atribuído não é um dos valores <see cref="T:System.Windows.Forms.Shortcut" />.</exception>
        <altmember cref="T:System.Windows.Forms.Shortcut" />
      </Docs>
    </Member>
    <Member MemberName="ShowShortcut">
      <MemberSignature Language="C#" Value="public bool ShowShortcut { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ShowShortcut" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.MenuItem.ShowShortcut" />
      <MemberSignature Language="VB.NET" Value="Public Property ShowShortcut As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool ShowShortcut { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.ShowShortcut : bool with get, set" Usage="System.Windows.Forms.MenuItem.ShowShortcut" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define um valor que indica se a tecla de atalho associada ao item de menu é exibida ao lado da legenda do item de menu.</summary>
        <value><see langword="true" /> Se a combinação de teclas de atalho é exibida ao lado da legenda do item de menu; <see langword="false" /> se a combinação de teclas de atalho não será exibido. O padrão é <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Você pode usar essa propriedade para fornecer a opção para os usuários ocultem atalhos de menus para conservar o espaço de menu ou ocultar uma tecla de atalho que está sendo exibida.  
  
   
  
## Examples  
 O exemplo de código a seguir cria um item de menu, define a legenda, atribui uma tecla de atalho, torna o item de menu visível e mostra a exibição de chave de atalho para o item de menu. O exemplo requer que um <xref:System.Windows.Forms.MenuItem> tiver sido criado que é chamado `menuItem1`.  
  
 [!code-cpp[Classic MenuItem.Text Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic MenuItem.Text Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MenuItem.Text Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic MenuItem.Text Example/CS/source.cs#1)]
 [!code-vb[Classic MenuItem.Text Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic MenuItem.Text Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.MenuItem.Shortcut" />
      </Docs>
    </Member>
    <Member MemberName="Text">
      <MemberSignature Language="C#" Value="public string Text { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Text" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.MenuItem.Text" />
      <MemberSignature Language="VB.NET" Value="Public Property Text As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Text { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Text : string with get, set" Usage="System.Windows.Forms.MenuItem.Text" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define um valor que indica a legenda do item de menu.</summary>
        <value>A legenda de texto do item de menu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando você especificar uma legenda para o item de menu, você também pode especificar uma chave de acesso, colocando um '&' antes do caractere a ser usado como a chave de acesso. Por exemplo, para especificar o "F" em "Arquivo" como uma chave de acesso, você deve especificar a legenda do item de menu como "& arquivo". Você pode usar esse recurso para fornecer uma navegação de teclado para seus menus.  
  
 Definir essa propriedade como "`-`" faz com que o item de menu a ser exibido como um separador (uma linha horizontal) em vez de um item de menu padrão.  
  
   
  
## Examples  
 O exemplo de código a seguir cria um item de menu, define a legenda, atribui uma tecla de atalho, torna o item de menu visível e mostra a exibição de chave de atalho para o item de menu. O exemplo requer que um <xref:System.Windows.Forms.MenuItem> tiver sido criado que é chamado `menuItem1`.  
  
 [!code-cpp[Classic MenuItem.Text Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic MenuItem.Text Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MenuItem.Text Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic MenuItem.Text Example/CS/source.cs#1)]
 [!code-vb[Classic MenuItem.Text Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic MenuItem.Text Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.MenuItem.Mnemonic" />
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.MenuItem.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="menuItem.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retorna uma cadeia de caracteres que representa o <see cref="T:System.Windows.Forms.MenuItem" />.</summary>
        <returns>Uma cadeia de caracteres que representa o <see cref="T:System.Windows.Forms.MenuItem" /> atual. A cadeia de caracteres inclui o tipo e a propriedade <see cref="P:System.Windows.Forms.MenuItem.Text" /> do controle.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Visible">
      <MemberSignature Language="C#" Value="public bool Visible { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Visible" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.MenuItem.Visible" />
      <MemberSignature Language="VB.NET" Value="Public Property Visible As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Visible { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.Visible : bool with get, set" Usage="System.Windows.Forms.MenuItem.Visible" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define um valor que indica se o item de menu está visível.</summary>
        <value><see langword="true" /> se o item de menu ficar visível no menu; caso contrário, <see langword="false" />. O padrão é <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Você pode usar essa propriedade para modificar uma estrutura de menu sem ter que mesclar menus ou desativar os menus. Por exemplo, se você quiser ocultar uma seção completa da funcionalidade dos menus para seu aplicativo, você pode ocultá-los do usuário definindo essa propriedade como `false`.  
  
   
  
## Examples  
 O exemplo de código a seguir cria um item de menu, define a legenda, atribui uma tecla de atalho, torna o item de menu visível e mostra a exibição de chave de atalho para o item de menu. O exemplo requer que um <xref:System.Windows.Forms.MenuItem> tiver sido criado que é chamado `menuItem1`.  
  
 [!code-cpp[Classic MenuItem.Text Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic MenuItem.Text Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MenuItem.Text Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic MenuItem.Text Example/CS/source.cs#1)]
 [!code-vb[Classic MenuItem.Text Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic MenuItem.Text Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>