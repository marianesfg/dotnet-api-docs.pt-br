<Type Name="XamlDirective" FullName="System.Xaml.XamlDirective">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="e483cb7bc238978ad2c332188cea604cbba11358" />
    <Meta Name="ms.sourcegitcommit" Value="434f60616a9793fa8436744549fc856e94f7a648" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="pt-BR" />
    <Meta Name="ms.lasthandoff" Value="08/25/2018" />
    <Meta Name="ms.locfileid" Value="39994861" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class XamlDirective : System.Xaml.XamlMember" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit XamlDirective extends System.Xaml.XamlMember" />
  <TypeSignature Language="DocId" Value="T:System.Xaml.XamlDirective" />
  <TypeSignature Language="VB.NET" Value="Public Class XamlDirective&#xA;Inherits XamlMember" />
  <TypeSignature Language="C++ CLI" Value="public ref class XamlDirective : System::Xaml::XamlMember" />
  <TypeSignature Language="F#" Value="type XamlDirective = class&#xA;    inherit XamlMember" />
  <AssemblyInfo>
    <AssemblyName>System.Xaml</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Xaml.XamlMember</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Fornece o identificador do sistema tipo XAML para um membro se o membro também for uma diretiva XAML. Leitores XAML e gravadores XAML usam o identificador <see cref="T:System.Xaml.XamlDirective" /> durante o processamento de nós membro. O identificador é usado quando o leitor XAML é posicionado em um <see cref="F:System.Xaml.XamlNodeType.StartMember" /> e <see cref="P:System.Xaml.XamlMember.IsDirective" /> é <see langword="true" />.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Xaml.XamlDirective> fornece valores esperados para o sistema de tipos XAML quando o membro é uma diretiva XAML. Por definição, uma diretiva XAML tem características que sempre retornam os mesmos resultados para um subconjunto do <xref:System.Xaml.XamlMember> propriedades e as mesmas informações de sistema de tipo XAML é relatado para todos os possíveis diretivas XAML. A emissão de relatórios de características do sistema de tipo XAML são específicas para diretivas é realizada pelo comportamento interno ou por meio de substituições de <xref:System.Xaml.XamlMember> `Lookup*` membros virtuais no <xref:System.Xaml.XamlDirective> classe.  
  
 A lista a seguir mostra os resultados retornados de uma diretiva XAML para <xref:System.Xaml.XamlMember> quando o membro é realmente um <xref:System.Xaml.XamlDirective>:  
  
-   <xref:System.Xaml.XamlMember.LookupCustomAttributeProvider%2A> é sempre `null`.  
  
-   <xref:System.Xaml.XamlMember.DeferringLoader%2A> é sempre `null`.  
  
-   <xref:System.Xaml.XamlMember.DependsOn%2A> é sempre `null`.  
  
-   <xref:System.Xaml.XamlMember.IsAmbient%2A> é sempre `false`.  
  
-   <xref:System.Xaml.XamlMember.IsAttachable%2A> é sempre `false`.  
  
-   <xref:System.Xaml.XamlMember.IsDirective%2A> é sempre `true`.  
  
-   <xref:System.Xaml.XamlMember.IsEvent%2A> é sempre `false`.  
  
-   <xref:System.Xaml.XamlMember.IsReadOnly%2A> é sempre `false`.  
  
-   <xref:System.Xaml.XamlMember.IsReadPublic%2A> é sempre `true`.  
  
-   <xref:System.Xaml.XamlMember.IsWritePublic%2A> é sempre `true`.  
  
 Além disso, o suporte interno para <xref:System.Xaml.XamlMember.DeclaringType%2A> mantém indefinido e retorna `null`.  
  
> [!IMPORTANT]
>  <xref:System.Xaml.XamlDirective> é um <xref:System.Xaml.XamlMember> subclasse. Assim como acontece com <xref:System.Xaml.XamlMember>, <xref:System.Xaml.XamlDirective> tem considerações de segurança sobre como o sistema de tipos XAML relatórios o acesso. Consulte <xref:System.Xaml.XamlMember>.  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Xaml.XamlMember" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicializa uma nova instância da classe <see cref="T:System.Xaml.XamlDirective" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XamlDirective (string xamlNamespace, string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string xamlNamespace, string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlDirective.#ctor(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (xamlNamespace As String, name As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; XamlDirective(System::String ^ xamlNamespace, System::String ^ name);" />
      <MemberSignature Language="F#" Value="new System.Xaml.XamlDirective : string * string -&gt; System.Xaml.XamlDirective" Usage="new System.Xaml.XamlDirective (xamlNamespace, name)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="xamlNamespace" Type="System.String" />
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="xamlNamespace">O namespace XAML primário em que este <see cref="T:System.Xaml.XamlDirective" /> pode existir.</param>
        <param name="name">O nome de identificação do <see cref="T:System.Xaml.XamlDirective" />.</param>
        <summary>Inicializa uma nova instância da classe <see cref="T:System.Xaml.XamlDirective" />, especificando valores para um nome e um namespace XAML único. Use esta assinatura somente quando você quiser ou esperar que <see cref="P:System.Xaml.XamlMember.IsUnknown" /> relate <see langword="true" /> para a diretiva.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  Essa assinatura do construtor sempre gera um identificador para a diretiva onde <xref:System.Xaml.XamlMember.IsUnknown%2A> relatórios `true` sistema de tipo para o XAML. Se as informações necessárias estão disponíveis (o tipo de suporte e um item de informações de sintaxe de texto para conversão) e desejar que um identificador que pode aplicar a diretiva, use o <xref:System.Xaml.XamlDirective.%23ctor%2A?displayProperty=nameWithType> assinatura de construtor em vez disso.  
  
 Se você usar essa assinatura, o <xref:System.Xaml.XamlDirective.AllowedLocation%2A> de valor para a instância é <xref:System.Xaml.Schema.AllowedMemberLocations.Any>; e o <xref:System.Xaml.XamlMember.Type%2A> valor e <xref:System.Xaml.XamlMember.TypeConverter%2A> valor são ambos `null`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XamlDirective (System.Collections.Generic.IEnumerable&lt;string&gt; xamlNamespaces, string name, System.Xaml.XamlType xamlType, System.Xaml.Schema.XamlValueConverter&lt;System.ComponentModel.TypeConverter&gt; typeConverter, System.Xaml.Schema.AllowedMemberLocations allowedLocation);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Collections.Generic.IEnumerable`1&lt;string&gt; xamlNamespaces, string name, class System.Xaml.XamlType xamlType, class System.Xaml.Schema.XamlValueConverter`1&lt;class System.ComponentModel.TypeConverter&gt; typeConverter, valuetype System.Xaml.Schema.AllowedMemberLocations allowedLocation) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlDirective.#ctor(System.Collections.Generic.IEnumerable{System.String},System.String,System.Xaml.XamlType,System.Xaml.Schema.XamlValueConverter{System.ComponentModel.TypeConverter},System.Xaml.Schema.AllowedMemberLocations)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; XamlDirective(System::Collections::Generic::IEnumerable&lt;System::String ^&gt; ^ xamlNamespaces, System::String ^ name, System::Xaml::XamlType ^ xamlType, System::Xaml::Schema::XamlValueConverter&lt;System::ComponentModel::TypeConverter ^&gt; ^ typeConverter, System::Xaml::Schema::AllowedMemberLocations allowedLocation);" />
      <MemberSignature Language="F#" Value="new System.Xaml.XamlDirective : seq&lt;string&gt; * string * System.Xaml.XamlType * System.Xaml.Schema.XamlValueConverter&lt;System.ComponentModel.TypeConverter&gt; * System.Xaml.Schema.AllowedMemberLocations -&gt; System.Xaml.XamlDirective" Usage="new System.Xaml.XamlDirective (xamlNamespaces, name, xamlType, typeConverter, allowedLocation)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="xamlNamespaces" Type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" />
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="xamlType" Type="System.Xaml.XamlType" />
        <Parameter Name="typeConverter" Type="System.Xaml.Schema.XamlValueConverter&lt;System.ComponentModel.TypeConverter&gt;" />
        <Parameter Name="allowedLocation" Type="System.Xaml.Schema.AllowedMemberLocations" />
      </Parameters>
      <Docs>
        <param name="xamlNamespaces">Um conjunto de namespaces XAML em que este <see cref="T:System.Xaml.XamlDirective" /> pode existir, passado como um conjunto enumerável de cadeias de caracteres identificadoras.</param>
        <param name="name">O nome de identificação do <see cref="T:System.Xaml.XamlDirective" />.</param>
        <param name="xamlType">O tipo de XAML que faz o <see cref="T:System.Xaml.XamlDirective" />.</param>
        <param name="typeConverter">O conversor de tipo que este <see cref="T:System.Xaml.XamlDirective" /> usa para conversão de sintaxe do texto.</param>
        <param name="allowedLocation">Um valor da enumeração <see cref="T:System.Xaml.Schema.AllowedMemberLocations" />.</param>
        <summary>Inicializa uma nova instância da classe <see cref="T:System.Xaml.XamlDirective" />, especificando valores para cada valor por caso de um <see cref="T:System.Xaml.XamlDirective" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Você deve usar esse construtor para gerar uma <xref:System.Xaml.XamlDirective> não relata <xref:System.Xaml.XamlMember.IsUnknown%2A> como `true`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">O parâmetro <paramref name="xamlType" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="AllowedLocation">
      <MemberSignature Language="C#" Value="public System.Xaml.Schema.AllowedMemberLocations AllowedLocation { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Xaml.Schema.AllowedMemberLocations AllowedLocation" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlDirective.AllowedLocation" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property AllowedLocation As AllowedMemberLocations" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Xaml::Schema::AllowedMemberLocations AllowedLocation { System::Xaml::Schema::AllowedMemberLocations get(); };" />
      <MemberSignature Language="F#" Value="member this.AllowedLocation : System.Xaml.Schema.AllowedMemberLocations" Usage="System.Xaml.XamlDirective.AllowedLocation" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Xaml.Schema.AllowedMemberLocations</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém um valor que especifica os tipos de nó XAML em que a diretiva pode ser especificada.</summary>
        <value>Um valor da enumeração. O padrão é o padrão de enumeração, que é <see cref="F:System.Xaml.Schema.AllowedMemberLocations.None" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Você pode definir esse valor <xref:System.Xaml.XamlDirective.%23ctor%28System.Collections.Generic.IEnumerable%7BSystem.String%7D%2CSystem.String%2CSystem.Xaml.XamlType%2CSystem.Xaml.Schema.XamlValueConverter%7BSystem.ComponentModel.TypeConverter%7D%2CSystem.Xaml.Schema.AllowedMemberLocations%29> assinatura de construtor. Se você construir usando o <xref:System.Xaml.XamlDirective.%23ctor%28System.String%2CSystem.String%29> assinatura de construtor, o <xref:System.Xaml.XamlDirective.AllowedLocation%2A> valor para a instância é <xref:System.Xaml.Schema.AllowedMemberLocations.Any>. No entanto, a instância sempre informa <xref:System.Xaml.XamlMember.IsUnknown%2A> como `true`. Normalmente, esse comportamento afeta tentativas de gravar os gráficos de objeto e também afeta outros usos práticos de uma <xref:System.Xaml.XamlMember> valor.  
  
 Você normalmente não seria criar um caso de diretiva de XAML em que <xref:System.Xaml.XamlDirective.AllowedLocation%2A> é <xref:System.Xaml.Schema.AllowedMemberLocations.None?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlDirective.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="xamlDirective.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retorna o código hash para esse objeto.</summary>
        <returns>Um código hash inteiro.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetXamlNamespaces">
      <MemberSignature Language="C#" Value="public override System.Collections.Generic.IList&lt;string&gt; GetXamlNamespaces ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Collections.Generic.IList`1&lt;string&gt; GetXamlNamespaces() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlDirective.GetXamlNamespaces" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetXamlNamespaces () As IList(Of String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Collections::Generic::IList&lt;System::String ^&gt; ^ GetXamlNamespaces();" />
      <MemberSignature Language="F#" Value="override this.GetXamlNamespaces : unit -&gt; System.Collections.Generic.IList&lt;string&gt;" Usage="xamlDirective.GetXamlNamespaces " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IList&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retorna uma lista de namespaces XAML em que esse membro XAML pode existir.</summary>
        <returns>Uma lista de identificadores de namespace XAML, como cadeias de caracteres.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Os identificadores de namespace XAML são cadeias de caracteres que normalmente são exibidos na forma de cadeia de caracteres de identificador de recurso uniforme (URI) acordo com as convenções comuns para namespaces XAML e XML. Se a lista contiver mais de um item, o primeiro item no conjunto de geralmente é o namespace XAML primário relevante para fins de processamento e os outros itens são alternativas. <xref:System.Xaml.XamlMember.PreferredXamlNamespace%2A?displayProperty=nameWithType> se baseia nesta ordem.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupCustomAttributeProvider">
      <MemberSignature Language="C#" Value="protected override sealed System.Reflection.ICustomAttributeProvider LookupCustomAttributeProvider ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance class System.Reflection.ICustomAttributeProvider LookupCustomAttributeProvider() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlDirective.LookupCustomAttributeProvider" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides NotOverridable Function LookupCustomAttributeProvider () As ICustomAttributeProvider" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override System::Reflection::ICustomAttributeProvider ^ LookupCustomAttributeProvider();" />
      <MemberSignature Language="F#" Value="override this.LookupCustomAttributeProvider : unit -&gt; System.Reflection.ICustomAttributeProvider" Usage="xamlDirective.LookupCustomAttributeProvider " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.ICustomAttributeProvider</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retorna um implementação de <see cref="T:System.Reflection.ICustomAttributeProvider" />. Essa implementação sempre retorna <see langword="null" />.</summary>
        <returns>Sempre retorna <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Porque uma diretiva XAML não pode ter atributos personalizados, essa implementação sempre retorna `null`. <xref:System.Xaml.XamlDirective> lacra a esse membro virtual; Portanto, todas as <xref:System.Xaml.XamlDirective> tipos e todas as diretivas predefinidas de XAML devem usar esse comportamento.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupDeferringLoader">
      <MemberSignature Language="C#" Value="protected override sealed System.Xaml.Schema.XamlValueConverter&lt;System.Xaml.XamlDeferringLoader&gt; LookupDeferringLoader ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance class System.Xaml.Schema.XamlValueConverter`1&lt;class System.Xaml.XamlDeferringLoader&gt; LookupDeferringLoader() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlDirective.LookupDeferringLoader" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides NotOverridable Function LookupDeferringLoader () As XamlValueConverter(Of XamlDeferringLoader)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override System::Xaml::Schema::XamlValueConverter&lt;System::Xaml::XamlDeferringLoader ^&gt; ^ LookupDeferringLoader();" />
      <MemberSignature Language="F#" Value="override this.LookupDeferringLoader : unit -&gt; System.Xaml.Schema.XamlValueConverter&lt;System.Xaml.XamlDeferringLoader&gt;" Usage="xamlDirective.LookupDeferringLoader " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.Schema.XamlValueConverter&lt;System.Xaml.XamlDeferringLoader&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retorna um objeto <see cref="T:System.Xaml.Schema.XamlValueConverter`1" />, que é usado durante o carregamento adiado de objetos declarados em XAML. Essa implementação sempre retorna <see langword="null" />.</summary>
        <returns>Sempre retorna <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Porque uma diretiva não pode ter adiado o carregamento, essa implementação sempre retorna `null`. <xref:System.Xaml.XamlDirective> lacra a esse membro virtual; Portanto, todas as <xref:System.Xaml.XamlDirective> tipos e todas as diretivas predefinidas de XAML devem usar esse comportamento.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Xaml.XamlMember.DeferringLoader" />
      </Docs>
    </Member>
    <Member MemberName="LookupDependsOn">
      <MemberSignature Language="C#" Value="protected override sealed System.Collections.Generic.IList&lt;System.Xaml.XamlMember&gt; LookupDependsOn ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance class System.Collections.Generic.IList`1&lt;class System.Xaml.XamlMember&gt; LookupDependsOn() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlDirective.LookupDependsOn" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides NotOverridable Function LookupDependsOn () As IList(Of XamlMember)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override System::Collections::Generic::IList&lt;System::Xaml::XamlMember ^&gt; ^ LookupDependsOn();" />
      <MemberSignature Language="F#" Value="override this.LookupDependsOn : unit -&gt; System.Collections.Generic.IList&lt;System.Xaml.XamlMember&gt;" Usage="xamlDirective.LookupDependsOn " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IList&lt;System.Xaml.XamlMember&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retorna uma lista de objetos <see cref="T:System.Xaml.XamlMember" />. A lista relata os membros em que há relações de dependência para a ordem de inicialização em relação a esse <see cref="T:System.Xaml.XamlMember" />. Essa implementação sempre retorna <see langword="null" />.</summary>
        <returns>Sempre retorna <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Porque uma diretiva XAML não pode ter uma ordem de inicialização, essa implementação sempre retorna `null`. <xref:System.Xaml.XamlDirective> lacra a esse membro virtual; Portanto, todas as <xref:System.Xaml.XamlDirective> tipos e todas as diretivas predefinidas de XAML devem usar esse comportamento.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Xaml.XamlMember.DependsOn" />
      </Docs>
    </Member>
    <Member MemberName="LookupInvoker">
      <MemberSignature Language="C#" Value="protected override sealed System.Xaml.Schema.XamlMemberInvoker LookupInvoker ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance class System.Xaml.Schema.XamlMemberInvoker LookupInvoker() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlDirective.LookupInvoker" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides NotOverridable Function LookupInvoker () As XamlMemberInvoker" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override System::Xaml::Schema::XamlMemberInvoker ^ LookupInvoker();" />
      <MemberSignature Language="F#" Value="override this.LookupInvoker : unit -&gt; System.Xaml.Schema.XamlMemberInvoker" Usage="xamlDirective.LookupInvoker " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.Schema.XamlMemberInvoker</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retorna o <see cref="T:System.Xaml.Schema.XamlMemberInvoker" /> que é associado a um <see cref="T:System.Xaml.XamlDirective" />.</summary>
        <returns>As informações de <see cref="T:System.Xaml.Schema.XamlMemberInvoker" /> para este <see cref="T:System.Xaml.XamlMember" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método pode ser chamado por chamadas para <xref:System.Xaml.XamlMember.Invoker%2A>.  
  
 Essa implementação retorna um estático interno <xref:System.Xaml.Schema.XamlMemberInvoker> valor específico para as diretivas no sistema de tipos XAML. <xref:System.Xaml.XamlDirective> lacra a esse membro virtual; Portanto, todas as <xref:System.Xaml.XamlDirective> tipos e todas as diretivas predefinidas de XAML devem usar esse comportamento.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Xaml.XamlMember.Invoker" />
      </Docs>
    </Member>
    <Member MemberName="LookupIsAmbient">
      <MemberSignature Language="C#" Value="protected override sealed bool LookupIsAmbient ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance bool LookupIsAmbient() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlDirective.LookupIsAmbient" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides NotOverridable Function LookupIsAmbient () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override bool LookupIsAmbient();" />
      <MemberSignature Language="F#" Value="override this.LookupIsAmbient : unit -&gt; bool" Usage="xamlDirective.LookupIsAmbient " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retorna se este <see cref="T:System.Xaml.XamlMember" /> é relatado como uma propriedade de ambiente.</summary>
        <returns>Sempre retorna <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Como uma diretiva XAML não pode ser um tipo de ambiente, essa implementação sempre retorna `false`. <xref:System.Xaml.XamlDirective> lacra a esse membro virtual; Portanto, todas as <xref:System.Xaml.XamlDirective> tipos e todas as diretivas predefinidas de XAML devem usar esse comportamento.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Xaml.XamlMember.LookupIsAmbient" />
      </Docs>
    </Member>
    <Member MemberName="LookupIsEvent">
      <MemberSignature Language="C#" Value="protected override sealed bool LookupIsEvent ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance bool LookupIsEvent() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlDirective.LookupIsEvent" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides NotOverridable Function LookupIsEvent () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override bool LookupIsEvent();" />
      <MemberSignature Language="F#" Value="override this.LookupIsEvent : unit -&gt; bool" Usage="xamlDirective.LookupIsEvent " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retorna se este <see cref="T:System.Xaml.XamlDirective" /> representa um evento.</summary>
        <returns>Sempre retorna <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Xaml.XamlDirective> lacra a esse membro virtual; Portanto, todas as <xref:System.Xaml.XamlDirective> tipos e todas as diretivas predefinidas de XAML devem usar esse comportamento.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Xaml.XamlMember.IsEvent" />
      </Docs>
    </Member>
    <Member MemberName="LookupIsReadOnly">
      <MemberSignature Language="C#" Value="protected override sealed bool LookupIsReadOnly ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance bool LookupIsReadOnly() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlDirective.LookupIsReadOnly" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides NotOverridable Function LookupIsReadOnly () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override bool LookupIsReadOnly();" />
      <MemberSignature Language="F#" Value="override this.LookupIsReadOnly : unit -&gt; bool" Usage="xamlDirective.LookupIsReadOnly " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retorna se este <see cref="T:System.Xaml.XamlDirective" /> representa uma propriedade somente leitura pretendida.</summary>
        <returns>Sempre retorna <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Por definição, as diretivas são configuráveis. <xref:System.Xaml.XamlDirective> lacra a esse membro virtual; Portanto, todas as <xref:System.Xaml.XamlDirective> tipos e todas as diretivas predefinidas de XAML devem usar esse comportamento.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Xaml.XamlMember.IsReadOnly" />
      </Docs>
    </Member>
    <Member MemberName="LookupIsReadPublic">
      <MemberSignature Language="C#" Value="protected override sealed bool LookupIsReadPublic ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance bool LookupIsReadPublic() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlDirective.LookupIsReadPublic" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides NotOverridable Function LookupIsReadPublic () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override bool LookupIsReadPublic();" />
      <MemberSignature Language="F#" Value="override this.LookupIsReadPublic : unit -&gt; bool" Usage="xamlDirective.LookupIsReadPublic " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retorna se este <see cref="T:System.Xaml.XamlDirective" /> representa uma propriedade que tem um acessador <see langword="get" /> público.</summary>
        <returns>Sempre retorna <see langword="true" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Xaml.XamlDirective> lacra a esse membro virtual; Portanto, todas as <xref:System.Xaml.XamlDirective> tipos e todas as diretivas predefinidas de XAML devem usar esse comportamento.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Xaml.XamlMember.IsReadPublic" />
      </Docs>
    </Member>
    <Member MemberName="LookupIsUnknown">
      <MemberSignature Language="C#" Value="protected override sealed bool LookupIsUnknown ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance bool LookupIsUnknown() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlDirective.LookupIsUnknown" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides NotOverridable Function LookupIsUnknown () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override bool LookupIsUnknown();" />
      <MemberSignature Language="F#" Value="override this.LookupIsUnknown : unit -&gt; bool" Usage="xamlDirective.LookupIsUnknown " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retorna se este <see cref="T:System.Xaml.XamlDirective" /> representa um membro que não pode ser resolvido pelo sistema de backup que é usado para a resolução de tipo e membro.</summary>
        <returns>
          <see langword="true" /> se este <see cref="T:System.Xaml.XamlDirective" /> representar um membro não pode ser resolvido; caso contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Xaml.XamlDirective> implementação apenas chama base e não faz nada mais. A implementação base retorna os resultados nesta ordem: os resultados são baseados em reflexão interno; ou os resultados baseiam-se sobre a verificação de um valor nulo a <xref:System.Xaml.XamlMember.UnderlyingMember%2A>. O <xref:System.Xaml.XamlDirective> implementação lacra isso virtual membro; portanto, todos <xref:System.Xaml.XamlDirective> tipos e todas as diretivas predefinidas de XAML devem usar esse comportamento.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupIsWriteOnly">
      <MemberSignature Language="C#" Value="protected override sealed bool LookupIsWriteOnly ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance bool LookupIsWriteOnly() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlDirective.LookupIsWriteOnly" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides NotOverridable Function LookupIsWriteOnly () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override bool LookupIsWriteOnly();" />
      <MemberSignature Language="F#" Value="override this.LookupIsWriteOnly : unit -&gt; bool" Usage="xamlDirective.LookupIsWriteOnly " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retorna se este <see cref="T:System.Xaml.XamlDirective" /> representa uma propriedade somente gravação pretendida.</summary>
        <returns>Sempre retorna <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Xaml.XamlDirective> lacra a esse membro virtual; Portanto, todas as <xref:System.Xaml.XamlDirective> tipos e todas as diretivas predefinidas de XAML devem usar esse comportamento.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Xaml.XamlMember.IsWriteOnly" />
      </Docs>
    </Member>
    <Member MemberName="LookupIsWritePublic">
      <MemberSignature Language="C#" Value="protected override sealed bool LookupIsWritePublic ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance bool LookupIsWritePublic() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlDirective.LookupIsWritePublic" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides NotOverridable Function LookupIsWritePublic () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override bool LookupIsWritePublic();" />
      <MemberSignature Language="F#" Value="override this.LookupIsWritePublic : unit -&gt; bool" Usage="xamlDirective.LookupIsWritePublic " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retorna se este <see cref="T:System.Xaml.XamlDirective" /> representa uma propriedade que tem um acessador <see langword="set" /> público.</summary>
        <returns>Sempre retorna <see langword="true" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Xaml.XamlDirective> lacra a esse membro virtual; Portanto, todas as <xref:System.Xaml.XamlDirective> tipos e todas as diretivas predefinidas de XAML devem usar esse comportamento.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Xaml.XamlMember.IsWritePublic" />
      </Docs>
    </Member>
    <Member MemberName="LookupTargetType">
      <MemberSignature Language="C#" Value="protected override sealed System.Xaml.XamlType LookupTargetType ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance class System.Xaml.XamlType LookupTargetType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlDirective.LookupTargetType" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides NotOverridable Function LookupTargetType () As XamlType" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override System::Xaml::XamlType ^ LookupTargetType();" />
      <MemberSignature Language="F#" Value="override this.LookupTargetType : unit -&gt; System.Xaml.XamlType" Usage="xamlDirective.LookupTargetType " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.XamlType</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retorna o <see cref="T:System.Xaml.XamlType" /> do tipo em que o <see cref="T:System.Xaml.XamlMember" /> pode existir. Essa implementação sempre retorna <see langword="null" />.</summary>
        <returns>Sempre retorna <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Tipos de destino não são relevantes para diretivas; Portanto, essa implementação sempre retorna `null`. <xref:System.Xaml.XamlDirective> lacra a esse membro virtual; Portanto, todas as <xref:System.Xaml.XamlDirective> tipos e todas as diretivas predefinidas de XAML devem usar esse comportamento.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Xaml.XamlMember.TargetType" />
      </Docs>
    </Member>
    <Member MemberName="LookupType">
      <MemberSignature Language="C#" Value="protected override sealed System.Xaml.XamlType LookupType ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance class System.Xaml.XamlType LookupType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlDirective.LookupType" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides NotOverridable Function LookupType () As XamlType" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override System::Xaml::XamlType ^ LookupType();" />
      <MemberSignature Language="F#" Value="override this.LookupType : unit -&gt; System.Xaml.XamlType" Usage="xamlDirective.LookupType " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.XamlType</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retorna o <see cref="T:System.Xaml.XamlType" /> do tipo que é usado pelo membro.</summary>
        <returns>O <see cref="T:System.Xaml.XamlType" /> do tipo que é usado pelo membro.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Xaml.XamlDirective> implementação apenas chama base e não faz nada mais. A implementação base retorna os resultados com base em reflexão interno ou procurando um valor nulo de <xref:System.Xaml.XamlMember.UnderlyingMember%2A>, o processamento, nessa ordem. <xref:System.Xaml.XamlDirective> lacra a esse membro virtual; Portanto, todas as <xref:System.Xaml.XamlDirective> tipos e todas as diretivas predefinidas de XAML devem usar esse comportamento.  
  
 Consulte os comentários no <xref:System.Xaml.XamlMember.LookupType%2A?displayProperty=nameWithType> para obter mais informações sobre quais informações <xref:System.Xaml.XamlMember.Type%2A> executa.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Xaml.XamlMember.Type" />
      </Docs>
    </Member>
    <Member MemberName="LookupTypeConverter">
      <MemberSignature Language="C#" Value="protected override sealed System.Xaml.Schema.XamlValueConverter&lt;System.ComponentModel.TypeConverter&gt; LookupTypeConverter ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance class System.Xaml.Schema.XamlValueConverter`1&lt;class System.ComponentModel.TypeConverter&gt; LookupTypeConverter() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlDirective.LookupTypeConverter" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides NotOverridable Function LookupTypeConverter () As XamlValueConverter(Of TypeConverter)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override System::Xaml::Schema::XamlValueConverter&lt;System::ComponentModel::TypeConverter ^&gt; ^ LookupTypeConverter();" />
      <MemberSignature Language="F#" Value="override this.LookupTypeConverter : unit -&gt; System.Xaml.Schema.XamlValueConverter&lt;System.ComponentModel.TypeConverter&gt;" Usage="xamlDirective.LookupTypeConverter " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.Schema.XamlValueConverter&lt;System.ComponentModel.TypeConverter&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retorna uma implementação do conversos de tipo associado a este <see cref="T:System.Xaml.XamlDirective" />.</summary>
        <returns>Uma instância de <see cref="T:System.Xaml.Schema.XamlValueConverter`1" /> que tem uma restrição <see cref="T:System.ComponentModel.TypeConverter" />; ou <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Xaml.XamlDirective> implementação apenas chama base e não faz nada mais. Consulte <xref:System.Xaml.XamlMember.LookupTypeConverter%2A?displayProperty=nameWithType>. <xref:System.Xaml.XamlDirective> lacra a esse membro virtual; Portanto, todas as <xref:System.Xaml.XamlDirective> tipos e todas as diretivas predefinidas de XAML devem usar esse comportamento.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Xaml.XamlMember.Type" />
      </Docs>
    </Member>
    <Member MemberName="LookupUnderlyingGetter">
      <MemberSignature Language="C#" Value="protected override sealed System.Reflection.MethodInfo LookupUnderlyingGetter ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance class System.Reflection.MethodInfo LookupUnderlyingGetter() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlDirective.LookupUnderlyingGetter" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides NotOverridable Function LookupUnderlyingGetter () As MethodInfo" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override System::Reflection::MethodInfo ^ LookupUnderlyingGetter();" />
      <MemberSignature Language="F#" Value="override this.LookupUnderlyingGetter : unit -&gt; System.Reflection.MethodInfo" Usage="xamlDirective.LookupUnderlyingGetter " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retorna um acessador <see langword="get" /> associado a este <see cref="T:System.Xaml.XamlDirective" />. Essa implementação sempre retorna <see langword="null" />.</summary>
        <returns>Sempre retorna <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Xaml.XamlDirective> lacra a esse membro virtual; Portanto, todas as <xref:System.Xaml.XamlDirective> tipos e todas as diretivas predefinidas de XAML devem usar esse comportamento.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupUnderlyingMember">
      <MemberSignature Language="C#" Value="protected override sealed System.Reflection.MemberInfo LookupUnderlyingMember ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance class System.Reflection.MemberInfo LookupUnderlyingMember() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlDirective.LookupUnderlyingMember" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides NotOverridable Function LookupUnderlyingMember () As MemberInfo" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override System::Reflection::MemberInfo ^ LookupUnderlyingMember();" />
      <MemberSignature Language="F#" Value="override this.LookupUnderlyingMember : unit -&gt; System.Reflection.MemberInfo" Usage="xamlDirective.LookupUnderlyingMember " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberInfo</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retorna um reflexo de CLR <see cref="T:System.Reflection.MemberInfo" /> associado a este <see cref="T:System.Xaml.XamlDirective" />. Essa implementação sempre retorna <see langword="null" />.</summary>
        <returns>Sempre retorna <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Xaml.XamlDirective> lacra a esse membro virtual; Portanto, todas as <xref:System.Xaml.XamlDirective> tipos e todas as diretivas predefinidas de XAML devem usar esse comportamento.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Xaml.XamlMember.UnderlyingMember" />
      </Docs>
    </Member>
    <Member MemberName="LookupUnderlyingSetter">
      <MemberSignature Language="C#" Value="protected override sealed System.Reflection.MethodInfo LookupUnderlyingSetter ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance class System.Reflection.MethodInfo LookupUnderlyingSetter() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlDirective.LookupUnderlyingSetter" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides NotOverridable Function LookupUnderlyingSetter () As MethodInfo" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override System::Reflection::MethodInfo ^ LookupUnderlyingSetter();" />
      <MemberSignature Language="F#" Value="override this.LookupUnderlyingSetter : unit -&gt; System.Reflection.MethodInfo" Usage="xamlDirective.LookupUnderlyingSetter " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retorna um acessador <see langword="set" /> associado a este <see cref="T:System.Xaml.XamlDirective" />. Essa implementação sempre retorna <see langword="null" />.</summary>
        <returns>Sempre retorna <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Xaml.XamlDirective> lacra a esse membro virtual; Portanto, todas as <xref:System.Xaml.XamlDirective> tipos e todas as diretivas predefinidas de XAML devem usar esse comportamento.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlDirective.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="xamlDirective.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retorna uma representação de cadeia de caracteres desse <see cref="T:System.Xaml.XamlDirective" />.</summary>
        <returns>Uma representação da cadeia de caracteres desse <see cref="T:System.Xaml.XamlDirective" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se as informações de namespace XAML estiverem disponíveis, essa implementação retorna uma combinação de cadeia de caracteres de <xref:System.Xaml.XamlMember.PreferredXamlNamespace%2A> e <xref:System.Xaml.XamlMember.Name%2A>. Se as informações de namespace XAML não estiverem disponíveis, essa implementação retorna <xref:System.Xaml.XamlMember.Name%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>