<Type Name="XamlMember" FullName="System.Xaml.XamlMember">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="81d50a3ca76157834fc7eb0634ae1d13af8fe855" />
    <Meta Name="ms.sourcegitcommit" Value="6a0b904069161bbaec4ffd02aa7d9cf38c61e72e" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="pt-BR" />
    <Meta Name="ms.lasthandoff" Value="06/24/2018" />
    <Meta Name="ms.locfileid" Value="36444385" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class XamlMember : IEquatable&lt;System.Xaml.XamlMember&gt;" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit XamlMember extends System.Object implements class System.IEquatable`1&lt;class System.Xaml.XamlMember&gt;" />
  <TypeSignature Language="DocId" Value="T:System.Xaml.XamlMember" />
  <TypeSignature Language="VB.NET" Value="Public Class XamlMember&#xA;Implements IEquatable(Of XamlMember)" />
  <TypeSignature Language="C++ CLI" Value="public ref class XamlMember : IEquatable&lt;System::Xaml::XamlMember ^&gt;" />
  <TypeSignature Language="F#" Value="type XamlMember = class&#xA;    interface IEquatable&lt;XamlMember&gt;" />
  <AssemblyInfo>
    <AssemblyName>System.Xaml</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IEquatable&lt;System.Xaml.XamlMember&gt;</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Fornece o identificador do sistema de tipo XAML para membros de tipos de XAML. O identificador é usado por leitores de XAML e gravadores de XAML durante o processamento de nós de membros (quando o leitor de XAML está posicionado em um <see cref="F:System.Xaml.XamlNodeType.StartMember" />) e também para a lógica de sistema do tipo XAML geral.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Xaml.XamlMember> pode usar as metodologias de três para retornar informações sobre um membro XAML: padrão reflexão comum de tempo de execução (CLR) do idioma; uma técnica de reflexão somente para referência interna ao chamar esse bit de otimização do uso de APIs sinalizadores; ou chamar virtual substituições do `Lookup*` API fornecida pelo possível <xref:System.Xaml.XamlMember> subclasses. Para a maioria dos usos de APIs de serviços XAML do .NET Framework e o <xref:System.Xaml.XamlMember> API, você usa o contexto do esquema XAML padrão. O contexto do esquema padrão XAML para serviços XAML do .NET Framework usa backup para o sistema de tipo CLR. Isso permite que os leitores XAML e gravadores XAML trabalhar com qualquer tipo ou membro que é definido em ou não disponível para, o CLR e suas técnicas de reflexão.  
  
## <a name="lookup-apis-and-xamlmember-derived-classes"></a>Classes derivadas do XamlMember e APIs de pesquisa *  
 <xref:System.Xaml.XamlMember> define vários membros virtuais que classes derivadas podem substituir. Esses membros com nomes que iniciam sempre com a cadeia de caracteres `Lookup`. O restante da API de referências, em seguida, o propriedade name que influencia o método virtual. Por exemplo, um <xref:System.Xaml.XamlMember> classe derivada pode substituir <xref:System.Xaml.XamlMember.LookupTargetType%2A> para influenciar que a base de dados de propriedade <xref:System.Xaml.XamlMember.TargetType%2A> retorna em uma classe derivada. Você pode prever valores de retorno para essas propriedades no <xref:System.Xaml.XamlMember> ou existente classes derivadas lendo a documentação relevante `Lookup*` métodos.  
  
 A finalidade de `Lookup*` métodos é fornecer uma técnica de extensão de sistema de tipo XAML que incorpora o <xref:System.Xaml.XamlMember> classe base. Derivando de <xref:System.Xaml.XamlMember> e substituindo o `Lookup` membros virtuais, você pode definir o conceito de um membro XAML para um esquema XAML em um sistema de tipo XAML sem ser vinculado às especificações de um sistema de tipos de backup ou uma tecnologia. Você pode também usar um contexto de esquema XAML fornecido sob esse esquema e ainda retornará os resultados desejados.  
  
 Por exemplo, considere o <xref:System.Xaml.XamlMember> propriedade <xref:System.Xaml.XamlMember.IsWritePublic%2A>. Essa propriedade informa os chamadores que operações como usando um <xref:System.Xaml.XamlWriter> para serialização pode gravar um valor para esse membro em um objeto de destino. Na implementação do padrão, a determinação se o membro é gravável é feita usando técnicas de reflexão em relação a CLR de apoio <xref:System.Type> e seus membros (o <xref:System.Reflection.MemberInfo>). Portanto, por padrão, o sistema de tipo XAML depende do sistema de tipo CLR. No entanto, você pode remover essa dependência para o seu sistema de tipo XAML relatório de <xref:System.Xaml.XamlMember.IsWritePublic%2A> , substituindo a API <xref:System.Xaml.XamlMember.LookupIsWritePublic%2A>. Dentro de sua substituição, você pode usar outras decisões, como metadados específicos para sua tecnologia, de uma tabela de pesquisa principal que é otimizada para um vocabulário XAML fixado ou uma variedade de outras estratégias para determinar se um membro XAML é gravável no seu Vocabulário XAML.  
  
## <a name="constructing-xamlmember-without-xaml-schema-context"></a>Construindo XamlMember sem contexto do esquema XAML  
 A maioria dos construtores de <xref:System.Xaml.XamlMember> exigem um <xref:System.Xaml.XamlSchemaContext> como parte da sua inicialização. O <xref:System.Xaml.XamlSchemaContext> também é necessária para muitos interno <xref:System.Xaml.XamlSchemaContext> operações, como obter as informações que está sendo encaminhadas do tipo de backup. Quando você estiver trabalhando com o <xref:System.Xaml.XamlMember> API, geralmente precisam ter um <xref:System.Xaml.XamlSchemaContext> que está disponível a partir de uma construção ao redor, como um <xref:System.Xaml.XamlWriter>. Nesse caso, você pode passar o <xref:System.Xaml.XamlSchemaContext> referência por meio de todas as chamadas de sistema de tipo XAML que exigem um contexto de esquema XAML.  
  
 Um construtor específico, <xref:System.Xaml.XamlMember.%23ctor%28System.String%2CSystem.Xaml.XamlType%2CSystem.Boolean%29>, não requer um <xref:System.Xaml.XamlSchemaContext>. No entanto, um <xref:System.Xaml.XamlMember> que é construído com a <xref:System.Xaml.XamlMember.%23ctor%28System.String%2CSystem.Xaml.XamlType%2CSystem.Boolean%29> assinatura retorna `true` para <xref:System.Xaml.XamlMember.IsUnknown%2A>.  
  
 Para um caminho de carga que envolve <xref:System.Xaml.XamlObjectWriter>, esse membro não pode ser gravado em um gráfico de objeto. Com a implementação de serviços XAML do .NET Framework, o <xref:System.Xaml.XamlObjectWriter.WriteStartMember%2A?displayProperty=nameWithType> chamar lança um <xref:System.Xaml.XamlObjectWriterException> quando relevante <xref:System.Xaml.XamlMember> relatórios `true` para <xref:System.Xaml.XamlMember.IsUnknown%2A>.  
  
 Você não deve criar um <xref:System.Xaml.XamlMember> que tem um valor de `true` para <xref:System.Xaml.XamlMember.IsUnknown%2A> , a menos que sua implementação pode manipular as exceções de <xref:System.Xaml.XamlObjectWriter>, ou você tiver outras maneiras de ajustar o <xref:System.Xaml.XamlObjectWriter> comportamento. Por exemplo, um ou mais dos itens a seguir podem ser verdadeiro para sua implementação:  
  
-   O contexto do esquema XAML está disponível mais tarde.  
  
-   Você usar um padrão de chamador do membro.  
  
-   Substituir deliberadamente <xref:System.Xaml.XamlObjectWriter.WriteStartMember%2A?displayProperty=nameWithType> em um gravador XAML personalizado.  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Xaml.XamlType" />
    <altmember cref="T:System.Xaml.XamlDirective" />
    <altmember cref="T:System.Xaml.XamlObjectWriter" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicializa uma nova instância da classe <see cref="T:System.Xaml.XamlMember" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XamlMember (System.Reflection.EventInfo eventInfo, System.Xaml.XamlSchemaContext schemaContext);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Reflection.EventInfo eventInfo, class System.Xaml.XamlSchemaContext schemaContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.#ctor(System.Reflection.EventInfo,System.Xaml.XamlSchemaContext)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; XamlMember(System::Reflection::EventInfo ^ eventInfo, System::Xaml::XamlSchemaContext ^ schemaContext);" />
      <MemberSignature Language="F#" Value="new System.Xaml.XamlMember : System.Reflection.EventInfo * System.Xaml.XamlSchemaContext -&gt; System.Xaml.XamlMember" Usage="new System.Xaml.XamlMember (eventInfo, schemaContext)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="eventInfo" Type="System.Reflection.EventInfo" />
        <Parameter Name="schemaContext" Type="System.Xaml.XamlSchemaContext" />
      </Parameters>
      <Docs>
        <param name="eventInfo">O <see cref="T:System.Reflection.EventInfo" /> do sistema do tipo CLR que representa o membro de evento.</param>
        <param name="schemaContext">O contexto <see cref="T:System.Xaml.XamlSchemaContext" /> que qualifica o membro.</param>
        <summary>Inicializa uma nova instância da classe <see cref="T:System.Xaml.XamlMember" /> usando o <see cref="T:System.Reflection.EventInfo" /> do sistema de tipo CLR e um <see cref="T:System.Xaml.XamlSchemaContext" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use este construtor se o membro representa um evento (propriedade de ponto de conexão de manipulador de eventos).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XamlMember (System.Reflection.PropertyInfo propertyInfo, System.Xaml.XamlSchemaContext schemaContext);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Reflection.PropertyInfo propertyInfo, class System.Xaml.XamlSchemaContext schemaContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.#ctor(System.Reflection.PropertyInfo,System.Xaml.XamlSchemaContext)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; XamlMember(System::Reflection::PropertyInfo ^ propertyInfo, System::Xaml::XamlSchemaContext ^ schemaContext);" />
      <MemberSignature Language="F#" Value="new System.Xaml.XamlMember : System.Reflection.PropertyInfo * System.Xaml.XamlSchemaContext -&gt; System.Xaml.XamlMember" Usage="new System.Xaml.XamlMember (propertyInfo, schemaContext)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="propertyInfo" Type="System.Reflection.PropertyInfo" />
        <Parameter Name="schemaContext" Type="System.Xaml.XamlSchemaContext" />
      </Parameters>
      <Docs>
        <param name="propertyInfo">O <see cref="T:System.Reflection.PropertyInfo" /> do sistema do tipo CLR que representa o membro de propriedade.</param>
        <param name="schemaContext">O contexto <see cref="T:System.Xaml.XamlSchemaContext" /> que qualifica o membro.</param>
        <summary>Inicializa uma nova instância da classe <see cref="T:System.Xaml.XamlMember" /> usando o <see cref="T:System.Reflection.PropertyInfo" /> do sistema de tipo CLR e um <see cref="T:System.Xaml.XamlSchemaContext" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use este construtor se o membro representa uma propriedade (e especificamente não é uma conexão de manipulador de eventos).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XamlMember (System.Reflection.EventInfo eventInfo, System.Xaml.XamlSchemaContext schemaContext, System.Xaml.Schema.XamlMemberInvoker invoker);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Reflection.EventInfo eventInfo, class System.Xaml.XamlSchemaContext schemaContext, class System.Xaml.Schema.XamlMemberInvoker invoker) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.#ctor(System.Reflection.EventInfo,System.Xaml.XamlSchemaContext,System.Xaml.Schema.XamlMemberInvoker)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; XamlMember(System::Reflection::EventInfo ^ eventInfo, System::Xaml::XamlSchemaContext ^ schemaContext, System::Xaml::Schema::XamlMemberInvoker ^ invoker);" />
      <MemberSignature Language="F#" Value="new System.Xaml.XamlMember : System.Reflection.EventInfo * System.Xaml.XamlSchemaContext * System.Xaml.Schema.XamlMemberInvoker -&gt; System.Xaml.XamlMember" Usage="new System.Xaml.XamlMember (eventInfo, schemaContext, invoker)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="eventInfo" Type="System.Reflection.EventInfo" />
        <Parameter Name="schemaContext" Type="System.Xaml.XamlSchemaContext" />
        <Parameter Name="invoker" Type="System.Xaml.Schema.XamlMemberInvoker" />
      </Parameters>
      <Docs>
        <param name="eventInfo">O <see cref="T:System.Reflection.EventInfo" /> do sistema do tipo CLR que representa o membro de evento.</param>
        <param name="schemaContext">O contexto <see cref="T:System.Xaml.XamlSchemaContext" /> que qualifica o membro.</param>
        <param name="invoker">A implementação de <see cref="T:System.Xaml.Schema.XamlMemberInvoker" /> que manipula a reflexão de chamadas do tempo de execução em relação a <see cref="T:System.Xaml.XamlMember" />.</param>
        <summary>Inicializa uma nova instância da classe <see cref="T:System.Xaml.XamlMember" /> usando o <see cref="T:System.Reflection.EventInfo" /> do sistema de tipo CLR e um <see cref="T:System.Xaml.XamlSchemaContext" />, incluindo informações de <see cref="T:System.Xaml.Schema.XamlMemberInvoker" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use este construtor se o membro representa um evento (ou uma propriedade de ponto de conexão do manipulador de eventos).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XamlMember (System.Reflection.PropertyInfo propertyInfo, System.Xaml.XamlSchemaContext schemaContext, System.Xaml.Schema.XamlMemberInvoker invoker);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Reflection.PropertyInfo propertyInfo, class System.Xaml.XamlSchemaContext schemaContext, class System.Xaml.Schema.XamlMemberInvoker invoker) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.#ctor(System.Reflection.PropertyInfo,System.Xaml.XamlSchemaContext,System.Xaml.Schema.XamlMemberInvoker)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; XamlMember(System::Reflection::PropertyInfo ^ propertyInfo, System::Xaml::XamlSchemaContext ^ schemaContext, System::Xaml::Schema::XamlMemberInvoker ^ invoker);" />
      <MemberSignature Language="F#" Value="new System.Xaml.XamlMember : System.Reflection.PropertyInfo * System.Xaml.XamlSchemaContext * System.Xaml.Schema.XamlMemberInvoker -&gt; System.Xaml.XamlMember" Usage="new System.Xaml.XamlMember (propertyInfo, schemaContext, invoker)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="propertyInfo" Type="System.Reflection.PropertyInfo" />
        <Parameter Name="schemaContext" Type="System.Xaml.XamlSchemaContext" />
        <Parameter Name="invoker" Type="System.Xaml.Schema.XamlMemberInvoker" />
      </Parameters>
      <Docs>
        <param name="propertyInfo">O <see cref="T:System.Reflection.PropertyInfo" /> do sistema do tipo CLR que representa o membro de propriedade.</param>
        <param name="schemaContext">O contexto <see cref="T:System.Xaml.XamlSchemaContext" /> que qualifica o membro.</param>
        <param name="invoker">A implementação de <see cref="T:System.Xaml.Schema.XamlMemberInvoker" /> que manipula a invocação de chamadas do tempo de execução em relação a <see cref="T:System.Xaml.XamlMember" />.</param>
        <summary>Inicializa uma nova instância da classe <see cref="T:System.Xaml.XamlMember" /> usando o <see cref="T:System.Reflection.PropertyInfo" /> de reflexão e um <see cref="T:System.Xaml.XamlSchemaContext" />, incluindo informações de <see cref="T:System.Xaml.Schema.XamlMemberInvoker" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use este construtor somente se o membro representa uma propriedade e se não for uma conexão de manipulador de eventos.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XamlMember (string attachableEventName, System.Reflection.MethodInfo adder, System.Xaml.XamlSchemaContext schemaContext);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string attachableEventName, class System.Reflection.MethodInfo adder, class System.Xaml.XamlSchemaContext schemaContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.#ctor(System.String,System.Reflection.MethodInfo,System.Xaml.XamlSchemaContext)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (attachableEventName As String, adder As MethodInfo, schemaContext As XamlSchemaContext)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; XamlMember(System::String ^ attachableEventName, System::Reflection::MethodInfo ^ adder, System::Xaml::XamlSchemaContext ^ schemaContext);" />
      <MemberSignature Language="F#" Value="new System.Xaml.XamlMember : string * System.Reflection.MethodInfo * System.Xaml.XamlSchemaContext -&gt; System.Xaml.XamlMember" Usage="new System.Xaml.XamlMember (attachableEventName, adder, schemaContext)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="attachableEventName" Type="System.String" />
        <Parameter Name="adder" Type="System.Reflection.MethodInfo" />
        <Parameter Name="schemaContext" Type="System.Xaml.XamlSchemaContext" />
      </Parameters>
      <Docs>
        <param name="attachableEventName">O nome da cadeia de caracteres do evento anexável.</param>
        <param name="adder">O <see cref="T:System.Reflection.MethodInfo" /> do sistema do tipo CLR do método <see langword="Add" /> do manipulador da implementação de suporte do membro anexável.</param>
        <param name="schemaContext">O contexto <see cref="T:System.Xaml.XamlSchemaContext" /> que qualifica o membro.</param>
        <summary>Inicializa uma nova instância da classe <see cref="T:System.Xaml.XamlMember" /> para um <see cref="T:System.Xaml.XamlMember" /> que representa um evento anexável.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use este construtor se o membro representa um membro de evento anexável.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XamlMember (string name, System.Xaml.XamlType declaringType, bool isAttachable);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string name, class System.Xaml.XamlType declaringType, bool isAttachable) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.#ctor(System.String,System.Xaml.XamlType,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (name As String, declaringType As XamlType, isAttachable As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; XamlMember(System::String ^ name, System::Xaml::XamlType ^ declaringType, bool isAttachable);" />
      <MemberSignature Language="F#" Value="new System.Xaml.XamlMember : string * System.Xaml.XamlType * bool -&gt; System.Xaml.XamlMember" Usage="new System.Xaml.XamlMember (name, declaringType, isAttachable)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="declaringType" Type="System.Xaml.XamlType" />
        <Parameter Name="isAttachable" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="name">O nome da cadeia de caracteres do membro.</param>
        <param name="declaringType">As informações de <see cref="T:System.Xaml.XamlType" /> para o tipo declarativo.</param>
        <param name="isAttachable">
          <see langword="true" /> para indicar que o membro anexável, caso contrário, <see langword="false" />.</param>
        <summary>Inicializa uma nova instância da classe <see cref="T:System.Xaml.XamlMember" /> usando o nome da cadeia de caracteres e as informações de <see cref="T:System.Xaml.XamlType" /> declarativo. Um <see cref="T:System.Xaml.XamlMember" /> que é construído com esta assinatura tem limitações significativas.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Um <xref:System.Xaml.XamlMember> que é construído com a <xref:System.Xaml.XamlMember.%23ctor%28System.String%2CSystem.Xaml.XamlType%2CSystem.Boolean%29> assinatura retorna `true` para <xref:System.Xaml.XamlMember.IsUnknown%2A>.  
  
 Para um caminho de carga que envolve <xref:System.Xaml.XamlObjectWriter>, esse membro não pode ser gravado em um gráfico de objeto. Com a implementação de serviços XAML do .NET Framework, o <xref:System.Xaml.XamlObjectWriter.WriteStartMember%2A?displayProperty=nameWithType> chamar lança um <xref:System.Xaml.XamlObjectWriterException> quando relevante <xref:System.Xaml.XamlMember> relatórios `true` para <xref:System.Xaml.XamlMember.IsUnknown%2A>.  
  
 Você não deve criar um <xref:System.Xaml.XamlMember> com <xref:System.Xaml.XamlMember.IsUnknown%2A> `true` , a menos que sua implementação pode manipular as exceções de <xref:System.Xaml.XamlObjectWriter>, ou você tiver outras maneiras de ajustar o <xref:System.Xaml.XamlObjectWriter> comportamento. Por exemplo, um ou mais dos itens a seguir podem ser verdadeiro para sua implementação:  
  
-   O contexto do esquema XAML está disponível mais tarde.  
  
-   Você usar um padrão de chamador do membro.  
  
-   Substituir deliberadamente <xref:System.Xaml.XamlObjectWriter.WriteStartMember%2A?displayProperty=nameWithType> em um gravador XAML personalizado.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> ou <paramref name="declaringType" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XamlMember (string attachablePropertyName, System.Reflection.MethodInfo getter, System.Reflection.MethodInfo setter, System.Xaml.XamlSchemaContext schemaContext);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string attachablePropertyName, class System.Reflection.MethodInfo getter, class System.Reflection.MethodInfo setter, class System.Xaml.XamlSchemaContext schemaContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.#ctor(System.String,System.Reflection.MethodInfo,System.Reflection.MethodInfo,System.Xaml.XamlSchemaContext)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (attachablePropertyName As String, getter As MethodInfo, setter As MethodInfo, schemaContext As XamlSchemaContext)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; XamlMember(System::String ^ attachablePropertyName, System::Reflection::MethodInfo ^ getter, System::Reflection::MethodInfo ^ setter, System::Xaml::XamlSchemaContext ^ schemaContext);" />
      <MemberSignature Language="F#" Value="new System.Xaml.XamlMember : string * System.Reflection.MethodInfo * System.Reflection.MethodInfo * System.Xaml.XamlSchemaContext -&gt; System.Xaml.XamlMember" Usage="new System.Xaml.XamlMember (attachablePropertyName, getter, setter, schemaContext)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="attachablePropertyName" Type="System.String" />
        <Parameter Name="getter" Type="System.Reflection.MethodInfo" />
        <Parameter Name="setter" Type="System.Reflection.MethodInfo" />
        <Parameter Name="schemaContext" Type="System.Xaml.XamlSchemaContext" />
      </Parameters>
      <Docs>
        <param name="attachablePropertyName">O nome da cadeia de caracteres da propriedade anexável.</param>
        <param name="getter">O <see cref="T:System.Reflection.MethodInfo" /> do sistema do tipo CLR do acessador <see langword="get" /> da implementação de suporte do membro anexável.</param>
        <param name="setter">O <see cref="T:System.Reflection.MethodInfo" /> do sistema do tipo CLR do acessador <see langword="set" /> da implementação de suporte do membro anexável.</param>
        <param name="schemaContext">O contexto <see cref="T:System.Xaml.XamlSchemaContext" /> que qualifica o membro.</param>
        <summary>Inicializa uma nova instância da classe <see cref="T:System.Xaml.XamlMember" /> para um <see cref="T:System.Xaml.XamlMember" /> que representa uma propriedade anexável.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use este construtor se o membro representa uma propriedade anexável.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XamlMember (string attachableEventName, System.Reflection.MethodInfo adder, System.Xaml.XamlSchemaContext schemaContext, System.Xaml.Schema.XamlMemberInvoker invoker);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string attachableEventName, class System.Reflection.MethodInfo adder, class System.Xaml.XamlSchemaContext schemaContext, class System.Xaml.Schema.XamlMemberInvoker invoker) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.#ctor(System.String,System.Reflection.MethodInfo,System.Xaml.XamlSchemaContext,System.Xaml.Schema.XamlMemberInvoker)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (attachableEventName As String, adder As MethodInfo, schemaContext As XamlSchemaContext, invoker As XamlMemberInvoker)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; XamlMember(System::String ^ attachableEventName, System::Reflection::MethodInfo ^ adder, System::Xaml::XamlSchemaContext ^ schemaContext, System::Xaml::Schema::XamlMemberInvoker ^ invoker);" />
      <MemberSignature Language="F#" Value="new System.Xaml.XamlMember : string * System.Reflection.MethodInfo * System.Xaml.XamlSchemaContext * System.Xaml.Schema.XamlMemberInvoker -&gt; System.Xaml.XamlMember" Usage="new System.Xaml.XamlMember (attachableEventName, adder, schemaContext, invoker)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="attachableEventName" Type="System.String" />
        <Parameter Name="adder" Type="System.Reflection.MethodInfo" />
        <Parameter Name="schemaContext" Type="System.Xaml.XamlSchemaContext" />
        <Parameter Name="invoker" Type="System.Xaml.Schema.XamlMemberInvoker" />
      </Parameters>
      <Docs>
        <param name="attachableEventName">O nome da cadeia de caracteres do evento anexável.</param>
        <param name="adder">O <see cref="T:System.Reflection.MethodInfo" /> do sistema do tipo CLR do método <see langword="Add" /> do manipulador da implementação de suporte do membro anexável.</param>
        <param name="schemaContext">O contexto <see cref="T:System.Xaml.XamlSchemaContext" /> que qualifica o membro.</param>
        <param name="invoker">A implementação de <see cref="T:System.Xaml.Schema.XamlMemberInvoker" /> que manipula a invocação de chamadas do tempo de execução em relação a <see cref="T:System.Xaml.XamlMember" />.</param>
        <summary>Inicializa uma nova instância da classe <see cref="T:System.Xaml.XamlMember" /> para um <see cref="T:System.Xaml.XamlMember" /> que representa um evento anexável, incluindo informações de <see cref="T:System.Xaml.Schema.XamlMemberInvoker" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use este construtor se o membro representa um membro de evento anexável.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XamlMember (string attachablePropertyName, System.Reflection.MethodInfo getter, System.Reflection.MethodInfo setter, System.Xaml.XamlSchemaContext schemaContext, System.Xaml.Schema.XamlMemberInvoker invoker);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string attachablePropertyName, class System.Reflection.MethodInfo getter, class System.Reflection.MethodInfo setter, class System.Xaml.XamlSchemaContext schemaContext, class System.Xaml.Schema.XamlMemberInvoker invoker) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.#ctor(System.String,System.Reflection.MethodInfo,System.Reflection.MethodInfo,System.Xaml.XamlSchemaContext,System.Xaml.Schema.XamlMemberInvoker)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (attachablePropertyName As String, getter As MethodInfo, setter As MethodInfo, schemaContext As XamlSchemaContext, invoker As XamlMemberInvoker)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; XamlMember(System::String ^ attachablePropertyName, System::Reflection::MethodInfo ^ getter, System::Reflection::MethodInfo ^ setter, System::Xaml::XamlSchemaContext ^ schemaContext, System::Xaml::Schema::XamlMemberInvoker ^ invoker);" />
      <MemberSignature Language="F#" Value="new System.Xaml.XamlMember : string * System.Reflection.MethodInfo * System.Reflection.MethodInfo * System.Xaml.XamlSchemaContext * System.Xaml.Schema.XamlMemberInvoker -&gt; System.Xaml.XamlMember" Usage="new System.Xaml.XamlMember (attachablePropertyName, getter, setter, schemaContext, invoker)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="attachablePropertyName" Type="System.String" />
        <Parameter Name="getter" Type="System.Reflection.MethodInfo" />
        <Parameter Name="setter" Type="System.Reflection.MethodInfo" />
        <Parameter Name="schemaContext" Type="System.Xaml.XamlSchemaContext" />
        <Parameter Name="invoker" Type="System.Xaml.Schema.XamlMemberInvoker" />
      </Parameters>
      <Docs>
        <param name="attachablePropertyName">O nome da cadeia de caracteres da propriedade anexável.</param>
        <param name="getter">O <see cref="T:System.Reflection.MethodInfo" /> do sistema do tipo CLR do acessador <see langword="get" /> da implementação de suporte do membro anexável.</param>
        <param name="setter">O <see cref="T:System.Reflection.MethodInfo" /> do sistema do tipo CLR do acessador <see langword="set" /> da implementação de suporte do membro anexável.</param>
        <param name="schemaContext">O contexto <see cref="T:System.Xaml.XamlSchemaContext" /> que qualifica o membro.</param>
        <param name="invoker">A implementação de <see cref="T:System.Xaml.Schema.XamlMemberInvoker" /> que manipula a invocação de chamadas do tempo de execução em relação a <see cref="T:System.Xaml.XamlMember" />.</param>
        <summary>Inicializa uma nova instância da classe <see cref="T:System.Xaml.XamlMember" /> para um <see cref="T:System.Xaml.XamlMember" /> que representa uma propriedade anexável, incluindo informações de <see cref="T:System.Xaml.Schema.XamlMemberInvoker" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use este construtor se o membro representa um membro de uma propriedade anexável.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DeclaringType">
      <MemberSignature Language="C#" Value="public System.Xaml.XamlType DeclaringType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Xaml.XamlType DeclaringType" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlMember.DeclaringType" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DeclaringType As XamlType" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Xaml::XamlType ^ DeclaringType { System::Xaml::XamlType ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DeclaringType : System.Xaml.XamlType" Usage="System.Xaml.XamlMember.DeclaringType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.XamlType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém o <see cref="T:System.Xaml.XamlType" /> para o tipo que declara o membro que é associado a esse <see cref="T:System.Xaml.XamlMember" />.</summary>
        <value>O <see cref="T:System.Xaml.XamlType" /> para o tipo que declara o membro que é associado a essa <see cref="T:System.Xaml.XamlMember" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse valor normalmente é definida durante a inicialização e não costuma ser `null`.  
  
> [!IMPORTANT]
>  <xref:System.Xaml.XamlMember.DeclaringType%2A> informações podem ser passadas por construtores para inicialização. Chamando diretamente construtores base, a inicialização para <xref:System.Xaml.XamlMember> classes derivadas podem omitir alguns as verificações de valor que são feitas na classe base. Portanto, a inicialização derivada pode alterar as informações de relação de membro de tipo relatado de um membro XAML para que ele não se alinha de forma esperada com as informações de sua declaração de CLR subjacente do sistema de tipo. Para verificações da declaração de tipo informações críticas de segurança, use o tipo CLR subjacente.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DeferringLoader">
      <MemberSignature Language="C#" Value="public System.Xaml.Schema.XamlValueConverter&lt;System.Xaml.XamlDeferringLoader&gt; DeferringLoader { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Xaml.Schema.XamlValueConverter`1&lt;class System.Xaml.XamlDeferringLoader&gt; DeferringLoader" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlMember.DeferringLoader" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DeferringLoader As XamlValueConverter(Of XamlDeferringLoader)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Xaml::Schema::XamlValueConverter&lt;System::Xaml::XamlDeferringLoader ^&gt; ^ DeferringLoader { System::Xaml::Schema::XamlValueConverter&lt;System::Xaml::XamlDeferringLoader ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DeferringLoader : System.Xaml.Schema.XamlValueConverter&lt;System.Xaml.XamlDeferringLoader&gt;" Usage="System.Xaml.XamlMember.DeferringLoader" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.Schema.XamlValueConverter&lt;System.Xaml.XamlDeferringLoader&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém um objeto <see cref="T:System.Xaml.Schema.XamlValueConverter`1" />, que é usado para o carregamento adiado de objetos declarados em XAML.</summary>
        <value>Um <see cref="T:System.Xaml.Schema.XamlValueConverter`1" /> com <see cref="T:System.Xaml.XamlDeferringLoader" /> restrição genérica.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Chamando <xref:System.Xaml.XamlMember.DeferringLoader%2A> invoca <xref:System.Xaml.XamlMember.LookupDeferringLoader%2A> ou uma substituição específica desse método. Esse comportamento ocorre nos casos em que a lógica de reflexão interno inicial ainda não tiver definido as informações.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DependsOn">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IList&lt;System.Xaml.XamlMember&gt; DependsOn { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IList`1&lt;class System.Xaml.XamlMember&gt; DependsOn" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlMember.DependsOn" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DependsOn As IList(Of XamlMember)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Generic::IList&lt;System::Xaml::XamlMember ^&gt; ^ DependsOn { System::Collections::Generic::IList&lt;System::Xaml::XamlMember ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DependsOn : System.Collections.Generic.IList&lt;System.Xaml.XamlMember&gt;" Usage="System.Xaml.XamlMember.DependsOn" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IList&lt;System.Xaml.XamlMember&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém uma lista de objetos <see cref="T:System.Xaml.XamlMember" />. Eles relatam os membros em que há relações de dependência para a ordem de inicialização em relação a esse <see cref="T:System.Xaml.XamlMember" />.</summary>
        <value>Uma lista de objetos <see cref="T:System.Xaml.XamlMember" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Chamando <xref:System.Xaml.XamlMember.DependsOn%2A> invoca <xref:System.Xaml.XamlMember.LookupDependsOn%2A> ou uma substituição específica desse método. Esse comportamento ocorre nos casos em que a lógica de reflexão interno inicial ainda não tiver definido as informações.  
  
 O `DependsOn` padrão pode ser aplicado a casos de modelo de objeto que deliberadamente contradigam a regra XAML geral. A regra XAML geral é que os membros de um tipo que não são transmitidos como texto de inicialização (ou por um método de fábrica em XAML 2009) devem poder ser atribuídas em qualquer ordem. Aplicando um `DependsOn` padrão para um membro, você pode instruir gravadores XAML para processar sempre o membro referenciado antes desse membro. Você pode aplicar esse padrão em situações em que o valor do membro atual requer contexto ou outras informações que está disponíveis somente depois de outro membro é definido.  
  
 O `DependsOn` padrão deve ser aplicado criteriosamente e reservado para cenários de propriedade em que ele tem uma finalidade de arquitetura. Grandes números de dependências têm potencial para reduzir a velocidade de processamento de XAML. Além disso, é possível produzir dependências circulares, caso em que o comportamento de processamento de XAML é indefinido.  
  
 Exemplo `DependsOn` cenários do WPF incluem determinadas propriedades em <xref:System.Windows.Controls.ControlTemplate> e <xref:System.Windows.DataTemplate>, na <xref:System.Windows.Trigger>e em <xref:System.Windows.Setter>.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Markup.DependsOnAttribute" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Equals">
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Indica se o objeto atual é igual a outro objeto.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="override this.Equals : obj -&gt; bool" Usage="xamlMember.Equals obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">O objeto a ser comparado com este objeto.</param>
        <summary>Indica se o objeto atual é igual a outro objeto.</summary>
        <returns>
          <see langword="true" /> se o objeto atual for igual ao parâmetro <paramref name="obj" />; caso contrário, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public bool Equals (System.Xaml.XamlMember other);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Equals(class System.Xaml.XamlMember other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.Equals(System.Xaml.XamlMember)" />
      <MemberSignature Language="VB.NET" Value="Public Function Equals (other As XamlMember) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Equals(System::Xaml::XamlMember ^ other);" />
      <MemberSignature Language="F#" Value="override this.Equals : System.Xaml.XamlMember -&gt; bool" Usage="xamlMember.Equals other" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IEquatable`1.Equals(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Xaml.XamlMember" />
      </Parameters>
      <Docs>
        <param name="other">Um objeto para comparação com esse objeto.</param>
        <summary>Indica se o objeto atual é igual a outro objeto do mesmo tipo.</summary>
        <returns>
          <see langword="true" /> se o objeto atual for igual ao parâmetro <paramref name="other" />; caso contrário, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="xamlMember.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retorna o código hash para esse objeto.</summary>
        <returns>Um código hash inteiro.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetXamlNamespaces">
      <MemberSignature Language="C#" Value="public virtual System.Collections.Generic.IList&lt;string&gt; GetXamlNamespaces ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Generic.IList`1&lt;string&gt; GetXamlNamespaces() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.GetXamlNamespaces" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetXamlNamespaces () As IList(Of String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Collections::Generic::IList&lt;System::String ^&gt; ^ GetXamlNamespaces();" />
      <MemberSignature Language="F#" Value="abstract member GetXamlNamespaces : unit -&gt; System.Collections.Generic.IList&lt;string&gt;&#xA;override this.GetXamlNamespaces : unit -&gt; System.Collections.Generic.IList&lt;string&gt;" Usage="xamlMember.GetXamlNamespaces " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IList&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retorna uma lista de namespaces XAML em que esse membro XAML pode existir.</summary>
        <returns>Uma lista de identificadores de namespace XAML como cadeias de caracteres.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A implementação padrão retorna o <xref:System.Xaml.XamlType.GetXamlNamespaces%2A?displayProperty=nameWithType> chamar resultado da <xref:System.Xaml.XamlMember.DeclaringType%2A> que é associada a essa <xref:System.Xaml.XamlMember>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Invoker">
      <MemberSignature Language="C#" Value="public System.Xaml.Schema.XamlMemberInvoker Invoker { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Xaml.Schema.XamlMemberInvoker Invoker" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlMember.Invoker" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Invoker As XamlMemberInvoker" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Xaml::Schema::XamlMemberInvoker ^ Invoker { System::Xaml::Schema::XamlMemberInvoker ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Invoker : System.Xaml.Schema.XamlMemberInvoker" Usage="System.Xaml.XamlMember.Invoker" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.Schema.XamlMemberInvoker</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém a implementação de <see cref="T:System.Xaml.Schema.XamlMemberInvoker" /> que está associada a esse <see cref="T:System.Xaml.XamlMember" />.</summary>
        <value>O <see cref="T:System.Xaml.Schema.XamlMemberInvoker" /> implementação que está associada a essa <see cref="T:System.Xaml.XamlMember" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O `Invoker` padrão é uma técnica de extensão do sistema de tipo XAML avançada. O `Invoker` padrão fornece uma maneira de inserir o comportamento de mapeamento de tipo de esquema diferente, enquanto estiver usando definições de sistema de tipo XAML de serviços XAML do .NET Framework.  
  
 Se um <xref:System.Xaml.XamlMember.LookupInvoker%2A> substituir retorna `null`, ou se a implementação padrão retorna `null` porque ele não tem o <xref:System.Xaml.XamlMember.UnderlyingMember%2A> para este <xref:System.Xaml.XamlMember>, o <xref:System.Xaml.XamlMember.Invoker%2A> propriedade retorna <xref:System.Xaml.Schema.XamlMemberInvoker.UnknownInvoker%2A?displayProperty=nameWithType>.  
  
 <xref:System.Xaml.Schema.XamlMemberInvoker.UnknownInvoker%2A?displayProperty=nameWithType> é o padrão. Isso é verdadeiro para a maioria das operações que usam serviços XAML do .NET Framework e o contexto do esquema XAML padrão e em nenhum específicos substituir `Invoker` padrões são passados para a construção de entidades do sistema de tipo XAML.  
  
 Chamando <xref:System.Xaml.XamlMember.Invoker%2A> invoca <xref:System.Xaml.XamlMember.LookupInvoker%2A> ou uma substituição específica desse método.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsAmbient">
      <MemberSignature Language="C#" Value="public bool IsAmbient { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsAmbient" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlMember.IsAmbient" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsAmbient As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsAmbient { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsAmbient : bool" Usage="System.Xaml.XamlMember.IsAmbient" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém um valor que indica se este <see cref="T:System.Xaml.XamlMember" /> é relatado como uma propriedade de ambiente.</summary>
        <value>
          <see langword="true" /> Se este <see cref="T:System.Xaml.XamlMember" /> relatados como uma propriedade de ambiente; caso contrário, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Chamando <xref:System.Xaml.XamlMember.IsAmbient%2A> invoca <xref:System.Xaml.XamlMember.LookupIsAmbient%2A> ou uma substituição específica desse método. Esse comportamento ocorre em implementações onde a lógica de reflexão interno inicial ainda não tiver definido as informações.  
  
 Verificando para propriedades de ambiente é geralmente fazem parte da lógica de processamento de XAML para certificar-se de que os objetos e os valores que se baseiam no uso de ambiente para a qualificação do tipo podem funcionar corretamente. APIs de serviços XAML do .NET Framework e o contexto do esquema padrão XAML preenche esse valor com base na atribuição com <xref:System.Windows.Markup.AmbientAttribute>. A implementação padrão de <xref:System.Xaml.XamlMember.LookupIsAmbient%2A> usa esse existente <xref:System.Windows.Markup.AmbientAttribute> técnica e retornará `true` se <xref:System.Windows.Markup.AmbientAttribute> existe em uma declaração de membro.  
  
 <xref:System.Windows.Markup.AmbientAttribute> foi encontrado em membros de vários tipos WPF, que incluem <xref:System.Windows.Application>, <xref:System.Windows.Setter>, e <xref:System.Windows.Style>. Ele também é encontrado na <xref:System.Windows.ResourceDictionary> tipo, que dá a ideia de que qualquer membro que usa <xref:System.Windows.ResourceDictionary> como seu tipo deve ser considerado ambiente mesmo se o membro não é especificamente atribuído.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Markup.AmbientAttribute" />
      </Docs>
    </Member>
    <Member MemberName="IsAttachable">
      <MemberSignature Language="C#" Value="public bool IsAttachable { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsAttachable" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlMember.IsAttachable" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsAttachable As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsAttachable { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsAttachable : bool" Usage="System.Xaml.XamlMember.IsAttachable" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém um valor que indica se este <see cref="T:System.Xaml.XamlMember" /> é um membro anexável.</summary>
        <value>
          <see langword="true" /> Se este <see cref="T:System.Xaml.XamlMember" /> é um membro anexável; caso contrário, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Xaml.XamlMember.IsAttachable%2A> o valor é inicializado com base em qual construtor foi usado para construir um <xref:System.Xaml.XamlMember>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsDirective">
      <MemberSignature Language="C#" Value="public bool IsDirective { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsDirective" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlMember.IsDirective" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsDirective As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsDirective { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsDirective : bool" Usage="System.Xaml.XamlMember.IsDirective" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém um valor que indica se este <see cref="T:System.Xaml.XamlMember" /> é uma diretiva XAML.</summary>
        <value>
          <see langword="true" /> Se este <see cref="T:System.Xaml.XamlMember" /> é uma XAML diretiva; caso contrário, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Xaml.XamlMember.IsDirective%2A> o valor é inicializado com base em qual construtor foi usado para construir um <xref:System.Xaml.XamlMember>. A base de <xref:System.Xaml.XamlMember> inicializar construtores para que <xref:System.Xaml.XamlMember.IsDirective%2A> é `false`. No entanto, o <xref:System.Xaml.XamlDirective> classe (um <xref:System.Xaml.XamlMember> classe derivada) inicializa para que <xref:System.Xaml.XamlMember.IsDirective%2A> é `true`.  
  
 Se você deseja relatar <xref:System.Xaml.XamlMember.IsDirective%2A> como `true` para chamadores de uma classe personalizada de esquema XAML para membros XAML, verifique se você derivar da <xref:System.Xaml.XamlDirective> porque é a única maneira de habilitar esse comportamento.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsEvent">
      <MemberSignature Language="C#" Value="public bool IsEvent { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsEvent" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlMember.IsEvent" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsEvent As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsEvent { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsEvent : bool" Usage="System.Xaml.XamlMember.IsEvent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém um valor que indica se esse <see cref="T:System.Xaml.XamlMember" /> representa um membro de evento.</summary>
        <value>
          <see langword="true" /> Se este <see cref="T:System.Xaml.XamlMember" /> representa um evento; caso contrário, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Chamando <xref:System.Xaml.XamlMember.IsEvent%2A> invoca <xref:System.Xaml.XamlMember.LookupIsEvent%2A> ou uma substituição específica desse método.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsNameValid">
      <MemberSignature Language="C#" Value="public bool IsNameValid { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsNameValid" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlMember.IsNameValid" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsNameValid As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsNameValid { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsNameValid : bool" Usage="System.Xaml.XamlMember.IsNameValid" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém um valor que indica se este <see cref="T:System.Xaml.XamlMember" /> é inicializado com uma cadeia de caracteres <see langword="xamlName" /> válida como seu <see cref="P:System.Xaml.XamlMember.Name" />.</summary>
        <value>
          <see langword="true" /> Se este <see cref="T:System.Xaml.XamlMember" /> é inicializada com uma validade <see langword="xamlName" /> de cadeia de caracteres; caso contrário, <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsReadOnly">
      <MemberSignature Language="C#" Value="public bool IsReadOnly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsReadOnly" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlMember.IsReadOnly" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsReadOnly As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsReadOnly { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsReadOnly : bool" Usage="System.Xaml.XamlMember.IsReadOnly" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém um valor que indica se esse <see cref="T:System.Xaml.XamlMember" /> representa um membro somente leitura.</summary>
        <value>
          <see langword="true" /> Se este <see cref="T:System.Xaml.XamlMember" /> representa um membro somente leitura; caso contrário, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Chamando <xref:System.Xaml.XamlMember.IsReadOnly%2A> invoca <xref:System.Xaml.XamlMember.LookupIsReadOnly%2A> ou uma substituição específica desse método.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsReadPublic">
      <MemberSignature Language="C#" Value="public bool IsReadPublic { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsReadPublic" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlMember.IsReadPublic" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsReadPublic As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsReadPublic { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsReadPublic : bool" Usage="System.Xaml.XamlMember.IsReadPublic" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém um valor que indica se este <see cref="T:System.Xaml.XamlMember" /> representa um membro com um acessador <see langword="get" /> público chamável.</summary>
        <value>
          <see langword="true" /> Se este <see cref="T:System.Xaml.XamlMember" /> representa um público que pode ser chamado <see langword="get" /> acessador; caso contrário, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Xaml.XamlMember.IsReadPublic%2A> valor verifica se o <xref:System.Xaml.XamlMember.DeclaringType%2A> é público. Se <xref:System.Xaml.XamlMember.DeclaringType%2A> é não público, o `get` acessador não é chamado de um modo prático, e <xref:System.Xaml.XamlMember.IsReadPublic%2A> retorna `false`.  
  
 Chamando <xref:System.Xaml.XamlMember.IsReadPublic%2A> invoca <xref:System.Xaml.XamlMember.LookupIsReadPublic%2A> ou uma substituição específica desse método.  
  
> [!IMPORTANT]
>  O <xref:System.Xaml.XamlMember.LookupIsReadPublic%2A> método é virtual e, portanto, pode ser substituído. A substituição tem o potencial de mudar (maliciosamente ou não) as informações de acesso reportadas de um membro XAML para que ele não alinhe de forma esperada com as informações de acesso de sua declaração de CLR subjacente do tipo system. Para qualquer verificação de segurança crítica dos níveis de acesso, use o tipo CLR subjacente.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsUnknown">
      <MemberSignature Language="C#" Value="public bool IsUnknown { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsUnknown" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlMember.IsUnknown" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsUnknown As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsUnknown { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsUnknown : bool" Usage="System.Xaml.XamlMember.IsUnknown" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém um valor que indica se o membro não pode ser resolvido pelo sistema de backup que é usado para a resolução de membro e de tipo.</summary>
        <value>
          <see langword="true" /> Se o membro não pode ser resolvido; <see langword="false" /> se o membro puder ser resolvido.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Um <xref:System.Xaml.XamlMember> que é construído com a <xref:System.Xaml.XamlMember.%23ctor%28System.String%2CSystem.Xaml.XamlType%2CSystem.Boolean%29> assinatura retorna `true` para <xref:System.Xaml.XamlMember.IsUnknown%2A>.  
  
 Para um caminho de carga que envolve <xref:System.Xaml.XamlObjectWriter>, um <xref:System.Xaml.XamlMember> com `true` para <xref:System.Xaml.XamlMember.IsUnknown%2A> não pode ser gravado em um gráfico de objeto. Sob as implementações padrão de APIs de serviços de XAML do .NET Framework, o <xref:System.Xaml.XamlObjectWriter.WriteStartMember%2A?displayProperty=nameWithType> chamar lança um <xref:System.Xaml.XamlObjectWriterException> quando relevante <xref:System.Xaml.XamlMember> relatórios `true` para <xref:System.Xaml.XamlMember.IsUnknown%2A>.  
  
 Você não deve criar um <xref:System.Xaml.XamlMember> que tem um valor de `true` para <xref:System.Xaml.XamlMember.IsUnknown%2A> , a menos que sua implementação pode manipular as exceções de <xref:System.Xaml.XamlObjectWriter>, ou você tiver outras maneiras de ajustar o <xref:System.Xaml.XamlObjectWriter> comportamento.  
  
 Chamando <xref:System.Xaml.XamlMember.IsUnknown%2A> invoca <xref:System.Xaml.XamlMember.LookupIsUnknown%2A> ou uma substituição específica desse método.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsWriteOnly">
      <MemberSignature Language="C#" Value="public bool IsWriteOnly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsWriteOnly" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlMember.IsWriteOnly" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsWriteOnly As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsWriteOnly { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsWriteOnly : bool" Usage="System.Xaml.XamlMember.IsWriteOnly" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém um valor que indica se esse <see cref="T:System.Xaml.XamlMember" /> representa um membro somente gravação.</summary>
        <value>
          <see langword="true" /> se este <see cref="T:System.Xaml.XamlMember" /> representar um membro somente gravação, caso contrário, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Chamando <xref:System.Xaml.XamlMember.IsWriteOnly%2A> invoca <xref:System.Xaml.XamlMember.LookupIsWriteOnly%2A> ou uma substituição específica desse método.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsWritePublic">
      <MemberSignature Language="C#" Value="public bool IsWritePublic { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsWritePublic" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlMember.IsWritePublic" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsWritePublic As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsWritePublic { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsWritePublic : bool" Usage="System.Xaml.XamlMember.IsWritePublic" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém um valor que indica se este <see cref="T:System.Xaml.XamlMember" /> representa um membro que tem um acessador <see langword="set" /> público chamável.</summary>
        <value>
          <see langword="true" /> Se este <see cref="T:System.Xaml.XamlMember" /> representa um público que pode ser chamado <see langword="set" /> acessador; caso contrário, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Xaml.XamlMember.IsWritePublic%2A> valor considera se o <xref:System.Xaml.XamlMember.DeclaringType%2A> é público como parte da determinação. Se <xref:System.Xaml.XamlMember.DeclaringType%2A> é não público, o `set` acessador não é chamado de um modo prático, e <xref:System.Xaml.XamlMember.IsWritePublic%2A> retorna `false`.  
  
 Chamando <xref:System.Xaml.XamlMember.IsWritePublic%2A> invoca <xref:System.Xaml.XamlMember.LookupIsWritePublic%2A> ou uma substituição específica desse método.  
  
> [!IMPORTANT]
>  O <xref:System.Xaml.XamlMember.LookupIsWritePublic%2A> método é virtual e, portanto, pode ser substituído. A substituição tem o potencial de mudar (maliciosamente ou não) as informações de acesso reportadas de um membro XAML para que ele não alinhe de forma esperada com as informações de acesso de sua declaração de CLR subjacente do tipo system. Para qualquer verificação de segurança crítica dos níveis de acesso, use o tipo CLR subjacente.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupCustomAttributeProvider">
      <MemberSignature Language="C#" Value="protected virtual System.Reflection.ICustomAttributeProvider LookupCustomAttributeProvider ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Reflection.ICustomAttributeProvider LookupCustomAttributeProvider() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.LookupCustomAttributeProvider" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupCustomAttributeProvider () As ICustomAttributeProvider" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Reflection::ICustomAttributeProvider ^ LookupCustomAttributeProvider();" />
      <MemberSignature Language="F#" Value="abstract member LookupCustomAttributeProvider : unit -&gt; System.Reflection.ICustomAttributeProvider&#xA;override this.LookupCustomAttributeProvider : unit -&gt; System.Reflection.ICustomAttributeProvider" Usage="xamlMember.LookupCustomAttributeProvider " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.ICustomAttributeProvider</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Quando implementado em uma classe derivada, retorna uma implementação <see cref="T:System.Reflection.ICustomAttributeProvider" />.</summary>
        <returns>Uma implementação <see cref="T:System.Reflection.ICustomAttributeProvider" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Substitua este método para fornecer a reflexão interna com uma maneira alternativa para obter valores de atributo do CLR. Na ausência de uma substituição, o reflector interno usa a lógica de reflexão típica do CLR como chamadas ao <xref:System.Reflection.CustomAttributeData.GetCustomAttributes%2A>.  
  
 A implementação padrão retorna `null`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupDeferringLoader">
      <MemberSignature Language="C#" Value="protected virtual System.Xaml.Schema.XamlValueConverter&lt;System.Xaml.XamlDeferringLoader&gt; LookupDeferringLoader ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Xaml.Schema.XamlValueConverter`1&lt;class System.Xaml.XamlDeferringLoader&gt; LookupDeferringLoader() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.LookupDeferringLoader" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupDeferringLoader () As XamlValueConverter(Of XamlDeferringLoader)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Xaml::Schema::XamlValueConverter&lt;System::Xaml::XamlDeferringLoader ^&gt; ^ LookupDeferringLoader();" />
      <MemberSignature Language="F#" Value="abstract member LookupDeferringLoader : unit -&gt; System.Xaml.Schema.XamlValueConverter&lt;System.Xaml.XamlDeferringLoader&gt;&#xA;override this.LookupDeferringLoader : unit -&gt; System.Xaml.Schema.XamlValueConverter&lt;System.Xaml.XamlDeferringLoader&gt;" Usage="xamlMember.LookupDeferringLoader " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.Schema.XamlValueConverter&lt;System.Xaml.XamlDeferringLoader&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retorna um objeto <see cref="T:System.Xaml.Schema.XamlValueConverter`1" />, que é usado para o carregamento adiado de objetos declarados em XAML.</summary>
        <returns>Um <see cref="T:System.Xaml.Schema.XamlValueConverter`1" /> que tem uma restrição <see cref="T:System.Xaml.XamlDeferringLoader" /> sobre o genérico.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método é chamado quando um chamador obtém um valor da <xref:System.Xaml.XamlMember.DeferringLoader%2A> propriedade. Substitua este método se desejar <xref:System.Xaml.XamlMember.DeferringLoader%2A> para retornar um valor diferente do valor que é habilitado por reflexão interno do padrão, e se você estiver fornecendo também personalizado <xref:System.Xaml.Schema.XamlMemberInvoker> informações.  
  
 A implementação padrão retorna um objeto lendo <xref:System.Windows.Markup.XamlDeferLoadAttribute> ou usando um <xref:System.Xaml.XamlDeferringLoader> do tipo de declaração. Se nenhum objeto estiver disponível, esse método pode retornar `null`.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Xaml.XamlMember.DeferringLoader" />
      </Docs>
    </Member>
    <Member MemberName="LookupDependsOn">
      <MemberSignature Language="C#" Value="protected virtual System.Collections.Generic.IList&lt;System.Xaml.XamlMember&gt; LookupDependsOn ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Collections.Generic.IList`1&lt;class System.Xaml.XamlMember&gt; LookupDependsOn() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.LookupDependsOn" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupDependsOn () As IList(Of XamlMember)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Collections::Generic::IList&lt;System::Xaml::XamlMember ^&gt; ^ LookupDependsOn();" />
      <MemberSignature Language="F#" Value="abstract member LookupDependsOn : unit -&gt; System.Collections.Generic.IList&lt;System.Xaml.XamlMember&gt;&#xA;override this.LookupDependsOn : unit -&gt; System.Collections.Generic.IList&lt;System.Xaml.XamlMember&gt;" Usage="xamlMember.LookupDependsOn " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IList&lt;System.Xaml.XamlMember&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retorna uma lista de objetos <see cref="T:System.Xaml.XamlMember" />. Os itens na lista relatam os membros em que há relações de dependência para a ordem de inicialização em relação a esse <see cref="T:System.Xaml.XamlMember" />.</summary>
        <returns>Uma lista de objetos <see cref="T:System.Xaml.XamlMember" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método é chamado quando um chamador obtém um valor da <xref:System.Xaml.XamlMember.DependsOn%2A> propriedade. Substitua este método se desejar <xref:System.Xaml.XamlMember.DependsOn%2A> para retornar um valor diferente do valor que é habilitado por reflexão interno do padrão, e se você estiver fornecendo também personalizado <xref:System.Xaml.Schema.XamlMemberInvoker> informações.  
  
 As implementações de leitor e gravador do WPF XAML atributo nesse caso com <xref:System.Windows.Markup.DependsOnAttribute>. A implementação padrão usa esse existente <xref:System.Windows.Markup.DependsOnAttribute> técnica.  
  
 Substitua este método se você não estiver usando <xref:System.Windows.Markup.DependsOnAttribute> para essa finalidade e a intenção de substituir essa técnica para indicar a ordem de processamento de propriedade com sua própria técnica. Se você não pretende dar suporte a uma ordem de processamento de propriedade, você pode usar a implementação padrão porque ele não retorna nenhum resultado, que é apropriado.  
  
 A lista é somente leitura.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Xaml.XamlMember.DependsOn" />
      </Docs>
    </Member>
    <Member MemberName="LookupInvoker">
      <MemberSignature Language="C#" Value="protected virtual System.Xaml.Schema.XamlMemberInvoker LookupInvoker ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Xaml.Schema.XamlMemberInvoker LookupInvoker() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.LookupInvoker" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupInvoker () As XamlMemberInvoker" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Xaml::Schema::XamlMemberInvoker ^ LookupInvoker();" />
      <MemberSignature Language="F#" Value="abstract member LookupInvoker : unit -&gt; System.Xaml.Schema.XamlMemberInvoker&#xA;override this.LookupInvoker : unit -&gt; System.Xaml.Schema.XamlMemberInvoker" Usage="xamlMember.LookupInvoker " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.Schema.XamlMemberInvoker</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retorna um <see cref="T:System.Xaml.Schema.XamlMemberInvoker" /> que é associado a esse <see cref="T:System.Xaml.XamlMember" />.</summary>
        <returns>As informações de <see cref="T:System.Xaml.Schema.XamlMemberInvoker" /> para este <see cref="T:System.Xaml.XamlMember" /> ou <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método é invocado por chamadas para <xref:System.Xaml.XamlMember.Invoker%2A>.  
  
 A implementação padrão não requer que um <xref:System.Xaml.XamlMember> ser construídas usando um dos construtores que passam um inicial <xref:System.Xaml.Schema.XamlMemberInvoker>. No entanto, um <xref:System.Xaml.XamlMember.UnderlyingMember%2A> valor deve existir para o <xref:System.Xaml.XamlMember>; caso contrário, retorna a implementação padrão `null`.  
  
 Substitua este método se você também derivar de <xref:System.Xaml.Schema.XamlMemberInvoker> e pretendia retornar classe derivada. Se você retornar `null`, <xref:System.Xaml.XamlMember.Invoker%2A> retorna <xref:System.Xaml.Schema.XamlMemberInvoker.UnknownInvoker%2A?displayProperty=nameWithType> para chamadores.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Xaml.XamlMember.Invoker" />
        <altmember cref="T:System.Xaml.Schema.XamlMemberInvoker" />
      </Docs>
    </Member>
    <Member MemberName="LookupIsAmbient">
      <MemberSignature Language="C#" Value="protected virtual bool LookupIsAmbient ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool LookupIsAmbient() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.LookupIsAmbient" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupIsAmbient () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool LookupIsAmbient();" />
      <MemberSignature Language="F#" Value="abstract member LookupIsAmbient : unit -&gt; bool&#xA;override this.LookupIsAmbient : unit -&gt; bool" Usage="xamlMember.LookupIsAmbient " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retorna se este <see cref="T:System.Xaml.XamlMember" /> é relatado como uma propriedade de ambiente.</summary>
        <returns>
          <see langword="true" /> para relatar este <see cref="T:System.Xaml.XamlMember" /> como uma propriedade de ambiente, caso contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método é invocado por chamadas internas que verificar se há informações de propriedade do ambiente XAML. Comportamento de propriedade de ambiente é contabilizado no comportamento de API público de leitores XAML e gravadores XAML. As chamadas internas que fazem referência a <xref:System.Xaml.XamlMember.LookupIsAmbient%2A> geralmente fazem parte da lógica de processamento de XAML para certificar-se de que os objetos e os valores que se baseiam no uso de ambiente para a qualificação do tipo podem funcionar corretamente. A implementação de serviços XAML do .NET Framework padrão usa a atribuição para obter essas informações de reflexão fazendo tipos CLR. Especificamente, a implementação padrão procura <xref:System.Windows.Markup.AmbientAttribute> e retorna `true` para <xref:System.Xaml.XamlMember.LookupIsAmbient%2A> se <xref:System.Windows.Markup.AmbientAttribute> existe em uma definição de membro.  
  
 Substitua este método se você não estiver usando <xref:System.Windows.Markup.AmbientAttribute> para essa finalidade e a intenção de substituir essa técnica para indicar propriedades XAML ambiente com sua própria técnica.  
  
 Exemplo APIs do WPF esse atributo com <xref:System.Windows.Markup.AmbientAttribute> são <xref:System.Windows.Trigger.Property%2A?displayProperty=nameWithType> e <xref:System.Windows.Style.BasedOn%2A?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Markup.AmbientAttribute" />
      </Docs>
    </Member>
    <Member MemberName="LookupIsEvent">
      <MemberSignature Language="C#" Value="protected virtual bool LookupIsEvent ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool LookupIsEvent() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.LookupIsEvent" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupIsEvent () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool LookupIsEvent();" />
      <MemberSignature Language="F#" Value="abstract member LookupIsEvent : unit -&gt; bool&#xA;override this.LookupIsEvent : unit -&gt; bool" Usage="xamlMember.LookupIsEvent " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retorna se este <see cref="T:System.Xaml.XamlMember" /> representa um evento.</summary>
        <returns>
          <see langword="true" /> para relatar que este <see cref="T:System.Xaml.XamlMember" /> representa um evento, caso contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 As verificações de implementação padrão se <xref:System.Xaml.XamlMember.UnderlyingMember%2A> é do tipo <xref:System.Reflection.EventInfo>e se for, retornará `true`.  
  
 Esse método é chamado quando um chamador obtém um valor de <xref:System.Xaml.XamlMember.IsEvent%2A>. Substitua este método se você deseja relatar resultados uniforme para toda uma <xref:System.Xaml.XamlMember> derivado da classe, ou se você tiver um especializado metadados disponíveis que podem ser interpretados para determinar o XAML tipo representações de sistema em uma base por caso.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Xaml.XamlMember.IsEvent" />
      </Docs>
    </Member>
    <Member MemberName="LookupIsReadOnly">
      <MemberSignature Language="C#" Value="protected virtual bool LookupIsReadOnly ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool LookupIsReadOnly() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.LookupIsReadOnly" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupIsReadOnly () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool LookupIsReadOnly();" />
      <MemberSignature Language="F#" Value="abstract member LookupIsReadOnly : unit -&gt; bool&#xA;override this.LookupIsReadOnly : unit -&gt; bool" Usage="xamlMember.LookupIsReadOnly " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retorna se este <see cref="T:System.Xaml.XamlMember" /> representa uma propriedade somente leitura pretendida.</summary>
        <returns>
          <see langword="true" /> para relatar este <see cref="T:System.Xaml.XamlMember" /> como uma propriedade somente leitura pretendida, caso contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A implementação padrão retorna `true` se <xref:System.Xaml.XamlMember.UnderlyingMember%2A> existe, mas um público `set` acessador não existe para ele, conforme determinado pela reflexão interno.  
  
 Esse método é chamado quando um chamador obtém um valor de <xref:System.Xaml.XamlMember.IsReadOnly%2A>. Substitua este método se você deseja relatar resultados uniforme para toda uma <xref:System.Xaml.XamlMember> derivado da classe, ou se você tiver um especializado metadados disponíveis que podem ser interpretados para determinar o XAML tipo representações de sistema em uma base por caso.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Xaml.XamlMember.IsReadOnly" />
      </Docs>
    </Member>
    <Member MemberName="LookupIsReadPublic">
      <MemberSignature Language="C#" Value="protected virtual bool LookupIsReadPublic ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool LookupIsReadPublic() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.LookupIsReadPublic" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupIsReadPublic () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool LookupIsReadPublic();" />
      <MemberSignature Language="F#" Value="abstract member LookupIsReadPublic : unit -&gt; bool&#xA;override this.LookupIsReadPublic : unit -&gt; bool" Usage="xamlMember.LookupIsReadPublic " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retorna se este <see cref="T:System.Xaml.XamlMember" /> representa uma propriedade que tem um acessador <see langword="get" /> público.</summary>
        <returns>
          <see langword="true" /> se este <see cref="T:System.Xaml.XamlMember" /> representa uma propriedade que tem um acessador público <see langword="get" />, caso contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A implementação padrão retorna resultados com base em reflexão interno ou a negação de <xref:System.Xaml.XamlMember.IsWriteOnly%2A>, o processamento nessa ordem.  
  
 <xref:System.Xaml.XamlMember.LookupIsReadPublic%2A> Retorna se o próprio membro é público; ele retorna `true` para um membro público em um confidenciais tipo declarativo. Use <xref:System.Xaml.XamlMember.IsReadPublic%2A> em vez disso, se você também queira considerar a visibilidade do tipo declarativo.  
  
 Esse método é chamado quando um chamador obtém um valor de <xref:System.Xaml.XamlMember.IsReadPublic%2A>. Substitua este método se você deseja relatar resultados uniforme para toda uma <xref:System.Xaml.XamlMember> derivado da classe, ou se você tiver um especializado metadados disponíveis para determinar isso em uma base por caso.  
  
> [!IMPORTANT]
>  O <xref:System.Xaml.XamlMember.LookupIsReadPublic%2A> método é virtual e, portanto, pode ser substituído. A substituição tem o potencial de mudar (maliciosamente ou não) as informações de acesso reportadas de um membro XAML para que ele não alinhe de forma esperada com as informações de acesso de sua declaração de CLR subjacente do tipo system. Para qualquer verificação de segurança crítica dos níveis de acesso, use o tipo CLR subjacente.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Xaml.XamlMember.IsReadPublic" />
      </Docs>
    </Member>
    <Member MemberName="LookupIsUnknown">
      <MemberSignature Language="C#" Value="protected virtual bool LookupIsUnknown ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool LookupIsUnknown() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.LookupIsUnknown" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupIsUnknown () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool LookupIsUnknown();" />
      <MemberSignature Language="F#" Value="abstract member LookupIsUnknown : unit -&gt; bool&#xA;override this.LookupIsUnknown : unit -&gt; bool" Usage="xamlMember.LookupIsUnknown " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retorna se este <see cref="T:System.Xaml.XamlMember" /> representa um membro que não pode ser resolvido pelo sistema de backup que é usado para a resolução de tipo e membro.</summary>
        <returns>
          <see langword="true" /> se este <see cref="T:System.Xaml.XamlMember" /> representar um membro não pode ser resolvido; caso contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método pode ser chamado quando um chamador obtém um valor de <xref:System.Xaml.XamlMember.IsUnknown%2A>. A implementação padrão retorna resultados com base em qualquer reflexão interno ou verificando um `null` valor <xref:System.Xaml.XamlMember.UnderlyingMember%2A>, o processamento nessa ordem.  
  
 Substitua este método se você deseja relatar resultados uniforme para toda uma <xref:System.Xaml.XamlMember> derivado da classe, ou se você tiver um especializado metadados disponíveis para determinar isso em uma base por caso.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Xaml.XamlMember.IsUnknown" />
      </Docs>
    </Member>
    <Member MemberName="LookupIsWriteOnly">
      <MemberSignature Language="C#" Value="protected virtual bool LookupIsWriteOnly ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool LookupIsWriteOnly() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.LookupIsWriteOnly" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupIsWriteOnly () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool LookupIsWriteOnly();" />
      <MemberSignature Language="F#" Value="abstract member LookupIsWriteOnly : unit -&gt; bool&#xA;override this.LookupIsWriteOnly : unit -&gt; bool" Usage="xamlMember.LookupIsWriteOnly " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retorna se este <see cref="T:System.Xaml.XamlMember" /> representa um membro que tem um acessador <see langword="set" /> público, mas não um acessador <see langword="get" /> público.</summary>
        <returns>
          <see langword="true" /> se este <see cref="T:System.Xaml.XamlMember" /> representar um membro somente gravação, caso contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A implementação padrão retorna `true` se um <xref:System.Xaml.XamlMember.UnderlyingMember%2A> existe que tem um público `set` acessador e um confidenciais `get` acessador, conforme determinado pela reflexão interno.  
  
 Esse método é chamado quando um chamador obtém um valor de <xref:System.Xaml.XamlMember.IsWriteOnly%2A>. Substitua este método se você deseja relatar resultados uniforme para toda uma <xref:System.Xaml.XamlMember> derivado da classe, ou se você tiver um especializado metadados disponíveis para determinar isso em uma base por caso.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Xaml.XamlMember.IsWriteOnly" />
      </Docs>
    </Member>
    <Member MemberName="LookupIsWritePublic">
      <MemberSignature Language="C#" Value="protected virtual bool LookupIsWritePublic ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool LookupIsWritePublic() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.LookupIsWritePublic" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupIsWritePublic () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool LookupIsWritePublic();" />
      <MemberSignature Language="F#" Value="abstract member LookupIsWritePublic : unit -&gt; bool&#xA;override this.LookupIsWritePublic : unit -&gt; bool" Usage="xamlMember.LookupIsWritePublic " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retorna se este <see cref="T:System.Xaml.XamlMember" /> representa um membro de que tem um acessador <see langword="set" /> público.</summary>
        <returns>
          <see langword="true" /> se este <see cref="T:System.Xaml.XamlMember" /> representar um membro gravável, caso contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A implementação padrão retorna resultados com base em reflexão interno ou a negação de <xref:System.Xaml.XamlMember.IsReadOnly%2A>, o processamento nessa ordem.  
  
 Esse método é chamado quando um chamador obtém um valor de <xref:System.Xaml.XamlMember.IsWritePublic%2A>. Substitua este método se você deseja relatar resultados uniforme para toda uma <xref:System.Xaml.XamlMember> derivado da classe, ou se você tiver um especializado metadados disponíveis para determinar isso em uma base por caso.  
  
> [!IMPORTANT]
>  O <xref:System.Xaml.XamlMember.LookupIsWritePublic%2A> método é virtual e, portanto, pode ser substituído. A substituição tem o potencial de mudar (maliciosamente ou não) as informações de acesso reportadas de um membro XAML para que ele não alinhe de forma esperada com as informações de acesso de sua declaração de CLR subjacente do tipo system. Para qualquer verificação de segurança crítica dos níveis de acesso, use o tipo CLR subjacente.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Xaml.XamlMember.IsWritePublic" />
      </Docs>
    </Member>
    <Member MemberName="LookupMarkupExtensionBracketCharacters">
      <MemberSignature Language="C#" Value="protected virtual System.Collections.Generic.IReadOnlyDictionary&lt;char,char&gt; LookupMarkupExtensionBracketCharacters ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Collections.Generic.IReadOnlyDictionary`2&lt;char, char&gt; LookupMarkupExtensionBracketCharacters() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.LookupMarkupExtensionBracketCharacters" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupMarkupExtensionBracketCharacters () As IReadOnlyDictionary(Of Char, Char)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Collections::Generic::IReadOnlyDictionary&lt;char, char&gt; ^ LookupMarkupExtensionBracketCharacters();" />
      <MemberSignature Language="F#" Value="abstract member LookupMarkupExtensionBracketCharacters : unit -&gt; System.Collections.Generic.IReadOnlyDictionary&lt;char, char&gt;&#xA;override this.LookupMarkupExtensionBracketCharacters : unit -&gt; System.Collections.Generic.IReadOnlyDictionary&lt;char, char&gt;" Usage="xamlMember.LookupMarkupExtensionBracketCharacters " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IReadOnlyDictionary&lt;System.Char,System.Char&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retorna os caracteres de colchete de abertura e fechamento de uma extensão de marcação.</summary>
        <returns>Uma coleção que contém os caracteres de colchete de abertura e fechamento.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupTargetType">
      <MemberSignature Language="C#" Value="protected virtual System.Xaml.XamlType LookupTargetType ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Xaml.XamlType LookupTargetType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.LookupTargetType" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupTargetType () As XamlType" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Xaml::XamlType ^ LookupTargetType();" />
      <MemberSignature Language="F#" Value="abstract member LookupTargetType : unit -&gt; System.Xaml.XamlType&#xA;override this.LookupTargetType : unit -&gt; System.Xaml.XamlType" Usage="xamlMember.LookupTargetType " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.XamlType</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retorna o <see cref="T:System.Xaml.XamlType" /> do tipo em que o <see cref="T:System.Xaml.XamlMember" /> pode existir.</summary>
        <returns>O tipo em que o <see cref="T:System.Xaml.XamlMember" /> pode existir.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A implementação padrão faz distinção entre os membros anexáveis e não anexável. Para membros não anexável, <xref:System.Xaml.XamlMember.LookupTargetType%2A> sempre retorna <xref:System.Xaml.XamlMember.DeclaringType%2A>. Para membros anexáveis, <xref:System.Xaml.XamlMember.LookupTargetType%2A> retorna um resultado com base em examinar o <xref:System.Xaml.XamlMember.UnderlyingMember%2A> tipo de parâmetro do acessador e interpreta que tipo com base no contexto do esquema XAML.  
  
 Esse método é chamado quando um chamador obtém um valor de <xref:System.Xaml.XamlMember.TargetType%2A>. Substitua este método se você deseja relatar resultados uniforme para toda uma <xref:System.Xaml.XamlMember> derivado da classe, ou se você tiver um especializado metadados disponíveis para determinar isso em uma base por caso.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Xaml.XamlMember.TargetType" />
      </Docs>
    </Member>
    <Member MemberName="LookupType">
      <MemberSignature Language="C#" Value="protected virtual System.Xaml.XamlType LookupType ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Xaml.XamlType LookupType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.LookupType" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupType () As XamlType" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Xaml::XamlType ^ LookupType();" />
      <MemberSignature Language="F#" Value="abstract member LookupType : unit -&gt; System.Xaml.XamlType&#xA;override this.LookupType : unit -&gt; System.Xaml.XamlType" Usage="xamlMember.LookupType " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.XamlType</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retorna o <see cref="T:System.Xaml.XamlType" /> do tipo que é usado pelo membro.</summary>
        <returns>O <see cref="T:System.Xaml.XamlType" /> do tipo que é usado pelo membro.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método é chamado quando um chamador obtém um valor de <xref:System.Xaml.XamlMember.Type%2A>. Substitua este método se desejar <xref:System.Xaml.XamlMember.Type%2A> para retornar um valor diferente do valor que é habilitado por reflexão interno do padrão, e se você estiver fornecendo também personalizado <xref:System.Xaml.Schema.XamlMemberInvoker> informações.  
  
 A implementação padrão usa caminhos de código diferentes e significados conceituais para retornado <xref:System.Xaml.XamlType> que baseia-se isso <xref:System.Xaml.XamlMember> representa uma propriedade, método ou evento.  
  
-   Para uma propriedade, retornada <xref:System.Xaml.XamlType> é o tipo que define a propriedade ou é retornado pela propriedade.  
  
-   Para um evento, retornado <xref:System.Xaml.XamlType> é o tipo de manipulador de eventos necessários (um delegado em uma implementação de CLR).  
  
-   Para um método, <xref:System.Xaml.XamlType> é o tipo de retorno.  
  
 Em cada caso, o contexto do esquema XML é usado para avaliar o tipo XAML do tipo de sistema subjacente.  
  
 Esse método é chamado quando um chamador obtém um valor de <xref:System.Xaml.XamlMember.Type%2A>. Substitua este método se você deseja relatar resultados uniforme para toda uma <xref:System.Xaml.XamlMember> derivado da classe, ou se você tiver um especializado metadados disponíveis para determinar isso em uma base por caso.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Xaml.XamlMember.Type" />
      </Docs>
    </Member>
    <Member MemberName="LookupTypeConverter">
      <MemberSignature Language="C#" Value="protected virtual System.Xaml.Schema.XamlValueConverter&lt;System.ComponentModel.TypeConverter&gt; LookupTypeConverter ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Xaml.Schema.XamlValueConverter`1&lt;class System.ComponentModel.TypeConverter&gt; LookupTypeConverter() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.LookupTypeConverter" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupTypeConverter () As XamlValueConverter(Of TypeConverter)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Xaml::Schema::XamlValueConverter&lt;System::ComponentModel::TypeConverter ^&gt; ^ LookupTypeConverter();" />
      <MemberSignature Language="F#" Value="abstract member LookupTypeConverter : unit -&gt; System.Xaml.Schema.XamlValueConverter&lt;System.ComponentModel.TypeConverter&gt;&#xA;override this.LookupTypeConverter : unit -&gt; System.Xaml.Schema.XamlValueConverter&lt;System.ComponentModel.TypeConverter&gt;" Usage="xamlMember.LookupTypeConverter " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.Schema.XamlValueConverter&lt;System.ComponentModel.TypeConverter&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retorna uma implementação do conversos de tipo associado a este <see cref="T:System.Xaml.XamlMember" />.</summary>
        <returns>Uma instância <see cref="T:System.Xaml.Schema.XamlValueConverter`1" /> com a restrição <see cref="T:System.ComponentModel.TypeConverter" /> ou <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A implementação padrão usa a seguinte lógica e a ordem de processamento:  
  
-   Se a atribuição existe no nível de membro (<xref:System.ComponentModel.TypeConverterAttribute>), as informações de atributo são usadas para chamar <xref:System.Xaml.XamlSchemaContext.GetValueConverter%2A> em relação ao contexto de esquema XAML.  
  
-   Se <xref:System.Xaml.XamlMember.Type%2A> for válido, um conversor de tipo que está associado com o tipo será retornado.  
  
-   Se o membro é um evento, um conversor de tipo de evento específico será retornado.  
  
 Esse método é chamado quando um chamador obtém um valor de <xref:System.Xaml.XamlMember.TypeConverter%2A>. Substitua este método se você deseja relatar resultados uniforme para toda uma <xref:System.Xaml.XamlMember> derivado da classe, ou se você tiver um especializado metadados disponíveis para determinar isso em uma base por caso.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Xaml.XamlMember.TypeConverter" />
      </Docs>
    </Member>
    <Member MemberName="LookupUnderlyingGetter">
      <MemberSignature Language="C#" Value="protected virtual System.Reflection.MethodInfo LookupUnderlyingGetter ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Reflection.MethodInfo LookupUnderlyingGetter() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.LookupUnderlyingGetter" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupUnderlyingGetter () As MethodInfo" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Reflection::MethodInfo ^ LookupUnderlyingGetter();" />
      <MemberSignature Language="F#" Value="abstract member LookupUnderlyingGetter : unit -&gt; System.Reflection.MethodInfo&#xA;override this.LookupUnderlyingGetter : unit -&gt; System.Reflection.MethodInfo" Usage="xamlMember.LookupUnderlyingGetter " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retorna um acessador <see langword="get" /> associado a este <see cref="T:System.Xaml.XamlMember" />.</summary>
        <returns>O <see cref="T:System.Reflection.MethodInfo" /> para o acessador <see langword="get" /> associado ou <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A implementação padrão interpreta o <xref:System.Xaml.XamlMember.UnderlyingMember%2A> a propriedade como <xref:System.Reflection.PropertyInfo> e retorna o valor de <xref:System.Reflection.PropertyInfo.GetGetMethod%2A?displayProperty=nameWithType> (com o parâmetro definido `true`), que significa que o método retornado pode ser confidenciais. Esse comportamento pode resultar em `null` para determinados casos. incluindo casos em que nenhum acessador associado existe ou o membro não é uma propriedade.  
  
 Esse método é chamado quando um chamador obtém um valor da <xref:System.Xaml.Schema.XamlMemberInvoker.UnderlyingGetter%2A> propriedade em um tipo de <xref:System.Xaml.Schema.XamlMemberInvoker>. Substitua este método se você deseja relatar resultados uniforme para toda uma <xref:System.Xaml.XamlMember> derivado da classe, ou se você tiver um especializado metadados disponíveis para determinar isso em uma base por caso. Certifique-se de implementar <xref:System.Xaml.XamlMember.LookupUnderlyingGetter%2A>, <xref:System.Xaml.XamlMember.LookupUnderlyingSetter%2A>, e <xref:System.Xaml.XamlMember.LookupUnderlyingMember%2A> para que retornem resultados correlacionados.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupUnderlyingMember">
      <MemberSignature Language="C#" Value="protected virtual System.Reflection.MemberInfo LookupUnderlyingMember ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Reflection.MemberInfo LookupUnderlyingMember() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.LookupUnderlyingMember" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupUnderlyingMember () As MemberInfo" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Reflection::MemberInfo ^ LookupUnderlyingMember();" />
      <MemberSignature Language="F#" Value="abstract member LookupUnderlyingMember : unit -&gt; System.Reflection.MemberInfo&#xA;override this.LookupUnderlyingMember : unit -&gt; System.Reflection.MemberInfo" Usage="xamlMember.LookupUnderlyingMember " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberInfo</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retorna um <see cref="T:System.Reflection.MemberInfo" /> do sistema de tipo CLR que está associado a este <see cref="T:System.Xaml.XamlMember" />.</summary>
        <returns>Cria um objeto <see cref="T:System.Reflection.MemberInfo" /> do sistema de tipo CLR que está associado a este <see cref="T:System.Xaml.XamlMember" /> ou <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A implementação padrão retorna as informações de membro subjacente, que se baseia em construção. Se o <xref:System.Reflection.MemberInfo> objeto for construído com uma assinatura que não fornece informações suficientes para definir o membro base, esse método retornará `null`.  
  
 Se um membro subjacente foi definido durante a construção, você não precisará chamar esse método.  
  
 Esse método é chamado quando um chamador obtém um valor de <xref:System.Xaml.XamlMember.UnderlyingMember%2A>. Substitua este método se você deseja relatar resultados uniforme para toda uma <xref:System.Xaml.XamlMember> derivado da classe, ou se você tiver um especializado metadados disponíveis para determinar isso em uma base por caso. Certifique-se de implementar <xref:System.Xaml.XamlMember.LookupUnderlyingGetter%2A>, <xref:System.Xaml.XamlMember.LookupUnderlyingSetter%2A>, e <xref:System.Xaml.XamlMember.LookupUnderlyingMember%2A> para que retornem resultados correlacionados.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Xaml.XamlMember.UnderlyingMember" />
      </Docs>
    </Member>
    <Member MemberName="LookupUnderlyingSetter">
      <MemberSignature Language="C#" Value="protected virtual System.Reflection.MethodInfo LookupUnderlyingSetter ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Reflection.MethodInfo LookupUnderlyingSetter() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.LookupUnderlyingSetter" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupUnderlyingSetter () As MethodInfo" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Reflection::MethodInfo ^ LookupUnderlyingSetter();" />
      <MemberSignature Language="F#" Value="abstract member LookupUnderlyingSetter : unit -&gt; System.Reflection.MethodInfo&#xA;override this.LookupUnderlyingSetter : unit -&gt; System.Reflection.MethodInfo" Usage="xamlMember.LookupUnderlyingSetter " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retorna um acessador <see langword="set" /> associado a este <see cref="T:System.Xaml.XamlMember" />.</summary>
        <returns>O <see cref="T:System.Reflection.MethodInfo" /> para o acessador <see langword="set" /> associado ou <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A implementação padrão interpreta <xref:System.Xaml.XamlMember.UnderlyingMember%2A> como <xref:System.Reflection.PropertyInfo> e retorna o valor de <xref:System.Reflection.PropertyInfo.GetSetMethod%2A?displayProperty=nameWithType> (com o parâmetro definido `true`), que significa que o método retornado pode ser confidenciais. Isso pode resultar em `null` para certos casos, inclusive os casos em que não há nenhum tal acessador ou o membro não é uma propriedade.  
  
 Esse método é chamado quando um chamador obtém um valor de <xref:System.Xaml.Schema.XamlMemberInvoker.UnderlyingSetter%2A> em um tipo de <xref:System.Xaml.Schema.XamlMemberInvoker>. Substitua este método se você deseja relatar resultados uniforme para toda uma <xref:System.Xaml.XamlMember> derivado da classe, ou se você tiver um especializado metadados disponíveis para determinar isso em uma base por caso. Certifique-se de implementar <xref:System.Xaml.XamlMember.LookupUnderlyingGetter%2A>, <xref:System.Xaml.XamlMember.LookupUnderlyingSetter%2A>, e <xref:System.Xaml.XamlMember.LookupUnderlyingMember%2A> para que retornem resultados correlacionados.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupValueSerializer">
      <MemberSignature Language="C#" Value="protected virtual System.Xaml.Schema.XamlValueConverter&lt;System.Windows.Markup.ValueSerializer&gt; LookupValueSerializer ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Xaml.Schema.XamlValueConverter`1&lt;class System.Windows.Markup.ValueSerializer&gt; LookupValueSerializer() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.LookupValueSerializer" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupValueSerializer () As XamlValueConverter(Of ValueSerializer)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Xaml::Schema::XamlValueConverter&lt;System::Windows::Markup::ValueSerializer ^&gt; ^ LookupValueSerializer();" />
      <MemberSignature Language="F#" Value="abstract member LookupValueSerializer : unit -&gt; System.Xaml.Schema.XamlValueConverter&lt;System.Windows.Markup.ValueSerializer&gt;&#xA;override this.LookupValueSerializer : unit -&gt; System.Xaml.Schema.XamlValueConverter&lt;System.Windows.Markup.ValueSerializer&gt;" Usage="xamlMember.LookupValueSerializer " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.Schema.XamlValueConverter&lt;System.Windows.Markup.ValueSerializer&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retorna uma implementação do serializador de valor que está associado a este <see cref="T:System.Xaml.XamlMember" />.</summary>
        <returns>Uma instância <see cref="T:System.Xaml.Schema.XamlValueConverter`1" /> com a restrição <see cref="T:System.Windows.Markup.ValueSerializer" /> ou <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A implementação padrão usa a seguinte lógica e a ordem de processamento:  
  
-   Se a atribuição existe no nível de membro (<xref:System.Windows.Markup.ValueSerializerAttribute>), as informações de atributo são usadas para chamar <xref:System.Xaml.XamlSchemaContext.GetValueConverter%2A> em relação ao contexto de esquema XAML.  
  
-   Se <xref:System.Xaml.XamlMember.Type%2A> for válido, um conversor de valor que está associado com o tipo será retornado.  
  
-   Se não se aplicam as condições anteriores, `null` será retornado.  
  
 Esse método é chamado quando um chamador obtém um valor de <xref:System.Xaml.XamlMember.ValueSerializer%2A>. Substitua este método se você deseja relatar resultados uniforme para toda uma <xref:System.Xaml.XamlMember> derivado da classe, ou se você tiver um especializado metadados disponíveis para determinar isso em uma base por caso.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Xaml.XamlMember.ValueSerializer" />
      </Docs>
    </Member>
    <Member MemberName="MarkupExtensionBracketCharacters">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IReadOnlyDictionary&lt;char,char&gt; MarkupExtensionBracketCharacters { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IReadOnlyDictionary`2&lt;char, char&gt; MarkupExtensionBracketCharacters" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlMember.MarkupExtensionBracketCharacters" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property MarkupExtensionBracketCharacters As IReadOnlyDictionary(Of Char, Char)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Generic::IReadOnlyDictionary&lt;char, char&gt; ^ MarkupExtensionBracketCharacters { System::Collections::Generic::IReadOnlyDictionary&lt;char, char&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.MarkupExtensionBracketCharacters : System.Collections.Generic.IReadOnlyDictionary&lt;char, char&gt;" Usage="System.Xaml.XamlMember.MarkupExtensionBracketCharacters" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IReadOnlyDictionary&lt;System.Char,System.Char&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Define os caracteres de colchete de abertura e fechamento de uma extensão de marcação.</summary>
        <value>Uma coleção que contém os caracteres de colchete de abertura e fechamento.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public string Name { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlMember.Name" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Name As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Name { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Name : string" Usage="System.Xaml.XamlMember.Name" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém o nome de cadeia de caracteres <see langword="xamlName" /> que declara este <see cref="T:System.Xaml.XamlMember" />.</summary>
        <value>O <see langword="xamlName" /> nome de cadeia de caracteres que declara isso <see cref="T:System.Xaml.XamlMember" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse valor é sempre definido durante a construção. Os construtores que são implementados por <xref:System.Xaml.XamlMember> normalmente lançar uma exceção se não for especificado um nome inicial; portanto, não espere essa propriedade para ser `null` ou uma cadeia de caracteres vazia, se você estiver usando serviços de XAML padrão .NET Framework implementações.  
  
 [Gramática XamlName](~/docs/framework/xaml-services/xamlname-grammar.md) e as regras de nomenclatura para o tipo CLR e os membros não são uma interseção exata. É possível declarar um nome de membro que é válido em CLR, mas não é válido em XAML de nomenclatura. Você deve evitar essa situação, se possível.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (System.Xaml.XamlMember xamlMember1, System.Xaml.XamlMember xamlMember2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(class System.Xaml.XamlMember xamlMember1, class System.Xaml.XamlMember xamlMember2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.op_Equality(System.Xaml.XamlMember,System.Xaml.XamlMember)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator == (xamlMember1 As XamlMember, xamlMember2 As XamlMember) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator ==(System::Xaml::XamlMember ^ xamlMember1, System::Xaml::XamlMember ^ xamlMember2);" />
      <MemberSignature Language="F#" Value="static member ( = ) : System.Xaml.XamlMember * System.Xaml.XamlMember -&gt; bool" Usage="xamlMember1 = xamlMember2" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="xamlMember1" Type="System.Xaml.XamlMember" />
        <Parameter Name="xamlMember2" Type="System.Xaml.XamlMember" />
      </Parameters>
      <Docs>
        <param name="xamlMember1">
          <see cref="T:System.Xaml.XamlMember" /> ou <see langword="null" />.</param>
        <param name="xamlMember2">
          <see cref="T:System.Xaml.XamlMember" /> ou <see langword="null" />.</param>
        <summary>Determina se dois objetos <see cref="T:System.Xaml.XamlMember" /> especificados têm o mesmo valor.</summary>
        <returns>
          <see langword="true" /> se o valor de <paramref name="xamlMember1" /> for o mesmo que o valor de <paramref name="xamlMember2" />; caso contrário, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (System.Xaml.XamlMember xamlMember1, System.Xaml.XamlMember xamlMember2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(class System.Xaml.XamlMember xamlMember1, class System.Xaml.XamlMember xamlMember2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.op_Inequality(System.Xaml.XamlMember,System.Xaml.XamlMember)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator != (xamlMember1 As XamlMember, xamlMember2 As XamlMember) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator !=(System::Xaml::XamlMember ^ xamlMember1, System::Xaml::XamlMember ^ xamlMember2);" />
      <MemberSignature Language="F#" Value="static member op_Inequality : System.Xaml.XamlMember * System.Xaml.XamlMember -&gt; bool" Usage="System.Xaml.XamlMember.op_Inequality (xamlMember1, xamlMember2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="xamlMember1" Type="System.Xaml.XamlMember" />
        <Parameter Name="xamlMember2" Type="System.Xaml.XamlMember" />
      </Parameters>
      <Docs>
        <param name="xamlMember1">
          <see cref="T:System.Xaml.XamlMember" /> ou <see langword="null" />.</param>
        <param name="xamlMember2">
          <see cref="T:System.Xaml.XamlMember" /> ou <see langword="null" />.</param>
        <summary>Determina se dois objetos <see cref="T:System.Xaml.XamlMember" /> especificados têm valores diferentes.</summary>
        <returns>
          <see langword="true" /> se o valor de <paramref name="xamlMember1" /> for diferente do valor de <paramref name="xamlMember2" />; caso contrário, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PreferredXamlNamespace">
      <MemberSignature Language="C#" Value="public string PreferredXamlNamespace { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string PreferredXamlNamespace" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlMember.PreferredXamlNamespace" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PreferredXamlNamespace As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ PreferredXamlNamespace { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.PreferredXamlNamespace : string" Usage="System.Xaml.XamlMember.PreferredXamlNamespace" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém o único URI de namespace de XAML que identifica o namespace de XAML primário para este <see cref="T:System.Xaml.XamlMember" />.</summary>
        <value>O identificador do namespace XAML primário para este <see cref="T:System.Xaml.XamlMember" />, como uma cadeia de caracteres.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Xaml.XamlMember.PreferredXamlNamespace%2A> propriedade fornece o mesmo valor que a chamada <xref:System.Xaml.XamlMember.GetXamlNamespaces%2A> e, em seguida, obter a primeira cadeia de caracteres do valor da lista retornada. O namespace XAML preferencial deve ser usado ao gravar o membro de volta para o texto ou outras representações que preservam as informações de namespace XAML.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SerializationVisibility">
      <MemberSignature Language="C#" Value="public System.ComponentModel.DesignerSerializationVisibility SerializationVisibility { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.ComponentModel.DesignerSerializationVisibility SerializationVisibility" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlMember.SerializationVisibility" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SerializationVisibility As DesignerSerializationVisibility" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::ComponentModel::DesignerSerializationVisibility SerializationVisibility { System::ComponentModel::DesignerSerializationVisibility get(); };" />
      <MemberSignature Language="F#" Value="member this.SerializationVisibility : System.ComponentModel.DesignerSerializationVisibility" Usage="System.Xaml.XamlMember.SerializationVisibility" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ComponentModel.DesignerSerializationVisibility</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém um valor <see cref="T:System.ComponentModel.DesignerSerializationVisibility" />, que indica como um designer visual deve processar o membro.</summary>
        <value>Um valor da enumeração <see cref="T:System.ComponentModel.DesignerSerializationVisibility" />. O padrão é <see cref="F:System.ComponentModel.DesignerSerializationVisibility.Visible" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TargetType">
      <MemberSignature Language="C#" Value="public System.Xaml.XamlType TargetType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Xaml.XamlType TargetType" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlMember.TargetType" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property TargetType As XamlType" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Xaml::XamlType ^ TargetType { System::Xaml::XamlType ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.TargetType : System.Xaml.XamlType" Usage="System.Xaml.XamlMember.TargetType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.XamlType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém o <see cref="T:System.Xaml.XamlType" /> do tipo em que o <see cref="T:System.Xaml.XamlMember" /> pode existir.</summary>
        <value>O tipo em que o <see cref="T:System.Xaml.XamlMember" /> pode existir.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O valor retornado é diferente para membros anexáveis e não anexável. Para membros não anexável, <xref:System.Xaml.XamlMember.TargetType%2A> retorna <xref:System.Xaml.XamlMember.DeclaringType%2A>. Para membros anexáveis, <xref:System.Xaml.XamlMember.LookupTargetType%2A> retorna um resultado com base em lógica:  
  
-   Se a reflexão não é possível resolver um backup (<xref:System.Xaml.XamlMember.IsUnknown%2A> `true`), esse método retorna uma constante interna que representa um tipo de objeto genérico.  
  
-   Se a condição anterior não se aplica, <xref:System.Xaml.XamlMember.LookupTargetType%2A> é chamado. A implementação padrão retorna um <xref:System.Xaml.XamlType> que se baseia no examinando os métodos que implementam o `get` e `set` acessadores. Uma classe pode substituir <xref:System.Xaml.XamlMember.LookupTargetType%2A> usar um comportamento diferente, como outros metadados de formulários que poderá reportar os tipos de destino para membros anexáveis.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="xamlMember.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retorna uma representação de cadeia de caracteres desse <see cref="T:System.Xaml.XamlMember" />.</summary>
        <returns>Uma representação da cadeia de caracteres desse <see cref="T:System.Xaml.XamlMember" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Essa implementação retorna <xref:System.Xaml.XamlMember.Name%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Type">
      <MemberSignature Language="C#" Value="public System.Xaml.XamlType Type { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Xaml.XamlType Type" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlMember.Type" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Type As XamlType" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Xaml::XamlType ^ Type { System::Xaml::XamlType ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Type : System.Xaml.XamlType" Usage="System.Xaml.XamlMember.Type" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.XamlType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém o <see cref="T:System.Xaml.XamlType" /> do tipo que é usado pelo membro.</summary>
        <value>O <see cref="T:System.Xaml.XamlType" /> do tipo que é usado pelo membro.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Chamando <xref:System.Xaml.XamlMember.Type%2A> invoca <xref:System.Xaml.XamlMember.LookupType%2A> ou uma substituição específica desse método. Isso ocorre quando a lógica de reflexão interno inicial ainda não tiver definido as informações.  
  
 No comportamento padrão (nenhuma <xref:System.Xaml.XamlMember.LookupType%2A> substituir), retornado <xref:System.Xaml.XamlType> pode ter diferentes significados conceituais. Aplica-se qual significado depende se isso <xref:System.Xaml.XamlMember> representa uma propriedade, método ou evento, como mostra a lista a seguir:  
  
-   Para uma propriedade, retornada <xref:System.Xaml.XamlType> é o tipo que define a propriedade ou é retornado pela propriedade.  
  
-   Para um evento, retornado <xref:System.Xaml.XamlType> é o tipo de manipulador de eventos necessários (um delegado em uma implementação de CLR).  
  
-   Para um método, <xref:System.Xaml.XamlType> é o tipo de retorno desse método, o que pode ser `null`.  
  
 Em cada caso, o contexto do esquema XAML é usado para avaliar o tipo XAML do tipo de backup.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TypeConverter">
      <MemberSignature Language="C#" Value="public System.Xaml.Schema.XamlValueConverter&lt;System.ComponentModel.TypeConverter&gt; TypeConverter { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Xaml.Schema.XamlValueConverter`1&lt;class System.ComponentModel.TypeConverter&gt; TypeConverter" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlMember.TypeConverter" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property TypeConverter As XamlValueConverter(Of TypeConverter)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Xaml::Schema::XamlValueConverter&lt;System::ComponentModel::TypeConverter ^&gt; ^ TypeConverter { System::Xaml::Schema::XamlValueConverter&lt;System::ComponentModel::TypeConverter ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.TypeConverter : System.Xaml.Schema.XamlValueConverter&lt;System.ComponentModel.TypeConverter&gt;" Usage="System.Xaml.XamlMember.TypeConverter" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.Schema.XamlValueConverter&lt;System.ComponentModel.TypeConverter&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém um objeto <see cref="T:System.Xaml.Schema.XamlValueConverter`1" />, que pode ser usado para a construção de conversão de tipo de objetos declarados XAML.</summary>
        <value>Um <see cref="T:System.Xaml.Schema.XamlValueConverter`1" /> valor, com um <see cref="T:System.ComponentModel.TypeConverter" /> restrição genérica.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Chamando <xref:System.Xaml.XamlMember.TypeConverter%2A> invoca <xref:System.Xaml.XamlMember.LookupTypeConverter%2A> ou uma substituição específica desse método. Esse comportamento ocorre quando a lógica de reflexão interno inicial ainda não tiver definido as informações.  
  
 Valor de implementações que retornam uma propriedade não nula para <xref:System.Xaml.XamlMember.TypeConverter%2A> não são necessariamente um trabalho <xref:System.ComponentModel.TypeConverter>. A seguir está uma lista de possíveis valores de retorno não nulo para <xref:System.Xaml.XamlMember.TypeConverter%2A> e esses valores representam:  
  
-   O valor de retorno relata um conversor de tipo é atribuído especificamente para esse membro ou de forma geral para o tipo de destino do conversor. Normalmente, esse comportamento é que a maioria dos sistemas de tipo XAML e procure processadores XAML para instanciar um conversor de tipo e chamar seus métodos.  
  
-   O valor de retorno relata um conversor de valor interno. Esses conversores existem para determinadas operações internas que são executadas por um autor XAML. Em particular, esses conversores de valor interno converter os valores de cadeia de caracteres bruta de atributo para os primitivos de nível de linguagem XAML. Para a implementação de serviços XAML do .NET Framework, essas conversões de tipo interno geralmente encaminham para um conversor de tipo é definido no assembly System. Por exemplo, uma conversão para um <xref:System.Int32> valor tem interno encaminhado conversão e, portanto, o <xref:System.Xaml.Schema.XamlValueConverter%601.ConverterType%2A> valor referências <xref:System.ComponentModel.Int32Converter>.  
  
-   O valor de retorno relatórios caso especial de um modelo de objeto irrestrita; ou seja, o <xref:System.Xaml.XamlMember> tem um <xref:System.Xaml.XamlMember.Type%2A> valor <xref:System.Object>. Nesse caso, o <xref:System.Xaml.Schema.XamlValueConverter%601> relata que o <xref:System.Xaml.Schema.XamlValueConverter%601.Name%2A?displayProperty=nameWithType> é {`Object}`. No entanto, <xref:System.Xaml.Schema.XamlValueConverter%601.ConverterInstance%2A> é `null` porque nenhum tipo real ou a instância está disponível para realizar essa conversão. Em vez disso, o comportamento do modelo de objeto não pode ser determinado até o tempo de execução, quando o tempo de execução da tecnologia específica determina a manipulação de seu gráfico de objeto.  
  
 Se você puder acessar um trabalho <xref:System.ComponentModel.TypeConverter> de <xref:System.Xaml.Schema.XamlValueConverter%601.ConverterInstance%2A>, você pode chamar seus métodos de conversão. No entanto, vários métodos de conversão confiam no contexto do serviço. Se você não tem o mesmo contexto de serviço disponível que o conversor de tipo de espera para sua função típica de gravação de objetos para gráficos de objeto, os métodos de conversor podem gerar exceções.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UnderlyingMember">
      <MemberSignature Language="C#" Value="public System.Reflection.MemberInfo UnderlyingMember { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.MemberInfo UnderlyingMember" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlMember.UnderlyingMember" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property UnderlyingMember As MemberInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Reflection::MemberInfo ^ UnderlyingMember { System::Reflection::MemberInfo ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.UnderlyingMember : System.Reflection.MemberInfo" Usage="System.Xaml.XamlMember.UnderlyingMember" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém o <see cref="T:System.Reflection.MemberInfo" /> do sistema do tipo CLR que está disponível para um membro que é criado por <see cref="T:System.Reflection.PropertyInfo" />, <see cref="T:System.Reflection.MethodInfo" /> ou <see cref="T:System.Reflection.EventInfo" />.</summary>
        <value>Sistema de tipos CLR <see cref="T:System.Reflection.MemberInfo" /> informações, como conversão de parâmetros de construtor inicial. Um <see cref="T:System.Xaml.XamlMember" /> que é construído com a <see cref="M:System.Xaml.XamlMember.#ctor(System.String,System.Xaml.XamlType,System.Boolean)" /> assinatura retorna <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Chamando <xref:System.Xaml.XamlMember.UnderlyingMember%2A> invoca <xref:System.Xaml.XamlMember.LookupUnderlyingMember%2A> ou uma substituição específica desse método.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ValueSerializer">
      <MemberSignature Language="C#" Value="public System.Xaml.Schema.XamlValueConverter&lt;System.Windows.Markup.ValueSerializer&gt; ValueSerializer { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Xaml.Schema.XamlValueConverter`1&lt;class System.Windows.Markup.ValueSerializer&gt; ValueSerializer" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlMember.ValueSerializer" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ValueSerializer As XamlValueConverter(Of ValueSerializer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Xaml::Schema::XamlValueConverter&lt;System::Windows::Markup::ValueSerializer ^&gt; ^ ValueSerializer { System::Xaml::Schema::XamlValueConverter&lt;System::Windows::Markup::ValueSerializer ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ValueSerializer : System.Xaml.Schema.XamlValueConverter&lt;System.Windows.Markup.ValueSerializer&gt;" Usage="System.Xaml.XamlMember.ValueSerializer" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.Schema.XamlValueConverter&lt;System.Windows.Markup.ValueSerializer&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém um objeto <see cref="T:System.Xaml.Schema.XamlValueConverter`1" />, que é usado para a serialização de valor de objetos declarados XAML.</summary>
        <value>Um <see cref="T:System.Xaml.Schema.XamlValueConverter`1" /> com <see cref="T:System.Windows.Markup.ValueSerializer" /> restrição genérica.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Chamando <xref:System.Xaml.XamlMember.ValueSerializer%2A> invoca <xref:System.Xaml.XamlMember.LookupValueSerializer%2A> ou uma substituição específica desse método. Esse comportamento ocorre quando a lógica de reflexão interno inicial ainda não tiver definido as informações.  
  
 Valor de nem todos os casos que retornam uma propriedade não nula para <xref:System.Xaml.XamlMember.ValueSerializer%2A> são necessariamente um trabalho <xref:System.Windows.Markup.ValueSerializer>. Consulte <xref:System.Xaml.XamlMember.TypeConverter%2A>; as mesmas considerações se aplicam a <xref:System.Xaml.XamlMember.ValueSerializer%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>