<Type Name="XamlType" FullName="System.Xaml.XamlType">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="bb0ff907d26752a779ff68947140ab04c94ff374" />
    <Meta Name="ms.sourcegitcommit" Value="434f60616a9793fa8436744549fc856e94f7a648" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="pt-BR" />
    <Meta Name="ms.lasthandoff" Value="08/25/2018" />
    <Meta Name="ms.locfileid" Value="39978465" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class XamlType : IEquatable&lt;System.Xaml.XamlType&gt;" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit XamlType extends System.Object implements class System.IEquatable`1&lt;class System.Xaml.XamlType&gt;" />
  <TypeSignature Language="DocId" Value="T:System.Xaml.XamlType" />
  <TypeSignature Language="VB.NET" Value="Public Class XamlType&#xA;Implements IEquatable(Of XamlType)" />
  <TypeSignature Language="C++ CLI" Value="public ref class XamlType : IEquatable&lt;System::Xaml::XamlType ^&gt;" />
  <TypeSignature Language="F#" Value="type XamlType = class&#xA;    interface IEquatable&lt;XamlType&gt;" />
  <AssemblyInfo>
    <AssemblyName>System.Xaml</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IEquatable&lt;System.Xaml.XamlType&gt;</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Relata informações sobre os tipos XAML, como parte do sistema geral de XAML que é implementado nos serviços XAML do .NET Framework.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Várias APIs no <xref:System.Xaml.XamlType> classe fornecem informações sobre tipos XAML, onde o conceito relatarem é semelhante a seções específicas da especificação [MS-XAML] de XAML.  
  
 <xref:System.Xaml.XamlType> é usado extensivamente na API de serviços de XAML do .NET Framework para o relatório de informações sobre um tipo XAML. <xref:System.Xaml.XamlType> relata as informações que talvez você precise saber sobre um tipo XAML para trabalhar com uma instância ou para acessar seus membros de um fluxo do nó XAML ou uma representação de XAML semelhante. Seu relatório é semelhante ao modo como o <xref:System.Type> no CLR, digite sistema, junto com as classes de reflexão, como <xref:System.Reflection.MemberInfo>, fornecem informações sobre um tipo CLR e seu uso.  
  
 Para estender o sistema de tipos XAML, você pode derivar de <xref:System.Xaml.XamlType>. Para fazer de forma tão eficaz, você também precisará implementar uma <xref:System.Xaml.Schema.XamlTypeInvoker>. O <xref:System.Xaml.Schema.XamlTypeInvoker> permite que o sistema de tipo XAML generalizado trabalhar com o sistema de tipos fazendo o que você especifique como parte do comportamento de invocação. Personalizado específico <xref:System.Xaml.Schema.XamlTypeInvoker> fornece uma maneira de reduzir as dependências no sistema de tipos CLR, que são usadas pelo padrão <xref:System.Xaml.XamlType> comportamento.  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicializa uma nova instância da classe <see cref="T:System.Xaml.XamlType" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XamlType (Type underlyingType, System.Xaml.XamlSchemaContext schemaContext);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Type underlyingType, class System.Xaml.XamlSchemaContext schemaContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.#ctor(System.Type,System.Xaml.XamlSchemaContext)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (underlyingType As Type, schemaContext As XamlSchemaContext)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; XamlType(Type ^ underlyingType, System::Xaml::XamlSchemaContext ^ schemaContext);" />
      <MemberSignature Language="F#" Value="new System.Xaml.XamlType : Type * System.Xaml.XamlSchemaContext -&gt; System.Xaml.XamlType" Usage="new System.Xaml.XamlType (underlyingType, schemaContext)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="underlyingType" Type="System.Type" />
        <Parameter Name="schemaContext" Type="System.Xaml.XamlSchemaContext" />
      </Parameters>
      <Docs>
        <param name="underlyingType">O CLR subjacente <see cref="T:System.Type" /> para o tipo XAML a ser construído.</param>
        <param name="schemaContext">Contexto do esquema XAML para leitores de XAML ou gravadores de XAML.</param>
        <summary>Inicializa uma nova instância da classe <see cref="T:System.Xaml.XamlType" /> com base nas informações do tipo de CLR subjacente.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">Um ou mais <paramref name="underlyingType" /> ou <paramref name="schemaContext" /> são <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected XamlType (string typeName, System.Collections.Generic.IList&lt;System.Xaml.XamlType&gt; typeArguments, System.Xaml.XamlSchemaContext schemaContext);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(string typeName, class System.Collections.Generic.IList`1&lt;class System.Xaml.XamlType&gt; typeArguments, class System.Xaml.XamlSchemaContext schemaContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.#ctor(System.String,System.Collections.Generic.IList{System.Xaml.XamlType},System.Xaml.XamlSchemaContext)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New (typeName As String, typeArguments As IList(Of XamlType), schemaContext As XamlSchemaContext)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; XamlType(System::String ^ typeName, System::Collections::Generic::IList&lt;System::Xaml::XamlType ^&gt; ^ typeArguments, System::Xaml::XamlSchemaContext ^ schemaContext);" />
      <MemberSignature Language="F#" Value="new System.Xaml.XamlType : string * System.Collections.Generic.IList&lt;System.Xaml.XamlType&gt; * System.Xaml.XamlSchemaContext -&gt; System.Xaml.XamlType" Usage="new System.Xaml.XamlType (typeName, typeArguments, schemaContext)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="typeArguments" Type="System.Collections.Generic.IList&lt;System.Xaml.XamlType&gt;" />
        <Parameter Name="schemaContext" Type="System.Xaml.XamlSchemaContext" />
      </Parameters>
      <Docs>
        <param name="typeName">O nome do tipo a ser criado.</param>
        <param name="typeArguments">Os argumentos de tipo para um <see cref="T:System.Xaml.XamlType" /> que representa um tipo genérico. Pode ser (e geralmente é) <see langword="null" />, o que indica que o tipo representado não é um tipo genérico.</param>
        <param name="schemaContext">Contexto do esquema XAML para leitores de XAML e gravadores de XAML.</param>
        <summary>Inicializa uma nova instância da classe <see cref="T:System.Xaml.XamlType" /> com base em um nome de cadeia de caracteres para o tipo.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse é um construtor protegido. Não há classes derivadas de públicas atuais existem que usam esse caminho específico para a construção. Como um consumidor de existente <xref:System.Xaml.XamlType>, você deve usar as outras assinaturas de construtor (<xref:System.Xaml.XamlType.%23ctor%28System.Type%2CSystem.Xaml.XamlSchemaContext%2CSystem.Xaml.Schema.XamlTypeInvoker%29>, <xref:System.Xaml.XamlType.%23ctor%28System.Type%2CSystem.Xaml.XamlSchemaContext%29>, ou <xref:System.Xaml.XamlType.%23ctor%28System.String%2CSystem.String%2CSystem.Collections.Generic.IList%7BSystem.Xaml.XamlType%7D%2CSystem.Xaml.XamlSchemaContext%29>) para inicializar um <xref:System.Xaml.XamlType> objeto.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Um ou mais <paramref name="typeName" /> ou <paramref name="schemaContext" /> são <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XamlType (Type underlyingType, System.Xaml.XamlSchemaContext schemaContext, System.Xaml.Schema.XamlTypeInvoker invoker);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Type underlyingType, class System.Xaml.XamlSchemaContext schemaContext, class System.Xaml.Schema.XamlTypeInvoker invoker) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.#ctor(System.Type,System.Xaml.XamlSchemaContext,System.Xaml.Schema.XamlTypeInvoker)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (underlyingType As Type, schemaContext As XamlSchemaContext, invoker As XamlTypeInvoker)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; XamlType(Type ^ underlyingType, System::Xaml::XamlSchemaContext ^ schemaContext, System::Xaml::Schema::XamlTypeInvoker ^ invoker);" />
      <MemberSignature Language="F#" Value="new System.Xaml.XamlType : Type * System.Xaml.XamlSchemaContext * System.Xaml.Schema.XamlTypeInvoker -&gt; System.Xaml.XamlType" Usage="new System.Xaml.XamlType (underlyingType, schemaContext, invoker)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="underlyingType" Type="System.Type" />
        <Parameter Name="schemaContext" Type="System.Xaml.XamlSchemaContext" />
        <Parameter Name="invoker" Type="System.Xaml.Schema.XamlTypeInvoker" />
      </Parameters>
      <Docs>
        <param name="underlyingType">O tipo subjacente para o tipo XAML a ser construído.</param>
        <param name="schemaContext">Contexto do esquema XML para o leitor de XAML.</param>
        <param name="invoker">A implementação de <see cref="T:System.Xaml.Schema.XamlTypeInvoker" /> que manipula a reflexão de chamadas do tempo de execução em relação a <see cref="T:System.Xaml.XamlType" />.</param>
        <summary>Inicializa uma nova instância da classe <see cref="T:System.Xaml.XamlType" /> com base nas informações de tipo subjacentes e uma implementação <see cref="T:System.Xaml.Schema.XamlTypeInvoker" />.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">Um ou mais <paramref name="underlyingType" /> ou <paramref name="schemaContext" /> são <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XamlType (string unknownTypeNamespace, string unknownTypeName, System.Collections.Generic.IList&lt;System.Xaml.XamlType&gt; typeArguments, System.Xaml.XamlSchemaContext schemaContext);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string unknownTypeNamespace, string unknownTypeName, class System.Collections.Generic.IList`1&lt;class System.Xaml.XamlType&gt; typeArguments, class System.Xaml.XamlSchemaContext schemaContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.#ctor(System.String,System.String,System.Collections.Generic.IList{System.Xaml.XamlType},System.Xaml.XamlSchemaContext)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (unknownTypeNamespace As String, unknownTypeName As String, typeArguments As IList(Of XamlType), schemaContext As XamlSchemaContext)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; XamlType(System::String ^ unknownTypeNamespace, System::String ^ unknownTypeName, System::Collections::Generic::IList&lt;System::Xaml::XamlType ^&gt; ^ typeArguments, System::Xaml::XamlSchemaContext ^ schemaContext);" />
      <MemberSignature Language="F#" Value="new System.Xaml.XamlType : string * string * System.Collections.Generic.IList&lt;System.Xaml.XamlType&gt; * System.Xaml.XamlSchemaContext -&gt; System.Xaml.XamlType" Usage="new System.Xaml.XamlType (unknownTypeNamespace, unknownTypeName, typeArguments, schemaContext)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="unknownTypeNamespace" Type="System.String" />
        <Parameter Name="unknownTypeName" Type="System.String" />
        <Parameter Name="typeArguments" Type="System.Collections.Generic.IList&lt;System.Xaml.XamlType&gt;" />
        <Parameter Name="schemaContext" Type="System.Xaml.XamlSchemaContext" />
      </Parameters>
      <Docs>
        <param name="unknownTypeNamespace">O namespace de XAML para o tipo, como uma cadeia de caracteres.</param>
        <param name="unknownTypeName">O nome do tipo no namespace de XAML <c>unknownTypeNamespace</c> fornecido.</param>
        <param name="typeArguments">Os argumentos de tipo para um <see cref="T:System.Xaml.XamlType" /> que representa um tipo genérico. Pode ser (e geralmente é) <see langword="null" />, o que indica que o tipo representado não é um tipo genérico.</param>
        <param name="schemaContext">Contexto do esquema XAML para leitores de XAML ou gravadores de XAML.</param>
        <summary>Inicializa uma nova instância da classe <see cref="T:System.Xaml.XamlType" /> com base no namespace de XAML e em um nome de cadeia de caracteres para o tipo. Este construtor é exclusivamente para análise e a gravação de nó de XAML de usos de tipo que são conhecidos por não terem suporte no sistema de tipos compatível nem no contexto de esquema XAML.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use esse construtor somente para tipos de "desconhecidos", onde um tipo XAML que é mapeado para um sistema de tipos subjacente não está disponível. Este construtor não pode produzir um resultado em que <xref:System.Xaml.XamlType.IsUnknown%2A?displayProperty=nameWithType> é `true`. Em vez disso, a lógica do reflector padrão relata o tipo subjacente que <xref:System.Xaml.XamlLanguage.Object%2A?displayProperty=nameWithType>. No entanto, esse comportamento pode mudar devido a <xref:System.Xaml.XamlType.LookupIsUnknown%2A> substituir.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Um ou mais dentre <paramref name="unknownTypeNamespace" />, <paramref name="unknownTypeName" /> ou <paramref name="schemaContext" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="AllowedContentTypes">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IList&lt;System.Xaml.XamlType&gt; AllowedContentTypes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IList`1&lt;class System.Xaml.XamlType&gt; AllowedContentTypes" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlType.AllowedContentTypes" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property AllowedContentTypes As IList(Of XamlType)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Generic::IList&lt;System::Xaml::XamlType ^&gt; ^ AllowedContentTypes { System::Collections::Generic::IList&lt;System::Xaml::XamlType ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.AllowedContentTypes : System.Collections.Generic.IList&lt;System.Xaml.XamlType&gt;" Usage="System.Xaml.XamlType.AllowedContentTypes" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IList&lt;System.Xaml.XamlType&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém uma coleção somente leitura dos tipos que são utilizáveis como o valor <see cref="P:System.Xaml.XamlType.ContentProperty" /> para esse <see cref="T:System.Xaml.XamlType" />.</summary>
        <value>Uma coleção somente leitura de possíveis tipos de conteúdo.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Tipos que podem ser atribuídos um tipo específico de conteúdo (por exemplo, pode ser atribuído a um tipo base que é um tipo de conteúdo permitido) não são considerados vários tipos para fins de <xref:System.Xaml.XamlType.AllowedContentTypes%2A>.  
  
 Se você não usar a técnica de reflexão padrão interna CLR para um <xref:System.Xaml.XamlType>, chamadas para essa propriedade podem invocar <xref:System.Xaml.XamlType.LookupAllowedContentTypes%2A> prevalece em <xref:System.Xaml.XamlType> classes derivadas.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BaseType">
      <MemberSignature Language="C#" Value="public System.Xaml.XamlType BaseType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Xaml.XamlType BaseType" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlType.BaseType" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property BaseType As XamlType" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Xaml::XamlType ^ BaseType { System::Xaml::XamlType ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.BaseType : System.Xaml.XamlType" Usage="System.Xaml.XamlType.BaseType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.XamlType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém o <see cref="T:System.Xaml.XamlType" /> para o tipo base imediato desse tipo de XAML. A determinação desse valor é baseada no tipo subjacente deste <see cref="T:System.Xaml.XamlType" /> e no contexto do esquema.</summary>
        <value>O <see cref="T:System.Xaml.XamlType" /> para o tipo base imediato desse tipo de XAML.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se você não usar a técnica de reflexão padrão interna CLR para um <xref:System.Xaml.XamlType>, chamadas para essa propriedade podem invocar <xref:System.Xaml.XamlType.LookupBaseType%2A> prevalece em <xref:System.Xaml.XamlType> classes derivadas. Para obter mais informações sobre valores de retorno e outros comportamentos, consulte a documentação para <xref:System.Xaml.XamlType.LookupBaseType%2A> nesse tipo. Por padrão, <xref:System.Xaml.XamlType.BaseType%2A> retorna uma constante interna que representa uma <xref:System.Object> se <xref:System.Xaml.XamlType.UnderlyingType%2A> é `null`.  
  
> [!IMPORTANT]
>  <xref:System.Xaml.XamlType.LookupBaseType%2A> é virtual e, portanto, pode ser substituído. A substituição tem o potencial (seja para fins mal-intencionados ou de outra forma) para alterar as informações de tipo informada sobre um tipo XAML para que ele não precisa mais se alinhe de maneira esperada com as informações do sistema de tipo de seu tipo CLR subjacente. Para nenhuma verificação de segurança crítica das operações de atribuição e de acesso, use o tipo CLR subjacente.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CanAssignTo">
      <MemberSignature Language="C#" Value="public virtual bool CanAssignTo (System.Xaml.XamlType xamlType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool CanAssignTo(class System.Xaml.XamlType xamlType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.CanAssignTo(System.Xaml.XamlType)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool CanAssignTo(System::Xaml::XamlType ^ xamlType);" />
      <MemberSignature Language="F#" Value="abstract member CanAssignTo : System.Xaml.XamlType -&gt; bool&#xA;override this.CanAssignTo : System.Xaml.XamlType -&gt; bool" Usage="xamlType.CanAssignTo xamlType" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="xamlType" Type="System.Xaml.XamlType" />
      </Parameters>
      <Docs>
        <param name="xamlType">O tipo para verificar em relação ao <see cref="T:System.Xaml.XamlType" /> atual.</param>
        <summary>Retorna um valor que indica se uma instância deste <see cref="T:System.Xaml.XamlType" /> tem o <see cref="T:System.Xaml.XamlType" /> especificado em sua lista de tipos atribuíveis.</summary>
        <returns>
          <see langword="true" /> se <paramref name="xamlType" /> está na lista de tipos atribuíveis; caso contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Embora o tipo pode ser atribuído não tem todos os recursos do tipo de referência, você pode usá-lo para a atribuição. Por exemplo, você pode usar a atribuição para fazer as correspondências de tipo para os valores de uma propriedade. O conceito de tipos atribuíveis no XAML é semelhante ao conceito de conversão de backup no sistema de tipos CLR. Por exemplo, em um sistema de tipos CLR, cada tipo tem um <xref:System.Object> na sua lista de tipos atribuíveis.  
  
 Se um dos dois <xref:System.Xaml.XamlType> instâncias que são usadas para comparação tem <xref:System.Xaml.XamlType.IsUnknown%2A> igual a `true`, esse método tem um modo desconhecido especial que retorna `true` se os dois <xref:System.Xaml.XamlType> instâncias forem equivalentes.  
  
 A implementação padrão usa o CLR <xref:System.Type> partir <xref:System.Xaml.XamlType.UnderlyingType%2A> para este <xref:System.Xaml.XamlType> e a entrada <xref:System.Xaml.XamlType>e chamadas <xref:System.Type.IsAssignableFrom%2A>. Substitua este método se você quiser uma determinação diferente de tipos atribuíveis.  
  
 Passando um valor nulo `xamlType` não gerará uma exceção e sempre retorna `false`.  
  
> [!IMPORTANT]
>  <xref:System.Xaml.XamlType.CanAssignTo%2A> é virtual e, portanto, pode ser substituído. A substituição tem o potencial (seja para fins mal-intencionados ou de outra forma) para alterar a atribuição de um tipo XAML para que ele não precisa mais se alinhe de maneira esperada com o comportamento de conversão de tipo de seu tipo CLR subjacente. Para nenhuma verificação de segurança crítica das operações de atribuição e de acesso, use o tipo CLR subjacente.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ConstructionRequiresArguments">
      <MemberSignature Language="C#" Value="public bool ConstructionRequiresArguments { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ConstructionRequiresArguments" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlType.ConstructionRequiresArguments" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ConstructionRequiresArguments As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool ConstructionRequiresArguments { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.ConstructionRequiresArguments : bool" Usage="System.Xaml.XamlType.ConstructionRequiresArguments" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém um valor que indica se este <see cref="T:System.Xaml.XamlType" /> deve ter argumentos (restrições genéricas por meio de <see langword="x:TypeArguments" />, de texto de inicialização ou de outras técnicas de XAML) para construir uma instância válida do tipo.</summary>
        <value>
          <see langword="true" /> Se a construção de uma instância exige algum valor de argumento; Caso contrário, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se você não usar a técnica de reflexão padrão interna CLR para um <xref:System.Xaml.XamlType>, chamadas para essa propriedade podem invocar <xref:System.Xaml.XamlType.LookupConstructionRequiresArguments%2A> prevalece em <xref:System.Xaml.XamlType> classes derivadas. Para obter mais informações sobre valores de retorno e outros comportamentos, consulte a documentação para <xref:System.Xaml.XamlType.LookupConstructionRequiresArguments%2A> nesse tipo.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ContentProperty">
      <MemberSignature Language="C#" Value="public System.Xaml.XamlMember ContentProperty { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Xaml.XamlMember ContentProperty" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlType.ContentProperty" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ContentProperty As XamlMember" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Xaml::XamlMember ^ ContentProperty { System::Xaml::XamlMember ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ContentProperty : System.Xaml.XamlMember" Usage="System.Xaml.XamlType.ContentProperty" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.XamlMember</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém as informações de <see cref="T:System.Xaml.XamlMember" /> para a propriedade de conteúdo deste <see cref="T:System.Xaml.XamlType" />.</summary>
        <value>As informações de <see cref="T:System.Xaml.XamlMember" /> para a propriedade de conteúdo deste <see cref="T:System.Xaml.XamlType" />. Pode ser <see langword="null" /> não se existir nenhuma propriedade de conteúdo.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ao usar a associação ou fazendo do sistema de tipos CLR, a propriedade de conteúdo XAML pode ser especificada em um tipo por meio da aplicação <xref:System.Windows.Markup.ContentPropertyAttribute> à definição de tipo.  
  
 Essa propriedade se alinha com o `[content property]` item de informação na especificação [MS-XAML].  
  
 Se você não usar a técnica de reflexão padrão interna CLR para um <xref:System.Xaml.XamlType>, chamadas para essa propriedade podem invocar <xref:System.Xaml.XamlType.LookupContentProperty%2A> prevalece em <xref:System.Xaml.XamlType> classes derivadas. Para obter mais informações sobre valores de retorno e outros comportamentos, consulte a documentação para <xref:System.Xaml.XamlType.LookupContentProperty%2A> nesse tipo.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ContentWrappers">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IList&lt;System.Xaml.XamlType&gt; ContentWrappers { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IList`1&lt;class System.Xaml.XamlType&gt; ContentWrappers" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlType.ContentWrappers" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ContentWrappers As IList(Of XamlType)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Generic::IList&lt;System::Xaml::XamlType ^&gt; ^ ContentWrappers { System::Collections::Generic::IList&lt;System::Xaml::XamlType ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ContentWrappers : System.Collections.Generic.IList&lt;System.Xaml.XamlType&gt;" Usage="System.Xaml.XamlType.ContentWrappers" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IList&lt;System.Xaml.XamlType&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém os tipos que são usados para encapsular conteúdo para uma propriedade de conteúdo quando não for uma correspondência de tipo estrito, como cadeias de caracteres em uma <see langword="Collection&lt;T&gt;" /> fortemente tipada.</summary>
        <value>Uma coleção somente leitura dos tipos possíveis de wrapper de conteúdo; Caso contrário, <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se não houver nenhum wrappers para levar em conta a correspondência de tipo flexibilizar, essa propriedade é `null`.  
  
 Tipos que são avaliadas como <xref:System.Xaml.XamlType.CanAssignTo%2A> para um tipo específico de conteúdo não são considerados o vários tipos para fins de <xref:System.Xaml.XamlType.ContentWrappers%2A>.  
  
 Na associação para CLR <xref:System.Xaml> e <xref:System.Xaml.XamlType>, o tipo de wrapper de conteúdo XAML pode ser especificado em um tipo como um <xref:System.Windows.Markup.ContentWrapperAttribute>.  
  
 Se você não usar a técnica de reflexão padrão interna CLR para um <xref:System.Xaml.XamlType>, chamadas para essa propriedade podem invocar <xref:System.Xaml.XamlType.LookupContentWrappers%2A> prevalece em <xref:System.Xaml.XamlType> classes derivadas. Para obter mais informações sobre valores de retorno e outros comportamentos, consulte a documentação para <xref:System.Xaml.XamlType.LookupContentWrappers%2A> nesse tipo.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DeferringLoader">
      <MemberSignature Language="C#" Value="public System.Xaml.Schema.XamlValueConverter&lt;System.Xaml.XamlDeferringLoader&gt; DeferringLoader { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Xaml.Schema.XamlValueConverter`1&lt;class System.Xaml.XamlDeferringLoader&gt; DeferringLoader" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlType.DeferringLoader" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DeferringLoader As XamlValueConverter(Of XamlDeferringLoader)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Xaml::Schema::XamlValueConverter&lt;System::Xaml::XamlDeferringLoader ^&gt; ^ DeferringLoader { System::Xaml::Schema::XamlValueConverter&lt;System::Xaml::XamlDeferringLoader ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DeferringLoader : System.Xaml.Schema.XamlValueConverter&lt;System.Xaml.XamlDeferringLoader&gt;" Usage="System.Xaml.XamlType.DeferringLoader" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.Schema.XamlValueConverter&lt;System.Xaml.XamlDeferringLoader&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém o <see cref="T:System.Xaml.Schema.XamlValueConverter`1" /> que representa o comportamento de conversão de carregamento adiado para esse tipo.</summary>
        <value>O <see cref="T:System.Xaml.Schema.XamlValueConverter`1" /> com <see cref="T:System.Xaml.XamlDeferringLoader" /> que representa o comportamento de carregamento adiado para esse tipo de restrição.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Comportamento do modelo XAML no WPF é um exemplo de comportamento de carregamento adiado.  
  
 Se você não usar a técnica de reflexão padrão interna CLR para um <xref:System.Xaml.XamlType>, chamadas para essa propriedade podem invocar <xref:System.Xaml.XamlType.LookupDeferringLoader%2A> prevalece em <xref:System.Xaml.XamlType> classes derivadas. Para obter mais informações sobre valores de retorno e outros comportamentos, consulte a documentação para <xref:System.Xaml.XamlType.LookupDeferringLoader%2A> nesse tipo.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Equals">
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Indica se o objeto atual é igual a outro objeto.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="override this.Equals : obj -&gt; bool" Usage="xamlType.Equals obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">O objeto a ser comparado com este objeto.</param>
        <summary>Indica se o objeto atual é igual a outro objeto.</summary>
        <returns>
          <see langword="true" /> se o objeto atual for igual ao parâmetro <paramref name="obj" />; caso contrário, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public bool Equals (System.Xaml.XamlType other);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Equals(class System.Xaml.XamlType other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.Equals(System.Xaml.XamlType)" />
      <MemberSignature Language="VB.NET" Value="Public Function Equals (other As XamlType) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Equals(System::Xaml::XamlType ^ other);" />
      <MemberSignature Language="F#" Value="override this.Equals : System.Xaml.XamlType -&gt; bool" Usage="xamlType.Equals other" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IEquatable`1.Equals(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Xaml.XamlType" />
      </Parameters>
      <Docs>
        <param name="other">Um objeto para comparação com esse objeto.</param>
        <summary>Indica se o objeto atual é igual a outro objeto do mesmo tipo.</summary>
        <returns>
          <see langword="true" /> se o objeto atual for igual ao parâmetro <paramref name="other" />; caso contrário, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetAliasedProperty">
      <MemberSignature Language="C#" Value="public System.Xaml.XamlMember GetAliasedProperty (System.Xaml.XamlDirective directive);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Xaml.XamlMember GetAliasedProperty(class System.Xaml.XamlDirective directive) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.GetAliasedProperty(System.Xaml.XamlDirective)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAliasedProperty (directive As XamlDirective) As XamlMember" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Xaml::XamlMember ^ GetAliasedProperty(System::Xaml::XamlDirective ^ directive);" />
      <MemberSignature Language="F#" Value="member this.GetAliasedProperty : System.Xaml.XamlDirective -&gt; System.Xaml.XamlMember" Usage="xamlType.GetAliasedProperty directive" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.XamlMember</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="directive" Type="System.Xaml.XamlDirective" />
      </Parameters>
      <Docs>
        <param name="directive">A diretiva para a qual localizar o membro com alias.</param>
        <summary>Retorna o membro XAML que é transformado em alias para uma diretiva XAML por esse <see cref="T:System.Xaml.XamlType" />.</summary>
        <returns>O membro transformado em alias, se encontrado; caso contrário, <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se você não usar a técnica de reflexão padrão interna CLR para um <xref:System.Xaml.XamlType>, chamadas para esse método podem invocar <xref:System.Xaml.XamlType.LookupAliasedProperty%2A> prevalece em <xref:System.Xaml.XamlType> classes derivadas. Para obter mais informações sobre valores de retorno e outros comportamentos, consulte a documentação para <xref:System.Xaml.XamlType.LookupAliasedProperty%2A> nesse tipo.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetAllAttachableMembers">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.ICollection&lt;System.Xaml.XamlMember&gt; GetAllAttachableMembers ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.ICollection`1&lt;class System.Xaml.XamlMember&gt; GetAllAttachableMembers() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.GetAllAttachableMembers" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAllAttachableMembers () As ICollection(Of XamlMember)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::ICollection&lt;System::Xaml::XamlMember ^&gt; ^ GetAllAttachableMembers();" />
      <MemberSignature Language="F#" Value="member this.GetAllAttachableMembers : unit -&gt; System.Collections.Generic.ICollection&lt;System.Xaml.XamlMember&gt;" Usage="xamlType.GetAllAttachableMembers " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.ICollection&lt;System.Xaml.XamlMember&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retorna uma coleção que contém todas as propriedades anexáveis que são expostas por esse <see cref="T:System.Xaml.XamlType" />.</summary>
        <returns>Uma coleção que contém zero ou mais valores <see cref="T:System.Xaml.XamlMember" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cada <xref:System.Xaml.XamlMember> na coleção retornada deve conter valores que suportam o conceito que o <xref:System.Xaml.XamlMember> é um membro anexável. Por exemplo, os membros devem retornar `true` para <xref:System.Xaml.XamlMember.IsAttachable%2A>, um tipo para <xref:System.Xaml.XamlMember.TargetType%2A>e assim por diante.  
  
 Se você não usar a técnica de reflexão padrão interna CLR para um <xref:System.Xaml.XamlType>, chamadas para esse método podem invocar <xref:System.Xaml.XamlType.LookupAllAttachableMembers%2A> prevalece em <xref:System.Xaml.XamlType> classes derivadas. Para obter mais informações sobre valores de retorno e outros comportamentos, consulte a documentação para <xref:System.Xaml.XamlType.LookupAllAttachableMembers%2A> nesse tipo.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetAllMembers">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.ICollection&lt;System.Xaml.XamlMember&gt; GetAllMembers ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.ICollection`1&lt;class System.Xaml.XamlMember&gt; GetAllMembers() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.GetAllMembers" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAllMembers () As ICollection(Of XamlMember)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::ICollection&lt;System::Xaml::XamlMember ^&gt; ^ GetAllMembers();" />
      <MemberSignature Language="F#" Value="member this.GetAllMembers : unit -&gt; System.Collections.Generic.ICollection&lt;System.Xaml.XamlMember&gt;" Usage="xamlType.GetAllMembers " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.ICollection&lt;System.Xaml.XamlMember&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retorna uma coleção que contém todos os membros que são expostos por esse <see cref="T:System.Xaml.XamlType" />.</summary>
        <returns>Uma coleção que contém zero ou mais valores <see cref="T:System.Xaml.XamlMember" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Chamadas para esse método podem invocar <xref:System.Xaml.XamlType.LookupAllMembers%2A> substituições em <xref:System.Xaml.XamlType> classes derivadas.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetAttachableMember">
      <MemberSignature Language="C#" Value="public System.Xaml.XamlMember GetAttachableMember (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Xaml.XamlMember GetAttachableMember(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.GetAttachableMember(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAttachableMember (name As String) As XamlMember" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Xaml::XamlMember ^ GetAttachableMember(System::String ^ name);" />
      <MemberSignature Language="F#" Value="member this.GetAttachableMember : string -&gt; System.Xaml.XamlMember" Usage="xamlType.GetAttachableMember name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.XamlMember</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">O nome do membro anexável a ser obtido, no formato <c>ownerTypeName.MemberName</c>.</param>
        <summary>Retorna um <see cref="T:System.Xaml.XamlMember" /> que representa um membro anexável nomeado específico deste <see cref="T:System.Xaml.XamlType" />.</summary>
        <returns>Um objeto <see cref="T:System.Xaml.XamlMember" /> para o membro anexável solicitado; caso contrário, <see langword="null" />, se não existir nenhum membro anexável com esse nome.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Chamadas para esse método podem invocar <xref:System.Xaml.XamlType.LookupAttachableMember%2A> substituições em <xref:System.Xaml.XamlType> classes derivadas.  
  
> [!IMPORTANT]
>  <xref:System.Xaml.XamlType.LookupAttachableMember%2A> é virtual e, portanto, pode ser substituído. A substituição tem o potencial (seja para fins mal-intencionados ou de outra forma) para alterar os membros relatados de um tipo XAML para que eles não se alinham de maneira esperada com a <xref:System.ComponentModel.TypeDescriptor> `Get*` informações sobre o tipo CLR subjacente. Para nenhuma verificação de segurança crítica de emissão de relatórios do membro, use o tipo CLR subjacente.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="xamlType.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retorna o código hash para esse objeto.</summary>
        <returns>Um código hash inteiro.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetMember">
      <MemberSignature Language="C#" Value="public System.Xaml.XamlMember GetMember (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Xaml.XamlMember GetMember(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.GetMember(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMember (name As String) As XamlMember" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Xaml::XamlMember ^ GetMember(System::String ^ name);" />
      <MemberSignature Language="F#" Value="member this.GetMember : string -&gt; System.Xaml.XamlMember" Usage="xamlType.GetMember name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.XamlMember</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">O nome do membro a ser obtido (como uma cadeia de caracteres).</param>
        <summary>Retorna um <see cref="T:System.Xaml.XamlMember" /> para um membro nomeado específico deste <see cref="T:System.Xaml.XamlType" />.</summary>
        <returns>As informações <see cref="T:System.Xaml.XamlMember" /> para o membro, se esse membro for encontrado; caso contrário, <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O valor de `name` deve ser não qualificado. Nomes de tipo qualificado que indicam que um membro anexado devem ser enviados ao <xref:System.Xaml.XamlType.GetAttachableMember%2A> em vez disso. Membro de nomes não devem ser usados; o prefixo um prefixo é situacional a um uso e o sistema de tipos XAML não pode saber o contexto de tal uso e como o prefixo é mapeado.  
  
 Chamadas para esse método podem invocar <xref:System.Xaml.XamlType.LookupMember%2A> substituições em <xref:System.Xaml.XamlType> classes derivadas.  
  
> [!IMPORTANT]
>  <xref:System.Xaml.XamlType.LookupMember%2A> é virtual e, portanto, pode ser substituído. A substituição tem o potencial (seja para fins mal-intencionados ou de outra forma) para alterar os membros relatados de um tipo XAML para que eles não se alinham de maneira esperada com a <xref:System.ComponentModel.TypeDescriptor> `Get*` informações sobre o tipo CLR subjacente. Para nenhuma verificação de segurança crítica de emissão de relatórios do membro, use o tipo CLR subjacente.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetPositionalParameters">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IList&lt;System.Xaml.XamlType&gt; GetPositionalParameters (int parameterCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.IList`1&lt;class System.Xaml.XamlType&gt; GetPositionalParameters(int32 parameterCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.GetPositionalParameters(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetPositionalParameters (parameterCount As Integer) As IList(Of XamlType)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::IList&lt;System::Xaml::XamlType ^&gt; ^ GetPositionalParameters(int parameterCount);" />
      <MemberSignature Language="F#" Value="member this.GetPositionalParameters : int -&gt; System.Collections.Generic.IList&lt;System.Xaml.XamlType&gt;" Usage="xamlType.GetPositionalParameters parameterCount" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IList&lt;System.Xaml.XamlType&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="parameterCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="parameterCount">A contagem (aridade) do modo de sintaxe ou de construtor específico do qual você deseja obter informações.</param>
        <summary>Para tipos de extensão de marcação, retorna os tipos dos parâmetros posicionais que são compatíveis no uso de extensão de marcação específica para este <see cref="T:System.Xaml.XamlType" />.</summary>
        <returns>Uma lista de valores <see cref="T:System.Xaml.XamlType" />, em que cada <see cref="T:System.Xaml.XamlType" /> é o tipo da posição na sintaxe. Você deve especificar os tipos na mesma ordem em que fornecer a entrada de marcação para a extensão de marcação.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Essa API só é relevante se este <xref:System.Xaml.XamlType> representa uma extensão de marcação (<xref:System.Xaml.XamlType.IsMarkupExtension%2A> é `true`).  
  
 A entrada `parameterCount` não é para solicitar o tipo de um parâmetro posicional específico. Ele é para especificar a aridade do uso de uma extensão de marcação. Uso de extensão de marcação geralmente tem várias "assinaturas" e usa parâmetros diferentes arity (contagem) de parâmetros posicionais para diferenciar. No entanto, você pode configurar um contexto de esquema para permitir arities duplicados e usar tipos dos parâmetros posicionais para diferenciação. Para obter mais informações, consulte <xref:System.Xaml.XamlSchemaContext.SupportMarkupExtensionsWithDuplicateArity%2A>. Para arity específico (contagem), a posição de parâmetro e tipos podem variar. Para obter o tipo posicional de uso de extensão de marcação de um específico igual à aridade, você primeiro chamar <xref:System.Xaml.XamlType.GetPositionalParameters%2A> especificar a contagem de arity. Em seguida, obtenha o item nessa posição na coleção retornada.  
  
 Chamadas para esse método podem invocar <xref:System.Xaml.XamlType.LookupPositionalParameters%2A> substituições em <xref:System.Xaml.XamlType> classes derivadas.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetXamlNamespaces">
      <MemberSignature Language="C#" Value="public virtual System.Collections.Generic.IList&lt;string&gt; GetXamlNamespaces ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Generic.IList`1&lt;string&gt; GetXamlNamespaces() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.GetXamlNamespaces" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetXamlNamespaces () As IList(Of String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Collections::Generic::IList&lt;System::String ^&gt; ^ GetXamlNamespaces();" />
      <MemberSignature Language="F#" Value="abstract member GetXamlNamespaces : unit -&gt; System.Collections.Generic.IList&lt;string&gt;&#xA;override this.GetXamlNamespaces : unit -&gt; System.Collections.Generic.IList&lt;string&gt;" Usage="xamlType.GetXamlNamespaces " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IList&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retorna uma lista de identificadores de cadeia de caracteres para namespaces de XAML nos quais o tipo está incluído.</summary>
        <returns>Uma lista de valores de cadeia de caracteres, em que cada cadeia de caracteres é o identificador de URI para um namespace de XAML.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Identificadores de namespace XAML típicos são cadeias de caracteres em forma de URI.  
  
 A implementação padrão verifica o seguinte, em ordem: o namespace XAML que é fornecido na construção (<xref:System.Xaml.XamlType.%23ctor%28System.String%2CSystem.String%2CSystem.Collections.Generic.IList%7BSystem.Xaml.XamlType%7D%2CSystem.Xaml.XamlSchemaContext%29> assinatura somente); e os namespaces que estão disponíveis no contexto de esquema. Se cada um é `null`, uma nova lista é gerada que contém uma única cadeia de caracteres vazia. Você pode substituir esse método para alterar a metodologia de pesquisa.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Invoker">
      <MemberSignature Language="C#" Value="public System.Xaml.Schema.XamlTypeInvoker Invoker { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Xaml.Schema.XamlTypeInvoker Invoker" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlType.Invoker" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Invoker As XamlTypeInvoker" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Xaml::Schema::XamlTypeInvoker ^ Invoker { System::Xaml::Schema::XamlTypeInvoker ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Invoker : System.Xaml.Schema.XamlTypeInvoker" Usage="System.Xaml.XamlType.Invoker" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.Schema.XamlTypeInvoker</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém a implementação de <see cref="T:System.Xaml.Schema.XamlTypeInvoker" /> que está associada a esse <see cref="T:System.Xaml.XamlType" />.</summary>
        <value>O <see cref="T:System.Xaml.Schema.XamlTypeInvoker" /> implementação que está associada a este <see cref="T:System.Xaml.XamlType" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se você não usar a técnica de reflexão padrão interna CLR para um <xref:System.Xaml.XamlType>, chamar <xref:System.Xaml.XamlType.Invoker%2A> pode invocar qualquer um <xref:System.Xaml.XamlType.LookupInvoker%2A> ou uma substituição específica desse método. Para obter mais informações sobre valores de retorno e outros comportamentos, consulte a documentação para <xref:System.Xaml.XamlType.LookupInvoker%2A> nesse tipo.  
  
 Se um <xref:System.Xaml.XamlType.LookupInvoker%2A> substituir retorna `null`, ou se a implementação padrão retorna `null` devido à falta de <xref:System.Xaml.XamlType.UnderlyingType%2A> para este <xref:System.Xaml.XamlType>, em seguida, <xref:System.Xaml.XamlType.Invoker%2A> retorna <xref:System.Xaml.Schema.XamlTypeInvoker.UnknownInvoker%2A?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsAmbient">
      <MemberSignature Language="C#" Value="public bool IsAmbient { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsAmbient" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlType.IsAmbient" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsAmbient As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsAmbient { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsAmbient : bool" Usage="System.Xaml.XamlType.IsAmbient" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém um valor que indica se este <see cref="T:System.Xaml.XamlType" /> representa um tipo de ambiente, de acordo com a definição de XAML.</summary>
        <value>
          <see langword="true" /> se este <see cref="T:System.Xaml.XamlType" /> representa um tipo de ambiente; caso contrário, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se você não usar a técnica de reflexão padrão interna CLR para um <xref:System.Xaml.XamlType>, chamadas para essa propriedade podem invocar <xref:System.Xaml.XamlType.LookupIsAmbient%2A> prevalece em <xref:System.Xaml.XamlType> classes derivadas. Para obter mais informações sobre valores de retorno e outros comportamentos, consulte a documentação para <xref:System.Xaml.XamlType.LookupIsAmbient%2A> nesse tipo.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsArray">
      <MemberSignature Language="C#" Value="public bool IsArray { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsArray" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlType.IsArray" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsArray As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsArray { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsArray : bool" Usage="System.Xaml.XamlType.IsArray" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém um valor que indica se esse <see cref="T:System.Xaml.XamlType" /> representa uma matriz.</summary>
        <value>
          <see langword="true" /> Se este <see cref="T:System.Xaml.XamlType" /> representa uma matriz; caso contrário, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se você não usar a técnica de reflexão padrão interna CLR para um <xref:System.Xaml.XamlType>, chamadas para essa propriedade podem invocar <xref:System.Xaml.XamlType.LookupCollectionKind%2A> prevalece em <xref:System.Xaml.XamlType> classes derivadas. Para obter mais informações sobre valores de retorno e outros comportamentos, consulte a documentação para <xref:System.Xaml.XamlType.LookupCollectionKind%2A> nesse tipo.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsCollection">
      <MemberSignature Language="C#" Value="public bool IsCollection { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsCollection" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlType.IsCollection" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsCollection As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsCollection { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsCollection : bool" Usage="System.Xaml.XamlType.IsCollection" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém um valor que indica se esse <see cref="T:System.Xaml.XamlType" /> representa uma coleção.</summary>
        <value>
          <see langword="true" /> Se este <see cref="T:System.Xaml.XamlType" /> representa uma coleção; caso contrário, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se você não usar a técnica de reflexão padrão interna CLR para um <xref:System.Xaml.XamlType>, chamadas para essa propriedade podem invocar <xref:System.Xaml.XamlType.LookupCollectionKind%2A> prevalece em <xref:System.Xaml.XamlType> classes derivadas. Para obter mais informações sobre valores de retorno e outros comportamentos, consulte a documentação para <xref:System.Xaml.XamlType.LookupCollectionKind%2A> nesse tipo.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsConstructible">
      <MemberSignature Language="C#" Value="public bool IsConstructible { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsConstructible" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlType.IsConstructible" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsConstructible As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsConstructible { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsConstructible : bool" Usage="System.Xaml.XamlType.IsConstructible" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém um valor que indica se este <see cref="T:System.Xaml.XamlType" /> representa um tipo construível, de acordo com a definição de XAML.</summary>
        <value>
          <see langword="true" /> se este <see cref="T:System.Xaml.XamlType" /> representa um tipo construível; caso contrário, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Essa propriedade se alinha com o `[is default constructible]` item de informação na especificação [MS-XAML].  
  
 Se você não usar a técnica de reflexão padrão interna CLR para um <xref:System.Xaml.XamlType>, chamadas para essa propriedade podem invocar <xref:System.Xaml.XamlType.LookupIsConstructible%2A> prevalece em <xref:System.Xaml.XamlType> classes derivadas. Para obter mais informações sobre valores de retorno e outros comportamentos, consulte a documentação para <xref:System.Xaml.XamlType.LookupIsConstructible%2A> nesse tipo.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Xaml.XamlType.ConstructionRequiresArguments" />
      </Docs>
    </Member>
    <Member MemberName="IsDictionary">
      <MemberSignature Language="C#" Value="public bool IsDictionary { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsDictionary" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlType.IsDictionary" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsDictionary As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsDictionary { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsDictionary : bool" Usage="System.Xaml.XamlType.IsDictionary" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém um valor que indica se este <see cref="T:System.Xaml.XamlType" /> representa um dicionário, de acordo com a definição de XAML.</summary>
        <value>
          <see langword="true" /> Se este <see cref="T:System.Xaml.XamlType" /> representa um dicionário; caso contrário, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Essa propriedade se alinha com o `[is dictionary]` item de informação na especificação [MS-XAML].  
  
 Se você não usar a técnica de reflexão padrão interna CLR para um <xref:System.Xaml.XamlType>, chamadas para essa propriedade podem invocar <xref:System.Xaml.XamlType.LookupCollectionKind%2A> prevalece em <xref:System.Xaml.XamlType> classes derivadas. Para obter mais informações sobre valores de retorno e outros comportamentos, consulte a documentação para <xref:System.Xaml.XamlType.LookupCollectionKind%2A> nesse tipo.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsGeneric">
      <MemberSignature Language="C#" Value="public bool IsGeneric { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsGeneric" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlType.IsGeneric" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsGeneric As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsGeneric { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsGeneric : bool" Usage="System.Xaml.XamlType.IsGeneric" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém um valor que indica se este <see cref="T:System.Xaml.XamlType" /> representa um tipo genérico.</summary>
        <value>
          <see langword="true" /> Se este <see cref="T:System.Xaml.XamlType" /> representa um tipo genérico; caso contrário, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Essa propriedade é uma propriedade de auxiliar que verifica se há um valor nulo de <xref:System.Xaml.XamlType.TypeArguments%2A>. Não há nenhum específicas `Lookup` método relacionados ao <xref:System.Xaml.XamlType.IsGeneric%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsMarkupExtension">
      <MemberSignature Language="C#" Value="public bool IsMarkupExtension { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsMarkupExtension" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlType.IsMarkupExtension" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsMarkupExtension As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsMarkupExtension { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsMarkupExtension : bool" Usage="System.Xaml.XamlType.IsMarkupExtension" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém um valor que indica se este <see cref="T:System.Xaml.XamlType" /> representa uma extensão de marcação.</summary>
        <value>
          <see langword="true" /> se este <see cref="T:System.Xaml.XamlType" /> representa uma extensão de marcação; caso contrário, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Em termos de especificação de XAML, esse tipo deve ser atribuível ao `x:MarkupExtension` para retornar `true` para <xref:System.Xaml.XamlType.IsMarkupExtension%2A>.  
  
 Se você não usar a técnica de reflexão padrão interna CLR para um <xref:System.Xaml.XamlType>, chamadas para essa propriedade podem invocar <xref:System.Xaml.XamlType.LookupIsMarkupExtension%2A> prevalece em <xref:System.Xaml.XamlType> classes derivadas. Para obter mais informações sobre valores de retorno e outros comportamentos, consulte a documentação para <xref:System.Xaml.XamlType.LookupIsMarkupExtension%2A> nesse tipo.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsNameScope">
      <MemberSignature Language="C#" Value="public bool IsNameScope { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsNameScope" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlType.IsNameScope" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsNameScope As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsNameScope { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsNameScope : bool" Usage="System.Xaml.XamlType.IsNameScope" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém um valor que indica se este <see cref="T:System.Xaml.XamlType" /> representa um namescope de XAML, de acordo com a definição de XAML.</summary>
        <value>
          <see langword="true" /> se este <see cref="T:System.Xaml.XamlType" /> representa um namescope de XAML; caso contrário, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Um namescope XAML impõe a exclusividade do nome da propriedade ou propriedades usadas para `x:Name`  /  `[name property]`. Se <xref:System.Xaml.XamlType.IsNameScope%2A> é `true`, algum mecanismo para impor a exclusividade deve existir e deve avaliar a partir da perspectiva desse tipo de proprietário de um namescope XAML. O namescope XAML, em seguida, estende ao conteúdo do tipo até encontrar outro tipo de proprietário de namescope XAML.  
  
 Essa propriedade se alinha com o `[is name scope]` item de informação na especificação [MS-XAML].  
  
 Se você não usar a técnica de reflexão padrão interna CLR para um <xref:System.Xaml.XamlType>, chamadas para essa propriedade podem invocar <xref:System.Xaml.XamlType.LookupIsNameScope%2A> prevalece em <xref:System.Xaml.XamlType> classes derivadas.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsNameValid">
      <MemberSignature Language="C#" Value="public bool IsNameValid { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsNameValid" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlType.IsNameValid" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsNameValid As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsNameValid { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsNameValid : bool" Usage="System.Xaml.XamlType.IsNameValid" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém um valor que indica se este <see cref="T:System.Xaml.XamlType" /> é inicializado usando uma cadeia de caracteres <see langword="xamlName" /> válida como seu <see cref="P:System.Xaml.XamlType.Name" />.</summary>
        <value>
          <see langword="true" /> Se este <see cref="T:System.Xaml.XamlType" /> é inicializada usando válido <see langword="xamlName" /> de cadeia de caracteres; caso contrário, <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsNullable">
      <MemberSignature Language="C#" Value="public bool IsNullable { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsNullable" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlType.IsNullable" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsNullable As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsNullable { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsNullable : bool" Usage="System.Xaml.XamlType.IsNullable" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém um valor que indica se este <see cref="T:System.Xaml.XamlType" /> representa um tipo que permite valor nulo, de acordo com a definição de XAML.</summary>
        <value>
          <see langword="true" /> se este <see cref="T:System.Xaml.XamlType" /> representa um tipo que permite valor nulo; caso contrário, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Essa propriedade se alinha com o `[is nullable]` item de informação na especificação [MS-XAML].  
  
 Se você não estiver usando a técnica de reflexão padrão interna CLR para um <xref:System.Xaml.XamlType>, chamadas para essa propriedade podem invocar <xref:System.Xaml.XamlType.LookupIsNullable%2A> substituições em <xref:System.Xaml.XamlType> classes derivadas.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsPublic">
      <MemberSignature Language="C#" Value="public bool IsPublic { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsPublic" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlType.IsPublic" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsPublic As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsPublic { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsPublic : bool" Usage="System.Xaml.XamlType.IsPublic" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém um valor que indica se este <see cref="T:System.Xaml.XamlType" /> representa um tipo público no sistema de tipos relevante.</summary>
        <value>
          <see langword="true" /> se este <see cref="T:System.Xaml.XamlType" /> representa um tipo público; caso contrário, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se você não usar a técnica de reflexão padrão interna CLR para um <xref:System.Xaml.XamlType>, chamadas para essa propriedade podem invocar <xref:System.Xaml.XamlType.LookupIsPublic%2A> prevalece em <xref:System.Xaml.XamlType> classes derivadas.  
  
> [!IMPORTANT]
>  <xref:System.Xaml.XamlType.LookupIsPublic%2A> é virtual e, portanto, pode ser substituído. A substituição tem o potencial (seja para fins mal-intencionados ou de outra forma) para alterar as informações de acesso reportadas sobre um tipo XAML para que ele não precisa mais se alinhe de maneira esperada com as informações de acesso e o sistema de tipo de seu tipo CLR subjacente. Para nenhuma verificação de segurança crítica das operações de atribuição e de acesso, use o tipo CLR subjacente.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsUnknown">
      <MemberSignature Language="C#" Value="public bool IsUnknown { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsUnknown" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlType.IsUnknown" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsUnknown As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsUnknown { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsUnknown : bool" Usage="System.Xaml.XamlType.IsUnknown" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém um valor que indica se este <see cref="T:System.Xaml.XamlType" /> representa um tipo que não pode ser resolvido no sistema de tipos subjacente.</summary>
        <value>
          <see langword="true" /> Se este <see cref="T:System.Xaml.XamlType" /> representa um tipo pode ser resolvido; caso contrário, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se você não usar a técnica de reflexão padrão interna CLR para um <xref:System.Xaml.XamlType>, chamadas para essa propriedade podem invocar <xref:System.Xaml.XamlType.LookupIsUnknown%2A> prevalece em <xref:System.Xaml.XamlType> classes derivadas.  
  
 Para um caminho de carga que envolve <xref:System.Xaml.XamlObjectWriter>, um <xref:System.Xaml.XamlType> que tem `true` para <xref:System.Xaml.XamlType.IsUnknown%2A> não podem ser gravados em um gráfico de objeto. Sob as implementações padrão no <xref:System.Xaml> , o <xref:System.Xaml.XamlObjectWriter.WriteStartObject%2A?displayProperty=nameWithType> chamar lança uma <xref:System.Xaml.XamlObjectWriterException> quando o relevantes <xref:System.Xaml.XamlType> relatórios `true` para <xref:System.Xaml.XamlType.IsUnknown%2A>. Você não deve passar uma <xref:System.Xaml.XamlType> que tem <xref:System.Xaml.XamlType.IsUnknown%2A> como `true` , a menos que você está preparado para lidar com as exceções das <xref:System.Xaml.XamlObjectWriter>, ou você tem outras maneiras de ajustar o <xref:System.Xaml.XamlObjectWriter> comportamento ou o fluxo do nó XAML antes de gravar o objeto gráfico.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsUsableDuringInitialization">
      <MemberSignature Language="C#" Value="public bool IsUsableDuringInitialization { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsUsableDuringInitialization" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlType.IsUsableDuringInitialization" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsUsableDuringInitialization As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsUsableDuringInitialization { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsUsableDuringInitialization : bool" Usage="System.Xaml.XamlType.IsUsableDuringInitialization" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém um valor que indica se este <see cref="T:System.Xaml.XamlType" /> é compilado de cima para baixo durante a inicialização do XAML.</summary>
        <value>
          <see langword="true" /> se este <see cref="T:System.Xaml.XamlType" /> é compilado de cima para baixo durante a inicialização do XAML; caso contrário, <see langword="false" />. O padrão é <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 De cima para baixo é uma metáfora que aproxima o comportamento do processador XAML ao criar o gráfico do objeto. Quando compilado de cima para baixo, um tipo é instanciado, anexado ao pai, e, em seguida, configurou suas propriedades. Construção de cima para baixo evita invocar manipuladores de propriedades alteradas várias vezes. Tal tratamento ripples o grafo de objeto e, portanto, elimina as várias chamadas do manipulador e fornece uma otimização de desempenho de inicialização do grafo do objeto.  
  
 Se você não usar a técnica de reflexão padrão interna CLR para um <xref:System.Xaml.XamlType>, chamadas para essa propriedade podem invocar <xref:System.Xaml.XamlType.LookupUsableDuringInitialization%2A> prevalece em <xref:System.Xaml.XamlType> classes derivadas. Para obter mais informações sobre valores de retorno e outros comportamentos, consulte a documentação para <xref:System.Xaml.XamlType.LookupUsableDuringInitialization%2A> nesse tipo.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Markup.XamlReader.LoadAsync(System.IO.Stream)" />
        <altmember cref="P:System.Windows.FrameworkElement.IsInitialized" />
      </Docs>
    </Member>
    <Member MemberName="IsWhitespaceSignificantCollection">
      <MemberSignature Language="C#" Value="public bool IsWhitespaceSignificantCollection { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsWhitespaceSignificantCollection" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlType.IsWhitespaceSignificantCollection" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsWhitespaceSignificantCollection As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsWhitespaceSignificantCollection { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsWhitespaceSignificantCollection : bool" Usage="System.Xaml.XamlType.IsWhitespaceSignificantCollection" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém um valor que indica se este <see cref="T:System.Xaml.XamlType" /> representa uma coleção significativa de espaço em branco, de acordo com a definição de XML.</summary>
        <value>
          <see langword="true" /> Se este <see cref="T:System.Xaml.XamlType" /> representa uma coleção significativa de espaço em branco; caso contrário, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se você não usar a técnica de reflexão padrão interna CLR para um <xref:System.Xaml.XamlType>, chamadas para essa propriedade podem invocar <xref:System.Xaml.XamlType.LookupIsWhitespaceSignificantCollection%2A> prevalece em <xref:System.Xaml.XamlType> classes derivadas. Para obter mais informações sobre valores de retorno e outros comportamentos, consulte a documentação para <xref:System.Xaml.XamlType.LookupIsWhitespaceSignificantCollection%2A> nesse tipo.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsXData">
      <MemberSignature Language="C#" Value="public bool IsXData { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsXData" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlType.IsXData" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsXData As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsXData { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsXData : bool" Usage="System.Xaml.XamlType.IsXData" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém um valor que indica se este <see cref="T:System.Xaml.XamlType" /> representa um <see langword="XDATA" /> XML, de acordo com a definição de XAML.</summary>
        <value>
          <see langword="true" /> se este <see cref="T:System.Xaml.XamlType" /> representa <see langword="XDATA" />; caso contrário, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Essa propriedade se alinha com o `[is xdata]` item de informação na especificação [MS-XAML].  
  
 Se você não usar a técnica de reflexão padrão interna CLR para um <xref:System.Xaml.XamlType>, chamadas para essa propriedade podem invocar <xref:System.Xaml.XamlType.LookupIsXData%2A> prevalece em <xref:System.Xaml.XamlType> classes derivadas. Para obter mais informações sobre valores de retorno e outros comportamentos, consulte a documentação para <xref:System.Xaml.XamlType.LookupIsXData%2A> nesse tipo.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ItemType">
      <MemberSignature Language="C#" Value="public System.Xaml.XamlType ItemType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Xaml.XamlType ItemType" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlType.ItemType" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ItemType As XamlType" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Xaml::XamlType ^ ItemType { System::Xaml::XamlType ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ItemType : System.Xaml.XamlType" Usage="System.Xaml.XamlType.ItemType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.XamlType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém um valor que fornece as informações de tipo para a propriedade <see langword="Items" /> deste <see cref="T:System.Xaml.XamlType" />.</summary>
        <value>Um <see cref="T:System.Xaml.XamlType" /> objeto para o tipo dos itens na coleção; caso contrário, <see langword="null" />, se este <see cref="T:System.Xaml.XamlType" /> não representa uma coleção.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Essa propriedade só é relevante se este <xref:System.Xaml.XamlType> representa uma coleção (<xref:System.Xaml.XamlType.IsCollection%2A> é `true`). O `Items` é de propriedade de qualquer propriedade que contém os itens nesse tipo de coleção ou matriz.  
  
 Se você não usar a técnica de reflexão padrão interna CLR para um <xref:System.Xaml.XamlType>, chamadas para essa propriedade podem invocar <xref:System.Xaml.XamlType.LookupItemType%2A> prevalece em <xref:System.Xaml.XamlType> classes derivadas. Para obter mais informações sobre valores de retorno e outros comportamentos, consulte a documentação para <xref:System.Xaml.XamlType.LookupItemType%2A> nesse tipo.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="KeyType">
      <MemberSignature Language="C#" Value="public System.Xaml.XamlType KeyType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Xaml.XamlType KeyType" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlType.KeyType" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property KeyType As XamlType" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Xaml::XamlType ^ KeyType { System::Xaml::XamlType ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.KeyType : System.Xaml.XamlType" Usage="System.Xaml.XamlType.KeyType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.XamlType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém um valor que fornece as informações de tipo para a propriedade de chave deste <see cref="T:System.Xaml.XamlType" />, se o <see cref="T:System.Xaml.XamlType" /> representa um dicionário.</summary>
        <value>Um <see cref="T:System.Xaml.XamlType" /> objeto para o tipo da chave para uso do dicionário, caso contrário, <see langword="null" />, se este <see cref="T:System.Xaml.XamlType" /> não representa um dicionário.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Essa propriedade só é relevante se este <xref:System.Xaml.XamlType> representa um dicionário (<xref:System.Xaml.XamlType.IsDictionary%2A> é `true`).  
  
 Se você não usar a técnica de reflexão padrão interna CLR para um <xref:System.Xaml.XamlType>, chamadas para essa propriedade podem invocar <xref:System.Xaml.XamlType.LookupKeyType%2A> prevalece em <xref:System.Xaml.XamlType> classes derivadas. Para obter mais informações sobre valores de retorno e outros comportamentos, consulte a documentação para <xref:System.Xaml.XamlType.LookupKeyType%2A> nesse tipo.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupAliasedProperty">
      <MemberSignature Language="C#" Value="protected virtual System.Xaml.XamlMember LookupAliasedProperty (System.Xaml.XamlDirective directive);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Xaml.XamlMember LookupAliasedProperty(class System.Xaml.XamlDirective directive) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.LookupAliasedProperty(System.Xaml.XamlDirective)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupAliasedProperty (directive As XamlDirective) As XamlMember" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Xaml::XamlMember ^ LookupAliasedProperty(System::Xaml::XamlDirective ^ directive);" />
      <MemberSignature Language="F#" Value="abstract member LookupAliasedProperty : System.Xaml.XamlDirective -&gt; System.Xaml.XamlMember&#xA;override this.LookupAliasedProperty : System.Xaml.XamlDirective -&gt; System.Xaml.XamlMember" Usage="xamlType.LookupAliasedProperty directive" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.XamlMember</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="directive" Type="System.Xaml.XamlDirective" />
      </Parameters>
      <Docs>
        <param name="directive">A diretiva para a qual localizar o membro com alias.</param>
        <summary>Retorna o membro XAML que é transformado em alias para uma diretiva XAML por esse <see cref="T:System.Xaml.XamlType" />.</summary>
        <returns>O membro transformado em alias, se encontrado; caso contrário, <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método pode ser invocado quando um chamador obtém um valor de <xref:System.Xaml.XamlType.GetAliasedProperty%2A>.  
  
 A implementação padrão pode retornar resultados para as seguintes diretivas XAML: `Key`; `Name`; `Uid`; e `xml:lang`. Os valores para eles dependem de reflexão subjacente e ainda podem retornar `null` se nenhuma propriedade de um alias for encontrada.  
  
 Substitua este método se você não dependem de reflexão de CLR interno padrão e estiver usando metadados ou outras técnicas para as informações do sistema de tipo XAML ou as informações de esquema de um tipo de relatório.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Xaml.XamlDirective" />
        <altmember cref="T:System.Xaml.XamlLanguage" />
      </Docs>
    </Member>
    <Member MemberName="LookupAllAttachableMembers">
      <MemberSignature Language="C#" Value="protected virtual System.Collections.Generic.IEnumerable&lt;System.Xaml.XamlMember&gt; LookupAllAttachableMembers ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;class System.Xaml.XamlMember&gt; LookupAllAttachableMembers() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.LookupAllAttachableMembers" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupAllAttachableMembers () As IEnumerable(Of XamlMember)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Collections::Generic::IEnumerable&lt;System::Xaml::XamlMember ^&gt; ^ LookupAllAttachableMembers();" />
      <MemberSignature Language="F#" Value="abstract member LookupAllAttachableMembers : unit -&gt; seq&lt;System.Xaml.XamlMember&gt;&#xA;override this.LookupAllAttachableMembers : unit -&gt; seq&lt;System.Xaml.XamlMember&gt;" Usage="xamlType.LookupAllAttachableMembers " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Xaml.XamlMember&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retorna um conjunto enumerável que contém todas as propriedades anexáveis que são expostas por esse <see cref="T:System.Xaml.XamlType" />.</summary>
        <returns>Um conjunto enumerável que contém zero ou mais valores <see cref="T:System.Xaml.XamlMember" />; caso contrário, <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método pode ser invocado quando um chamador obtém um valor de <xref:System.Xaml.XamlType.GetAllAttachableMembers%2A>.  
  
 Embora <xref:System.Xaml.XamlType.GetAllAttachableMembers%2A> retorna uma coleção genérica, isso `Lookup` método retorna um conjunto enumerável genérico.  
  
 A implementação padrão usa a reflexão do CLR interna. Quando <xref:System.Xaml.XamlType.UnderlyingType%2A> está `null`, a implementação padrão pode usar <xref:System.Xaml.XamlType.BaseType%2A>, se ele estiver disponível. Esse comportamento chama <xref:System.Xaml.XamlType.LookupAllAttachableMembers%2A> recursivamente para tentar encontrar um tipo base válido e retorna `null` se não existe nenhum tipo base válido.  
  
 Substitua este método se você não dependem de reflexão de CLR interno padrão e estiver usando metadados ou outras técnicas para as informações do sistema de tipo XAML ou informações de esquema de um tipo de relatório. Um retorno nulo deve ser reservado para casos em que as informações não podem ser determinadas devido à falta de suporte ao tipo de sistema ou reflexão. Se um tipo é válido e reflexão ou outras técnicas estão disponíveis, mas um tipo não tem membros anexáveis, você deverá retornar um vazio <xref:System.Collections.Generic.IEnumerable%601> definido.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupAllMembers">
      <MemberSignature Language="C#" Value="protected virtual System.Collections.Generic.IEnumerable&lt;System.Xaml.XamlMember&gt; LookupAllMembers ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;class System.Xaml.XamlMember&gt; LookupAllMembers() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.LookupAllMembers" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupAllMembers () As IEnumerable(Of XamlMember)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Collections::Generic::IEnumerable&lt;System::Xaml::XamlMember ^&gt; ^ LookupAllMembers();" />
      <MemberSignature Language="F#" Value="abstract member LookupAllMembers : unit -&gt; seq&lt;System.Xaml.XamlMember&gt;&#xA;override this.LookupAllMembers : unit -&gt; seq&lt;System.Xaml.XamlMember&gt;" Usage="xamlType.LookupAllMembers " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Xaml.XamlMember&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retorna um conjunto enumerável que contém todos os membros que são expostos por esse <see cref="T:System.Xaml.XamlType" />.</summary>
        <returns>Um conjunto enumerável que contém zero ou mais valores <see cref="T:System.Xaml.XamlMember" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método pode ser invocado quando um chamador obtém um valor de <xref:System.Xaml.XamlType.GetAllMembers%2A>.  
  
 Embora <xref:System.Xaml.XamlType.GetAllMembers%2A> retorna uma coleção genérica, isso `Lookup` método retorna um conjunto enumerável genérico.  
  
 A implementação padrão usa a reflexão do CLR interna. Para casos em que <xref:System.Xaml.XamlType.UnderlyingType%2A> está `null`, a implementação padrão pode usar <xref:System.Xaml.XamlType.BaseType%2A>, se ele estiver disponível. Esse comportamento chama <xref:System.Xaml.XamlType.LookupAllMembers%2A> recursivamente para tentar encontrar um tipo base válido e retorna `null` se não existe nenhum tipo base válido.  
  
 Substitua este método se você não dependem de reflexão de CLR interno padrão e estiver usando metadados ou outras técnicas para as informações do sistema de tipo XAML ou informações de esquema de um tipo de relatório. Um retorno nulo deve ser reservado para casos em que as informações não podem ser determinadas devido à falta de suporte ao tipo de sistema ou reflexão. Se um tipo for válido, a reflexão ou outras técnicas estão disponíveis; Se um tipo não tem membros, você deverá retornar um vazio <xref:System.Collections.Generic.IEnumerable%601> definido.  
  
 Retornar valores para <xref:System.Xaml.XamlType.LookupAllMembers%2A> e <xref:System.Xaml.XamlType.LookupAllAttachableMembers%2A> devem ser mutuamente exclusivos. Se você tiver uma situação em que uma propriedade de sistema de tipo de suporte pode dar suporte a um uso de instância padrão, bem como um uso anexável, esse membro deve ser relatado como dois diferentes <xref:System.Xaml.XamlMember> valores, com um valor que aparece na lista anexável e outro no lista de membros padrão.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupAllowedContentTypes">
      <MemberSignature Language="C#" Value="protected virtual System.Collections.Generic.IList&lt;System.Xaml.XamlType&gt; LookupAllowedContentTypes ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Collections.Generic.IList`1&lt;class System.Xaml.XamlType&gt; LookupAllowedContentTypes() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.LookupAllowedContentTypes" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupAllowedContentTypes () As IList(Of XamlType)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Collections::Generic::IList&lt;System::Xaml::XamlType ^&gt; ^ LookupAllowedContentTypes();" />
      <MemberSignature Language="F#" Value="abstract member LookupAllowedContentTypes : unit -&gt; System.Collections.Generic.IList&lt;System.Xaml.XamlType&gt;&#xA;override this.LookupAllowedContentTypes : unit -&gt; System.Collections.Generic.IList&lt;System.Xaml.XamlType&gt;" Usage="xamlType.LookupAllowedContentTypes " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IList&lt;System.Xaml.XamlType&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retorna uma lista dos tipos que podem ser usados como o valor <see cref="P:System.Xaml.XamlType.ContentProperty" /> para este <see cref="T:System.Xaml.XamlType" />.</summary>
        <returns>Uma lista de possíveis tipos de conteúdo.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método pode ser invocado quando um chamador obtém um valor de <xref:System.Xaml.XamlType.AllowedContentTypes%2A>.  
  
 Tipos que são avaliadas como <xref:System.Xaml.XamlType.CanAssignTo%2A> para um tipo específico de conteúdo não são considerados o vários tipos para fins de <xref:System.Xaml.XamlType.AllowedContentTypes%2A>.  
  
 A implementação padrão pode usar outras propriedades de <xref:System.Xaml.XamlType> (<xref:System.Xaml.XamlType.ContentWrappers%2A>, <xref:System.Xaml.XamlType.ContentProperty%2A>, ou <xref:System.Xaml.XamlType.ItemType%2A>) para obter um resultado. O `Lookup` substituições para a lista de propriedade anterior também pode ser invocada nessa determinação.  
  
 Substitua este método se você não dependem de reflexão de CLR interno padrão e estiver usando metadados ou outras técnicas para as informações do sistema de tipo XAML ou informações de esquema de um tipo de relatório.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupAttachableMember">
      <MemberSignature Language="C#" Value="protected virtual System.Xaml.XamlMember LookupAttachableMember (string name);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Xaml.XamlMember LookupAttachableMember(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.LookupAttachableMember(System.String)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupAttachableMember (name As String) As XamlMember" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Xaml::XamlMember ^ LookupAttachableMember(System::String ^ name);" />
      <MemberSignature Language="F#" Value="abstract member LookupAttachableMember : string -&gt; System.Xaml.XamlMember&#xA;override this.LookupAttachableMember : string -&gt; System.Xaml.XamlMember" Usage="xamlType.LookupAttachableMember name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.XamlMember</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">O nome do membro anexável a ser obtido, no formato <c>ownerTypeName.MemberName</c>.</param>
        <summary>Retorna um <see cref="T:System.Xaml.XamlMember" /> para um anexável nomeado específico deste <see cref="T:System.Xaml.XamlType" />.</summary>
        <returns>Um objeto <see cref="T:System.Xaml.XamlMember" /> para o membro anexável solicitado; caso contrário, <see langword="null" />, se não existir nenhum membro anexável com esse nome.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método pode ser invocado quando um chamador obtém um valor de <xref:System.Xaml.XamlType.GetAttachableMember%2A>.  
  
 A implementação padrão usa a reflexão do CLR interna. Quando <xref:System.Xaml.XamlType.UnderlyingType%2A> está `null`, a implementação padrão pode usar <xref:System.Xaml.XamlType.BaseType%2A>, se ele estiver disponível. Esse comportamento chama <xref:System.Xaml.XamlType.LookupAttachableMember%2A> recursivamente para tentar encontrar um tipo base válido e retorna `null` se não existe nenhum tipo base válido.  
  
 Substitua este método se você não dependem de reflexão de CLR interno padrão e estiver usando metadados ou outras técnicas para as informações do sistema de tipo XAML ou informações de esquema de um tipo de relatório.  
  
> [!IMPORTANT]
>  <xref:System.Xaml.XamlType.LookupAttachableMember%2A> é virtual e, portanto, pode ser substituído. A substituição tem o potencial (seja para fins mal-intencionados ou de outra forma) para alterar os membros relatados de um tipo XAML para que eles não se alinham de maneira esperada com a <xref:System.ComponentModel.TypeDescriptor> `Get*` informações sobre o tipo CLR subjacente. Para nenhuma verificação de segurança crítica de emissão de relatórios do membro, use o tipo CLR subjacente.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupBaseType">
      <MemberSignature Language="C#" Value="protected virtual System.Xaml.XamlType LookupBaseType ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Xaml.XamlType LookupBaseType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.LookupBaseType" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupBaseType () As XamlType" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Xaml::XamlType ^ LookupBaseType();" />
      <MemberSignature Language="F#" Value="abstract member LookupBaseType : unit -&gt; System.Xaml.XamlType&#xA;override this.LookupBaseType : unit -&gt; System.Xaml.XamlType" Usage="xamlType.LookupBaseType " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.XamlType</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retorna o <see cref="T:System.Xaml.XamlType" /> para o tipo base imediato desse tipo de XAML. A determinação desse valor é baseada no tipo subjacente deste <see cref="T:System.Xaml.XamlType" /> e no contexto do esquema.</summary>
        <returns>O <see cref="T:System.Xaml.XamlType" /> para o tipo base imediato desse tipo de XAML.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método pode ser invocado quando um chamador obtém um valor de <xref:System.Xaml.XamlType.BaseType%2A>.  
  
 A implementação padrão pode retornar uma constante interna que representa o <xref:System.Object> se <xref:System.Xaml.XamlType.UnderlyingType%2A> é `null`.  
  
 Substitua este método se você não dependem de reflexão de CLR interno padrão e estiver usando metadados ou outras técnicas para as informações do sistema de tipo XAML ou informações de esquema de um tipo de relatório.  
  
> [!IMPORTANT]
>  <xref:System.Xaml.XamlType.LookupBaseType%2A> é virtual e, portanto, pode ser substituído. A substituição tem o potencial (seja para fins mal-intencionados ou de outra forma) para alterar as informações de tipo informada sobre um tipo XAML para que ele não precisa mais se alinhe de maneira esperada com as informações do sistema de tipo de seu tipo CLR subjacente. Para nenhuma verificação de segurança crítica das operações de atribuição e de acesso, use o tipo CLR subjacente.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupCollectionKind">
      <MemberSignature Language="C#" Value="protected virtual System.Xaml.Schema.XamlCollectionKind LookupCollectionKind ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance valuetype System.Xaml.Schema.XamlCollectionKind LookupCollectionKind() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.LookupCollectionKind" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupCollectionKind () As XamlCollectionKind" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Xaml::Schema::XamlCollectionKind LookupCollectionKind();" />
      <MemberSignature Language="F#" Value="abstract member LookupCollectionKind : unit -&gt; System.Xaml.Schema.XamlCollectionKind&#xA;override this.LookupCollectionKind : unit -&gt; System.Xaml.Schema.XamlCollectionKind" Usage="xamlType.LookupCollectionKind " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.Schema.XamlCollectionKind</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retorna um valor da enumeração <see cref="T:System.Xaml.Schema.XamlCollectionKind" /> que declara qual tipo de coleção específica esse <see cref="T:System.Xaml.XamlType" /> usa.</summary>
        <returns>Um valor da enumeração <see cref="T:System.Xaml.Schema.XamlCollectionKind" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método é invocado por um método privado interno (não público `CollectionKind` ou `GetCollectionKind` API existe em <xref:System.Xaml.XamlType>).  
  
 A implementação padrão usa a reflexão do CLR interna. Para casos em que <xref:System.Xaml.XamlType.UnderlyingType%2A> está `null`, a implementação padrão pode usar <xref:System.Xaml.XamlType.BaseType%2A>, se ele estiver disponível. Esse comportamento chama indiretamente <xref:System.Xaml.XamlType.LookupCollectionKind%2A> recursivamente para tentar encontrar um tipo base válido; ele retorna <xref:System.Xaml.Schema.XamlCollectionKind.None?displayProperty=nameWithType> se não existe nenhum tipo base válido. Em geral, a implementação padrão tenta localizar o `Add` método do tipo subjacente por reflexão. Se encontrado, o <xref:System.Reflection.MethodInfo> do `Add` método é informações suficientes para determinar quais <xref:System.Xaml.Schema.XamlCollectionKind> valor deve ser retornado. Caso contrário, retornará <xref:System.Xaml.Schema.XamlCollectionKind.None?displayProperty=nameWithType>.  
  
 Substitua este método se você não dependem de reflexão de CLR interno padrão e estiver usando metadados ou outras técnicas para as informações do sistema de tipo XAML ou informações de esquema de um tipo de relatório.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupConstructionRequiresArguments">
      <MemberSignature Language="C#" Value="protected virtual bool LookupConstructionRequiresArguments ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool LookupConstructionRequiresArguments() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.LookupConstructionRequiresArguments" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupConstructionRequiresArguments () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool LookupConstructionRequiresArguments();" />
      <MemberSignature Language="F#" Value="abstract member LookupConstructionRequiresArguments : unit -&gt; bool&#xA;override this.LookupConstructionRequiresArguments : unit -&gt; bool" Usage="xamlType.LookupConstructionRequiresArguments " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retorna um valor que indica se este <see cref="T:System.Xaml.XamlType" /> deve ter argumentos (restrições genéricas por meio de <see langword="x:TypeArguments" />, de texto de inicialização ou de outras técnicas de XAML) para construir uma instância válida do tipo.</summary>
        <returns>
          <see langword="true" /> se a construção de uma instância exige algum valor de argumento; caso contrário, False.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método pode ser invocado quando um chamador obtém um valor de <xref:System.Xaml.XamlType.ConstructionRequiresArguments%2A>.  
  
 A implementação padrão retorna `false` sistema de tipos para tipos considerados tipos de valor no CLR. Para outros que tipos de valor, reflexo de CLR <xref:System.Reflection.ConstructorInfo> é usado para determinar se um construtor padrão existe.  
  
 Substitua este método se você não dependem de reflexão de CLR interno padrão e estiver usando metadados ou outras técnicas para as informações do sistema de tipo XAML ou informações de esquema de um tipo de relatório.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupContentProperty">
      <MemberSignature Language="C#" Value="protected virtual System.Xaml.XamlMember LookupContentProperty ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Xaml.XamlMember LookupContentProperty() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.LookupContentProperty" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupContentProperty () As XamlMember" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Xaml::XamlMember ^ LookupContentProperty();" />
      <MemberSignature Language="F#" Value="abstract member LookupContentProperty : unit -&gt; System.Xaml.XamlMember&#xA;override this.LookupContentProperty : unit -&gt; System.Xaml.XamlMember" Usage="xamlType.LookupContentProperty " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.XamlMember</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retorna as informações de <see cref="T:System.Xaml.XamlMember" /> para a propriedade de conteúdo deste <see cref="T:System.Xaml.XamlType" />.</summary>
        <returns>As informações de <see cref="T:System.Xaml.XamlMember" /> para a propriedade de conteúdo deste <see cref="T:System.Xaml.XamlType" />. Pode ser <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método pode ser invocado quando um chamador obtém um valor de <xref:System.Xaml.XamlType.ContentProperty%2A>.  
  
 A implementação padrão verifica se há <xref:System.Windows.Markup.ContentPropertyAttribute> na definição de tipo. Ele também pode verificar <xref:System.Xaml.XamlType.BaseType%2A> para o atributo se nenhum atributo for encontrado no tipo subjacente de imediato. Se essas verificações não são descobertos por um tipo de conteúdo, a implementação padrão retorna `null`.  
  
 Substitua este método se você não dependem de reflexão de CLR interno padrão e estiver usando metadados ou outras técnicas para as informações do sistema de tipo XAML ou informações de esquema de um tipo de relatório.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupContentWrappers">
      <MemberSignature Language="C#" Value="protected virtual System.Collections.Generic.IList&lt;System.Xaml.XamlType&gt; LookupContentWrappers ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Collections.Generic.IList`1&lt;class System.Xaml.XamlType&gt; LookupContentWrappers() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.LookupContentWrappers" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupContentWrappers () As IList(Of XamlType)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Collections::Generic::IList&lt;System::Xaml::XamlType ^&gt; ^ LookupContentWrappers();" />
      <MemberSignature Language="F#" Value="abstract member LookupContentWrappers : unit -&gt; System.Collections.Generic.IList&lt;System.Xaml.XamlType&gt;&#xA;override this.LookupContentWrappers : unit -&gt; System.Collections.Generic.IList&lt;System.Xaml.XamlType&gt;" Usage="xamlType.LookupContentWrappers " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IList&lt;System.Xaml.XamlType&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Obtém uma lista de valores <see cref="T:System.Xaml.XamlType" /> que representam os wrappers de conteúdo para este <see cref="T:System.Xaml.XamlType" />.</summary>
        <returns>Uma lista de valores <see cref="T:System.Xaml.XamlType" /> que representam os wrappers de conteúdo para este <see cref="T:System.Xaml.XamlType" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Um wrapper de conteúdo é uma classe que representa o tipo de coleção de conteúdo quando os tipos que são usados na coleção não são contíguos no sistema de tipo. Os tipos de itens de coleta para o wrapper de conteúdo devem ser limitados de alguma maneira além do <xref:System.Object> ou um objeto neutro equivalente. No entanto, essa limitação é imposta apenas pelo design ou a finalidade das propriedades que usam esse tipo e não pelo sistema de tipo. Mais de um wrapper de conteúdo pode existir em um tipo.  
  
 Para um exemplo de classe e o cenário da implementação do WPF XAML, consulte <xref:System.Windows.Documents.InlineCollection>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupCustomAttributeProvider">
      <MemberSignature Language="C#" Value="protected virtual System.Reflection.ICustomAttributeProvider LookupCustomAttributeProvider ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Reflection.ICustomAttributeProvider LookupCustomAttributeProvider() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.LookupCustomAttributeProvider" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupCustomAttributeProvider () As ICustomAttributeProvider" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Reflection::ICustomAttributeProvider ^ LookupCustomAttributeProvider();" />
      <MemberSignature Language="F#" Value="abstract member LookupCustomAttributeProvider : unit -&gt; System.Reflection.ICustomAttributeProvider&#xA;override this.LookupCustomAttributeProvider : unit -&gt; System.Reflection.ICustomAttributeProvider" Usage="xamlType.LookupCustomAttributeProvider " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.ICustomAttributeProvider</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Quando implementado em uma classe derivada, retorna uma implementação <see cref="T:System.Reflection.ICustomAttributeProvider" />.</summary>
        <returns>Uma implementação <see cref="T:System.Reflection.ICustomAttributeProvider" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Substitua este método para fornecer a reflexão interna com uma maneira alternativa para obter valores de atributo CLR. Na ausência de uma substituição, o reflector interno usa a lógica de reflexão de CLR típica.  
  
 A implementação padrão retorna `null`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupDeferringLoader">
      <MemberSignature Language="C#" Value="protected virtual System.Xaml.Schema.XamlValueConverter&lt;System.Xaml.XamlDeferringLoader&gt; LookupDeferringLoader ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Xaml.Schema.XamlValueConverter`1&lt;class System.Xaml.XamlDeferringLoader&gt; LookupDeferringLoader() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.LookupDeferringLoader" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupDeferringLoader () As XamlValueConverter(Of XamlDeferringLoader)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Xaml::Schema::XamlValueConverter&lt;System::Xaml::XamlDeferringLoader ^&gt; ^ LookupDeferringLoader();" />
      <MemberSignature Language="F#" Value="abstract member LookupDeferringLoader : unit -&gt; System.Xaml.Schema.XamlValueConverter&lt;System.Xaml.XamlDeferringLoader&gt;&#xA;override this.LookupDeferringLoader : unit -&gt; System.Xaml.Schema.XamlValueConverter&lt;System.Xaml.XamlDeferringLoader&gt;" Usage="xamlType.LookupDeferringLoader " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.Schema.XamlValueConverter&lt;System.Xaml.XamlDeferringLoader&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retorna um objeto <see cref="T:System.Xaml.Schema.XamlValueConverter`1" />, que é usado para o carregamento adiado de objetos declarados em XAML.</summary>
        <returns>Um <see cref="T:System.Xaml.Schema.XamlValueConverter`1" /> que tem uma restrição <see cref="T:System.Xaml.XamlDeferringLoader" /> sobre o genérico.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método pode ser invocado quando um chamador obtém um valor de <xref:System.Xaml.XamlType.DeferringLoader%2A>. Substitua este método se você quiser <xref:System.Xaml.XamlType.DeferringLoader%2A> para retornar um valor diferente do que é habilitado por reflexão interno do padrão e também estão fornecendo personalizado <xref:System.Xaml.Schema.XamlTypeInvoker> informações.  
  
 A implementação padrão retorna um objeto com base na leitura <xref:System.Windows.Markup.XamlDeferLoadAttribute>. Ele também pode verificar <xref:System.Xaml.XamlType.BaseType%2A> para o atributo se nenhum atributo for encontrado no tipo subjacente de imediato. Se um valor não estiver disponível, esse método retorna `null`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupInvoker">
      <MemberSignature Language="C#" Value="protected virtual System.Xaml.Schema.XamlTypeInvoker LookupInvoker ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Xaml.Schema.XamlTypeInvoker LookupInvoker() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.LookupInvoker" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupInvoker () As XamlTypeInvoker" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Xaml::Schema::XamlTypeInvoker ^ LookupInvoker();" />
      <MemberSignature Language="F#" Value="abstract member LookupInvoker : unit -&gt; System.Xaml.Schema.XamlTypeInvoker&#xA;override this.LookupInvoker : unit -&gt; System.Xaml.Schema.XamlTypeInvoker" Usage="xamlType.LookupInvoker " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.Schema.XamlTypeInvoker</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retorna um <see cref="T:System.Xaml.Schema.XamlTypeInvoker" /> que é associado a esse <see cref="T:System.Xaml.XamlType" />.</summary>
        <returns>As informações <see cref="T:System.Xaml.Schema.XamlTypeInvoker" /> para este <see cref="T:System.Xaml.XamlType" />; caso contrário, <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método pode ser invocado por chamadas para <xref:System.Xaml.XamlType.Invoker%2A>.  
  
 A implementação padrão não requer que um <xref:System.Xaml.XamlType> ser construído usando um dos construtores que passar um inicial <xref:System.Xaml.Schema.XamlTypeInvoker>. No entanto, uma <xref:System.Xaml.XamlType.UnderlyingType%2A> valor deve existir para o <xref:System.Xaml.XamlType>; caso contrário, a implementação padrão retorna `null`.  
  
 Substitua este método se você criar também uma classe derivada de <xref:System.Xaml.Schema.XamlTypeInvoker> e pretender retornar a classe derivada. Se você retornar `null`, <xref:System.Xaml.XamlType.Invoker%2A> retorna <xref:System.Xaml.Schema.XamlTypeInvoker.UnknownInvoker%2A?displayProperty=nameWithType> aos chamadores.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupIsAmbient">
      <MemberSignature Language="C#" Value="protected virtual bool LookupIsAmbient ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool LookupIsAmbient() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.LookupIsAmbient" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupIsAmbient () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool LookupIsAmbient();" />
      <MemberSignature Language="F#" Value="abstract member LookupIsAmbient : unit -&gt; bool&#xA;override this.LookupIsAmbient : unit -&gt; bool" Usage="xamlType.LookupIsAmbient " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retorna um valor que indica se este <see cref="T:System.Xaml.XamlType" /> representa um tipo de ambiente, de acordo com a definição de XAML.</summary>
        <returns>
          <see langword="true" /> se este <see cref="T:System.Xaml.XamlType" /> representa um tipo de ambiente; caso contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método pode ser invocado por chamadas para <xref:System.Xaml.XamlType.IsAmbient%2A>.  
  
 A implementação padrão usa a reflexão do CLR no <xref:System.Xaml.XamlType.UnderlyingType%2A> e pode verificar os tipos base. Essa implementação verifica os <xref:System.Windows.Markup.AmbientAttribute> que é aplicado à definição do tipo relevante no nível de classe e retorna `true` nesse caso. Retornam todos os outros casos `false`.  
  
 Substitua este método se você quiser <xref:System.Xaml.XamlType.IsAmbient%2A> para retornar um valor diferente do que é habilitado por reflexão de interno padrão.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupIsConstructible">
      <MemberSignature Language="C#" Value="protected virtual bool LookupIsConstructible ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool LookupIsConstructible() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.LookupIsConstructible" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupIsConstructible () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool LookupIsConstructible();" />
      <MemberSignature Language="F#" Value="abstract member LookupIsConstructible : unit -&gt; bool&#xA;override this.LookupIsConstructible : unit -&gt; bool" Usage="xamlType.LookupIsConstructible " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retorna um valor que indica se este <see cref="T:System.Xaml.XamlType" /> representa um tipo construível, de acordo com a definição de XAML.</summary>
        <returns>
          <see langword="true" /> se este <see cref="T:System.Xaml.XamlType" /> representa um tipo construível; caso contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método pode ser invocado por chamadas para <xref:System.Xaml.XamlType.IsConstructible%2A>.  
  
 A implementação padrão usa a reflexão do CLR no <xref:System.Xaml.XamlType.UnderlyingType%2A>. O tipo deve ser concreto, não aninhadas e fechado. A implementação padrão verifica se o tipo é um tipo de valor e o retorno de <xref:System.Xaml.XamlType.ConstructionRequiresArguments%2A>. Para um valor nulo <xref:System.Xaml.XamlType.UnderlyingType%2A>, esse método retornará `true`.  
  
 Substitua este método se você quiser <xref:System.Xaml.XamlType.IsConstructible%2A> para retornar um valor diferente do que é habilitado por reflexão de interno padrão.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupIsMarkupExtension">
      <MemberSignature Language="C#" Value="protected virtual bool LookupIsMarkupExtension ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool LookupIsMarkupExtension() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.LookupIsMarkupExtension" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupIsMarkupExtension () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool LookupIsMarkupExtension();" />
      <MemberSignature Language="F#" Value="abstract member LookupIsMarkupExtension : unit -&gt; bool&#xA;override this.LookupIsMarkupExtension : unit -&gt; bool" Usage="xamlType.LookupIsMarkupExtension " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retorna um valor que indica se este <see cref="T:System.Xaml.XamlType" /> representa uma extensão de marcação.</summary>
        <returns>
          <see langword="true" /> se este <see cref="T:System.Xaml.XamlType" /> representa uma extensão de marcação; caso contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método pode ser invocado por chamadas para <xref:System.Xaml.XamlType.IsMarkupExtension%2A>.  
  
 A implementação padrão consiste apenas essa chamada:  
  
 `return CanAssignTo(XamlLanguage.MarkupExtension);`  
  
 Substitua este método se você quiser <xref:System.Xaml.XamlType.IsMarkupExtension%2A> para usar uma lógica diferente.  
  
 Em termos de especificação de XAML, esse tipo deve ser atribuível ao `x:MarkupExtension` para retornar `true` para <xref:System.Xaml.XamlType.IsMarkupExtension%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupIsNameScope">
      <MemberSignature Language="C#" Value="protected virtual bool LookupIsNameScope ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool LookupIsNameScope() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.LookupIsNameScope" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupIsNameScope () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool LookupIsNameScope();" />
      <MemberSignature Language="F#" Value="abstract member LookupIsNameScope : unit -&gt; bool&#xA;override this.LookupIsNameScope : unit -&gt; bool" Usage="xamlType.LookupIsNameScope " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retorna um valor que indica se este <see cref="T:System.Xaml.XamlType" /> representa um namescope de XAML, de acordo com a definição de XAML.</summary>
        <returns>
          <see langword="true" /> se este <see cref="T:System.Xaml.XamlType" /> representa um namescope de XAML; caso contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método pode ser invocado por chamadas para <xref:System.Xaml.XamlType.IsNameScope%2A>.  
  
 A implementação padrão faz uma <xref:System.Xaml.XamlType.CanAssignTo%2A> chame indiretamente o tipo <xref:System.Windows.Markup.INameScope>. <xref:System.Windows.Markup.INameScope> é uma interface que é definida no assembly WindowsBase. dll. Essa técnica para identificação de namescope XAML é usada tanto pelo WPF e Windows Workflow Foundation implementações de XAML.  
  
 Substitua este método se você quiser <xref:System.Xaml.XamlType.IsNameScope%2A> para usar uma lógica diferente.  
  
 Um namescope XAML impõe a exclusividade do nome da propriedade ou propriedades que são usadas para `x:Name`  /  `[name property]`. Se <xref:System.Xaml.XamlType.IsNameScope%2A> é `true`, em seguida, algum mecanismo para impor a exclusividade deve existir e deve avaliar a partir da perspectiva desse tipo de proprietário de um namescope XAML. O namescope XAML, em seguida, estende ao conteúdo do tipo até encontrar outro tipo de proprietário de namescope XAML.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Xaml.XamlObjectWriter.RootNameScope" />
      </Docs>
    </Member>
    <Member MemberName="LookupIsNullable">
      <MemberSignature Language="C#" Value="protected virtual bool LookupIsNullable ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool LookupIsNullable() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.LookupIsNullable" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupIsNullable () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool LookupIsNullable();" />
      <MemberSignature Language="F#" Value="abstract member LookupIsNullable : unit -&gt; bool&#xA;override this.LookupIsNullable : unit -&gt; bool" Usage="xamlType.LookupIsNullable " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retorna um valor que indica se este <see cref="T:System.Xaml.XamlType" /> representa um tipo que permite valor nulo, de acordo com a definição de XAML.</summary>
        <returns>
          <see langword="true" /> se este <see cref="T:System.Xaml.XamlType" /> representa um tipo que permite valor nulo; caso contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método pode ser invocado por chamadas para <xref:System.Xaml.XamlType.IsNullable%2A>.  
  
 A implementação padrão faz uma determinação com base no CLR principal que permite valor nulo conceito de biblioteca, verificado em relação <xref:System.Xaml.XamlType.UnderlyingType%2A>. Para um valor nulo <xref:System.Xaml.XamlType.UnderlyingType%2A>, ele retorna `true`.  
  
 Substitua este método se você quiser <xref:System.Xaml.XamlType.IsNullable%2A> para usar uma lógica diferente.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupIsPublic">
      <MemberSignature Language="C#" Value="protected virtual bool LookupIsPublic ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool LookupIsPublic() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.LookupIsPublic" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupIsPublic () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool LookupIsPublic();" />
      <MemberSignature Language="F#" Value="abstract member LookupIsPublic : unit -&gt; bool&#xA;override this.LookupIsPublic : unit -&gt; bool" Usage="xamlType.LookupIsPublic " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retorna um valor que indica se este <see cref="T:System.Xaml.XamlType" /> representa um tipo público no sistema de tipos relevante.</summary>
        <returns>
          <see langword="true" /> se este <see cref="T:System.Xaml.XamlType" /> representa um tipo público; caso contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método pode ser invocado por chamadas para <xref:System.Xaml.XamlType.IsPublic%2A>.  
  
 A implementação padrão usa a reflexão do CLR em relação a não-nulo <xref:System.Xaml.XamlType.UnderlyingType%2A>. Para um valor nulo <xref:System.Xaml.XamlType.UnderlyingType%2A>, ele retorna `true`.  
  
 Substitua este método se você quiser <xref:System.Xaml.XamlType.IsPublic%2A> para usar uma lógica diferente.  
  
> [!IMPORTANT]
>  <xref:System.Xaml.XamlType.LookupIsPublic%2A> é virtual e, portanto, pode ser substituído. A substituição tem o potencial (seja para fins mal-intencionados ou de outra forma) para alterar as informações de acesso reportadas sobre um tipo XAML para que ele não precisa mais se alinhe de maneira esperada com as informações de acesso ou o sistema de tipo de seu tipo CLR subjacente. Para nenhuma verificação de segurança crítica das operações de atribuição e de acesso, use o tipo CLR subjacente.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupIsUnknown">
      <MemberSignature Language="C#" Value="protected virtual bool LookupIsUnknown ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool LookupIsUnknown() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.LookupIsUnknown" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupIsUnknown () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool LookupIsUnknown();" />
      <MemberSignature Language="F#" Value="abstract member LookupIsUnknown : unit -&gt; bool&#xA;override this.LookupIsUnknown : unit -&gt; bool" Usage="xamlType.LookupIsUnknown " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retorna um valor que indica se este <see cref="T:System.Xaml.XamlType" /> representa um tipo que não pode ser resolvido no sistema de tipos subjacente.</summary>
        <returns>
          <see langword="true" /> se este <see cref="T:System.Xaml.XamlType" /> representa um tipo não resolvido; caso contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método pode ser invocado por chamadas para <xref:System.Xaml.XamlType.IsUnknown%2A>.  
  
 A implementação padrão pode usar a reflexão do CLR. Para um valor nulo <xref:System.Xaml.XamlType.UnderlyingType%2A>, ele retorna `true`.  
  
 Substitua este método se você quiser <xref:System.Xaml.XamlType.IsUnknown%2A> para usar uma lógica diferente.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupIsWhitespaceSignificantCollection">
      <MemberSignature Language="C#" Value="protected virtual bool LookupIsWhitespaceSignificantCollection ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool LookupIsWhitespaceSignificantCollection() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.LookupIsWhitespaceSignificantCollection" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupIsWhitespaceSignificantCollection () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool LookupIsWhitespaceSignificantCollection();" />
      <MemberSignature Language="F#" Value="abstract member LookupIsWhitespaceSignificantCollection : unit -&gt; bool&#xA;override this.LookupIsWhitespaceSignificantCollection : unit -&gt; bool" Usage="xamlType.LookupIsWhitespaceSignificantCollection " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retorna um valor que indica se este <see cref="T:System.Xaml.XamlType" /> representa uma coleção significativa de espaço em branco, de acordo com a definição de XML.</summary>
        <returns>
          <see langword="true" /> se este <see cref="T:System.Xaml.XamlType" /> representa uma coleção significativa de espaço em branco; caso contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método pode ser invocado por chamadas para <xref:System.Xaml.XamlType.IsWhitespaceSignificantCollection%2A>.  
  
 A implementação padrão retorna um valor baseado na leitura <xref:System.Windows.Markup.WhitespaceSignificantCollectionAttribute>. Ele também pode verificar o <xref:System.Xaml.XamlType.BaseType%2A> para o atributo se nenhum atributo for encontrado no tipo subjacente de imediato. Se um valor não estiver disponível, ele retorna `false`.  
  
 Substitua este método se você quiser <xref:System.Xaml.XamlType.IsWhitespaceSignificantCollection%2A> para usar uma lógica diferente.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupIsXData">
      <MemberSignature Language="C#" Value="protected virtual bool LookupIsXData ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool LookupIsXData() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.LookupIsXData" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupIsXData () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool LookupIsXData();" />
      <MemberSignature Language="F#" Value="abstract member LookupIsXData : unit -&gt; bool&#xA;override this.LookupIsXData : unit -&gt; bool" Usage="xamlType.LookupIsXData " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retorna um valor que indica se este <see cref="T:System.Xaml.XamlType" /> representa um <see langword="XDATA" /> XML, de acordo com a definição de XAML.</summary>
        <returns>
          <see langword="true" /> se este <see cref="T:System.Xaml.XamlType" /> representa <see langword="XDATA" />; caso contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método pode ser invocado por chamadas para <xref:System.Xaml.XamlType.IsXData%2A>.  
  
 A implementação padrão faz uma <xref:System.Xaml.XamlType.CanAssignTo%2A> chame indiretamente o tipo <xref:System.Xml.Serialization.IXmlSerializable>.  
  
 Substitua este método se você quiser <xref:System.Xaml.XamlType.IsXData%2A> para usar uma lógica diferente.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupItemType">
      <MemberSignature Language="C#" Value="protected virtual System.Xaml.XamlType LookupItemType ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Xaml.XamlType LookupItemType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.LookupItemType" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupItemType () As XamlType" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Xaml::XamlType ^ LookupItemType();" />
      <MemberSignature Language="F#" Value="abstract member LookupItemType : unit -&gt; System.Xaml.XamlType&#xA;override this.LookupItemType : unit -&gt; System.Xaml.XamlType" Usage="xamlType.LookupItemType " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.XamlType</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retorna um valor que fornece as informações de tipo para a propriedade <see langword="Items" /> deste <see cref="T:System.Xaml.XamlType" />.</summary>
        <returns>Um objeto <see cref="T:System.Xaml.XamlType" /> para o tipo dos itens na coleção; caso contrário, <see langword="null" /> se este <see cref="T:System.Xaml.XamlType" /> não representa uma coleção.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método pode ser invocado por chamadas para <xref:System.Xaml.XamlType.ItemType%2A>.  
  
 A implementação padrão pode usar os conceitos de reflexão do CLR, como a verificação para um `Add` método pelo <xref:System.Reflection.MethodInfo> e usando o <xref:System.Reflection.ParameterInfo>; verificação <xref:System.Xaml.XamlType.IsArray%2A>; e a verificação de <xref:System.Xaml.XamlType.BaseType%2A> e tentar a mesma lógica de lá.  
  
 Substitua este método se você quiser <xref:System.Xaml.XamlType.ItemType%2A> para usar uma lógica diferente. Casos onde <xref:System.Xaml.XamlType.LookupCollectionKind%2A> retorna <xref:System.Xaml.Schema.XamlCollectionKind.None?displayProperty=nameWithType> deve retornar `null`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupKeyType">
      <MemberSignature Language="C#" Value="protected virtual System.Xaml.XamlType LookupKeyType ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Xaml.XamlType LookupKeyType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.LookupKeyType" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupKeyType () As XamlType" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Xaml::XamlType ^ LookupKeyType();" />
      <MemberSignature Language="F#" Value="abstract member LookupKeyType : unit -&gt; System.Xaml.XamlType&#xA;override this.LookupKeyType : unit -&gt; System.Xaml.XamlType" Usage="xamlType.LookupKeyType " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.XamlType</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retorna um valor que fornece as informações de tipo para a propriedade de chave deste <see cref="T:System.Xaml.XamlType" />, se o <see cref="T:System.Xaml.XamlType" /> representa um dicionário.</summary>
        <returns>Um objeto <see cref="T:System.Xaml.XamlType" /> para o tipo da chave para uso de dicionário ou <see langword="null" /> se este <see cref="T:System.Xaml.XamlType" /> não representa um dicionário,</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método pode ser invocado por chamadas para <xref:System.Xaml.XamlType.KeyType%2A>.  
  
 A implementação padrão pode usar os conceitos de reflexão do CLR, como a verificação para um `Add` método pelo <xref:System.Reflection.MethodInfo> e usando o <xref:System.Reflection.ParameterInfo>; e a verificação de <xref:System.Xaml.XamlType.BaseType%2A> e tentar a mesma lógica de lá.  
  
 Substitua este método se você quiser <xref:System.Xaml.XamlType.KeyType%2A> para usar uma lógica diferente. Casos onde <xref:System.Xaml.XamlType.LookupCollectionKind%2A> não retorna <xref:System.Xaml.Schema.XamlCollectionKind.Dictionary?displayProperty=nameWithType> deve retornar `null`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupMarkupExtensionReturnType">
      <MemberSignature Language="C#" Value="protected virtual System.Xaml.XamlType LookupMarkupExtensionReturnType ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Xaml.XamlType LookupMarkupExtensionReturnType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.LookupMarkupExtensionReturnType" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupMarkupExtensionReturnType () As XamlType" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Xaml::XamlType ^ LookupMarkupExtensionReturnType();" />
      <MemberSignature Language="F#" Value="abstract member LookupMarkupExtensionReturnType : unit -&gt; System.Xaml.XamlType&#xA;override this.LookupMarkupExtensionReturnType : unit -&gt; System.Xaml.XamlType" Usage="xamlType.LookupMarkupExtensionReturnType " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.XamlType</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retorna um valor que fornece as informações de tipo para o <see langword="ProvideValue" /> retornado deste <see cref="T:System.Xaml.XamlType" />, se ele representa uma extensão de marcação.</summary>
        <returns>Um objeto <see cref="T:System.Xaml.XamlType" /> para o tipo de retorno para o uso da extensão de marcação; caso contrário, <see langword="null" />, se este <see cref="T:System.Xaml.XamlType" /> não representa uma extensão de marcação.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método pode ser invocado por chamadas para <xref:System.Xaml.XamlType.MarkupExtensionReturnType%2A>.  
  
 A implementação padrão retorna um <xref:System.Xaml.XamlType> com base na leitura <xref:System.Windows.Markup.MarkupExtensionReturnTypeAttribute>. Ele também pode verificar <xref:System.Xaml.XamlType.BaseType%2A> para o atributo se nenhum atributo for encontrado no tipo subjacente de imediato. Se um valor não estiver disponível, ele retorna `null`.  
  
 Substitua este método se você quiser <xref:System.Xaml.XamlType.MarkupExtensionReturnType%2A> para usar uma lógica diferente.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupMember">
      <MemberSignature Language="C#" Value="protected virtual System.Xaml.XamlMember LookupMember (string name, bool skipReadOnlyCheck);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Xaml.XamlMember LookupMember(string name, bool skipReadOnlyCheck) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.LookupMember(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupMember (name As String, skipReadOnlyCheck As Boolean) As XamlMember" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Xaml::XamlMember ^ LookupMember(System::String ^ name, bool skipReadOnlyCheck);" />
      <MemberSignature Language="F#" Value="abstract member LookupMember : string * bool -&gt; System.Xaml.XamlMember&#xA;override this.LookupMember : string * bool -&gt; System.Xaml.XamlMember" Usage="xamlType.LookupMember (name, skipReadOnlyCheck)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.XamlMember</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="skipReadOnlyCheck" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="name">O nome do membro a ser obtido (como uma cadeia de caracteres).</param>
        <param name="skipReadOnlyCheck">
          <see langword="true" /> para retornar um membro, mesmo se esse membro tiver um valor <see langword="true" /> para <see cref="P:System.Xaml.XamlMember.IsReadOnly" />; <see langword="false" /> para não retornar um membro <see cref="P:System.Xaml.XamlMember.IsReadOnly" />. O padrão é <see langword="false" />.</param>
        <summary>Retorna o <see cref="T:System.Xaml.XamlMember" /> para um membro nomeado específico deste <see cref="T:System.Xaml.XamlType" />.</summary>
        <returns>As informações <see cref="T:System.Xaml.XamlMember" /> para o membro, se um membro for encontrado; caso contrário, <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método pode ser invocado por chamadas para <xref:System.Xaml.XamlType.GetMember%2A>.  
  
 A implementação padrão retorna um <xref:System.Xaml.XamlType> com base em reflexão interno do CLR e avaliação contra o contexto do esquema.  
  
 Substitua este método se você quiser <xref:System.Xaml.XamlType.GetMember%2A> para usar uma lógica diferente.  
  
> [!IMPORTANT]
>  <xref:System.Xaml.XamlType.LookupMember%2A> é virtual e, portanto, pode ser substituído. A substituição tem o potencial (seja para fins mal-intencionados ou de outra forma) para alterar os membros relatados de um tipo XAML para que eles não se alinham de maneira esperada com a <xref:System.ComponentModel.TypeDescriptor> `Get*` informações sobre o tipo CLR subjacente. Para nenhuma verificação de segurança crítica de emissão de relatórios do membro, use o tipo CLR subjacente.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupPositionalParameters">
      <MemberSignature Language="C#" Value="protected virtual System.Collections.Generic.IList&lt;System.Xaml.XamlType&gt; LookupPositionalParameters (int parameterCount);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Collections.Generic.IList`1&lt;class System.Xaml.XamlType&gt; LookupPositionalParameters(int32 parameterCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.LookupPositionalParameters(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupPositionalParameters (parameterCount As Integer) As IList(Of XamlType)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Collections::Generic::IList&lt;System::Xaml::XamlType ^&gt; ^ LookupPositionalParameters(int parameterCount);" />
      <MemberSignature Language="F#" Value="abstract member LookupPositionalParameters : int -&gt; System.Collections.Generic.IList&lt;System.Xaml.XamlType&gt;&#xA;override this.LookupPositionalParameters : int -&gt; System.Collections.Generic.IList&lt;System.Xaml.XamlType&gt;" Usage="xamlType.LookupPositionalParameters parameterCount" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IList&lt;System.Xaml.XamlType&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="parameterCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="parameterCount">A contagem (aridade) do modo de sintaxe ou de construtor específico do qual você deseja obter informações.</param>
        <summary>Para tipos de extensão de marcação, retorna os tipos dos parâmetros posicionais que são compatíveis no uso de extensão de marcação específica para este <see cref="T:System.Xaml.XamlType" />.</summary>
        <returns>Uma lista de valores <see cref="T:System.Xaml.XamlType" />, em que cada um desses <see cref="T:System.Xaml.XamlType" /> é o tipo da posição na sintaxe. Você deve especificar esses tipos na mesma ordem ao fornecer a entrada de marcação para a extensão de marcação.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método pode ser invocado por chamadas para <xref:System.Xaml.XamlType.GetPositionalParameters%2A>.  
  
 A implementação padrão usa informações de reflexão interno com base na localização construtores e verificando o arity. Substitua este método se você quiser <xref:System.Xaml.XamlType.GetPositionalParameters%2A> para usar uma lógica diferente.  
  
 Essa API só é relevante se este <xref:System.Xaml.XamlType> representa uma extensão de marcação (<xref:System.Xaml.XamlType.IsMarkupExtension%2A> é `true`).  
  
 A entrada `parameterCount` não é para solicitar o tipo de um parâmetro posicional específico. Ele é para especificar a aridade do uso de uma extensão de marcação. Uso de extensão de marcação geralmente tem várias assinaturas e usa parâmetros diferentes arity (contagem) de parâmetros posicionais para diferenciar. No entanto, você pode configurar um contexto de esquema para permitir arities duplicados e usar tipos dos parâmetros posicionais para diferenciação. Para obter mais informações, consulte <xref:System.Xaml.XamlSchemaContext.SupportMarkupExtensionsWithDuplicateArity%2A>. Para uma contagem de arity específico, a posição de parâmetro e tipos podem variar. Para obter o tipo posicional de uso de extensão de marcação de um específico igual à aridade, você primeiro chama <xref:System.Xaml.XamlType.GetPositionalParameters%2A> com a contagem de arity. Em seguida, obtenha o item nessa posição na coleção retornada.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupSetMarkupExtensionHandler">
      <MemberSignature Language="C#" Value="protected virtual EventHandler&lt;System.Windows.Markup.XamlSetMarkupExtensionEventArgs&gt; LookupSetMarkupExtensionHandler ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.EventHandler`1&lt;class System.Windows.Markup.XamlSetMarkupExtensionEventArgs&gt; LookupSetMarkupExtensionHandler() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.LookupSetMarkupExtensionHandler" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupSetMarkupExtensionHandler () As EventHandler(Of XamlSetMarkupExtensionEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual EventHandler&lt;System::Windows::Markup::XamlSetMarkupExtensionEventArgs ^&gt; ^ LookupSetMarkupExtensionHandler();" />
      <MemberSignature Language="F#" Value="abstract member LookupSetMarkupExtensionHandler : unit -&gt; EventHandler&lt;System.Windows.Markup.XamlSetMarkupExtensionEventArgs&gt;&#xA;override this.LookupSetMarkupExtensionHandler : unit -&gt; EventHandler&lt;System.Windows.Markup.XamlSetMarkupExtensionEventArgs&gt;" Usage="xamlType.LookupSetMarkupExtensionHandler " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Windows.Markup.XamlSetMarkupExtensionEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retorna um retorno de chamada do manipulador a ser usado para as operações de conjunto das extensões de marcação.</summary>
        <returns>Um retorno de chamada do manipulador a ser usado para as operações de conjunto das extensões de marcação.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A implementação padrão retorna um valor baseado na leitura <xref:System.Windows.Markup.XamlSetMarkupExtensionAttribute>. Ele também pode verificar <xref:System.Xaml.XamlType.BaseType%2A> para o atributo se nenhum atributo for encontrado no tipo subjacente de imediato. Se um valor não estiver disponível, ele retorna `null`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupSetTypeConverterHandler">
      <MemberSignature Language="C#" Value="protected virtual EventHandler&lt;System.Windows.Markup.XamlSetTypeConverterEventArgs&gt; LookupSetTypeConverterHandler ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.EventHandler`1&lt;class System.Windows.Markup.XamlSetTypeConverterEventArgs&gt; LookupSetTypeConverterHandler() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.LookupSetTypeConverterHandler" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupSetTypeConverterHandler () As EventHandler(Of XamlSetTypeConverterEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual EventHandler&lt;System::Windows::Markup::XamlSetTypeConverterEventArgs ^&gt; ^ LookupSetTypeConverterHandler();" />
      <MemberSignature Language="F#" Value="abstract member LookupSetTypeConverterHandler : unit -&gt; EventHandler&lt;System.Windows.Markup.XamlSetTypeConverterEventArgs&gt;&#xA;override this.LookupSetTypeConverterHandler : unit -&gt; EventHandler&lt;System.Windows.Markup.XamlSetTypeConverterEventArgs&gt;" Usage="xamlType.LookupSetTypeConverterHandler " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Windows.Markup.XamlSetTypeConverterEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retorna um manipulador a ser usado para casos configuração de conversor de tipo.</summary>
        <returns>Um manipulador a ser usado para casos configuração de conversor de tipo.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A implementação padrão retorna um valor baseado na leitura <xref:System.Windows.Markup.XamlSetTypeConverterAttribute>. Ele também pode verificar <xref:System.Xaml.XamlType.BaseType%2A> para o atributo se nenhum atributo for encontrado no tipo subjacente de imediato. Se um valor não estiver disponível, ele retorna `null`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupTrimSurroundingWhitespace">
      <MemberSignature Language="C#" Value="protected virtual bool LookupTrimSurroundingWhitespace ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool LookupTrimSurroundingWhitespace() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.LookupTrimSurroundingWhitespace" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupTrimSurroundingWhitespace () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool LookupTrimSurroundingWhitespace();" />
      <MemberSignature Language="F#" Value="abstract member LookupTrimSurroundingWhitespace : unit -&gt; bool&#xA;override this.LookupTrimSurroundingWhitespace : unit -&gt; bool" Usage="xamlType.LookupTrimSurroundingWhitespace " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retorna um valor que indica se este <see cref="T:System.Xaml.XamlType" /> deve ser serializado usando um modo que corta os espaços em branco ao redor.</summary>
        <returns>
          <see langword="true" /> se este <see cref="T:System.Xaml.XamlType" /> deve ser serializado em um modo que corta os espaços em branco ao redor; caso contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método pode ser invocado por chamadas para <xref:System.Xaml.XamlType.TrimSurroundingWhitespace%2A>.  
  
 A implementação padrão retorna um valor baseado na leitura <xref:System.Windows.Markup.TrimSurroundingWhitespaceAttribute>. Ele também pode verificar <xref:System.Xaml.XamlType.BaseType%2A> para o atributo se nenhum atributo for encontrado no tipo subjacente de imediato. Se um valor não estiver disponível, ele retorna `false`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupTypeConverter">
      <MemberSignature Language="C#" Value="protected virtual System.Xaml.Schema.XamlValueConverter&lt;System.ComponentModel.TypeConverter&gt; LookupTypeConverter ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Xaml.Schema.XamlValueConverter`1&lt;class System.ComponentModel.TypeConverter&gt; LookupTypeConverter() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.LookupTypeConverter" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupTypeConverter () As XamlValueConverter(Of TypeConverter)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Xaml::Schema::XamlValueConverter&lt;System::ComponentModel::TypeConverter ^&gt; ^ LookupTypeConverter();" />
      <MemberSignature Language="F#" Value="abstract member LookupTypeConverter : unit -&gt; System.Xaml.Schema.XamlValueConverter&lt;System.ComponentModel.TypeConverter&gt;&#xA;override this.LookupTypeConverter : unit -&gt; System.Xaml.Schema.XamlValueConverter&lt;System.ComponentModel.TypeConverter&gt;" Usage="xamlType.LookupTypeConverter " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.Schema.XamlValueConverter&lt;System.ComponentModel.TypeConverter&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retorna um <see cref="T:System.Xaml.Schema.XamlValueConverter`1" /> que tem uma restrição <see cref="T:System.ComponentModel.TypeConverter" />, que representa o comportamento de conversão de tipo para valores desse <see cref="T:System.Xaml.XamlType" />.</summary>
        <returns>Um <see cref="T:System.Xaml.Schema.XamlValueConverter`1" /> com restrição <see cref="T:System.ComponentModel.TypeConverter" /> que representa o comportamento de conversão de tipo para valores desse <see cref="T:System.Xaml.XamlType" />; caso contrário, <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método pode ser invocado por chamadas para <xref:System.Xaml.XamlType.TypeConverter%2A>.  
  
 A implementação padrão retorna um valor baseado na leitura <xref:System.ComponentModel.TypeConverterAttribute>. A implementação padrão também pode verificar <xref:System.Xaml.XamlType.BaseType%2A> para o atributo se nenhum atributo for encontrado no tipo subjacente de imediato. Ele também inclui uma lógica especial para a conversão de padrão de enumerações, tipos de valor comuns e genéricos. Se um valor não estiver disponível, ele retorna `null`.  
  
 Substitua este método se você quiser <xref:System.Xaml.XamlType.TypeConverter%2A> para usar uma lógica diferente.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupUnderlyingType">
      <MemberSignature Language="C#" Value="protected virtual Type LookupUnderlyingType ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Type LookupUnderlyingType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.LookupUnderlyingType" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupUnderlyingType () As Type" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual Type ^ LookupUnderlyingType();" />
      <MemberSignature Language="F#" Value="abstract member LookupUnderlyingType : unit -&gt; Type&#xA;override this.LookupUnderlyingType : unit -&gt; Type" Usage="xamlType.LookupUnderlyingType " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retorna o <see cref="T:System.Type" /> do CLR que é subjacente a esse <see cref="T:System.Xaml.XamlType" />.</summary>
        <returns>O <see cref="T:System.Type" /> do CLR que é subjacente a esse <see cref="T:System.Xaml.XamlType" />; caso contrário, <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método pode ser invocado por chamadas para <xref:System.Xaml.XamlType.UnderlyingType%2A>.  
  
 A implementação padrão retorna um campo interno. Geralmente, esse campo é inicializado durante a construção e seu valor é baseado em qual construtor foi chamado e as informações que você forneceu.  
  
 Substitua este método se você quiser <xref:System.Xaml.XamlType.UnderlyingType%2A> para usar uma lógica diferente.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupUsableDuringInitialization">
      <MemberSignature Language="C#" Value="protected virtual bool LookupUsableDuringInitialization ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool LookupUsableDuringInitialization() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.LookupUsableDuringInitialization" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupUsableDuringInitialization () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool LookupUsableDuringInitialization();" />
      <MemberSignature Language="F#" Value="abstract member LookupUsableDuringInitialization : unit -&gt; bool&#xA;override this.LookupUsableDuringInitialization : unit -&gt; bool" Usage="xamlType.LookupUsableDuringInitialization " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retorna um valor que indica se este <see cref="T:System.Xaml.XamlType" /> é compilado de cima para baixo durante a inicialização do XAML.</summary>
        <returns>
          <see langword="true" /> se este <see cref="T:System.Xaml.XamlType" /> é compilado de cima para baixo durante a inicialização do XAML; caso contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 De cima para baixo é uma metáfora que aproxima o comportamento do processador XAML quando ele cria o gráfico do objeto. Quando compilado de cima para baixo, um tipo é instanciado, anexado ao pai, e tem suas propriedades definidas. Construção de cima para baixo evita invocar manipuladores de propriedades alteradas várias vezes. Tal tratamento ripples o grafo de objeto e, portanto, elimina as várias chamadas do manipulador e fornece uma otimização de desempenho de inicialização do grafo do objeto.  
  
 Esse método pode ser invocado por chamadas para <xref:System.Xaml.XamlType.IsUsableDuringInitialization%2A>.  
  
 A implementação padrão retorna um valor baseado na leitura <xref:System.Windows.Markup.UsableDuringInitializationAttribute>. Ele também pode verificar <xref:System.Xaml.XamlType.BaseType%2A> para o atributo se nenhum atributo for encontrado no tipo subjacente de imediato. Se um valor não estiver disponível, ele retorna `false`.  
  
 Substitua este método se você quiser <xref:System.Xaml.XamlType.IsUsableDuringInitialization%2A> para usar uma lógica diferente.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupValueSerializer">
      <MemberSignature Language="C#" Value="protected virtual System.Xaml.Schema.XamlValueConverter&lt;System.Windows.Markup.ValueSerializer&gt; LookupValueSerializer ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Xaml.Schema.XamlValueConverter`1&lt;class System.Windows.Markup.ValueSerializer&gt; LookupValueSerializer() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.LookupValueSerializer" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupValueSerializer () As XamlValueConverter(Of ValueSerializer)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Xaml::Schema::XamlValueConverter&lt;System::Windows::Markup::ValueSerializer ^&gt; ^ LookupValueSerializer();" />
      <MemberSignature Language="F#" Value="abstract member LookupValueSerializer : unit -&gt; System.Xaml.Schema.XamlValueConverter&lt;System.Windows.Markup.ValueSerializer&gt;&#xA;override this.LookupValueSerializer : unit -&gt; System.Xaml.Schema.XamlValueConverter&lt;System.Windows.Markup.ValueSerializer&gt;" Usage="xamlType.LookupValueSerializer " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.Schema.XamlValueConverter&lt;System.Windows.Markup.ValueSerializer&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retorna um <see cref="T:System.Xaml.Schema.XamlValueConverter`1" /> que tem uma restrição <see cref="T:System.Windows.Markup.ValueSerializer" />, que representa o comportamento de serialização de valor para valores desse <see cref="T:System.Xaml.XamlType" />.</summary>
        <returns>Um <see cref="T:System.Xaml.Schema.XamlValueConverter`1" /> com restrição <see cref="T:System.Windows.Markup.ValueSerializer" /> que representa o comportamento de serialização de valor para valores desse <see cref="T:System.Xaml.XamlType" />; caso contrário, <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método pode ser invocado por chamadas para <xref:System.Xaml.XamlType.ValueSerializer%2A>.  
  
 A implementação padrão retorna um valor baseado na leitura <xref:System.Windows.Markup.ValueSerializerAttribute>. Ele também pode verificar <xref:System.Xaml.XamlType.BaseType%2A> para o atributo se nenhum atributo for encontrado no tipo subjacente de imediato. Ele também inclui uma lógica especial para a serialização padrão de enumerações, tipos de valor comuns ou genéricos. Se um valor não estiver disponível, ele retorna `null`.  
  
 Substitua este método se você quiser <xref:System.Xaml.XamlType.ValueSerializer%2A> para usar uma lógica diferente.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MarkupExtensionReturnType">
      <MemberSignature Language="C#" Value="public System.Xaml.XamlType MarkupExtensionReturnType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Xaml.XamlType MarkupExtensionReturnType" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlType.MarkupExtensionReturnType" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property MarkupExtensionReturnType As XamlType" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Xaml::XamlType ^ MarkupExtensionReturnType { System::Xaml::XamlType ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.MarkupExtensionReturnType : System.Xaml.XamlType" Usage="System.Xaml.XamlType.MarkupExtensionReturnType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.XamlType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém um valor que fornece as informações de tipo para o <see langword="ProvideValue" /> retornado deste <see cref="T:System.Xaml.XamlType" />, se ele representa uma extensão de marcação.</summary>
        <value>Um objeto <see cref="T:System.Xaml.XamlType" /> para o tipo de retorno para o uso da extensão de marcação; caso contrário, <see langword="null" />, se este <see cref="T:System.Xaml.XamlType" /> não representa uma extensão de marcação.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Essa propriedade só é relevante se este <xref:System.Xaml.XamlType> representa uma extensão de marcação (`x:MarkupExtension` está na lista de tipos atribuíveis).  
  
 Se você não usar a técnica de reflexão padrão interna CLR para um <xref:System.Xaml.XamlType>, chamadas para essa propriedade podem invocar <xref:System.Xaml.XamlType.LookupMarkupExtensionReturnType%2A> prevalece em <xref:System.Xaml.XamlType> classes derivadas. Para obter mais informações sobre valores de retorno e outros comportamentos, consulte a documentação para <xref:System.Xaml.XamlType.LookupMarkupExtensionReturnType%2A> nesse tipo.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public string Name { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlType.Name" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Name As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Name { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Name : string" Usage="System.Xaml.XamlType.Name" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém o nome da cadeia de caracteres do tipo que esse <see cref="T:System.Xaml.XamlType" /> representa.</summary>
        <value>O nome de cadeia de caracteres desse tipo de XAML.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Essa propriedade normalmente obtém o nome do esquema construído (pela <xref:System.Xaml.XamlType.%23ctor%2A> assinatura), ou o nome da <xref:System.Type>, se ele é construído usando o construtor pertinente do sistema de tipos CLR.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (System.Xaml.XamlType xamlType1, System.Xaml.XamlType xamlType2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(class System.Xaml.XamlType xamlType1, class System.Xaml.XamlType xamlType2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.op_Equality(System.Xaml.XamlType,System.Xaml.XamlType)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator == (xamlType1 As XamlType, xamlType2 As XamlType) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator ==(System::Xaml::XamlType ^ xamlType1, System::Xaml::XamlType ^ xamlType2);" />
      <MemberSignature Language="F#" Value="static member ( = ) : System.Xaml.XamlType * System.Xaml.XamlType -&gt; bool" Usage="xamlType1 = xamlType2" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="xamlType1" Type="System.Xaml.XamlType" />
        <Parameter Name="xamlType2" Type="System.Xaml.XamlType" />
      </Parameters>
      <Docs>
        <param name="xamlType1">
          <see cref="T:System.Xaml.XamlType" /> ou <see langword="null" />.</param>
        <param name="xamlType2">
          <see cref="T:System.Xaml.XamlType" /> ou <see langword="null" />.</param>
        <summary>Determina se dois objetos <see cref="T:System.Xaml.XamlType" /> especificados têm o mesmo valor.</summary>
        <returns>
          <see langword="true" /> se o valor de <paramref name="xamlType1" /> for o mesmo que o valor de <paramref name="xamlType2" />; caso contrário, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (System.Xaml.XamlType xamlType1, System.Xaml.XamlType xamlType2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(class System.Xaml.XamlType xamlType1, class System.Xaml.XamlType xamlType2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.op_Inequality(System.Xaml.XamlType,System.Xaml.XamlType)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator != (xamlType1 As XamlType, xamlType2 As XamlType) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator !=(System::Xaml::XamlType ^ xamlType1, System::Xaml::XamlType ^ xamlType2);" />
      <MemberSignature Language="F#" Value="static member op_Inequality : System.Xaml.XamlType * System.Xaml.XamlType -&gt; bool" Usage="System.Xaml.XamlType.op_Inequality (xamlType1, xamlType2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="xamlType1" Type="System.Xaml.XamlType" />
        <Parameter Name="xamlType2" Type="System.Xaml.XamlType" />
      </Parameters>
      <Docs>
        <param name="xamlType1">
          <see cref="T:System.Xaml.XamlType" /> ou <see langword="null" />.</param>
        <param name="xamlType2">
          <see cref="T:System.Xaml.XamlType" /> ou <see langword="null" />.</param>
        <summary>Determina se dois objetos <see cref="T:System.Xaml.XamlType" /> especificados têm valores diferentes.</summary>
        <returns>
          <see langword="true" /> se o valor de <paramref name="xamlType1" /> for diferente do valor de <paramref name="xamlType2" />; caso contrário, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PreferredXamlNamespace">
      <MemberSignature Language="C#" Value="public string PreferredXamlNamespace { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string PreferredXamlNamespace" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlType.PreferredXamlNamespace" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PreferredXamlNamespace As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ PreferredXamlNamespace { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.PreferredXamlNamespace : string" Usage="System.Xaml.XamlType.PreferredXamlNamespace" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém o único namespace de XAML que é o namespace de XAML primário para este <see cref="T:System.Xaml.XamlType" />.</summary>
        <value>O identificador, como uma cadeia de caracteres do namespace XAML primário para este tipo XAML.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Essa implementação oferece o mesmo valor que chamar <xref:System.Xaml.XamlType.GetXamlNamespaces%2A> e, em seguida, recebendo a primeira cadeia de caracteres do valor de conjunto enumerável retornado.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SchemaContext">
      <MemberSignature Language="C#" Value="public System.Xaml.XamlSchemaContext SchemaContext { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Xaml.XamlSchemaContext SchemaContext" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlType.SchemaContext" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SchemaContext As XamlSchemaContext" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Xaml::XamlSchemaContext ^ SchemaContext { System::Xaml::XamlSchemaContext ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SchemaContext : System.Xaml.XamlSchemaContext" Usage="System.Xaml.XamlType.SchemaContext" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Xaml.XamlSchemaContext</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém o <see cref="T:System.Xaml.XamlSchemaContext" /> ativo para o processamento desse <see cref="T:System.Xaml.XamlType" />.</summary>
        <value>O Active Directory <see cref="T:System.Xaml.XamlSchemaContext" /> para o processamento desse <see cref="T:System.Xaml.XamlType" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Xaml.XamlSchemaContext> é uma entrada de parâmetro obrigatório ao construir um <xref:System.Xaml.XamlType>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="xamlType.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retorna uma representação de cadeia de caracteres desse <see cref="T:System.Xaml.XamlType" />.</summary>
        <returns>Uma representação da cadeia de caracteres desse <see cref="T:System.Xaml.XamlType" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Xaml.XamlType> implementação de <xref:System.Object.ToString%2A> retorna o <xref:System.Xaml.XamlType.Name%2A> propriedade do <xref:System.Xaml.XamlType>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TrimSurroundingWhitespace">
      <MemberSignature Language="C#" Value="public bool TrimSurroundingWhitespace { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool TrimSurroundingWhitespace" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlType.TrimSurroundingWhitespace" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property TrimSurroundingWhitespace As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool TrimSurroundingWhitespace { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.TrimSurroundingWhitespace : bool" Usage="System.Xaml.XamlType.TrimSurroundingWhitespace" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém um valor que indica se este <see cref="T:System.Xaml.XamlType" /> tem o comportamento de manipulação de espaço em branco para serialização que corta o espaço em branco ao redor em seu conteúdo.</summary>
        <value>
          <see langword="true" /> Se este <see cref="T:System.Xaml.XamlType" /> representa um tipo que usa o espaço em branco trimming; caso contrário, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se você não usar a técnica de reflexão padrão interna CLR para um <xref:System.Xaml.XamlType>, chamadas para essa propriedade podem invocar <xref:System.Xaml.XamlType.LookupIsWhitespaceSignificantCollection%2A> prevalece em <xref:System.Xaml.XamlType> classes derivadas. Para obter mais informações sobre valores de retorno e outros comportamentos, consulte a documentação para <xref:System.Xaml.XamlType.LookupIsWhitespaceSignificantCollection%2A> nesse tipo.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TypeArguments">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IList&lt;System.Xaml.XamlType&gt; TypeArguments { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IList`1&lt;class System.Xaml.XamlType&gt; TypeArguments" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlType.TypeArguments" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property TypeArguments As IList(Of XamlType)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Generic::IList&lt;System::Xaml::XamlType ^&gt; ^ TypeArguments { System::Collections::Generic::IList&lt;System::Xaml::XamlType ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.TypeArguments : System.Collections.Generic.IList&lt;System.Xaml.XamlType&gt;" Usage="System.Xaml.XamlType.TypeArguments" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IList&lt;System.Xaml.XamlType&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém uma lista de argumentos de tipo para casos em que esse <see cref="T:System.Xaml.XamlType" /> representa um genérico.</summary>
        <value>Uma lista de tipos de argumento de tipo; Caso contrário, <see langword="null" />, se este <see cref="T:System.Xaml.XamlType" /> não representa um genérico.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Existem alguns cenários para uma <xref:System.Xaml.XamlType> em que chamar o <xref:System.Xaml.XamlType.TypeArguments%2A> parâmetro retorna uma lista em que os tipos ainda estão abertos. Nesse caso, um ou mais dos retornado <xref:System.Xaml.XamlType> valores terão valores de espaço reservado <xref:System.Xaml.XamlType.Name%2A?displayProperty=nameWithType>, como `T`, para representar que o genérico ainda está aberto. Este cenário poderá ocorrer se você receber um <xref:System.Xaml.XamlType> de uma chamada para <xref:System.Xaml.XamlSchemaContext.GetXamlType%2A>, em vez de uma implementação de leitor XAML.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TypeConverter">
      <MemberSignature Language="C#" Value="public System.Xaml.Schema.XamlValueConverter&lt;System.ComponentModel.TypeConverter&gt; TypeConverter { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Xaml.Schema.XamlValueConverter`1&lt;class System.ComponentModel.TypeConverter&gt; TypeConverter" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlType.TypeConverter" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property TypeConverter As XamlValueConverter(Of TypeConverter)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Xaml::Schema::XamlValueConverter&lt;System::ComponentModel::TypeConverter ^&gt; ^ TypeConverter { System::Xaml::Schema::XamlValueConverter&lt;System::ComponentModel::TypeConverter ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.TypeConverter : System.Xaml.Schema.XamlValueConverter&lt;System.ComponentModel.TypeConverter&gt;" Usage="System.Xaml.XamlType.TypeConverter" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.Schema.XamlValueConverter&lt;System.ComponentModel.TypeConverter&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém um <see cref="T:System.Xaml.Schema.XamlValueConverter`1" /> com restrição <see cref="T:System.ComponentModel.TypeConverter" /> que representa o comportamento de conversão de tipo para valores desse <see cref="T:System.Xaml.XamlType" />.</summary>
        <value>Um <see cref="T:System.Xaml.Schema.XamlValueConverter`1" /> com <see cref="T:System.ComponentModel.TypeConverter" /> que representa o comportamento de conversão para valores desse tipo de restrição <see cref="T:System.Xaml.XamlType" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se você não usar a técnica de reflexão padrão interna CLR para um <xref:System.Xaml.XamlType>, chamadas para essa propriedade podem invocar <xref:System.Xaml.XamlType.LookupTypeConverter%2A> prevalece em <xref:System.Xaml.XamlType> classes derivadas. Para obter mais informações sobre valores de retorno e outros comportamentos, consulte a documentação para <xref:System.Xaml.XamlType.LookupTypeConverter%2A> nesse tipo.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UnderlyingType">
      <MemberSignature Language="C#" Value="public Type UnderlyingType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type UnderlyingType" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlType.UnderlyingType" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property UnderlyingType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Type ^ UnderlyingType { Type ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.UnderlyingType : Type" Usage="System.Xaml.XamlType.UnderlyingType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém o <see cref="T:System.Type" /> do CLR que é subjacente a esse <see cref="T:System.Xaml.XamlType" />.</summary>
        <value>O CLR <see cref="T:System.Type" /> que é subjacente a esse <see cref="T:System.Xaml.XamlType" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ValueSerializer">
      <MemberSignature Language="C#" Value="public System.Xaml.Schema.XamlValueConverter&lt;System.Windows.Markup.ValueSerializer&gt; ValueSerializer { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Xaml.Schema.XamlValueConverter`1&lt;class System.Windows.Markup.ValueSerializer&gt; ValueSerializer" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlType.ValueSerializer" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ValueSerializer As XamlValueConverter(Of ValueSerializer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Xaml::Schema::XamlValueConverter&lt;System::Windows::Markup::ValueSerializer ^&gt; ^ ValueSerializer { System::Xaml::Schema::XamlValueConverter&lt;System::Windows::Markup::ValueSerializer ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ValueSerializer : System.Xaml.Schema.XamlValueConverter&lt;System.Windows.Markup.ValueSerializer&gt;" Usage="System.Xaml.XamlType.ValueSerializer" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.Schema.XamlValueConverter&lt;System.Windows.Markup.ValueSerializer&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém um <see cref="T:System.Xaml.Schema.XamlValueConverter`1" /> com restrição <see cref="T:System.Windows.Markup.ValueSerializer" /> que representa o comportamento de serialização de valor para valores desse <see cref="T:System.Xaml.XamlType" />.</summary>
        <value>Um <see cref="T:System.Xaml.Schema.XamlValueConverter`1" /> com restrição <see cref="T:System.Windows.Markup.ValueSerializer" /> que representa o comportamento de serialização de valor para valores desse <see cref="T:System.Xaml.XamlType" />; caso contrário, <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se você não usar a técnica de reflexão padrão interna CLR para um <xref:System.Xaml.XamlType>, chamadas para essa propriedade podem invocar <xref:System.Xaml.XamlType.LookupValueSerializer%2A> prevalece em <xref:System.Xaml.XamlType> classes derivadas. Para obter mais informações sobre valores de retorno e outros comportamentos, consulte a documentação para <xref:System.Xaml.XamlType.LookupValueSerializer%2A> nesse tipo.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>