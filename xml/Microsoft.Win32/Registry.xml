<Type Name="Registry" FullName="Microsoft.Win32.Registry">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="b5ddffb41db3e1edcd0591a5abd1027692cd10e8" />
    <Meta Name="ms.sourcegitcommit" Value="0ec122ee5f3681159b8460ab15b409fd6e3d3ae0" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="pt-BR" />
    <Meta Name="ms.lasthandoff" Value="10/04/2018" />
    <Meta Name="ms.locfileid" Value="48757679" />
  </Metadata>
  <TypeSignature Language="C#" Value="public static class Registry" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed beforefieldinit Registry extends System.Object" />
  <TypeSignature Language="DocId" Value="T:Microsoft.Win32.Registry" />
  <TypeSignature Language="VB.NET" Value="Public Class Registry" />
  <TypeSignature Language="C++ CLI" Value="public ref class Registry abstract sealed" />
  <TypeSignature Language="F#" Value="type Registry = class" />
  <AssemblyInfo>
    <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Fornece objetos <see cref="T:Microsoft.Win32.RegistryKey" /> que representam as chaves raiz no Registro do Windows e os métodos <see langword="static" /> para acessar os pares chave/valor.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Essa classe fornece o conjunto de chaves de raiz padrão encontrado no registro em computadores executando o Windows. O registro é um recurso de armazenamento para obter informações sobre aplicativos, usuários e configurações padrão do sistema. Por exemplo, os aplicativos podem usar o registro para armazenar informações que precisam ser preservadas quando o aplicativo é fechado e acessar as mesmas informações quando o aplicativo é recarregado. Por exemplo, você pode armazenar preferências de cor, locais de tela ou o tamanho da janela. Você pode controlar esses dados para cada usuário, armazenando as informações em um local diferente no registro.  
  
 A base ou raiz <xref:Microsoft.Win32.RegistryKey> instâncias que são expostas pelo `Registry` classe delineiam o mecanismo de armazenamento básica para os valores no registro e subchaves. Todas as chaves são somente leitura porque o registro depende de sua existência. As chaves expostas pela `Registry` são:  
  
 <xref:Microsoft.Win32.Registry.CurrentUser>  
 Armazena informações sobre as preferências do usuário.  
  
 <xref:Microsoft.Win32.Registry.LocalMachine>  
 Armazena informações de configuração para o computador local.  
  
 <xref:Microsoft.Win32.Registry.ClassesRoot>  
 Armazena informações sobre tipos (e classes) e suas propriedades.  
  
 <xref:Microsoft.Win32.Registry.Users>  
 Armazena informações sobre a configuração de usuário padrão.  
  
 <xref:Microsoft.Win32.Registry.PerformanceData>  
 Armazena informações de desempenho de componentes de software.  
  
 <xref:Microsoft.Win32.Registry.CurrentConfig>  
 Armazena informações de hardware não específico de usuário.  
  
 <xref:Microsoft.Win32.Registry.DynData>  
 Armazena dados dinâmicos.  
  
 Depois de ter identificado a chave de raiz sob a qual você deseja armazenar/recuperar informações do registro, você pode usar o <xref:Microsoft.Win32.RegistryKey> de classe para adicionar ou remover as subchaves e manipular os valores para uma determinada chave.  
  
 Dispositivos de hardware podem colocar as informações no registro automaticamente usando a interface de Plug and Play. Software para instalar os drivers de dispositivo pode colocar informações no registro, escrevendo para APIs padrão.  
  
## <a name="static-methods-for-getting-and-setting-values"></a>Métodos estáticos para obter e definir valores  
 No .NET Framework versão 2.0, o <xref:Microsoft.Win32.Registry> classe também contém `static` <xref:Microsoft.Win32.Registry.GetValue%2A> e <xref:Microsoft.Win32.Registry.SetValue%2A> métodos para definir e recuperar valores de chaves do registro. Esses métodos abrem e chaves de registro fechar cada tempo eles são usados, para que eles não executam bem como métodos análogos no <xref:Microsoft.Win32.RegistryKey> classe, quando você acessa um grande número de valores.  
  
 O <xref:Microsoft.Win32.RegistryKey> classe também fornece métodos que permitem que você defina a segurança de controle de acesso do Windows para chaves do registro, para testar o tipo de dados de um valor antes de recuperá-lo e excluir chaves.  
  
   
  
## Examples  
 Esta seção contém dois exemplos de código. O primeiro exemplo demonstra as chaves de raiz e o segundo exemplo demonstra a `static` <xref:Microsoft.Win32.Registry.GetValue%2A> e <xref:Microsoft.Win32.Registry.SetValue%2A> métodos.  
  
 Exemplo 1  
  
 O exemplo de código a seguir demonstra como recuperar as subchaves da chave HKEY_USERS e seus nomes para a tela de impressão. Use o <xref:Microsoft.Win32.RegistryKey.OpenSubKey%2A> método para criar uma instância da subchave de interesse específica. Você pode usar outras operações em `RegistryKey` para manipular essa chave.  
  
 [!code-cpp[Classic Registry.Users Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Registry.Users Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Registry.Users Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Registry.Users Example/CS/source.cs#1)]
 [!code-vb[Classic Registry.Users Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Registry.Users Example/VB/source.vb#1)]  
  
 Exemplo 2  
  
 O exemplo de código a seguir armazena valores de diversos tipos de dados em uma chave de exemplo, a criação da chave conforme ele faz isso e, em seguida, recupera e exibe os valores. O exemplo demonstra como armazenar e recuperar o par de nome/valor (sem nome) padrão e o uso de `defaultValue` quando um par nome/valor não existe.  
  
 [!code-cpp[Microsoft.Win32.Registry.GetSet#1](~/samples/snippets/cpp/VS_Snippets_CLR/Microsoft.Win32.Registry.GetSet/CPP/source.cpp#1)]
 [!code-csharp[Microsoft.Win32.Registry.GetSet#1](~/samples/snippets/csharp/VS_Snippets_CLR/Microsoft.Win32.Registry.GetSet/CS/source.cs#1)]
 [!code-vb[Microsoft.Win32.Registry.GetSet#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Microsoft.Win32.Registry.GetSet/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:Microsoft.Win32.RegistryHive" />
    <altmember cref="T:Microsoft.Win32.RegistryKey" />
  </Docs>
  <Members>
    <Member MemberName="ClassesRoot">
      <MemberSignature Language="C#" Value="public static readonly Microsoft.Win32.RegistryKey ClassesRoot;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class Microsoft.Win32.RegistryKey ClassesRoot" />
      <MemberSignature Language="DocId" Value="F:Microsoft.Win32.Registry.ClassesRoot" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ClassesRoot As RegistryKey " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly Microsoft::Win32::RegistryKey ^ ClassesRoot;" />
      <MemberSignature Language="F#" Value=" staticval mutable ClassesRoot : Microsoft.Win32.RegistryKey" Usage="Microsoft.Win32.Registry.ClassesRoot" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.RegistryKey</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Define os tipos (ou classes) de documentos e as propriedades associadas a esses tipos. Este campo lê a chave base do Registro HKEY_CLASSES_ROOT do Windows.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Os aplicativos convencionais e os aplicativos OLE usam dados armazenados nessa chave. Essa chave também fornece compatibilidade com versões anteriores com o banco de dados de registro do Windows 3.1, armazenando informações de suporte do DDE e OLE. Visualizadores de arquivo e extensões de interface do usuário armazenam seus identificadores de classe OLE nessa chave, e os servidores de processamento são registrados nesta chave.  
  
   
  
## Examples  
 O exemplo a seguir demonstra como recuperar as subchaves dessa chave e imprime os nomes para a tela. Use o <xref:Microsoft.Win32.RegistryKey.OpenSubKey%2A> método para criar uma instância da subchave de interesse específica. Você pode usar outras operações em <xref:Microsoft.Win32.RegistryKey> para manipular essa chave.  
  
 [!code-cpp[Classic Registry.ClassesRoot Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Registry.ClassesRoot Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Registry.ClassesRoot Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Registry.ClassesRoot Example/CS/source.cs#1)]
 [!code-vb[Classic Registry.ClassesRoot Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Registry.ClassesRoot Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CurrentConfig">
      <MemberSignature Language="C#" Value="public static readonly Microsoft.Win32.RegistryKey CurrentConfig;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class Microsoft.Win32.RegistryKey CurrentConfig" />
      <MemberSignature Language="DocId" Value="F:Microsoft.Win32.Registry.CurrentConfig" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly CurrentConfig As RegistryKey " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly Microsoft::Win32::RegistryKey ^ CurrentConfig;" />
      <MemberSignature Language="F#" Value=" staticval mutable CurrentConfig : Microsoft.Win32.RegistryKey" Usage="Microsoft.Win32.Registry.CurrentConfig" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.RegistryKey</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Contém informações de configuração relacionadas ao hardware que não é específico do usuário. Este campo lê a chave base HKEY_CURRENT_CONFIG do Registro do Windows.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse membro é mapeado para uma subchave em <xref:Microsoft.Win32.Registry.LocalMachine>.  
  
 Um exemplo de como usar esse membro é um aplicativo que armazena um nome de servidor diferente para seus dados, dependendo se o sistema estiver conectado a uma rede.  
  
   
  
## Examples  
 O exemplo a seguir demonstra como recuperar as subchaves dessa chave e imprime os nomes para a tela. Use o <xref:Microsoft.Win32.RegistryKey.OpenSubKey%2A> método para criar uma instância da subchave de interesse específica. Você pode usar outras operações em <xref:Microsoft.Win32.RegistryKey> para manipular essa chave.  
  
 [!code-cpp[Classic Registry.CurrentConfig Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Registry.CurrentConfig Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Registry.CurrentConfig Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Registry.CurrentConfig Example/CS/source.cs#1)]
 [!code-vb[Classic Registry.CurrentConfig Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Registry.CurrentConfig Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CurrentUser">
      <MemberSignature Language="C#" Value="public static readonly Microsoft.Win32.RegistryKey CurrentUser;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class Microsoft.Win32.RegistryKey CurrentUser" />
      <MemberSignature Language="DocId" Value="F:Microsoft.Win32.Registry.CurrentUser" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly CurrentUser As RegistryKey " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly Microsoft::Win32::RegistryKey ^ CurrentUser;" />
      <MemberSignature Language="F#" Value=" staticval mutable CurrentUser : Microsoft.Win32.RegistryKey" Usage="Microsoft.Win32.Registry.CurrentUser" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.RegistryKey</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Contém informações sobre as preferências do usuário atual. Este campo lê a chave base de Registro HKEY_CLASSES_ROOT do Windows</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 As informações armazenadas nesta chave incluem as configurações de variáveis de ambiente e dados sobre grupos de programas, cores, impressoras, conexões de rede e as preferências de aplicativo. Essa chave torna mais fácil estabelecer as configurações do usuário atual. Nessa chave, fornecedores de software armazenam as preferências específicas do usuário atual a ser usado dentro de seus aplicativos. Microsoft, por exemplo, cria a chave HKEY_CURRENT_USER\Software\Microsoft. para seus aplicativos para usar com cada aplicativo criando sua própria subchave sob a chave da Microsoft.  
  
   
  
## Examples  
 O exemplo a seguir demonstra como recuperar as subchaves dessa chave e imprime os nomes para a tela. Use o <xref:Microsoft.Win32.RegistryKey.OpenSubKey%2A> método para criar uma instância da subchave de interesse específica. Você pode usar outras operações em <xref:Microsoft.Win32.RegistryKey> para manipular essa chave.  
  
 [!code-cpp[Classic Registry.CurrentUser Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Registry.CurrentUser Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Registry.CurrentUser Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Registry.CurrentUser Example/CS/source.cs#1)]
 [!code-vb[Classic Registry.CurrentUser Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Registry.CurrentUser Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DynData">
      <MemberSignature Language="C#" Value="public static readonly Microsoft.Win32.RegistryKey DynData;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class Microsoft.Win32.RegistryKey DynData" />
      <MemberSignature Language="DocId" Value="F:Microsoft.Win32.Registry.DynData" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly DynData As RegistryKey " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly Microsoft::Win32::RegistryKey ^ DynData;" />
      <MemberSignature Language="F#" Value=" staticval mutable DynData : Microsoft.Win32.RegistryKey" Usage="Microsoft.Win32.Registry.DynData" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use PerformanceData instead")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("The DynData registry key only works on Win9x, which is no longer supported by the CLR.  On NT-based operating systems, use the PerformanceData registry key instead.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.RegistryKey</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Contém dados dinâmicos do Registro. Este campo lê a chave base HKEY_DYN_DATA do Registro do Windows.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O registro do Windows 98/Windows Me dá suporte a dados estáticos (que são armazenados em disco no registro) e dados dinâmicos (que é alterada com frequência, como estatísticas de desempenho). Essa área de dados dinâmicos é o mecanismo que permite que os Drivers de dispositivos virtuais (VxDs) para fornecer dados em tempo real para aplicativos Win32 que podem ser executados remotamente, assim como localmente. Ele também permite que o monitor do sistema fornecer estatísticas de desempenho no Windows 98/Windows Me sistemas remotos.  
  
 VxDs não está limitados aos dados de desempenho. Eles podem fornecer quaisquer dados que ele deseja transmitir de anel 0 para o anel 3 com eficiência sem monopolize a CPU. O registro dá suporte a dados dinâmicos ao armazenar um ponteiro para uma função que retorna um valor (ou muitos valores). Quando valores de consultas de chamada de um registro associado com uma chave dinâmica, que a função é chamada para retornar o valor desejado ou valores.  
  
> [!NOTE]
>  As chaves dinâmicas foram introduzidas no Microsoft Windows 95 para lidar com dados dinâmicos do registro. Eles são suportados apenas no Windows 98/Windows Me.  
  
   
  
## Examples  
 O exemplo a seguir demonstra como recuperar as subchaves dessa chave e imprime os nomes para a tela. Use o <xref:Microsoft.Win32.RegistryKey.OpenSubKey%2A> método para criar uma instância da subchave de interesse específica. Você pode usar outras operações em <xref:Microsoft.Win32.RegistryKey> para manipular essa chave. Observe que este exemplo não pode retornar nenhum resultado, uma vez que talvez não haja dados dinâmicos disponíveis, ou você pode não estar executando o Windows 98 / Me. Usando essa chave pode causar um erro em outros sistemas.  
  
 [!code-cpp[Classic Registry.DynData Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Registry.DynData Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Registry.DynData Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Registry.DynData Example/CS/source.cs#1)]
 [!code-vb[Classic Registry.DynData Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Registry.DynData Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">O sistema operacional não dá suporte a dados dinâmicos; ou seja, ele não é o Windows 98, Windows 98 Second Edition nem Windows Millennium Edition (Windows Me).</exception>
      </Docs>
    </Member>
    <Member MemberName="GetValue">
      <MemberSignature Language="C#" Value="public static object GetValue (string keyName, string valueName, object defaultValue);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object GetValue(string keyName, string valueName, object defaultValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Win32.Registry.GetValue(System.String,System.String,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetValue (keyName As String, valueName As String, defaultValue As Object) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ GetValue(System::String ^ keyName, System::String ^ valueName, System::Object ^ defaultValue);" />
      <MemberSignature Language="F#" Value="static member GetValue : string * string * obj -&gt; obj" Usage="Microsoft.Win32.Registry.GetValue (keyName, valueName, defaultValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="keyName" Type="System.String" />
        <Parameter Name="valueName" Type="System.String" />
        <Parameter Name="defaultValue" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="keyName">O caminho do Registro completo da chave, começando com uma raiz do Registro válida, como “HKEY_CURRENT_USER”.</param>
        <param name="valueName">O nome do par nome-valor.</param>
        <param name="defaultValue">O valor a ser retornado se <c>valueName</c> não existir.</param>
        <summary>Recupera o valor associado ao nome especificado, na chave do Registro especificada. Se o nome não for encontrado na chave especificada, retornará um valor padrão que você fornecer, ou <see langword="null" /> se a chave especificada não existir.</summary>
        <returns>
          <see langword="null" /> se a subchave especificada por <paramref name="keyName" /> não existir; caso contrário, o valor associado a <paramref name="valueName" /> ou <paramref name="defaultValue" /> se <paramref name="valueName" /> não for encontrado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A cadeia de caracteres `valueName` não diferencia maiusculas de minúsculas.  
  
> [!NOTE]
>  Uma chave do registro pode conter um valor que não está associado com qualquer nome. Quando esse valor sem nome é exibido no Editor do Registro, a cadeia de caracteres "(Default)" é exibida em vez de um nome. Para recuperar esse valor sem nome, especifique `null` ou a cadeia de caracteres vazia ("") para `valuName`.  
  
 Nomes de raiz válido são HKEY_CURRENT_USER, HKEY_LOCAL_MACHINE, HKEY_CLASSES_ROOT, HKEY_USERS, HKEY_PERFORMANCE_DATA, HKEY_CURRENT_CONFIG e HKEY_DYN_DATA. Por exemplo, no Visual Basic, a cadeia de caracteres "HKEY_CURRENT_USER\MyTestKey" acessa pares chave/valor para a subchave "MyTestKey" na raiz HKEY_CURRENT_USER.  
  
 Quando o <xref:Microsoft.Win32.RegistryKey.GetValue%2A> método recupera os valores de cadeia de caracteres expansível (<xref:Microsoft.Win32.RegistryValueKind.ExpandString?displayProperty=nameWithType>), ele expande as cadeias de caracteres de ambiente usando dados do ambiente local. Se um valor que contém expansíveis referências a variáveis de ambiente é armazenado como uma cadeia de caracteres (<xref:Microsoft.Win32.RegistryValueKind.String?displayProperty=nameWithType>), em vez de como uma cadeia de caracteres expansível (<xref:Microsoft.Win32.RegistryValueKind.ExpandString?displayProperty=nameWithType>), <xref:Microsoft.Win32.RegistryKey.GetValue%2A> não expandi-lo. Você pode expandir uma cadeia de caracteres após recuperação chamando o <xref:System.Environment.ExpandEnvironmentVariables%2A?displayProperty=nameWithType> método.  
  
> [!NOTE]
>  A maneira recomendada para recuperar dados de HKEY_PERFORMANCE_DATA é usar o <xref:System.Diagnostics.PerformanceCounter> classe em vez de <xref:Microsoft.Win32.RegistryKey.GetValue%2A?displayProperty=nameWithType> método.  
  
 O <xref:Microsoft.Win32.Registry.GetValue%2A> e <xref:Microsoft.Win32.Registry.SetValue%2A> métodos abrem e chaves de registro fechar cada vez que eles são usados, para que eles não executam bem como os métodos do <xref:Microsoft.Win32.RegistryKey> se você acessar um grande número de valores de classe.  
  
 <xref:Microsoft.Win32.RegistryKey> também fornece métodos que permitem que você adicione uma lista de controle de acesso (ACL) para uma chave do registro, para testar o tipo de dados de um valor antes de recuperá-lo e excluir chaves.  
  
   
  
## Examples  
 O exemplo de código a seguir armazena valores de diversos tipos de dados em uma chave de exemplo, a criação da chave conforme ele faz isso e, em seguida, recupera e exibe os valores. O exemplo demonstra como armazenar e recuperar o par de nome/valor (sem nome) padrão e o uso de `defaultValue` quando um par nome/valor não existe.  
  
 [!code-cpp[Microsoft.Win32.Registry.GetSet#1](~/samples/snippets/cpp/VS_Snippets_CLR/Microsoft.Win32.Registry.GetSet/CPP/source.cpp#1)]
 [!code-csharp[Microsoft.Win32.Registry.GetSet#1](~/samples/snippets/csharp/VS_Snippets_CLR/Microsoft.Win32.Registry.GetSet/CS/source.cs#1)]
 [!code-vb[Microsoft.Win32.Registry.GetSet#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Microsoft.Win32.Registry.GetSet/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">O usuário não tem as permissões necessárias a serem lidas na chave do Registro.</exception>
        <exception cref="T:System.IO.IOException">O <see cref="T:Microsoft.Win32.RegistryKey" /> que contém o valor especificado foi marcado para exclusão.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="keyName" /> não começa com uma raiz do Registro válida.</exception>
        <permission cref="T:System.Security.Permissions.RegistryPermission">para ler do Registro. Enumeração associada: <see cref="F:System.Security.Permissions.RegistryPermissionAccess.Read" /></permission>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">para ler uma chave do registro do tipo REG_EXPAND_SZ. Enumeração associada: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></permission>
      </Docs>
    </Member>
    <Member MemberName="LocalMachine">
      <MemberSignature Language="C#" Value="public static readonly Microsoft.Win32.RegistryKey LocalMachine;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class Microsoft.Win32.RegistryKey LocalMachine" />
      <MemberSignature Language="DocId" Value="F:Microsoft.Win32.Registry.LocalMachine" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly LocalMachine As RegistryKey " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly Microsoft::Win32::RegistryKey ^ LocalMachine;" />
      <MemberSignature Language="F#" Value=" staticval mutable LocalMachine : Microsoft.Win32.RegistryKey" Usage="Microsoft.Win32.Registry.LocalMachine" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.RegistryKey</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Contém os dados de configuração para o computador local. Este campo lê a chave de base de Registro HKEY_LOCAL_MACHINE do Windows.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `LocalMachine` contém cinco chaves:  
  
 Hardware  
 Descreve o hardware físico no computador, da maneira que drivers de dispositivo usam esse hardware e mapeamentos e dados relacionados que vinculam os drivers do modo kernel com o código de modo de usuário. Todos os dados nessa chave é recriado cada vez que o sistema é iniciado. A subchave de descrição descreve o hardware do computador real. A subchave DeviceMap contém diversos dados em formatos específicos para classes específicas de drivers. A subchave ResourceMap descreve quais recursos de hardware de declaração de quais drivers de dispositivo. O programa de diagnóstico do Windows NT (Winmsdp.exe) pode relatar seu conteúdo em um formulário de fácil leitura.  
  
 SAM  
 O banco de dados de serviços de diretório de informações de segurança para contas de usuário e grupo e para os domínios no Windows 2000 Server (SAM é o gerente de conta de segurança, conhecido como o banco de dados de serviços de diretório).  
  
 Segurança  
 Contém a política de segurança local, como direitos de usuário específico. Essa chave é usada apenas pelo subsistema de segurança do Windows 2000.  
  
 Software  
 O banco de dados de software por computador. Esta chave contém dados sobre o software instalado no computador local, juntamente com vários itens de dados de configuração de diversos.  
  
 Sistema  
 Controla a inicialização do sistema, carregamento do driver de dispositivo, serviços do Windows 2000 e o comportamento do sistema operacional.  
  
 Por convenção, se houver dados semelhantes na <xref:Microsoft.Win32.Registry.CurrentUser> e, em <xref:Microsoft.Win32.Registry.LocalMachine>, os dados em <xref:Microsoft.Win32.Registry.CurrentUser> terá precedência. No entanto, valores nessa chave podem também estender (em vez de substituir) dados em Registry.LocalMachine. Além disso, alguns itens (como o driver de dispositivo Carregando entradas) não fazem sentidos se elas ocorrerem fora Registry.LocalMachine.  
  
   
  
## Examples  
 O exemplo a seguir demonstra como recuperar as subchaves dessa chave e imprime os nomes para a tela. Use o <xref:Microsoft.Win32.RegistryKey.OpenSubKey%2A> método para criar uma instância da subchave de interesse específica. Você pode usar outras operações em <xref:Microsoft.Win32.RegistryKey> para manipular essa chave.  
  
 [!code-cpp[Classic Registry.LocalMachine Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Registry.LocalMachine Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Registry.LocalMachine Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Registry.LocalMachine Example/CS/source.cs#1)]
 [!code-vb[Classic Registry.LocalMachine Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Registry.LocalMachine Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PerformanceData">
      <MemberSignature Language="C#" Value="public static readonly Microsoft.Win32.RegistryKey PerformanceData;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class Microsoft.Win32.RegistryKey PerformanceData" />
      <MemberSignature Language="DocId" Value="F:Microsoft.Win32.Registry.PerformanceData" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PerformanceData As RegistryKey " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly Microsoft::Win32::RegistryKey ^ PerformanceData;" />
      <MemberSignature Language="F#" Value=" staticval mutable PerformanceData : Microsoft.Win32.RegistryKey" Usage="Microsoft.Win32.Registry.PerformanceData" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.RegistryKey</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Contém informações de desempenho de componentes de software. Esse campo lê a chave base do Registro HKEY_PERFORMANCE_DATA do Windows.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cada componente de software cria chaves para seus objetos, contadores de quando ele é instalado e grava dados do contador durante sua execução. Você pode acessar esses dados, como você acessaria quaisquer outros dados de registro, usando o <xref:Microsoft.Win32.RegistryKey> funções.  
  
 Apesar de você usa o registro para coletar dados de desempenho, os dados não são armazenados no banco de dados do registro. Em vez disso, ao acessar o registro com essa chave faz com que o sistema coletar os dados dos gerenciadores de objeto apropriada do sistema.  
  
 Para obter dados de desempenho do sistema local, use o <xref:Microsoft.Win32.RegistryKey.GetValue%2A> método, com a chave Registry.PerformanceData. A primeira chamada abre a chave (não é necessário abrir a chave explicitamente pela primeira vez). No entanto, certifique-se de usar o <xref:Microsoft.Win32.RegistryKey.Close%2A> método para fechar o identificador para a chave quando tiver terminado de obtenção de dados de desempenho. O usuário não é possível instalar ou remover um componente de software, enquanto seus dados de desempenho estão em uso.  
  
 Para obter dados de desempenho de um sistema remoto, você deve usar o <xref:Microsoft.Win32.RegistryKey.OpenRemoteBaseKey%2A> método, com o nome do computador do sistema remoto e a chave de Registry.PerformanceData. Essa chamada recupera uma chave que representa os dados de desempenho do sistema remoto. Para recuperar os dados, chame <xref:Microsoft.Win32.RegistryKey.GetValue%2A> usando essa chave, em vez da chave Registry.PerformanceData.  
  
> [!NOTE]
>  No Windows Server 2003, um usuário pelo menos deve pertencer ao grupo de usuários de Monitor de desempenho para acessar subchaves dessa chave de base.  
  
   
  
## Examples  
 O exemplo a seguir demonstra como recuperar as subchaves dessa chave e imprime os nomes para a tela. Use o <xref:Microsoft.Win32.RegistryKey.OpenSubKey%2A> método para criar uma instância da subchave de interesse específica. Você pode usar outras operações em <xref:Microsoft.Win32.RegistryKey> para manipular essa chave. Observe que este exemplo geralmente não pode retornar nenhum resultado, já que não pode haver nenhum dado de desempenho.  
  
 [!code-cpp[Classic Registry.PerformanceData Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Registry.PerformanceData Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Registry.PerformanceData Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Registry.PerformanceData Example/CS/source.cs#1)]
 [!code-vb[Classic Registry.PerformanceData Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Registry.PerformanceData Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="SetValue">
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Define o valor de um par nome-valor em uma chave do Registro.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O exemplo de código a seguir armazena valores de diversos tipos de dados em uma chave de exemplo, a criação da chave conforme ele faz isso e, em seguida, recupera e exibe os valores. O exemplo demonstra como armazenar e recuperar o par de nome/valor (sem nome) padrão e o uso de `defaultValue` quando um par nome/valor não existe.  
  
 [!code-cpp[Microsoft.Win32.Registry.GetSet#1](~/samples/snippets/cpp/VS_Snippets_CLR/Microsoft.Win32.Registry.GetSet/CPP/source.cpp#1)]
 [!code-csharp[Microsoft.Win32.Registry.GetSet#1](~/samples/snippets/csharp/VS_Snippets_CLR/Microsoft.Win32.Registry.GetSet/CS/source.cs#1)]
 [!code-vb[Microsoft.Win32.Registry.GetSet#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Microsoft.Win32.Registry.GetSet/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="SetValue">
      <MemberSignature Language="C#" Value="public static void SetValue (string keyName, string valueName, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetValue(string keyName, string valueName, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Win32.Registry.SetValue(System.String,System.String,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetValue (keyName As String, valueName As String, value As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetValue(System::String ^ keyName, System::String ^ valueName, System::Object ^ value);" />
      <MemberSignature Language="F#" Value="static member SetValue : string * string * obj -&gt; unit" Usage="Microsoft.Win32.Registry.SetValue (keyName, valueName, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="keyName" Type="System.String" />
        <Parameter Name="valueName" Type="System.String" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="keyName">O caminho do Registro completo da chave, começando com uma raiz do Registro válida, como “HKEY_CURRENT_USER”.</param>
        <param name="valueName">O nome do par nome-valor.</param>
        <param name="value">O valor a ser armazenado.</param>
        <summary>Define o par nome-valor especificado na chave do Registro especificada. Se a chave especificada não existir, ela será criada.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Começando com o [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], o `valueName` parâmetro não é mais restrito a um máximo de 255 caracteres; no entanto, o `keyName` parâmetro continua com a restrição de 255 caracteres.  
  
 Como muitos valores podem ser armazenados em cada chave no registro, você deve usar o `valueName` parâmetro para especificar o valor específico que você deseja definir.  
  
> [!NOTE]
>  Uma chave do registro pode conter um valor que não está associado com qualquer nome. Quando esse valor sem nome é exibido no Editor do Registro, a cadeia de caracteres "(Default)" é exibida em vez de um nome. Para definir esse valor sem nome, especifique `null` ou a cadeia de caracteres vazia ("") para `valueName`.  
  
 Se `valueName` não existe na chave, ele é criado e o valor associado é definido como `value`.  
  
 Se `keyName` Especifica uma subchave que não existe, a subchave é criada na raiz especificada. Por exemplo, no Visual Basic, a cadeia de caracteres "HKEY_CURRENT_USER\MyTestKey" cria a subchave "MyTestKey" na raiz HKEY_CURRENT_USER. A cadeia de caracteres "HKEY_CURRENT_USER\MyTestKey\Key2\Key3" cria as subchaves aninhadas "MyTestKey", "MyTestKey\Key2" e "MyTestKey\Key2\Key3".  
  
 Nomes de raiz válido incluem HKEY_CURRENT_USER, HKEY_LOCAL_MACHINE, HKEY_CLASSES_ROOT, HKEY_USERS, HKEY_PERFORMANCE_DATA, HKEY_CURRENT_CONFIG e HKEY_DYN_DATA.  
  
> [!NOTE]
>  O <xref:Microsoft.Win32.Registry.SetValue%2A> método abre uma chave do registro, define o valor e fecha a chave toda vez que é chamado. Se você precisar modificar um grande número de valores, o <xref:Microsoft.Win32.RegistryKey.SetValue%2A?displayProperty=nameWithType> método pode oferecer melhor desempenho. O <xref:Microsoft.Win32.RegistryKey> classe também fornece métodos que permitem que você adicione uma lista de controle de acesso (ACL) para uma chave do registro, para testar o tipo de dados de um valor antes de recuperá-lo e excluir chaves.  
  
 Essa sobrecarga de <xref:Microsoft.Win32.Registry.SetValue%2A> armazena inteiros de 64 bits como cadeias de caracteres (<xref:Microsoft.Win32.RegistryValueKind.String?displayProperty=nameWithType>). Para armazenar números de 64 bits como <xref:Microsoft.Win32.RegistryValueKind.QWord?displayProperty=nameWithType> valores, use o <xref:Microsoft.Win32.Registry.SetValue%28System.String%2CSystem.String%2CSystem.Object%2CMicrosoft.Win32.RegistryValueKind%29> sobrecarga de método.  
  
 Essa sobrecarga de <xref:Microsoft.Win32.Registry.SetValue%2A> armazena todos os valores de cadeia de caracteres como <xref:Microsoft.Win32.RegistryValueKind.String?displayProperty=nameWithType> objetos, mesmo se eles contiverem expansíveis referências a variáveis de ambiente. Para salvar os valores de cadeia de caracteres expansíveis como cadeias de caracteres (<xref:Microsoft.Win32.RegistryValueKind.ExpandString?displayProperty=nameWithType>), use o <xref:Microsoft.Win32.Registry.SetValue%28System.String%2CSystem.String%2CSystem.Object%2CMicrosoft.Win32.RegistryValueKind%29> sobrecarga de método.  
  
 Essa sobrecarga é equivalente a chamar o <xref:Microsoft.Win32.Registry.SetValue%28System.String%2CSystem.String%2CSystem.Object%2CMicrosoft.Win32.RegistryValueKind%29> sobrecarga de método com <xref:Microsoft.Win32.RegistryValueKind.Unknown?displayProperty=nameWithType>.  
  
> [!NOTE]
>  No Windows 98 e Windows Millennium Edition (Windows Me), o registro não for Unicode e não todos os caracteres Unicode são válidos para todas as páginas de código. Um caractere Unicode inválido para a página de código atual é substituído por melhor correspondência disponíveis. Nenhuma exceção é lançada.  
  
   
  
## Examples  
 O exemplo de código a seguir armazena valores de diversos tipos de dados em uma chave de exemplo, a criação da chave conforme ele faz isso e, em seguida, recupera e exibe os valores. O exemplo demonstra como armazenar e recuperar o par de nome/valor (sem nome) padrão e o uso de `defaultValue` quando um par nome/valor não existe.  
  
 [!code-cpp[Microsoft.Win32.Registry.GetSet#1](~/samples/snippets/cpp/VS_Snippets_CLR/Microsoft.Win32.Registry.GetSet/CPP/source.cpp#1)]
 [!code-csharp[Microsoft.Win32.Registry.GetSet#1](~/samples/snippets/csharp/VS_Snippets_CLR/Microsoft.Win32.Registry.GetSet/CS/source.cs#1)]
 [!code-vb[Microsoft.Win32.Registry.GetSet#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Microsoft.Win32.Registry.GetSet/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="keyName" /> não começa com uma raiz do Registro válida.  
  
- ou - 
 <paramref name="keyName" /> é maior que o tamanho máximo permitido (255 caracteres).</exception>
        <exception cref="T:System.UnauthorizedAccessException">O <see cref="T:Microsoft.Win32.RegistryKey" /> é somente leitura e, portanto, não pode ser usado para gravação; por exemplo, é um nó de nível raiz.</exception>
        <exception cref="T:System.Security.SecurityException">O usuário não tem as permissões necessárias para criar ou modificar chaves do Registro.</exception>
        <permission cref="T:System.Security.Permissions.RegistryPermission">Para modificar a chave do registro especificado se ele existir, ou para criar a chave do registro se ele ainda não existir. Enumerações associadas: <see cref="F:System.Security.Permissions.RegistryPermissionAccess.Write" />, <see cref="F:System.Security.Permissions.RegistryPermissionAccess.Create" /></permission>
      </Docs>
    </Member>
    <Member MemberName="SetValue">
      <MemberSignature Language="C#" Value="public static void SetValue (string keyName, string valueName, object value, Microsoft.Win32.RegistryValueKind valueKind);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetValue(string keyName, string valueName, object value, valuetype Microsoft.Win32.RegistryValueKind valueKind) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Win32.Registry.SetValue(System.String,System.String,System.Object,Microsoft.Win32.RegistryValueKind)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetValue (keyName As String, valueName As String, value As Object, valueKind As RegistryValueKind)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetValue(System::String ^ keyName, System::String ^ valueName, System::Object ^ value, Microsoft::Win32::RegistryValueKind valueKind);" />
      <MemberSignature Language="F#" Value="static member SetValue : string * string * obj * Microsoft.Win32.RegistryValueKind -&gt; unit" Usage="Microsoft.Win32.Registry.SetValue (keyName, valueName, value, valueKind)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="keyName" Type="System.String" />
        <Parameter Name="valueName" Type="System.String" />
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="valueKind" Type="Microsoft.Win32.RegistryValueKind" />
      </Parameters>
      <Docs>
        <param name="keyName">O caminho do Registro completo da chave, começando com uma raiz do Registro válida, como “HKEY_CURRENT_USER”.</param>
        <param name="valueName">O nome do par nome-valor.</param>
        <param name="value">O valor a ser armazenado.</param>
        <param name="valueKind">O tipo de dados do Registro a ser usado ao armazenar os dados.</param>
        <summary>Define o par nome-valor na chave do Registro especificada, usando o tipo de dados do Registro especificado. Se a chave especificada não existir, ela será criada.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Começando com o [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], o `valueName` parâmetro não é mais restrito a um máximo de 255 caracteres; no entanto, o `keyName` parâmetro continua a ter a restrição de 255 caracteres.  
  
 Como muitos valores podem ser armazenados em cada chave no registro, você deve usar o `valueName` parâmetro para especificar o valor específico que você deseja definir.  
  
> [!NOTE]
>  Uma chave do registro pode conter um valor que não está associado com qualquer nome. Quando esse valor sem nome é exibido no Editor do Registro, a cadeia de caracteres "(Default)" é exibida em vez de um nome. Para definir esse valor sem nome, especifique `null` ou a cadeia de caracteres vazia ("") para `valueName`.  
  
 Se `valueName` não existe na chave, ele é criado e o valor associado é definido como `value`.  
  
 Se `keyName` Especifica uma subchave que não existe, a subchave é criada na raiz especificada. Por exemplo, no Visual Basic, a cadeia de caracteres "HKEY_CURRENT_USER\MyTestKey" cria a subchave "MyTestKey" na raiz HKEY_CURRENT_USER. A cadeia de caracteres "HKEY_CURRENT_USER\MyTestKey\Key2\Key3" cria as subchaves aninhadas "MyTestKey", "MyTestKey\Key2" e "MyTestKey\Key2\Key3".  
  
 Nomes de raiz válido incluem HKEY_CURRENT_USER, HKEY_LOCAL_MACHINE, HKEY_CLASSES_ROOT, HKEY_USERS, HKEY_PERFORMANCE_DATA, HKEY_CURRENT_CONFIG e HKEY_DYN_DATA.  
  
> [!NOTE]
>  O <xref:Microsoft.Win32.Registry.SetValue%2A> método abre uma chave do registro, define o valor e fecha a chave toda vez que é chamado. Se você precisar modificar um grande número de valores, o <xref:Microsoft.Win32.RegistryKey.SetValue%2A?displayProperty=nameWithType> método pode oferecer melhor desempenho. O <xref:Microsoft.Win32.RegistryKey> classe também fornece métodos que permitem que você adicione uma lista de controle de acesso (ACL) para uma chave do registro, para testar o tipo de dados de um valor antes de recuperá-lo e excluir chaves.  
  
 Se o tipo de especificado `value` não corresponde ao especificado `valueKind`, e os dados não podem ser convertido, <xref:System.ArgumentException> é lançada. Por exemplo, você pode armazenar um <xref:System.Int64?displayProperty=nameWithType> como um <xref:Microsoft.Win32.RegistryValueKind.DWord?displayProperty=nameWithType>, mas apenas se seu valor é menor que o valor máximo de um <xref:System.Int32?displayProperty=nameWithType>. Não é possível armazenar um valor de cadeia de caracteres única como um <xref:Microsoft.Win32.RegistryValueKind.MultiString?displayProperty=nameWithType>.  
  
> [!NOTE]
>  Se valores boxed são passados para <xref:Microsoft.Win32.RegistryValueKind.DWord?displayProperty=nameWithType> ou <xref:Microsoft.Win32.RegistryValueKind.QWord?displayProperty=nameWithType>, a conversão é feita usando a cultura invariável.  
  
> [!NOTE]
>  No Windows 98 e Windows Millennium Edition (Windows Me), o registro não for Unicode e não todos os caracteres Unicode são válidos para todas as páginas de código. Um caractere Unicode inválido para a página de código atual é substituído por melhor correspondência disponíveis. Nenhuma exceção é lançada.  
  
   
  
## Examples  
 O exemplo de código a seguir armazena valores de diversos tipos de dados em uma chave de exemplo, a criação da chave conforme ele faz isso e, em seguida, recupera e exibe os valores. O exemplo demonstra como armazenar e recuperar o par de nome/valor (sem nome) padrão e o uso de `defaultValue` quando um par nome/valor não existe.  
  
 [!code-cpp[Microsoft.Win32.Registry.GetSet#1](~/samples/snippets/cpp/VS_Snippets_CLR/Microsoft.Win32.Registry.GetSet/CPP/source.cpp#1)]
 [!code-csharp[Microsoft.Win32.Registry.GetSet#1](~/samples/snippets/csharp/VS_Snippets_CLR/Microsoft.Win32.Registry.GetSet/CS/source.cs#1)]
 [!code-vb[Microsoft.Win32.Registry.GetSet#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Microsoft.Win32.Registry.GetSet/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="keyName" /> não começa com uma raiz do Registro válida.  
  
- ou - 
 <paramref name="keyName" /> é maior que o tamanho máximo permitido (255 caracteres).  
  
- ou - 
O tipo de <paramref name="value" /> não correspondia ao tipo de dados do Registro especificado pelo <paramref name="valueKind" /> e, portanto, não foi possível converter os dados corretamente.</exception>
        <exception cref="T:System.UnauthorizedAccessException">O <see cref="T:Microsoft.Win32.RegistryKey" /> é somente leitura e, portanto, não pode ser usado para gravação; por exemplo, ele é um nó de nível raiz, ou a chave não foi aberta com acesso de gravação.</exception>
        <exception cref="T:System.Security.SecurityException">O usuário não tem as permissões necessárias para criar ou modificar chaves do Registro.</exception>
        <permission cref="T:System.Security.Permissions.RegistryPermission">Para modificar a chave do registro especificado se ele existir, ou para criar a chave do registro se ele ainda não existir. Enumerações associadas: <see cref="F:System.Security.Permissions.RegistryPermissionAccess.Write" />, <see cref="F:System.Security.Permissions.RegistryPermissionAccess.Create" /></permission>
      </Docs>
    </Member>
    <Member MemberName="Users">
      <MemberSignature Language="C#" Value="public static readonly Microsoft.Win32.RegistryKey Users;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class Microsoft.Win32.RegistryKey Users" />
      <MemberSignature Language="DocId" Value="F:Microsoft.Win32.Registry.Users" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Users As RegistryKey " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly Microsoft::Win32::RegistryKey ^ Users;" />
      <MemberSignature Language="F#" Value=" staticval mutable Users : Microsoft.Win32.RegistryKey" Usage="Microsoft.Win32.Registry.Users" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.RegistryKey</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Contém informações sobre a configuração de usuário padrão. Este campo lê a chave base do Registro do Windows HKEY_USERS.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esta chave contém um branch para cada usuário do computador. A configuração padrão é fornecida para novos usuários no computador local e para o usuário atual do padrão se o usuário não tiver alterado as preferências. Porque o Windows 98 / ME também dá suporte a Registry.Users, os aplicativos podem acessar as informações específicas do usuário da mesma forma que eles fazem no Windows 2000. Informações de cada usuário são armazenadas em um arquivo separado, que pode ser armazenado localmente ou em um servidor de rede. Windows 98 / ME pode copiar esse arquivo para o sistema do usuário atual para que as configurações podem mover de um computador para outro com o usuário.  
  
   
  
## Examples  
 O exemplo a seguir demonstra como recuperar as subchaves dessa chave e imprime os nomes para a tela. Use o <xref:Microsoft.Win32.RegistryKey.OpenSubKey%2A> método para criar uma instância da subchave de interesse específica. Você pode usar outras operações em <xref:Microsoft.Win32.RegistryKey> para manipular essa chave.  
  
 [!code-cpp[Classic Registry.Users Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Registry.Users Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Registry.Users Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Registry.Users Example/CS/source.cs#1)]
 [!code-vb[Classic Registry.Users Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Registry.Users Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>