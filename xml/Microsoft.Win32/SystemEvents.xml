<Type Name="SystemEvents" FullName="Microsoft.Win32.SystemEvents">
  <Metadata><Meta Name="ms.openlocfilehash" Value="747b741b14ca1c1c4215b08c1bcd371740cad132" /><Meta Name="ms.sourcegitcommit" Value="d40b35262cbc997b79bf76da3a39ccf59b738efc" /><Meta Name="ms.translationtype" Value="HT" /><Meta Name="ms.contentlocale" Value="pt-BR" /><Meta Name="ms.lasthandoff" Value="12/05/2018" /><Meta Name="ms.locfileid" Value="52911617" /></Metadata><TypeSignature Language="C#" Value="public sealed class SystemEvents" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit SystemEvents extends System.Object" />
  <TypeSignature Language="DocId" Value="T:Microsoft.Win32.SystemEvents" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class SystemEvents" />
  <TypeSignature Language="C++ CLI" Value="public ref class SystemEvents sealed" />
  <TypeSignature Language="F#" Value="type SystemEvents = class" />
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>Microsoft.Win32.SystemEvents</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Fornece acesso às notificações de eventos do sistema. Essa classe não pode ser herdada.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:Microsoft.Win32.SystemEvents> classe fornece a capacidade de responder a tipos específicos de eventos do sistema.  
  
 Quando ocorre um evento de sistema, quaisquer delegados anexados ao evento que são chamados usando o thread que monitora eventos do sistema. Portanto, você deve fazer todas as chamadas de seu thread-safe de manipuladores de eventos. Se você precisar chamar um evento do sistema que não é exposto como um membro dessa classe, você pode usar o <xref:Microsoft.Win32.SystemEvents.InvokeOnEventsThread%2A> método.  
  
> [!CAUTION]
>  Não executa processamento demorado no thread que gera um manipulador de eventos do sistema, porque isso poderá impedir que outros aplicativos funcionem.  
  
> [!NOTE]
>  Alguns eventos do sistema não podem ser disparados em [!INCLUDE[windowsver](~/includes/windowsver-md.md)]. Certifique-se de verificar se seu aplicativo funciona conforme o esperado em [!INCLUDE[windowsver](~/includes/windowsver-md.md)].  
  
   
  
## Examples  
 Esta seção contém dois exemplos. O primeiro exemplo mostra como usar eventos do sistema em um aplicativo comum, e o segundo exemplo mostra como usar eventos do sistema em um serviço do Windows.  
  
 **Exemplo 1**  
  
 O exemplo de código a seguir registra o interesse em alguns eventos do sistema e, em seguida, aguarda qualquer um desses eventos ocorrer. A saída mostrada ocorre se o usuário alterar a resolução de vídeo.  
  
 [!code-cpp[SystemEvents#1](~/samples/snippets/cpp/VS_Snippets_Winforms/SystemEvents/cpp/SystemEvents.cpp#1)]
 [!code-csharp[SystemEvents#1](~/samples/snippets/csharp/VS_Snippets_Winforms/SystemEvents/CS/SystemEvents.cs#1)]
 [!code-vb[SystemEvents#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/SystemEvents/VB/SystemEvents.vb#1)]  
  
 **Exemplo 2**  
  
 O exemplo de código a seguir demonstra um serviço do Windows muito simples que lida com o <xref:Microsoft.Win32.SystemEvents.TimeChanged> e <xref:Microsoft.Win32.SystemEvents.UserPreferenceChanged> eventos. O exemplo inclui um serviço nomeado `SimpleService`, um formulário chamado `HiddenForm`e um instalador. O formulário fornece o loop de mensagem que é exigido pelo eventos do sistema.  
  
> [!NOTE]
>  Os serviços não têm loops de mensagem, a menos que eles têm permissão para interagir com a área de trabalho. Se o loop de mensagem não é fornecido por um formulário oculto, como neste exemplo, o serviço deve ser executado sob a conta sistema local e intervenção manual é necessária para habilitar a interação com a área de trabalho. Ou seja, o administrador deve verificar manualmente os **permitir que o serviço interaja com a área de trabalho** caixa de seleção a **fazer logon** guia da caixa de diálogo de propriedades do serviço. Nesse caso, um loop de mensagem é fornecido automaticamente. Essa opção está disponível somente quando o serviço for executado sob a conta sistema local. Interação com a área de trabalho não pode ser habilitada por meio de programação.  
  
 O serviço neste exemplo inicia um thread que executa uma instância de `HiddenForm`. Os eventos são conectados e manipulados no formulário. Os eventos devem ser vinculados no evento load do formulário, para certificar-se de que o formulário seja completamente carregado pela primeira vez; Caso contrário, os eventos não serão gerados.  
  
> [!NOTE]
>  O exemplo fornece todo o código necessário, incluindo o código de inicialização do formulário normalmente gerado pelo designer do Visual Studio. Se você estiver desenvolvendo seu serviço no Visual Studio, você pode omitir a segunda classe parcial e usar o **propriedades** janela para definir a altura e largura do formulário oculto para zero, o estilo de borda para <xref:System.Windows.Forms.FormBorderStyle.None?displayProperty=nameWithType>e o estado da janela <xref:System.Windows.Forms.FormWindowState.Minimized?displayProperty=nameWithType>.  
  
 Para executar o exemplo:  
  
1.  Compile o código da linha de comando. O nome que você usa para o arquivo de origem não é importante.  
  
2.  Instalar o serviço de linha de comando usando o [Installutil.exe (ferramenta de instalação)](~/docs/framework/tools/installutil-exe-installer-tool.md) utilitário. Por exemplo, `InstallUtil example.exe` se o nome do arquivo de origem é `example.cs` ou `example.vb`. Você deve ser um administrador para instalar o serviço.  
  
3.  Use o console de serviços para iniciar o serviço.  
  
4.  Alterar a hora do sistema ou alterar as preferências do usuário, como as propriedades de mouse.  
  
5.  Exibir as mensagens na **aplicativo** categoria do Visualizador de eventos.  
  
6.  Use o console de serviços para interromper o serviço.  
  
7.  Desinstalar o serviço da linha de comando usando o `/u` opção. Por exemplo, `InstallUtil /u example.exe`.  
  
 [!code-csharp[ManagedWindowsService#1](~/samples/snippets/csharp/VS_Snippets_CLR/ManagedWindowsService/cs/source.cs#1)]
 [!code-vb[ManagedWindowsService#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ManagedWindowsService/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <permission cref="T:System.Security.NamedPermissionSet">Para obter acesso completo aos recursos do sistema. Valores de demanda: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />. Estado associado:</permission>
    <altmember cref="T:Microsoft.Win32.PowerModeChangedEventHandler" />
    <altmember cref="T:Microsoft.Win32.SessionEndedEventHandler" />
    <altmember cref="T:Microsoft.Win32.SessionEndingEventHandler" />
    <altmember cref="T:Microsoft.Win32.SessionSwitchEventHandler" />
    <altmember cref="T:Microsoft.Win32.TimerElapsedEventHandler" />
    <altmember cref="T:Microsoft.Win32.UserPreferenceChangedEventHandler" />
    <altmember cref="T:Microsoft.Win32.UserPreferenceChangingEventHandler" />
  </Docs>
  <Members>
    <Member MemberName="CreateTimer">
      <MemberSignature Language="C#" Value="public static IntPtr CreateTimer (int interval);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int CreateTimer(int32 interval) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Win32.SystemEvents.CreateTimer(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateTimer (interval As Integer) As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static IntPtr CreateTimer(int interval);" />
      <MemberSignature Language="F#" Value="static member CreateTimer : int -&gt; nativeint" Usage="Microsoft.Win32.SystemEvents.CreateTimer interval" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.SystemEvents</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="interval" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="interval">Especifica o intervalo entre as notificações de temporizador, em milissegundos.</param>
        <summary>Cria um novo temporizador de janela associado à janela de eventos do sistema.</summary>
        <returns>A ID do novo temporizador.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException">O intervalo é menor ou igual a zero.</exception>
        <exception cref="T:System.InvalidOperationException">Não há suporte para notificações de eventos do sistema no contexto atual. Os processos do servidor, por exemplo, podem não dar suporte a notificações de eventos globais do sistema.</exception>
        <exception cref="T:System.Runtime.InteropServices.ExternalException">A tentativa de criar um thread de janela de eventos do sistema não foi bem-sucedida ou a tentativa de criar o timer não teve êxito.</exception>
      </Docs>
    </Member>
    <Member MemberName="DisplaySettingsChanged">
      <MemberSignature Language="C#" Value="public static event EventHandler DisplaySettingsChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler DisplaySettingsChanged" />
      <MemberSignature Language="DocId" Value="E:Microsoft.Win32.SystemEvents.DisplaySettingsChanged" />
      <MemberSignature Language="VB.NET" Value="Public Shared Custom Event DisplaySettingsChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static event EventHandler ^ DisplaySettingsChanged;" />
      <MemberSignature Language="F#" Value="member this.DisplaySettingsChanged : EventHandler " Usage="member this.DisplaySettingsChanged : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.SystemEvents</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ocorre quando o usuário altera as configurações de exibição.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!CAUTION]
>  Como esse é um evento estático, você deve desanexar seus manipuladores de eventos quando seu aplicativo é descartado ou o resultado serão vazamentos de memória.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como monitorar o <xref:Microsoft.Win32.SystemEvents.DisplaySettingsChanged> eventos. Este exemplo de código é parte de um exemplo maior fornecido para o <xref:Microsoft.Win32.SystemEvents> classe.  
  
 [!code-cpp[SystemEvents#2](~/samples/snippets/cpp/VS_Snippets_Winforms/SystemEvents/cpp/SystemEvents.cpp#2)]
 [!code-csharp[SystemEvents#2](~/samples/snippets/csharp/VS_Snippets_Winforms/SystemEvents/CS/SystemEvents.cs#2)]
 [!code-vb[SystemEvents#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/SystemEvents/VB/SystemEvents.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Não há suporte para notificações de eventos do sistema no contexto atual. Os processos do servidor, por exemplo, podem não dar suporte a notificações de eventos globais do sistema.</exception>
        <exception cref="T:System.Runtime.InteropServices.ExternalException">A tentativa de criar um thread de janela de eventos do sistema não foi bem-sucedida.</exception>
        <altmember cref="E:Microsoft.Win32.SystemEvents.DisplaySettingsChanging" />
      </Docs>
    </Member>
    <Member MemberName="DisplaySettingsChanging">
      <MemberSignature Language="C#" Value="public static event EventHandler DisplaySettingsChanging;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler DisplaySettingsChanging" />
      <MemberSignature Language="DocId" Value="E:Microsoft.Win32.SystemEvents.DisplaySettingsChanging" />
      <MemberSignature Language="VB.NET" Value="Public Shared Custom Event DisplaySettingsChanging As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static event EventHandler ^ DisplaySettingsChanging;" />
      <MemberSignature Language="F#" Value="member this.DisplaySettingsChanging : EventHandler " Usage="member this.DisplaySettingsChanging : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.SystemEvents</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.MonoTODO("Currently does nothing on Mono")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ocorre quando as configurações de exibição estão sendo alteradas.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!CAUTION]
>  Como esse é um evento estático, você deve desanexar seus manipuladores de eventos quando seu aplicativo é descartado ou o resultado serão vazamentos de memória.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Não há suporte para notificações de eventos do sistema no contexto atual. Os processos do servidor, por exemplo, podem não dar suporte a notificações de eventos globais do sistema.</exception>
        <exception cref="T:System.Runtime.InteropServices.ExternalException">A tentativa de criar um thread de janela de eventos do sistema não foi bem-sucedida.</exception>
        <altmember cref="E:Microsoft.Win32.SystemEvents.DisplaySettingsChanged" />
      </Docs>
    </Member>
    <Member MemberName="EventsThreadShutdown">
      <MemberSignature Language="C#" Value="public static event EventHandler EventsThreadShutdown;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler EventsThreadShutdown" />
      <MemberSignature Language="DocId" Value="E:Microsoft.Win32.SystemEvents.EventsThreadShutdown" />
      <MemberSignature Language="VB.NET" Value="Public Shared Custom Event EventsThreadShutdown As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static event EventHandler ^ EventsThreadShutdown;" />
      <MemberSignature Language="F#" Value="member this.EventsThreadShutdown : EventHandler " Usage="member this.EventsThreadShutdown : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.SystemEvents</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.MonoTODO("Currently does nothing on Mono")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ocorre antes de o thread que escuta eventos do sistema é encerrado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse evento é gerado como o thread que escuta eventos do sistema está prestes a ser encerrado. Representantes de eventos do sistema são invocados usando o thread que escuta eventos do sistema.  
  
> [!CAUTION]
>  Como esse é um evento estático, você deve desanexar seus manipuladores de eventos quando seu aplicativo é descartado ou o resultado serão vazamentos de memória.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Não há suporte para notificações de eventos do sistema no contexto atual. Os processos do servidor, por exemplo, podem não dar suporte a notificações de eventos globais do sistema.</exception>
        <exception cref="T:System.Runtime.InteropServices.ExternalException">A tentativa de criar um thread de janela de eventos do sistema não foi bem-sucedida.</exception>
      </Docs>
    </Member>
    <Member MemberName="InstalledFontsChanged">
      <MemberSignature Language="C#" Value="public static event EventHandler InstalledFontsChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler InstalledFontsChanged" />
      <MemberSignature Language="DocId" Value="E:Microsoft.Win32.SystemEvents.InstalledFontsChanged" />
      <MemberSignature Language="VB.NET" Value="Public Shared Custom Event InstalledFontsChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static event EventHandler ^ InstalledFontsChanged;" />
      <MemberSignature Language="F#" Value="member this.InstalledFontsChanged : EventHandler " Usage="member this.InstalledFontsChanged : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.SystemEvents</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.MonoTODO("Currently does nothing on Mono")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ocorre quando o usuário adiciona ou remove fontes do sistema.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!CAUTION]
>  Como esse é um evento estático, você deve desanexar seus manipuladores de eventos quando seu aplicativo é descartado ou o resultado serão vazamentos de memória.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Não há suporte para notificações de eventos do sistema no contexto atual. Os processos do servidor, por exemplo, podem não dar suporte a notificações de eventos globais do sistema.</exception>
        <exception cref="T:System.Runtime.InteropServices.ExternalException">A tentativa de criar um thread de janela de eventos do sistema não foi bem-sucedida.</exception>
      </Docs>
    </Member>
    <Member MemberName="InvokeOnEventsThread">
      <MemberSignature Language="C#" Value="public static void InvokeOnEventsThread (Delegate method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void InvokeOnEventsThread(class System.Delegate method) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Win32.SystemEvents.InvokeOnEventsThread(System.Delegate)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub InvokeOnEventsThread (method As Delegate)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void InvokeOnEventsThread(Delegate ^ method);" />
      <MemberSignature Language="F#" Value="static member InvokeOnEventsThread : Delegate -&gt; unit" Usage="Microsoft.Win32.SystemEvents.InvokeOnEventsThread method" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.SystemEvents</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="method" Type="System.Delegate" />
      </Parameters>
      <Docs>
        <param name="method">Um delegado para invocar usando o thread que escuta eventos do sistema.</param>
        <summary>Invoca o delegado especificado usando o thread que escuta eventos do sistema.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Você pode usar esse método sempre que você precisa manipular um evento de sistema que não esteja exposto caso contrário, o <xref:Microsoft.Win32.SystemEvents> classe.  
  
 Quando você chama esse método, o delegado especificado será invocado pelo thread que seu aplicativo está usando para processar eventos do sistema.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Não há suporte para notificações de eventos do sistema no contexto atual. Os processos do servidor, por exemplo, podem não dar suporte a notificações de eventos globais do sistema.</exception>
        <exception cref="T:System.Runtime.InteropServices.ExternalException">A tentativa de criar um thread de janela de eventos do sistema não foi bem-sucedida.</exception>
      </Docs>
    </Member>
    <Member MemberName="KillTimer">
      <MemberSignature Language="C#" Value="public static void KillTimer (IntPtr timerId);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void KillTimer(native int timerId) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Win32.SystemEvents.KillTimer(System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub KillTimer (timerId As IntPtr)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void KillTimer(IntPtr timerId);" />
      <MemberSignature Language="F#" Value="static member KillTimer : nativeint -&gt; unit" Usage="Microsoft.Win32.SystemEvents.KillTimer timerId" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.SystemEvents</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timerId" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="timerId">A ID do temporizador a encerrar.</param>
        <summary>Encerra o temporizador especificado pela ID determinada.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException">Não há suporte para notificações de eventos do sistema no contexto atual. Os processos do servidor, por exemplo, podem não dar suporte a notificações de eventos globais do sistema.</exception>
        <exception cref="T:System.Runtime.InteropServices.ExternalException">A tentativa de criar um thread de janela de eventos do sistema não foi bem-sucedida, ou a tentativa de encerrar o timer não teve êxito.</exception>
      </Docs>
    </Member>
    <Member MemberName="LowMemory">
      <MemberSignature Language="C#" Value="public static event EventHandler LowMemory;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler LowMemory" />
      <MemberSignature Language="DocId" Value="E:Microsoft.Win32.SystemEvents.LowMemory" />
      <MemberSignature Language="VB.NET" Value="Public Shared Custom Event LowMemory As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static event EventHandler ^ LowMemory;" />
      <MemberSignature Language="F#" Value="member this.LowMemory : EventHandler " Usage="member this.LowMemory : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.SystemEvents</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netcore-2.1;netframework-4.8;dotnet-plat-ext-2.1;netcore-2.2;dotnet-plat-ext-2.2">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netcore-2.1;netframework-4.8;dotnet-plat-ext-2.1;netcore-2.2;dotnet-plat-ext-2.2">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.MonoTODO("Currently does nothing on Mono")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.Obsolete("")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netcore-2.1;netframework-4.8;dotnet-plat-ext-2.1;netcore-2.2;dotnet-plat-ext-2.2">
          <AttributeName>System.Obsolete("This event has been deprecated. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ocorre quando o sistema está ficando sem memória RAM disponível.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse evento encapsula a mensagem WM_COMPACTING. Esta mensagem é enviada para todas as janelas de nível superior quando o sistema detectar mais de 12,5% de tempo do sistema durante um intervalo de 30 a 60 segundos está sendo gasto a compactação de memória. Isso indica que a memória do sistema é baixa.  
  
> [!NOTE]
>  Esse evento é gerado apenas se a bomba de mensagens está em execução. Em um serviço do Windows, a menos que um formulário oculto é usado ou a bomba de mensagens foi iniciada manualmente, ele será não ser gerado. Para obter um exemplo de código que mostra como manipular eventos do sistema por meio de um formulário oculto em um serviço do Windows, consulte o <xref:Microsoft.Win32.SystemEvents> classe.  
  
> [!CAUTION]
>  Como esse é um evento estático, você deve desanexar seus manipuladores de eventos quando seu aplicativo é descartado ou o resultado serão vazamentos de memória.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Não há suporte para notificações de eventos do sistema no contexto atual. Os processos do servidor, por exemplo, podem não dar suporte a notificações de eventos globais do sistema.</exception>
        <exception cref="T:System.Runtime.InteropServices.ExternalException">A tentativa de criar um thread de janela de eventos do sistema não foi bem-sucedida.</exception>
        <block subset="none" type="usage"><para>Esta mensagem é fornecida somente para compatibilidade com aplicativos baseados em Windows de 16 bits.</para></block>
      </Docs>
    </Member>
    <Member MemberName="PaletteChanged">
      <MemberSignature Language="C#" Value="public static event EventHandler PaletteChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler PaletteChanged" />
      <MemberSignature Language="DocId" Value="E:Microsoft.Win32.SystemEvents.PaletteChanged" />
      <MemberSignature Language="VB.NET" Value="Public Shared Custom Event PaletteChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static event EventHandler ^ PaletteChanged;" />
      <MemberSignature Language="F#" Value="member this.PaletteChanged : EventHandler " Usage="member this.PaletteChanged : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.SystemEvents</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.MonoTODO("Currently does nothing on Mono")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ocorre quando o usuário muda para um aplicativo que usa uma paleta diferente.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Esse evento é gerado apenas se a bomba de mensagens está em execução. Em um serviço do Windows, a menos que um formulário oculto é usado ou a bomba de mensagens foi iniciada manualmente, ele será não ser gerado. Para obter um exemplo de código que mostra como manipular eventos do sistema por meio de um formulário oculto em um serviço do Windows, consulte o <xref:Microsoft.Win32.SystemEvents> classe.  
  
> [!CAUTION]
>  Como esse é um evento estático, você deve desanexar seus manipuladores de eventos quando seu aplicativo é descartado ou o resultado serão vazamentos de memória.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como monitorar o <xref:Microsoft.Win32.SystemEvents.PaletteChanged> eventos. Este exemplo de código é parte de um exemplo maior fornecido para o <xref:Microsoft.Win32.SystemEvents> classe.  
  
 [!code-cpp[SystemEvents#2](~/samples/snippets/cpp/VS_Snippets_Winforms/SystemEvents/cpp/SystemEvents.cpp#2)]
 [!code-csharp[SystemEvents#2](~/samples/snippets/csharp/VS_Snippets_Winforms/SystemEvents/CS/SystemEvents.cs#2)]
 [!code-vb[SystemEvents#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/SystemEvents/VB/SystemEvents.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Não há suporte para notificações de eventos do sistema no contexto atual. Os processos do servidor, por exemplo, podem não dar suporte a notificações de eventos globais do sistema.</exception>
        <exception cref="T:System.Runtime.InteropServices.ExternalException">A tentativa de criar um thread de janela de eventos do sistema não foi bem-sucedida.</exception>
      </Docs>
    </Member>
    <Member MemberName="PowerModeChanged">
      <MemberSignature Language="C#" Value="public static event Microsoft.Win32.PowerModeChangedEventHandler PowerModeChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class Microsoft.Win32.PowerModeChangedEventHandler PowerModeChanged" />
      <MemberSignature Language="DocId" Value="E:Microsoft.Win32.SystemEvents.PowerModeChanged" />
      <MemberSignature Language="VB.NET" Value="Public Shared Custom Event PowerModeChanged As PowerModeChangedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static event Microsoft::Win32::PowerModeChangedEventHandler ^ PowerModeChanged;" />
      <MemberSignature Language="F#" Value="member this.PowerModeChanged : Microsoft.Win32.PowerModeChangedEventHandler " Usage="member this.PowerModeChanged : Microsoft.Win32.PowerModeChangedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.SystemEvents</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.MonoTODO("Currently does nothing on Mono")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.PowerModeChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ocorre quando o usuário suspende ou retoma o sistema.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Esse evento é gerado apenas se a bomba de mensagens está em execução. Em um serviço do Windows, a menos que um formulário oculto é usado ou a bomba de mensagens foi iniciada manualmente, ele será não ser gerado. Para obter um exemplo de código que mostra como manipular eventos do sistema por meio de um formulário oculto em um serviço do Windows, consulte o <xref:Microsoft.Win32.SystemEvents> classe.  
  
> [!CAUTION]
>  Como esse é um evento estático, você deve desanexar seus manipuladores de eventos quando seu aplicativo é descartado ou o resultado serão vazamentos de memória.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Não há suporte para notificações de eventos do sistema no contexto atual. Os processos do servidor, por exemplo, podem não dar suporte a notificações de eventos globais do sistema.</exception>
        <exception cref="T:System.Runtime.InteropServices.ExternalException">A tentativa de criar um thread de janela de eventos do sistema não foi bem-sucedida.</exception>
        <altmember cref="T:Microsoft.Win32.PowerModeChangedEventArgs" />
        <altmember cref="T:Microsoft.Win32.PowerModeChangedEventHandler" />
        <altmember cref="T:Microsoft.Win32.PowerModes" />
      </Docs>
    </Member>
    <Member MemberName="SessionEnded">
      <MemberSignature Language="C#" Value="public static event Microsoft.Win32.SessionEndedEventHandler SessionEnded;" />
      <MemberSignature Language="ILAsm" Value=".event class Microsoft.Win32.SessionEndedEventHandler SessionEnded" />
      <MemberSignature Language="DocId" Value="E:Microsoft.Win32.SystemEvents.SessionEnded" />
      <MemberSignature Language="VB.NET" Value="Public Shared Custom Event SessionEnded As SessionEndedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static event Microsoft::Win32::SessionEndedEventHandler ^ SessionEnded;" />
      <MemberSignature Language="F#" Value="member this.SessionEnded : Microsoft.Win32.SessionEndedEventHandler " Usage="member this.SessionEnded : Microsoft.Win32.SessionEndedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.SystemEvents</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.MonoTODO("Currently does nothing on Mono")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.SessionEndedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ocorre quando o usuário está tentando fazer logoff ou desligar o sistema.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Esse evento é gerado apenas se a bomba de mensagens está em execução. Em um serviço do Windows, a menos que um formulário oculto é usado ou a bomba de mensagens foi iniciada manualmente, ele será não ser gerado. Para obter um exemplo de código que mostra como manipular eventos do sistema por meio de um formulário oculto em um serviço do Windows, consulte o <xref:Microsoft.Win32.SystemEvents> classe.  
  
> [!CAUTION]
>  Como esse é um evento estático, você deve desanexar seus manipuladores de eventos quando seu aplicativo é descartado ou o resultado serão vazamentos de memória.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Não há suporte para notificações de eventos do sistema no contexto atual. Os processos do servidor, por exemplo, podem não dar suporte a notificações de eventos globais do sistema.</exception>
        <exception cref="T:System.Runtime.InteropServices.ExternalException">A tentativa de criar um thread de janela de eventos do sistema não foi bem-sucedida.</exception>
        <altmember cref="T:Microsoft.Win32.SessionEndedEventArgs" />
        <altmember cref="T:Microsoft.Win32.SessionEndedEventHandler" />
        <altmember cref="T:Microsoft.Win32.SessionEndReasons" />
      </Docs>
    </Member>
    <Member MemberName="SessionEnding">
      <MemberSignature Language="C#" Value="public static event Microsoft.Win32.SessionEndingEventHandler SessionEnding;" />
      <MemberSignature Language="ILAsm" Value=".event class Microsoft.Win32.SessionEndingEventHandler SessionEnding" />
      <MemberSignature Language="DocId" Value="E:Microsoft.Win32.SystemEvents.SessionEnding" />
      <MemberSignature Language="VB.NET" Value="Public Shared Custom Event SessionEnding As SessionEndingEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static event Microsoft::Win32::SessionEndingEventHandler ^ SessionEnding;" />
      <MemberSignature Language="F#" Value="member this.SessionEnding : Microsoft.Win32.SessionEndingEventHandler " Usage="member this.SessionEnding : Microsoft.Win32.SessionEndingEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.SystemEvents</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.MonoTODO("Currently does nothing on Mono")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.SessionEndingEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ocorre quando o usuário está tentando fazer logoff ou desligar o sistema.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este é um evento cancelável. Definindo o <xref:Microsoft.Win32.SessionEndingEventArgs.Cancel%2A> propriedade para `true` solicita que a sessão continue a executar. Ele fornece nenhuma garantia de que a sessão não será encerrada.  
  
 Se você estiver usando <xref:Microsoft.Win32.SystemEvents.SessionEnding> em um formulário do Windows para detectar o logoff do sistema ou a reinicialização, não há nenhuma maneira determinística para decidir se o <xref:System.Windows.Forms.Form.Closing> evento será acionado antes desse evento.  
  
 Se você quiser executar algumas tarefas especiais antes <xref:System.Windows.Forms.Form.Closing> é disparado, você precisa garantir que <xref:Microsoft.Win32.SystemEvents.SessionEnding> será acionado antes de <xref:System.Windows.Forms.Form.Closing>. Para fazer isso, você precisa interceptar o `WM_QUERYENDSESSION` no formulário, substituindo o `WndProc` função.  Este exemplo demonstra como fazer isso.  
  
```vb  
Private Shared WM_QUERYENDSESSION As Integer = &H11  
 Private Shared systemShutdown As Boolean = False  
 Protected Overrides Sub WndProc(ByRef m As System.Windows.Forms.Message)  
     If m.Msg = WM_QUERYENDSESSION Then  
         MessageBox.Show("queryendsession: this is a logoff, shutdown, or reboot")  
         systemShutdown = True  
     End If  
     ' If this is WM_QUERYENDSESSION, the closing event should be raised in the base WndProc.  
     MyBase.WndProc(m)  
 End Sub 'WndProc   
 Private Sub Form1_Closing(ByVal sender As System.Object, ByVal e As System.ComponentModel.CancelEventArgs) Handles MyBase.Closing  
     If (systemShutdown) Then  
     ' Reset the variable because the user might cancel the shutdown.  
         systemShutdown = False  
         If (System.Windows.Forms.DialogResult.Yes = _  
                 MessageBox.Show("My application", "Do you want to save your work before logging off?", MessageBoxButtons.YesNo)) Then  
                 e.Cancel = True  
         Else  
                 e.Cancel = False  
         End If  
     End If  
 End Sub  
  
```  
  
```csharp  
private static int WM_QUERYENDSESSION = 0x11;  
private static bool systemShutdown = false;  
protected override void WndProc(ref System.Windows.Forms.Message m)  
{  
    if (m.Msg==WM_QUERYENDSESSION)  
    {  
        MessageBox.Show("queryendsession: this is a logoff, shutdown, or reboot");  
        systemShutdown = true;  
    }  
  
    // If this is WM_QUERYENDSESSION, the closing event should be  
    // raised in the base WndProc.  
    base.WndProc(ref m);  
  
} //WndProc   
  
private void Form1_Closing(  
    System.Object sender,   
    System.ComponentModel.CancelEventArgs e)  
{  
    if (systemShutdown)  
        // Reset the variable because the user might cancel the   
        // shutdown.  
    {  
        systemShutdown = false;  
        if (DialogResult.Yes==MessageBox.Show("My application",   
            "Do you want to save your work before logging off?",   
            MessageBoxButtons.YesNo))  
        {  
            e.Cancel = true;  
        }  
        else  
        {  
            e.Cancel = false;  
        }  
    }  
}  
```  
  
> [!IMPORTANT]
>  Aplicativos de console não acionam o <xref:Microsoft.Win32.SystemEvents.SessionEnding> eventos.  
  
> [!NOTE]
>  Esse evento é gerado apenas se a bomba de mensagens está em execução. Em um serviço do Windows, a menos que um formulário oculto é usado ou a bomba de mensagens foi iniciada manualmente, ele será não ser gerado. Para obter um exemplo de código que mostra como manipular eventos do sistema por meio de um formulário oculto em um serviço do Windows, consulte o <xref:Microsoft.Win32.SystemEvents> classe.  
  
> [!CAUTION]
>  Como esse é um evento estático, você deve desanexar seus manipuladores de eventos quando seu aplicativo é descartado ou o resultado serão vazamentos de memória.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Não há suporte para notificações de eventos do sistema no contexto atual. Os processos do servidor, por exemplo, podem não dar suporte a notificações de eventos globais do sistema.</exception>
        <exception cref="T:System.Runtime.InteropServices.ExternalException">A tentativa de criar um thread de janela de eventos do sistema não foi bem-sucedida.</exception>
        <altmember cref="T:Microsoft.Win32.SessionEndingEventArgs" />
        <altmember cref="T:Microsoft.Win32.SessionEndingEventHandler" />
        <altmember cref="T:Microsoft.Win32.SessionEndReasons" />
      </Docs>
    </Member>
    <Member MemberName="SessionSwitch">
      <MemberSignature Language="C#" Value="public static event Microsoft.Win32.SessionSwitchEventHandler SessionSwitch;" />
      <MemberSignature Language="ILAsm" Value=".event class Microsoft.Win32.SessionSwitchEventHandler SessionSwitch" />
      <MemberSignature Language="DocId" Value="E:Microsoft.Win32.SystemEvents.SessionSwitch" />
      <MemberSignature Language="VB.NET" Value="Public Shared Custom Event SessionSwitch As SessionSwitchEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static event Microsoft::Win32::SessionSwitchEventHandler ^ SessionSwitch;" />
      <MemberSignature Language="F#" Value="member this.SessionSwitch : Microsoft.Win32.SessionSwitchEventHandler " Usage="member this.SessionSwitch : Microsoft.Win32.SessionSwitchEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.SystemEvents</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.MonoTODO("Currently does nothing on Mono")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.SessionSwitchEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ocorre quando o usuário conectado no momento foi alterado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Esse evento é gerado apenas se a bomba de mensagens está em execução. Em um serviço do Windows, a menos que um formulário oculto é usado ou a bomba de mensagens foi iniciada manualmente, ele será não ser gerado. Para obter um exemplo de código que mostra como manipular eventos do sistema por meio de um formulário oculto em um serviço do Windows, consulte o <xref:Microsoft.Win32.SystemEvents> classe.  
  
> [!CAUTION]
>  Como esse é um evento estático, você deve desanexar seus manipuladores de eventos quando seu aplicativo é descartado ou o resultado serão vazamentos de memória.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Não há suporte para notificações de eventos do sistema no contexto atual. Os processos do servidor, por exemplo, podem não dar suporte a notificações de eventos globais do sistema.</exception>
        <exception cref="T:System.Runtime.InteropServices.ExternalException">A tentativa de criar um thread de janela de eventos do sistema não foi bem-sucedida.</exception>
        <altmember cref="T:Microsoft.Win32.SessionSwitchEventHandler" />
      </Docs>
    </Member>
    <Member MemberName="TimeChanged">
      <MemberSignature Language="C#" Value="public static event EventHandler TimeChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler TimeChanged" />
      <MemberSignature Language="DocId" Value="E:Microsoft.Win32.SystemEvents.TimeChanged" />
      <MemberSignature Language="VB.NET" Value="Public Shared Custom Event TimeChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static event EventHandler ^ TimeChanged;" />
      <MemberSignature Language="F#" Value="member this.TimeChanged : EventHandler " Usage="member this.TimeChanged : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.SystemEvents</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.MonoTODO("Currently does nothing on Mono")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ocorre quando o usuário altera a hora no relógio do sistema.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Esse evento é gerado apenas se a bomba de mensagens está em execução. Em um serviço do Windows, a menos que um formulário oculto é usado ou a bomba de mensagens foi iniciada manualmente, ele será não ser gerado. Para obter um exemplo de código que mostra como manipular eventos do sistema por meio de um formulário oculto em um serviço do Windows, consulte o <xref:Microsoft.Win32.SystemEvents> classe.  
  
> [!CAUTION]
>  Como esse é um evento estático, você deve desanexar seus manipuladores de eventos quando seu aplicativo é descartado ou o resultado serão vazamentos de memória.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Não há suporte para notificações de eventos do sistema no contexto atual. Os processos do servidor, por exemplo, podem não dar suporte a notificações de eventos globais do sistema.</exception>
        <exception cref="T:System.Runtime.InteropServices.ExternalException">A tentativa de criar um thread de janela de eventos do sistema não foi bem-sucedida.</exception>
        <altmember cref="P:System.DateTime.Now" />
      </Docs>
    </Member>
    <Member MemberName="TimerElapsed">
      <MemberSignature Language="C#" Value="public static event Microsoft.Win32.TimerElapsedEventHandler TimerElapsed;" />
      <MemberSignature Language="ILAsm" Value=".event class Microsoft.Win32.TimerElapsedEventHandler TimerElapsed" />
      <MemberSignature Language="DocId" Value="E:Microsoft.Win32.SystemEvents.TimerElapsed" />
      <MemberSignature Language="VB.NET" Value="Public Shared Custom Event TimerElapsed As TimerElapsedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static event Microsoft::Win32::TimerElapsedEventHandler ^ TimerElapsed;" />
      <MemberSignature Language="F#" Value="member this.TimerElapsed : Microsoft.Win32.TimerElapsedEventHandler " Usage="member this.TimerElapsed : Microsoft.Win32.TimerElapsedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.SystemEvents</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.TimerElapsedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ocorre quando um intervalo do temporizador do Windows expirou.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Esse evento é gerado apenas se a bomba de mensagens está em execução. Em um serviço do Windows, a menos que um formulário oculto é usado ou a bomba de mensagens foi iniciada manualmente, ele será não ser gerado. Para obter um exemplo de código que mostra como manipular eventos do sistema por meio de um formulário oculto em um serviço do Windows, consulte o <xref:Microsoft.Win32.SystemEvents> classe.  
  
> [!CAUTION]
>  Como esse é um evento estático, você deve desanexar seus manipuladores de eventos quando seu aplicativo é descartado ou o resultado serão vazamentos de memória.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Não há suporte para notificações de eventos do sistema no contexto atual. Os processos do servidor, por exemplo, podem não dar suporte a notificações de eventos globais do sistema.</exception>
        <exception cref="T:System.Runtime.InteropServices.ExternalException">A tentativa de criar um thread de janela de eventos do sistema não foi bem-sucedida.</exception>
        <altmember cref="T:Microsoft.Win32.TimerElapsedEventArgs" />
        <altmember cref="T:Microsoft.Win32.TimerElapsedEventHandler" />
      </Docs>
    </Member>
    <Member MemberName="UserPreferenceChanged">
      <MemberSignature Language="C#" Value="public static event Microsoft.Win32.UserPreferenceChangedEventHandler UserPreferenceChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class Microsoft.Win32.UserPreferenceChangedEventHandler UserPreferenceChanged" />
      <MemberSignature Language="DocId" Value="E:Microsoft.Win32.SystemEvents.UserPreferenceChanged" />
      <MemberSignature Language="VB.NET" Value="Public Shared Custom Event UserPreferenceChanged As UserPreferenceChangedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static event Microsoft::Win32::UserPreferenceChangedEventHandler ^ UserPreferenceChanged;" />
      <MemberSignature Language="F#" Value="member this.UserPreferenceChanged : Microsoft.Win32.UserPreferenceChangedEventHandler " Usage="member this.UserPreferenceChanged : Microsoft.Win32.UserPreferenceChangedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.SystemEvents</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.MonoTODO("Currently does nothing on Mono")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.UserPreferenceChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ocorre quando uma preferência do usuário foi alterada.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Esse evento é gerado apenas se a bomba de mensagens está em execução. Em um serviço do Windows, a menos que um formulário oculto é usado ou a bomba de mensagens foi iniciada manualmente, ele será não ser gerado. Para obter um exemplo de código que mostra como manipular eventos do sistema por meio de um formulário oculto em um serviço do Windows, consulte o <xref:Microsoft.Win32.SystemEvents> classe.  
  
> [!CAUTION]
>  Como esse é um evento estático, você deve desanexar seus manipuladores de eventos quando seu aplicativo é descartado ou o resultado serão vazamentos de memória.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Não há suporte para notificações de eventos do sistema no contexto atual. Os processos do servidor, por exemplo, podem não dar suporte a notificações de eventos globais do sistema.</exception>
        <exception cref="T:System.Runtime.InteropServices.ExternalException">A tentativa de criar um thread de janela de eventos do sistema não foi bem-sucedida.</exception>
        <altmember cref="T:Microsoft.Win32.UserPreferenceChangedEventArgs" />
        <altmember cref="T:Microsoft.Win32.UserPreferenceChangedEventHandler" />
        <altmember cref="T:Microsoft.Win32.UserPreferenceCategory" />
      </Docs>
    </Member>
    <Member MemberName="UserPreferenceChanging">
      <MemberSignature Language="C#" Value="public static event Microsoft.Win32.UserPreferenceChangingEventHandler UserPreferenceChanging;" />
      <MemberSignature Language="ILAsm" Value=".event class Microsoft.Win32.UserPreferenceChangingEventHandler UserPreferenceChanging" />
      <MemberSignature Language="DocId" Value="E:Microsoft.Win32.SystemEvents.UserPreferenceChanging" />
      <MemberSignature Language="VB.NET" Value="Public Shared Custom Event UserPreferenceChanging As UserPreferenceChangingEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static event Microsoft::Win32::UserPreferenceChangingEventHandler ^ UserPreferenceChanging;" />
      <MemberSignature Language="F#" Value="member this.UserPreferenceChanging : Microsoft.Win32.UserPreferenceChangingEventHandler " Usage="member this.UserPreferenceChanging : Microsoft.Win32.UserPreferenceChangingEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.SystemEvents</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.MonoTODO("Currently does nothing on Mono")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.UserPreferenceChangingEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ocorre quando uma preferência do usuário está sendo alterada.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Esse evento é gerado apenas se a bomba de mensagens está em execução. Em um serviço do Windows, a menos que um formulário oculto é usado ou a bomba de mensagens foi iniciada manualmente, ele será não ser gerado. Para obter um exemplo de código que mostra como manipular eventos do sistema por meio de um formulário oculto em um serviço do Windows, consulte o <xref:Microsoft.Win32.SystemEvents> classe.  
  
> [!CAUTION]
>  Como esse é um evento estático, você deve desanexar seus manipuladores de eventos quando seu aplicativo é descartado ou o resultado serão vazamentos de memória.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como monitorar o <xref:Microsoft.Win32.SystemEvents.UserPreferenceChanging> eventos. Este exemplo de código é parte de um exemplo maior fornecido para o <xref:Microsoft.Win32.SystemEvents> classe.  
  
 [!code-cpp[SystemEvents#2](~/samples/snippets/cpp/VS_Snippets_Winforms/SystemEvents/cpp/SystemEvents.cpp#2)]
 [!code-csharp[SystemEvents#2](~/samples/snippets/csharp/VS_Snippets_Winforms/SystemEvents/CS/SystemEvents.cs#2)]
 [!code-vb[SystemEvents#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/SystemEvents/VB/SystemEvents.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Não há suporte para notificações de eventos do sistema no contexto atual. Os processos do servidor, por exemplo, podem não dar suporte a notificações de eventos globais do sistema.</exception>
        <exception cref="T:System.Runtime.InteropServices.ExternalException">A tentativa de criar um thread de janela de eventos do sistema não foi bem-sucedida.</exception>
        <altmember cref="T:Microsoft.Win32.UserPreferenceChangingEventArgs" />
        <altmember cref="T:Microsoft.Win32.UserPreferenceChangingEventHandler" />
        <altmember cref="T:Microsoft.Win32.UserPreferenceCategory" />
      </Docs>
    </Member>
  </Members>
</Type>