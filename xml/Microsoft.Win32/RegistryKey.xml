<Type Name="RegistryKey" FullName="Microsoft.Win32.RegistryKey">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="bd1c542732c55e805b838b930fc5df9a58097d3b" />
    <Meta Name="ms.sourcegitcommit" Value="6a0b904069161bbaec4ffd02aa7d9cf38c61e72e" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="pt-BR" />
    <Meta Name="ms.lasthandoff" Value="06/24/2018" />
    <Meta Name="ms.locfileid" Value="36657890" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class RegistryKey : MarshalByRefObject, IDisposable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed RegistryKey extends System.MarshalByRefObject implements class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:Microsoft.Win32.RegistryKey" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class RegistryKey&#xA;Inherits MarshalByRefObject&#xA;Implements IDisposable" />
  <TypeSignature Language="C++ CLI" Value="public ref class RegistryKey sealed : MarshalByRefObject, IDisposable" />
  <TypeSignature Language="F#" Value="type RegistryKey = class&#xA;    inherit MarshalByRefObject&#xA;    interface IDisposable" />
  <AssemblyInfo>
    <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
    <BaseTypeName FrameworkAlternate="netframework-4.5">System.MarshalByRefObject</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Represents a key-level node in the Windows registry. This class is a registry encapsulation.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para obter uma instância de <xref:Microsoft.Win32.RegistryKey>, use um dos membros estáticos da classe <xref:Microsoft.Win32.Registry>.  
  
 O registro atua como um repositório central de informações para o sistema operacional e os aplicativos em um computador. O registro é organizado em um formato hierárquico, com base em uma ordem lógica dos elementos armazenados nele (consulte <xref:Microsoft.Win32.Registry> para os itens de nível básico nesta hierarquia). Ao armazenar informações no registro, selecione o local apropriado com base no tipo de informações que estão sendo armazenados. Certifique-se de evitar destruir informações criadas por outros aplicativos, pois isso pode fazer com que esses aplicativos exibem um comportamento inesperado e também pode ter um efeito adverso em seu próprio aplicativo.  
  
> [!IMPORTANT]
>  Este tipo implementa o <xref:System.IDisposable> interface. Quando você terminar de usar o tipo, descarte-direta ou indiretamente. Para descartar o tipo diretamente, chame seu <xref:System.IDisposable.Dispose%2A> método em um `try` / `catch` bloco. Para descartar indiretamente dele, use uma construção de linguagem, como `using` (em c#) ou `Using` (no Visual Basic). Para obter mais informações, consulte a seção "Usando um objeto que implementa IDisposable" o <xref:System.IDisposable> tópico de interface.  
  
 Chaves do registro são a unidade básica de organização no registro e podem ser comparadas com pastas no Explorador de arquivos. Uma determinada chave pode ter subchaves, assim como uma pasta pode ter subpastas. Cada chave pode ser excluído, contanto que o usuário tem as permissões apropriadas para fazer isso, e a chave não é uma chave de base ou no nível de diretamente sob as chaves de base. Cada chave também pode ter vários valores associados a ele (um valor pode ser comparado a um arquivo), que são usados para armazenar as informações — por exemplo, informações sobre um aplicativo instalado no computador. Cada valor contém um elemento específico de informação, que pode ser recuperado ou atualizada quando necessário. Por exemplo, você pode criar um <xref:Microsoft.Win32.RegistryKey> para sua empresa, sob a chave HKEY_LOCAL_MACHINE\Software e, em seguida, uma subchave para cada aplicativo que cria sua empresa. Cada subchave armazena as informações específicas para esse aplicativo, como configurações de cor, tamanho e local na tela ou extensões de arquivo reconhecidas.  
  
 Observe que informações armazenadas no registro estão disponíveis para outros usuários e aplicativos e, portanto, não devem ser usadas para armazenar informações de aplicativos críticos ou dados de segurança.  
  
> [!CAUTION]
>  Não exponha objetos <xref:Microsoft.Win32.RegistryKey> de maneira que um programa mal-intencionado possa criar milhares de subchaves sem sentido ou os pares de chave/valor. Por exemplo, não permita que chamadores insiram chaves ou valores arbitrários.  
  
 A partir de [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], o comprimento de uma chave do registro não está mais limitado a 255 caracteres.  
  
   
  
## Examples  
 O exemplo de código a seguir mostra como criar uma subchave em HKEY_CURRENT_USER, manipular seu conteúdo e, em seguida, exclua a subchave.  
  
 [!code-cpp[Microsoft.Win32.RegistryKey2#1](~/samples/snippets/cpp/VS_Snippets_CLR/Microsoft.Win32.RegistryKey2/CPP/source.cpp#1)]
 [!code-csharp[Microsoft.Win32.RegistryKey2#1](~/samples/snippets/csharp/VS_Snippets_CLR/Microsoft.Win32.RegistryKey2/CS/source.cs#1)]
 [!code-vb[Microsoft.Win32.RegistryKey2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Microsoft.Win32.RegistryKey2/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:Microsoft.Win32.Registry" />
    <altmember cref="T:Microsoft.Win32.RegistryHive" />
  </Docs>
  <Members>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Win32.RegistryKey.Close" />
      <MemberSignature Language="VB.NET" Value="Public Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Close();" />
      <MemberSignature Language="F#" Value="member this.Close : unit -&gt; unit" Usage="registryKey.Close " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Closes the key and flushes it to disk if its contents have been modified.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Chamar este método em chaves do sistema não terá efeito, como as chaves do sistema nunca são fechadas.  
  
 Esse método não fará nada se chamá-lo em uma instância de `RegistryKey` que já está fechado.  
  
   
  
## Examples  
 Este exemplo de código é parte de um exemplo maior fornecido para a <xref:Microsoft.Win32.RegistryKey> classe.  
  
 [!code-cpp[Microsoft.Win32.RegistryKey2#4](~/samples/snippets/cpp/VS_Snippets_CLR/Microsoft.Win32.RegistryKey2/CPP/source.cpp#4)]
 [!code-csharp[Microsoft.Win32.RegistryKey2#4](~/samples/snippets/csharp/VS_Snippets_CLR/Microsoft.Win32.RegistryKey2/CS/source.cs#4)]
 [!code-vb[Microsoft.Win32.RegistryKey2#4](~/samples/snippets/visualbasic/VS_Snippets_CLR/Microsoft.Win32.RegistryKey2/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.Win32.RegistryKey.Flush" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateSubKey">
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Creates a new subkey or opens an existing subkey.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateSubKey">
      <MemberSignature Language="C#" Value="public Microsoft.Win32.RegistryKey CreateSubKey (string subkey);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class Microsoft.Win32.RegistryKey CreateSubKey(string subkey) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Win32.RegistryKey.CreateSubKey(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateSubKey (subkey As String) As RegistryKey" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Microsoft::Win32::RegistryKey ^ CreateSubKey(System::String ^ subkey);" />
      <MemberSignature Language="F#" Value="member this.CreateSubKey : string -&gt; Microsoft.Win32.RegistryKey" Usage="registryKey.CreateSubKey subkey" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.RegistryKey</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="subkey" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="subkey">The name or path of the subkey to create or open. This string is not case-sensitive.</param>
        <summary>Creates a new subkey or opens an existing subkey for write access.</summary>
        <returns>The newly created subkey, or <see langword="null" /> if the operation failed. If a zero-length string is specified for <paramref name="subkey" />, the current <see cref="T:Microsoft.Win32.RegistryKey" /> object is returned.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para executar esta ação, o usuário deve ter permissão neste nível e abaixo na hierarquia do registro.  
  
> [!CAUTION]
>  Não exponha objetos <xref:Microsoft.Win32.RegistryKey> de maneira que um programa mal-intencionado possa criar milhares de subchaves sem sentido ou os pares de chave/valor. Por exemplo, não permita que chamadores insiram chaves ou valores arbitrários.  
  
   
  
## Examples  
 O exemplo de código a seguir mostra como criar uma subchave em HKEY_CURRENT_USER, manipular seu conteúdo e, em seguida, exclua a subchave.  
  
 [!code-cpp[Microsoft.Win32.RegistryKey2#1](~/samples/snippets/cpp/VS_Snippets_CLR/Microsoft.Win32.RegistryKey2/CPP/source.cpp#1)]
 [!code-csharp[Microsoft.Win32.RegistryKey2#1](~/samples/snippets/csharp/VS_Snippets_CLR/Microsoft.Win32.RegistryKey2/CS/source.cs#1)]
 [!code-vb[Microsoft.Win32.RegistryKey2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Microsoft.Win32.RegistryKey2/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="subkey" /> is <see langword="null" />.</exception>
        <exception cref="T:System.Security.SecurityException">The user does not have the permissions required to create or open the registry key.</exception>
        <exception cref="T:System.ObjectDisposedException">The <see cref="T:Microsoft.Win32.RegistryKey" /> on which this method is being invoked is closed (closed keys cannot be accessed).</exception>
        <exception cref="T:System.UnauthorizedAccessException">The <see cref="T:Microsoft.Win32.RegistryKey" /> cannot be written to; for example, it was not opened as a writable key , or the user does not have the necessary access rights.</exception>
        <exception cref="T:System.IO.IOException">The nesting level exceeds 510.  -or-  A system error occurred, such as deletion of the key, or an attempt to create a key in the <see cref="F:Microsoft.Win32.Registry.LocalMachine" /> root.</exception>
        <permission cref="T:System.Security.Permissions.RegistryPermission">a capacidade de modificar a chave de registro especificado se ele existir, ou para a capacidade de criar a chave do registro em caso de ele ainda não existir. Enumerações associadas: <see cref="F:System.Security.Permissions.RegistryPermissionAccess.Write" />, <see cref="F:System.Security.Permissions.RegistryPermissionAccess.Create" /></permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">para a capacidade de acessar a chave do Registro especificada caso ela seja uma chave remota. Enumeração associada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="M:Microsoft.Win32.RegistryKey.DeleteSubKey(System.String)" />
        <altmember cref="M:Microsoft.Win32.RegistryKey.OpenSubKey(System.String,System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="CreateSubKey">
      <MemberSignature Language="C#" Value="public Microsoft.Win32.RegistryKey CreateSubKey (string subkey, Microsoft.Win32.RegistryKeyPermissionCheck permissionCheck);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class Microsoft.Win32.RegistryKey CreateSubKey(string subkey, valuetype Microsoft.Win32.RegistryKeyPermissionCheck permissionCheck) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Win32.RegistryKey.CreateSubKey(System.String,Microsoft.Win32.RegistryKeyPermissionCheck)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateSubKey (subkey As String, permissionCheck As RegistryKeyPermissionCheck) As RegistryKey" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Microsoft::Win32::RegistryKey ^ CreateSubKey(System::String ^ subkey, Microsoft::Win32::RegistryKeyPermissionCheck permissionCheck);" />
      <MemberSignature Language="F#" Value="member this.CreateSubKey : string * Microsoft.Win32.RegistryKeyPermissionCheck -&gt; Microsoft.Win32.RegistryKey" Usage="registryKey.CreateSubKey (subkey, permissionCheck)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.RegistryKey</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="subkey" Type="System.String" />
        <Parameter Name="permissionCheck" Type="Microsoft.Win32.RegistryKeyPermissionCheck" />
      </Parameters>
      <Docs>
        <param name="subkey">The name or path of the subkey to create or open. This string is not case-sensitive.</param>
        <param name="permissionCheck">One of the enumeration values that specifies whether the key is opened for read or read/write access.</param>
        <summary>Creates a new subkey or opens an existing subkey for write access, using the specified permission check option.</summary>
        <returns>The newly created subkey, or <see langword="null" /> if the operation failed. If a zero-length string is specified for <paramref name="subkey" />, the current <see cref="T:Microsoft.Win32.RegistryKey" /> object is returned.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para executar esta ação, o usuário deve ter permissão neste nível e abaixo na hierarquia do registro.  
  
> [!CAUTION]
>  Não exponha objetos <xref:Microsoft.Win32.RegistryKey> de maneira que um programa mal-intencionado possa criar milhares de subchaves sem sentido ou os pares de chave/valor. Por exemplo, não permita que chamadores insiram chaves ou valores arbitrários.  
  
 Para usar o método <xref:Microsoft.Win32.RegistryKey.OpenSubKey%2A>, você deve ter uma instância da classe <xref:Microsoft.Win32.RegistryKey>. Para obter uma instância de <xref:Microsoft.Win32.RegistryKey>, use um dos membros estáticos da classe <xref:Microsoft.Win32.Registry>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="subkey" /> is <see langword="null" />.</exception>
        <exception cref="T:System.Security.SecurityException">The user does not have the permissions required to create or open the registry key.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="permissionCheck" /> contains an invalid value.</exception>
        <exception cref="T:System.ObjectDisposedException">The <see cref="T:Microsoft.Win32.RegistryKey" /> on which this method is being invoked is closed (closed keys cannot be accessed).</exception>
        <exception cref="T:System.UnauthorizedAccessException">The <see cref="T:Microsoft.Win32.RegistryKey" /> cannot be written to; for example, it was not opened as a writable key, or the user does not have the necessary access rights.</exception>
        <exception cref="T:System.IO.IOException">The nesting level exceeds 510.  -or-  A system error occurred, such as deletion of the key, or an attempt to create a key in the <see cref="F:Microsoft.Win32.Registry.LocalMachine" /> root.</exception>
        <permission cref="T:System.Security.Permissions.RegistryPermission">a capacidade de modificar a chave de registro especificado se ele existir, ou para a capacidade de criar a chave do registro em caso de ele ainda não existir. Enumerações associadas: <see cref="F:System.Security.Permissions.RegistryPermissionAccess.Write" />, <see cref="F:System.Security.Permissions.RegistryPermissionAccess.Create" /></permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">para a capacidade de acessar a chave do Registro especificada caso ela seja uma chave remota. Enumeração associada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="M:Microsoft.Win32.RegistryKey.DeleteSubKey(System.String)" />
        <altmember cref="M:Microsoft.Win32.RegistryKey.OpenSubKey(System.String,System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="CreateSubKey">
      <MemberSignature Language="C#" Value="public Microsoft.Win32.RegistryKey CreateSubKey (string subkey, bool writable);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class Microsoft.Win32.RegistryKey CreateSubKey(string subkey, bool writable) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Win32.RegistryKey.CreateSubKey(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateSubKey (subkey As String, writable As Boolean) As RegistryKey" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Microsoft::Win32::RegistryKey ^ CreateSubKey(System::String ^ subkey, bool writable);" />
      <MemberSignature Language="F#" Value="member this.CreateSubKey : string * bool -&gt; Microsoft.Win32.RegistryKey" Usage="registryKey.CreateSubKey (subkey, writable)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.RegistryKey</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="subkey" Type="System.String" />
        <Parameter Name="writable" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="subkey">The name or path of the subkey to create or open. This string is not case-sensitive.</param>
        <param name="writable">
          <see langword="true" /> to indicate the new subkey is writable; otherwise, <see langword="false" />.</param>
        <summary>Creates a new subkey or opens an existing subkey with the specified access.  Available starting in [!INCLUDE[net_v46](~/includes/net-v46-md.md)]</summary>
        <returns>The newly created subkey, or <see langword="null" /> if the operation failed. If a zero-length string is specified for <paramref name="subkey" />, the current <see cref="T:Microsoft.Win32.RegistryKey" /> object is returned.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para executar esta ação, o usuário deve ter permissão neste nível e abaixo na hierarquia do registro.  
  
> [!CAUTION]
>  Não exponha objetos <xref:Microsoft.Win32.RegistryKey> de maneira que um programa mal-intencionado possa criar milhares de subchaves sem sentido ou os pares de chave/valor. Por exemplo, não permita que chamadores insiram chaves ou valores arbitrários.  
  
 Para usar o método <xref:Microsoft.Win32.RegistryKey.CreateSubKey%2A>, você deve ter uma instância da classe <xref:Microsoft.Win32.RegistryKey>. Para obter uma instância de <xref:Microsoft.Win32.RegistryKey>, use um dos membros estáticos da classe <xref:Microsoft.Win32.Registry>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="subkey" /> is <see langword="null" />.</exception>
        <exception cref="T:System.Security.SecurityException">The user does not have the permissions required to create or open the registry key.</exception>
        <exception cref="T:System.UnauthorizedAccessException">The current <see cref="T:Microsoft.Win32.RegistryKey" /> cannot be written to; for example, it was not opened as a writable key, or the user does not have the necessary access rights.</exception>
        <exception cref="T:System.IO.IOException">The nesting level exceeds 510.  -or-  A system error occurred, such as deletion of the key, or an attempt to create a key in the <see cref="F:Microsoft.Win32.Registry.LocalMachine" /> root.</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateSubKey">
      <MemberSignature Language="C#" Value="public Microsoft.Win32.RegistryKey CreateSubKey (string subkey, Microsoft.Win32.RegistryKeyPermissionCheck permissionCheck, System.Security.AccessControl.RegistrySecurity registrySecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class Microsoft.Win32.RegistryKey CreateSubKey(string subkey, valuetype Microsoft.Win32.RegistryKeyPermissionCheck permissionCheck, class System.Security.AccessControl.RegistrySecurity registrySecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Win32.RegistryKey.CreateSubKey(System.String,Microsoft.Win32.RegistryKeyPermissionCheck,System.Security.AccessControl.RegistrySecurity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Microsoft::Win32::RegistryKey ^ CreateSubKey(System::String ^ subkey, Microsoft::Win32::RegistryKeyPermissionCheck permissionCheck, System::Security::AccessControl::RegistrySecurity ^ registrySecurity);" />
      <MemberSignature Language="F#" Value="member this.CreateSubKey : string * Microsoft.Win32.RegistryKeyPermissionCheck * System.Security.AccessControl.RegistrySecurity -&gt; Microsoft.Win32.RegistryKey" Usage="registryKey.CreateSubKey (subkey, permissionCheck, registrySecurity)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.RegistryKey</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="subkey" Type="System.String" />
        <Parameter Name="permissionCheck" Type="Microsoft.Win32.RegistryKeyPermissionCheck" />
        <Parameter Name="registrySecurity" Type="System.Security.AccessControl.RegistrySecurity" />
      </Parameters>
      <Docs>
        <param name="subkey">The name or path of the subkey to create or open. This string is not case-sensitive.</param>
        <param name="permissionCheck">One of the enumeration values that specifies whether the key is opened for read or read/write access.</param>
        <param name="registrySecurity">The access control security for the new key.</param>
        <summary>Creates a new subkey or opens an existing subkey for write access, using the specified permission check option and registry security.</summary>
        <returns>The newly created subkey, or <see langword="null" /> if the operation failed. If a zero-length string is specified for <paramref name="subkey" />, the current <see cref="T:Microsoft.Win32.RegistryKey" /> object is returned.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:Microsoft.Win32.RegistryKey.CreateSubKey%2A> método cria uma chave do registro que contém o controle de acesso especificado pelo `registrySecurity` parâmetro. O <xref:Microsoft.Win32.RegistryKey> objeto retornado representa a chave do registro, mas esse objeto não é restrito pelo controle de acesso especificado no `registrySecurity` parâmetro.  
  
 Se `permissionCheck` é <xref:Microsoft.Win32.RegistryKeyPermissionCheck.ReadWriteSubTree?displayProperty=nameWithType>, a chave é aberta para acesso de leitura/gravação. Se `permissionCheck` é <xref:Microsoft.Win32.RegistryKeyPermissionCheck.ReadSubTree?displayProperty=nameWithType>, a chave é aberta para acesso de leitura.  
  
 Para compatibilidade com versões anteriores, a chave é aberta para leitura e gravação se `permissionCheck` é <xref:Microsoft.Win32.RegistryKeyPermissionCheck.Default?displayProperty=nameWithType> e também tem a chave pai <xref:Microsoft.Win32.RegistryKeyPermissionCheck.Default?displayProperty=nameWithType>. Se a chave pai tiver qualquer outra configuração, o status de leitura/gravação é controlado pela configuração da chave pai.  
  
 Para executar esta ação, o usuário deve ter permissões neste nível e abaixo na hierarquia do registro.  
  
> [!CAUTION]
>  Não exponha objetos <xref:Microsoft.Win32.RegistryKey> de maneira que um programa mal-intencionado possa criar milhares de subchaves sem sentido ou os pares de chave/valor. Por exemplo, não permita que chamadores insiram chaves ou valores arbitrários.  
  
 Para usar o método <xref:Microsoft.Win32.RegistryKey.OpenSubKey%2A>, você deve ter uma instância da classe <xref:Microsoft.Win32.RegistryKey>. Para obter uma instância de <xref:Microsoft.Win32.RegistryKey>, use um dos membros estáticos da classe <xref:Microsoft.Win32.Registry>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="subkey" /> is <see langword="null" />.</exception>
        <exception cref="T:System.Security.SecurityException">The user does not have the permissions required to create or open the registry key.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="permissionCheck" /> contains an invalid value.</exception>
        <exception cref="T:System.ObjectDisposedException">The <see cref="T:Microsoft.Win32.RegistryKey" /> on which this method is being invoked is closed (closed keys cannot be accessed).</exception>
        <exception cref="T:System.UnauthorizedAccessException">The current <see cref="T:Microsoft.Win32.RegistryKey" /> cannot be written to; for example, it was not opened as a writable key, or the user does not have the necessary access rights.</exception>
        <exception cref="T:System.IO.IOException">The nesting level exceeds 510.  -or-  A system error occurred, such as deletion of the key, or an attempt to create a key in the <see cref="F:Microsoft.Win32.Registry.LocalMachine" /> root.</exception>
        <permission cref="T:System.Security.Permissions.RegistryPermission">a capacidade de modificar a chave de registro especificado se ele existir, ou para a capacidade de criar a chave do registro em caso de ele ainda não existir. Enumerações associadas: <see cref="F:System.Security.Permissions.RegistryPermissionAccess.Write" />, <see cref="F:System.Security.Permissions.RegistryPermissionAccess.Create" /></permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">para a capacidade de acessar a chave do Registro especificada caso ela seja uma chave remota. Enumeração associada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="M:Microsoft.Win32.RegistryKey.DeleteSubKey(System.String)" />
        <altmember cref="M:Microsoft.Win32.RegistryKey.OpenSubKey(System.String,System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="CreateSubKey">
      <MemberSignature Language="C#" Value="public Microsoft.Win32.RegistryKey CreateSubKey (string subkey, bool writable, Microsoft.Win32.RegistryOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class Microsoft.Win32.RegistryKey CreateSubKey(string subkey, bool writable, valuetype Microsoft.Win32.RegistryOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Win32.RegistryKey.CreateSubKey(System.String,System.Boolean,Microsoft.Win32.RegistryOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateSubKey (subkey As String, writable As Boolean, options As RegistryOptions) As RegistryKey" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Microsoft::Win32::RegistryKey ^ CreateSubKey(System::String ^ subkey, bool writable, Microsoft::Win32::RegistryOptions options);" />
      <MemberSignature Language="F#" Value="member this.CreateSubKey : string * bool * Microsoft.Win32.RegistryOptions -&gt; Microsoft.Win32.RegistryKey" Usage="registryKey.CreateSubKey (subkey, writable, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.RegistryKey</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="subkey" Type="System.String" />
        <Parameter Name="writable" Type="System.Boolean" />
        <Parameter Name="options" Type="Microsoft.Win32.RegistryOptions" />
      </Parameters>
      <Docs>
        <param name="subkey">The name or path of the subkey to create or open. This string is not case-sensitive.</param>
        <param name="writable">
          <see langword="true" /> to indicate the new subkey is writable; otherwise, <see langword="false" />.</param>
        <param name="options">The registry option to use.</param>
        <summary>Creates a new subkey or opens an existing subkey with the specified access.  Available starting in [!INCLUDE[net_v46](~/includes/net-v46-md.md)]</summary>
        <returns>The newly created subkey, or <see langword="null" /> if the operation failed. If a zero-length string is specified for <paramref name="subkey" />, the current <see cref="T:Microsoft.Win32.RegistryKey" /> object is returned.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para executar esta ação, o usuário deve ter permissão neste nível e abaixo na hierarquia do registro.  
  
> [!CAUTION]
>  Não exponha objetos <xref:Microsoft.Win32.RegistryKey> de maneira que um programa mal-intencionado possa criar milhares de subchaves sem sentido ou os pares de chave/valor. Por exemplo, não permita que chamadores insiram chaves ou valores arbitrários.  
  
 Para usar o método <xref:Microsoft.Win32.RegistryKey.CreateSubKey%2A>, você deve ter uma instância da classe <xref:Microsoft.Win32.RegistryKey>. Para obter uma instância de <xref:Microsoft.Win32.RegistryKey>, use um dos membros estáticos da classe <xref:Microsoft.Win32.Registry>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="subkey" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="options" /> does not specify a valid Option</exception>
        <exception cref="T:System.Security.SecurityException">The user does not have the permissions required to create or open the registry key.</exception>
        <exception cref="T:System.UnauthorizedAccessException">The current <see cref="T:Microsoft.Win32.RegistryKey" /> cannot be written to; for example, it was not opened as a writable key, or the user does not have the necessary access rights.</exception>
        <exception cref="T:System.IO.IOException">The nesting level exceeds 510.  -or-  A system error occurred, such as deletion of the key, or an attempt to create a key in the <see cref="F:Microsoft.Win32.Registry.LocalMachine" /> root.</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateSubKey">
      <MemberSignature Language="C#" Value="public Microsoft.Win32.RegistryKey CreateSubKey (string subkey, Microsoft.Win32.RegistryKeyPermissionCheck permissionCheck, Microsoft.Win32.RegistryOptions options);" FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class Microsoft.Win32.RegistryKey CreateSubKey(string subkey, valuetype Microsoft.Win32.RegistryKeyPermissionCheck permissionCheck, valuetype Microsoft.Win32.RegistryOptions options) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Win32.RegistryKey.CreateSubKey(System.String,Microsoft.Win32.RegistryKeyPermissionCheck,Microsoft.Win32.RegistryOptions)" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0" />
      <MemberSignature Language="C#" Value="public Microsoft.Win32.RegistryKey CreateSubKey (string subkey, Microsoft.Win32.RegistryKeyPermissionCheck permissionCheck, Microsoft.Win32.RegistryOptions registryOptions);" FrameworkAlternate="netcore-2.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class Microsoft.Win32.RegistryKey CreateSubKey(string subkey, valuetype Microsoft.Win32.RegistryKeyPermissionCheck permissionCheck, valuetype Microsoft.Win32.RegistryOptions registryOptions) cil managed" FrameworkAlternate="netcore-2.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Microsoft::Win32::RegistryKey ^ CreateSubKey(System::String ^ subkey, Microsoft::Win32::RegistryKeyPermissionCheck permissionCheck, Microsoft::Win32::RegistryOptions options);" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateSubKey (subkey As String, permissionCheck As RegistryKeyPermissionCheck, options As RegistryOptions) As RegistryKey" />
      <MemberSignature Language="F#" Value="member this.CreateSubKey : string * Microsoft.Win32.RegistryKeyPermissionCheck * Microsoft.Win32.RegistryOptions -&gt; Microsoft.Win32.RegistryKey" Usage="registryKey.CreateSubKey (subkey, permissionCheck, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.RegistryKey</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="subkey" Type="System.String" Index="0" />
        <Parameter Name="permissionCheck" Type="Microsoft.Win32.RegistryKeyPermissionCheck" Index="1" />
        <Parameter Name="options" Type="Microsoft.Win32.RegistryOptions" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0" />
        <Parameter Name="registryOptions" Type="Microsoft.Win32.RegistryOptions" Index="2" FrameworkAlternate="netcore-2.0" />
      </Parameters>
      <Docs>
        <param name="subkey">The name or path of the subkey to create or open.</param>
        <param name="permissionCheck">One of the enumeration values that specifies whether the key is opened for read or read/write access.</param>
        <param name="options">The registry option to use; for example, that creates a volatile key.</param>
        <param name="registryOptions">To be added.</param>
        <summary>Creates a subkey or opens a subkey for write access, using the specified permission check and registry options.</summary>
        <returns>The newly created subkey, or <see langword="null" /> if the operation failed.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para obter atual <xref:Microsoft.Win32.RegistryKey> de objeto, especifique uma cadeia de caracteres vazia ("") para `subkey`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="subkey" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ObjectDisposedException">The current <see cref="T:Microsoft.Win32.RegistryKey" /> object is closed (closed keys cannot be accessed).</exception>
        <exception cref="T:System.UnauthorizedAccessException">The current <see cref="T:Microsoft.Win32.RegistryKey" /> object cannot be written to; for example, it was not opened as a writable key, or the user does not have the required access rights.</exception>
        <exception cref="T:System.IO.IOException">The nesting level exceeds 510.  -or-  A system error occurred, such as deletion of the key or an attempt to create a key in the <see cref="F:Microsoft.Win32.Registry.LocalMachine" /> root.</exception>
        <exception cref="T:System.Security.SecurityException">The user does not have the permissions required to create or open the registry key.</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateSubKey">
      <MemberSignature Language="C#" Value="public Microsoft.Win32.RegistryKey CreateSubKey (string subkey, Microsoft.Win32.RegistryKeyPermissionCheck permissionCheck, Microsoft.Win32.RegistryOptions registryOptions, System.Security.AccessControl.RegistrySecurity registrySecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class Microsoft.Win32.RegistryKey CreateSubKey(string subkey, valuetype Microsoft.Win32.RegistryKeyPermissionCheck permissionCheck, valuetype Microsoft.Win32.RegistryOptions registryOptions, class System.Security.AccessControl.RegistrySecurity registrySecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Win32.RegistryKey.CreateSubKey(System.String,Microsoft.Win32.RegistryKeyPermissionCheck,Microsoft.Win32.RegistryOptions,System.Security.AccessControl.RegistrySecurity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Microsoft::Win32::RegistryKey ^ CreateSubKey(System::String ^ subkey, Microsoft::Win32::RegistryKeyPermissionCheck permissionCheck, Microsoft::Win32::RegistryOptions registryOptions, System::Security::AccessControl::RegistrySecurity ^ registrySecurity);" />
      <MemberSignature Language="F#" Value="member this.CreateSubKey : string * Microsoft.Win32.RegistryKeyPermissionCheck * Microsoft.Win32.RegistryOptions * System.Security.AccessControl.RegistrySecurity -&gt; Microsoft.Win32.RegistryKey" Usage="registryKey.CreateSubKey (subkey, permissionCheck, registryOptions, registrySecurity)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.RegistryKey</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="subkey" Type="System.String" />
        <Parameter Name="permissionCheck" Type="Microsoft.Win32.RegistryKeyPermissionCheck" />
        <Parameter Name="registryOptions" Type="Microsoft.Win32.RegistryOptions" />
        <Parameter Name="registrySecurity" Type="System.Security.AccessControl.RegistrySecurity" />
      </Parameters>
      <Docs>
        <param name="subkey">The name or path of the subkey to create or open.</param>
        <param name="permissionCheck">One of the enumeration values that specifies whether the key is opened for read or read/write access.</param>
        <param name="registryOptions">The registry option to use.</param>
        <param name="registrySecurity">The access control security for the new subkey.</param>
        <summary>Creates a subkey or opens a subkey for write access, using the specified permission check option, registry option, and registry security.</summary>
        <returns>The newly created subkey, or <see langword="null" /> if the operation failed.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para obter atual <xref:Microsoft.Win32.RegistryKey> de objeto, especifique uma cadeia de caracteres vazia ("") para `subkey`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="subkey" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ObjectDisposedException">The current <see cref="T:Microsoft.Win32.RegistryKey" /> object is closed. Closed keys cannot be accessed.</exception>
        <exception cref="T:System.UnauthorizedAccessException">The current <see cref="T:Microsoft.Win32.RegistryKey" /> object cannot be written to; for example, it was not opened as a writable key, or the user does not have the required access rights.</exception>
        <exception cref="T:System.IO.IOException">The nesting level exceeds 510.  -or-  A system error occurred, such as deletion of the key or an attempt to create a key in the <see cref="F:Microsoft.Win32.Registry.LocalMachine" /> root.</exception>
        <exception cref="T:System.Security.SecurityException">The user does not have the permissions required to create or open the registry key.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="DeleteSubKey">
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Deletes the specified subkey.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="DeleteSubKey">
      <MemberSignature Language="C#" Value="public void DeleteSubKey (string subkey);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DeleteSubKey(string subkey) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Win32.RegistryKey.DeleteSubKey(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub DeleteSubKey (subkey As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DeleteSubKey(System::String ^ subkey);" />
      <MemberSignature Language="F#" Value="member this.DeleteSubKey : string -&gt; unit" Usage="registryKey.DeleteSubKey subkey" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="subkey" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="subkey">The name of the subkey to delete. This string is not case-sensitive.</param>
        <summary>Deletes the specified subkey.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para excluir as subchaves filho, use <xref:Microsoft.Win32.RegistryKey.DeleteSubKeyTree%2A>.  
  
 Tenha cuidado ao excluir chaves do registro.  
  
   
  
## Examples  
 O exemplo a seguir demonstra como usar <xref:Microsoft.Win32.RegistryKey.DeleteSubKey%2A>.  
  
 [!code-cpp[Microsoft.Win32.RegistryKey2#5](~/samples/snippets/cpp/VS_Snippets_CLR/Microsoft.Win32.RegistryKey2/CPP/source2.cpp#5)]
 [!code-csharp[Microsoft.Win32.RegistryKey2#5](~/samples/snippets/csharp/VS_Snippets_CLR/Microsoft.Win32.RegistryKey2/CS/source2.cs#5)]
 [!code-vb[Microsoft.Win32.RegistryKey2#5](~/samples/snippets/visualbasic/VS_Snippets_CLR/Microsoft.Win32.RegistryKey2/VB/source2.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">The <paramref name="subkey" /> has child subkeys</exception>
        <exception cref="T:System.ArgumentException">The <paramref name="subkey" /> parameter does not specify a valid registry key</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="subkey" /> is <see langword="null" /></exception>
        <exception cref="T:System.Security.SecurityException">The user does not have the permissions required to delete the key.</exception>
        <exception cref="T:System.ObjectDisposedException">The <see cref="T:Microsoft.Win32.RegistryKey" /> being manipulated is closed (closed keys cannot be accessed).</exception>
        <exception cref="T:System.UnauthorizedAccessException">The user does not have the necessary registry rights.</exception>
        <permission cref="T:System.Security.Permissions.RegistryPermission">para a capacidade de modificar a chave do Registro especificada. Enumeração associada: <see cref="F:System.Security.Permissions.RegistryPermissionAccess.Write" /></permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">para a capacidade de acessar a chave do Registro especificada caso ela seja uma chave remota. Enumeração associada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="M:Microsoft.Win32.RegistryKey.DeleteSubKeyTree(System.String)" />
        <altmember cref="M:Microsoft.Win32.RegistryKey.CreateSubKey(System.String)" />
        <altmember cref="M:Microsoft.Win32.RegistryKey.DeleteValue(System.String)" />
        <altmember cref="M:Microsoft.Win32.RegistryKey.GetSubKeyNames" />
      </Docs>
    </Member>
    <Member MemberName="DeleteSubKey">
      <MemberSignature Language="C#" Value="public void DeleteSubKey (string subkey, bool throwOnMissingSubKey);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DeleteSubKey(string subkey, bool throwOnMissingSubKey) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Win32.RegistryKey.DeleteSubKey(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub DeleteSubKey (subkey As String, throwOnMissingSubKey As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DeleteSubKey(System::String ^ subkey, bool throwOnMissingSubKey);" />
      <MemberSignature Language="F#" Value="member this.DeleteSubKey : string * bool -&gt; unit" Usage="registryKey.DeleteSubKey (subkey, throwOnMissingSubKey)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="subkey" Type="System.String" />
        <Parameter Name="throwOnMissingSubKey" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="subkey">The name of the subkey to delete. This string is not case-sensitive.</param>
        <param name="throwOnMissingSubKey">Indicates whether an exception should be raised if the specified subkey cannot be found. If this argument is <see langword="true" /> and the specified subkey does not exist, an exception is raised. If this argument is <see langword="false" /> and the specified subkey does not exist, no action is taken.</param>
        <summary>Deletes the specified subkey, and specifies whether an exception is raised if the subkey is not found.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para excluir as subchaves filho, use <xref:Microsoft.Win32.RegistryKey.DeleteSubKeyTree%2A>.  
  
 Tenha cuidado ao excluir chaves do registro.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="subkey" /> has child subkeys.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="subkey" /> does not specify a valid registry key, and <paramref name="throwOnMissingSubKey" /> is <see langword="true" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="subkey" /> is <see langword="null" />.</exception>
        <exception cref="T:System.Security.SecurityException">The user does not have the permissions required to delete the key.</exception>
        <exception cref="T:System.ObjectDisposedException">The <see cref="T:Microsoft.Win32.RegistryKey" /> being manipulated is closed (closed keys cannot be accessed).</exception>
        <exception cref="T:System.UnauthorizedAccessException">The user does not have the necessary registry rights.</exception>
        <permission cref="T:System.Security.Permissions.RegistryPermission">para a capacidade de modificar a chave do Registro especificada. Enumeração associada: <see cref="F:System.Security.Permissions.RegistryPermissionAccess.Write" /></permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">para a capacidade de acessar a chave do Registro especificada caso ela seja uma chave remota. Enumeração associada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="M:Microsoft.Win32.RegistryKey.DeleteSubKeyTree(System.String)" />
        <altmember cref="M:Microsoft.Win32.RegistryKey.CreateSubKey(System.String)" />
        <altmember cref="M:Microsoft.Win32.RegistryKey.DeleteValue(System.String)" />
        <altmember cref="M:Microsoft.Win32.RegistryKey.GetSubKeyNames" />
      </Docs>
    </Member>
    <MemberGroup MemberName="DeleteSubKeyTree">
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Deletes a subkey and any child subkeys recursively, with optional exception handling.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="DeleteSubKeyTree">
      <MemberSignature Language="C#" Value="public void DeleteSubKeyTree (string subkey);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DeleteSubKeyTree(string subkey) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Win32.RegistryKey.DeleteSubKeyTree(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub DeleteSubKeyTree (subkey As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DeleteSubKeyTree(System::String ^ subkey);" />
      <MemberSignature Language="F#" Value="member this.DeleteSubKeyTree : string -&gt; unit" Usage="registryKey.DeleteSubKeyTree subkey" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="subkey" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="subkey">The subkey to delete. This string is not case-sensitive.</param>
        <summary>Deletes a subkey and any child subkeys recursively.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Você deve ter permissões adequadas para excluir a subchave e sua árvore.  
  
> [!CAUTION]
>  Excluir uma determinada chave removerá todas as entradas abaixo da chave na árvore. Nenhum aviso será fornecido. Se você quiser excluir uma subchave somente quando ele tem subchaves nenhum filho, use o <xref:Microsoft.Win32.RegistryKey.DeleteSubKey%2A> método.  
  
   
  
## Examples  
 Este exemplo de código é parte de um exemplo maior fornecido para a <xref:Microsoft.Win32.RegistryKey> classe.  
  
 [!code-cpp[Microsoft.Win32.RegistryKey2#4](~/samples/snippets/cpp/VS_Snippets_CLR/Microsoft.Win32.RegistryKey2/CPP/source.cpp#4)]
 [!code-csharp[Microsoft.Win32.RegistryKey2#4](~/samples/snippets/csharp/VS_Snippets_CLR/Microsoft.Win32.RegistryKey2/CS/source.cs#4)]
 [!code-vb[Microsoft.Win32.RegistryKey2#4](~/samples/snippets/visualbasic/VS_Snippets_CLR/Microsoft.Win32.RegistryKey2/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="subkey" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Deletion of a root hive is attempted.  -or-  <paramref name="subkey" /> does not specify a valid registry subkey.</exception>
        <exception cref="T:System.IO.IOException">An I/O error has occurred.</exception>
        <exception cref="T:System.Security.SecurityException">The user does not have the permissions required to delete the key.</exception>
        <exception cref="T:System.ObjectDisposedException">The <see cref="T:Microsoft.Win32.RegistryKey" /> being manipulated is closed (closed keys cannot be accessed).</exception>
        <exception cref="T:System.UnauthorizedAccessException">The user does not have the necessary registry rights.</exception>
        <permission cref="T:System.Security.Permissions.RegistryPermission">para a capacidade de modificar a chave do Registro especificada. Enumeração associada: <see cref="F:System.Security.Permissions.RegistryPermissionAccess.Write" /></permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">para a capacidade de acessar a chave do Registro especificada caso ela seja uma chave remota. Enumeração associada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="M:Microsoft.Win32.RegistryKey.DeleteSubKey(System.String)" />
        <altmember cref="M:Microsoft.Win32.RegistryKey.CreateSubKey(System.String)" />
        <altmember cref="M:Microsoft.Win32.RegistryKey.DeleteValue(System.String)" />
        <altmember cref="M:Microsoft.Win32.RegistryKey.GetSubKeyNames" />
        <altmember cref="P:Microsoft.Win32.RegistryKey.SubKeyCount" />
      </Docs>
    </Member>
    <Member MemberName="DeleteSubKeyTree">
      <MemberSignature Language="C#" Value="public void DeleteSubKeyTree (string subkey, bool throwOnMissingSubKey);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DeleteSubKeyTree(string subkey, bool throwOnMissingSubKey) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Win32.RegistryKey.DeleteSubKeyTree(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub DeleteSubKeyTree (subkey As String, throwOnMissingSubKey As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DeleteSubKeyTree(System::String ^ subkey, bool throwOnMissingSubKey);" />
      <MemberSignature Language="F#" Value="member this.DeleteSubKeyTree : string * bool -&gt; unit" Usage="registryKey.DeleteSubKeyTree (subkey, throwOnMissingSubKey)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="subkey" Type="System.String" />
        <Parameter Name="throwOnMissingSubKey" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="subkey">The name of the subkey to delete. This string is not case-sensitive.</param>
        <param name="throwOnMissingSubKey">Indicates whether an exception should be raised if the specified subkey cannot be found. If this argument is <see langword="true" /> and the specified subkey does not exist, an exception is raised. If this argument is <see langword="false" /> and the specified subkey does not exist, no action is taken.</param>
        <summary>Deletes the specified subkey and any child subkeys recursively, and specifies whether an exception is raised if the subkey is not found.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException">An attempt was made to delete the root hive of the tree.  -or-  <paramref name="subkey" /> does not specify a valid registry subkey, and <paramref name="throwOnMissingSubKey" /> is <see langword="true" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="subkey" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ObjectDisposedException">The <see cref="T:Microsoft.Win32.RegistryKey" /> is closed (closed keys cannot be accessed).</exception>
        <exception cref="T:System.UnauthorizedAccessException">The user does not have the necessary registry rights.</exception>
        <exception cref="T:System.Security.SecurityException">The user does not have the permissions required to delete the key.</exception>
        <permission cref="T:System.Security.Permissions.RegistryPermission">para a capacidade de modificar a chave do Registro especificada. Enumeração associada: <see cref="F:System.Security.Permissions.RegistryPermissionAccess.Write" /></permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">para a capacidade de acessar a chave do Registro especificada caso ela seja uma chave remota. Enumeração associada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="DeleteValue">
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Deletes the specified value from this key, and throws an exception if the value is not found.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="DeleteValue">
      <MemberSignature Language="C#" Value="public void DeleteValue (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DeleteValue(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Win32.RegistryKey.DeleteValue(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub DeleteValue (name As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DeleteValue(System::String ^ name);" />
      <MemberSignature Language="F#" Value="member this.DeleteValue : string -&gt; unit" Usage="registryKey.DeleteValue name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">The name of the value to delete.</param>
        <summary>Deletes the specified value from this key.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 No Windows 95, Windows 98, Windows 98 Segunda edição e Windows Millennium Edition, especificando uma cadeia de caracteres vazia para o `name` parâmetro não exclui o valor padrão.  
  
   
  
## Examples  
 Este exemplo de código é parte de um exemplo maior fornecido para a <xref:Microsoft.Win32.RegistryKey> classe.  
  
 [!code-cpp[Microsoft.Win32.RegistryKey2#3](~/samples/snippets/cpp/VS_Snippets_CLR/Microsoft.Win32.RegistryKey2/CPP/source.cpp#3)]
 [!code-csharp[Microsoft.Win32.RegistryKey2#3](~/samples/snippets/csharp/VS_Snippets_CLR/Microsoft.Win32.RegistryKey2/CS/source.cs#3)]
 [!code-vb[Microsoft.Win32.RegistryKey2#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/Microsoft.Win32.RegistryKey2/VB/source.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> is not a valid reference to a value.</exception>
        <exception cref="T:System.Security.SecurityException">The user does not have the permissions required to delete the value.</exception>
        <exception cref="T:System.ObjectDisposedException">The <see cref="T:Microsoft.Win32.RegistryKey" /> being manipulated is closed (closed keys cannot be accessed).</exception>
        <exception cref="T:System.UnauthorizedAccessException">The <see cref="T:Microsoft.Win32.RegistryKey" /> being manipulated is read-only.</exception>
        <permission cref="T:System.Security.Permissions.RegistryPermission">a capacidade de excluir a chave do Registro especificada. Enumerações associadas: <see cref="F:System.Security.Permissions.RegistryPermissionAccess.Write" /></permission>
        <altmember cref="M:Microsoft.Win32.RegistryKey.DeleteSubKey(System.String)" />
        <altmember cref="M:Microsoft.Win32.RegistryKey.OpenSubKey(System.String,System.Boolean)" />
        <altmember cref="M:Microsoft.Win32.RegistryKey.GetValue(System.String)" />
        <altmember cref="M:Microsoft.Win32.RegistryKey.GetValueNames" />
        <altmember cref="P:Microsoft.Win32.RegistryKey.ValueCount" />
      </Docs>
    </Member>
    <Member MemberName="DeleteValue">
      <MemberSignature Language="C#" Value="public void DeleteValue (string name, bool throwOnMissingValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DeleteValue(string name, bool throwOnMissingValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Win32.RegistryKey.DeleteValue(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub DeleteValue (name As String, throwOnMissingValue As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DeleteValue(System::String ^ name, bool throwOnMissingValue);" />
      <MemberSignature Language="F#" Value="member this.DeleteValue : string * bool -&gt; unit" Usage="registryKey.DeleteValue (name, throwOnMissingValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="throwOnMissingValue" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="name">The name of the value to delete.</param>
        <param name="throwOnMissingValue">Indicates whether an exception should be raised if the specified value cannot be found. If this argument is <see langword="true" /> and the specified value does not exist, an exception is raised. If this argument is <see langword="false" /> and the specified value does not exist, no action is taken.</param>
        <summary>Deletes the specified value from this key, and specifies whether an exception is raised if the value is not found.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se `throwOnMissingValue` é `false`, não é possível saber se a exclusão foi bem-sucedida, sem tentar acessar o valor excluído apenas posteriormente. Portanto, tenha cuidado ao excluir os valores do registro dessa maneira.  
  
 No Windows 95, Windows 98, Windows 98 Segunda edição e Windows Millennium Edition, especificando uma cadeia de caracteres vazia para o `name` parâmetro não exclui o valor padrão.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> is not a valid reference to a value and <paramref name="throwOnMissingValue" /> is <see langword="true" />.  -or-  <paramref name="name" /> is <see langword="null" />.</exception>
        <exception cref="T:System.Security.SecurityException">The user does not have the permissions required to delete the value.</exception>
        <exception cref="T:System.ObjectDisposedException">The <see cref="T:Microsoft.Win32.RegistryKey" /> being manipulated is closed (closed keys cannot be accessed).</exception>
        <exception cref="T:System.UnauthorizedAccessException">The <see cref="T:Microsoft.Win32.RegistryKey" /> being manipulated is read-only.</exception>
        <permission cref="T:System.Security.Permissions.RegistryPermission">a capacidade de excluir a chave do Registro especificada. Enumerações associadas: <see cref="F:System.Security.Permissions.RegistryPermissionAccess.Write" /></permission>
        <altmember cref="M:Microsoft.Win32.RegistryKey.DeleteSubKey(System.String)" />
        <altmember cref="M:Microsoft.Win32.RegistryKey.OpenSubKey(System.String,System.Boolean)" />
        <altmember cref="M:Microsoft.Win32.RegistryKey.GetValue(System.String)" />
        <altmember cref="M:Microsoft.Win32.RegistryKey.GetValueNames" />
        <altmember cref="P:Microsoft.Win32.RegistryKey.ValueCount" />
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Win32.RegistryKey.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberSignature Language="F#" Value="abstract member Dispose : unit -&gt; unit&#xA;override this.Dispose : unit -&gt; unit" Usage="registryKey.Dispose " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Releases all resources used by the current instance of the <see cref="T:Microsoft.Win32.RegistryKey" /> class.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Chamar `Dispose` quando tiver terminado de usar o <xref:Microsoft.Win32.RegistryKey>. O `Dispose` método deixa o <xref:Microsoft.Win32.RegistryKey> em um estado inutilizável. Depois de chamar `Dispose`, você deve liberar todas as referências para o <xref:Microsoft.Win32.RegistryKey> para o coletor de lixo possa recuperar a memória que o <xref:Microsoft.Win32.RegistryKey> estava ocupando.  
  
 Para obter mais informações, consulte [limpeza de recursos não gerenciados](~/docs/standard/garbage-collection/unmanaged.md) e [implementar um método Dispose](~/docs/standard/garbage-collection/implementing-dispose.md).  
  
> [!NOTE]
>  Sempre chamar `Dispose` antes de liberar sua última referência para o <xref:Microsoft.Win32.RegistryKey>. Caso contrário, os recursos que está usando não serão liberados até que o coletor de lixo chame o <xref:Microsoft.Win32.RegistryKey> do objeto `Finalize` método.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Flush">
      <MemberSignature Language="C#" Value="public void Flush ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Flush() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Win32.RegistryKey.Flush" />
      <MemberSignature Language="VB.NET" Value="Public Sub Flush ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Flush();" />
      <MemberSignature Language="F#" Value="member this.Flush : unit -&gt; unit" Usage="registryKey.Flush " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Writes all the attributes of the specified open registry key into the registry.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Não é necessário chamar `Flush` para gravar as alterações para uma chave. Alterações no registro são liberadas para disco quando o liberador lento do usa o registro. Liberando lento ocorre regularmente e automaticamente após um intervalo de tempo especificado pelo sistema. Alterações no registro também são liberadas para o disco no desligamento do sistema.  
  
 Ao contrário de <xref:Microsoft.Win32.RegistryKey.Close%2A>, o `Flush` função retorna somente quando todos os dados foram gravadas no registro.  
  
 O `Flush` função também pode gravar partes de ou todas as outras chaves. Chamar essa função excessivamente pode ter um efeito negativo no desempenho de um aplicativo.  
  
 Um aplicativo só deve chamar `Flush` se ele deve ser absoluto determinados que alterações de registro são gravadas no disco. Em geral, `Flush` raramente, ou nunca, precisa ser usado.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.Win32.RegistryKey.Close" />
      </Docs>
    </Member>
    <MemberGroup MemberName="FromHandle">
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Creates a registry key from a specified handle.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="FromHandle">
      <MemberSignature Language="C#" Value="public static Microsoft.Win32.RegistryKey FromHandle (Microsoft.Win32.SafeHandles.SafeRegistryHandle handle);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.Win32.RegistryKey FromHandle(class Microsoft.Win32.SafeHandles.SafeRegistryHandle handle) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Win32.RegistryKey.FromHandle(Microsoft.Win32.SafeHandles.SafeRegistryHandle)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FromHandle (handle As SafeRegistryHandle) As RegistryKey" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Microsoft::Win32::RegistryKey ^ FromHandle(Microsoft::Win32::SafeHandles::SafeRegistryHandle ^ handle);" />
      <MemberSignature Language="F#" Value="static member FromHandle : Microsoft.Win32.SafeHandles.SafeRegistryHandle -&gt; Microsoft.Win32.RegistryKey" Usage="Microsoft.Win32.RegistryKey.FromHandle handle" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.RegistryKey</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="handle" Type="Microsoft.Win32.SafeHandles.SafeRegistryHandle" />
      </Parameters>
      <Docs>
        <param name="handle">The handle to the registry key.</param>
        <summary>Creates a registry key from a specified handle.</summary>
        <returns>A registry key.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="handle" /> is <see langword="null" />.</exception>
        <exception cref="T:System.UnauthorizedAccessException">The user does not have the necessary registry rights.</exception>
        <exception cref="T:System.Security.SecurityException">The user does not have the permissions required to perform this action.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requer confiança total para o chamador imediato. Este membro não pode ser usado pelo código transparente ou parcialmente confiável.</permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">para a capacidade de acessar a chave do Registro especificada caso ela seja uma chave remota. Enumeração associada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
    <Member MemberName="FromHandle">
      <MemberSignature Language="C#" Value="public static Microsoft.Win32.RegistryKey FromHandle (Microsoft.Win32.SafeHandles.SafeRegistryHandle handle, Microsoft.Win32.RegistryView view);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.Win32.RegistryKey FromHandle(class Microsoft.Win32.SafeHandles.SafeRegistryHandle handle, valuetype Microsoft.Win32.RegistryView view) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Win32.RegistryKey.FromHandle(Microsoft.Win32.SafeHandles.SafeRegistryHandle,Microsoft.Win32.RegistryView)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FromHandle (handle As SafeRegistryHandle, view As RegistryView) As RegistryKey" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Microsoft::Win32::RegistryKey ^ FromHandle(Microsoft::Win32::SafeHandles::SafeRegistryHandle ^ handle, Microsoft::Win32::RegistryView view);" />
      <MemberSignature Language="F#" Value="static member FromHandle : Microsoft.Win32.SafeHandles.SafeRegistryHandle * Microsoft.Win32.RegistryView -&gt; Microsoft.Win32.RegistryKey" Usage="Microsoft.Win32.RegistryKey.FromHandle (handle, view)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.RegistryKey</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="handle" Type="Microsoft.Win32.SafeHandles.SafeRegistryHandle" />
        <Parameter Name="view" Type="Microsoft.Win32.RegistryView" />
      </Parameters>
      <Docs>
        <param name="handle">The handle to the registry key.</param>
        <param name="view">The registry view to use.</param>
        <summary>Creates a registry key from a specified handle and registry view setting.</summary>
        <returns>A registry key.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O `view` parâmetro para este método é usado em operações subsequentes, como abrir subchaves.  
  
 Se `view` é <xref:Microsoft.Win32.RegistryView.Registry64> , mas o computador está executando um sistema operacional de 32 bits, a chave retornada usará o <xref:Microsoft.Win32.RegistryView.Registry32> exibição.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="view" /> is invalid.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="handle" /> is <see langword="null" />.</exception>
        <exception cref="T:System.UnauthorizedAccessException">The user does not have the necessary registry rights.</exception>
        <exception cref="T:System.Security.SecurityException">The user does not have the permissions required to perform this action.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requer confiança total para o chamador imediato. Este membro não pode ser usado pelo código transparente ou parcialmente confiável.</permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">para a capacidade de acessar a chave do Registro especificada caso ela seja uma chave remota. Enumeração associada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetAccessControl">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Returns the access control security for the current registry key.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetAccessControl">
      <MemberSignature Language="C#" Value="public System.Security.AccessControl.RegistrySecurity GetAccessControl ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Security.AccessControl.RegistrySecurity GetAccessControl() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Win32.RegistryKey.GetAccessControl" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAccessControl () As RegistrySecurity" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Security::AccessControl::RegistrySecurity ^ GetAccessControl();" />
      <MemberSignature Language="F#" Value="member this.GetAccessControl : unit -&gt; System.Security.AccessControl.RegistrySecurity" Usage="registryKey.GetAccessControl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.AccessControl.RegistrySecurity</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Returns the access control security for the current registry key.</summary>
        <returns>An object that describes the access control permissions on the registry key represented by the current <see cref="T:Microsoft.Win32.RegistryKey" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Essa sobrecarga de método é equivalente a chamar o <xref:Microsoft.Win32.RegistryKey.GetAccessControl%28System.Security.AccessControl.AccessControlSections%29> sobrecarga de método com a combinação de bit a bit dos sinalizadores a seguir: <xref:System.Security.AccessControl.AccessControlSections.Access?displayProperty=nameWithType>, <xref:System.Security.AccessControl.AccessControlSections.Owner?displayProperty=nameWithType>, e <xref:System.Security.AccessControl.AccessControlSections.Group?displayProperty=nameWithType>. Você pode usar essa sobrecarga para procurar outras permissões.  
  
 O usuário deve ter <xref:System.Security.AccessControl.RegistryRights.ReadPermissions?displayProperty=nameWithType> direitos para chamar esse método.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">The user does not have the necessary permissions.</exception>
        <exception cref="T:System.ObjectDisposedException">The <see cref="T:Microsoft.Win32.RegistryKey" /> being manipulated is closed (closed keys cannot be accessed).</exception>
        <exception cref="T:System.InvalidOperationException">The current key has been deleted.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetAccessControl">
      <MemberSignature Language="C#" Value="public System.Security.AccessControl.RegistrySecurity GetAccessControl (System.Security.AccessControl.AccessControlSections includeSections);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Security.AccessControl.RegistrySecurity GetAccessControl(valuetype System.Security.AccessControl.AccessControlSections includeSections) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Win32.RegistryKey.GetAccessControl(System.Security.AccessControl.AccessControlSections)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAccessControl (includeSections As AccessControlSections) As RegistrySecurity" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Security::AccessControl::RegistrySecurity ^ GetAccessControl(System::Security::AccessControl::AccessControlSections includeSections);" />
      <MemberSignature Language="F#" Value="member this.GetAccessControl : System.Security.AccessControl.AccessControlSections -&gt; System.Security.AccessControl.RegistrySecurity" Usage="registryKey.GetAccessControl includeSections" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.AccessControl.RegistrySecurity</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="includeSections" Type="System.Security.AccessControl.AccessControlSections" />
      </Parameters>
      <Docs>
        <param name="includeSections">A bitwise combination of enumeration values that specifies the type of security information to get.</param>
        <summary>Returns the specified sections of the access control security for the current registry key.</summary>
        <returns>An object that describes the access control permissions on the registry key represented by the current <see cref="T:Microsoft.Win32.RegistryKey" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para solicitar as permissões de acesso concedidas atualmente para os usuários, especifique a combinação bit a bit dos sinalizadores a seguir: <xref:System.Security.AccessControl.AccessControlSections.Access?displayProperty=nameWithType>, <xref:System.Security.AccessControl.AccessControlSections.Owner?displayProperty=nameWithType>, e <xref:System.Security.AccessControl.AccessControlSections.Group?displayProperty=nameWithType>. Como alternativa, você pode usar o <xref:Microsoft.Win32.RegistryKey.GetAccessControl> sobrecarga de método, que especifica exatamente essa combinação de valores.  
  
 O usuário deve ter <xref:System.Security.AccessControl.RegistryRights.ReadPermissions?displayProperty=nameWithType> direitos para chamar esse método.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">The user does not have the necessary permissions.</exception>
        <exception cref="T:System.ObjectDisposedException">The <see cref="T:Microsoft.Win32.RegistryKey" /> being manipulated is closed (closed keys cannot be accessed).</exception>
        <exception cref="T:System.InvalidOperationException">The current key has been deleted.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetSubKeyNames">
      <MemberSignature Language="C#" Value="public string[] GetSubKeyNames ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] GetSubKeyNames() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Win32.RegistryKey.GetSubKeyNames" />
      <MemberSignature Language="VB.NET" Value="Public Function GetSubKeyNames () As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::String ^&gt; ^ GetSubKeyNames();" />
      <MemberSignature Language="F#" Value="member this.GetSubKeyNames : unit -&gt; string[]" Usage="registryKey.GetSubKeyNames " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retrieves an array of strings that contains all the subkey names.</summary>
        <returns>An array of strings that contains the names of the subkeys for the current key.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método não localizar nomes que não recursivamente. Ele retorna os nomes de nível base do qual ele foi chamado.  
  
   
  
## Examples  
 Este exemplo de código é parte de um exemplo maior fornecido para a <xref:Microsoft.Win32.RegistryKey> classe.  
  
 [!code-cpp[Microsoft.Win32.RegistryKey2#2](~/samples/snippets/cpp/VS_Snippets_CLR/Microsoft.Win32.RegistryKey2/CPP/source.cpp#2)]
 [!code-csharp[Microsoft.Win32.RegistryKey2#2](~/samples/snippets/csharp/VS_Snippets_CLR/Microsoft.Win32.RegistryKey2/CS/source.cs#2)]
 [!code-vb[Microsoft.Win32.RegistryKey2#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/Microsoft.Win32.RegistryKey2/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">The user does not have the permissions required to read from the key.</exception>
        <exception cref="T:System.ObjectDisposedException">The <see cref="T:Microsoft.Win32.RegistryKey" /> being manipulated is closed (closed keys cannot be accessed).</exception>
        <exception cref="T:System.UnauthorizedAccessException">The user does not have the necessary registry rights.</exception>
        <exception cref="T:System.IO.IOException">A system error occurred, for example the current key has been deleted.</exception>
        <permission cref="T:System.Security.Permissions.RegistryPermission">a capacidade de ler a partir do registro. Enumeração associada: <see cref="F:System.Security.Permissions.RegistryPermissionAccess.Read" /></permission>
        <altmember cref="P:Microsoft.Win32.RegistryKey.SubKeyCount" />
        <altmember cref="M:Microsoft.Win32.RegistryKey.GetValueNames" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetValue">
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Retrieves the value associated with the specified name.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetValue">
      <MemberSignature Language="C#" Value="public object GetValue (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object GetValue(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Win32.RegistryKey.GetValue(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetValue (name As String) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ GetValue(System::String ^ name);" />
      <MemberSignature Language="F#" Value="member this.GetValue : string -&gt; obj" Usage="registryKey.GetValue name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">The name of the value to retrieve. This string is not case-sensitive.</param>
        <summary>Retrieves the value associated with the specified name. Returns <see langword="null" /> if the name/value pair does not exist in the registry.</summary>
        <returns>The value associated with <paramref name="name" />, or <see langword="null" /> if <paramref name="name" /> is not found.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Uma chave do Registro pode ter um valor que não está associado a nenhum nome. Quando esse valor sem nome é exibido no Editor do Registro, a cadeia de caracteres "(Default)" é exibida em vez de um nome. Para recuperar esse sem nome de valor, especifique `null` ou cadeia de caracteres vazia ("") para `name`.  
  
 Quando o <xref:Microsoft.Win32.RegistryKey.GetValue%2A> método recupera valores de cadeia de caracteres expansível (<xref:Microsoft.Win32.RegistryValueKind.ExpandString?displayProperty=nameWithType>), ele expande as cadeias de caracteres de ambiente usando dados do ambiente local. Para recuperar valores de cadeia de caracteres expansível do registro em um computador remoto, use o <xref:Microsoft.Win32.RegistryKey.GetValue%28System.String%2CSystem.Object%2CMicrosoft.Win32.RegistryValueOptions%29> sobrecarga do método para especificar que você não quer que cadeias de caracteres de ambiente expandidas.  
  
> [!NOTE]
>  Se um valor que contém expansíveis referências a variáveis de ambiente foi armazenado como uma cadeia de caracteres (<xref:Microsoft.Win32.RegistryValueKind.String?displayProperty=nameWithType>), em vez de como uma cadeia de caracteres expansível (<xref:Microsoft.Win32.RegistryValueKind.ExpandString?displayProperty=nameWithType>), <xref:Microsoft.Win32.RegistryKey.GetValue%2A> não expandi-lo. Você pode expandir uma cadeia de caracteres depois que forem recuperado chamando o <xref:System.Environment.ExpandEnvironmentVariables%2A> método.  
  
> [!NOTE]
>  A maneira recomendada para recuperar dados de <xref:Microsoft.Win32.Registry.PerformanceData> chave é usar o <xref:System.Diagnostics.PerformanceCounter> classe em vez de <xref:Microsoft.Win32.RegistryKey.GetValue%2A?displayProperty=nameWithType> método.  
>   
>  <xref:Microsoft.Win32.RegistryKey.GetValue%2A> não oferece suporte ao ler valores do tipo REG_NONE ou REG_LINK.  Em ambos os casos, o valor padrão (`null`) é retornado em vez do valor real.  
  
   
  
## Examples  
 O exemplo de código a seguir cria uma chave de teste e adiciona valores de diferentes tipos de dados para a chave. O exemplo, em seguida, lê os pares nome/valor e exibe-as no console usando o <xref:Microsoft.Win32.RegistryKey.GetValueKind%2A> método para recuperar os tipos de dados de registro correspondentes.  
  
 [!code-cpp[Microsoft.Win32.RegistryValueKind#1](~/samples/snippets/cpp/VS_Snippets_CLR/Microsoft.Win32.RegistryValueKind/CPP/source.cpp#1)]
 [!code-csharp[Microsoft.Win32.RegistryValueKind#1](~/samples/snippets/csharp/VS_Snippets_CLR/Microsoft.Win32.RegistryValueKind/CS/source.cs#1)]
 [!code-vb[Microsoft.Win32.RegistryValueKind#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Microsoft.Win32.RegistryValueKind/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">The user does not have the permissions required to read from the registry key.</exception>
        <exception cref="T:System.ObjectDisposedException">The <see cref="T:Microsoft.Win32.RegistryKey" /> that contains the specified value is closed (closed keys cannot be accessed).</exception>
        <exception cref="T:System.IO.IOException">The <see cref="T:Microsoft.Win32.RegistryKey" /> that contains the specified value has been marked for deletion.</exception>
        <exception cref="T:System.UnauthorizedAccessException">The user does not have the necessary registry rights.</exception>
        <permission cref="T:System.Security.Permissions.RegistryPermission">para ler do Registro. Enumeração associada: <see cref="F:System.Security.Permissions.RegistryPermissionAccess.Read" /></permission>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">para ler uma chave do registro do tipo REG_EXPAND_SZ. Enumeração associada: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></permission>
        <altmember cref="M:Microsoft.Win32.RegistryKey.GetValueNames" />
        <altmember cref="Overload:Microsoft.Win32.RegistryKey.SetValue" />
        <altmember cref="M:Microsoft.Win32.RegistryKey.DeleteValue(System.String)" />
        <altmember cref="P:Microsoft.Win32.RegistryKey.ValueCount" />
        <altmember cref="M:Microsoft.Win32.RegistryKey.GetSubKeyNames" />
      </Docs>
    </Member>
    <Member MemberName="GetValue">
      <MemberSignature Language="C#" Value="public object GetValue (string name, object defaultValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object GetValue(string name, object defaultValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Win32.RegistryKey.GetValue(System.String,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetValue (name As String, defaultValue As Object) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ GetValue(System::String ^ name, System::Object ^ defaultValue);" />
      <MemberSignature Language="F#" Value="member this.GetValue : string * obj -&gt; obj" Usage="registryKey.GetValue (name, defaultValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="defaultValue" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="name">The name of the value to retrieve. This string is not case-sensitive.</param>
        <param name="defaultValue">The value to return if <c>name</c> does not exist.</param>
        <summary>Retrieves the value associated with the specified name. If the name is not found, returns the default value that you provide.</summary>
        <returns>The value associated with <paramref name="name" />, with any embedded environment variables left unexpanded, or <paramref name="defaultValue" /> if <paramref name="name" /> is not found.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use essa sobrecarga de <xref:Microsoft.Win32.RegistryKey.GetValue%2A> para lidar com o caso em que um nome ainda não existir, por exemplo, a primeira vez que seu aplicativo é executado. Sempre que você chamar essa sobrecarga, use o `defaultValue` parâmetro para especificar o valor a ser retornado se `name` não existe.  
  
> [!NOTE]
>  Uma chave do Registro pode ter um valor que não está associado a nenhum nome. Quando esse valor sem nome é exibido no Editor do Registro, a cadeia de caracteres "(Default)" é exibida em vez de um nome. Para recuperar esse sem nome de valor, especifique `null` ou cadeia de caracteres vazia ("") para `name`.  
  
 Quando o <xref:Microsoft.Win32.RegistryKey.GetValue%2A> método recupera valores de cadeia de caracteres expansível (<xref:Microsoft.Win32.RegistryValueKind.ExpandString?displayProperty=nameWithType>), ele expande as cadeias de caracteres de ambiente usando dados do ambiente local. Para recuperar valores de cadeia de caracteres expansível do registro em um computador remoto, use o <xref:Microsoft.Win32.RegistryKey.GetValue%2A> sobrecarga para especificar que você não quer que cadeias de caracteres de ambiente expandidas.  
  
> [!NOTE]
>  Se um valor que contém expansíveis referências a variáveis de ambiente foi armazenado como uma cadeia de caracteres (<xref:Microsoft.Win32.RegistryValueKind.String?displayProperty=nameWithType>), em vez de como uma cadeia de caracteres expansível (<xref:Microsoft.Win32.RegistryValueKind.ExpandString?displayProperty=nameWithType>), o <xref:Microsoft.Win32.RegistryKey.GetValue%2A> método não expandi-lo. Você pode expandir uma cadeia de caracteres depois que forem recuperado chamando o <xref:System.Environment.ExpandEnvironmentVariables%2A> método.  
  
> [!NOTE]
>  A maneira recomendada para recuperar dados de <xref:Microsoft.Win32.Registry.PerformanceData> chave é usar o <xref:System.Diagnostics.PerformanceCounter> classe em vez de <xref:Microsoft.Win32.RegistryKey.GetValue%2A?displayProperty=nameWithType> método.  
>   
>  <xref:Microsoft.Win32.RegistryKey.GetValue%2A> não oferece suporte ao ler valores do tipo REG_NONE ou REG_LINK.  Em ambos os casos, o valor padrão (`null`) é retornado em vez do valor real.  
  
   
  
## Examples  
 O exemplo de código a seguir cria uma chave de teste com um valor e recupera o valor. O exemplo, em seguida, tenta recuperar um valor inexistente da chave; Nesse caso o <xref:Microsoft.Win32.RegistryKey.GetValue%2A> método retornará o valor padrão especificado.  
  
 [!code-cpp[Classic RegistryKey.GetValue Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic RegistryKey.GetValue Example/CPP/source.cpp#1)]
 [!code-csharp[Classic RegistryKey.GetValue Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic RegistryKey.GetValue Example/CS/source.cs#1)]
 [!code-vb[Classic RegistryKey.GetValue Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic RegistryKey.GetValue Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">The user does not have the permissions required to read from the registry key.</exception>
        <exception cref="T:System.ObjectDisposedException">The <see cref="T:Microsoft.Win32.RegistryKey" /> that contains the specified value is closed (closed keys cannot be accessed).</exception>
        <exception cref="T:System.IO.IOException">The <see cref="T:Microsoft.Win32.RegistryKey" /> that contains the specified value has been marked for deletion.</exception>
        <exception cref="T:System.UnauthorizedAccessException">The user does not have the necessary registry rights.</exception>
        <permission cref="T:System.Security.Permissions.RegistryPermission">para ler do Registro. Enumeração associada: <see cref="F:System.Security.Permissions.RegistryPermissionAccess.Read" /></permission>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">para ler uma chave do registro do tipo REG_EXPAND_SZ. Enumeração associada: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></permission>
        <altmember cref="M:Microsoft.Win32.RegistryKey.GetValueNames" />
        <altmember cref="Overload:Microsoft.Win32.RegistryKey.SetValue" />
        <altmember cref="M:Microsoft.Win32.RegistryKey.DeleteValue(System.String)" />
        <altmember cref="P:Microsoft.Win32.RegistryKey.ValueCount" />
        <altmember cref="M:Microsoft.Win32.RegistryKey.GetSubKeyNames" />
      </Docs>
    </Member>
    <Member MemberName="GetValue">
      <MemberSignature Language="C#" Value="public object GetValue (string name, object defaultValue, Microsoft.Win32.RegistryValueOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object GetValue(string name, object defaultValue, valuetype Microsoft.Win32.RegistryValueOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Win32.RegistryKey.GetValue(System.String,System.Object,Microsoft.Win32.RegistryValueOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetValue (name As String, defaultValue As Object, options As RegistryValueOptions) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ GetValue(System::String ^ name, System::Object ^ defaultValue, Microsoft::Win32::RegistryValueOptions options);" />
      <MemberSignature Language="F#" Value="member this.GetValue : string * obj * Microsoft.Win32.RegistryValueOptions -&gt; obj" Usage="registryKey.GetValue (name, defaultValue, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="defaultValue" Type="System.Object" />
        <Parameter Name="options" Type="Microsoft.Win32.RegistryValueOptions" />
      </Parameters>
      <Docs>
        <param name="name">The name of the value to retrieve. This string is not case-sensitive.</param>
        <param name="defaultValue">The value to return if <c>name</c> does not exist.</param>
        <param name="options">One of the enumeration values that specifies optional processing of the retrieved value.</param>
        <summary>Retrieves the value associated with the specified name and retrieval options. If the name is not found, returns the default value that you provide.</summary>
        <returns>The value associated with <paramref name="name" />, processed according to the specified <paramref name="options" />, or <paramref name="defaultValue" /> if <paramref name="name" /> is not found.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use essa sobrecarga para especificar um processamento especial, o valor a ser recuperado. Por exemplo, você pode especificar <xref:Microsoft.Win32.RegistryValueOptions.DoNotExpandEnvironmentNames?displayProperty=nameWithType> ao recuperar um valor de registro do tipo <xref:Microsoft.Win32.RegistryValueKind.ExpandString?displayProperty=nameWithType> para recuperar a cadeia de caracteres sem expandir inserido variáveis de ambiente.  
  
 Use o `defaultValue` parâmetro para especificar o valor a ser retornado se `name` não existe.  
  
> [!NOTE]
>  Uma chave do Registro pode ter um valor que não está associado a nenhum nome. Quando esse valor sem nome é exibido no Editor do Registro, a cadeia de caracteres "(Default)" é exibida em vez de um nome. Para recuperar esse sem nome de valor, especifique `null` ou cadeia de caracteres vazia ("") para `name`.  
>   
>  <xref:Microsoft.Win32.RegistryKey.GetValue%2A> não oferece suporte ao ler valores do tipo REG_NONE ou REG_LINK.  Em ambos os casos, o valor padrão (`null`) é retornado em vez do valor real.  
  
   
  
## Examples  
 O exemplo de código a seguir cria uma chave de teste, adiciona um valor com uma variável de ambiente inseridos e recupera o valor em formulários expandidos e não expandidos.  
  
 [!code-cpp[RegistryValueOptions#1](~/samples/snippets/cpp/VS_Snippets_CLR/RegistryValueOptions/CPP/RegistryValueOptions.cpp#1)]
 [!code-csharp[RegistryValueOptions#1](~/samples/snippets/csharp/VS_Snippets_CLR/RegistryValueOptions/CS/source.cs#1)]
 [!code-vb[RegistryValueOptions#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/RegistryValueOptions/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">The user does not have the permissions required to read from the registry key.</exception>
        <exception cref="T:System.ObjectDisposedException">The <see cref="T:Microsoft.Win32.RegistryKey" /> that contains the specified value is closed (closed keys cannot be accessed).</exception>
        <exception cref="T:System.IO.IOException">The <see cref="T:Microsoft.Win32.RegistryKey" /> that contains the specified value has been marked for deletion.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="options" /> is not a valid <see cref="T:Microsoft.Win32.RegistryValueOptions" /> value; for example, an invalid value is cast to <see cref="T:Microsoft.Win32.RegistryValueOptions" />.</exception>
        <exception cref="T:System.UnauthorizedAccessException">The user does not have the necessary registry rights.</exception>
        <permission cref="T:System.Security.Permissions.RegistryPermission">para ler do Registro. Enumeração associada: <see cref="F:System.Security.Permissions.RegistryPermissionAccess.Read" /></permission>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">para ler uma chave do registro do tipo REG_EXPAND_SZ. Enumeração associada: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></permission>
        <altmember cref="T:Microsoft.Win32.RegistryValueOptions" />
        <altmember cref="M:Microsoft.Win32.RegistryKey.GetValueNames" />
        <altmember cref="Overload:Microsoft.Win32.RegistryKey.SetValue" />
        <altmember cref="M:Microsoft.Win32.RegistryKey.DeleteValue(System.String)" />
        <altmember cref="P:Microsoft.Win32.RegistryKey.ValueCount" />
        <altmember cref="M:Microsoft.Win32.RegistryKey.GetSubKeyNames" />
      </Docs>
    </Member>
    <Member MemberName="GetValueKind">
      <MemberSignature Language="C#" Value="public Microsoft.Win32.RegistryValueKind GetValueKind (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype Microsoft.Win32.RegistryValueKind GetValueKind(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Win32.RegistryKey.GetValueKind(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetValueKind (name As String) As RegistryValueKind" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Microsoft::Win32::RegistryValueKind GetValueKind(System::String ^ name);" />
      <MemberSignature Language="F#" Value="member this.GetValueKind : string -&gt; Microsoft.Win32.RegistryValueKind" Usage="registryKey.GetValueKind name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.RegistryValueKind</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">The name of the value whose registry data type is to be retrieved. This string is not case-sensitive.</param>
        <summary>Retrieves the registry data type of the value associated with the specified name.</summary>
        <returns>The registry data type of the value associated with <paramref name="name" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Uma chave do Registro pode ter um valor que não está associado a nenhum nome. Quando esse valor sem nome é exibido no Editor do Registro, a cadeia de caracteres "(Default)" é exibida em vez de um nome. Para recuperar o tipo de dados de registro sem nome de valor, especifique `null` ou cadeia de caracteres vazia ("") para `name`.  
  
 Para obter uma descrição dos tipos de dados de registro com suporte, consulte o <xref:Microsoft.Win32.RegistryValueKind> enumeração.  
  
   
  
## Examples  
 O exemplo de código a seguir cria uma chave de teste e adiciona valores de diferentes tipos de dados para a chave. O exemplo, em seguida, lê os pares nome/valor e exibe-as no console usando o <xref:Microsoft.Win32.RegistryKey.GetValueKind%2A> método para recuperar os tipos de dados de registro correspondentes.  
  
 [!code-cpp[Microsoft.Win32.RegistryValueKind#1](~/samples/snippets/cpp/VS_Snippets_CLR/Microsoft.Win32.RegistryValueKind/CPP/source.cpp#1)]
 [!code-csharp[Microsoft.Win32.RegistryValueKind#1](~/samples/snippets/csharp/VS_Snippets_CLR/Microsoft.Win32.RegistryValueKind/CS/source.cs#1)]
 [!code-vb[Microsoft.Win32.RegistryValueKind#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Microsoft.Win32.RegistryValueKind/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">The user does not have the permissions required to read from the registry key.</exception>
        <exception cref="T:System.ObjectDisposedException">The <see cref="T:Microsoft.Win32.RegistryKey" /> that contains the specified value is closed (closed keys cannot be accessed).</exception>
        <exception cref="T:System.IO.IOException">The subkey that contains the specified value does not exist.  -or-  The name/value pair specified by <paramref name="name" /> does not exist.  This exception is not thrown on Windows 95, Windows 98, or Windows Millennium Edition.</exception>
        <exception cref="T:System.UnauthorizedAccessException">The user does not have the necessary registry rights.</exception>
        <permission cref="T:System.Security.Permissions.RegistryPermission">para ler do Registro. Enumeração associada: <see cref="F:System.Security.Permissions.RegistryPermissionAccess.Read" /></permission>
        <altmember cref="M:Microsoft.Win32.RegistryKey.GetValueNames" />
        <altmember cref="M:Microsoft.Win32.RegistryKey.GetValue(System.String)" />
        <altmember cref="M:Microsoft.Win32.RegistryKey.SetValue(System.String,System.Object)" />
        <altmember cref="T:Microsoft.Win32.RegistryValueKind" />
      </Docs>
    </Member>
    <Member MemberName="GetValueNames">
      <MemberSignature Language="C#" Value="public string[] GetValueNames ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] GetValueNames() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Win32.RegistryKey.GetValueNames" />
      <MemberSignature Language="VB.NET" Value="Public Function GetValueNames () As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::String ^&gt; ^ GetValueNames();" />
      <MemberSignature Language="F#" Value="member this.GetValueNames : unit -&gt; string[]" Usage="registryKey.GetValueNames " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retrieves an array of strings that contains all the value names associated with this key.</summary>
        <returns>An array of strings that contains the value names for the current key.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se nenhum nome de valor para a chave for encontrado, uma matriz vazia será retornada.  
  
 Uma chave do registro pode ter um valor padrão — ou seja, um par de nome/valor no qual o nome é a cadeia de caracteres vazia (""). Se um valor padrão tiver sido definido para uma chave do registro, a matriz retornada pelo <xref:Microsoft.Win32.RegistryKey.GetValueNames%2A> método inclui a cadeia de caracteres vazia.  
  
   
  
## Examples  
 Este exemplo de código é parte de um exemplo maior fornecido para a <xref:Microsoft.Win32.RegistryKey> classe.  
  
 [!code-cpp[Microsoft.Win32.RegistryKey2#2](~/samples/snippets/cpp/VS_Snippets_CLR/Microsoft.Win32.RegistryKey2/CPP/source.cpp#2)]
 [!code-csharp[Microsoft.Win32.RegistryKey2#2](~/samples/snippets/csharp/VS_Snippets_CLR/Microsoft.Win32.RegistryKey2/CS/source.cs#2)]
 [!code-vb[Microsoft.Win32.RegistryKey2#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/Microsoft.Win32.RegistryKey2/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">The user does not have the permissions required to read from the registry key.</exception>
        <exception cref="T:System.ObjectDisposedException">The <see cref="T:Microsoft.Win32.RegistryKey" /> being manipulated is closed (closed keys cannot be accessed).</exception>
        <exception cref="T:System.UnauthorizedAccessException">The user does not have the necessary registry rights.</exception>
        <exception cref="T:System.IO.IOException">A system error occurred; for example, the current key has been deleted.</exception>
        <permission cref="T:System.Security.Permissions.RegistryPermission">a capacidade de ler a partir do registro. Enumeração associada: <see cref="F:System.Security.Permissions.RegistryPermissionAccess.Read" /></permission>
        <altmember cref="M:Microsoft.Win32.RegistryKey.GetValue(System.String)" />
        <altmember cref="M:Microsoft.Win32.RegistryKey.GetSubKeyNames" />
      </Docs>
    </Member>
    <Member MemberName="Handle">
      <MemberSignature Language="C#" Value="public Microsoft.Win32.SafeHandles.SafeRegistryHandle Handle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.Win32.SafeHandles.SafeRegistryHandle Handle" />
      <MemberSignature Language="DocId" Value="P:Microsoft.Win32.RegistryKey.Handle" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Handle As SafeRegistryHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Microsoft::Win32::SafeHandles::SafeRegistryHandle ^ Handle { Microsoft::Win32::SafeHandles::SafeRegistryHandle ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Handle : Microsoft.Win32.SafeHandles.SafeRegistryHandle" Usage="Microsoft.Win32.RegistryKey.Handle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.SafeHandles.SafeRegistryHandle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets a <see cref="T:Microsoft.Win32.SafeHandles.SafeRegistryHandle" /> object that represents the registry key that the current <see cref="T:Microsoft.Win32.RegistryKey" /> object encapsulates.</summary>
        <value>O identificador da chave do Registro.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException">The registry key is closed. Closed keys cannot be accessed.</exception>
        <exception cref="T:System.UnauthorizedAccessException">The user does not have the necessary registry rights.</exception>
        <exception cref="T:System.IO.IOException">A system error occurred, such as deletion of the current key.</exception>
        <exception cref="T:System.Security.SecurityException">The user does not have the permissions required to read the key.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Requer confiança total para o chamador imediato. Este membro não pode ser usado pelo código transparente ou parcialmente confiável.</permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">para a capacidade de acessar a chave do Registro especificada caso ela seja uma chave remota. Enumeração associada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public string Name { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:Microsoft.Win32.RegistryKey.Name" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Name As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Name { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Name : string" Usage="Microsoft.Win32.RegistryKey.Name" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Retrieves the name of the key.</summary>
        <value>O nome absoluto (qualificado) da chave.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O nome da chave inclui o caminho absoluto dessa chave no registro, sempre começando em uma chave de base, por exemplo, HKEY_LOCAL_MACHINE.  
  
   
  
## Examples  
 Este exemplo de código é parte de um exemplo maior fornecido para a <xref:Microsoft.Win32.RegistryKey> classe.  
  
 [!code-cpp[Microsoft.Win32.RegistryKey2#4](~/samples/snippets/cpp/VS_Snippets_CLR/Microsoft.Win32.RegistryKey2/CPP/source.cpp#4)]
 [!code-csharp[Microsoft.Win32.RegistryKey2#4](~/samples/snippets/csharp/VS_Snippets_CLR/Microsoft.Win32.RegistryKey2/CS/source.cs#4)]
 [!code-vb[Microsoft.Win32.RegistryKey2#4](~/samples/snippets/visualbasic/VS_Snippets_CLR/Microsoft.Win32.RegistryKey2/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">The <see cref="T:Microsoft.Win32.RegistryKey" /> is closed (closed keys cannot be accessed).</exception>
        <altmember cref="M:Microsoft.Win32.RegistryKey.ToString" />
      </Docs>
    </Member>
    <Member MemberName="OpenBaseKey">
      <MemberSignature Language="C#" Value="public static Microsoft.Win32.RegistryKey OpenBaseKey (Microsoft.Win32.RegistryHive hKey, Microsoft.Win32.RegistryView view);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.Win32.RegistryKey OpenBaseKey(valuetype Microsoft.Win32.RegistryHive hKey, valuetype Microsoft.Win32.RegistryView view) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Win32.RegistryKey.OpenBaseKey(Microsoft.Win32.RegistryHive,Microsoft.Win32.RegistryView)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OpenBaseKey (hKey As RegistryHive, view As RegistryView) As RegistryKey" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Microsoft::Win32::RegistryKey ^ OpenBaseKey(Microsoft::Win32::RegistryHive hKey, Microsoft::Win32::RegistryView view);" />
      <MemberSignature Language="F#" Value="static member OpenBaseKey : Microsoft.Win32.RegistryHive * Microsoft.Win32.RegistryView -&gt; Microsoft.Win32.RegistryKey" Usage="Microsoft.Win32.RegistryKey.OpenBaseKey (hKey, view)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.RegistryKey</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="hKey" Type="Microsoft.Win32.RegistryHive" />
        <Parameter Name="view" Type="Microsoft.Win32.RegistryView" />
      </Parameters>
      <Docs>
        <param name="hKey">The HKEY to open.</param>
        <param name="view">The registry view to use.</param>
        <summary>Opens a new <see cref="T:Microsoft.Win32.RegistryKey" /> that represents the requested key on the local machine with the specified view.</summary>
        <returns>The requested registry key.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="hKey" /> or <paramref name="view" /> is invalid.</exception>
        <exception cref="T:System.UnauthorizedAccessException">The user does not have the necessary registry rights.</exception>
        <exception cref="T:System.Security.SecurityException">The user does not have the permissions required to perform this action.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="OpenRemoteBaseKey">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Opens a new T:Microsoft.Win32.RegistryKey that represents the requested key on a remote machine, with the option of specified registry view.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="OpenRemoteBaseKey">
      <MemberSignature Language="C#" Value="public static Microsoft.Win32.RegistryKey OpenRemoteBaseKey (Microsoft.Win32.RegistryHive hKey, string machineName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.Win32.RegistryKey OpenRemoteBaseKey(valuetype Microsoft.Win32.RegistryHive hKey, string machineName) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Win32.RegistryKey.OpenRemoteBaseKey(Microsoft.Win32.RegistryHive,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OpenRemoteBaseKey (hKey As RegistryHive, machineName As String) As RegistryKey" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Microsoft::Win32::RegistryKey ^ OpenRemoteBaseKey(Microsoft::Win32::RegistryHive hKey, System::String ^ machineName);" />
      <MemberSignature Language="F#" Value="static member OpenRemoteBaseKey : Microsoft.Win32.RegistryHive * string -&gt; Microsoft.Win32.RegistryKey" Usage="Microsoft.Win32.RegistryKey.OpenRemoteBaseKey (hKey, machineName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.RegistryKey</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="hKey" Type="Microsoft.Win32.RegistryHive" />
        <Parameter Name="machineName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="hKey">The HKEY to open, from the <see cref="T:Microsoft.Win32.RegistryHive" /> enumeration.</param>
        <param name="machineName">The remote machine.</param>
        <summary>Opens a new <see cref="T:Microsoft.Win32.RegistryKey" /> that represents the requested key on a remote machine.</summary>
        <returns>The requested registry key.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O registro do computador local é aberto se `machineName` é <xref:System.String.Empty?displayProperty=nameWithType>. A chave solicitada deve ser uma chave de raiz no computador remoto e é identificada pelo apropriada <xref:Microsoft.Win32.RegistryHive> valor.  
  
 Em ordem para uma chave a ser aberto remotamente, máquinas cliente e servidor devem estar executando o serviço Registro remoto e tiver habilitada a administração remota.  
  
   
  
## Examples  
 O exemplo de código a seguir mostra como abrir uma chave do registro em um computador remoto e enumerar os valores da chave. O computador remoto deve estar executando o serviço Registro remoto. Especifique o nome do computador remoto como um argumento de linha de comando ao invocar o programa.  
  
 [!code-cpp[Microsoft.Win32.RegistryKey.OpenRemoteBaseKey#1](~/samples/snippets/cpp/VS_Snippets_CLR/Microsoft.Win32.RegistryKey.OpenRemoteBaseKey/CPP/source.cpp#1)]
 [!code-csharp[Microsoft.Win32.RegistryKey.OpenRemoteBaseKey#1](~/samples/snippets/csharp/VS_Snippets_CLR/Microsoft.Win32.RegistryKey.OpenRemoteBaseKey/CS/source.cs#1)]
 [!code-vb[Microsoft.Win32.RegistryKey.OpenRemoteBaseKey#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Microsoft.Win32.RegistryKey.OpenRemoteBaseKey/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="hKey" /> is invalid.</exception>
        <exception cref="T:System.IO.IOException">
          <paramref name="machineName" /> is not found.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="machineName" /> is <see langword="null" />.</exception>
        <exception cref="T:System.Security.SecurityException">The user does not have the proper permissions to perform this operation.</exception>
        <exception cref="T:System.UnauthorizedAccessException">The user does not have the necessary registry rights.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">para a capacidade de acessar a chave do Registro especificada caso ela seja uma chave remota. Enumeração associada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="T:Microsoft.Win32.RegistryHive" />
        <altmember cref="M:Microsoft.Win32.RegistryKey.OpenSubKey(System.String,System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="OpenRemoteBaseKey">
      <MemberSignature Language="C#" Value="public static Microsoft.Win32.RegistryKey OpenRemoteBaseKey (Microsoft.Win32.RegistryHive hKey, string machineName, Microsoft.Win32.RegistryView view);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.Win32.RegistryKey OpenRemoteBaseKey(valuetype Microsoft.Win32.RegistryHive hKey, string machineName, valuetype Microsoft.Win32.RegistryView view) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Win32.RegistryKey.OpenRemoteBaseKey(Microsoft.Win32.RegistryHive,System.String,Microsoft.Win32.RegistryView)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OpenRemoteBaseKey (hKey As RegistryHive, machineName As String, view As RegistryView) As RegistryKey" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Microsoft::Win32::RegistryKey ^ OpenRemoteBaseKey(Microsoft::Win32::RegistryHive hKey, System::String ^ machineName, Microsoft::Win32::RegistryView view);" />
      <MemberSignature Language="F#" Value="static member OpenRemoteBaseKey : Microsoft.Win32.RegistryHive * string * Microsoft.Win32.RegistryView -&gt; Microsoft.Win32.RegistryKey" Usage="Microsoft.Win32.RegistryKey.OpenRemoteBaseKey (hKey, machineName, view)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.RegistryKey</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="hKey" Type="Microsoft.Win32.RegistryHive" />
        <Parameter Name="machineName" Type="System.String" />
        <Parameter Name="view" Type="Microsoft.Win32.RegistryView" />
      </Parameters>
      <Docs>
        <param name="hKey">The HKEY to open from the <see cref="T:Microsoft.Win32.RegistryHive" /> enumeration..</param>
        <param name="machineName">The remote machine.</param>
        <param name="view">The registry view to use.</param>
        <summary>Opens a new registry key that represents the requested key on a remote machine with the specified view.</summary>
        <returns>The requested registry key.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O registro do computador local é aberto se `machineName` é <xref:System.String.Empty?displayProperty=nameWithType>. A chave solicitada deve ser uma chave de raiz no computador remoto e é identificada pelo apropriada <xref:Microsoft.Win32.RegistryHive> valor.  
  
 Em ordem para uma chave a ser aberto remotamente, máquinas cliente e servidor devem estar executando o serviço Registro remoto e tiver habilitada a administração remota.  
  
 Nas versões de 64 bits do Windows, as partes do registro são armazenadas separadamente para aplicativos de 32 bits e 64 bits. Há um modo de exibição de 32 bits para aplicativos de 32 bits e um modo de exibição de 64 bits para aplicativos de 64 bits. Se `view` é <xref:Microsoft.Win32.RegistryView.Registry64> , mas o computador remoto está executando um sistema operacional de 32 bits, a chave retornada usará o <xref:Microsoft.Win32.RegistryView.Registry32> exibição.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="hKey" /> or <paramref name="view" /> is invalid.</exception>
        <exception cref="T:System.IO.IOException">
          <paramref name="machineName" /> is not found.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="machineName" /> is <see langword="null" />.</exception>
        <exception cref="T:System.UnauthorizedAccessException">The user does not have the necessary registry rights.</exception>
        <exception cref="T:System.Security.SecurityException">The user does not have the required permissions to perform this operation.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="OpenSubKey">
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Retrieves the specified subkey.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="OpenSubKey">
      <MemberSignature Language="C#" Value="public Microsoft.Win32.RegistryKey OpenSubKey (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class Microsoft.Win32.RegistryKey OpenSubKey(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Win32.RegistryKey.OpenSubKey(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function OpenSubKey (name As String) As RegistryKey" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Microsoft::Win32::RegistryKey ^ OpenSubKey(System::String ^ name);" />
      <MemberSignature Language="F#" Value="member this.OpenSubKey : string -&gt; Microsoft.Win32.RegistryKey" Usage="registryKey.OpenSubKey name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.RegistryKey</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">The name or path of the subkey to open as read-only.</param>
        <summary>Retrieves a subkey as read-only.</summary>
        <returns>The subkey requested, or <see langword="null" /> if the operation failed.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Você deve abrir uma chave antes que ele pode ser manipulado com outros métodos e propriedades. Para modificar uma chave, você deve abri-lo com uma sobrecarga do <xref:Microsoft.Win32.RegistryKey.OpenSubKey%2A> método que permite que você especifique o acesso de gravação, como o <xref:Microsoft.Win32.RegistryKey.OpenSubKey%28System.String%2CMicrosoft.Win32.RegistryKeyPermissionCheck%29> sobrecarregar ou <xref:Microsoft.Win32.RegistryKey.OpenSubKey%28System.String%2CSystem.Boolean%29> de sobrecarga.  
  
 Se a subchave especificada não pode ser encontrada, `null` será retornado.  
  
 Para usar o <xref:Microsoft.Win32.RegistryKey.OpenSubKey%2A> método, você deve ter uma instância de <xref:Microsoft.Win32.RegistryKey>. Para obter uma instância de <xref:Microsoft.Win32.RegistryKey>, use um dos membros estáticos de <xref:Microsoft.Win32.Registry> classe.  
  
   
  
## Examples  
 O exemplo de código a seguir cria uma chave de teste e usa o <xref:Microsoft.Win32.RegistryKey.OpenSubKey%2A> método abri-lo, demonstrando as duas sobrecargas do método.  
  
 [!code-cpp[RegistryKey.OpenSubKey#1](~/samples/snippets/cpp/VS_Snippets_CLR/RegistryKey.OpenSubKey/CPP/opensubkey.cpp#1)]
 [!code-csharp[RegistryKey.OpenSubKey#1](~/samples/snippets/csharp/VS_Snippets_CLR/RegistryKey.OpenSubKey/CS/opensubkey.cs#1)]
 [!code-vb[RegistryKey.OpenSubKey#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/RegistryKey.OpenSubKey/VB/opensubkey.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> is <see langword="null" /></exception>
        <exception cref="T:System.ObjectDisposedException">The <see cref="T:Microsoft.Win32.RegistryKey" /> is closed (closed keys cannot be accessed).</exception>
        <exception cref="T:System.Security.SecurityException">The user does not have the permissions required to read the registry key.</exception>
        <permission cref="T:System.Security.Permissions.RegistryPermission">para a capacidade de ler a chave do Registro especificada. Enumeração associada: <see cref="F:System.Security.Permissions.RegistryPermissionAccess.Read" /></permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">para a capacidade de acessar a chave do Registro especificada caso ela seja uma chave remota. Enumeração associada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="M:Microsoft.Win32.RegistryKey.CreateSubKey(System.String)" />
        <altmember cref="M:Microsoft.Win32.RegistryKey.DeleteSubKey(System.String)" />
        <altmember cref="M:Microsoft.Win32.RegistryKey.DeleteSubKeyTree(System.String)" />
        <altmember cref="M:Microsoft.Win32.RegistryKey.GetSubKeyNames" />
        <altmember cref="M:Microsoft.Win32.RegistryKey.OpenRemoteBaseKey(Microsoft.Win32.RegistryHive,System.String)" />
        <altmember cref="P:Microsoft.Win32.RegistryKey.SubKeyCount" />
        <altmember cref="T:Microsoft.Win32.Registry" />
      </Docs>
    </Member>
    <Member MemberName="OpenSubKey">
      <MemberSignature Language="C#" Value="public Microsoft.Win32.RegistryKey OpenSubKey (string name, Microsoft.Win32.RegistryKeyPermissionCheck permissionCheck);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class Microsoft.Win32.RegistryKey OpenSubKey(string name, valuetype Microsoft.Win32.RegistryKeyPermissionCheck permissionCheck) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Win32.RegistryKey.OpenSubKey(System.String,Microsoft.Win32.RegistryKeyPermissionCheck)" />
      <MemberSignature Language="VB.NET" Value="Public Function OpenSubKey (name As String, permissionCheck As RegistryKeyPermissionCheck) As RegistryKey" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Microsoft::Win32::RegistryKey ^ OpenSubKey(System::String ^ name, Microsoft::Win32::RegistryKeyPermissionCheck permissionCheck);" />
      <MemberSignature Language="F#" Value="member this.OpenSubKey : string * Microsoft.Win32.RegistryKeyPermissionCheck -&gt; Microsoft.Win32.RegistryKey" Usage="registryKey.OpenSubKey (name, permissionCheck)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.RegistryKey</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="permissionCheck" Type="Microsoft.Win32.RegistryKeyPermissionCheck" />
      </Parameters>
      <Docs>
        <param name="name">The name or path of the subkey to create or open.</param>
        <param name="permissionCheck">One of the enumeration values that specifies whether the key is opened for read or read/write access.</param>
        <summary>Retrieves the specified subkey for read or read/write access.</summary>
        <returns>The subkey requested, or <see langword="null" /> if the operation failed.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Em vez de gerar uma exceção, este método retorna `null` se a chave solicitada não existe.  
  
 Se `permissionCheck` é <xref:Microsoft.Win32.RegistryKeyPermissionCheck.ReadWriteSubTree?displayProperty=nameWithType>, a chave é aberta para leitura e gravação; se `permissionCheck` é <xref:Microsoft.Win32.RegistryKeyPermissionCheck.ReadSubTree?displayProperty=nameWithType> ou <xref:Microsoft.Win32.RegistryKeyPermissionCheck.Default?displayProperty=nameWithType>, a chave é aberta para leitura, a menos que a chave pai foi aberta com <xref:Microsoft.Win32.RegistryKeyPermissionCheck.ReadWriteSubTree?displayProperty=nameWithType>.  
  
 Para usar o método <xref:Microsoft.Win32.RegistryKey.OpenSubKey%2A>, você deve ter uma instância da classe <xref:Microsoft.Win32.RegistryKey>. Para obter uma instância de <xref:Microsoft.Win32.RegistryKey>, use um dos membros estáticos da classe <xref:Microsoft.Win32.Registry>.  
  
   
  
## Examples  
 O exemplo de código a seguir cria uma subchave que contém pares de chave/valor de 100 e fechá-lo. O exemplo abre a subchave com <xref:Microsoft.Win32.RegistryKeyPermissionCheck.Default>, registra o tempo que leva para ler todos os valores e fecha a subchave. O exemplo abre a subchave com <xref:Microsoft.Win32.RegistryKeyPermissionCheck.ReadSubTree> e registra o tempo necessário para ler todos os valores. Por fim, o exemplo calcula e exibe a porcentagem de aperfeiçoamento.  
  
 [!code-csharp[RegistryKey.OpenSubKey_PermCheck#1](~/samples/snippets/csharp/VS_Snippets_CLR/RegistryKey.OpenSubKey_PermCheck/cs/source.cs#1)]
 [!code-vb[RegistryKey.OpenSubKey_PermCheck#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/RegistryKey.OpenSubKey_PermCheck/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> is <see langword="null" /></exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="permissionCheck" /> contains an invalid value.</exception>
        <exception cref="T:System.ObjectDisposedException">The <see cref="T:Microsoft.Win32.RegistryKey" /> is closed (closed keys cannot be accessed).</exception>
        <exception cref="T:System.Security.SecurityException">The user does not have the permissions required to read the registry key.</exception>
        <permission cref="T:System.Security.Permissions.RegistryPermission">para a capacidade de ler a chave do Registro especificada. Enumeração associada: <see cref="F:System.Security.Permissions.RegistryPermissionAccess.Read" /></permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">para a capacidade de acessar a chave do Registro especificada caso ela seja uma chave remota. Enumeração associada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="M:Microsoft.Win32.RegistryKey.CreateSubKey(System.String)" />
        <altmember cref="M:Microsoft.Win32.RegistryKey.DeleteSubKey(System.String)" />
        <altmember cref="M:Microsoft.Win32.RegistryKey.DeleteSubKeyTree(System.String)" />
        <altmember cref="M:Microsoft.Win32.RegistryKey.GetSubKeyNames" />
        <altmember cref="M:Microsoft.Win32.RegistryKey.OpenRemoteBaseKey(Microsoft.Win32.RegistryHive,System.String)" />
        <altmember cref="P:Microsoft.Win32.RegistryKey.SubKeyCount" />
        <altmember cref="T:Microsoft.Win32.Registry" />
      </Docs>
    </Member>
    <Member MemberName="OpenSubKey">
      <MemberSignature Language="C#" Value="public Microsoft.Win32.RegistryKey OpenSubKey (string name, bool writable);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class Microsoft.Win32.RegistryKey OpenSubKey(string name, bool writable) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Win32.RegistryKey.OpenSubKey(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function OpenSubKey (name As String, writable As Boolean) As RegistryKey" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Microsoft::Win32::RegistryKey ^ OpenSubKey(System::String ^ name, bool writable);" />
      <MemberSignature Language="F#" Value="member this.OpenSubKey : string * bool -&gt; Microsoft.Win32.RegistryKey" Usage="registryKey.OpenSubKey (name, writable)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.RegistryKey</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="writable" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="name">Name or path of the subkey to open.</param>
        <param name="writable">Set to <see langword="true" /> if you need write access to the key.</param>
        <summary>Retrieves a specified subkey, and specifies whether write access is to be applied to the key.</summary>
        <returns>The subkey requested, or <see langword="null" /> if the operation failed.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se a chave solicitada não existe, esse método retorna `null` em vez de gerar uma exceção.  
  
 Se `writable` é `true`, a chave será aberta para leitura e gravação, caso contrário, a chave será aberta como somente leitura.  
  
 Para usar o <xref:Microsoft.Win32.RegistryKey.OpenSubKey%2A> método, você deve ter uma instância do <xref:Microsoft.Win32.RegistryKey> método. Para obter uma instância de <xref:Microsoft.Win32.RegistryKey>, use um dos membros estáticos da classe <xref:Microsoft.Win32.Registry>.  
  
   
  
## Examples  
 O exemplo de código a seguir cria uma chave de teste e usa o <xref:Microsoft.Win32.RegistryKey.OpenSubKey%2A> método abri-lo, demonstrando as duas sobrecargas do método.  
  
 [!code-cpp[RegistryKey.OpenSubKey#1](~/samples/snippets/cpp/VS_Snippets_CLR/RegistryKey.OpenSubKey/CPP/opensubkey.cpp#1)]
 [!code-csharp[RegistryKey.OpenSubKey#1](~/samples/snippets/csharp/VS_Snippets_CLR/RegistryKey.OpenSubKey/CS/opensubkey.cs#1)]
 [!code-vb[RegistryKey.OpenSubKey#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/RegistryKey.OpenSubKey/VB/opensubkey.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ObjectDisposedException">The <see cref="T:Microsoft.Win32.RegistryKey" /> is closed (closed keys cannot be accessed).</exception>
        <exception cref="T:System.Security.SecurityException">The user does not have the permissions required to access the registry key in the specified mode.</exception>
        <permission cref="T:System.Security.Permissions.RegistryPermission">para a capacidade de ler a chave do Registro especificada. Enumeração associada: <see cref="F:System.Security.Permissions.RegistryPermissionAccess.Read" /></permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">para a capacidade de acessar a chave do Registro especificada caso ela seja uma chave remota. Enumeração associada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="M:Microsoft.Win32.RegistryKey.CreateSubKey(System.String)" />
        <altmember cref="M:Microsoft.Win32.RegistryKey.DeleteSubKey(System.String)" />
        <altmember cref="M:Microsoft.Win32.RegistryKey.DeleteSubKeyTree(System.String)" />
        <altmember cref="M:Microsoft.Win32.RegistryKey.GetSubKeyNames" />
        <altmember cref="M:Microsoft.Win32.RegistryKey.OpenRemoteBaseKey(Microsoft.Win32.RegistryHive,System.String)" />
        <altmember cref="P:Microsoft.Win32.RegistryKey.SubKeyCount" />
        <altmember cref="T:Microsoft.Win32.Registry" />
      </Docs>
    </Member>
    <Member MemberName="OpenSubKey">
      <MemberSignature Language="C#" Value="public Microsoft.Win32.RegistryKey OpenSubKey (string name, System.Security.AccessControl.RegistryRights rights);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class Microsoft.Win32.RegistryKey OpenSubKey(string name, valuetype System.Security.AccessControl.RegistryRights rights) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Win32.RegistryKey.OpenSubKey(System.String,System.Security.AccessControl.RegistryRights)" />
      <MemberSignature Language="VB.NET" Value="Public Function OpenSubKey (name As String, rights As RegistryRights) As RegistryKey" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Microsoft::Win32::RegistryKey ^ OpenSubKey(System::String ^ name, System::Security::AccessControl::RegistryRights rights);" />
      <MemberSignature Language="F#" Value="member this.OpenSubKey : string * System.Security.AccessControl.RegistryRights -&gt; Microsoft.Win32.RegistryKey" Usage="registryKey.OpenSubKey (name, rights)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.RegistryKey</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="rights" Type="System.Security.AccessControl.RegistryRights" />
      </Parameters>
      <Docs>
        <param name="name">The name or path of the subkey to create or open.</param>
        <param name="rights">The rights for the registry key.</param>
        <summary>Retrieves a subkey with the specified name and .  Available starting in .NET Framework 4.6</summary>
        <returns>The subkey requested, or <see langword="null" /> if the operation failed.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Você deve abrir uma chave antes que ele pode ser manipulado com outros métodos e propriedades. Para modificar uma chave, você deve abri-lo com uma sobrecarga de <xref:Microsoft.Win32.RegistryKey.OpenSubKey%2A> método que permite que você especifique o acesso de gravação.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ObjectDisposedException">The <see cref="T:Microsoft.Win32.RegistryKey" /> is closed (closed keys cannot be accessed).</exception>
        <exception cref="T:System.Security.SecurityException">The user does not have the permissions required to access the registry key in the specified mode.</exception>
      </Docs>
    </Member>
    <Member MemberName="OpenSubKey">
      <MemberSignature Language="C#" Value="public Microsoft.Win32.RegistryKey OpenSubKey (string name, Microsoft.Win32.RegistryKeyPermissionCheck permissionCheck, System.Security.AccessControl.RegistryRights rights);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class Microsoft.Win32.RegistryKey OpenSubKey(string name, valuetype Microsoft.Win32.RegistryKeyPermissionCheck permissionCheck, valuetype System.Security.AccessControl.RegistryRights rights) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Win32.RegistryKey.OpenSubKey(System.String,Microsoft.Win32.RegistryKeyPermissionCheck,System.Security.AccessControl.RegistryRights)" />
      <MemberSignature Language="VB.NET" Value="Public Function OpenSubKey (name As String, permissionCheck As RegistryKeyPermissionCheck, rights As RegistryRights) As RegistryKey" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Microsoft::Win32::RegistryKey ^ OpenSubKey(System::String ^ name, Microsoft::Win32::RegistryKeyPermissionCheck permissionCheck, System::Security::AccessControl::RegistryRights rights);" />
      <MemberSignature Language="F#" Value="member this.OpenSubKey : string * Microsoft.Win32.RegistryKeyPermissionCheck * System.Security.AccessControl.RegistryRights -&gt; Microsoft.Win32.RegistryKey" Usage="registryKey.OpenSubKey (name, permissionCheck, rights)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.RegistryKey</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="permissionCheck" Type="Microsoft.Win32.RegistryKeyPermissionCheck" />
        <Parameter Name="rights" Type="System.Security.AccessControl.RegistryRights" />
      </Parameters>
      <Docs>
        <param name="name">The name or path of the subkey to create or open.</param>
        <param name="permissionCheck">One of the enumeration values that specifies whether the key is opened for read or read/write access.</param>
        <param name="rights">A bitwise combination of enumeration values that specifies the desired security access.</param>
        <summary>Retrieves the specified subkey for read or read/write access, requesting the specified access rights.</summary>
        <returns>The subkey requested, or <see langword="null" /> if the operation failed.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Em vez de gerar uma exceção, este método retorna `null` se a chave solicitada não existe.  
  
 Se `permissionCheck` é <xref:Microsoft.Win32.RegistryKeyPermissionCheck.ReadWriteSubTree?displayProperty=nameWithType>, a chave é aberta para leitura e gravação; se `permissionCheck` é <xref:Microsoft.Win32.RegistryKeyPermissionCheck.ReadSubTree?displayProperty=nameWithType> ou <xref:Microsoft.Win32.RegistryKeyPermissionCheck.Default?displayProperty=nameWithType>, a chave é aberta para leitura, a menos que a chave pai foi aberta com <xref:Microsoft.Win32.RegistryKeyPermissionCheck.ReadWriteSubTree?displayProperty=nameWithType>.  
  
 O acesso especificado para `permissionCheck` tem precedência sobre o acesso especificado para `rights`. Por exemplo, se você especificar <xref:Microsoft.Win32.RegistryKeyPermissionCheck.ReadSubTree?displayProperty=nameWithType> para `permissionCheck` e <xref:System.Security.AccessControl.RegistryRights.WriteKey?displayProperty=nameWithType> para `rights`, uma tentativa de gravar na subchave lança uma exceção.  
  
 Para usar o método <xref:Microsoft.Win32.RegistryKey.OpenSubKey%2A>, você deve ter uma instância da classe <xref:Microsoft.Win32.RegistryKey>. Para obter uma instância de <xref:Microsoft.Win32.RegistryKey>, use um dos membros estáticos da classe <xref:Microsoft.Win32.Registry>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> is <see langword="null" /></exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="permissionCheck" /> contains an invalid value.</exception>
        <exception cref="T:System.ObjectDisposedException">The <see cref="T:Microsoft.Win32.RegistryKey" /> is closed (closed keys cannot be accessed).</exception>
        <exception cref="T:System.Security.SecurityException">
          <paramref name="rights" /> includes invalid registry rights values.  -or-  The user does not have the requested permissions.</exception>
        <permission cref="T:System.Security.Permissions.RegistryPermission">para a capacidade de ler a chave do Registro especificada. Enumeração associada: <see cref="F:System.Security.Permissions.RegistryPermissionAccess.Read" /></permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">para a capacidade de acessar a chave do Registro especificada caso ela seja uma chave remota. Enumeração associada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="M:Microsoft.Win32.RegistryKey.CreateSubKey(System.String)" />
        <altmember cref="M:Microsoft.Win32.RegistryKey.DeleteSubKey(System.String)" />
        <altmember cref="M:Microsoft.Win32.RegistryKey.DeleteSubKeyTree(System.String)" />
        <altmember cref="M:Microsoft.Win32.RegistryKey.GetSubKeyNames" />
        <altmember cref="M:Microsoft.Win32.RegistryKey.OpenRemoteBaseKey(Microsoft.Win32.RegistryHive,System.String)" />
        <altmember cref="P:Microsoft.Win32.RegistryKey.SubKeyCount" />
        <altmember cref="T:Microsoft.Win32.Registry" />
      </Docs>
    </Member>
    <Member MemberName="SetAccessControl">
      <MemberSignature Language="C#" Value="public void SetAccessControl (System.Security.AccessControl.RegistrySecurity registrySecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetAccessControl(class System.Security.AccessControl.RegistrySecurity registrySecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Win32.RegistryKey.SetAccessControl(System.Security.AccessControl.RegistrySecurity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetAccessControl(System::Security::AccessControl::RegistrySecurity ^ registrySecurity);" />
      <MemberSignature Language="F#" Value="member this.SetAccessControl : System.Security.AccessControl.RegistrySecurity -&gt; unit" Usage="registryKey.SetAccessControl registrySecurity" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="registrySecurity" Type="System.Security.AccessControl.RegistrySecurity" />
      </Parameters>
      <Docs>
        <param name="registrySecurity">The access control security to apply to the current subkey.</param>
        <summary>Applies Windows access control security to an existing registry key.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para modificar permissões para uma chave do registro, use o <xref:Microsoft.Win32.RegistryKey.GetAccessControl%2A> método para obter um <xref:System.Security.AccessControl.RegistrySecurity> objeto representando a segurança de controle de acesso existente do Windows, modifique que <xref:System.Security.AccessControl.RegistrySecurity> objeto e, em seguida, use o <xref:Microsoft.Win32.RegistryKey.SetAccessControl%2A> método de atualização de segurança para a chave.  
  
> [!CAUTION]
>  O <xref:System.Security.AccessControl.RegistrySecurity> o objeto especificado para `registrySecurity` substitui a segurança existente para a chave do registro. Para adicionar permissões para um novo usuário, use o <xref:Microsoft.Win32.RegistryKey.GetAccessControl%2A> método para obter o acesso existente controlar a segurança e, em seguida, modificá-lo.  
  
   
  
## Examples  
 O exemplo de código a seguir cria uma chave de teste. O usuário atual tem permissão <xref:System.Security.AccessControl.RegistryRights.ReadKey> e <xref:System.Security.AccessControl.RegistryRights.Delete> direitos mas negado <xref:System.Security.AccessControl.RegistryRights.ChangePermissions> e <xref:System.Security.AccessControl.RegistryRights.WriteKey> direitos. Tentativas subsequentes manipular o chave êxito ou falhar dependendo essas permissões.  
  
 Antes da chave é excluída, o código faz uma pausa. Você pode alternar para o editor do registro e verifique se os mesmos direitos de acesso se aplicam quando a chave for acessada usando o editor do registro. (Isso funciona melhor se você usar **RunAs** da linha de comando para executar o editor do registro e o código de exemplo como um usuário local sem direitos de administrador. O editor do registro sempre permite que um administrador alterar permissões, mesmo que o administrador específico foi negado esses direitos. Se você tiver definido um usuário local chamado TestUser, o comando `runas /user:TestUser cmd` abre uma janela de comando do qual você pode executar o editor do registro e, em seguida, o código de exemplo.)  
  
 [!code-cpp[RegistrySecurity101#1](~/samples/snippets/cpp/VS_Snippets_CLR/RegistrySecurity101/cpp/source.cpp#1)]
 [!code-csharp[RegistrySecurity101#1](~/samples/snippets/csharp/VS_Snippets_CLR/RegistrySecurity101/CS/source.cs#1)]
 [!code-vb[RegistrySecurity101#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/RegistrySecurity101/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">The current <see cref="T:Microsoft.Win32.RegistryKey" /> object represents a key with access control security, and the caller does not have <see cref="F:System.Security.AccessControl.RegistryRights.ChangePermissions" /> rights.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="registrySecurity" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ObjectDisposedException">The <see cref="T:Microsoft.Win32.RegistryKey" /> being manipulated is closed (closed keys cannot be accessed).</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="SetValue">
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Sets the value of a name/value pair in the registry key. Depending on the overload, the registry data type is determined from the type of data being stored or from a specified <see cref="T:Microsoft.Win32.RegistryValueKind" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SetValue">
      <MemberSignature Language="C#" Value="public void SetValue (string name, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetValue(string name, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Win32.RegistryKey.SetValue(System.String,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetValue (name As String, value As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetValue(System::String ^ name, System::Object ^ value);" />
      <MemberSignature Language="F#" Value="member this.SetValue : string * obj -&gt; unit" Usage="registryKey.SetValue (name, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="name">The name of the value to store.</param>
        <param name="value">The data to be stored.</param>
        <summary>Sets the specified name/value pair.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Como muitos valores podem ser armazenados em cada chave do registro, você deve usar o `name` para especificar o valor específico que você deseja definir.  
  
> [!NOTE]
>  Uma chave do Registro pode ter um valor que não está associado a nenhum nome. Quando esse valor sem nome é exibido no Editor do Registro, a cadeia de caracteres "(Default)" é exibida em vez de um nome. Para definir isso sem nome de valor, especifique `null` ou cadeia de caracteres vazia ("") para `name`.  
  
 Para definir valores em uma chave, você deve abrir a chave com acesso de gravação. Depois de abrir uma chave com acesso de gravação, você pode alterar os pares de nome/valor na chave.  
  
 Se especificado `name` não existe na chave, ele é criado e o valor associado é definido como `value`.  
  
 Esta sobrecarga do <xref:Microsoft.Win32.RegistryKey.SetValue%2A> armazena inteiros de 64 bits como cadeias de caracteres (<xref:Microsoft.Win32.RegistryValueKind.String?displayProperty=nameWithType>). Para armazenar números de 64 bits como <xref:Microsoft.Win32.RegistryValueKind.QWord?displayProperty=nameWithType> valores, use o <xref:Microsoft.Win32.RegistryKey.SetValue%28System.String%2CSystem.Object%2CMicrosoft.Win32.RegistryValueKind%29> sobrecarga especifica <xref:Microsoft.Win32.RegistryValueKind>.  
  
 Esta sobrecarga do <xref:Microsoft.Win32.RegistryKey.SetValue%2A> armazena todos os valores de cadeia de caracteres como <xref:Microsoft.Win32.RegistryValueKind.String?displayProperty=nameWithType>, mesmo que eles contêm expansíveis referências a variáveis de ambiente. Para salvar os valores de cadeia de caracteres expansíveis como cadeias de caracteres (<xref:Microsoft.Win32.RegistryValueKind.ExpandString?displayProperty=nameWithType>), use o <xref:Microsoft.Win32.RegistryKey.SetValue%28System.String%2CSystem.Object%2CMicrosoft.Win32.RegistryValueKind%29> sobrecarga especifica <xref:Microsoft.Win32.RegistryValueKind>.  
  
 Tipos numéricos que não sejam números inteiros de 32 bits são armazenados como cadeias de caracteres por essa sobrecarga de método. Enumeração elementos são armazenados como cadeias de caracteres que contém os nomes de elemento.  
  
> [!CAUTION]
>  Não exponha objetos <xref:Microsoft.Win32.RegistryKey> de maneira que um programa mal-intencionado possa criar milhares de subchaves sem sentido ou os pares de chave/valor. Por exemplo, não permita que chamadores insiram chaves ou valores arbitrários.  
  
> [!NOTE]
>  No Windows 98 e Windows Millennium Edition no registro não for Unicode e não todos os caracteres Unicode são válidos para todas as páginas de código. Um caractere Unicode inválido para a página de código atual é substituído por melhor correspondência disponível. Nenhuma exceção é lançada.  
  
   
  
## Examples  
 O seguinte exemplo de código mostra como o <xref:Microsoft.Win32.RegistryKey.SetValue%2A> método determina o tipo de dados do registro quando ele define valores. O exemplo cria uma chave de teste e adiciona valores de diferentes tipos de dados para a chave. O exemplo, em seguida, lê os pares nome/valor e exibe-as no console usando o <xref:Microsoft.Win32.RegistryKey.GetValueKind%2A> método para exibir os tipos de dados de registro correspondentes.  
  
 [!code-cpp[Microsoft.Win32.RegistryKey.SetValue1#1](~/samples/snippets/cpp/VS_Snippets_CLR/Microsoft.Win32.RegistryKey.SetValue1/CPP/source.cpp#1)]
 [!code-csharp[Microsoft.Win32.RegistryKey.SetValue1#1](~/samples/snippets/csharp/VS_Snippets_CLR/Microsoft.Win32.RegistryKey.SetValue1/CS/source.cs#1)]
 [!code-vb[Microsoft.Win32.RegistryKey.SetValue1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Microsoft.Win32.RegistryKey.SetValue1/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="value" /> is an unsupported data type.</exception>
        <exception cref="T:System.ObjectDisposedException">The <see cref="T:Microsoft.Win32.RegistryKey" /> that contains the specified value is closed (closed keys cannot be accessed).</exception>
        <exception cref="T:System.UnauthorizedAccessException">The <see cref="T:Microsoft.Win32.RegistryKey" /> is read-only, and cannot be written to; for example, the key has not been opened with write access.  -or-  The <see cref="T:Microsoft.Win32.RegistryKey" /> object represents a root-level node, and the operating system is Windows Millennium Edition or Windows 98.</exception>
        <exception cref="T:System.Security.SecurityException">The user does not have the permissions required to create or modify registry keys.</exception>
        <exception cref="T:System.IO.IOException">The <see cref="T:Microsoft.Win32.RegistryKey" /> object represents a root-level node, and the operating system is Windows 2000, Windows XP, or Windows Server 2003.</exception>
        <permission cref="T:System.Security.Permissions.RegistryPermission">Para modificar a chave do registro especificado se ele existir, ou para criar a chave do registro se ele ainda não existir. Enumerações associadas: <see cref="F:System.Security.Permissions.RegistryPermissionAccess.Write" />, <see cref="F:System.Security.Permissions.RegistryPermissionAccess.Create" /></permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">para a capacidade de acessar a chave do Registro especificada caso ela seja uma chave remota. Enumeração associada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="M:Microsoft.Win32.RegistryKey.GetValue(System.String)" />
        <altmember cref="M:Microsoft.Win32.RegistryKey.GetValueKind(System.String)" />
        <altmember cref="P:Microsoft.Win32.RegistryKey.ValueCount" />
      </Docs>
    </Member>
    <Member MemberName="SetValue">
      <MemberSignature Language="C#" Value="public void SetValue (string name, object value, Microsoft.Win32.RegistryValueKind valueKind);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetValue(string name, object value, valuetype Microsoft.Win32.RegistryValueKind valueKind) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Win32.RegistryKey.SetValue(System.String,System.Object,Microsoft.Win32.RegistryValueKind)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetValue (name As String, value As Object, valueKind As RegistryValueKind)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetValue(System::String ^ name, System::Object ^ value, Microsoft::Win32::RegistryValueKind valueKind);" />
      <MemberSignature Language="F#" Value="member this.SetValue : string * obj * Microsoft.Win32.RegistryValueKind -&gt; unit" Usage="registryKey.SetValue (name, value, valueKind)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="valueKind" Type="Microsoft.Win32.RegistryValueKind" />
      </Parameters>
      <Docs>
        <param name="name">The name of the value to be stored.</param>
        <param name="value">The data to be stored.</param>
        <param name="valueKind">The registry data type to use when storing the data.</param>
        <summary>Sets the value of a name/value pair in the registry key, using the specified registry data type.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Como muitos valores podem ser armazenados em cada chave do registro, você deve usar o `name` para especificar o valor específico que você deseja definir.  
  
> [!NOTE]
>  Uma chave do Registro pode ter um valor que não está associado a nenhum nome. Quando esse valor sem nome é exibido no Editor do Registro, a cadeia de caracteres "(Default)" é exibida em vez de um nome. Para definir isso sem nome de valor, especifique `null` ou cadeia de caracteres vazia ("") para `name`.  
  
 Para definir valores em uma chave, você deve abrir a chave com acesso de gravação. Depois de abrir uma chave com acesso de gravação, você pode alterar os pares de nome/valor na chave.  
  
 Se especificado `name` não existe na chave, ele é criado e o valor associado é definido como `value`.  
  
> [!NOTE]
>  Especifica o tipo de dados do registro <xref:Microsoft.Win32.RegistryValueKind.Unknown> é o mesmo que usar o <xref:Microsoft.Win32.RegistryKey.SetValue%2A> de sobrecarga.  
  
 Se o tipo especificado `value` não coincide com a especificada `valueKind`, e os dados não podem ser convertido, <xref:System.ArgumentException> é gerada. Por exemplo, você pode armazenar um <xref:System.Int64?displayProperty=nameWithType> como um <xref:Microsoft.Win32.RegistryValueKind.DWord?displayProperty=nameWithType>, mas somente se o valor for menor que o valor máximo de um <xref:System.Int32?displayProperty=nameWithType>. Você não pode armazenar um valor de cadeia de caracteres única como um <xref:Microsoft.Win32.RegistryValueKind.MultiString?displayProperty=nameWithType>.  
  
> [!NOTE]
>  Se valores boxed são passados para <xref:Microsoft.Win32.RegistryValueKind.DWord?displayProperty=nameWithType> ou <xref:Microsoft.Win32.RegistryValueKind.QWord?displayProperty=nameWithType>, a conversão é feita usando a cultura invariável.  
  
> [!CAUTION]
>  Não exponha objetos <xref:Microsoft.Win32.RegistryKey> de maneira que um programa mal-intencionado possa criar milhares de subchaves sem sentido ou os pares de chave/valor. Por exemplo, não permita que chamadores insiram chaves ou valores arbitrários.  
  
> [!NOTE]
>  No Windows 98 e Windows Millennium Edition no registro não for Unicode e não todos os caracteres Unicode são válidos para todas as páginas de código. Um caractere Unicode inválido para a página de código atual é substituído por melhor correspondência disponível. Nenhuma exceção é lançada.  
  
   
  
## Examples  
 O exemplo de código a seguir cria uma chave de teste e usa o <xref:Microsoft.Win32.RegistryKey.SetValue%2A> método para armazenar vários valores, especificando o tipo de dados de registro para cada valor. O exemplo, em seguida, lê os pares nome/valor e exibe-as no console usando o <xref:Microsoft.Win32.RegistryKey.GetValueKind%2A> método para exibir os tipos de dados de registro correspondentes.  
  
 [!code-cpp[Microsoft.Win32.RegistryValueKind#1](~/samples/snippets/cpp/VS_Snippets_CLR/Microsoft.Win32.RegistryValueKind/CPP/source.cpp#1)]
 [!code-csharp[Microsoft.Win32.RegistryValueKind#1](~/samples/snippets/csharp/VS_Snippets_CLR/Microsoft.Win32.RegistryValueKind/CS/source.cs#1)]
 [!code-vb[Microsoft.Win32.RegistryValueKind#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Microsoft.Win32.RegistryValueKind/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">The type of <paramref name="value" /> did not match the registry data type specified by <paramref name="valueKind" />, therefore the data could not be converted properly.</exception>
        <exception cref="T:System.ObjectDisposedException">The <see cref="T:Microsoft.Win32.RegistryKey" /> that contains the specified value is closed (closed keys cannot be accessed).</exception>
        <exception cref="T:System.UnauthorizedAccessException">The <see cref="T:Microsoft.Win32.RegistryKey" /> is read-only, and cannot be written to; for example, the key has not been opened with write access.  -or-  The <see cref="T:Microsoft.Win32.RegistryKey" /> object represents a root-level node, and the operating system is Windows Millennium Edition or Windows 98.</exception>
        <exception cref="T:System.Security.SecurityException">The user does not have the permissions required to create or modify registry keys.</exception>
        <exception cref="T:System.IO.IOException">The <see cref="T:Microsoft.Win32.RegistryKey" /> object represents a root-level node, and the operating system is Windows 2000, Windows XP, or Windows Server 2003.</exception>
        <permission cref="T:System.Security.Permissions.RegistryPermission">Para modificar a chave do registro especificado se ele existir, ou para criar a chave do registro se ele ainda não existir. Enumerações associadas: <see cref="F:System.Security.Permissions.RegistryPermissionAccess.Write" />, <see cref="F:System.Security.Permissions.RegistryPermissionAccess.Create" /></permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">para a capacidade de acessar a chave do Registro especificada caso ela seja uma chave remota. Enumeração associada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="M:Microsoft.Win32.RegistryKey.GetValueKind(System.String)" />
        <altmember cref="M:Microsoft.Win32.RegistryKey.GetValue(System.String)" />
        <altmember cref="P:Microsoft.Win32.RegistryKey.ValueCount" />
        <altmember cref="T:Microsoft.Win32.RegistryValueKind" />
      </Docs>
    </Member>
    <Member MemberName="SubKeyCount">
      <MemberSignature Language="C#" Value="public int SubKeyCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 SubKeyCount" />
      <MemberSignature Language="DocId" Value="P:Microsoft.Win32.RegistryKey.SubKeyCount" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SubKeyCount As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int SubKeyCount { int get(); };" />
      <MemberSignature Language="F#" Value="member this.SubKeyCount : int" Usage="Microsoft.Win32.RegistryKey.SubKeyCount" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Retrieves the count of subkeys of the current key.</summary>
        <value>O número de subchaves da chave atual.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Essa propriedade não não nomes de contagem de forma recursiva. Ele retorna somente a contagem de nomes no nível de base do qual ele foi chamado.  
  
   
  
## Examples  
 Este exemplo de código é parte de um exemplo maior fornecido para a <xref:Microsoft.Win32.RegistryKey> classe.  
  
 [!code-cpp[Microsoft.Win32.RegistryKey2#2](~/samples/snippets/cpp/VS_Snippets_CLR/Microsoft.Win32.RegistryKey2/CPP/source.cpp#2)]
 [!code-csharp[Microsoft.Win32.RegistryKey2#2](~/samples/snippets/csharp/VS_Snippets_CLR/Microsoft.Win32.RegistryKey2/CS/source.cs#2)]
 [!code-vb[Microsoft.Win32.RegistryKey2#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/Microsoft.Win32.RegistryKey2/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">The user does not have read permission for the key.</exception>
        <exception cref="T:System.ObjectDisposedException">The <see cref="T:Microsoft.Win32.RegistryKey" /> being manipulated is closed (closed keys cannot be accessed).</exception>
        <exception cref="T:System.UnauthorizedAccessException">The user does not have the necessary registry rights.</exception>
        <exception cref="T:System.IO.IOException">A system error occurred, for example the current key has been deleted.</exception>
        <permission cref="T:System.Security.Permissions.RegistryPermission">para a capacidade de ler a chave do Registro especificada. Enumeração associada: <see cref="F:System.Security.Permissions.RegistryPermissionAccess.Read" /></permission>
        <altmember cref="M:Microsoft.Win32.RegistryKey.GetSubKeyNames" />
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Win32.RegistryKey.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="registryKey.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retrieves a string representation of this key.</summary>
        <returns>A string representing the key. If the specified key is invalid (cannot be found) then <see langword="null" /> is returned.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O valor de retorno inclui o caminho do registro da chave especificada e o valor hexadecimal para a chave. O caminho do registro inclui a raiz absoluta da chave especificada, sempre inicia em uma das chaves de base para o registro, por exemplo, HKEY_LOCAL_MACHINE.  
  
   
  
## Examples  
 Este exemplo de código é parte de um exemplo maior fornecido para a <xref:Microsoft.Win32.RegistryKey> classe.  
  
 [!code-cpp[Microsoft.Win32.RegistryKey2#4](~/samples/snippets/cpp/VS_Snippets_CLR/Microsoft.Win32.RegistryKey2/CPP/source.cpp#4)]
 [!code-csharp[Microsoft.Win32.RegistryKey2#4](~/samples/snippets/csharp/VS_Snippets_CLR/Microsoft.Win32.RegistryKey2/CS/source.cs#4)]
 [!code-vb[Microsoft.Win32.RegistryKey2#4](~/samples/snippets/visualbasic/VS_Snippets_CLR/Microsoft.Win32.RegistryKey2/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">The <see cref="T:Microsoft.Win32.RegistryKey" /> being accessed is closed (closed keys cannot be accessed).</exception>
        <altmember cref="P:Microsoft.Win32.RegistryKey.Name" />
      </Docs>
    </Member>
    <Member MemberName="ValueCount">
      <MemberSignature Language="C#" Value="public int ValueCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 ValueCount" />
      <MemberSignature Language="DocId" Value="P:Microsoft.Win32.RegistryKey.ValueCount" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ValueCount As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int ValueCount { int get(); };" />
      <MemberSignature Language="F#" Value="member this.ValueCount : int" Usage="Microsoft.Win32.RegistryKey.ValueCount" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Retrieves the count of values in the key.</summary>
        <value>O número de pares nome/valor na chave.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cada chave do registro tem um valor padrão que não está associado com qualquer nome. Isso sem nome de valor pode ser definido usando o <xref:Microsoft.Win32.RegistryKey.SetValue%2A> método e especificando o `null` ou cadeia de caracteres vazia ("") para `name`. Se o valor padrão nunca tiver sido definido, ele não contribuem para a contagem total retornada pelo <xref:Microsoft.Win32.RegistryKey.ValueCount%2A> propriedade; depois que ele tiver sido definido, no entanto, ele sempre é contado.  
  
   
  
## Examples  
 Este exemplo de código é parte de um exemplo maior fornecido para a <xref:Microsoft.Win32.RegistryKey> classe.  
  
 [!code-cpp[Microsoft.Win32.RegistryKey2#2](~/samples/snippets/cpp/VS_Snippets_CLR/Microsoft.Win32.RegistryKey2/CPP/source.cpp#2)]
 [!code-csharp[Microsoft.Win32.RegistryKey2#2](~/samples/snippets/csharp/VS_Snippets_CLR/Microsoft.Win32.RegistryKey2/CS/source.cs#2)]
 [!code-vb[Microsoft.Win32.RegistryKey2#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/Microsoft.Win32.RegistryKey2/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">The user does not have read permission for the key.</exception>
        <exception cref="T:System.ObjectDisposedException">The <see cref="T:Microsoft.Win32.RegistryKey" /> being manipulated is closed (closed keys cannot be accessed).</exception>
        <exception cref="T:System.UnauthorizedAccessException">The user does not have the necessary registry rights.</exception>
        <exception cref="T:System.IO.IOException">A system error occurred, for example the current key has been deleted.</exception>
        <permission cref="T:System.Security.Permissions.RegistryPermission">para a capacidade de ler a chave do Registro especificada. Enumeração associada: <see cref="F:System.Security.Permissions.RegistryPermissionAccess.Read" /></permission>
      </Docs>
    </Member>
    <Member MemberName="View">
      <MemberSignature Language="C#" Value="public Microsoft.Win32.RegistryView View { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype Microsoft.Win32.RegistryView View" />
      <MemberSignature Language="DocId" Value="P:Microsoft.Win32.RegistryKey.View" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property View As RegistryView" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Microsoft::Win32::RegistryView View { Microsoft::Win32::RegistryView get(); };" />
      <MemberSignature Language="F#" Value="member this.View : Microsoft.Win32.RegistryView" Usage="Microsoft.Win32.RegistryKey.View" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.RegistryView</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the view that was used to create the registry key.</summary>
        <value>A exibição que foi usada para criar a chave do Registro.  - ou - <see cref="F:Microsoft.Win32.RegistryView.Default" />, se nenhuma exibição foi usada.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nas versões de 64 bits do Windows, as partes do registro são armazenadas separadamente para aplicativos de 32 bits e 64 bits. Há um modo de exibição de 32 bits para aplicativos de 32 bits e um modo de exibição de 64 bits para aplicativos de 64 bits.  
  
 Não suponha que a exibição sempre corresponde à exibição real do <xref:Microsoft.Win32.RegistryKey>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>