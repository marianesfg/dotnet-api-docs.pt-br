<Type Name="Enumerable" FullName="System.Linq.Enumerable">
  <Metadata><Meta Name="ms.openlocfilehash" Value="692edf2fecd751dc6e62858b6b93a6640fb4a65a" /><Meta Name="ms.sourcegitcommit" Value="adc8598fd19d91438cacaa8fa7ce613e28c8218e" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="pt-BR" /><Meta Name="ms.lasthandoff" Value="12/11/2018" /><Meta Name="ms.locfileid" Value="53233530" /></Metadata><TypeSignature Language="C#" Value="public static class Enumerable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed beforefieldinit Enumerable extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Linq.Enumerable" />
  <TypeSignature Language="VB.NET" Value="Public Module Enumerable" />
  <TypeSignature Language="C++ CLI" Value="public ref class Enumerable abstract sealed" />
  <TypeSignature Language="F#" Value="type Enumerable = class" />
  <AssemblyInfo>
    <AssemblyName>System.Linq</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Core</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>3.5.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Fornece um conjunto de métodos <see langword="static" /> (<see langword="Shared" /> no Visual Basic) para consultar objetos que implementam <see cref="T:System.Collections.Generic.IEnumerable`1" />.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Os métodos nessa classe fornecem uma implementação de operadores de consulta padrão para consultar dados de fontes que implementam <xref:System.Collections.Generic.IEnumerable%601>. Operadores de consulta padrão são os métodos de finalidade geral que seguem o [!INCLUDE[vbteclinq](~/includes/vbteclinq-md.md)] padrão e lhe permitem expressar operações de passagem, filtro e projeção sobre dados em qualquer um. Linguagem de programação baseado em NET.  
  
 A maioria dos métodos nessa classe são definidos como métodos de extensão que estendem <xref:System.Collections.Generic.IEnumerable%601>. Isso significa que eles podem ser chamados como um método de instância em qualquer objeto que implementa <xref:System.Collections.Generic.IEnumerable%601>.  
  
 Métodos que são usados em uma consulta que retorna uma sequência de valores não consomem os dados de destino até que o objeto de consulta seja enumerado. Isso é conhecido como execução adiada. Métodos que são usados em uma consulta que retorna um valor singleton execute e consumam os dados de destino imediatamente.  
  
 ]]></format>
    </remarks>
    <related type="Article" href="https://msdn.microsoft.com/library/24cda21e-8af8-4632-b519-c404a839b9b2">Visão geral de operadores de consulta padrão</related>
    <related type="Article" href="https://msdn.microsoft.com/library/175ce3ff-9bbf-4e64-8421-faeb81a0bb51">Métodos de extensão (Guia de Programação em C#)</related>
    <related type="Article" href="https://msdn.microsoft.com/library/b8020aae-374d-46a9-bcb7-8cc2390b93b6">Métodos de extensão (Visual Basic)</related>
  </Docs>
  <Members>
    <Member MemberName="Aggregate&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static TSource Aggregate&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,TSource,TSource&gt; func);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TSource Aggregate&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`3&lt;!!TSource, !!TSource, !!TSource&gt; func) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Aggregate``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``0,``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Aggregate(Of TSource) (source As IEnumerable(Of TSource), func As Func(Of TSource, TSource, TSource)) As TSource" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static TSource Aggregate(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Func&lt;TSource, TSource, TSource&gt; ^ func);" />
      <MemberSignature Language="F#" Value="static member Aggregate : seq&lt;'Source&gt; * Func&lt;'Source, 'Source, 'Source&gt; -&gt; 'Source" Usage="System.Linq.Enumerable.Aggregate (source, func)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TSource</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="func" Type="System.Func&lt;TSource,TSource,TSource&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">O tipo dos elementos de <paramref name="source" />.</typeparam>
        <param name="source">Um <see cref="T:System.Collections.Generic.IEnumerable`1" /> no qual será feita a agregação.</param>
        <param name="func">Uma função de acumulador a ser invocada em cada elemento.</param>
        <summary>Aplica uma função de acumulador a uma sequência.</summary>
        <returns>O valor final do acumulador.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Linq.Enumerable.Aggregate%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2C%60%600%2C%60%600%7D%29> método torna simples para executar um cálculo em uma sequência de valores. Esse método funciona chamando `func` uma vez para cada elemento em `source` , exceto o primeiro deles. Cada vez `func` é chamado, <xref:System.Linq.Enumerable.Aggregate%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2C%60%600%2C%60%600%7D%29> passa os dois o elemento da sequência e um valor agregado (como o primeiro argumento para `func`). O primeiro elemento da `source` é usado como o valor de agregação inicial. O resultado de `func` substitui o valor agregado anterior. <xref:System.Linq.Enumerable.Aggregate%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2C%60%600%2C%60%600%7D%29> Retorna o resultado final da `func`.  
  
 Essa sobrecarga da <xref:System.Linq.Enumerable.Aggregate%2A> método não é adequado para todos os casos porque ele usa o primeiro elemento da `source` como o valor de agregação inicial. Você deve escolher outra sobrecarga se o valor de retorno deve incluir apenas os elementos de `source` que atendem determinada condição. Por exemplo, essa sobrecarga não é confiável para calcular a soma de números pares em `source`. O resultado será incorreto se o primeiro elemento é ímpar em vez do mesmo.  
  
 Para simplificar as operações de agregação comuns, os operadores de consulta padrão também incluem um método de contagem de uso geral <xref:System.Linq.Enumerable.Count%2A>e quatro métodos de agregação numéricas, ou seja, <xref:System.Linq.Enumerable.Min%2A>, <xref:System.Linq.Enumerable.Max%2A>, <xref:System.Linq.Enumerable.Sum%2A>, e <xref:System.Linq.Enumerable.Average%2A>.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como reverter a ordem das palavras em uma cadeia de caracteres usando <xref:System.Linq.Enumerable.Aggregate%2A>.  
  
 [!code-csharp[System.Linq.Enumerable#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#1)]
 [!code-vb[System.Linq.Enumerable#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> ou <paramref name="func" /> é <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="source" /> não contém elementos.</exception>
      </Docs>
    </Member>
    <Member MemberName="Aggregate&lt;TSource,TAccumulate&gt;">
      <MemberSignature Language="C#" Value="public static TAccumulate Aggregate&lt;TSource,TAccumulate&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, TAccumulate seed, Func&lt;TAccumulate,TSource,TAccumulate&gt; func);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TAccumulate Aggregate&lt;TSource, TAccumulate&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, !!TAccumulate seed, class System.Func`3&lt;!!TAccumulate, !!TSource, !!TAccumulate&gt; func) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Aggregate``2(System.Collections.Generic.IEnumerable{``0},``1,System.Func{``1,``0,``1})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Aggregate(Of TSource, TAccumulate) (source As IEnumerable(Of TSource), seed As TAccumulate, func As Func(Of TAccumulate, TSource, TAccumulate)) As TAccumulate" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TAccumulate&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static TAccumulate Aggregate(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, TAccumulate seed, Func&lt;TAccumulate, TSource, TAccumulate&gt; ^ func);" />
      <MemberSignature Language="F#" Value="static member Aggregate : seq&lt;'Source&gt; * 'Accumulate * Func&lt;'Accumulate, 'Source, 'Accumulate&gt; -&gt; 'Accumulate" Usage="System.Linq.Enumerable.Aggregate (source, seed, func)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TAccumulate</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TAccumulate" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="seed" Type="TAccumulate" />
        <Parameter Name="func" Type="System.Func&lt;TAccumulate,TSource,TAccumulate&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">O tipo dos elementos de <paramref name="source" />.</typeparam>
        <typeparam name="TAccumulate">O tipo do valor do acumulador.</typeparam>
        <param name="source">Um <see cref="T:System.Collections.Generic.IEnumerable`1" /> no qual será feita a agregação.</param>
        <param name="seed">O valor inicial do acumulador.</param>
        <param name="func">Uma função de acumulador a ser invocada em cada elemento.</param>
        <summary>Aplica uma função de acumulador a uma sequência. O valor de semente especificado é usado como o valor inicial do acumulador.</summary>
        <returns>O valor final do acumulador.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Linq.Enumerable.Aggregate%60%602%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2C%60%601%2CSystem.Func%7B%60%601%2C%60%600%2C%60%601%7D%29> método torna simples para executar um cálculo em uma sequência de valores. Esse método funciona chamando `func` uma vez para cada elemento em `source`. Cada vez `func` é chamado, <xref:System.Linq.Enumerable.Aggregate%60%602%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2C%60%601%2CSystem.Func%7B%60%601%2C%60%600%2C%60%601%7D%29> passa os dois o elemento da sequência e um valor agregado (como o primeiro argumento para `func`). O valor da `seed` parâmetro é usado como o valor de agregação inicial. O resultado de `func` substitui o valor agregado anterior. <xref:System.Linq.Enumerable.Aggregate%60%602%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2C%60%601%2CSystem.Func%7B%60%601%2C%60%600%2C%60%601%7D%29> Retorna o resultado final da `func`.  
  
 Para simplificar as operações de agregação comuns, os operadores de consulta padrão também incluem um método de contagem de uso geral <xref:System.Linq.Enumerable.Count%2A>e quatro métodos de agregação numéricas, ou seja, <xref:System.Linq.Enumerable.Min%2A>, <xref:System.Linq.Enumerable.Max%2A>, <xref:System.Linq.Enumerable.Sum%2A>, e <xref:System.Linq.Enumerable.Average%2A>.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como usar <xref:System.Linq.Enumerable.Aggregate%2A> para aplicar uma função de acumulador e usar um valor de semente.  
  
 [!code-csharp[System.Linq.Enumerable#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#2)]
 [!code-vb[System.Linq.Enumerable#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> ou <paramref name="func" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Aggregate&lt;TSource,TAccumulate,TResult&gt;">
      <MemberSignature Language="C#" Value="public static TResult Aggregate&lt;TSource,TAccumulate,TResult&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, TAccumulate seed, Func&lt;TAccumulate,TSource,TAccumulate&gt; func, Func&lt;TAccumulate,TResult&gt; resultSelector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TResult Aggregate&lt;TSource, TAccumulate, TResult&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, !!TAccumulate seed, class System.Func`3&lt;!!TAccumulate, !!TSource, !!TAccumulate&gt; func, class System.Func`2&lt;!!TAccumulate, !!TResult&gt; resultSelector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Aggregate``3(System.Collections.Generic.IEnumerable{``0},``1,System.Func{``1,``0,``1},System.Func{``1,``2})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Aggregate(Of TSource, TAccumulate, TResult) (source As IEnumerable(Of TSource), seed As TAccumulate, func As Func(Of TAccumulate, TSource, TAccumulate), resultSelector As Func(Of TAccumulate, TResult)) As TResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TAccumulate, typename TResult&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static TResult Aggregate(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, TAccumulate seed, Func&lt;TAccumulate, TSource, TAccumulate&gt; ^ func, Func&lt;TAccumulate, TResult&gt; ^ resultSelector);" />
      <MemberSignature Language="F#" Value="static member Aggregate : seq&lt;'Source&gt; * 'Accumulate * Func&lt;'Accumulate, 'Source, 'Accumulate&gt; * Func&lt;'Accumulate, 'Result&gt; -&gt; 'Result" Usage="System.Linq.Enumerable.Aggregate (source, seed, func, resultSelector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TAccumulate" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="seed" Type="TAccumulate" />
        <Parameter Name="func" Type="System.Func&lt;TAccumulate,TSource,TAccumulate&gt;" />
        <Parameter Name="resultSelector" Type="System.Func&lt;TAccumulate,TResult&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">O tipo dos elementos de <paramref name="source" />.</typeparam>
        <typeparam name="TAccumulate">O tipo do valor do acumulador.</typeparam>
        <typeparam name="TResult">O tipo do valor resultante.</typeparam>
        <param name="source">Um <see cref="T:System.Collections.Generic.IEnumerable`1" /> no qual será feita a agregação.</param>
        <param name="seed">O valor inicial do acumulador.</param>
        <param name="func">Uma função de acumulador a ser invocada em cada elemento.</param>
        <param name="resultSelector">Uma função para transformar o valor final do acumulador no valor de resultado.</param>
        <summary>Aplica uma função de acumulador a uma sequência. O valor de semente especificado é usado como o valor inicial do acumulador e a função especificada é usada para selecionar o valor do resultado.</summary>
        <returns>O valor final do acumulador transformado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Linq.Enumerable.Aggregate%60%603%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2C%60%601%2CSystem.Func%7B%60%601%2C%60%600%2C%60%601%7D%2CSystem.Func%7B%60%601%2C%60%602%7D%29> método torna simples para executar um cálculo em uma sequência de valores. Esse método funciona chamando `func` uma vez para cada elemento em `source`. Cada vez `func` é chamado, <xref:System.Linq.Enumerable.Aggregate%60%603%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2C%60%601%2CSystem.Func%7B%60%601%2C%60%600%2C%60%601%7D%2CSystem.Func%7B%60%601%2C%60%602%7D%29> passa os dois o elemento da sequência e um valor agregado (como o primeiro argumento para `func`). O valor da `seed` parâmetro é usado como o valor de agregação inicial. O resultado de `func` substitui o valor agregado anterior. O resultado final da `func` é passado para `resultSelector` para obter o resultado final de <xref:System.Linq.Enumerable.Aggregate%60%603%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2C%60%601%2CSystem.Func%7B%60%601%2C%60%600%2C%60%601%7D%2CSystem.Func%7B%60%601%2C%60%602%7D%29>.  
  
 Para simplificar as operações de agregação comuns, os operadores de consulta padrão também incluem um método de contagem de uso geral <xref:System.Linq.Enumerable.Count%2A>e quatro métodos de agregação numéricas, ou seja, <xref:System.Linq.Enumerable.Min%2A>, <xref:System.Linq.Enumerable.Max%2A>, <xref:System.Linq.Enumerable.Sum%2A>, e <xref:System.Linq.Enumerable.Average%2A>.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como usar <xref:System.Linq.Enumerable.Aggregate%2A> para aplicar uma função de acumulador e um seletor de resultado.  
  
 [!code-csharp[System.Linq.Enumerable#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#3)]
 [!code-vb[System.Linq.Enumerable#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" />, <paramref name="func" /> ou <paramref name="resultSelector" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="All&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static bool All&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,bool&gt; predicate);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool All&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, bool&gt; predicate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.All``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Boolean})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function All(Of TSource) (source As IEnumerable(Of TSource), predicate As Func(Of TSource, Boolean)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static bool All(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Func&lt;TSource, bool&gt; ^ predicate);" />
      <MemberSignature Language="F#" Value="static member All : seq&lt;'Source&gt; * Func&lt;'Source, bool&gt; -&gt; bool" Usage="System.Linq.Enumerable.All (source, predicate)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="predicate" Type="System.Func&lt;TSource,System.Boolean&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">O tipo dos elementos de <paramref name="source" />.</typeparam>
        <param name="source">Um <see cref="T:System.Collections.Generic.IEnumerable`1" /> que contém os elementos aos quais o predicado será aplicado.</param>
        <param name="predicate">Uma função para testar cada elemento em relação a uma condição.</param>
        <summary>Determina se todos os elementos de uma sequência atendem a uma condição.</summary>
        <returns><see langword="true" /> se todos os elementos da sequência de origem passarem no teste no predicado especificado ou se a sequência for vazia; caso contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Esse método não retorna todos os elementos de uma coleção. Em vez disso, ele determina se todos os elementos de uma coleção satisfazem uma condição.  
  
 A enumeração de `source` é interrompido assim que o resultado pode ser determinado.  
  
 Na sintaxe de expressão de consulta do Visual Basic, uma `Aggregate Into All()` cláusula se traduz em uma invocação de <xref:System.Linq.Enumerable.All%2A>.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como usar <xref:System.Linq.Enumerable.All%2A> para determinar se todos os elementos em uma sequência satisfazem uma condição. Variável `allStartWithB` é true se todos os nomes de animal de estimação iniciar com "B" ou se o `pets` matriz está vazia.  
  
 [!code-csharp[System.Linq.Enumerable#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#4)]
 [!code-vb[System.Linq.Enumerable#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#4)]  
  
 O valor booleano que o <xref:System.Linq.Enumerable.All%2A> método retorna, normalmente é usada no predicado de um `where` cláusula (`Where` cláusula no Visual Basic) ou uma chamada direta para o <xref:System.Linq.Enumerable.Where%2A> método. O exemplo a seguir demonstra o uso do `All` método.  
  
 [!code-csharp[System.Linq.Enumerable#129](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#129)]
 [!code-vb[System.Linq.Enumerable#129](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#129)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> ou <paramref name="predicate" /> é <see langword="null" />.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/1315a814-5db6-4077-b34b-b141e11cc0eb">Cláusula Aggregate (Visual Basic)</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Any&lt;TSource&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Determina se qualquer elemento de uma sequência existe ou atende a uma condição.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Any&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static bool Any&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Any&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Any``1(System.Collections.Generic.IEnumerable{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Any(Of TSource) (source As IEnumerable(Of TSource)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static bool Any(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Any : seq&lt;'Source&gt; -&gt; bool" Usage="System.Linq.Enumerable.Any source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">O tipo dos elementos de <paramref name="source" />.</typeparam>
        <param name="source">O <see cref="T:System.Collections.Generic.IEnumerable`1" /> a ser verificado se está vazio.</param>
        <summary>Determina se uma sequência contém elementos.</summary>
        <returns><see langword="true" /> se a sequência de origem contiver elementos; caso contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Esse método não retorna qualquer elemento de uma coleção. Em vez disso, ele determina se a coleção contém quaisquer elementos.  
  
 A enumeração de `source` é interrompido assim que o resultado pode ser determinado.  
  
 Na sintaxe de expressão de consulta do Visual Basic, uma `Aggregate Into Any()` cláusula se traduz em uma invocação de <xref:System.Linq.Enumerable.Any%2A>.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como usar <xref:System.Linq.Enumerable.Any%2A> para determinar se uma sequência contém elementos.  
  
 [!code-csharp[System.Linq.Enumerable#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#5)]
 [!code-vb[System.Linq.Enumerable#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#5)]  
  
 O valor booleano que o <xref:System.Linq.Enumerable.Any%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%29> método retorna, normalmente é usada no predicado de um `where` cláusula (`Where` cláusula no Visual Basic) ou uma chamada direta para o <xref:System.Linq.Enumerable.Where%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Boolean%7D%29> método. O exemplo a seguir demonstra o uso do `Any` método.  
  
 [!code-csharp[System.Linq.Enumerable#130](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#130)]
 [!code-vb[System.Linq.Enumerable#130](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#130)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> é <see langword="null" />.</exception>
        <altmember cref="M:System.Linq.Enumerable.Any``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Boolean})" />
        <related type="Article" href="https://msdn.microsoft.com/library/1315a814-5db6-4077-b34b-b141e11cc0eb">Cláusula Aggregate (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Any&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static bool Any&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,bool&gt; predicate);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Any&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, bool&gt; predicate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Any``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Boolean})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Any(Of TSource) (source As IEnumerable(Of TSource), predicate As Func(Of TSource, Boolean)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static bool Any(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Func&lt;TSource, bool&gt; ^ predicate);" />
      <MemberSignature Language="F#" Value="static member Any : seq&lt;'Source&gt; * Func&lt;'Source, bool&gt; -&gt; bool" Usage="System.Linq.Enumerable.Any (source, predicate)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="predicate" Type="System.Func&lt;TSource,System.Boolean&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">O tipo dos elementos de <paramref name="source" />.</typeparam>
        <param name="source">Um <see cref="T:System.Collections.Generic.IEnumerable`1" /> a cujos elementos o predicado será aplicado.</param>
        <param name="predicate">Uma função para testar cada elemento em relação a uma condição.</param>
        <summary>Determina se algum elemento de uma sequência atende a uma condição.</summary>
        <returns><see langword="true" /> se algum elemento na sequência de origem for aprovado no teste do predicado especificado; caso contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Esse método não retorna qualquer elemento de uma coleção. Em vez disso, ele determina se os elementos de uma coleção satisfazem uma condição.  
  
 A enumeração de `source` é interrompido assim que o resultado pode ser determinado.  
  
 Na sintaxe de expressão de consulta do Visual Basic, uma `Aggregate Into Any()` cláusula se traduz em uma invocação de <xref:System.Linq.Enumerable.Any%2A>.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como usar <xref:System.Linq.Enumerable.Any%2A> para determinar se qualquer elemento em uma sequência satisfazem uma condição.  
  
 [!code-csharp[System.Linq.Enumerable#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#6)]
 [!code-vb[System.Linq.Enumerable#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> ou <paramref name="predicate" /> é <see langword="null" />.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/1315a814-5db6-4077-b34b-b141e11cc0eb">Cláusula Aggregate (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Append&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;TSource&gt; Append&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, TSource element);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; Append&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, !!TSource element) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Append``1(System.Collections.Generic.IEnumerable{``0},``0)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Append(Of TSource) (source As IEnumerable(Of TSource), element As TSource) As IEnumerable(Of TSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ Append(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, TSource element);" />
      <MemberSignature Language="F#" Value="static member Append : seq&lt;'Source&gt; * 'Source -&gt; seq&lt;'Source&gt;" Usage="System.Linq.Enumerable.Append (source, element)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netstandard-2.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="element" Type="TSource" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">O tipo dos elementos de <paramref name="source" />.</typeparam>
        <param name="source">Uma sequência de valores.</param>
        <param name="element">O valor a ser acrescentado a <paramref name="source" />.</param>
        <summary>Acrescenta um valor ao final da sequência.</summary>
        <returns>Uma nova sequência que termina com <paramref name="element" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Esse método não modifica os elementos da coleção. Em vez disso, ele cria uma cópia da coleção com o novo elemento.
  
## Examples  
 O exemplo de código a seguir demonstra como usar <xref:System.Linq.Enumerable.Append%2A> para acrescentar um valor ao final da sequência.  
  
 [!code-csharp[System.Linq.Enumerable#201](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#201)]
 [!code-vb[System.Linq.Enumerable#201](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#201)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="AsEnumerable&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;TSource&gt; AsEnumerable&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; AsEnumerable&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.AsEnumerable``1(System.Collections.Generic.IEnumerable{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function AsEnumerable(Of TSource) (source As IEnumerable(Of TSource)) As IEnumerable(Of TSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ AsEnumerable(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member AsEnumerable : seq&lt;'Source&gt; -&gt; seq&lt;'Source&gt;" Usage="System.Linq.Enumerable.AsEnumerable source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">O tipo dos elementos de <paramref name="source" />.</typeparam>
        <param name="source">A sequência a ser digitada como <see cref="T:System.Collections.Generic.IEnumerable`1" />.</param>
        <summary>Retorna a entrada digitada como <see cref="T:System.Collections.Generic.IEnumerable`1" />.</summary>
        <returns>A sequência de entrada digitada como <see cref="T:System.Collections.Generic.IEnumerable`1" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Linq.Enumerable.AsEnumerable%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%29> método não tem nenhum efeito diferente de alterar o tipo de tempo de compilação de `source` de um tipo que implementa <xref:System.Collections.Generic.IEnumerable%601> para <xref:System.Collections.Generic.IEnumerable%601> em si.  
  
 <xref:System.Linq.Enumerable.AsEnumerable%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%29> pode ser usado para escolher entre implementações de consulta quando uma sequência implementa <xref:System.Collections.Generic.IEnumerable%601> , mas também tem um conjunto diferente de métodos de consulta públicas disponíveis. Por exemplo, dada uma classe genérica `Table` que implementa <xref:System.Collections.Generic.IEnumerable%601> e tem seus próprios métodos, como `Where`, `Select`, e `SelectMany`, uma chamada para `Where` invocaria o público `Where` método `Table`. Um `Table` tipo que representa uma tabela de banco de dados poderia ter um `Where` método que usa o argumento como uma árvore de expressão de predicado e converte a árvore para o SQL para execução remota. Se a execução remota não for desejada, por exemplo porque o predicado invoca um método de local, o <xref:System.Linq.Enumerable.AsEnumerable%2A> método pode ser usado para ocultar os métodos personalizados e disponibilizar os operadores de consulta padrão em vez disso.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como usar <xref:System.Linq.Enumerable.AsEnumerable%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%29> para ocultar um tipo do personalizado `Where` método quando a implementação do operador de consulta padrão é desejada.  
  
 [!code-csharp[System.Linq.Enumerable#108](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#108)]
 [!code-vb[System.Linq.Enumerable#108](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#108)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Average">
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Computa a média de uma sequência de valores numéricos.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Average">
      <MemberSignature Language="C#" Value="public static decimal Average (this System.Collections.Generic.IEnumerable&lt;decimal&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Decimal Average(class System.Collections.Generic.IEnumerable`1&lt;valuetype System.Decimal&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Average(System.Collections.Generic.IEnumerable{System.Decimal})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Average (source As IEnumerable(Of Decimal)) As Decimal" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Decimal Average(System::Collections::Generic::IEnumerable&lt;System::Decimal&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Average : seq&lt;decimal&gt; -&gt; decimal" Usage="System.Linq.Enumerable.Average source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;System.Decimal&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Uma sequência de valores <see cref="T:System.Decimal" /> para realizar o cálculo da média.</param>
        <summary>Computa a média de uma sequência de valores <see cref="T:System.Decimal" />.</summary>
        <returns>A média da sequência de valores.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Na sintaxe de expressão de consulta do Visual Basic, uma `Aggregate Into Average()` cláusula se traduz em uma invocação de <xref:System.Linq.Enumerable.Average%2A>.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como usar <xref:System.Linq.Enumerable.Average%28System.Collections.Generic.IEnumerable%7BSystem.Int32%7D%29> para calcular a média de uma sequência de valores.  
  
 [!INCLUDE[sqo_diff_overload_example_elementtype](~/includes/sqo-diff-overload-example-elementtype-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#8)]
 [!code-vb[System.Linq.Enumerable#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> é <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="source" /> não contém elementos.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/1315a814-5db6-4077-b34b-b141e11cc0eb">Cláusula Aggregate (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Average">
      <MemberSignature Language="C#" Value="public static double Average (this System.Collections.Generic.IEnumerable&lt;double&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Average(class System.Collections.Generic.IEnumerable`1&lt;float64&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Average(System.Collections.Generic.IEnumerable{System.Double})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Average (source As IEnumerable(Of Double)) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static double Average(System::Collections::Generic::IEnumerable&lt;double&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Average : seq&lt;double&gt; -&gt; double" Usage="System.Linq.Enumerable.Average source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;System.Double&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Uma sequência de valores <see cref="T:System.Double" /> para realizar o cálculo da média.</param>
        <summary>Computa a média de uma sequência de valores <see cref="T:System.Double" />.</summary>
        <returns>A média da sequência de valores.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se a soma dos elementos é muito grande para ser representado como um <xref:System.Double>, esse método retorna infinito positivo ou negativo.  
  
 Na sintaxe de expressão de consulta do Visual Basic, uma `Aggregate Into Average()` cláusula se traduz em uma invocação de <xref:System.Linq.Enumerable.Average%2A>.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como usar <xref:System.Linq.Enumerable.Average%28System.Collections.Generic.IEnumerable%7BSystem.Int32%7D%29> para calcular uma média.  
  
 [!INCLUDE[sqo_diff_overload_example_elementtype](~/includes/sqo-diff-overload-example-elementtype-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#8)]
 [!code-vb[System.Linq.Enumerable#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> é <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="source" /> não contém elementos.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/1315a814-5db6-4077-b34b-b141e11cc0eb">Cláusula Aggregate (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Average">
      <MemberSignature Language="C#" Value="public static double Average (this System.Collections.Generic.IEnumerable&lt;int&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Average(class System.Collections.Generic.IEnumerable`1&lt;int32&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Average(System.Collections.Generic.IEnumerable{System.Int32})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Average (source As IEnumerable(Of Integer)) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static double Average(System::Collections::Generic::IEnumerable&lt;int&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Average : seq&lt;int&gt; -&gt; double" Usage="System.Linq.Enumerable.Average source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;System.Int32&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Uma sequência de valores <see cref="T:System.Int32" /> para realizar o cálculo da média.</param>
        <summary>Computa a média de uma sequência de valores <see cref="T:System.Int32" />.</summary>
        <returns>A média da sequência de valores.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Na sintaxe de expressão de consulta do Visual Basic, uma `Aggregate Into Average()` cláusula se traduz em uma invocação de <xref:System.Linq.Enumerable.Average%2A>.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como usar <xref:System.Linq.Enumerable.Average%28System.Collections.Generic.IEnumerable%7BSystem.Int32%7D%29> para calcular uma média.  
  
 [!code-csharp[System.Linq.Enumerable#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#8)]
 [!code-vb[System.Linq.Enumerable#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> é <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="source" /> não contém elementos.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/1315a814-5db6-4077-b34b-b141e11cc0eb">Cláusula Aggregate (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Average">
      <MemberSignature Language="C#" Value="public static double Average (this System.Collections.Generic.IEnumerable&lt;long&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Average(class System.Collections.Generic.IEnumerable`1&lt;int64&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Average(System.Collections.Generic.IEnumerable{System.Int64})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Average (source As IEnumerable(Of Long)) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static double Average(System::Collections::Generic::IEnumerable&lt;long&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Average : seq&lt;int64&gt; -&gt; double" Usage="System.Linq.Enumerable.Average source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;System.Int64&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Uma sequência de valores <see cref="T:System.Int64" /> para realizar o cálculo da média.</param>
        <summary>Computa a média de uma sequência de valores <see cref="T:System.Int64" />.</summary>
        <returns>A média da sequência de valores.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Na sintaxe de expressão de consulta do Visual Basic, uma `Aggregate Into Average()` cláusula se traduz em uma invocação de <xref:System.Linq.Enumerable.Average%2A>.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como usar <xref:System.Linq.Enumerable.Average%28System.Collections.Generic.IEnumerable%7BSystem.Int32%7D%29> para calcular uma média.  
  
 [!INCLUDE[sqo_diff_overload_example_elementtype](~/includes/sqo-diff-overload-example-elementtype-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#8)]
 [!code-vb[System.Linq.Enumerable#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> é <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="source" /> não contém elementos.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/1315a814-5db6-4077-b34b-b141e11cc0eb">Cláusula Aggregate (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Average">
      <MemberSignature Language="C#" Value="public static Nullable&lt;decimal&gt; Average (this System.Collections.Generic.IEnumerable&lt;Nullable&lt;decimal&gt;&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;valuetype System.Decimal&gt; Average(class System.Collections.Generic.IEnumerable`1&lt;valuetype System.Nullable`1&lt;valuetype System.Decimal&gt;&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Average(System.Collections.Generic.IEnumerable{System.Nullable{System.Decimal}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Average (source As IEnumerable(Of Nullable(Of Decimal))) As Nullable(Of Decimal)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Nullable&lt;System::Decimal&gt; Average(System::Collections::Generic::IEnumerable&lt;Nullable&lt;System::Decimal&gt;&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Average : seq&lt;Nullable&lt;decimal&gt;&gt; -&gt; Nullable&lt;decimal&gt;" Usage="System.Linq.Enumerable.Average source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Decimal&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;System.Nullable&lt;System.Decimal&gt;&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Uma sequência de valores <see cref="T:System.Decimal" /> que permitem valores nulos para cálculo da média.</param>
        <summary>Computa a média de uma sequência de valores <see cref="T:System.Decimal" /> que permitem valores nulos.</summary>
        <returns>A média da sequência de valores ou <see langword="null" />, se a sequência de origem estiver vazia ou contiver somente valores que são <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Na sintaxe de expressão de consulta do Visual Basic, uma `Aggregate Into Average()` cláusula se traduz em uma invocação de <xref:System.Linq.Enumerable.Average%2A>.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como usar <xref:System.Linq.Enumerable.Average%28System.Collections.Generic.IEnumerable%7BSystem.Nullable%7BSystem.Int64%7D%7D%29> para calcular uma média.  
  
 [!INCLUDE[sqo_diff_overload_example_elementtype](~/includes/sqo-diff-overload-example-elementtype-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#12)]
 [!code-vb[System.Linq.Enumerable#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#12)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> é <see langword="null" />.</exception>
        <exception cref="T:System.OverflowException">A soma dos elementos na sequência é maior do que <see cref="F:System.Decimal.MaxValue" />.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/1315a814-5db6-4077-b34b-b141e11cc0eb">Cláusula Aggregate (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Average">
      <MemberSignature Language="C#" Value="public static Nullable&lt;double&gt; Average (this System.Collections.Generic.IEnumerable&lt;Nullable&lt;double&gt;&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;float64&gt; Average(class System.Collections.Generic.IEnumerable`1&lt;valuetype System.Nullable`1&lt;float64&gt;&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Average(System.Collections.Generic.IEnumerable{System.Nullable{System.Double}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Average (source As IEnumerable(Of Nullable(Of Double))) As Nullable(Of Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Nullable&lt;double&gt; Average(System::Collections::Generic::IEnumerable&lt;Nullable&lt;double&gt;&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Average : seq&lt;Nullable&lt;double&gt;&gt; -&gt; Nullable&lt;double&gt;" Usage="System.Linq.Enumerable.Average source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Double&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;System.Nullable&lt;System.Double&gt;&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Uma sequência de valores <see cref="T:System.Double" /> que permitem valores nulos para cálculo da média.</param>
        <summary>Computa a média de uma sequência de valores <see cref="T:System.Double" /> que permitem valores nulos.</summary>
        <returns>A média da sequência de valores ou <see langword="null" />, se a sequência de origem estiver vazia ou contiver somente valores que são <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se a soma dos elementos é muito grande para ser representado como um <xref:System.Double>, esse método retorna infinito positivo ou negativo.  
  
 Na sintaxe de expressão de consulta do Visual Basic, uma `Aggregate Into Average()` cláusula se traduz em uma invocação de <xref:System.Linq.Enumerable.Average%2A>.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como usar <xref:System.Linq.Enumerable.Average%28System.Collections.Generic.IEnumerable%7BSystem.Nullable%7BSystem.Int64%7D%7D%29> para calcular uma média.  
  
 [!INCLUDE[sqo_diff_overload_example_elementtype](~/includes/sqo-diff-overload-example-elementtype-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#12)]
 [!code-vb[System.Linq.Enumerable#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#12)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> é <see langword="null" />.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/1315a814-5db6-4077-b34b-b141e11cc0eb">Cláusula Aggregate (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Average">
      <MemberSignature Language="C#" Value="public static Nullable&lt;double&gt; Average (this System.Collections.Generic.IEnumerable&lt;Nullable&lt;int&gt;&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;float64&gt; Average(class System.Collections.Generic.IEnumerable`1&lt;valuetype System.Nullable`1&lt;int32&gt;&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Average(System.Collections.Generic.IEnumerable{System.Nullable{System.Int32}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Average (source As IEnumerable(Of Nullable(Of Integer))) As Nullable(Of Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Nullable&lt;double&gt; Average(System::Collections::Generic::IEnumerable&lt;Nullable&lt;int&gt;&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Average : seq&lt;Nullable&lt;int&gt;&gt; -&gt; Nullable&lt;double&gt;" Usage="System.Linq.Enumerable.Average source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Double&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;System.Nullable&lt;System.Int32&gt;&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Uma sequência de valores <see cref="T:System.Int32" /> que permitem valores nulos para cálculo da média.</param>
        <summary>Computa a média de uma sequência de valores <see cref="T:System.Int32" /> que permitem valores nulos.</summary>
        <returns>A média da sequência de valores ou <see langword="null" />, se a sequência de origem estiver vazia ou contiver somente valores que são <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Na sintaxe de expressão de consulta do Visual Basic, uma `Aggregate Into Average()` cláusula se traduz em uma invocação de <xref:System.Linq.Enumerable.Average%2A>.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como usar <xref:System.Linq.Enumerable.Average%28System.Collections.Generic.IEnumerable%7BSystem.Nullable%7BSystem.Int64%7D%7D%29> para calcular uma média.  
  
 [!INCLUDE[sqo_diff_overload_example_elementtype](~/includes/sqo-diff-overload-example-elementtype-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#12)]
 [!code-vb[System.Linq.Enumerable#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#12)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> é <see langword="null" />.</exception>
        <exception cref="T:System.OverflowException">A soma dos elementos na sequência é maior do que <see cref="F:System.Int64.MaxValue" />.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/1315a814-5db6-4077-b34b-b141e11cc0eb">Cláusula Aggregate (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Average">
      <MemberSignature Language="C#" Value="public static Nullable&lt;double&gt; Average (this System.Collections.Generic.IEnumerable&lt;Nullable&lt;long&gt;&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;float64&gt; Average(class System.Collections.Generic.IEnumerable`1&lt;valuetype System.Nullable`1&lt;int64&gt;&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Average(System.Collections.Generic.IEnumerable{System.Nullable{System.Int64}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Average (source As IEnumerable(Of Nullable(Of Long))) As Nullable(Of Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Nullable&lt;double&gt; Average(System::Collections::Generic::IEnumerable&lt;Nullable&lt;long&gt;&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Average : seq&lt;Nullable&lt;int64&gt;&gt; -&gt; Nullable&lt;double&gt;" Usage="System.Linq.Enumerable.Average source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Double&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;System.Nullable&lt;System.Int64&gt;&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Uma sequência de valores <see cref="T:System.Int64" /> que permitem valores nulos para cálculo da média.</param>
        <summary>Computa a média de uma sequência de valores <see cref="T:System.Int64" /> que permitem valores nulos.</summary>
        <returns>A média da sequência de valores ou <see langword="null" />, se a sequência de origem estiver vazia ou contiver somente valores que são <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Na sintaxe de expressão de consulta do Visual Basic, uma `Aggregate Into Average()` cláusula se traduz em uma invocação de <xref:System.Linq.Enumerable.Average%2A>.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como usar <xref:System.Linq.Enumerable.Average%28System.Collections.Generic.IEnumerable%7BSystem.Nullable%7BSystem.Int64%7D%7D%29> para calcular uma média.  
  
 [!code-csharp[System.Linq.Enumerable#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#12)]
 [!code-vb[System.Linq.Enumerable#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#12)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> é <see langword="null" />.</exception>
        <exception cref="T:System.OverflowException">A soma dos elementos na sequência é maior do que <see cref="F:System.Int64.MaxValue" />.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/1315a814-5db6-4077-b34b-b141e11cc0eb">Cláusula Aggregate (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Average">
      <MemberSignature Language="C#" Value="public static Nullable&lt;float&gt; Average (this System.Collections.Generic.IEnumerable&lt;Nullable&lt;float&gt;&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;float32&gt; Average(class System.Collections.Generic.IEnumerable`1&lt;valuetype System.Nullable`1&lt;float32&gt;&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Average(System.Collections.Generic.IEnumerable{System.Nullable{System.Single}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Average (source As IEnumerable(Of Nullable(Of Single))) As Nullable(Of Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Nullable&lt;float&gt; Average(System::Collections::Generic::IEnumerable&lt;Nullable&lt;float&gt;&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Average : seq&lt;Nullable&lt;single&gt;&gt; -&gt; Nullable&lt;single&gt;" Usage="System.Linq.Enumerable.Average source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Single&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;System.Nullable&lt;System.Single&gt;&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Uma sequência de valores <see cref="T:System.Single" /> que permitem valores nulos para cálculo da média.</param>
        <summary>Computa a média de uma sequência de valores <see cref="T:System.Single" /> que permitem valores nulos.</summary>
        <returns>A média da sequência de valores ou <see langword="null" />, se a sequência de origem estiver vazia ou contiver somente valores que são <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Na sintaxe de expressão de consulta do Visual Basic, uma `Aggregate Into Average()` cláusula se traduz em uma invocação de <xref:System.Linq.Enumerable.Average%2A>.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como usar <xref:System.Linq.Enumerable.Average%28System.Collections.Generic.IEnumerable%7BSystem.Nullable%7BSystem.Int64%7D%7D%29> para calcular uma média.  
  
 [!INCLUDE[sqo_diff_overload_example_elementtype](~/includes/sqo-diff-overload-example-elementtype-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#12)]
 [!code-vb[System.Linq.Enumerable#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#12)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> é <see langword="null" />.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/1315a814-5db6-4077-b34b-b141e11cc0eb">Cláusula Aggregate (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Average">
      <MemberSignature Language="C#" Value="public static float Average (this System.Collections.Generic.IEnumerable&lt;float&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 Average(class System.Collections.Generic.IEnumerable`1&lt;float32&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Average(System.Collections.Generic.IEnumerable{System.Single})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Average (source As IEnumerable(Of Single)) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static float Average(System::Collections::Generic::IEnumerable&lt;float&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Average : seq&lt;single&gt; -&gt; single" Usage="System.Linq.Enumerable.Average source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;System.Single&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Uma sequência de valores <see cref="T:System.Single" /> para realizar o cálculo da média.</param>
        <summary>Computa a média de uma sequência de valores <see cref="T:System.Single" />.</summary>
        <returns>A média da sequência de valores.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Na sintaxe de expressão de consulta do Visual Basic, uma `Aggregate Into Average()` cláusula se traduz em uma invocação de <xref:System.Linq.Enumerable.Average%2A>.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como usar <xref:System.Linq.Enumerable.Average%28System.Collections.Generic.IEnumerable%7BSystem.Int32%7D%29> para calcular uma média.  
  
 [!INCLUDE[sqo_diff_overload_example_elementtype](~/includes/sqo-diff-overload-example-elementtype-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#8)]
 [!code-vb[System.Linq.Enumerable#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> é <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="source" /> não contém elementos.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/1315a814-5db6-4077-b34b-b141e11cc0eb">Cláusula Aggregate (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Average&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static decimal Average&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,decimal&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Decimal Average&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, valuetype System.Decimal&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Average``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Decimal})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Average(Of TSource) (source As IEnumerable(Of TSource), selector As Func(Of TSource, Decimal)) As Decimal" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Decimal Average(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Func&lt;TSource, System::Decimal&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="static member Average : seq&lt;'Source&gt; * Func&lt;'Source, decimal&gt; -&gt; decimal" Usage="System.Linq.Enumerable.Average (source, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Decimal&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">O tipo dos elementos de <paramref name="source" />.</typeparam>
        <param name="source">Uma sequência de valores usados para calcular uma média.</param>
        <param name="selector">Uma função de transformação a ser aplicada a cada elemento.</param>
        <summary>Calcula a média de uma sequência de valores <see cref="T:System.Decimal" /> obtidos pela invocação de uma função de transformação em cada elemento da sequência de entrada.</summary>
        <returns>A média da sequência de valores.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Na sintaxe de expressão de consulta do Visual Basic, uma `Aggregate Into Average()` cláusula se traduz em uma invocação de <xref:System.Linq.Enumerable.Average%2A>.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como usar <xref:System.Linq.Enumerable.Average%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Int64%7D%29> para calcular uma média.  
  
 [!INCLUDE[sqo_diff_overload_example_func](~/includes/sqo-diff-overload-example-func-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#16](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#16)]
 [!code-vb[System.Linq.Enumerable#16](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#16)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> ou <paramref name="selector" /> é <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="source" /> não contém elementos.</exception>
        <exception cref="T:System.OverflowException">A soma dos elementos na sequência é maior do que <see cref="F:System.Decimal.MaxValue" />.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/1315a814-5db6-4077-b34b-b141e11cc0eb">Cláusula Aggregate (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Average&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static double Average&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,double&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Average&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, float64&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Average``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Double})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Average(Of TSource) (source As IEnumerable(Of TSource), selector As Func(Of TSource, Double)) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static double Average(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Func&lt;TSource, double&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="static member Average : seq&lt;'Source&gt; * Func&lt;'Source, double&gt; -&gt; double" Usage="System.Linq.Enumerable.Average (source, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Double&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">O tipo dos elementos de <paramref name="source" />.</typeparam>
        <param name="source">Uma sequência de valores para cálculo da média.</param>
        <param name="selector">Uma função de transformação a ser aplicada a cada elemento.</param>
        <summary>Calcula a média de uma sequência de valores <see cref="T:System.Double" /> obtidos pela invocação de uma função de transformação em cada elemento da sequência de entrada.</summary>
        <returns>A média da sequência de valores.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Na sintaxe de expressão de consulta do Visual Basic, uma `Aggregate Into Average()` cláusula se traduz em uma invocação de <xref:System.Linq.Enumerable.Average%2A>.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como usar <xref:System.Linq.Enumerable.Average%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Int64%7D%29> para calcular uma média.  
  
 [!INCLUDE[sqo_diff_overload_example_func](~/includes/sqo-diff-overload-example-func-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#16](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#16)]
 [!code-vb[System.Linq.Enumerable#16](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#16)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> ou <paramref name="selector" /> é <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="source" /> não contém elementos.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/1315a814-5db6-4077-b34b-b141e11cc0eb">Cláusula Aggregate (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Average&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static double Average&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,int&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Average&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, int32&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Average``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Int32})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Average(Of TSource) (source As IEnumerable(Of TSource), selector As Func(Of TSource, Integer)) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static double Average(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Func&lt;TSource, int&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="static member Average : seq&lt;'Source&gt; * Func&lt;'Source, int&gt; -&gt; double" Usage="System.Linq.Enumerable.Average (source, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Int32&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">O tipo dos elementos de <paramref name="source" />.</typeparam>
        <param name="source">Uma sequência de valores para cálculo da média.</param>
        <param name="selector">Uma função de transformação a ser aplicada a cada elemento.</param>
        <summary>Calcula a média de uma sequência de valores <see cref="T:System.Int32" /> obtidos pela invocação de uma função de transformação em cada elemento da sequência de entrada.</summary>
        <returns>A média da sequência de valores.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Na sintaxe de expressão de consulta do Visual Basic, uma `Aggregate Into Average()` cláusula se traduz em uma invocação de <xref:System.Linq.Enumerable.Average%2A>.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como usar <xref:System.Linq.Enumerable.Average%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Int32%7D%29> para calcular uma média.  
  
 [!code-csharp[System.Linq.Enumerable#18](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#18)]
 [!code-vb[System.Linq.Enumerable#18](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#18)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> ou <paramref name="selector" /> é <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="source" /> não contém elementos.</exception>
        <exception cref="T:System.OverflowException">A soma dos elementos na sequência é maior do que <see cref="F:System.Int64.MaxValue" />.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/1315a814-5db6-4077-b34b-b141e11cc0eb">Cláusula Aggregate (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Average&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static double Average&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,long&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Average&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, int64&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Average``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Int64})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Average(Of TSource) (source As IEnumerable(Of TSource), selector As Func(Of TSource, Long)) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static double Average(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Func&lt;TSource, long&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="static member Average : seq&lt;'Source&gt; * Func&lt;'Source, int64&gt; -&gt; double" Usage="System.Linq.Enumerable.Average (source, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Int64&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">O tipo dos elementos da fonte.</typeparam>
        <param name="source">Uma sequência de valores para cálculo da média.</param>
        <param name="selector">Uma função de transformação a ser aplicada a cada elemento.</param>
        <summary>Calcula a média de uma sequência de valores <see cref="T:System.Int64" /> obtidos pela invocação de uma função de transformação em cada elemento da sequência de entrada.</summary>
        <returns>A média da sequência de valores.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Na sintaxe de expressão de consulta do Visual Basic, uma `Aggregate Into Average()` cláusula se traduz em uma invocação de <xref:System.Linq.Enumerable.Average%2A>.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como usar <xref:System.Linq.Enumerable.Average%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Int64%7D%29> para calcular uma média.  
  
 [!code-csharp[System.Linq.Enumerable#16](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#16)]
 [!code-vb[System.Linq.Enumerable#16](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#16)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> ou <paramref name="selector" /> é <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="source" /> não contém elementos.</exception>
        <exception cref="T:System.OverflowException">A soma dos elementos na sequência é maior do que <see cref="F:System.Int64.MaxValue" />.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/1315a814-5db6-4077-b34b-b141e11cc0eb">Cláusula Aggregate (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Average&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static Nullable&lt;decimal&gt; Average&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,Nullable&lt;decimal&gt;&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;valuetype System.Decimal&gt; Average&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, valuetype System.Nullable`1&lt;valuetype System.Decimal&gt;&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Average``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Nullable{System.Decimal}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Average(Of TSource) (source As IEnumerable(Of TSource), selector As Func(Of TSource, Nullable(Of Decimal))) As Nullable(Of Decimal)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Nullable&lt;System::Decimal&gt; Average(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Func&lt;TSource, Nullable&lt;System::Decimal&gt;&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="static member Average : seq&lt;'Source&gt; * Func&lt;'Source, Nullable&lt;decimal&gt;&gt; -&gt; Nullable&lt;decimal&gt;" Usage="System.Linq.Enumerable.Average (source, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Decimal&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Nullable&lt;System.Decimal&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">O tipo dos elementos de <paramref name="source" />.</typeparam>
        <param name="source">Uma sequência de valores para cálculo da média.</param>
        <param name="selector">Uma função de transformação a ser aplicada a cada elemento.</param>
        <summary>Calcula a média de uma sequência de valores <see cref="T:System.Decimal" /> que permitem valor nulo obtidos pela invocação de uma função de transformação em cada elemento da sequência de entrada.</summary>
        <returns>A média da sequência de valores ou <see langword="null" />, se a sequência de origem estiver vazia ou contiver somente valores que são <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Na sintaxe de expressão de consulta do Visual Basic, uma `Aggregate Into Average()` cláusula se traduz em uma invocação de <xref:System.Linq.Enumerable.Average%2A>.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como usar <xref:System.Linq.Enumerable.Average%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Int64%7D%29> para calcular uma média.  
  
 [!INCLUDE[sqo_diff_overload_example_func](~/includes/sqo-diff-overload-example-func-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#16](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#16)]
 [!code-vb[System.Linq.Enumerable#16](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#16)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> ou <paramref name="selector" /> é <see langword="null" />.</exception>
        <exception cref="T:System.OverflowException">A soma dos elementos na sequência é maior do que <see cref="F:System.Decimal.MaxValue" />.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/1315a814-5db6-4077-b34b-b141e11cc0eb">Cláusula Aggregate (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Average&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static Nullable&lt;double&gt; Average&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,Nullable&lt;double&gt;&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;float64&gt; Average&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, valuetype System.Nullable`1&lt;float64&gt;&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Average``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Nullable{System.Double}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Average(Of TSource) (source As IEnumerable(Of TSource), selector As Func(Of TSource, Nullable(Of Double))) As Nullable(Of Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Nullable&lt;double&gt; Average(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Func&lt;TSource, Nullable&lt;double&gt;&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="static member Average : seq&lt;'Source&gt; * Func&lt;'Source, Nullable&lt;double&gt;&gt; -&gt; Nullable&lt;double&gt;" Usage="System.Linq.Enumerable.Average (source, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Double&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Nullable&lt;System.Double&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">O tipo dos elementos de <paramref name="source" />.</typeparam>
        <param name="source">Uma sequência de valores para cálculo da média.</param>
        <param name="selector">Uma função de transformação a ser aplicada a cada elemento.</param>
        <summary>Calcula a média de uma sequência de valores <see cref="T:System.Double" /> que permitem valor nulo obtidos pela invocação de uma função de transformação em cada elemento da sequência de entrada.</summary>
        <returns>A média da sequência de valores ou <see langword="null" />, se a sequência de origem estiver vazia ou contiver somente valores que são <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Na sintaxe de expressão de consulta do Visual Basic, uma `Aggregate Into Average()` cláusula se traduz em uma invocação de <xref:System.Linq.Enumerable.Average%2A>.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como usar <xref:System.Linq.Enumerable.Average%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Int64%7D%29> para calcular uma média.  
  
 [!INCLUDE[sqo_diff_overload_example_func](~/includes/sqo-diff-overload-example-func-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#16](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#16)]
 [!code-vb[System.Linq.Enumerable#16](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#16)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> ou <paramref name="selector" /> é <see langword="null" />.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/1315a814-5db6-4077-b34b-b141e11cc0eb">Cláusula Aggregate (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Average&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static Nullable&lt;double&gt; Average&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,Nullable&lt;int&gt;&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;float64&gt; Average&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, valuetype System.Nullable`1&lt;int32&gt;&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Average``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Nullable{System.Int32}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Average(Of TSource) (source As IEnumerable(Of TSource), selector As Func(Of TSource, Nullable(Of Integer))) As Nullable(Of Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Nullable&lt;double&gt; Average(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Func&lt;TSource, Nullable&lt;int&gt;&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="static member Average : seq&lt;'Source&gt; * Func&lt;'Source, Nullable&lt;int&gt;&gt; -&gt; Nullable&lt;double&gt;" Usage="System.Linq.Enumerable.Average (source, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Double&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Nullable&lt;System.Int32&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">O tipo dos elementos de <paramref name="source" />.</typeparam>
        <param name="source">Uma sequência de valores para cálculo da média.</param>
        <param name="selector">Uma função de transformação a ser aplicada a cada elemento.</param>
        <summary>Calcula a média de uma sequência de valores <see cref="T:System.Int32" /> que permitem valor nulo obtidos pela invocação de uma função de transformação em cada elemento da sequência de entrada.</summary>
        <returns>A média da sequência de valores ou <see langword="null" />, se a sequência de origem estiver vazia ou contiver somente valores que são <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Na sintaxe de expressão de consulta do Visual Basic, uma `Aggregate Into Average()` cláusula se traduz em uma invocação de <xref:System.Linq.Enumerable.Average%2A>.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como usar <xref:System.Linq.Enumerable.Average%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Int32%7D%29> para calcular uma média.  
  
 [!INCLUDE[sqo_diff_overload_example_func](~/includes/sqo-diff-overload-example-func-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#18](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#18)]
 [!code-vb[System.Linq.Enumerable#18](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#18)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> ou <paramref name="selector" /> é <see langword="null" />.</exception>
        <exception cref="T:System.OverflowException">A soma dos elementos na sequência é maior do que <see cref="F:System.Int64.MaxValue" />.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/1315a814-5db6-4077-b34b-b141e11cc0eb">Cláusula Aggregate (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Average&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static Nullable&lt;double&gt; Average&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,Nullable&lt;long&gt;&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;float64&gt; Average&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, valuetype System.Nullable`1&lt;int64&gt;&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Average``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Nullable{System.Int64}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Average(Of TSource) (source As IEnumerable(Of TSource), selector As Func(Of TSource, Nullable(Of Long))) As Nullable(Of Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Nullable&lt;double&gt; Average(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Func&lt;TSource, Nullable&lt;long&gt;&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="static member Average : seq&lt;'Source&gt; * Func&lt;'Source, Nullable&lt;int64&gt;&gt; -&gt; Nullable&lt;double&gt;" Usage="System.Linq.Enumerable.Average (source, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Double&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Nullable&lt;System.Int64&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">O tipo dos elementos de <paramref name="source" />.</typeparam>
        <param name="source">Uma sequência de valores para cálculo da média.</param>
        <param name="selector">Uma função de transformação a ser aplicada a cada elemento.</param>
        <summary>Calcula a média de uma sequência de valores <see cref="T:System.Int64" /> que permitem valor nulo obtidos pela invocação de uma função de transformação em cada elemento da sequência de entrada.</summary>
        <returns>A média da sequência de valores ou <see langword="null" />, se a sequência de origem estiver vazia ou contiver somente valores que são <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Na sintaxe de expressão de consulta do Visual Basic, uma `Aggregate Into Average()` cláusula se traduz em uma invocação de <xref:System.Linq.Enumerable.Average%2A>.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como usar <xref:System.Linq.Enumerable.Average%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Int64%7D%29> para calcular uma média.  
  
 [!INCLUDE[sqo_diff_overload_example_func](~/includes/sqo-diff-overload-example-func-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#16](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#16)]
 [!code-vb[System.Linq.Enumerable#16](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#16)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/1315a814-5db6-4077-b34b-b141e11cc0eb">Cláusula Aggregate (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Average&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static Nullable&lt;float&gt; Average&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,Nullable&lt;float&gt;&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;float32&gt; Average&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, valuetype System.Nullable`1&lt;float32&gt;&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Average``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Nullable{System.Single}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Average(Of TSource) (source As IEnumerable(Of TSource), selector As Func(Of TSource, Nullable(Of Single))) As Nullable(Of Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Nullable&lt;float&gt; Average(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Func&lt;TSource, Nullable&lt;float&gt;&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="static member Average : seq&lt;'Source&gt; * Func&lt;'Source, Nullable&lt;single&gt;&gt; -&gt; Nullable&lt;single&gt;" Usage="System.Linq.Enumerable.Average (source, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Single&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Nullable&lt;System.Single&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">O tipo dos elementos de <paramref name="source" />.</typeparam>
        <param name="source">Uma sequência de valores para cálculo da média.</param>
        <param name="selector">Uma função de transformação a ser aplicada a cada elemento.</param>
        <summary>Calcula a média de uma sequência de valores <see cref="T:System.Single" /> que permitem valor nulo obtidos pela invocação de uma função de transformação em cada elemento da sequência de entrada.</summary>
        <returns>A média da sequência de valores ou <see langword="null" />, se a sequência de origem estiver vazia ou contiver somente valores que são <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Na sintaxe de expressão de consulta do Visual Basic, uma `Aggregate Into Average()` cláusula se traduz em uma invocação de <xref:System.Linq.Enumerable.Average%2A>.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como usar <xref:System.Linq.Enumerable.Average%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Int32%7D%29> para calcular uma média.  
  
 [!INCLUDE[sqo_diff_overload_example_func](~/includes/sqo-diff-overload-example-func-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#18](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#18)]
 [!code-vb[System.Linq.Enumerable#18](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#18)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> ou <paramref name="selector" /> é <see langword="null" />.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/1315a814-5db6-4077-b34b-b141e11cc0eb">Cláusula Aggregate (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Average&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static float Average&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,float&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 Average&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, float32&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Average``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Single})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Average(Of TSource) (source As IEnumerable(Of TSource), selector As Func(Of TSource, Single)) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static float Average(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Func&lt;TSource, float&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="static member Average : seq&lt;'Source&gt; * Func&lt;'Source, single&gt; -&gt; single" Usage="System.Linq.Enumerable.Average (source, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Single&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">O tipo dos elementos de <paramref name="source" />.</typeparam>
        <param name="source">Uma sequência de valores para cálculo da média.</param>
        <param name="selector">Uma função de transformação a ser aplicada a cada elemento.</param>
        <summary>Calcula a média de uma sequência de valores <see cref="T:System.Single" /> obtidos pela invocação de uma função de transformação em cada elemento da sequência de entrada.</summary>
        <returns>A média da sequência de valores.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Na sintaxe de expressão de consulta do Visual Basic, uma `Aggregate Into Average()` cláusula se traduz em uma invocação de <xref:System.Linq.Enumerable.Average%2A>.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como usar <xref:System.Linq.Enumerable.Average%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Int32%7D%29> para calcular uma média.  
  
 [!INCLUDE[sqo_diff_overload_example_func](~/includes/sqo-diff-overload-example-func-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#18](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#18)]
 [!code-vb[System.Linq.Enumerable#18](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#18)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> ou <paramref name="selector" /> é <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="source" /> não contém elementos.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/1315a814-5db6-4077-b34b-b141e11cc0eb">Cláusula Aggregate (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Cast&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;TResult&gt; Cast&lt;TResult&gt; (this System.Collections.IEnumerable source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;!!TResult&gt; Cast&lt;TResult&gt;(class System.Collections.IEnumerable source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Cast``1(System.Collections.IEnumerable)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Cast(Of TResult) (source As IEnumerable) As IEnumerable(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Collections::Generic::IEnumerable&lt;TResult&gt; ^ Cast(System::Collections::IEnumerable ^ source);" />
      <MemberSignature Language="F#" Value="static member Cast : System.Collections.IEnumerable -&gt; seq&lt;'Result&gt;" Usage="System.Linq.Enumerable.Cast source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.IEnumerable" RefType="this" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">O tipo no qual os elementos de <paramref name="source" /> deverão ser convertidos.</typeparam>
        <param name="source">O <see cref="T:System.Collections.IEnumerable" /> que contém os elementos a serem convertidos no tipo <paramref name="TResult" />.</param>
        <summary>Converte os elementos de um <see cref="T:System.Collections.IEnumerable" /> para o tipo especificado.</summary>
        <returns>Um <see cref="T:System.Collections.Generic.IEnumerable`1" /> que contém cada elemento da sequência de origem convertido para o tipo especificado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método é implementado usando a execução adiada. O imediata valor retornado é um objeto que armazena todas as informações necessárias para executar a ação. A consulta representada por esse método não é executada até que o objeto é enumerado chamando-se suas `GetEnumerator` método diretamente ou usando `foreach` no Visual c# ou `For Each` no Visual Basic.  
  
 O <xref:System.Linq.Enumerable.Cast%60%601%28System.Collections.IEnumerable%29> método permite que os operadores de consulta padrão a ser invocada em coleções não genéricas, fornecendo as informações de tipo necessários. Por exemplo, <xref:System.Collections.ArrayList> não implementa <xref:System.Collections.Generic.IEnumerable%601>, mas chamando <xref:System.Linq.Enumerable.Cast%60%601%28System.Collections.IEnumerable%29> sobre o <xref:System.Collections.ArrayList> do objeto, os operadores de consulta padrão, em seguida, podem ser usados para consultar a sequência.  
  
 Se um elemento não pode ser convertido no tipo `TResult`, esse método lança um <xref:System.InvalidCastException>.

 A sequência de origem para este método é <xref:System.Collections.IEnumerable>, que significa que os elementos têm o tipo estático do tempo de compilação da `object`. Apenas conversões de tipo que são executadas por esse método são conversões de referência e conversões unboxing. O tipo de tempo de execução dos elementos na coleção deve corresponder ao tipo de destino ou, no caso de tipos de valor, o tipo de tempo de execução dos elementos deve ser o resultado de uma conversão boxing do tipo de destino. Outros tipos de conversão, como aqueles entre diferentes tipos numéricos, não são permitidos. 
 
 Para obter apenas os elementos que podem ser convertidos para o tipo `TResult`, use o <xref:System.Linq.Enumerable.OfType%2A> método em vez de <xref:System.Linq.Enumerable.Cast%60%601%28System.Collections.IEnumerable%29>.  
  
 Em uma expressão de consulta, uma variável de iteração digitadas explicitamente se traduz em uma invocação de <xref:System.Linq.Enumerable.Cast%60%601%28System.Collections.IEnumerable%29>. Este exemplo mostra a sintaxe para uma variável de intervalo de tipo explícito.  
  
```csharp  
from int i in objects  
```  
  
```vb  
From i As Integer In objects  
```  

Use o `select` cláusula de uma consulta para executar outros tipos de conversão, como as conversões numéricas implícitas. O exemplo a seguir usa o `Cast` método e um `select` instrução para converter uma sequência de inteiros demarcados em uma sequência de duplicatas.

```csharp
IEnumerable sequence = Enumerable.Range(0, 10);
var doubles = from int item in sequence
                select (double)item;
``` 

```vb
Dim sequence As IEnumerable = Enumerable.Range(0, 10)
Dim doubles = From item As Integer In sequence
                Select CType(item, Double)
```

## Examples  
 O exemplo de código a seguir demonstra como usar <xref:System.Linq.Enumerable.Cast%60%601%28System.Collections.IEnumerable%29> para habilitar o uso de operadores de consulta padrão em um <xref:System.Collections.ArrayList>.  
  
 [!code-csharp[System.Linq.Enumerable#19](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#19)]
 [!code-vb[System.Linq.Enumerable#19](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#19)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> é <see langword="null" />.</exception>
        <exception cref="T:System.InvalidCastException">Um elemento na sequência não pode ser convertido para o tipo <paramref name="TResult" />.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/1aefd18c-1314-47f8-99ec-9bcefb09e699">Cláusula from (Referência de C#)</related>
        <related type="Article" href="https://msdn.microsoft.com/library/83e3665e-68a0-4540-a3a3-3d777a0f95d5">Cláusula From (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Concat&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;TSource&gt; Concat&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; first, System.Collections.Generic.IEnumerable&lt;TSource&gt; second);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; Concat&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; first, class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; second) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Concat``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Concat(Of TSource) (first As IEnumerable(Of TSource), second As IEnumerable(Of TSource)) As IEnumerable(Of TSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ Concat(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ first, System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ second);" />
      <MemberSignature Language="F#" Value="static member Concat : seq&lt;'Source&gt; * seq&lt;'Source&gt; -&gt; seq&lt;'Source&gt;" Usage="System.Linq.Enumerable.Concat (first, second)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="first" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="second" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">O tipo dos elementos das sequências de entrada.</typeparam>
        <param name="first">A primeira sequência a ser concatenada.</param>
        <param name="second">A sequência a ser concatenada com a primeira sequência.</param>
        <summary>Concatena duas sequências.</summary>
        <returns>Um <see cref="T:System.Collections.Generic.IEnumerable`1" /> que contém os elementos concatenados das duas sequências de entrada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método é implementado usando a execução adiada. O imediata valor retornado é um objeto que armazena todas as informações necessárias para executar a ação. A consulta representada por esse método não é executada até que o objeto é enumerado chamando-se suas `GetEnumerator` método diretamente ou usando `foreach` no Visual c# ou `For Each` no Visual Basic.  
  
 O <xref:System.Linq.Enumerable.Concat%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%29> difere do método de <xref:System.Linq.Enumerable.Union%2A> método porque o <xref:System.Linq.Enumerable.Concat%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%29> método retorna todos os elementos originais nas sequências de entrada. O <xref:System.Linq.Enumerable.Union%2A> método retorna apenas os elementos exclusivos.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como usar <xref:System.Linq.Enumerable.Concat%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%29> para concatenar duas sequências.  
  
 [!code-csharp[System.Linq.Enumerable#20](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#20)]
 [!code-vb[System.Linq.Enumerable#20](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#20)]  
  
 Uma maneira alternativa de concatenar duas sequências é construir uma coleção, por exemplo uma matriz de sequências e, em seguida, aplicar o <xref:System.Linq.Enumerable.SelectMany%2A> método, passando a ele a função de seletor de identidade. O exemplo a seguir demonstra o uso de <xref:System.Linq.Enumerable.SelectMany%2A>.  
  
 [!code-csharp[System.Linq.Enumerable#112](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#112)]
 [!code-vb[System.Linq.Enumerable#112](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#112)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="first" /> ou <paramref name="second" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Contains&lt;TSource&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Determina se uma sequência contém um elemento especificado.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Contains&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static bool Contains&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, TSource value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Contains&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, !!TSource value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Contains``1(System.Collections.Generic.IEnumerable{``0},``0)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Contains(Of TSource) (source As IEnumerable(Of TSource), value As TSource) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static bool Contains(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, TSource value);" />
      <MemberSignature Language="F#" Value="static member Contains : seq&lt;'Source&gt; * 'Source -&gt; bool" Usage="System.Linq.Enumerable.Contains (source, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="value" Type="TSource" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">O tipo dos elementos de <paramref name="source" />.</typeparam>
        <param name="source">Uma sequência na qual um valor será localizado.</param>
        <param name="value">O valor a ser localizado na sequência.</param>
        <summary>Determina se uma sequência contém um elemento especificado usando o comparador de igualdade padrão.</summary>
        <returns><see langword="true" /> se a sequência de origem contiver um elemento que tem o valor especificado; caso contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se o tipo de `source` implementa <xref:System.Collections.Generic.ICollection%601>, o `Contains` método em que a implementação é chamado para obter o resultado. Caso contrário, este método determina se `source` contém o elemento especificado.  
  
 Enumeração será encerrada assim que um elemento correspondente for encontrado.  
  
 Elementos são comparados com o valor especificado usando o comparador de igualdade padrão, <xref:System.Collections.Generic.EqualityComparer%601.Default%2A>.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como usar <xref:System.Linq.Enumerable.Contains%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2C%60%600%29> para determinar se uma matriz contém um elemento específico.  
  
 [!code-csharp[System.Linq.Enumerable#21](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#21)]
 [!code-vb[System.Linq.Enumerable#21](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#21)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Contains&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static bool Contains&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, TSource value, System.Collections.Generic.IEqualityComparer&lt;TSource&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Contains&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, !!TSource value, class System.Collections.Generic.IEqualityComparer`1&lt;!!TSource&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Contains``1(System.Collections.Generic.IEnumerable{``0},``0,System.Collections.Generic.IEqualityComparer{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Contains(Of TSource) (source As IEnumerable(Of TSource), value As TSource, comparer As IEqualityComparer(Of TSource)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static bool Contains(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, TSource value, System::Collections::Generic::IEqualityComparer&lt;TSource&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="static member Contains : seq&lt;'Source&gt; * 'Source * System.Collections.Generic.IEqualityComparer&lt;'Source&gt; -&gt; bool" Usage="System.Linq.Enumerable.Contains (source, value, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="value" Type="TSource" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IEqualityComparer&lt;TSource&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">O tipo dos elementos de <paramref name="source" />.</typeparam>
        <param name="source">Uma sequência na qual um valor será localizado.</param>
        <param name="value">O valor a ser localizado na sequência.</param>
        <param name="comparer">Um comparador de igualdade para comparar valores.</param>
        <summary>Determina se uma sequência contém um elemento especificado usando um <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> especificado.</summary>
        <returns><see langword="true" /> se a sequência de origem contiver um elemento que tem o valor especificado; caso contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Enumeração será encerrada assim que um elemento correspondente for encontrado.  
  
 Se `comparer` está `null`, o comparador de igualdade padrão, <xref:System.Collections.Generic.EqualityComparer%601.Default%2A>, é usado para comparar elementos para o valor especificado.  
  
   
  
## Examples  
 O exemplo a seguir mostra como implementar um comparador de igualdade que pode ser usado no <xref:System.Linq.Enumerable.Contains%2A> método.  
  
 [!code-csharp[CSLINQCustomComparer#1](~/samples/snippets/csharp/VS_Snippets_VBCSharp/CsLINQCustomComparer/CS/CustomComparer.cs#1)]
 [!code-vb[CSLINQCustomComparer#1](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/CsLINQCustomComparer/VB/CustomComparer.vb#1)]  
  
 Depois de implementar esse comparador, você pode usar uma sequência de `Product` objetos no <xref:System.Linq.Enumerable.Contains%2A> método, conforme mostrado no exemplo a seguir.  
  
 [!code-csharp[CSLINQCustomComparer#6](~/samples/snippets/csharp/VS_Snippets_VBCSharp/CsLINQCustomComparer/CS/CustomComparer.cs#6)]
 [!code-vb[CSLINQCustomComparer#6](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/CsLINQCustomComparer/VB/CustomComparer.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Count&lt;TSource&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Retorna o número de elementos em uma sequência.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Count&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static int Count&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Count&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Count``1(System.Collections.Generic.IEnumerable{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Count(Of TSource) (source As IEnumerable(Of TSource)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static int Count(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Count : seq&lt;'Source&gt; -&gt; int" Usage="System.Linq.Enumerable.Count source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">O tipo dos elementos de <paramref name="source" />.</typeparam>
        <param name="source">Uma sequência que contém os elementos a serem contados.</param>
        <summary>Retorna o número de elementos em uma sequência.</summary>
        <returns>O número de elementos na sequência de entrada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se o tipo de `source` implementa <xref:System.Collections.Generic.ICollection%601>, que a implementação é usada para obter a contagem de elementos. Caso contrário, este método determina a contagem.  
  
 Use o <xref:System.Linq.Enumerable.LongCount%2A> método quando você esperar e deseja permitir que o resultado seja maior do que <xref:System.Int32.MaxValue>.  
  
 Na sintaxe de expressão de consulta do Visual Basic, uma `Aggregate Into Count()` cláusula se traduz em uma invocação de <xref:System.Linq.Enumerable.Count%2A>.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como usar <xref:System.Linq.Enumerable.Count%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%29> para contar os elementos em uma matriz.  
  
 [!code-csharp[System.Linq.Enumerable#22](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#22)]
 [!code-vb[System.Linq.Enumerable#22](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#22)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> é <see langword="null" />.</exception>
        <exception cref="T:System.OverflowException">O número de elementos no <paramref name="source" /> é maior que <see cref="F:System.Int32.MaxValue" />.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/1315a814-5db6-4077-b34b-b141e11cc0eb">Cláusula Aggregate (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Count&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static int Count&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,bool&gt; predicate);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Count&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, bool&gt; predicate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Count``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Boolean})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Count(Of TSource) (source As IEnumerable(Of TSource), predicate As Func(Of TSource, Boolean)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static int Count(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Func&lt;TSource, bool&gt; ^ predicate);" />
      <MemberSignature Language="F#" Value="static member Count : seq&lt;'Source&gt; * Func&lt;'Source, bool&gt; -&gt; int" Usage="System.Linq.Enumerable.Count (source, predicate)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="predicate" Type="System.Func&lt;TSource,System.Boolean&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">O tipo dos elementos de <paramref name="source" />.</typeparam>
        <param name="source">Uma sequência que contém os elementos a serem testados e contados.</param>
        <param name="predicate">Uma função para testar cada elemento em relação a uma condição.</param>
        <summary>Retorna um número que representa quantos elementos na sequência especificada atendem a uma condição.</summary>
        <returns>Um número que representa quantos elementos na sequência atendem à condição na função de predicado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se o tipo de `source` implementa <xref:System.Collections.Generic.ICollection%601>, que a implementação é usada para obter a contagem de elementos. Caso contrário, este método determina a contagem.  
  
 Você deve usar o <xref:System.Linq.Enumerable.LongCount%2A> método quando você esperar e deseja permitir que o resultado seja maior do que <xref:System.Int32.MaxValue>.  
  
 Na sintaxe de expressão de consulta do Visual Basic, uma `Aggregate Into Count()` cláusula se traduz em uma invocação de <xref:System.Linq.Enumerable.Count%2A>.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como usar <xref:System.Linq.Enumerable.Count%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Boolean%7D%29> para contar os elementos em uma matriz que satisfazem uma condição.  
  
 [!code-csharp[System.Linq.Enumerable#23](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#23)]
 [!code-vb[System.Linq.Enumerable#23](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#23)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> ou <paramref name="predicate" /> é <see langword="null" />.</exception>
        <exception cref="T:System.OverflowException">O número de elementos no <paramref name="source" /> é maior que <see cref="F:System.Int32.MaxValue" />.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/1315a814-5db6-4077-b34b-b141e11cc0eb">Cláusula Aggregate (Visual Basic)</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="DefaultIfEmpty&lt;TSource&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Retornará os elementos em um <see cref="T:System.Collections.Generic.IEnumerable`1" /> ou uma coleção de singletons com valor padrão se a sequência estiver vazia.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="DefaultIfEmpty&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;TSource&gt; DefaultIfEmpty&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; DefaultIfEmpty&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.DefaultIfEmpty``1(System.Collections.Generic.IEnumerable{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function DefaultIfEmpty(Of TSource) (source As IEnumerable(Of TSource)) As IEnumerable(Of TSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ DefaultIfEmpty(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member DefaultIfEmpty : seq&lt;'Source&gt; -&gt; seq&lt;'Source&gt;" Usage="System.Linq.Enumerable.DefaultIfEmpty source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">O tipo dos elementos de <paramref name="source" />.</typeparam>
        <param name="source">A sequência para a qual será retornado um valor padrão se ela estiver vazia.</param>
        <summary>Retornará os elementos da sequência especificada ou o valor padrão do parâmetro de tipo em uma coleção de singletons se a sequência estiver vazia.</summary>
        <returns>Um objeto <see cref="T:System.Collections.Generic.IEnumerable`1" /> que contém o valor padrão do tipo <paramref name="TSource" /> se <paramref name="source" /> estiver vazio; caso contrário, <paramref name="source" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método é implementado usando a execução adiada. O imediata valor retornado é um objeto que armazena todas as informações necessárias para executar a ação. A consulta representada por esse método não é executada até que o objeto é enumerado chamando-se suas `GetEnumerator` método diretamente ou usando `foreach` no Visual c# ou `For Each` no Visual Basic.  
  
 O valor padrão para referência e tipos que permitem valor nulos é `null`.  
  
 Esse método pode ser usado para produzir uma junção externa esquerda quando ele é combinado com o <xref:System.Linq.Enumerable.GroupJoin%2A>) método.  
  
   
  
## Examples  
 Os exemplos de código a seguir demonstram como usar <xref:System.Linq.Enumerable.DefaultIfEmpty%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%29> para fornecer um valor padrão caso a sequência de origem está vazia.  
  
 Este exemplo usa uma sequência não vazia.  
  
 [!code-csharp[System.Linq.Enumerable#24](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#24)]
 [!code-vb[System.Linq.Enumerable#24](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#24)]  
  
 Este exemplo usa uma sequência vazia.  
  
 [!code-csharp[System.Linq.Enumerable#25](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#25)]
 [!code-vb[System.Linq.Enumerable#25](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#25)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> é <see langword="null" />.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/442d176d-028c-4beb-8d22-407d4ef89107">Ingressando</related>
      </Docs>
    </Member>
    <Member MemberName="DefaultIfEmpty&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;TSource&gt; DefaultIfEmpty&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, TSource defaultValue);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; DefaultIfEmpty&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, !!TSource defaultValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.DefaultIfEmpty``1(System.Collections.Generic.IEnumerable{``0},``0)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function DefaultIfEmpty(Of TSource) (source As IEnumerable(Of TSource), defaultValue As TSource) As IEnumerable(Of TSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ DefaultIfEmpty(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, TSource defaultValue);" />
      <MemberSignature Language="F#" Value="static member DefaultIfEmpty : seq&lt;'Source&gt; * 'Source -&gt; seq&lt;'Source&gt;" Usage="System.Linq.Enumerable.DefaultIfEmpty (source, defaultValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="defaultValue" Type="TSource" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">O tipo dos elementos de <paramref name="source" />.</typeparam>
        <param name="source">A sequência para a qual será retornado o valor especificado se ela estiver vazia.</param>
        <param name="defaultValue">O valor a ser retornado se a sequência estiver vazia.</param>
        <summary>Retorna os elementos da sequência especificada ou o valor especificado em uma coleção de singletons se a sequência está vazia.</summary>
        <returns>Um <see cref="T:System.Collections.Generic.IEnumerable`1" /> que contém <paramref name="defaultValue" /> se <paramref name="source" /> está vazio; caso contrário, <paramref name="source" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método é implementado usando a execução adiada. O imediata valor retornado é um objeto que armazena todas as informações necessárias para executar a ação. A consulta representada por esse método não é executada até que o objeto é enumerado chamando-se suas `GetEnumerator` método diretamente ou usando `foreach` no Visual c# ou `For Each` no Visual Basic.  
  
 Esse método pode ser usado para produzir uma junção externa esquerda quando ele é combinado com o <xref:System.Linq.Enumerable.GroupJoin%2A>) método.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como usar o <xref:System.Linq.Enumerable.DefaultIfEmpty%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2C%60%600%29> método e especificar um valor padrão. A primeira sequência não está vazia e a segunda sequência está vazia.  
  
 [!code-csharp[System.Linq.Enumerable#26](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#26)]
 [!code-vb[System.Linq.Enumerable#26](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#26)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/442d176d-028c-4beb-8d22-407d4ef89107">Ingressando</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Distinct&lt;TSource&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Retorna elementos diferentes de uma sequência.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A sequência de resultado é desordenada.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Distinct&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;TSource&gt; Distinct&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; Distinct&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Distinct``1(System.Collections.Generic.IEnumerable{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Distinct(Of TSource) (source As IEnumerable(Of TSource)) As IEnumerable(Of TSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ Distinct(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Distinct : seq&lt;'Source&gt; -&gt; seq&lt;'Source&gt;" Usage="System.Linq.Enumerable.Distinct source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">O tipo dos elementos de <paramref name="source" />.</typeparam>
        <param name="source">A sequência da qual os elementos duplicados serão removidos.</param>
        <summary>Retorna os elementos distintos de uma sequência usando o comparador de igualdade padrão para comparar valores.</summary>
        <returns>Um <see cref="T:System.Collections.Generic.IEnumerable`1" /> que contém elementos distintos da sequência de origem.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método é implementado usando a execução adiada. O imediata valor retornado é um objeto que armazena todas as informações necessárias para executar a ação. A consulta representada por esse método não é executada até que o objeto é enumerado chamando-se suas `GetEnumerator` método diretamente ou usando `foreach` no Visual c# ou `For Each` no Visual Basic.  
  
 O <xref:System.Linq.Enumerable.Distinct%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%29> método retorna uma sequência não ordenada que não contenha valores duplicados. Ele usa o comparador de igualdade padrão, <xref:System.Collections.Generic.EqualityComparer%601.Default%2A>, para comparar valores.  
  
 Na sintaxe de expressão de consulta do Visual Basic, uma `Distinct` cláusula se traduz em uma invocação de <xref:System.Linq.Enumerable.Distinct%2A>.  
  
 O comparador de igualdade padrão, <xref:System.Collections.Generic.EqualityComparer%601.Default%2A>, é usado para comparar valores de tipos que implementam o <xref:System.IEquatable%601> interface genérica. Para comparar um tipo de dados personalizado, você precisa implementar esta interface e fornecer seus próprios <xref:System.Object.GetHashCode%2A> e <xref:System.Object.Equals%2A> métodos para o tipo.  
  
 Para obter um exemplo que usa <xref:System.Collections.Generic.IEqualityComparer%601> para definir um comparador personalizado, consulte <xref:System.Linq.Enumerable.Distinct%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Collections.Generic.IEqualityComparer%7B%60%600%7D%29>.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como usar <xref:System.Linq.Enumerable.Distinct%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%29> retornar elementos distintos de uma sequência de inteiros.  
  
 [!code-csharp[System.Linq.Enumerable#27](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#27)]
 [!code-vb[System.Linq.Enumerable#27](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#27)]  
  
 Se você quiser retornar elementos distintos de sequências de objetos de algum tipo de dados personalizado, você precisa implementar o <xref:System.IEquatable%601> interface genérica na classe. O exemplo de código a seguir mostra como implementar essa interface em um tipo de dados personalizadas e fornecer <xref:System.Object.GetHashCode%2A> e <xref:System.Object.Equals%2A> métodos.  
  
 [!code-csharp[CSLINQEncapsulatedComparer#1](~/samples/snippets/csharp/VS_Snippets_VBCSharp/CsLINQEncapsulatedComparer/CS/EncapsulatedComparer.cs#1)]
 [!code-vb[CSLINQEncapsulatedComparer#1](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/CsLINQEncapsulatedComparer/VB/EncapsulatedComparer.vb#1)]  
  
 Depois de implementar essa interface, você pode usar uma sequência de `Product` objetos no <xref:System.Linq.Enumerable.Distinct%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%29> método, conforme mostrado no exemplo a seguir.  
  
 [!code-csharp[CSLINQEncapsulatedComparer#5](~/samples/snippets/csharp/VS_Snippets_VBCSharp/CsLINQEncapsulatedComparer/CS/EncapsulatedComparer.cs#5)]
 [!code-vb[CSLINQEncapsulatedComparer#5](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/CsLINQEncapsulatedComparer/VB/EncapsulatedComparer.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> é <see langword="null" />.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/86f42614-0d8f-4ffc-b888-ce8a37a8d36a">Cláusula Distinct (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Distinct&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;TSource&gt; Distinct&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, System.Collections.Generic.IEqualityComparer&lt;TSource&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; Distinct&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Collections.Generic.IEqualityComparer`1&lt;!!TSource&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Distinct``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEqualityComparer{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Distinct(Of TSource) (source As IEnumerable(Of TSource), comparer As IEqualityComparer(Of TSource)) As IEnumerable(Of TSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ Distinct(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, System::Collections::Generic::IEqualityComparer&lt;TSource&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="static member Distinct : seq&lt;'Source&gt; * System.Collections.Generic.IEqualityComparer&lt;'Source&gt; -&gt; seq&lt;'Source&gt;" Usage="System.Linq.Enumerable.Distinct (source, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IEqualityComparer&lt;TSource&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">O tipo dos elementos de <paramref name="source" />.</typeparam>
        <param name="source">A sequência da qual os elementos duplicados serão removidos.</param>
        <param name="comparer">Um <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> para comparar valores.</param>
        <summary>Retorna os elementos distintos de uma sequência usando um <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> especificado para comparar valores.</summary>
        <returns>Um <see cref="T:System.Collections.Generic.IEnumerable`1" /> que contém elementos distintos da sequência de origem.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método é implementado usando a execução adiada. O imediata valor retornado é um objeto que armazena todas as informações necessárias para executar a ação. A consulta representada por esse método não é executada até que o objeto é enumerado chamando-se suas `GetEnumerator` método diretamente ou usando `foreach` no Visual c# ou `For Each` no Visual Basic.  
  
 O <xref:System.Linq.Enumerable.Distinct%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Collections.Generic.IEqualityComparer%7B%60%600%7D%29> método retorna uma sequência não ordenada que não contenha valores duplicados. Se `comparer` está `null`, o comparador de igualdade padrão, <xref:System.Collections.Generic.EqualityComparer%601.Default%2A>, é usado para comparar valores.  
  
   
  
## Examples  
 O exemplo a seguir mostra como implementar um comparador de igualdade que pode ser usado no <xref:System.Linq.Enumerable.Distinct%2A> método.  
  
 [!code-csharp[CSLINQCustomComparer#1](~/samples/snippets/csharp/VS_Snippets_VBCSharp/CsLINQCustomComparer/CS/CustomComparer.cs#1)]
 [!code-vb[CSLINQCustomComparer#1](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/CsLINQCustomComparer/VB/CustomComparer.vb#1)]  
  
 Depois de implementar esse comparador, você pode usar uma sequência de `Product` objetos no <xref:System.Linq.Enumerable.Distinct%2A> método, conforme mostrado no exemplo a seguir.  
  
 [!code-csharp[CSLINQCustomComparer#5](~/samples/snippets/csharp/VS_Snippets_VBCSharp/CsLINQCustomComparer/CS/CustomComparer.cs#5)]
 [!code-vb[CSLINQCustomComparer#5](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/CsLINQCustomComparer/VB/CustomComparer.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ElementAt&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static TSource ElementAt&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, int index);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TSource ElementAt&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.ElementAt``1(System.Collections.Generic.IEnumerable{``0},System.Int32)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ElementAt(Of TSource) (source As IEnumerable(Of TSource), index As Integer) As TSource" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static TSource ElementAt(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, int index);" />
      <MemberSignature Language="F#" Value="static member ElementAt : seq&lt;'Source&gt; * int -&gt; 'Source" Usage="System.Linq.Enumerable.ElementAt (source, index)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TSource</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">O tipo dos elementos de <paramref name="source" />.</typeparam>
        <param name="source">Um <see cref="T:System.Collections.Generic.IEnumerable`1" /> do qual um elemento será retornado.</param>
        <param name="index">O índice baseado em zero do elemento a ser recuperado.</param>
        <summary>Retorna o elemento de um índice especificado em uma sequência.</summary>
        <returns>O elemento na posição especificada na sequência de origem.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se o tipo de `source` implementa <xref:System.Collections.Generic.IList%601>, que a implementação é usada para obter o elemento no índice especificado. Caso contrário, esse método obtém o elemento especificado.  
  
 Esse método gera uma exceção se `index` está fora do intervalo. Para retornar em vez disso, um valor padrão quando o índice especificado está fora do intervalo, use o <xref:System.Linq.Enumerable.ElementAtOrDefault%2A> método.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como usar <xref:System.Linq.Enumerable.ElementAt%2A> para retornar um elemento em uma posição específica.  
  
 [!code-csharp[System.Linq.Enumerable#28](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#28)]
 [!code-vb[System.Linq.Enumerable#28](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#28)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> é menor que 0 ou maior ou igual ao número de elementos em <paramref name="source" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ElementAtOrDefault&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static TSource ElementAtOrDefault&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, int index);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TSource ElementAtOrDefault&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.ElementAtOrDefault``1(System.Collections.Generic.IEnumerable{``0},System.Int32)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ElementAtOrDefault(Of TSource) (source As IEnumerable(Of TSource), index As Integer) As TSource" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static TSource ElementAtOrDefault(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, int index);" />
      <MemberSignature Language="F#" Value="static member ElementAtOrDefault : seq&lt;'Source&gt; * int -&gt; 'Source" Usage="System.Linq.Enumerable.ElementAtOrDefault (source, index)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TSource</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">O tipo dos elementos de <paramref name="source" />.</typeparam>
        <param name="source">Um <see cref="T:System.Collections.Generic.IEnumerable`1" /> do qual um elemento será retornado.</param>
        <param name="index">O índice baseado em zero do elemento a ser recuperado.</param>
        <summary>Retorna o elemento em um índice especificado em uma sequência ou um valor padrão se o índice estiver fora do intervalo.</summary>
        <returns><see langword="default" />(<paramref name="TSource" />) se o índice estiver fora dos limites da sequência de origem; caso contrário, o elemento na posição especificada na sequência de origem.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se o tipo de `source` implementa <xref:System.Collections.Generic.IList%601>, que a implementação é usada para obter o elemento no índice especificado. Caso contrário, esse método obtém o elemento especificado.  
  
 O valor padrão para referência e tipos que permitem valor nulos é `null`.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como usar <xref:System.Linq.Enumerable.ElementAtOrDefault%2A>. Este exemplo usa um índice está fora dos limites da matriz.  
  
 [!code-csharp[System.Linq.Enumerable#29](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#29)]
 [!code-vb[System.Linq.Enumerable#29](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#29)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Empty&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;TResult&gt; Empty&lt;TResult&gt; ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;!!TResult&gt; Empty&lt;TResult&gt;() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Empty``1" />
      <MemberSignature Language="VB.NET" Value="Public Function Empty(Of TResult) () As IEnumerable(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; static System::Collections::Generic::IEnumerable&lt;TResult&gt; ^ Empty();" />
      <MemberSignature Language="F#" Value="static member Empty : unit -&gt; seq&lt;'Result&gt;" Usage="System.Linq.Enumerable.Empty " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters />
      <Docs>
        <typeparam name="TResult">O tipo a ser atribuído ao parâmetro de tipo genérico <see cref="T:System.Collections.Generic.IEnumerable`1" /> retornado.</typeparam>
        <summary>Retorna um <see cref="T:System.Collections.Generic.IEnumerable`1" /> vazio que tem o argumento do tipo especificado.</summary>
        <returns>Um <see cref="T:System.Collections.Generic.IEnumerable`1" /> vazio cujo tipo de argumento é <paramref name="TResult" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Linq.Enumerable.Empty%60%601> método armazena em cache uma sequência vazia do tipo `TResult`. Quando o objeto que ela retorna é enumerado, ele gera nenhum elemento.  
  
 Em alguns casos, esse método é útil para passar uma sequência vazia para um método definido pelo usuário que usa um <xref:System.Collections.Generic.IEnumerable%601>. Ele também pode ser usado para gerar um elemento neutro para métodos como <xref:System.Linq.Enumerable.Union%2A>. Consulte a seção de exemplo para obter um exemplo de uso de <xref:System.Linq.Enumerable.Empty%60%601>.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como usar <xref:System.Linq.Enumerable.Empty%60%601> para gerar um vazio <xref:System.Collections.Generic.IEnumerable%601>.  
  
 [!code-csharp[System.Linq.Enumerable#30](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#30)]
 [!code-vb[System.Linq.Enumerable#30](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#30)]  
  
 O exemplo de código a seguir demonstra um aplicativo possíveis do <xref:System.Linq.Enumerable.Empty%60%601> método. O <xref:System.Linq.Enumerable.Aggregate%2A> método é aplicado a uma coleção de matrizes de cadeia de caracteres. Os elementos de cada matriz na coleção são adicionados ao resultante <xref:System.Collections.Generic.IEnumerable%601> somente se essa matriz contém quatro ou mais elementos. <xref:System.Linq.Enumerable.Empty%2A> é usado para gerar o valor de semente para <xref:System.Linq.Enumerable.Aggregate%2A> porque se nenhuma matriz na coleção tem quatro ou mais elementos, somente a sequência vazia é retornada.  
  
 [!code-csharp[System.Linq.Enumerable#31](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#31)]
 [!code-vb[System.Linq.Enumerable#31](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#31)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Except&lt;TSource&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Produz a diferença de conjunto de duas sequências.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Except&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;TSource&gt; Except&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; first, System.Collections.Generic.IEnumerable&lt;TSource&gt; second);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; Except&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; first, class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; second) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Except``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Except(Of TSource) (first As IEnumerable(Of TSource), second As IEnumerable(Of TSource)) As IEnumerable(Of TSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ Except(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ first, System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ second);" />
      <MemberSignature Language="F#" Value="static member Except : seq&lt;'Source&gt; * seq&lt;'Source&gt; -&gt; seq&lt;'Source&gt;" Usage="System.Linq.Enumerable.Except (first, second)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="first" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="second" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">O tipo dos elementos das sequências de entrada.</typeparam>
        <param name="first">Um <see cref="T:System.Collections.Generic.IEnumerable`1" /> cujos elementos que não estão presentes também no <paramref name="second" /> serão retornados.</param>
        <param name="second">Um <see cref="T:System.Collections.Generic.IEnumerable`1" /> cujos elementos que também ocorrem na primeira sequência farão com que esses elementos sejam removidos da sequência retornada.</param>
        <summary>Produz a diferença de conjunto de duas sequências usando o comparador de igualdade padrão para comparar os valores.</summary>
        <returns>Uma sequência que contém a diferença de conjunto dos elementos das duas sequências.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método é implementado usando a execução adiada. O imediata valor retornado é um objeto que armazena todas as informações necessárias para executar a ação. A consulta representada por esse método não é executada até que o objeto é enumerado chamando-se suas `GetEnumerator` método diretamente ou usando `foreach` no Visual c# ou `For Each` no Visual Basic.  
  
 A diferença de conjunto de dois conjuntos é definida como os membros do primeiro conjunto que não aparecem no segundo conjunto.  
  
> [!NOTE]
>  Esse método retorna os elementos na `first` que não aparecem no `second`. Ele também não retornar esses elementos no `second` que não aparecem no `first`.  
  
 O comparador de igualdade padrão, <xref:System.Collections.Generic.EqualityComparer%601.Default%2A>, é usado para comparar valores de tipos que implementam o <xref:System.Collections.Generic.IEqualityComparer%601> interface genérica. Para comparar um tipo de dados personalizado, você precisa implementar esta interface e fornecer seus próprios <xref:System.Object.GetHashCode%2A> e <xref:System.Object.Equals%2A> métodos para o tipo.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como usar o <xref:System.Linq.Enumerable.Except%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%29> método para comparar duas sequências de números e retornar elementos que aparecem somente na primeira sequência.  
  
 [!code-csharp[System.Linq.Enumerable#34](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#34)]
 [!code-vb[System.Linq.Enumerable#34](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#34)]  
  
 Se você quiser comparar sequências de objetos de algum tipo de dados personalizado, você precisa implementar o <xref:System.Collections.Generic.IEqualityComparer%601> interface genérica em um helperclass. O exemplo de código a seguir mostra como implementar essa interface em um tipo de dados personalizadas e fornecer <xref:System.Object.GetHashCode%2A> e <xref:System.Object.Equals%2A> métodos.  
  
 [!code-csharp[CSLINQEncapsulatedComparer#9](~/samples/snippets/csharp/VS_Snippets_VBCSharp/CsLINQEncapsulatedComparer/CS/EncapsulatedComparer.cs#9)]  
  
 Depois de implementar essa interface, você pode usar sequências de `ProductA` objetos no <xref:System.Linq.Enumerable.Except%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%29> método, conforme mostrado no exemplo a seguir.  
  
 [!code-csharp[CSLINQEncapsulatedComparer#7](~/samples/snippets/csharp/VS_Snippets_VBCSharp/CsLINQEncapsulatedComparer/CS/EncapsulatedComparer.cs#7)]
 [!code-vb[CSLINQEncapsulatedComparer#7](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/CsLINQEncapsulatedComparer/VB/EncapsulatedComparer.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="first" /> ou <paramref name="second" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Except&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;TSource&gt; Except&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; first, System.Collections.Generic.IEnumerable&lt;TSource&gt; second, System.Collections.Generic.IEqualityComparer&lt;TSource&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; Except&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; first, class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; second, class System.Collections.Generic.IEqualityComparer`1&lt;!!TSource&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Except``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEqualityComparer{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Except(Of TSource) (first As IEnumerable(Of TSource), second As IEnumerable(Of TSource), comparer As IEqualityComparer(Of TSource)) As IEnumerable(Of TSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ Except(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ first, System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ second, System::Collections::Generic::IEqualityComparer&lt;TSource&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="static member Except : seq&lt;'Source&gt; * seq&lt;'Source&gt; * System.Collections.Generic.IEqualityComparer&lt;'Source&gt; -&gt; seq&lt;'Source&gt;" Usage="System.Linq.Enumerable.Except (first, second, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="first" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="second" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IEqualityComparer&lt;TSource&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">O tipo dos elementos das sequências de entrada.</typeparam>
        <param name="first">Um <see cref="T:System.Collections.Generic.IEnumerable`1" /> cujos elementos que não estão presentes também no <paramref name="second" /> serão retornados.</param>
        <param name="second">Um <see cref="T:System.Collections.Generic.IEnumerable`1" /> cujos elementos que também ocorrem na primeira sequência farão com que esses elementos sejam removidos da sequência retornada.</param>
        <param name="comparer">Um <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> para comparar valores.</param>
        <summary>Produz a diferença de conjunto de duas sequências usando o <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> especificado para comparar os valores.</summary>
        <returns>Uma sequência que contém a diferença de conjunto dos elementos das duas sequências.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se `comparer` está `null`, o comparador de igualdade padrão, <xref:System.Collections.Generic.EqualityComparer%601.Default%2A>, é usado para comparar valores.  
  
   
  
## Examples  
 O exemplo a seguir mostra como implementar um comparador de igualdade que pode ser usado no <xref:System.Linq.Enumerable.Except%2A> método.  
  
 [!code-csharp[CSLINQCustomComparer#1](~/samples/snippets/csharp/VS_Snippets_VBCSharp/CsLINQCustomComparer/CS/CustomComparer.cs#1)]
 [!code-vb[CSLINQCustomComparer#1](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/CsLINQCustomComparer/VB/CustomComparer.vb#1)]  
  
 Depois de implementar esse comparador, você pode usar sequências de `Product` objetos no <xref:System.Linq.Enumerable.Except%2A> método, conforme mostrado no exemplo a seguir.  
  
 [!code-csharp[CSLINQCustomComparer#7](~/samples/snippets/csharp/VS_Snippets_VBCSharp/CsLINQCustomComparer/CS/CustomComparer.cs#7)]
 [!code-vb[CSLINQCustomComparer#7](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/CsLINQCustomComparer/VB/CustomComparer.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="first" /> ou <paramref name="second" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="First&lt;TSource&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Retorna o primeiro elemento de uma sequência.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="First&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static TSource First&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TSource First&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.First``1(System.Collections.Generic.IEnumerable{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function First(Of TSource) (source As IEnumerable(Of TSource)) As TSource" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static TSource First(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member First : seq&lt;'Source&gt; -&gt; 'Source" Usage="System.Linq.Enumerable.First source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TSource</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">O tipo dos elementos de <paramref name="source" />.</typeparam>
        <param name="source">O <see cref="T:System.Collections.Generic.IEnumerable`1" /> do qual o primeiro elemento será retornado.</param>
        <summary>Retorna o primeiro elemento de uma sequência.</summary>
        <returns>O primeiro elemento na sequência especificada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Linq.Enumerable.First%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%29> método lança uma exceção se `source` não contiver elementos. Para retornar em vez disso, um valor padrão quando a sequência de origem estiver vazia, use o <xref:System.Linq.Enumerable.FirstOrDefault%2A> método.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como usar <xref:System.Linq.Enumerable.First%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%29> para retornar o primeiro elemento de uma matriz.  
  
 [!code-csharp[System.Linq.Enumerable#35](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#35)]
 [!code-vb[System.Linq.Enumerable#35](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> é <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Uma sequência de origem está vazia.</exception>
      </Docs>
    </Member>
    <Member MemberName="First&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static TSource First&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,bool&gt; predicate);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TSource First&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, bool&gt; predicate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.First``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Boolean})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function First(Of TSource) (source As IEnumerable(Of TSource), predicate As Func(Of TSource, Boolean)) As TSource" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static TSource First(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Func&lt;TSource, bool&gt; ^ predicate);" />
      <MemberSignature Language="F#" Value="static member First : seq&lt;'Source&gt; * Func&lt;'Source, bool&gt; -&gt; 'Source" Usage="System.Linq.Enumerable.First (source, predicate)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TSource</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="predicate" Type="System.Func&lt;TSource,System.Boolean&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">O tipo dos elementos de <paramref name="source" />.</typeparam>
        <param name="source">Um <see cref="T:System.Collections.Generic.IEnumerable`1" /> do qual um elemento será retornado.</param>
        <param name="predicate">Uma função para testar cada elemento em relação a uma condição.</param>
        <summary>Retorna o primeiro elemento em uma sequência que satisfaz uma condição especificada.</summary>
        <returns>O primeiro elemento na sequência que passa o teste na função de predicado especificada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Linq.Enumerable.First%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Boolean%7D%29> método gera uma exceção se nenhum elemento correspondente for encontrado no `source`. Para retornar em vez disso, um valor padrão quando nenhum elemento correspondente for encontrado, use o <xref:System.Linq.Enumerable.FirstOrDefault%2A> método.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como usar <xref:System.Linq.Enumerable.First%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Boolean%7D%29> para retornar o primeiro elemento de uma matriz que satisfaz uma condição.  
  
 [!code-csharp[System.Linq.Enumerable#36](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#36)]
 [!code-vb[System.Linq.Enumerable#36](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#36)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> ou <paramref name="predicate" /> é <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Nenhum elemento satisfaz a condição na <paramref name="predicate" />.  
  
- ou - 
Uma sequência de origem está vazia.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="FirstOrDefault&lt;TSource&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Retorna o primeiro elemento de uma sequência ou um valor padrão caso não seja encontrado nenhum elemento.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="FirstOrDefault&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static TSource FirstOrDefault&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TSource FirstOrDefault&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.FirstOrDefault``1(System.Collections.Generic.IEnumerable{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function FirstOrDefault(Of TSource) (source As IEnumerable(Of TSource)) As TSource" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static TSource FirstOrDefault(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member FirstOrDefault : seq&lt;'Source&gt; -&gt; 'Source" Usage="System.Linq.Enumerable.FirstOrDefault source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TSource</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">O tipo dos elementos de <paramref name="source" />.</typeparam>
        <param name="source">O <see cref="T:System.Collections.Generic.IEnumerable`1" /> do qual o primeiro elemento será retornado.</param>
        <summary>Retorna o primeiro elemento de uma sequência ou um valor padrão se a sequência não contém elementos.</summary>
        <returns><see langword="default" />(<paramref name="TSource" />) se <paramref name="source" /> estiver vazio; caso contrário, o primeiro elemento em <paramref name="source" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O valor padrão para referência e tipos que permitem valor nulos é `null`.  
  
 O <xref:System.Linq.Enumerable.FirstOrDefault%2A> método não fornece uma maneira de especificar um valor padrão. Se você quiser especificar um valor padrão diferente de `default(TSource)`, use o <xref:System.Linq.Enumerable.DefaultIfEmpty%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2C%60%600%29> método conforme descrito na seção de exemplo.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como usar <xref:System.Linq.Enumerable.FirstOrDefault%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%29> em uma matriz vazia.  
  
 [!code-csharp[System.Linq.Enumerable#37](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#37)]
 [!code-vb[System.Linq.Enumerable#37](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#37)]  
  
 Às vezes, o valor de `default(TSource)` não é o valor padrão que você deseja usar se a coleção não contiver elementos. Em vez de verificar o resultado para o valor padrão indesejado e, em seguida, alterando-se necessário, você pode usar o <xref:System.Linq.Enumerable.DefaultIfEmpty%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2C%60%600%29> método para especificar o valor padrão que você deseja usar, se a coleção está vazia. Em seguida, chame <xref:System.Linq.Enumerable.First%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%29> para obter o primeiro elemento. O exemplo de código a seguir usa ambas as técnicas para obter um valor padrão de 1 se uma coleção de meses numéricos está vazia. Como o valor padrão para um número inteiro é 0, o que não corresponde a qualquer mês, o valor padrão deve ser especificado como 1 em vez disso. A primeira variável de resultado é verificada para o valor padrão indesejados após a conclusão da consulta em execução. A segunda variável de resultado é obtida usando <xref:System.Linq.Enumerable.DefaultIfEmpty%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2C%60%600%29> para especificar um valor padrão de 1.  
  
 [!code-csharp[System.Linq.Enumerable#126](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#126)]
 [!code-vb[System.Linq.Enumerable#126](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#126)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="FirstOrDefault&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static TSource FirstOrDefault&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,bool&gt; predicate);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TSource FirstOrDefault&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, bool&gt; predicate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.FirstOrDefault``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Boolean})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function FirstOrDefault(Of TSource) (source As IEnumerable(Of TSource), predicate As Func(Of TSource, Boolean)) As TSource" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static TSource FirstOrDefault(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Func&lt;TSource, bool&gt; ^ predicate);" />
      <MemberSignature Language="F#" Value="static member FirstOrDefault : seq&lt;'Source&gt; * Func&lt;'Source, bool&gt; -&gt; 'Source" Usage="System.Linq.Enumerable.FirstOrDefault (source, predicate)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TSource</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="predicate" Type="System.Func&lt;TSource,System.Boolean&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">O tipo dos elementos de <paramref name="source" />.</typeparam>
        <param name="source">Um <see cref="T:System.Collections.Generic.IEnumerable`1" /> do qual um elemento será retornado.</param>
        <param name="predicate">Uma função para testar cada elemento em relação a uma condição.</param>
        <summary>Retorna o primeiro elemento da sequência que satisfaz uma condição ou um valor padrão, caso esse elemento não seja encontrado.</summary>
        <returns><see langword="default" />(<paramref name="TSource" />) se <paramref name="source" /> estiver vazio ou se nenhum elemento for aprovado no teste especificado por <paramref name="predicate" />; caso contrário, o primeiro elemento em <paramref name="source" /> que for aprovado no teste especificado por <paramref name="predicate" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O valor padrão para referência e tipos que permitem valor nulos é `null`.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como usar <xref:System.Linq.Enumerable.FirstOrDefault%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Boolean%7D%29> , passando um predicado. A segunda chamada para o método, há nenhum elemento na matriz que atende à condição.  
  
 [!code-csharp[System.Linq.Enumerable#38](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#38)]
 [!code-vb[System.Linq.Enumerable#38](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#38)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> ou <paramref name="predicate" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="GroupBy&lt;TSource,TKey&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Agrupa os elementos de uma sequência.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GroupBy&lt;TSource,TKey&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;System.Linq.IGrouping&lt;TKey,TSource&gt;&gt; GroupBy&lt;TSource,TKey&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,TKey&gt; keySelector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.IGrouping`2&lt;!!TKey, !!TSource&gt;&gt; GroupBy&lt;TSource, TKey&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, !!TKey&gt; keySelector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.GroupBy``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function GroupBy(Of TSource, TKey) (source As IEnumerable(Of TSource), keySelector As Func(Of TSource, TKey)) As IEnumerable(Of IGrouping(Of TKey, TSource))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TKey&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Collections::Generic::IEnumerable&lt;System::Linq::IGrouping&lt;TKey, TSource&gt; ^&gt; ^ GroupBy(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Func&lt;TSource, TKey&gt; ^ keySelector);" />
      <MemberSignature Language="F#" Value="static member GroupBy : seq&lt;'Source&gt; * Func&lt;'Source, 'Key&gt; -&gt; seq&lt;System.Linq.IGrouping&lt;'Key, 'Source&gt;&gt;" Usage="System.Linq.Enumerable.GroupBy (source, keySelector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Linq.IGrouping&lt;TKey,TSource&gt;&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TKey" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="keySelector" Type="System.Func&lt;TSource,TKey&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">O tipo dos elementos de <paramref name="source" />.</typeparam>
        <typeparam name="TKey">O tipo da chave retornada por <paramref name="keySelector" />.</typeparam>
        <param name="source">Um <see cref="T:System.Collections.Generic.IEnumerable`1" /> cujos elementos serão agrupados.</param>
        <param name="keySelector">Uma função para extrair a chave de cada elemento.</param>
        <summary>Agrupa os elementos de uma sequência de acordo com uma função de seletor de chave especificada.</summary>
        <returns>Um <c>IEnumerable&lt;IGrouping&lt;TKey, TSource&gt;&gt;</c> em C# ou <c>IEnumerable(Of IGrouping(Of TKey, TSource))</c> no Visual Basic em que cada objeto <see cref="T:System.Linq.IGrouping`2" /> contém uma sequência de objetos e uma chave.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método é implementado usando a execução adiada. O imediata valor retornado é um objeto que armazena todas as informações necessárias para executar a ação. A consulta representada por esse método não é executada até que o objeto é enumerado chamando-se suas `GetEnumerator` método diretamente ou usando `foreach` no Visual c# ou `For Each` no Visual Basic.  
  
> [!NOTE]
>  Para obter exemplos de `GroupBy`, consulte os tópicos a seguir.  
>   
>  -   <xref:System.Linq.Enumerable.GroupBy%60%603%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2C%60%601%7D%2CSystem.Func%7B%60%600%2C%60%602%7D%29>  
> -   <xref:System.Linq.Enumerable.GroupBy%60%603%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2C%60%601%7D%2CSystem.Func%7B%60%601%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%2C%60%602%7D%29>  
> -   <xref:System.Linq.Enumerable.GroupBy%60%604%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2C%60%601%7D%2CSystem.Func%7B%60%600%2C%60%602%7D%2CSystem.Func%7B%60%601%2CSystem.Collections.Generic.IEnumerable%7B%60%602%7D%2C%60%603%7D%29>  
  
 O <xref:System.Linq.Enumerable.GroupBy%60%602%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2C%60%601%7D%29> método retorna uma coleção de <xref:System.Linq.IGrouping%602> objetos, um para cada chave distinto que foi encontrado. Uma <xref:System.Linq.IGrouping%602> é um <xref:System.Collections.Generic.IEnumerable%601> que também tem uma chave associada a seus elementos.  
  
 O <xref:System.Linq.IGrouping%602> objetos são gerados em uma ordem com base na ordem de elementos no `source` que produziu a primeira chave de cada <xref:System.Linq.IGrouping%602>. Elementos em um agrupamento são gerados na ordem em que aparecem no `source`.  
  
 O comparador de igualdade padrão <xref:System.Collections.Generic.EqualityComparer%601.Default%2A> é usado para comparar chaves.  
  
 Na sintaxe de expressão de consulta, uma `group by` (Visual c#) ou `Group By Into` cláusula (Visual Basic) se traduz em uma invocação de <xref:System.Linq.Enumerable.GroupBy%2A>. Para obter mais informações e exemplos de uso, consulte [cláusula group](~/docs/csharp/language-reference/keywords/group-clause.md) e [por cláusula Group](~/docs/visual-basic/language-reference/queries/group-by-clause.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> ou <paramref name="keySelector" /> é <see langword="null" />.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/c817242e-b12c-4baa-a57e-73ee138f34d1">Cláusula group (Referência de C#)</related>
        <related type="Article" href="https://msdn.microsoft.com/library/b1b5dcea-6654-473b-a2db-01f7e4c265d7">Cláusula Group By (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="GroupBy&lt;TSource,TKey&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;System.Linq.IGrouping&lt;TKey,TSource&gt;&gt; GroupBy&lt;TSource,TKey&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,TKey&gt; keySelector, System.Collections.Generic.IEqualityComparer&lt;TKey&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.IGrouping`2&lt;!!TKey, !!TSource&gt;&gt; GroupBy&lt;TSource, TKey&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, !!TKey&gt; keySelector, class System.Collections.Generic.IEqualityComparer`1&lt;!!TKey&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.GroupBy``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1},System.Collections.Generic.IEqualityComparer{``1})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function GroupBy(Of TSource, TKey) (source As IEnumerable(Of TSource), keySelector As Func(Of TSource, TKey), comparer As IEqualityComparer(Of TKey)) As IEnumerable(Of IGrouping(Of TKey, TSource))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TKey&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Collections::Generic::IEnumerable&lt;System::Linq::IGrouping&lt;TKey, TSource&gt; ^&gt; ^ GroupBy(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Func&lt;TSource, TKey&gt; ^ keySelector, System::Collections::Generic::IEqualityComparer&lt;TKey&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="static member GroupBy : seq&lt;'Source&gt; * Func&lt;'Source, 'Key&gt; * System.Collections.Generic.IEqualityComparer&lt;'Key&gt; -&gt; seq&lt;System.Linq.IGrouping&lt;'Key, 'Source&gt;&gt;" Usage="System.Linq.Enumerable.GroupBy (source, keySelector, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Linq.IGrouping&lt;TKey,TSource&gt;&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TKey" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="keySelector" Type="System.Func&lt;TSource,TKey&gt;" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IEqualityComparer&lt;TKey&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">O tipo dos elementos de <paramref name="source" />.</typeparam>
        <typeparam name="TKey">O tipo da chave retornada por <paramref name="keySelector" />.</typeparam>
        <param name="source">Um <see cref="T:System.Collections.Generic.IEnumerable`1" /> cujos elementos serão agrupados.</param>
        <param name="keySelector">Uma função para extrair a chave de cada elemento.</param>
        <param name="comparer">Um <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> para comparar chaves.</param>
        <summary>Agrupa os elementos de uma sequência de acordo com uma função do seletor de chave especificada e compara as chaves usando um comparador especificado.</summary>
        <returns>Um <c>IEnumerable&lt;IGrouping&lt;TKey, TSource&gt;&gt;</c> em C# ou <c>IEnumerable(Of IGrouping(Of TKey, TSource))</c> no Visual Basic em que cada objeto <see cref="T:System.Linq.IGrouping`2" /> contém uma coleção de objetos e uma chave.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método é implementado usando a execução adiada. O imediata valor retornado é um objeto que armazena todas as informações necessárias para executar a ação. A consulta representada por esse método não é executada até que o objeto é enumerado chamando-se suas `GetEnumerator` método diretamente ou usando `foreach` no Visual c# ou `For Each` no Visual Basic.  
  
> [!NOTE]
>  Para obter exemplos de `GroupBy`, consulte os tópicos a seguir.  
>   
>  -   <xref:System.Linq.Enumerable.GroupBy%60%603%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2C%60%601%7D%2CSystem.Func%7B%60%600%2C%60%602%7D%29>  
> -   <xref:System.Linq.Enumerable.GroupBy%60%603%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2C%60%601%7D%2CSystem.Func%7B%60%601%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%2C%60%602%7D%29>  
> -   <xref:System.Linq.Enumerable.GroupBy%60%604%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2C%60%601%7D%2CSystem.Func%7B%60%600%2C%60%602%7D%2CSystem.Func%7B%60%601%2CSystem.Collections.Generic.IEnumerable%7B%60%602%7D%2C%60%603%7D%29>  
  
 O <xref:System.Linq.Enumerable.GroupBy%60%602%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2C%60%601%7D%2CSystem.Collections.Generic.IEqualityComparer%7B%60%601%7D%29> método retorna uma coleção de <xref:System.Linq.IGrouping%602> objetos, um para cada chave distinto que foi encontrado. Uma <xref:System.Linq.IGrouping%602> é um <xref:System.Collections.Generic.IEnumerable%601> que também tem uma chave associada a seus elementos.  
  
 O <xref:System.Linq.IGrouping%602> objetos são gerados em uma ordem com base na ordem de elementos no `source` que produziu a primeira chave de cada <xref:System.Linq.IGrouping%602>. Elementos em um agrupamento são gerados na ordem em que aparecem no `source`.  
  
 Se `comparer` está `null`, o comparador de igualdade padrão <xref:System.Collections.Generic.EqualityComparer%601.Default%2A> é usado para comparar chaves.  
  
 Se duas chaves forem consideradas iguais de acordo com `comparer`, a primeira chave é escolhida como a chave de agrupamento.  
  
 Na sintaxe de expressão de consulta, uma `group by` (Visual c#) ou `Group By Into` cláusula (Visual Basic) se traduz em uma invocação de <xref:System.Linq.Enumerable.GroupBy%2A>. Para obter mais informações e exemplos de uso, consulte [cláusula group](~/docs/csharp/language-reference/keywords/group-clause.md) e [por cláusula Group](~/docs/visual-basic/language-reference/queries/group-by-clause.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> ou <paramref name="keySelector" /> é <see langword="null" />.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/c817242e-b12c-4baa-a57e-73ee138f34d1">Cláusula group (Referência de C#)</related>
        <related type="Article" href="https://msdn.microsoft.com/library/b1b5dcea-6654-473b-a2db-01f7e4c265d7">Cláusula Group By (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="GroupBy&lt;TSource,TKey,TElement&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;System.Linq.IGrouping&lt;TKey,TElement&gt;&gt; GroupBy&lt;TSource,TKey,TElement&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,TKey&gt; keySelector, Func&lt;TSource,TElement&gt; elementSelector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.IGrouping`2&lt;!!TKey, !!TElement&gt;&gt; GroupBy&lt;TSource, TKey, TElement&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, !!TKey&gt; keySelector, class System.Func`2&lt;!!TSource, !!TElement&gt; elementSelector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.GroupBy``3(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1},System.Func{``0,``2})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function GroupBy(Of TSource, TKey, TElement) (source As IEnumerable(Of TSource), keySelector As Func(Of TSource, TKey), elementSelector As Func(Of TSource, TElement)) As IEnumerable(Of IGrouping(Of TKey, TElement))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TKey, typename TElement&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Collections::Generic::IEnumerable&lt;System::Linq::IGrouping&lt;TKey, TElement&gt; ^&gt; ^ GroupBy(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Func&lt;TSource, TKey&gt; ^ keySelector, Func&lt;TSource, TElement&gt; ^ elementSelector);" />
      <MemberSignature Language="F#" Value="static member GroupBy : seq&lt;'Source&gt; * Func&lt;'Source, 'Key&gt; * Func&lt;'Source, 'Element&gt; -&gt; seq&lt;System.Linq.IGrouping&lt;'Key, 'Element&gt;&gt;" Usage="System.Linq.Enumerable.GroupBy (source, keySelector, elementSelector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Linq.IGrouping&lt;TKey,TElement&gt;&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TKey" />
        <TypeParameter Name="TElement" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="keySelector" Type="System.Func&lt;TSource,TKey&gt;" />
        <Parameter Name="elementSelector" Type="System.Func&lt;TSource,TElement&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">O tipo dos elementos de <paramref name="source" />.</typeparam>
        <typeparam name="TKey">O tipo da chave retornada por <paramref name="keySelector" />.</typeparam>
        <typeparam name="TElement">O tipo dos elementos no <see cref="T:System.Linq.IGrouping`2" />.</typeparam>
        <param name="source">Um <see cref="T:System.Collections.Generic.IEnumerable`1" /> cujos elementos serão agrupados.</param>
        <param name="keySelector">Uma função para extrair a chave de cada elemento.</param>
        <param name="elementSelector">Uma função para mapear cada elemento de origem para um elemento no <see cref="T:System.Linq.IGrouping`2" />.</param>
        <summary>Agrupa os elementos de uma sequência de acordo com a função de seletor de chave especificada e projeta os elementos de cada grupo usando uma função especificada.</summary>
        <returns>Um <c>IEnumerable&lt;IGrouping&lt;TKey, TElement&gt;&gt;</c> em C# ou <c>IEnumerable(Of IGrouping(Of TKey, TElement))</c> no Visual Basic em que cada objeto <see cref="T:System.Linq.IGrouping`2" /> contém uma coleção de objetos de tipo <paramref name="TElement" /> e uma chave.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método é implementado usando a execução adiada. O imediata valor retornado é um objeto que armazena todas as informações necessárias para executar a ação. A consulta representada por esse método não é executada até que o objeto é enumerado chamando-se suas `GetEnumerator` método diretamente ou usando `foreach` no Visual c# ou `For Each` no Visual Basic.  
  
 O <xref:System.Linq.Enumerable.GroupBy%60%603%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2C%60%601%7D%2CSystem.Func%7B%60%600%2C%60%602%7D%29> método retorna uma coleção de <xref:System.Linq.IGrouping%602> objetos, um para cada chave distinto que foi encontrado. Uma <xref:System.Linq.IGrouping%602> é um <xref:System.Collections.Generic.IEnumerable%601> que também tem uma chave associada a seus elementos.  
  
 O <xref:System.Linq.IGrouping%602> objetos são gerados em uma ordem com base na ordem de elementos no `source` que produziu a primeira chave de cada <xref:System.Linq.IGrouping%602>. Elementos em um agrupamento são gerados na ordem em que os elementos que as produziu aparecer em `source`.  
  
 O comparador de igualdade padrão <xref:System.Collections.Generic.EqualityComparer%601.Default%2A> é usado para comparar chaves.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como usar <xref:System.Linq.Enumerable.GroupBy%60%603%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2C%60%601%7D%2CSystem.Func%7B%60%600%2C%60%602%7D%29> para agrupar os elementos de uma sequência.  
  
 [!code-csharp[System.Linq.Enumerable#39](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#39)]
 [!code-vb[System.Linq.Enumerable#39](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#39)]  
  
 Na sintaxe de expressão de consulta, uma `group by` (Visual c#) ou `Group By Into` cláusula (Visual Basic) se traduz em uma invocação de <xref:System.Linq.Enumerable.GroupBy%2A>. A conversão da expressão de consulta no exemplo a seguir é equivalente à consulta no exemplo acima.  
  
 [!code-csharp[System.Linq.Enumerable#122](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#122)]
 [!code-vb[System.Linq.Enumerable#122](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#122)]  
  
> [!NOTE]
>  Em uma expressão de consulta Visual c# ou Visual Basic, ocorrem as expressões de seleção do elemento e a chave na ordem inversa de suas posições de argumento em uma chamada para o <xref:System.Linq.Enumerable.GroupBy%60%603%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2C%60%601%7D%2CSystem.Func%7B%60%600%2C%60%602%7D%29> método.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" />, <paramref name="keySelector" /> ou <paramref name="elementSelector" /> é <see langword="null" />.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/c817242e-b12c-4baa-a57e-73ee138f34d1">Cláusula group (Referência de C#)</related>
        <related type="Article" href="https://msdn.microsoft.com/library/b1b5dcea-6654-473b-a2db-01f7e4c265d7">Cláusula Group By (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="GroupBy&lt;TSource,TKey,TElement&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;System.Linq.IGrouping&lt;TKey,TElement&gt;&gt; GroupBy&lt;TSource,TKey,TElement&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,TKey&gt; keySelector, Func&lt;TSource,TElement&gt; elementSelector, System.Collections.Generic.IEqualityComparer&lt;TKey&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.IGrouping`2&lt;!!TKey, !!TElement&gt;&gt; GroupBy&lt;TSource, TKey, TElement&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, !!TKey&gt; keySelector, class System.Func`2&lt;!!TSource, !!TElement&gt; elementSelector, class System.Collections.Generic.IEqualityComparer`1&lt;!!TKey&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.GroupBy``3(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1},System.Func{``0,``2},System.Collections.Generic.IEqualityComparer{``1})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function GroupBy(Of TSource, TKey, TElement) (source As IEnumerable(Of TSource), keySelector As Func(Of TSource, TKey), elementSelector As Func(Of TSource, TElement), comparer As IEqualityComparer(Of TKey)) As IEnumerable(Of IGrouping(Of TKey, TElement))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TKey, typename TElement&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Collections::Generic::IEnumerable&lt;System::Linq::IGrouping&lt;TKey, TElement&gt; ^&gt; ^ GroupBy(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Func&lt;TSource, TKey&gt; ^ keySelector, Func&lt;TSource, TElement&gt; ^ elementSelector, System::Collections::Generic::IEqualityComparer&lt;TKey&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="static member GroupBy : seq&lt;'Source&gt; * Func&lt;'Source, 'Key&gt; * Func&lt;'Source, 'Element&gt; * System.Collections.Generic.IEqualityComparer&lt;'Key&gt; -&gt; seq&lt;System.Linq.IGrouping&lt;'Key, 'Element&gt;&gt;" Usage="System.Linq.Enumerable.GroupBy (source, keySelector, elementSelector, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Linq.IGrouping&lt;TKey,TElement&gt;&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TKey" />
        <TypeParameter Name="TElement" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="keySelector" Type="System.Func&lt;TSource,TKey&gt;" />
        <Parameter Name="elementSelector" Type="System.Func&lt;TSource,TElement&gt;" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IEqualityComparer&lt;TKey&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">O tipo dos elementos de <paramref name="source" />.</typeparam>
        <typeparam name="TKey">O tipo da chave retornada por <paramref name="keySelector" />.</typeparam>
        <typeparam name="TElement">O tipo dos elementos no <see cref="T:System.Linq.IGrouping`2" />.</typeparam>
        <param name="source">Um <see cref="T:System.Collections.Generic.IEnumerable`1" /> cujos elementos serão agrupados.</param>
        <param name="keySelector">Uma função para extrair a chave de cada elemento.</param>
        <param name="elementSelector">Uma função para mapear cada elemento de origem para um elemento em um <see cref="T:System.Linq.IGrouping`2" />.</param>
        <param name="comparer">Um <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> para comparar chaves.</param>
        <summary>Agrupa os elementos de uma sequência de acordo com uma função de seletor de chave. As chaves são comparadas usando um comparador e os elementos de cada grupo são projetados usando uma função especificada.</summary>
        <returns>Um <c>IEnumerable&lt;IGrouping&lt;TKey, TElement&gt;&gt;</c> em C# ou <c>IEnumerable(Of IGrouping(Of TKey, TElement))</c> no Visual Basic em que cada objeto <see cref="T:System.Linq.IGrouping`2" /> contém uma coleção de objetos de tipo <paramref name="TElement" /> e uma chave.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método é implementado usando a execução adiada. O imediata valor retornado é um objeto que armazena todas as informações necessárias para executar a ação. A consulta representada por esse método não é executada até que o objeto é enumerado chamando-se suas `GetEnumerator` método diretamente ou usando `foreach` no Visual c# ou `For Each` no Visual Basic.  
  
> [!NOTE]
>  Para obter exemplos de `GroupBy`, consulte os tópicos a seguir.  
>   
>  -   <xref:System.Linq.Enumerable.GroupBy%60%603%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2C%60%601%7D%2CSystem.Func%7B%60%600%2C%60%602%7D%29>  
> -   <xref:System.Linq.Enumerable.GroupBy%60%603%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2C%60%601%7D%2CSystem.Func%7B%60%601%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%2C%60%602%7D%29>  
> -   <xref:System.Linq.Enumerable.GroupBy%60%604%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2C%60%601%7D%2CSystem.Func%7B%60%600%2C%60%602%7D%2CSystem.Func%7B%60%601%2CSystem.Collections.Generic.IEnumerable%7B%60%602%7D%2C%60%603%7D%29>  
  
 O <xref:System.Linq.Enumerable.GroupBy%60%603%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2C%60%601%7D%2CSystem.Func%7B%60%600%2C%60%602%7D%2CSystem.Collections.Generic.IEqualityComparer%7B%60%601%7D%29> método retorna uma coleção de <xref:System.Linq.IGrouping%602> objetos, um para cada chave distinto que foi encontrado. Uma <xref:System.Linq.IGrouping%602> é um <xref:System.Collections.Generic.IEnumerable%601> que também tem uma chave associada a seus elementos.  
  
 O <xref:System.Linq.IGrouping%602> objetos são gerados em uma ordem com base na ordem de elementos no `source` que produziu a primeira chave de cada <xref:System.Linq.IGrouping%602>. Elementos em um agrupamento são gerados na ordem em que os elementos que as produziu aparecer em `source`.  
  
 Se `comparer` está `null`, o comparador de igualdade padrão <xref:System.Collections.Generic.EqualityComparer%601.Default%2A> é usado para comparar chaves.  
  
 Se duas chaves forem consideradas iguais de acordo com `comparer`, a primeira chave é escolhida como a chave de agrupamento.  
  
 Na sintaxe de expressão de consulta, uma `group by` (Visual c#) ou `Group By Into` cláusula (Visual Basic) se traduz em uma invocação de <xref:System.Linq.Enumerable.GroupBy%2A>. Para obter mais informações e exemplos de uso, consulte [cláusula group](~/docs/csharp/language-reference/keywords/group-clause.md) e [por cláusula Group](~/docs/visual-basic/language-reference/queries/group-by-clause.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" />, <paramref name="keySelector" /> ou <paramref name="elementSelector" /> é <see langword="null" />.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/c817242e-b12c-4baa-a57e-73ee138f34d1">Cláusula group (Referência de C#)</related>
        <related type="Article" href="https://msdn.microsoft.com/library/b1b5dcea-6654-473b-a2db-01f7e4c265d7">Cláusula Group By (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="GroupBy&lt;TSource,TKey,TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;TResult&gt; GroupBy&lt;TSource,TKey,TResult&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,TKey&gt; keySelector, Func&lt;TKey,System.Collections.Generic.IEnumerable&lt;TSource&gt;,TResult&gt; resultSelector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;!!TResult&gt; GroupBy&lt;TSource, TKey, TResult&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, !!TKey&gt; keySelector, class System.Func`3&lt;!!TKey, class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt;, !!TResult&gt; resultSelector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.GroupBy``3(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1},System.Func{``1,System.Collections.Generic.IEnumerable{``0},``2})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function GroupBy(Of TSource, TKey, TResult) (source As IEnumerable(Of TSource), keySelector As Func(Of TSource, TKey), resultSelector As Func(Of TKey, IEnumerable(Of TSource), TResult)) As IEnumerable(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TKey, typename TResult&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Collections::Generic::IEnumerable&lt;TResult&gt; ^ GroupBy(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Func&lt;TSource, TKey&gt; ^ keySelector, Func&lt;TKey, System::Collections::Generic::IEnumerable&lt;TSource&gt; ^, TResult&gt; ^ resultSelector);" />
      <MemberSignature Language="F#" Value="static member GroupBy : seq&lt;'Source&gt; * Func&lt;'Source, 'Key&gt; * Func&lt;'Key, seq&lt;'Source&gt;, 'Result&gt; -&gt; seq&lt;'Result&gt;" Usage="System.Linq.Enumerable.GroupBy (source, keySelector, resultSelector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TKey" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="keySelector" Type="System.Func&lt;TSource,TKey&gt;" />
        <Parameter Name="resultSelector" Type="System.Func&lt;TKey,System.Collections.Generic.IEnumerable&lt;TSource&gt;,TResult&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">O tipo dos elementos de <paramref name="source" />.</typeparam>
        <typeparam name="TKey">O tipo da chave retornada por <paramref name="keySelector" />.</typeparam>
        <typeparam name="TResult">O tipo do valor de resultado retornado por <paramref name="resultSelector" />.</typeparam>
        <param name="source">Um <see cref="T:System.Collections.Generic.IEnumerable`1" /> cujos elementos serão agrupados.</param>
        <param name="keySelector">Uma função para extrair a chave de cada elemento.</param>
        <param name="resultSelector">Uma função para criar um valor de resultado de cada grupo.</param>
        <summary>Agrupa os elementos de uma sequência de acordo com uma função do seletor de chave especificada e cria um valor de resultado de cada grupo e sua chave.</summary>
        <returns>Uma coleção de elementos do tipo <paramref name="TResult" />, em que cada elemento representa uma projeção em um grupo e sua chave.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Na sintaxe de expressão de consulta, uma `group by` (Visual c#) ou `Group By Into` cláusula (Visual Basic) se traduz em uma invocação de <xref:System.Linq.Enumerable.GroupBy%2A>.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como usar <xref:System.Linq.Enumerable.GroupBy%60%603%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2C%60%601%7D%2CSystem.Func%7B%60%601%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%2C%60%602%7D%29> para agrupar os elementos de uma sequência e uma sequência de resultados do tipo de projeto `TResult`.  
  
 [!code-csharp[System.Linq.Enumerable#15](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#15)]
 [!code-vb[System.Linq.Enumerable#15](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#15)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/c817242e-b12c-4baa-a57e-73ee138f34d1">Cláusula group (Referência de C#)</related>
        <related type="Article" href="https://msdn.microsoft.com/library/b1b5dcea-6654-473b-a2db-01f7e4c265d7">Cláusula Group By (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="GroupBy&lt;TSource,TKey,TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;TResult&gt; GroupBy&lt;TSource,TKey,TResult&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,TKey&gt; keySelector, Func&lt;TKey,System.Collections.Generic.IEnumerable&lt;TSource&gt;,TResult&gt; resultSelector, System.Collections.Generic.IEqualityComparer&lt;TKey&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;!!TResult&gt; GroupBy&lt;TSource, TKey, TResult&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, !!TKey&gt; keySelector, class System.Func`3&lt;!!TKey, class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt;, !!TResult&gt; resultSelector, class System.Collections.Generic.IEqualityComparer`1&lt;!!TKey&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.GroupBy``3(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1},System.Func{``1,System.Collections.Generic.IEnumerable{``0},``2},System.Collections.Generic.IEqualityComparer{``1})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function GroupBy(Of TSource, TKey, TResult) (source As IEnumerable(Of TSource), keySelector As Func(Of TSource, TKey), resultSelector As Func(Of TKey, IEnumerable(Of TSource), TResult), comparer As IEqualityComparer(Of TKey)) As IEnumerable(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TKey, typename TResult&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Collections::Generic::IEnumerable&lt;TResult&gt; ^ GroupBy(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Func&lt;TSource, TKey&gt; ^ keySelector, Func&lt;TKey, System::Collections::Generic::IEnumerable&lt;TSource&gt; ^, TResult&gt; ^ resultSelector, System::Collections::Generic::IEqualityComparer&lt;TKey&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="static member GroupBy : seq&lt;'Source&gt; * Func&lt;'Source, 'Key&gt; * Func&lt;'Key, seq&lt;'Source&gt;, 'Result&gt; * System.Collections.Generic.IEqualityComparer&lt;'Key&gt; -&gt; seq&lt;'Result&gt;" Usage="System.Linq.Enumerable.GroupBy (source, keySelector, resultSelector, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TKey" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="keySelector" Type="System.Func&lt;TSource,TKey&gt;" />
        <Parameter Name="resultSelector" Type="System.Func&lt;TKey,System.Collections.Generic.IEnumerable&lt;TSource&gt;,TResult&gt;" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IEqualityComparer&lt;TKey&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">O tipo dos elementos de <paramref name="source" />.</typeparam>
        <typeparam name="TKey">O tipo da chave retornada por <paramref name="keySelector" />.</typeparam>
        <typeparam name="TResult">O tipo do valor de resultado retornado por <paramref name="resultSelector" />.</typeparam>
        <param name="source">Um <see cref="T:System.Collections.Generic.IEnumerable`1" /> cujos elementos serão agrupados.</param>
        <param name="keySelector">Uma função para extrair a chave de cada elemento.</param>
        <param name="resultSelector">Uma função para criar um valor de resultado de cada grupo.</param>
        <param name="comparer">Um <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> com o qual as chaves serão comparadas.</param>
        <summary>Agrupa os elementos de uma sequência de acordo com uma função do seletor de chave especificada e cria um valor de resultado de cada grupo e sua chave. As chaves são comparadas usando um comparador especificado.</summary>
        <returns>Uma coleção de elementos do tipo <paramref name="TResult" />, em que cada elemento representa uma projeção em um grupo e sua chave.</returns>
        <remarks>To be added.</remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/c817242e-b12c-4baa-a57e-73ee138f34d1">Cláusula group (Referência de C#)</related>
        <related type="Article" href="https://msdn.microsoft.com/library/b1b5dcea-6654-473b-a2db-01f7e4c265d7">Cláusula Group By (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="GroupBy&lt;TSource,TKey,TElement,TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;TResult&gt; GroupBy&lt;TSource,TKey,TElement,TResult&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,TKey&gt; keySelector, Func&lt;TSource,TElement&gt; elementSelector, Func&lt;TKey,System.Collections.Generic.IEnumerable&lt;TElement&gt;,TResult&gt; resultSelector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;!!TResult&gt; GroupBy&lt;TSource, TKey, TElement, TResult&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, !!TKey&gt; keySelector, class System.Func`2&lt;!!TSource, !!TElement&gt; elementSelector, class System.Func`3&lt;!!TKey, class System.Collections.Generic.IEnumerable`1&lt;!!TElement&gt;, !!TResult&gt; resultSelector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.GroupBy``4(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1},System.Func{``0,``2},System.Func{``1,System.Collections.Generic.IEnumerable{``2},``3})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function GroupBy(Of TSource, TKey, TElement, TResult) (source As IEnumerable(Of TSource), keySelector As Func(Of TSource, TKey), elementSelector As Func(Of TSource, TElement), resultSelector As Func(Of TKey, IEnumerable(Of TElement), TResult)) As IEnumerable(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TKey, typename TElement, typename TResult&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Collections::Generic::IEnumerable&lt;TResult&gt; ^ GroupBy(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Func&lt;TSource, TKey&gt; ^ keySelector, Func&lt;TSource, TElement&gt; ^ elementSelector, Func&lt;TKey, System::Collections::Generic::IEnumerable&lt;TElement&gt; ^, TResult&gt; ^ resultSelector);" />
      <MemberSignature Language="F#" Value="static member GroupBy : seq&lt;'Source&gt; * Func&lt;'Source, 'Key&gt; * Func&lt;'Source, 'Element&gt; * Func&lt;'Key, seq&lt;'Element&gt;, 'Result&gt; -&gt; seq&lt;'Result&gt;" Usage="System.Linq.Enumerable.GroupBy (source, keySelector, elementSelector, resultSelector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TKey" />
        <TypeParameter Name="TElement" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="keySelector" Type="System.Func&lt;TSource,TKey&gt;" />
        <Parameter Name="elementSelector" Type="System.Func&lt;TSource,TElement&gt;" />
        <Parameter Name="resultSelector" Type="System.Func&lt;TKey,System.Collections.Generic.IEnumerable&lt;TElement&gt;,TResult&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">O tipo dos elementos de <paramref name="source" />.</typeparam>
        <typeparam name="TKey">O tipo da chave retornada por <paramref name="keySelector" />.</typeparam>
        <typeparam name="TElement">O tipo dos elementos em cada <see cref="T:System.Linq.IGrouping`2" />.</typeparam>
        <typeparam name="TResult">O tipo do valor de resultado retornado por <paramref name="resultSelector" />.</typeparam>
        <param name="source">Um <see cref="T:System.Collections.Generic.IEnumerable`1" /> cujos elementos serão agrupados.</param>
        <param name="keySelector">Uma função para extrair a chave de cada elemento.</param>
        <param name="elementSelector">Uma função para mapear cada elemento de origem para um elemento em um <see cref="T:System.Linq.IGrouping`2" />.</param>
        <param name="resultSelector">Uma função para criar um valor de resultado de cada grupo.</param>
        <summary>Agrupa os elementos de uma sequência de acordo com uma função do seletor de chave especificada e cria um valor de resultado de cada grupo e sua chave. Os elementos de cada grupo são projetados usando uma função especificada.</summary>
        <returns>Uma coleção de elementos do tipo <paramref name="TResult" />, em que cada elemento representa uma projeção em um grupo e sua chave.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Na sintaxe de expressão de consulta, uma `group by` (Visual c#) ou `Group By Into` cláusula (Visual Basic) se traduz em uma invocação de <xref:System.Linq.Enumerable.GroupBy%2A>.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como usar <xref:System.Linq.Enumerable.GroupBy%60%604%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2C%60%601%7D%2CSystem.Func%7B%60%600%2C%60%602%7D%2CSystem.Func%7B%60%601%2CSystem.Collections.Generic.IEnumerable%7B%60%602%7D%2C%60%603%7D%29> para agrupar os elementos projetados de uma sequência e, em seguida, uma sequência de resultados do tipo de projeto `TResult`.  
  
 [!code-csharp[System.Linq.Enumerable#125](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#125)]
 [!code-vb[System.Linq.Enumerable#125](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#125)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/c817242e-b12c-4baa-a57e-73ee138f34d1">Cláusula group (Referência de C#)</related>
        <related type="Article" href="https://msdn.microsoft.com/library/b1b5dcea-6654-473b-a2db-01f7e4c265d7">Cláusula Group By (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="GroupBy&lt;TSource,TKey,TElement,TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;TResult&gt; GroupBy&lt;TSource,TKey,TElement,TResult&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,TKey&gt; keySelector, Func&lt;TSource,TElement&gt; elementSelector, Func&lt;TKey,System.Collections.Generic.IEnumerable&lt;TElement&gt;,TResult&gt; resultSelector, System.Collections.Generic.IEqualityComparer&lt;TKey&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;!!TResult&gt; GroupBy&lt;TSource, TKey, TElement, TResult&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, !!TKey&gt; keySelector, class System.Func`2&lt;!!TSource, !!TElement&gt; elementSelector, class System.Func`3&lt;!!TKey, class System.Collections.Generic.IEnumerable`1&lt;!!TElement&gt;, !!TResult&gt; resultSelector, class System.Collections.Generic.IEqualityComparer`1&lt;!!TKey&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.GroupBy``4(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1},System.Func{``0,``2},System.Func{``1,System.Collections.Generic.IEnumerable{``2},``3},System.Collections.Generic.IEqualityComparer{``1})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function GroupBy(Of TSource, TKey, TElement, TResult) (source As IEnumerable(Of TSource), keySelector As Func(Of TSource, TKey), elementSelector As Func(Of TSource, TElement), resultSelector As Func(Of TKey, IEnumerable(Of TElement), TResult), comparer As IEqualityComparer(Of TKey)) As IEnumerable(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TKey, typename TElement, typename TResult&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Collections::Generic::IEnumerable&lt;TResult&gt; ^ GroupBy(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Func&lt;TSource, TKey&gt; ^ keySelector, Func&lt;TSource, TElement&gt; ^ elementSelector, Func&lt;TKey, System::Collections::Generic::IEnumerable&lt;TElement&gt; ^, TResult&gt; ^ resultSelector, System::Collections::Generic::IEqualityComparer&lt;TKey&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="static member GroupBy : seq&lt;'Source&gt; * Func&lt;'Source, 'Key&gt; * Func&lt;'Source, 'Element&gt; * Func&lt;'Key, seq&lt;'Element&gt;, 'Result&gt; * System.Collections.Generic.IEqualityComparer&lt;'Key&gt; -&gt; seq&lt;'Result&gt;" Usage="System.Linq.Enumerable.GroupBy (source, keySelector, elementSelector, resultSelector, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TKey" />
        <TypeParameter Name="TElement" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="keySelector" Type="System.Func&lt;TSource,TKey&gt;" />
        <Parameter Name="elementSelector" Type="System.Func&lt;TSource,TElement&gt;" />
        <Parameter Name="resultSelector" Type="System.Func&lt;TKey,System.Collections.Generic.IEnumerable&lt;TElement&gt;,TResult&gt;" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IEqualityComparer&lt;TKey&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">O tipo dos elementos de <paramref name="source" />.</typeparam>
        <typeparam name="TKey">O tipo da chave retornada por <paramref name="keySelector" />.</typeparam>
        <typeparam name="TElement">O tipo dos elementos em cada <see cref="T:System.Linq.IGrouping`2" />.</typeparam>
        <typeparam name="TResult">O tipo do valor de resultado retornado por <paramref name="resultSelector" />.</typeparam>
        <param name="source">Um <see cref="T:System.Collections.Generic.IEnumerable`1" /> cujos elementos serão agrupados.</param>
        <param name="keySelector">Uma função para extrair a chave de cada elemento.</param>
        <param name="elementSelector">Uma função para mapear cada elemento de origem para um elemento em um <see cref="T:System.Linq.IGrouping`2" />.</param>
        <param name="resultSelector">Uma função para criar um valor de resultado de cada grupo.</param>
        <param name="comparer">Um <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> com o qual as chaves serão comparadas.</param>
        <summary>Agrupa os elementos de uma sequência de acordo com uma função do seletor de chave especificada e cria um valor de resultado de cada grupo e sua chave. Os valores da chave são comparados usando um comparador especificado e os elementos de cada grupo são projetados usando uma função especificada.</summary>
        <returns>Uma coleção de elementos do tipo <paramref name="TResult" />, em que cada elemento representa uma projeção em um grupo e sua chave.</returns>
        <remarks>To be added.</remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/c817242e-b12c-4baa-a57e-73ee138f34d1">Cláusula group (Referência de C#)</related>
        <related type="Article" href="https://msdn.microsoft.com/library/b1b5dcea-6654-473b-a2db-01f7e4c265d7">Cláusula Group By (Visual Basic)</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="GroupJoin&lt;TOuter,TInner,TKey,TResult&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Correlaciona os elementos de duas sequências com base na igualdade de chaves e agrupa os resultados.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GroupJoin&lt;TOuter,TInner,TKey,TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;TResult&gt; GroupJoin&lt;TOuter,TInner,TKey,TResult&gt; (this System.Collections.Generic.IEnumerable&lt;TOuter&gt; outer, System.Collections.Generic.IEnumerable&lt;TInner&gt; inner, Func&lt;TOuter,TKey&gt; outerKeySelector, Func&lt;TInner,TKey&gt; innerKeySelector, Func&lt;TOuter,System.Collections.Generic.IEnumerable&lt;TInner&gt;,TResult&gt; resultSelector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;!!TResult&gt; GroupJoin&lt;TOuter, TInner, TKey, TResult&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TOuter&gt; outer, class System.Collections.Generic.IEnumerable`1&lt;!!TInner&gt; inner, class System.Func`2&lt;!!TOuter, !!TKey&gt; outerKeySelector, class System.Func`2&lt;!!TInner, !!TKey&gt; innerKeySelector, class System.Func`3&lt;!!TOuter, class System.Collections.Generic.IEnumerable`1&lt;!!TInner&gt;, !!TResult&gt; resultSelector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.GroupJoin``4(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1},System.Func{``0,``2},System.Func{``1,``2},System.Func{``0,System.Collections.Generic.IEnumerable{``1},``3})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function GroupJoin(Of TOuter, TInner, TKey, TResult) (outer As IEnumerable(Of TOuter), inner As IEnumerable(Of TInner), outerKeySelector As Func(Of TOuter, TKey), innerKeySelector As Func(Of TInner, TKey), resultSelector As Func(Of TOuter, IEnumerable(Of TInner), TResult)) As IEnumerable(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TOuter, typename TInner, typename TKey, typename TResult&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Collections::Generic::IEnumerable&lt;TResult&gt; ^ GroupJoin(System::Collections::Generic::IEnumerable&lt;TOuter&gt; ^ outer, System::Collections::Generic::IEnumerable&lt;TInner&gt; ^ inner, Func&lt;TOuter, TKey&gt; ^ outerKeySelector, Func&lt;TInner, TKey&gt; ^ innerKeySelector, Func&lt;TOuter, System::Collections::Generic::IEnumerable&lt;TInner&gt; ^, TResult&gt; ^ resultSelector);" />
      <MemberSignature Language="F#" Value="static member GroupJoin : seq&lt;'Outer&gt; * seq&lt;'Inner&gt; * Func&lt;'Outer, 'Key&gt; * Func&lt;'Inner, 'Key&gt; * Func&lt;'Outer, seq&lt;'Inner&gt;, 'Result&gt; -&gt; seq&lt;'Result&gt;" Usage="System.Linq.Enumerable.GroupJoin (outer, inner, outerKeySelector, innerKeySelector, resultSelector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TOuter" />
        <TypeParameter Name="TInner" />
        <TypeParameter Name="TKey" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="outer" Type="System.Collections.Generic.IEnumerable&lt;TOuter&gt;" RefType="this" />
        <Parameter Name="inner" Type="System.Collections.Generic.IEnumerable&lt;TInner&gt;" />
        <Parameter Name="outerKeySelector" Type="System.Func&lt;TOuter,TKey&gt;" />
        <Parameter Name="innerKeySelector" Type="System.Func&lt;TInner,TKey&gt;" />
        <Parameter Name="resultSelector" Type="System.Func&lt;TOuter,System.Collections.Generic.IEnumerable&lt;TInner&gt;,TResult&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TOuter">O tipo dos elementos da primeira sequência.</typeparam>
        <typeparam name="TInner">O tipo dos elementos da segunda sequência.</typeparam>
        <typeparam name="TKey">O tipo das chaves retornadas pelas funções de seletor de chave.</typeparam>
        <typeparam name="TResult">O tipo dos elementos de resultado.</typeparam>
        <param name="outer">A primeira sequência a ser ingressada.</param>
        <param name="inner">A sequência a ser ingressada à primeira sequência.</param>
        <param name="outerKeySelector">Uma função para extrair a chave de junção de cada elemento da primeira sequência.</param>
        <param name="innerKeySelector">Uma função para extrair a chave de junção de cada elemento da segunda sequência.</param>
        <param name="resultSelector">Uma função para criar um elemento de resultado de um elemento da primeira sequência e uma coleção de elementos correspondentes da segunda sequência.</param>
        <summary>Correlaciona os elementos de duas sequências com base na igualdade de chaves e agrupa os resultados. O comparador de igualdade padrão é usado para comparar chaves.</summary>
        <returns>Um <see cref="T:System.Collections.Generic.IEnumerable`1" /> que contém elementos do tipo <paramref name="TResult" /> obtidos pela execução de uma junção agrupada em duas sequências.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método é implementado usando a execução adiada. O imediata valor retornado é um objeto que armazena todas as informações necessárias para executar a ação. A consulta representada por esse método não é executada até que o objeto é enumerado chamando-se suas `GetEnumerator` método diretamente ou usando `foreach` no Visual c# ou `For Each` no Visual Basic.  
  
 O comparador de igualdade padrão, <xref:System.Collections.Generic.EqualityComparer%601.Default%2A>, é usado para hash e comparar chaves.  
  
 <xref:System.Linq.Enumerable.GroupJoin%2A> produz resultados hierárquicos que significa que elementos de `outer` são emparelhados com coleções de elementos correspondentes da `inner`. `GroupJoin` permite que você baseie seus resultados em todo um conjunto de correspondências para cada elemento da `outer`.  
  
> [!NOTE]
>  Se não houver nenhum elemento correlacionado no `inner` para um determinado elemento de `outer`, a sequência de correspondências para esse elemento estará vazia, mas ainda aparecerá nos resultados.  
  
 O `resultSelector` função é chamada apenas uma vez para cada `outer` elemento junto com uma coleção de todos os `inner` elementos que correspondem a `outer` elemento. Isso difere de <xref:System.Linq.Enumerable.Join%2A> método, em que a função de seletor de resultado é chamada nos pares de contenham um elemento de `outer` e um elemento de `inner`.  
  
 `GroupJoin` preserva a ordem dos elementos da `outer`e para cada elemento de `outer`, a ordem dos elementos correspondentes de `inner`.  
  
 <xref:System.Linq.Enumerable.GroupJoin%2A> tem equivalente direto em termos de banco de dados relacionais tradicionais. No entanto, esse método implementa um superconjunto de junções internas e junções externas esquerdas. Ambas essas operações podem ser gravadas em termos de uma junção agrupada. Ver [operações de junção](https://msdn.microsoft.com/library/442d176d-028c-4beb-8d22-407d4ef89107).  
  
 Na sintaxe de expressão de consulta, uma `join … into` (Visual c#) ou `Group Join` cláusula (Visual Basic) se traduz em uma invocação de <xref:System.Linq.Enumerable.GroupJoin%2A>.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como usar <xref:System.Linq.Enumerable.GroupJoin%60%604%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Collections.Generic.IEnumerable%7B%60%601%7D%2CSystem.Func%7B%60%600%2C%60%602%7D%2CSystem.Func%7B%60%601%2C%60%602%7D%2CSystem.Func%7B%60%600%2CSystem.Collections.Generic.IEnumerable%7B%60%601%7D%2C%60%603%7D%29> para realizar uma junção agrupada em duas sequências.  
  
 [!code-csharp[System.Linq.Enumerable#40](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#40)]
 [!code-vb[System.Linq.Enumerable#40](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#40)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="outer" /> ou <paramref name="inner" /> ou <paramref name="outerKeySelector" /> ou <paramref name="innerKeySelector" /> ou <paramref name="resultSelector" /> é <see langword="null" />.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/442d176d-028c-4beb-8d22-407d4ef89107">Operações join</related>
        <related type="Article" href="https://msdn.microsoft.com/library/76e9df84-092c-41a6-9537-c3f1cbd7f0fb">Cláusula join (Referência de C#)</related>
        <related type="Article" href="https://msdn.microsoft.com/library/37dbf79c-7b5c-421b-bbb7-dadfd2b92a1c">Cláusula Join Group (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="GroupJoin&lt;TOuter,TInner,TKey,TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;TResult&gt; GroupJoin&lt;TOuter,TInner,TKey,TResult&gt; (this System.Collections.Generic.IEnumerable&lt;TOuter&gt; outer, System.Collections.Generic.IEnumerable&lt;TInner&gt; inner, Func&lt;TOuter,TKey&gt; outerKeySelector, Func&lt;TInner,TKey&gt; innerKeySelector, Func&lt;TOuter,System.Collections.Generic.IEnumerable&lt;TInner&gt;,TResult&gt; resultSelector, System.Collections.Generic.IEqualityComparer&lt;TKey&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;!!TResult&gt; GroupJoin&lt;TOuter, TInner, TKey, TResult&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TOuter&gt; outer, class System.Collections.Generic.IEnumerable`1&lt;!!TInner&gt; inner, class System.Func`2&lt;!!TOuter, !!TKey&gt; outerKeySelector, class System.Func`2&lt;!!TInner, !!TKey&gt; innerKeySelector, class System.Func`3&lt;!!TOuter, class System.Collections.Generic.IEnumerable`1&lt;!!TInner&gt;, !!TResult&gt; resultSelector, class System.Collections.Generic.IEqualityComparer`1&lt;!!TKey&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.GroupJoin``4(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1},System.Func{``0,``2},System.Func{``1,``2},System.Func{``0,System.Collections.Generic.IEnumerable{``1},``3},System.Collections.Generic.IEqualityComparer{``2})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function GroupJoin(Of TOuter, TInner, TKey, TResult) (outer As IEnumerable(Of TOuter), inner As IEnumerable(Of TInner), outerKeySelector As Func(Of TOuter, TKey), innerKeySelector As Func(Of TInner, TKey), resultSelector As Func(Of TOuter, IEnumerable(Of TInner), TResult), comparer As IEqualityComparer(Of TKey)) As IEnumerable(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TOuter, typename TInner, typename TKey, typename TResult&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Collections::Generic::IEnumerable&lt;TResult&gt; ^ GroupJoin(System::Collections::Generic::IEnumerable&lt;TOuter&gt; ^ outer, System::Collections::Generic::IEnumerable&lt;TInner&gt; ^ inner, Func&lt;TOuter, TKey&gt; ^ outerKeySelector, Func&lt;TInner, TKey&gt; ^ innerKeySelector, Func&lt;TOuter, System::Collections::Generic::IEnumerable&lt;TInner&gt; ^, TResult&gt; ^ resultSelector, System::Collections::Generic::IEqualityComparer&lt;TKey&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="static member GroupJoin : seq&lt;'Outer&gt; * seq&lt;'Inner&gt; * Func&lt;'Outer, 'Key&gt; * Func&lt;'Inner, 'Key&gt; * Func&lt;'Outer, seq&lt;'Inner&gt;, 'Result&gt; * System.Collections.Generic.IEqualityComparer&lt;'Key&gt; -&gt; seq&lt;'Result&gt;" Usage="System.Linq.Enumerable.GroupJoin (outer, inner, outerKeySelector, innerKeySelector, resultSelector, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TOuter" />
        <TypeParameter Name="TInner" />
        <TypeParameter Name="TKey" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="outer" Type="System.Collections.Generic.IEnumerable&lt;TOuter&gt;" RefType="this" />
        <Parameter Name="inner" Type="System.Collections.Generic.IEnumerable&lt;TInner&gt;" />
        <Parameter Name="outerKeySelector" Type="System.Func&lt;TOuter,TKey&gt;" />
        <Parameter Name="innerKeySelector" Type="System.Func&lt;TInner,TKey&gt;" />
        <Parameter Name="resultSelector" Type="System.Func&lt;TOuter,System.Collections.Generic.IEnumerable&lt;TInner&gt;,TResult&gt;" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IEqualityComparer&lt;TKey&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TOuter">O tipo dos elementos da primeira sequência.</typeparam>
        <typeparam name="TInner">O tipo dos elementos da segunda sequência.</typeparam>
        <typeparam name="TKey">O tipo das chaves retornadas pelas funções de seletor de chave.</typeparam>
        <typeparam name="TResult">O tipo dos elementos de resultado.</typeparam>
        <param name="outer">A primeira sequência a ser ingressada.</param>
        <param name="inner">A sequência a ser ingressada à primeira sequência.</param>
        <param name="outerKeySelector">Uma função para extrair a chave de junção de cada elemento da primeira sequência.</param>
        <param name="innerKeySelector">Uma função para extrair a chave de junção de cada elemento da segunda sequência.</param>
        <param name="resultSelector">Uma função para criar um elemento de resultado de um elemento da primeira sequência e uma coleção de elementos correspondentes da segunda sequência.</param>
        <param name="comparer">Um <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> para executar hash e comparar chaves.</param>
        <summary>Correlaciona os elementos de duas sequências com base na igualdade de chaves e agrupa os resultados. Um <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> especificado é usado para comparar chaves.</summary>
        <returns>Um <see cref="T:System.Collections.Generic.IEnumerable`1" /> que contém elementos do tipo <paramref name="TResult" /> obtidos pela execução de uma junção agrupada em duas sequências.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método é implementado usando a execução adiada. O imediata valor retornado é um objeto que armazena todas as informações necessárias para executar a ação. A consulta representada por esse método não é executada até que o objeto é enumerado chamando-se suas `GetEnumerator` método diretamente ou usando `foreach` no Visual c# ou `For Each` no Visual Basic.  
  
 Se `comparer` está `null`, o comparador de igualdade padrão, <xref:System.Collections.Generic.EqualityComparer%601.Default%2A>, é usado para hash e comparar chaves.  
  
 <xref:System.Linq.Enumerable.GroupJoin%2A> produz resultados hierárquicos que significa que elementos de `outer` são emparelhados com coleções de elementos correspondentes da `inner`. `GroupJoin` permite que você baseie seus resultados em todo um conjunto de correspondências para cada elemento da `outer`.  
  
> [!NOTE]
>  Se não houver nenhum elemento correlacionado no `inner` para um determinado elemento de `outer`, a sequência de correspondências para esse elemento estará vazia, mas ainda aparecerá nos resultados.  
  
 O `resultSelector` função é chamada apenas uma vez para cada `outer` elemento junto com uma coleção de todos os `inner` elementos que correspondem a `outer` elemento. Isso difere de <xref:System.Linq.Enumerable.Join%2A> método no qual a função de seletor de resultado é invocada em pares que contêm um elemento de `outer` e um elemento de `inner`.  
  
 `GroupJoin` preserva a ordem dos elementos da `outer`e para cada elemento de `outer`, a ordem dos elementos correspondentes de `inner`.  
  
 <xref:System.Linq.Enumerable.GroupJoin%2A> tem equivalente direto em termos de banco de dados relacionais tradicionais. No entanto, esse método implementa um superconjunto de junções internas e junções externas esquerdas. Ambas essas operações podem ser gravadas em termos de uma junção agrupada. Ver [operações de junção](https://msdn.microsoft.com/library/442d176d-028c-4beb-8d22-407d4ef89107).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="outer" /> ou <paramref name="inner" /> ou <paramref name="outerKeySelector" /> ou <paramref name="innerKeySelector" /> ou <paramref name="resultSelector" /> é <see langword="null" />.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/442d176d-028c-4beb-8d22-407d4ef89107">Executando operações de junção</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Intersect&lt;TSource&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Produz a interseção de conjunto de duas sequências.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Intersect&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;TSource&gt; Intersect&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; first, System.Collections.Generic.IEnumerable&lt;TSource&gt; second);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; Intersect&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; first, class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; second) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Intersect``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Intersect(Of TSource) (first As IEnumerable(Of TSource), second As IEnumerable(Of TSource)) As IEnumerable(Of TSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ Intersect(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ first, System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ second);" />
      <MemberSignature Language="F#" Value="static member Intersect : seq&lt;'Source&gt; * seq&lt;'Source&gt; -&gt; seq&lt;'Source&gt;" Usage="System.Linq.Enumerable.Intersect (first, second)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="first" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="second" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">O tipo dos elementos das sequências de entrada.</typeparam>
        <param name="first">Um <see cref="T:System.Collections.Generic.IEnumerable`1" /> cujos elementos distintos que também aparecem em <paramref name="second" /> serão retornados.</param>
        <param name="second">Um <see cref="T:System.Collections.Generic.IEnumerable`1" /> cujos elementos distintos que também aparecem na primeira sequência serão retornados.</param>
        <summary>Produz a interseção de conjunto de duas sequências usando o comparador de igualdade padrão para comparar os valores.</summary>
        <returns>Uma sequência que contém os elementos que formam a interseção de conjunto de duas sequências.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método é implementado usando a execução adiada. O imediata valor retornado é um objeto que armazena todas as informações necessárias para executar a ação. A consulta representada por esse método não é executada até que o objeto é enumerado chamando-se suas `GetEnumerator` método diretamente ou usando `foreach` no Visual c# ou `For Each` no Visual Basic.  
  
 A interseção de dois conjuntos A e B é definida como o conjunto que contém todos os elementos de um que também aparecem em B, mas nenhum outro elemento.  
  
 Quando o objeto retornado por esse método é enumerado, <xref:System.Linq.Enumerable.Intersect%2A> produz elementos distintos que ocorrem em ambas as sequências na ordem em que aparecem na `first`.  
  
 O comparador de igualdade padrão, <xref:System.Collections.Generic.EqualityComparer%601.Default%2A>, é usado para comparar valores de tipos que implementam o <xref:System.Collections.Generic.IEqualityComparer%601> interface genérica. Para comparar um tipo de dados personalizado, você precisa implementar esta interface e fornecer seus próprios <xref:System.Object.GetHashCode%2A> e <xref:System.Object.Equals%2A> métodos para o tipo.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como usar <xref:System.Linq.Enumerable.Intersect%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%29> para retornar os elementos que aparecem em cada uma das duas sequências de inteiros.  
  
 [!code-csharp[System.Linq.Enumerable#41](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#41)]
 [!code-vb[System.Linq.Enumerable#41](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#41)]  
  
 Se você quiser comparar sequências de objetos de um tipo de dados personalizado, você precisa implementar o <xref:System.Collections.Generic.IEqualityComparer%601> interface genérica em uma classe auxiliar. O exemplo de código a seguir mostra como implementar essa interface em um tipo de dados personalizadas e fornecer <xref:System.Object.GetHashCode%2A> e <xref:System.Object.Equals%2A> métodos.  
  
 [!code-csharp[CSLINQEncapsulatedComparer#9](~/samples/snippets/csharp/VS_Snippets_VBCSharp/CsLINQEncapsulatedComparer/CS/EncapsulatedComparer.cs#9)]  
  
 Depois de implementar essa interface, você pode usar sequências de `ProductA` objetos no <xref:System.Linq.Enumerable.Intersect%2A> método, conforme mostrado no exemplo a seguir.  
  
 [!code-csharp[CSLINQEncapsulatedComparer#10](~/samples/snippets/csharp/VS_Snippets_VBCSharp/CsLINQEncapsulatedComparer/CS/EncapsulatedComparer.cs#10)]  
[!code-csharp[CSLINQEncapsulatedComparer#3](~/samples/snippets/csharp/VS_Snippets_VBCSharp/CsLINQEncapsulatedComparer/CS/EncapsulatedComparer.cs#3)]
[!code-vb[CSLINQEncapsulatedComparer#3](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/CsLINQEncapsulatedComparer/VB/EncapsulatedComparer.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="first" /> ou <paramref name="second" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Intersect&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;TSource&gt; Intersect&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; first, System.Collections.Generic.IEnumerable&lt;TSource&gt; second, System.Collections.Generic.IEqualityComparer&lt;TSource&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; Intersect&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; first, class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; second, class System.Collections.Generic.IEqualityComparer`1&lt;!!TSource&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Intersect``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEqualityComparer{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Intersect(Of TSource) (first As IEnumerable(Of TSource), second As IEnumerable(Of TSource), comparer As IEqualityComparer(Of TSource)) As IEnumerable(Of TSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ Intersect(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ first, System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ second, System::Collections::Generic::IEqualityComparer&lt;TSource&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="static member Intersect : seq&lt;'Source&gt; * seq&lt;'Source&gt; * System.Collections.Generic.IEqualityComparer&lt;'Source&gt; -&gt; seq&lt;'Source&gt;" Usage="System.Linq.Enumerable.Intersect (first, second, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="first" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="second" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IEqualityComparer&lt;TSource&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">O tipo dos elementos das sequências de entrada.</typeparam>
        <param name="first">Um <see cref="T:System.Collections.Generic.IEnumerable`1" /> cujos elementos distintos que também aparecem em <paramref name="second" /> serão retornados.</param>
        <param name="second">Um <see cref="T:System.Collections.Generic.IEnumerable`1" /> cujos elementos distintos que também aparecem na primeira sequência serão retornados.</param>
        <param name="comparer">Um <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> para comparar valores.</param>
        <summary>Produz a interseção de conjunto de duas sequências usando o <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> especificado para comparar os valores.</summary>
        <returns>Uma sequência que contém os elementos que formam a interseção de conjunto de duas sequências.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método é implementado usando a execução adiada. O imediata valor retornado é um objeto que armazena todas as informações necessárias para executar a ação. A consulta representada por esse método não é executada até que o objeto é enumerado chamando-se suas `GetEnumerator` método diretamente ou usando `foreach` no Visual c# ou `For Each` no Visual Basic.  
  
 A interseção de dois conjuntos A e B é definida como o conjunto que contém todos os elementos de um que também aparecem em B, mas nenhum outro elemento.  
  
 Quando o objeto retornado por esse método é enumerado, <xref:System.Linq.Enumerable.Intersect%2A> produz elementos distintos que ocorrem em ambas as sequências na ordem em que aparecem na `first`.  
  
 Se `comparer` está `null`, o comparador de igualdade padrão, <xref:System.Collections.Generic.EqualityComparer%601.Default%2A>, é usado para comparar valores.  
  
   
  
## Examples  
 O exemplo a seguir mostra como implementar um comparador de igualdade que pode ser usado no <xref:System.Linq.Enumerable.Intersect%2A> método.  
  
 [!code-csharp[CSLINQCustomComparer#1](~/samples/snippets/csharp/VS_Snippets_VBCSharp/CsLINQCustomComparer/CS/CustomComparer.cs#1)]
 [!code-vb[CSLINQCustomComparer#1](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/CsLINQCustomComparer/VB/CustomComparer.vb#1)]  
  
 Depois de implementar esse comparador, você pode usar sequências de `Product` objetos no <xref:System.Linq.Enumerable.Intersect%2A> método, conforme mostrado no exemplo a seguir.  
  
 [!code-csharp[CSLINQCustomComparer#2](~/samples/snippets/csharp/VS_Snippets_VBCSharp/CsLINQCustomComparer/CS/CustomComparer.cs#2)]
 [!code-vb[CSLINQCustomComparer#2](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/CsLINQCustomComparer/VB/CustomComparer.vb#2)]  
[!code-csharp[CSLINQCustomComparer#3](~/samples/snippets/csharp/VS_Snippets_VBCSharp/CsLINQCustomComparer/CS/CustomComparer.cs#3)]
[!code-vb[CSLINQCustomComparer#3](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/CsLINQCustomComparer/VB/CustomComparer.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="first" /> ou <paramref name="second" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Join&lt;TOuter,TInner,TKey,TResult&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Correlaciona os elementos de duas sequências com base em chaves de correspondência.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Join&lt;TOuter,TInner,TKey,TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;TResult&gt; Join&lt;TOuter,TInner,TKey,TResult&gt; (this System.Collections.Generic.IEnumerable&lt;TOuter&gt; outer, System.Collections.Generic.IEnumerable&lt;TInner&gt; inner, Func&lt;TOuter,TKey&gt; outerKeySelector, Func&lt;TInner,TKey&gt; innerKeySelector, Func&lt;TOuter,TInner,TResult&gt; resultSelector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;!!TResult&gt; Join&lt;TOuter, TInner, TKey, TResult&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TOuter&gt; outer, class System.Collections.Generic.IEnumerable`1&lt;!!TInner&gt; inner, class System.Func`2&lt;!!TOuter, !!TKey&gt; outerKeySelector, class System.Func`2&lt;!!TInner, !!TKey&gt; innerKeySelector, class System.Func`3&lt;!!TOuter, !!TInner, !!TResult&gt; resultSelector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Join``4(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1},System.Func{``0,``2},System.Func{``1,``2},System.Func{``0,``1,``3})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Join(Of TOuter, TInner, TKey, TResult) (outer As IEnumerable(Of TOuter), inner As IEnumerable(Of TInner), outerKeySelector As Func(Of TOuter, TKey), innerKeySelector As Func(Of TInner, TKey), resultSelector As Func(Of TOuter, TInner, TResult)) As IEnumerable(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TOuter, typename TInner, typename TKey, typename TResult&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Collections::Generic::IEnumerable&lt;TResult&gt; ^ Join(System::Collections::Generic::IEnumerable&lt;TOuter&gt; ^ outer, System::Collections::Generic::IEnumerable&lt;TInner&gt; ^ inner, Func&lt;TOuter, TKey&gt; ^ outerKeySelector, Func&lt;TInner, TKey&gt; ^ innerKeySelector, Func&lt;TOuter, TInner, TResult&gt; ^ resultSelector);" />
      <MemberSignature Language="F#" Value="static member Join : seq&lt;'Outer&gt; * seq&lt;'Inner&gt; * Func&lt;'Outer, 'Key&gt; * Func&lt;'Inner, 'Key&gt; * Func&lt;'Outer, 'Inner, 'Result&gt; -&gt; seq&lt;'Result&gt;" Usage="System.Linq.Enumerable.Join (outer, inner, outerKeySelector, innerKeySelector, resultSelector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TOuter" />
        <TypeParameter Name="TInner" />
        <TypeParameter Name="TKey" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="outer" Type="System.Collections.Generic.IEnumerable&lt;TOuter&gt;" RefType="this" />
        <Parameter Name="inner" Type="System.Collections.Generic.IEnumerable&lt;TInner&gt;" />
        <Parameter Name="outerKeySelector" Type="System.Func&lt;TOuter,TKey&gt;" />
        <Parameter Name="innerKeySelector" Type="System.Func&lt;TInner,TKey&gt;" />
        <Parameter Name="resultSelector" Type="System.Func&lt;TOuter,TInner,TResult&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TOuter">O tipo dos elementos da primeira sequência.</typeparam>
        <typeparam name="TInner">O tipo dos elementos da segunda sequência.</typeparam>
        <typeparam name="TKey">O tipo das chaves retornadas pelas funções de seletor de chave.</typeparam>
        <typeparam name="TResult">O tipo dos elementos de resultado.</typeparam>
        <param name="outer">A primeira sequência a ser ingressada.</param>
        <param name="inner">A sequência a ser ingressada à primeira sequência.</param>
        <param name="outerKeySelector">Uma função para extrair a chave de junção de cada elemento da primeira sequência.</param>
        <param name="innerKeySelector">Uma função para extrair a chave de junção de cada elemento da segunda sequência.</param>
        <param name="resultSelector">Uma função para criar um elemento de resultado de dois elementos correspondentes.</param>
        <summary>Correlaciona os elementos de duas sequências com base em chaves de correspondência. O comparador de igualdade padrão é usado para comparar chaves.</summary>
        <returns>Um <see cref="T:System.Collections.Generic.IEnumerable`1" /> com elementos do tipo <paramref name="TResult" /> obtidos pela execução de uma junção interna em duas sequências.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método é implementado usando a execução adiada. O imediata valor retornado é um objeto que armazena todas as informações necessárias para executar a ação. A consulta representada por esse método não é executada até que o objeto é enumerado chamando-se suas `GetEnumerator` método diretamente ou usando `foreach` no Visual c# ou `For Each` no Visual Basic.  
  
 O comparador de igualdade padrão, <xref:System.Collections.Generic.EqualityComparer%601.Default%2A>, é usado para hash e comparar chaves.  
  
 Uma associação refere-se à operação de correlacionar os elementos de duas fontes de informações com base em uma chave comum. <xref:System.Linq.Enumerable.Join%2A> traz as duas fontes de informações e as chaves pelo qual elas são correspondidas juntos em uma chamada de método. Isso é diferente do uso de `SelectMany`, que requer mais de uma chamada de método para executar a mesma operação.  
  
 <xref:System.Linq.Enumerable.Join%2A> preserva a ordem dos elementos da `outer`e para cada um desses elementos, a ordem dos elementos correspondentes da `inner`.  
  
 Na sintaxe de expressão de consulta, uma `join` (Visual c#) ou `Join` cláusula (Visual Basic) se traduz em uma invocação de <xref:System.Linq.Enumerable.Join%2A>.  
  
 Em termos de banco de dados relacional, o <xref:System.Linq.Enumerable.Join%2A> método implementa uma junção por igualdade interna. 'Interna' significa que apenas os elementos que têm uma correspondência na outra sequência são incluídos nos resultados. Um ' equijoin' é uma junção na qual as chaves são comparadas quanto à igualdade. A esquerda da operação de junção externa, que tem nenhum operador de consulta padrão dedicado, mas pode ser executada usando o <xref:System.Linq.Enumerable.GroupJoin%2A> método. Ver [operações de junção](https://msdn.microsoft.com/library/442d176d-028c-4beb-8d22-407d4ef89107).  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como usar <xref:System.Linq.Enumerable.Join%60%604%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Collections.Generic.IEnumerable%7B%60%601%7D%2CSystem.Func%7B%60%600%2C%60%602%7D%2CSystem.Func%7B%60%601%2C%60%602%7D%2CSystem.Func%7B%60%600%2C%60%601%2C%60%603%7D%29> para realizar uma junção interna de duas sequências com base em uma chave comum.  
  
 [!code-csharp[System.Linq.Enumerable#42](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#42)]
 [!code-vb[System.Linq.Enumerable#42](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="outer" /> ou <paramref name="inner" /> ou <paramref name="outerKeySelector" /> ou <paramref name="innerKeySelector" /> ou <paramref name="resultSelector" /> é <see langword="null" />.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/442d176d-028c-4beb-8d22-407d4ef89107">Ingressando</related>
        <related type="Article" href="https://msdn.microsoft.com/library/76e9df84-092c-41a6-9537-c3f1cbd7f0fb">Cláusula join (Referência de C#)</related>
        <related type="Article" href="https://msdn.microsoft.com/library/6dd37936-b27c-4e00-98ad-154b23f4de64">Cláusula Join (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Join&lt;TOuter,TInner,TKey,TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;TResult&gt; Join&lt;TOuter,TInner,TKey,TResult&gt; (this System.Collections.Generic.IEnumerable&lt;TOuter&gt; outer, System.Collections.Generic.IEnumerable&lt;TInner&gt; inner, Func&lt;TOuter,TKey&gt; outerKeySelector, Func&lt;TInner,TKey&gt; innerKeySelector, Func&lt;TOuter,TInner,TResult&gt; resultSelector, System.Collections.Generic.IEqualityComparer&lt;TKey&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;!!TResult&gt; Join&lt;TOuter, TInner, TKey, TResult&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TOuter&gt; outer, class System.Collections.Generic.IEnumerable`1&lt;!!TInner&gt; inner, class System.Func`2&lt;!!TOuter, !!TKey&gt; outerKeySelector, class System.Func`2&lt;!!TInner, !!TKey&gt; innerKeySelector, class System.Func`3&lt;!!TOuter, !!TInner, !!TResult&gt; resultSelector, class System.Collections.Generic.IEqualityComparer`1&lt;!!TKey&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Join``4(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1},System.Func{``0,``2},System.Func{``1,``2},System.Func{``0,``1,``3},System.Collections.Generic.IEqualityComparer{``2})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Join(Of TOuter, TInner, TKey, TResult) (outer As IEnumerable(Of TOuter), inner As IEnumerable(Of TInner), outerKeySelector As Func(Of TOuter, TKey), innerKeySelector As Func(Of TInner, TKey), resultSelector As Func(Of TOuter, TInner, TResult), comparer As IEqualityComparer(Of TKey)) As IEnumerable(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TOuter, typename TInner, typename TKey, typename TResult&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Collections::Generic::IEnumerable&lt;TResult&gt; ^ Join(System::Collections::Generic::IEnumerable&lt;TOuter&gt; ^ outer, System::Collections::Generic::IEnumerable&lt;TInner&gt; ^ inner, Func&lt;TOuter, TKey&gt; ^ outerKeySelector, Func&lt;TInner, TKey&gt; ^ innerKeySelector, Func&lt;TOuter, TInner, TResult&gt; ^ resultSelector, System::Collections::Generic::IEqualityComparer&lt;TKey&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="static member Join : seq&lt;'Outer&gt; * seq&lt;'Inner&gt; * Func&lt;'Outer, 'Key&gt; * Func&lt;'Inner, 'Key&gt; * Func&lt;'Outer, 'Inner, 'Result&gt; * System.Collections.Generic.IEqualityComparer&lt;'Key&gt; -&gt; seq&lt;'Result&gt;" Usage="System.Linq.Enumerable.Join (outer, inner, outerKeySelector, innerKeySelector, resultSelector, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TOuter" />
        <TypeParameter Name="TInner" />
        <TypeParameter Name="TKey" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="outer" Type="System.Collections.Generic.IEnumerable&lt;TOuter&gt;" RefType="this" />
        <Parameter Name="inner" Type="System.Collections.Generic.IEnumerable&lt;TInner&gt;" />
        <Parameter Name="outerKeySelector" Type="System.Func&lt;TOuter,TKey&gt;" />
        <Parameter Name="innerKeySelector" Type="System.Func&lt;TInner,TKey&gt;" />
        <Parameter Name="resultSelector" Type="System.Func&lt;TOuter,TInner,TResult&gt;" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IEqualityComparer&lt;TKey&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TOuter">O tipo dos elementos da primeira sequência.</typeparam>
        <typeparam name="TInner">O tipo dos elementos da segunda sequência.</typeparam>
        <typeparam name="TKey">O tipo das chaves retornadas pelas funções de seletor de chave.</typeparam>
        <typeparam name="TResult">O tipo dos elementos de resultado.</typeparam>
        <param name="outer">A primeira sequência a ser ingressada.</param>
        <param name="inner">A sequência a ser ingressada à primeira sequência.</param>
        <param name="outerKeySelector">Uma função para extrair a chave de junção de cada elemento da primeira sequência.</param>
        <param name="innerKeySelector">Uma função para extrair a chave de junção de cada elemento da segunda sequência.</param>
        <param name="resultSelector">Uma função para criar um elemento de resultado de dois elementos correspondentes.</param>
        <param name="comparer">Um <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> para executar hash e comparar chaves.</param>
        <summary>Correlaciona os elementos de duas sequências com base em chaves de correspondência. Um <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> especificado é usado para comparar chaves.</summary>
        <returns>Um <see cref="T:System.Collections.Generic.IEnumerable`1" /> com elementos do tipo <paramref name="TResult" /> obtidos pela execução de uma junção interna em duas sequências.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método é implementado usando a execução adiada. O imediata valor retornado é um objeto que armazena todas as informações necessárias para executar a ação. A consulta representada por esse método não é executada até que o objeto é enumerado chamando-se suas `GetEnumerator` método diretamente ou usando `foreach` no Visual c# ou `For Each` no Visual Basic.  
  
 Se `comparer` está `null`, o comparador de igualdade padrão, <xref:System.Collections.Generic.EqualityComparer%601.Default%2A>, é usado para hash e comparar chaves.  
  
 Uma associação refere-se à operação de correlacionar os elementos de duas fontes de informações com base em uma chave comum. <xref:System.Linq.Enumerable.Join%2A> traz as duas fontes de informações e as chaves pelo qual elas são correspondidas juntos em uma chamada de método. Isso é diferente do uso de `SelectMany`, que requer mais de uma chamada de método para executar a mesma operação.  
  
 <xref:System.Linq.Enumerable.Join%2A> preserva a ordem dos elementos da `outer`e para cada um desses elementos, a ordem dos elementos correspondentes da `inner`.  
  
 Em termos de banco de dados relacional, o <xref:System.Linq.Enumerable.Join%2A> método implementa uma junção por igualdade interna. 'Interna' significa que apenas os elementos que têm uma correspondência na outra sequência são incluídos nos resultados. Um ' equijoin' é uma junção na qual as chaves são comparadas quanto à igualdade. A esquerda da operação de junção externa, que tem nenhum operador de consulta padrão dedicado, mas pode ser executada usando o <xref:System.Linq.Enumerable.GroupJoin%2A> método. Ver [operações de junção](https://msdn.microsoft.com/library/442d176d-028c-4beb-8d22-407d4ef89107).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="outer" /> ou <paramref name="inner" /> ou <paramref name="outerKeySelector" /> ou <paramref name="innerKeySelector" /> ou <paramref name="resultSelector" /> é <see langword="null" />.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/442d176d-028c-4beb-8d22-407d4ef89107">Ingressando</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Last&lt;TSource&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Retorna o último elemento de uma sequência.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Last&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static TSource Last&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TSource Last&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Last``1(System.Collections.Generic.IEnumerable{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Last(Of TSource) (source As IEnumerable(Of TSource)) As TSource" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static TSource Last(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Last : seq&lt;'Source&gt; -&gt; 'Source" Usage="System.Linq.Enumerable.Last source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TSource</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">O tipo dos elementos de <paramref name="source" />.</typeparam>
        <param name="source">Um <see cref="T:System.Collections.Generic.IEnumerable`1" /> do qual o último elemento será retornado.</param>
        <summary>Retorna o último elemento de uma sequência.</summary>
        <returns>O valor na última posição na sequência de origem.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Linq.Enumerable.Last%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%29> método lança uma exceção se `source` não contiver elementos. Para retornar em vez disso, um valor padrão quando a sequência de origem estiver vazia, use o <xref:System.Linq.Enumerable.LastOrDefault%2A> método.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como usar <xref:System.Linq.Enumerable.Last%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%29> para retornar o último elemento de uma matriz.  
  
 [!code-csharp[System.Linq.Enumerable#43](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#43)]
 [!code-vb[System.Linq.Enumerable#43](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#43)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> é <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Uma sequência de origem está vazia.</exception>
      </Docs>
    </Member>
    <Member MemberName="Last&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static TSource Last&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,bool&gt; predicate);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TSource Last&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, bool&gt; predicate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Last``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Boolean})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Last(Of TSource) (source As IEnumerable(Of TSource), predicate As Func(Of TSource, Boolean)) As TSource" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static TSource Last(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Func&lt;TSource, bool&gt; ^ predicate);" />
      <MemberSignature Language="F#" Value="static member Last : seq&lt;'Source&gt; * Func&lt;'Source, bool&gt; -&gt; 'Source" Usage="System.Linq.Enumerable.Last (source, predicate)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TSource</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="predicate" Type="System.Func&lt;TSource,System.Boolean&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">O tipo dos elementos de <paramref name="source" />.</typeparam>
        <param name="source">Um <see cref="T:System.Collections.Generic.IEnumerable`1" /> do qual um elemento será retornado.</param>
        <param name="predicate">Uma função para testar cada elemento em relação a uma condição.</param>
        <summary>Retorna o último elemento de uma sequência que satisfaz uma condição especificada.</summary>
        <returns>O último elemento na sequência que passa o teste na função de predicado especificada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Linq.Enumerable.Last%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Boolean%7D%29> método gera uma exceção se nenhum elemento correspondente for encontrado no `source`. Para retornar em vez disso, um valor padrão quando nenhum elemento correspondente for encontrado, use o <xref:System.Linq.Enumerable.LastOrDefault%2A> método.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como usar <xref:System.Linq.Enumerable.Last%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Boolean%7D%29> para retornar o último elemento de uma matriz que satisfaz uma condição.  
  
 [!code-csharp[System.Linq.Enumerable#44](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#44)]
 [!code-vb[System.Linq.Enumerable#44](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#44)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> ou <paramref name="predicate" /> é <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Nenhum elemento satisfaz a condição na <paramref name="predicate" />.  
  
- ou - 
Uma sequência de origem está vazia.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="LastOrDefault&lt;TSource&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Retornará o último elemento de uma sequência ou um valor padrão se nenhum elemento for encontrado.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="LastOrDefault&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static TSource LastOrDefault&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TSource LastOrDefault&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.LastOrDefault``1(System.Collections.Generic.IEnumerable{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function LastOrDefault(Of TSource) (source As IEnumerable(Of TSource)) As TSource" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static TSource LastOrDefault(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member LastOrDefault : seq&lt;'Source&gt; -&gt; 'Source" Usage="System.Linq.Enumerable.LastOrDefault source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TSource</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">O tipo dos elementos de <paramref name="source" />.</typeparam>
        <param name="source">Um <see cref="T:System.Collections.Generic.IEnumerable`1" /> do qual o último elemento será retornado.</param>
        <summary>Retorna o último elemento de uma sequência ou um valor padrão se a sequência não contém elementos.</summary>
        <returns><see langword="default" />(<paramref name="TSource" />) se a sequência de origem estiver vazia; caso contrário, o último elemento no <see cref="T:System.Collections.Generic.IEnumerable`1" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O valor padrão para referência e tipos que permitem valor nulos é `null`.  
  
 O <xref:System.Linq.Enumerable.LastOrDefault%2A> método não fornece uma maneira de especificar um valor padrão. Se você quiser especificar um valor padrão diferente de `default(TSource)`, use o <xref:System.Linq.Enumerable.DefaultIfEmpty%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2C%60%600%29> método conforme descrito na seção de exemplo.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como usar <xref:System.Linq.Enumerable.LastOrDefault%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%29> em uma matriz vazia.  
  
 [!code-csharp[System.Linq.Enumerable#45](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#45)]
 [!code-vb[System.Linq.Enumerable#45](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#45)]  
  
 Às vezes, o valor de `default(TSource)` não é o valor padrão que você deseja usar se a coleção não contiver elementos. Em vez de verificar o resultado para o valor padrão indesejado e, em seguida, alterando-se necessário, você pode usar o <xref:System.Linq.Enumerable.DefaultIfEmpty%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2C%60%600%29> método para especificar o valor padrão que você deseja usar, se a coleção está vazia. Em seguida, chame <xref:System.Linq.Enumerable.Last%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%29> para obter o último elemento. O exemplo de código a seguir usa ambas as técnicas para obter um valor padrão de 1, se uma coleção de numéricos dias do mês está vazia. Como o valor padrão para um número inteiro é 0, o que não corresponde a qualquer dia do mês, o valor padrão deve ser especificado como 1 em vez disso. A primeira variável de resultado é verificada para o valor padrão indesejados após a conclusão da consulta em execução. A segunda variável de resultado é obtida usando <xref:System.Linq.Enumerable.DefaultIfEmpty%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2C%60%600%29> para especificar um valor padrão de 1.  
  
 [!code-csharp[System.Linq.Enumerable#127](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#127)]
 [!code-vb[System.Linq.Enumerable#127](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#127)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="LastOrDefault&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static TSource LastOrDefault&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,bool&gt; predicate);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TSource LastOrDefault&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, bool&gt; predicate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.LastOrDefault``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Boolean})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function LastOrDefault(Of TSource) (source As IEnumerable(Of TSource), predicate As Func(Of TSource, Boolean)) As TSource" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static TSource LastOrDefault(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Func&lt;TSource, bool&gt; ^ predicate);" />
      <MemberSignature Language="F#" Value="static member LastOrDefault : seq&lt;'Source&gt; * Func&lt;'Source, bool&gt; -&gt; 'Source" Usage="System.Linq.Enumerable.LastOrDefault (source, predicate)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TSource</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="predicate" Type="System.Func&lt;TSource,System.Boolean&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">O tipo dos elementos de <paramref name="source" />.</typeparam>
        <param name="source">Um <see cref="T:System.Collections.Generic.IEnumerable`1" /> do qual um elemento será retornado.</param>
        <param name="predicate">Uma função para testar cada elemento em relação a uma condição.</param>
        <summary>Retorna o último elemento de uma sequência que satisfaz uma condição ou um valor padrão, caso esse elemento não seja encontrado.</summary>
        <returns><see langword="default" />(<paramref name="TSource" />) se a sequência for vazia ou se nenhum elemento passar no teste na função de predicado; caso contrário, o último elemento que passar no teste na função de predicado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O valor padrão para referência e tipos que permitem valor nulos é `null`.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como usar <xref:System.Linq.Enumerable.LastOrDefault%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Boolean%7D%29> , passando um predicado. A segunda chamada para o método, há nenhum elemento na sequência que satisfaz a condição.  
  
 [!code-csharp[System.Linq.Enumerable#46](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#46)]
 [!code-vb[System.Linq.Enumerable#46](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#46)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> ou <paramref name="predicate" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="LongCount&lt;TSource&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Retorna um <see cref="T:System.Int64" /> que representa o número de elementos em uma sequência.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="LongCount&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static long LongCount&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 LongCount&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.LongCount``1(System.Collections.Generic.IEnumerable{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function LongCount(Of TSource) (source As IEnumerable(Of TSource)) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static long LongCount(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member LongCount : seq&lt;'Source&gt; -&gt; int64" Usage="System.Linq.Enumerable.LongCount source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">O tipo dos elementos de <paramref name="source" />.</typeparam>
        <param name="source">Um <see cref="T:System.Collections.Generic.IEnumerable`1" /> que contém os elementos a serem contados.</param>
        <summary>Retorna um <see cref="T:System.Int64" /> que representa o número total de elementos em uma sequência.</summary>
        <returns>O número de elementos na sequência de origem.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use esse método em vez de <xref:System.Linq.Enumerable.Count%2A> quando você espera que o resultado seja maior do que <xref:System.Int32.MaxValue>.  
  
 Na sintaxe de expressão de consulta do Visual Basic, uma `Aggregate Into LongCount()` cláusula se traduz em uma invocação de <xref:System.Linq.Enumerable.LongCount%2A>.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como usar <xref:System.Linq.Enumerable.LongCount%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%29> para contar os elementos em uma matriz.  
  
 [!code-csharp[System.Linq.Enumerable#47](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#47)]
 [!code-vb[System.Linq.Enumerable#47](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#47)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> é <see langword="null" />.</exception>
        <exception cref="T:System.OverflowException">O número de elementos excede <see cref="F:System.Int64.MaxValue" />.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/1315a814-5db6-4077-b34b-b141e11cc0eb">Cláusula Aggregate (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="LongCount&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static long LongCount&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,bool&gt; predicate);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 LongCount&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, bool&gt; predicate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.LongCount``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Boolean})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function LongCount(Of TSource) (source As IEnumerable(Of TSource), predicate As Func(Of TSource, Boolean)) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static long LongCount(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Func&lt;TSource, bool&gt; ^ predicate);" />
      <MemberSignature Language="F#" Value="static member LongCount : seq&lt;'Source&gt; * Func&lt;'Source, bool&gt; -&gt; int64" Usage="System.Linq.Enumerable.LongCount (source, predicate)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="predicate" Type="System.Func&lt;TSource,System.Boolean&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">O tipo dos elementos de <paramref name="source" />.</typeparam>
        <param name="source">Um <see cref="T:System.Collections.Generic.IEnumerable`1" /> que contém os elementos a serem contados.</param>
        <param name="predicate">Uma função para testar cada elemento em relação a uma condição.</param>
        <summary>Retorna um <see cref="T:System.Int64" /> que representa quantos elementos na sequência atendem a uma condição.</summary>
        <returns>Um número que representa quantos elementos na sequência atendem à condição na função de predicado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use esse método em vez de <xref:System.Linq.Enumerable.Count%2A> quando você espera que o resultado seja maior do que <xref:System.Int32.MaxValue>.  
  
 Na sintaxe de expressão de consulta do Visual Basic, uma `Aggregate Into LongCount()` cláusula se traduz em uma invocação de <xref:System.Linq.Enumerable.LongCount%2A>.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como usar <xref:System.Linq.Enumerable.LongCount%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Boolean%7D%29> para contar os elementos em uma matriz que satisfazem uma condição.  
  
 [!code-csharp[System.Linq.Enumerable#48](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#48)]
 [!code-vb[System.Linq.Enumerable#48](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#48)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> ou <paramref name="predicate" /> é <see langword="null" />.</exception>
        <exception cref="T:System.OverflowException">O número de elementos correspondentes excede <see cref="F:System.Int64.MaxValue" />.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/1315a814-5db6-4077-b34b-b141e11cc0eb">Cláusula Aggregate (Visual Basic)</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Max">
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Retorna o valor máximo em uma sequência de valores.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Max">
      <MemberSignature Language="C#" Value="public static decimal Max (this System.Collections.Generic.IEnumerable&lt;decimal&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Decimal Max(class System.Collections.Generic.IEnumerable`1&lt;valuetype System.Decimal&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Max(System.Collections.Generic.IEnumerable{System.Decimal})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Max (source As IEnumerable(Of Decimal)) As Decimal" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Decimal Max(System::Collections::Generic::IEnumerable&lt;System::Decimal&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Max : seq&lt;decimal&gt; -&gt; decimal" Usage="System.Linq.Enumerable.Max source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;System.Decimal&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Uma sequência de valores <see cref="T:System.Decimal" /> da qual será determinado o valor máximo.</param>
        <summary>Retorna o valor máximo em uma sequência de valores <see cref="T:System.Decimal" />.</summary>
        <returns>O valor máximo na sequência.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Linq.Enumerable.Max%28System.Collections.Generic.IEnumerable%7BSystem.Decimal%7D%29> usa o <xref:System.Decimal> implementação de <xref:System.IComparable%601> para comparar valores.  
  
 Na sintaxe de expressão de consulta do Visual Basic, uma `Aggregate Into Max()` cláusula se traduz em uma invocação de <xref:System.Linq.Enumerable.Max%2A>.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como usar <xref:System.Linq.Enumerable.Max%28System.Collections.Generic.IEnumerable%7BSystem.Int64%7D%29> para determinar o valor máximo em uma sequência.  
  
 [!INCLUDE[sqo_diff_overload_example_elementtype](~/includes/sqo-diff-overload-example-elementtype-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#52](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#52)]
 [!code-vb[System.Linq.Enumerable#52](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#52)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> é <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="source" /> não contém elementos.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/1315a814-5db6-4077-b34b-b141e11cc0eb">Cláusula Aggregate (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Max">
      <MemberSignature Language="C#" Value="public static double Max (this System.Collections.Generic.IEnumerable&lt;double&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Max(class System.Collections.Generic.IEnumerable`1&lt;float64&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Max(System.Collections.Generic.IEnumerable{System.Double})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Max (source As IEnumerable(Of Double)) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static double Max(System::Collections::Generic::IEnumerable&lt;double&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Max : seq&lt;double&gt; -&gt; double" Usage="System.Linq.Enumerable.Max source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;System.Double&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Uma sequência de valores <see cref="T:System.Double" /> da qual será determinado o valor máximo.</param>
        <summary>Retorna o valor máximo em uma sequência de valores <see cref="T:System.Double" />.</summary>
        <returns>O valor máximo na sequência.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Linq.Enumerable.Max%28System.Collections.Generic.IEnumerable%7BSystem.Double%7D%29> usa o <xref:System.Double> implementação de <xref:System.IComparable%601> para comparar valores.  
  
 Na sintaxe de expressão de consulta do Visual Basic, uma `Aggregate Into Max()` cláusula se traduz em uma invocação de <xref:System.Linq.Enumerable.Max%2A>.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como usar <xref:System.Linq.Enumerable.Max%28System.Collections.Generic.IEnumerable%7BSystem.Int64%7D%29> para determinar o valor máximo em uma sequência.  
  
 [!INCLUDE[sqo_diff_overload_example_elementtype](~/includes/sqo-diff-overload-example-elementtype-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#52](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#52)]
 [!code-vb[System.Linq.Enumerable#52](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#52)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> é <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="source" /> não contém elementos.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/1315a814-5db6-4077-b34b-b141e11cc0eb">Cláusula Aggregate (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Max">
      <MemberSignature Language="C#" Value="public static int Max (this System.Collections.Generic.IEnumerable&lt;int&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Max(class System.Collections.Generic.IEnumerable`1&lt;int32&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Max(System.Collections.Generic.IEnumerable{System.Int32})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Max (source As IEnumerable(Of Integer)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static int Max(System::Collections::Generic::IEnumerable&lt;int&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Max : seq&lt;int&gt; -&gt; int" Usage="System.Linq.Enumerable.Max source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;System.Int32&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Uma sequência de valores <see cref="T:System.Int32" /> da qual será determinado o valor máximo.</param>
        <summary>Retorna o valor máximo em uma sequência de valores <see cref="T:System.Int32" />.</summary>
        <returns>O valor máximo na sequência.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Linq.Enumerable.Max%28System.Collections.Generic.IEnumerable%7BSystem.Int32%7D%29> usa o <xref:System.Int32> implementação de <xref:System.IComparable%601> para comparar valores.  
  
 Na sintaxe de expressão de consulta do Visual Basic, uma `Aggregate Into Max()` cláusula se traduz em uma invocação de <xref:System.Linq.Enumerable.Max%2A>.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como usar <xref:System.Linq.Enumerable.Max%28System.Collections.Generic.IEnumerable%7BSystem.Int64%7D%29> para determinar o valor máximo em uma sequência.  
  
 [!INCLUDE[sqo_diff_overload_example_elementtype](~/includes/sqo-diff-overload-example-elementtype-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#52](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#52)]
 [!code-vb[System.Linq.Enumerable#52](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#52)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> é <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="source" /> não contém elementos.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/1315a814-5db6-4077-b34b-b141e11cc0eb">Cláusula Aggregate (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Max">
      <MemberSignature Language="C#" Value="public static long Max (this System.Collections.Generic.IEnumerable&lt;long&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 Max(class System.Collections.Generic.IEnumerable`1&lt;int64&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Max(System.Collections.Generic.IEnumerable{System.Int64})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Max (source As IEnumerable(Of Long)) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static long Max(System::Collections::Generic::IEnumerable&lt;long&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Max : seq&lt;int64&gt; -&gt; int64" Usage="System.Linq.Enumerable.Max source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;System.Int64&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Uma sequência de valores <see cref="T:System.Int64" /> da qual será determinado o valor máximo.</param>
        <summary>Retorna o valor máximo em uma sequência de valores <see cref="T:System.Int64" />.</summary>
        <returns>O valor máximo na sequência.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Linq.Enumerable.Max%28System.Collections.Generic.IEnumerable%7BSystem.Int64%7D%29> usa o <xref:System.Int64> implementação de <xref:System.IComparable%601> para comparar valores.  
  
 Na sintaxe de expressão de consulta do Visual Basic, uma `Aggregate Into Max()` cláusula se traduz em uma invocação de <xref:System.Linq.Enumerable.Max%2A>.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como usar <xref:System.Linq.Enumerable.Max%28System.Collections.Generic.IEnumerable%7BSystem.Int64%7D%29> para determinar o valor máximo em uma sequência.  
  
 [!code-csharp[System.Linq.Enumerable#52](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#52)]
 [!code-vb[System.Linq.Enumerable#52](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#52)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> é <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="source" /> não contém elementos.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/1315a814-5db6-4077-b34b-b141e11cc0eb">Cláusula Aggregate (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Max">
      <MemberSignature Language="C#" Value="public static Nullable&lt;decimal&gt; Max (this System.Collections.Generic.IEnumerable&lt;Nullable&lt;decimal&gt;&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;valuetype System.Decimal&gt; Max(class System.Collections.Generic.IEnumerable`1&lt;valuetype System.Nullable`1&lt;valuetype System.Decimal&gt;&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Max(System.Collections.Generic.IEnumerable{System.Nullable{System.Decimal}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Max (source As IEnumerable(Of Nullable(Of Decimal))) As Nullable(Of Decimal)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Nullable&lt;System::Decimal&gt; Max(System::Collections::Generic::IEnumerable&lt;Nullable&lt;System::Decimal&gt;&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Max : seq&lt;Nullable&lt;decimal&gt;&gt; -&gt; Nullable&lt;decimal&gt;" Usage="System.Linq.Enumerable.Max source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Decimal&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;System.Nullable&lt;System.Decimal&gt;&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Uma sequência de valores <see cref="T:System.Decimal" /> anuláveis para determinar o valor máximo.</param>
        <summary>Retorna o valor máximo em uma sequência de valores <see cref="T:System.Decimal" /> anuláveis.</summary>
        <returns>Um valor do tipo <c>Nullable&lt;Decimal&gt;</c> em C# ou <c>Nullable(Of Decimal)</c> no Visual Basic que corresponde ao valor máximo na sequência.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Linq.Enumerable.Max%28System.Collections.Generic.IEnumerable%7BSystem.Nullable%7BSystem.Decimal%7D%7D%29> usa o <xref:System.Decimal> implementação de <xref:System.IComparable%601> para comparar valores.  
  
 Se a sequência de origem estiver vazia ou contiver somente valores que são `null`, essa função retorna `null`.  
  
 Na sintaxe de expressão de consulta do Visual Basic, uma `Aggregate Into Max()` cláusula se traduz em uma invocação de <xref:System.Linq.Enumerable.Max%2A>.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como usar <xref:System.Linq.Enumerable.Max%28System.Collections.Generic.IEnumerable%7BSystem.Nullable%7BSystem.Double%7D%7D%29> para determinar o valor máximo em uma sequência.  
  
 [!INCLUDE[sqo_diff_overload_example_elementtype](~/includes/sqo-diff-overload-example-elementtype-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#54](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#54)]
 [!code-vb[System.Linq.Enumerable#54](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#54)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> é <see langword="null" />.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/1315a814-5db6-4077-b34b-b141e11cc0eb">Cláusula Aggregate (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Max">
      <MemberSignature Language="C#" Value="public static Nullable&lt;double&gt; Max (this System.Collections.Generic.IEnumerable&lt;Nullable&lt;double&gt;&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;float64&gt; Max(class System.Collections.Generic.IEnumerable`1&lt;valuetype System.Nullable`1&lt;float64&gt;&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Max(System.Collections.Generic.IEnumerable{System.Nullable{System.Double}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Max (source As IEnumerable(Of Nullable(Of Double))) As Nullable(Of Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Nullable&lt;double&gt; Max(System::Collections::Generic::IEnumerable&lt;Nullable&lt;double&gt;&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Max : seq&lt;Nullable&lt;double&gt;&gt; -&gt; Nullable&lt;double&gt;" Usage="System.Linq.Enumerable.Max source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Double&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;System.Nullable&lt;System.Double&gt;&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Uma sequência de valores <see cref="T:System.Double" /> anuláveis para determinar o valor máximo.</param>
        <summary>Retorna o valor máximo em uma sequência de valores <see cref="T:System.Double" /> anuláveis.</summary>
        <returns>Um valor do tipo <c>Nullable&lt;Double&gt;</c> em C# ou <c>Nullable(Of Double)</c> no Visual Basic que corresponde ao valor máximo na sequência.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Linq.Enumerable.Max%28System.Collections.Generic.IEnumerable%7BSystem.Nullable%7BSystem.Double%7D%7D%29> usa o <xref:System.Double> implementação de <xref:System.IComparable%601> para comparar valores.  
  
 Se a sequência de origem estiver vazia ou contiver somente valores que são `null`, essa função retorna `null`.  
  
 Na sintaxe de expressão de consulta do Visual Basic, uma `Aggregate Into Max()` cláusula se traduz em uma invocação de <xref:System.Linq.Enumerable.Max%2A>.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como usar <xref:System.Linq.Enumerable.Max%28System.Collections.Generic.IEnumerable%7BSystem.Nullable%7BSystem.Double%7D%7D%29> para determinar o valor máximo em uma sequência.  
  
 [!code-csharp[System.Linq.Enumerable#54](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#54)]
 [!code-vb[System.Linq.Enumerable#54](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#54)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> é <see langword="null" />.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/1315a814-5db6-4077-b34b-b141e11cc0eb">Cláusula Aggregate (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Max">
      <MemberSignature Language="C#" Value="public static Nullable&lt;int&gt; Max (this System.Collections.Generic.IEnumerable&lt;Nullable&lt;int&gt;&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;int32&gt; Max(class System.Collections.Generic.IEnumerable`1&lt;valuetype System.Nullable`1&lt;int32&gt;&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Max(System.Collections.Generic.IEnumerable{System.Nullable{System.Int32}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Max (source As IEnumerable(Of Nullable(Of Integer))) As Nullable(Of Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Nullable&lt;int&gt; Max(System::Collections::Generic::IEnumerable&lt;Nullable&lt;int&gt;&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Max : seq&lt;Nullable&lt;int&gt;&gt; -&gt; Nullable&lt;int&gt;" Usage="System.Linq.Enumerable.Max source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;System.Nullable&lt;System.Int32&gt;&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Uma sequência de valores <see cref="T:System.Int32" /> anuláveis para determinar o valor máximo.</param>
        <summary>Retorna o valor máximo em uma sequência de valores <see cref="T:System.Int32" /> anuláveis.</summary>
        <returns>Um valor do tipo <c>Nullable&lt;Int32&gt;</c> em C# ou <c>Nullable(Of Int32)</c> no Visual Basic que corresponde ao valor máximo na sequência.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Linq.Enumerable.Max%28System.Collections.Generic.IEnumerable%7BSystem.Nullable%7BSystem.Int32%7D%7D%29> usa o <xref:System.Int32> implementação de <xref:System.IComparable%601> para comparar valores.  
  
 Se a sequência de origem estiver vazia ou contiver somente valores que são `null`, essa função retorna `null`.  
  
 Na sintaxe de expressão de consulta do Visual Basic, uma `Aggregate Into Max()` cláusula se traduz em uma invocação de <xref:System.Linq.Enumerable.Max%2A>.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como usar <xref:System.Linq.Enumerable.Max%28System.Collections.Generic.IEnumerable%7BSystem.Nullable%7BSystem.Double%7D%7D%29> para determinar o valor máximo em uma sequência.  
  
 [!INCLUDE[sqo_diff_overload_example_elementtype](~/includes/sqo-diff-overload-example-elementtype-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#54](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#54)]
 [!code-vb[System.Linq.Enumerable#54](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#54)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> é <see langword="null" />.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/1315a814-5db6-4077-b34b-b141e11cc0eb">Cláusula Aggregate (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Max">
      <MemberSignature Language="C#" Value="public static Nullable&lt;long&gt; Max (this System.Collections.Generic.IEnumerable&lt;Nullable&lt;long&gt;&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;int64&gt; Max(class System.Collections.Generic.IEnumerable`1&lt;valuetype System.Nullable`1&lt;int64&gt;&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Max(System.Collections.Generic.IEnumerable{System.Nullable{System.Int64}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Max (source As IEnumerable(Of Nullable(Of Long))) As Nullable(Of Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Nullable&lt;long&gt; Max(System::Collections::Generic::IEnumerable&lt;Nullable&lt;long&gt;&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Max : seq&lt;Nullable&lt;int64&gt;&gt; -&gt; Nullable&lt;int64&gt;" Usage="System.Linq.Enumerable.Max source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Int64&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;System.Nullable&lt;System.Int64&gt;&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Uma sequência de valores <see cref="T:System.Int64" /> anuláveis para determinar o valor máximo.</param>
        <summary>Retorna o valor máximo em uma sequência de valores <see cref="T:System.Int64" /> anuláveis.</summary>
        <returns>Um valor do tipo <c>Nullable&lt;Int64&gt;</c> em C# ou <c>Nullable(Of Int64)</c> no Visual Basic que corresponde ao valor máximo na sequência.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Linq.Enumerable.Max%28System.Collections.Generic.IEnumerable%7BSystem.Nullable%7BSystem.Int64%7D%7D%29> usa o <xref:System.Int64> implementação de <xref:System.IComparable%601> para comparar valores.  
  
 Se a sequência de origem estiver vazia ou contiver somente valores que são `null`, essa função retorna `null`.  
  
 Na sintaxe de expressão de consulta do Visual Basic, uma `Aggregate Into Max()` cláusula se traduz em uma invocação de <xref:System.Linq.Enumerable.Max%2A>.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como usar <xref:System.Linq.Enumerable.Max%28System.Collections.Generic.IEnumerable%7BSystem.Nullable%7BSystem.Double%7D%7D%29> para determinar o valor máximo em uma sequência.  
  
 [!INCLUDE[sqo_diff_overload_example_elementtype](~/includes/sqo-diff-overload-example-elementtype-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#54](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#54)]
 [!code-vb[System.Linq.Enumerable#54](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#54)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> é <see langword="null" />.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/1315a814-5db6-4077-b34b-b141e11cc0eb">Cláusula Aggregate (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Max">
      <MemberSignature Language="C#" Value="public static Nullable&lt;float&gt; Max (this System.Collections.Generic.IEnumerable&lt;Nullable&lt;float&gt;&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;float32&gt; Max(class System.Collections.Generic.IEnumerable`1&lt;valuetype System.Nullable`1&lt;float32&gt;&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Max(System.Collections.Generic.IEnumerable{System.Nullable{System.Single}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Max (source As IEnumerable(Of Nullable(Of Single))) As Nullable(Of Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Nullable&lt;float&gt; Max(System::Collections::Generic::IEnumerable&lt;Nullable&lt;float&gt;&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Max : seq&lt;Nullable&lt;single&gt;&gt; -&gt; Nullable&lt;single&gt;" Usage="System.Linq.Enumerable.Max source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Single&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;System.Nullable&lt;System.Single&gt;&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Uma sequência de valores <see cref="T:System.Single" /> anuláveis para determinar o valor máximo.</param>
        <summary>Retorna o valor máximo em uma sequência de valores <see cref="T:System.Single" /> anuláveis.</summary>
        <returns>Um valor do tipo <c>Nullable&lt;Single&gt;</c> em C# ou <c>Nullable(Of Single)</c> no Visual Basic que corresponde ao valor máximo na sequência.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Linq.Enumerable.Max%28System.Collections.Generic.IEnumerable%7BSystem.Nullable%7BSystem.Single%7D%7D%29> usa o <xref:System.Single> implementação de <xref:System.IComparable%601> para comparar valores.  
  
 Se a sequência de origem estiver vazia ou contiver somente valores que são `null`, essa função retorna `null`.  
  
 Na sintaxe de expressão de consulta do Visual Basic, uma `Aggregate Into Max()` cláusula se traduz em uma invocação de <xref:System.Linq.Enumerable.Max%2A>.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como usar <xref:System.Linq.Enumerable.Max%28System.Collections.Generic.IEnumerable%7BSystem.Nullable%7BSystem.Double%7D%7D%29> para determinar o valor máximo em uma sequência.  
  
 [!INCLUDE[sqo_diff_overload_example_elementtype](~/includes/sqo-diff-overload-example-elementtype-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#54](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#54)]
 [!code-vb[System.Linq.Enumerable#54](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#54)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> é <see langword="null" />.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/1315a814-5db6-4077-b34b-b141e11cc0eb">Cláusula Aggregate (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Max">
      <MemberSignature Language="C#" Value="public static float Max (this System.Collections.Generic.IEnumerable&lt;float&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 Max(class System.Collections.Generic.IEnumerable`1&lt;float32&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Max(System.Collections.Generic.IEnumerable{System.Single})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Max (source As IEnumerable(Of Single)) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static float Max(System::Collections::Generic::IEnumerable&lt;float&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Max : seq&lt;single&gt; -&gt; single" Usage="System.Linq.Enumerable.Max source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;System.Single&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Uma sequência de valores <see cref="T:System.Single" /> da qual será determinado o valor máximo.</param>
        <summary>Retorna o valor máximo em uma sequência de valores <see cref="T:System.Single" />.</summary>
        <returns>O valor máximo na sequência.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Linq.Enumerable.Max%28System.Collections.Generic.IEnumerable%7BSystem.Single%7D%29> usa o <xref:System.Single> implementação de <xref:System.IComparable%601> para comparar valores.  
  
 Na sintaxe de expressão de consulta do Visual Basic, uma `Aggregate Into Max()` cláusula se traduz em uma invocação de <xref:System.Linq.Enumerable.Max%2A>.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como usar <xref:System.Linq.Enumerable.Max%28System.Collections.Generic.IEnumerable%7BSystem.Int64%7D%29> para determinar o valor máximo em uma sequência.  
  
 [!INCLUDE[sqo_diff_overload_example_elementtype](~/includes/sqo-diff-overload-example-elementtype-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#52](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#52)]
 [!code-vb[System.Linq.Enumerable#52](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#52)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> é <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="source" /> não contém elementos.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/1315a814-5db6-4077-b34b-b141e11cc0eb">Cláusula Aggregate (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Max&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static TSource Max&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TSource Max&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Max``1(System.Collections.Generic.IEnumerable{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Max(Of TSource) (source As IEnumerable(Of TSource)) As TSource" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static TSource Max(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Max : seq&lt;'Source&gt; -&gt; 'Source" Usage="System.Linq.Enumerable.Max source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TSource</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">O tipo dos elementos de <paramref name="source" />.</typeparam>
        <param name="source">Uma sequência de valores para determinação do valor máximo.</param>
        <summary>Retorna o valor máximo em uma sequência genérica.</summary>
        <returns>O valor máximo na sequência.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se tipo `TSource` implementa <xref:System.IComparable%601>, o <xref:System.Linq.Enumerable.Max%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%29> usa o método que a implementação para comparar valores. Caso contrário, se tipo `TSource` implementa <xref:System.IComparable>, que a implementação é usada para comparar valores.  
  
 Se `TSource` é um tipo de referência e a sequência de origem estiver vazia ou contiver somente valores que são `null`, esse método retornará `null`.  
  
 Na sintaxe de expressão de consulta do Visual Basic, uma `Aggregate Into Max()` cláusula se traduz em uma invocação de <xref:System.Linq.Enumerable.Max%2A>.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como usar <xref:System.Linq.Enumerable.Max%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%29> para determinar o valor máximo em uma sequência de <xref:System.IComparable%601> objetos.  
  
 [!code-csharp[System.Linq.Enumerable#57](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#57)]
 [!code-vb[System.Linq.Enumerable#57](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#57)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> é <see langword="null" />.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/1315a814-5db6-4077-b34b-b141e11cc0eb">Cláusula Aggregate (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Max&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static decimal Max&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,decimal&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Decimal Max&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, valuetype System.Decimal&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Max``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Decimal})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Max(Of TSource) (source As IEnumerable(Of TSource), selector As Func(Of TSource, Decimal)) As Decimal" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Decimal Max(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Func&lt;TSource, System::Decimal&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="static member Max : seq&lt;'Source&gt; * Func&lt;'Source, decimal&gt; -&gt; decimal" Usage="System.Linq.Enumerable.Max (source, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Decimal&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">O tipo dos elementos de <paramref name="source" />.</typeparam>
        <param name="source">Uma sequência de valores para determinação do valor máximo.</param>
        <param name="selector">Uma função de transformação a ser aplicada a cada elemento.</param>
        <summary>Invoca uma função de transformação em cada elemento de uma sequência e retorna o valor <see cref="T:System.Decimal" /> máximo.</summary>
        <returns>O valor máximo na sequência.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Linq.Enumerable.Max%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Decimal%7D%29> usa o <xref:System.Decimal> implementação de <xref:System.IComparable%601> para comparar valores.  
  
 Você pode aplicar esse método em uma sequência de valores arbitrários, se você fornecer uma função `selector`, que os membros de projetos `source` em um tipo numérico, especificamente <xref:System.Decimal>.  
  
 Na sintaxe de expressão de consulta do Visual Basic, uma `Aggregate Into Max()` cláusula se traduz em uma invocação de <xref:System.Linq.Enumerable.Max%2A>.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como usar <xref:System.Linq.Enumerable.Max%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Int32%7D%29> para determinar o valor máximo em uma sequência de valores projetados.  
  
 [!INCLUDE[sqo_diff_overload_example_func](~/includes/sqo-diff-overload-example-func-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#58](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#58)]
 [!code-vb[System.Linq.Enumerable#58](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#58)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> ou <paramref name="selector" /> é <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="source" /> não contém elementos.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/1315a814-5db6-4077-b34b-b141e11cc0eb">Cláusula Aggregate (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Max&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static double Max&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,double&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Max&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, float64&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Max``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Double})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Max(Of TSource) (source As IEnumerable(Of TSource), selector As Func(Of TSource, Double)) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static double Max(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Func&lt;TSource, double&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="static member Max : seq&lt;'Source&gt; * Func&lt;'Source, double&gt; -&gt; double" Usage="System.Linq.Enumerable.Max (source, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Double&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">O tipo dos elementos de <paramref name="source" />.</typeparam>
        <param name="source">Uma sequência de valores para determinação do valor máximo.</param>
        <param name="selector">Uma função de transformação a ser aplicada a cada elemento.</param>
        <summary>Invoca uma função de transformação em cada elemento de uma sequência e retorna o valor <see cref="T:System.Double" /> máximo.</summary>
        <returns>O valor máximo na sequência.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Linq.Enumerable.Max%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Double%7D%29> usa o <xref:System.Double> implementação de <xref:System.IComparable%601> para comparar valores.  
  
 Você pode aplicar esse método em uma sequência de valores arbitrários, se você fornecer uma função `selector`, que os membros de projetos `source` em um tipo numérico, especificamente <xref:System.Double>.  
  
 Na sintaxe de expressão de consulta do Visual Basic, uma `Aggregate Into Max()` cláusula se traduz em uma invocação de <xref:System.Linq.Enumerable.Max%2A>.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como usar <xref:System.Linq.Enumerable.Max%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Int32%7D%29> para determinar o valor máximo em uma sequência de valores projetados.  
  
 [!INCLUDE[sqo_diff_overload_example_func](~/includes/sqo-diff-overload-example-func-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#58](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#58)]
 [!code-vb[System.Linq.Enumerable#58](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#58)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> ou <paramref name="selector" /> é <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="source" /> não contém elementos.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/1315a814-5db6-4077-b34b-b141e11cc0eb">Cláusula Aggregate (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Max&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static int Max&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,int&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Max&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, int32&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Max``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Int32})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Max(Of TSource) (source As IEnumerable(Of TSource), selector As Func(Of TSource, Integer)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static int Max(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Func&lt;TSource, int&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="static member Max : seq&lt;'Source&gt; * Func&lt;'Source, int&gt; -&gt; int" Usage="System.Linq.Enumerable.Max (source, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Int32&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">O tipo dos elementos de <paramref name="source" />.</typeparam>
        <param name="source">Uma sequência de valores para determinação do valor máximo.</param>
        <param name="selector">Uma função de transformação a ser aplicada a cada elemento.</param>
        <summary>Invoca uma função de transformação em cada elemento de uma sequência e retorna o valor <see cref="T:System.Int32" /> máximo.</summary>
        <returns>O valor máximo na sequência.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Linq.Enumerable.Max%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Int32%7D%29> usa o <xref:System.Int32> implementação de <xref:System.IComparable%601> para comparar valores.  
  
 Você pode aplicar esse método em uma sequência de valores arbitrários, se você fornecer uma função `selector`, que os membros de projetos `source` em um tipo numérico, especificamente <xref:System.Int32>.  
  
 Na sintaxe de expressão de consulta do Visual Basic, uma `Aggregate Into Max()` cláusula se traduz em uma invocação de <xref:System.Linq.Enumerable.Max%2A>.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como usar <xref:System.Linq.Enumerable.Max%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Int32%7D%29> para determinar o valor máximo em uma sequência de valores projetados.  
  
 [!code-csharp[System.Linq.Enumerable#58](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#58)]
 [!code-vb[System.Linq.Enumerable#58](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#58)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> ou <paramref name="selector" /> é <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="source" /> não contém elementos.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/1315a814-5db6-4077-b34b-b141e11cc0eb">Cláusula Aggregate (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Max&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static long Max&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,long&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 Max&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, int64&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Max``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Int64})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Max(Of TSource) (source As IEnumerable(Of TSource), selector As Func(Of TSource, Long)) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static long Max(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Func&lt;TSource, long&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="static member Max : seq&lt;'Source&gt; * Func&lt;'Source, int64&gt; -&gt; int64" Usage="System.Linq.Enumerable.Max (source, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Int64&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">O tipo dos elementos de <paramref name="source" />.</typeparam>
        <param name="source">Uma sequência de valores para determinação do valor máximo.</param>
        <param name="selector">Uma função de transformação a ser aplicada a cada elemento.</param>
        <summary>Invoca uma função de transformação em cada elemento de uma sequência e retorna o valor <see cref="T:System.Int64" /> máximo.</summary>
        <returns>O valor máximo na sequência.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Linq.Enumerable.Max%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Int64%7D%29> usa o <xref:System.Int64> implementação de <xref:System.IComparable%601> para comparar valores.  
  
 Você pode aplicar esse método em uma sequência de valores arbitrários, se você fornecer uma função `selector`, que os membros de projetos `source` em um tipo numérico, especificamente <xref:System.Int64>.  
  
 Na sintaxe de expressão de consulta do Visual Basic, uma `Aggregate Into Max()` cláusula se traduz em uma invocação de <xref:System.Linq.Enumerable.Max%2A>.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como usar <xref:System.Linq.Enumerable.Max%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Int32%7D%29> para determinar o valor máximo em uma sequência de valores projetados.  
  
 [!INCLUDE[sqo_diff_overload_example_func](~/includes/sqo-diff-overload-example-func-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#58](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#58)]
 [!code-vb[System.Linq.Enumerable#58](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#58)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> ou <paramref name="selector" /> é <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="source" /> não contém elementos.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/1315a814-5db6-4077-b34b-b141e11cc0eb">Cláusula Aggregate (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Max&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static Nullable&lt;decimal&gt; Max&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,Nullable&lt;decimal&gt;&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;valuetype System.Decimal&gt; Max&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, valuetype System.Nullable`1&lt;valuetype System.Decimal&gt;&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Max``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Nullable{System.Decimal}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Max(Of TSource) (source As IEnumerable(Of TSource), selector As Func(Of TSource, Nullable(Of Decimal))) As Nullable(Of Decimal)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Nullable&lt;System::Decimal&gt; Max(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Func&lt;TSource, Nullable&lt;System::Decimal&gt;&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="static member Max : seq&lt;'Source&gt; * Func&lt;'Source, Nullable&lt;decimal&gt;&gt; -&gt; Nullable&lt;decimal&gt;" Usage="System.Linq.Enumerable.Max (source, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Decimal&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Nullable&lt;System.Decimal&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">O tipo dos elementos de <paramref name="source" />.</typeparam>
        <param name="source">Uma sequência de valores para determinação do valor máximo.</param>
        <param name="selector">Uma função de transformação a ser aplicada a cada elemento.</param>
        <summary>Invoca uma função de transformação em cada elemento de uma sequência e retorna o valor <see cref="T:System.Decimal" /> máximo que permite valor nulo.</summary>
        <returns>O valor do tipo <c>Nullable&lt;Decimal&gt;</c> em C# ou <c>Nullable(Of Decimal)</c> no Visual Basic que corresponde ao valor máximo na sequência.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Linq.Enumerable.Max%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Nullable%7BSystem.Decimal%7D%7D%29> usa o <xref:System.Decimal> implementação de <xref:System.IComparable%601> para comparar valores.  
  
 Você pode aplicar esse método em uma sequência de valores arbitrários, se você fornecer uma função `selector`, que os membros de projetos `source` em um tipo numérico, especificamente `Nullable<Decimal>` em c# ou `Nullable(Of Decimal)` no Visual Basic.  
  
 Na sintaxe de expressão de consulta do Visual Basic, uma `Aggregate Into Max()` cláusula se traduz em uma invocação de <xref:System.Linq.Enumerable.Max%2A>.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como usar <xref:System.Linq.Enumerable.Max%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Int32%7D%29> para determinar o valor máximo em uma sequência de valores projetados.  
  
 [!INCLUDE[sqo_diff_overload_example_func](~/includes/sqo-diff-overload-example-func-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#58](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#58)]
 [!code-vb[System.Linq.Enumerable#58](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#58)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> ou <paramref name="selector" /> é <see langword="null" />.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/1315a814-5db6-4077-b34b-b141e11cc0eb">Cláusula Aggregate (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Max&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static Nullable&lt;double&gt; Max&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,Nullable&lt;double&gt;&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;float64&gt; Max&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, valuetype System.Nullable`1&lt;float64&gt;&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Max``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Nullable{System.Double}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Max(Of TSource) (source As IEnumerable(Of TSource), selector As Func(Of TSource, Nullable(Of Double))) As Nullable(Of Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Nullable&lt;double&gt; Max(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Func&lt;TSource, Nullable&lt;double&gt;&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="static member Max : seq&lt;'Source&gt; * Func&lt;'Source, Nullable&lt;double&gt;&gt; -&gt; Nullable&lt;double&gt;" Usage="System.Linq.Enumerable.Max (source, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Double&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Nullable&lt;System.Double&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">O tipo dos elementos de <paramref name="source" />.</typeparam>
        <param name="source">Uma sequência de valores para determinação do valor máximo.</param>
        <param name="selector">Uma função de transformação a ser aplicada a cada elemento.</param>
        <summary>Invoca uma função de transformação em cada elemento de uma sequência e retorna o valor <see cref="T:System.Double" /> máximo que permite valor nulo.</summary>
        <returns>O valor do tipo <c>Nullable&lt;Double&gt;</c> em C# ou <c>Nullable(Of Double)</c> no Visual Basic que corresponde ao valor máximo na sequência.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Linq.Enumerable.Max%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Nullable%7BSystem.Double%7D%7D%29> usa o <xref:System.Double> implementação de <xref:System.IComparable%601> para comparar valores.  
  
 Você pode aplicar esse método em uma sequência de valores arbitrários, se você fornecer uma função `selector`, que os membros de projetos `source` em um tipo numérico, especificamente `Nullable<Double>` em c# ou `Nullable(Of Double)` no Visual Basic.  
  
 Na sintaxe de expressão de consulta do Visual Basic, uma `Aggregate Into Max()` cláusula se traduz em uma invocação de <xref:System.Linq.Enumerable.Max%2A>.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como usar <xref:System.Linq.Enumerable.Max%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Int32%7D%29> para determinar o valor máximo em uma sequência de valores projetados.  
  
 [!INCLUDE[sqo_diff_overload_example_func](~/includes/sqo-diff-overload-example-func-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#58](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#58)]
 [!code-vb[System.Linq.Enumerable#58](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#58)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> ou <paramref name="selector" /> é <see langword="null" />.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/1315a814-5db6-4077-b34b-b141e11cc0eb">Cláusula Aggregate (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Max&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static Nullable&lt;int&gt; Max&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,Nullable&lt;int&gt;&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;int32&gt; Max&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, valuetype System.Nullable`1&lt;int32&gt;&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Max``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Nullable{System.Int32}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Max(Of TSource) (source As IEnumerable(Of TSource), selector As Func(Of TSource, Nullable(Of Integer))) As Nullable(Of Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Nullable&lt;int&gt; Max(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Func&lt;TSource, Nullable&lt;int&gt;&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="static member Max : seq&lt;'Source&gt; * Func&lt;'Source, Nullable&lt;int&gt;&gt; -&gt; Nullable&lt;int&gt;" Usage="System.Linq.Enumerable.Max (source, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Nullable&lt;System.Int32&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">O tipo dos elementos de <paramref name="source" />.</typeparam>
        <param name="source">Uma sequência de valores para determinação do valor máximo.</param>
        <param name="selector">Uma função de transformação a ser aplicada a cada elemento.</param>
        <summary>Invoca uma função de transformação em cada elemento de uma sequência e retorna o valor <see cref="T:System.Int32" /> máximo que permite valor nulo.</summary>
        <returns>O valor do tipo <c>Nullable&lt;Int32&gt;</c> em C# ou <c>Nullable(Of Int32)</c> no Visual Basic que corresponde ao valor máximo na sequência.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Linq.Enumerable.Max%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Nullable%7BSystem.Int32%7D%7D%29> usa o <xref:System.Int32> implementação de <xref:System.IComparable%601> para comparar valores.  
  
 Você pode aplicar esse método em uma sequência de valores arbitrários, se você fornecer uma função `selector`, que os membros de projetos `source` em um tipo numérico, especificamente `Nullable<Int32>` em c# ou `Nullable(Of Int32)` no Visual Basic.  
  
 Na sintaxe de expressão de consulta do Visual Basic, uma `Aggregate Into Max()` cláusula se traduz em uma invocação de <xref:System.Linq.Enumerable.Max%2A>.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como usar <xref:System.Linq.Enumerable.Max%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Int32%7D%29> para determinar o valor máximo em uma sequência de valores projetados.  
  
 [!INCLUDE[sqo_diff_overload_example_func](~/includes/sqo-diff-overload-example-func-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#58](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#58)]
 [!code-vb[System.Linq.Enumerable#58](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#58)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> ou <paramref name="selector" /> é <see langword="null" />.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/1315a814-5db6-4077-b34b-b141e11cc0eb">Cláusula Aggregate (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Max&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static Nullable&lt;long&gt; Max&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,Nullable&lt;long&gt;&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;int64&gt; Max&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, valuetype System.Nullable`1&lt;int64&gt;&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Max``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Nullable{System.Int64}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Max(Of TSource) (source As IEnumerable(Of TSource), selector As Func(Of TSource, Nullable(Of Long))) As Nullable(Of Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Nullable&lt;long&gt; Max(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Func&lt;TSource, Nullable&lt;long&gt;&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="static member Max : seq&lt;'Source&gt; * Func&lt;'Source, Nullable&lt;int64&gt;&gt; -&gt; Nullable&lt;int64&gt;" Usage="System.Linq.Enumerable.Max (source, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Int64&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Nullable&lt;System.Int64&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">O tipo dos elementos de <paramref name="source" />.</typeparam>
        <param name="source">Uma sequência de valores para determinação do valor máximo.</param>
        <param name="selector">Uma função de transformação a ser aplicada a cada elemento.</param>
        <summary>Invoca uma função de transformação em cada elemento de uma sequência e retorna o valor <see cref="T:System.Int64" /> máximo que permite valor nulo.</summary>
        <returns>O valor do tipo <c>Nullable&lt;Int64&gt;</c> em C# ou <c>Nullable(Of Int64)</c> no Visual Basic que corresponde ao valor máximo na sequência.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Linq.Enumerable.Max%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Nullable%7BSystem.Int64%7D%7D%29> usa o <xref:System.Int64> implementação de <xref:System.IComparable%601> para comparar valores.  
  
 Você pode aplicar esse método em uma sequência de valores arbitrários, se você fornecer uma função `selector`, que os membros de projetos `source` em um tipo numérico, especificamente `Nullable<Int64>` em c# ou `Nullable(Of Int64)` no Visual Basic.  
  
 Na sintaxe de expressão de consulta do Visual Basic, uma `Aggregate Into Max()` cláusula se traduz em uma invocação de <xref:System.Linq.Enumerable.Max%2A>.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como usar <xref:System.Linq.Enumerable.Max%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Int32%7D%29> para determinar o valor máximo em uma sequência de valores projetados.  
  
 [!INCLUDE[sqo_diff_overload_example_func](~/includes/sqo-diff-overload-example-func-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#58](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#58)]
 [!code-vb[System.Linq.Enumerable#58](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#58)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> ou <paramref name="selector" /> é <see langword="null" />.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/1315a814-5db6-4077-b34b-b141e11cc0eb">Cláusula Aggregate (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Max&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static Nullable&lt;float&gt; Max&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,Nullable&lt;float&gt;&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;float32&gt; Max&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, valuetype System.Nullable`1&lt;float32&gt;&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Max``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Nullable{System.Single}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Max(Of TSource) (source As IEnumerable(Of TSource), selector As Func(Of TSource, Nullable(Of Single))) As Nullable(Of Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Nullable&lt;float&gt; Max(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Func&lt;TSource, Nullable&lt;float&gt;&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="static member Max : seq&lt;'Source&gt; * Func&lt;'Source, Nullable&lt;single&gt;&gt; -&gt; Nullable&lt;single&gt;" Usage="System.Linq.Enumerable.Max (source, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Single&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Nullable&lt;System.Single&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">O tipo dos elementos de <paramref name="source" />.</typeparam>
        <param name="source">Uma sequência de valores para determinação do valor máximo.</param>
        <param name="selector">Uma função de transformação a ser aplicada a cada elemento.</param>
        <summary>Invoca uma função de transformação em cada elemento de uma sequência e retorna o valor <see cref="T:System.Single" /> máximo que permite valor nulo.</summary>
        <returns>O valor do tipo <c>Nullable&lt;Single&gt;</c> em C# ou <c>Nullable(Of Single)</c> no Visual Basic que corresponde ao valor máximo na sequência.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Linq.Enumerable.Max%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Nullable%7BSystem.Single%7D%7D%29> usa o <xref:System.Single> implementação de <xref:System.IComparable%601> para comparar valores.  
  
 Você pode aplicar esse método em uma sequência de valores arbitrários, se você fornecer uma função `selector`, que os membros de projetos `source` em um tipo numérico, especificamente `Nullable<Single>` em c# ou `Nullable(Of Single)` no Visual Basic.  
  
 Na sintaxe de expressão de consulta do Visual Basic, uma `Aggregate Into Max()` cláusula se traduz em uma invocação de <xref:System.Linq.Enumerable.Max%2A>.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como usar <xref:System.Linq.Enumerable.Max%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Int32%7D%29> para determinar o valor máximo em uma sequência de valores projetados.  
  
 [!INCLUDE[sqo_diff_overload_example_func](~/includes/sqo-diff-overload-example-func-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#58](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#58)]
 [!code-vb[System.Linq.Enumerable#58](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#58)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> ou <paramref name="selector" /> é <see langword="null" />.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/1315a814-5db6-4077-b34b-b141e11cc0eb">Cláusula Aggregate (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Max&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static float Max&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,float&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 Max&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, float32&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Max``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Single})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Max(Of TSource) (source As IEnumerable(Of TSource), selector As Func(Of TSource, Single)) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static float Max(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Func&lt;TSource, float&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="static member Max : seq&lt;'Source&gt; * Func&lt;'Source, single&gt; -&gt; single" Usage="System.Linq.Enumerable.Max (source, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Single&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">O tipo dos elementos de <paramref name="source" />.</typeparam>
        <param name="source">Uma sequência de valores para determinação do valor máximo.</param>
        <param name="selector">Uma função de transformação a ser aplicada a cada elemento.</param>
        <summary>Invoca uma função de transformação em cada elemento de uma sequência e retorna o valor <see cref="T:System.Single" /> máximo.</summary>
        <returns>O valor máximo na sequência.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Linq.Enumerable.Max%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Single%7D%29> usa o <xref:System.Single> implementação de <xref:System.IComparable%601> para comparar valores.  
  
 Você pode aplicar esse método em uma sequência de valores arbitrários, se você fornecer uma função `selector`, que os membros de projetos `source` em um tipo numérico, especificamente <xref:System.Single>.  
  
 Na sintaxe de expressão de consulta do Visual Basic, uma `Aggregate Into Max()` cláusula se traduz em uma invocação de <xref:System.Linq.Enumerable.Max%2A>.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como usar <xref:System.Linq.Enumerable.Max%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Int32%7D%29> para determinar o valor máximo em uma sequência de valores projetados.  
  
 [!INCLUDE[sqo_diff_overload_example_func](~/includes/sqo-diff-overload-example-func-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#58](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#58)]
 [!code-vb[System.Linq.Enumerable#58](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#58)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> ou <paramref name="selector" /> é <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="source" /> não contém elementos.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/1315a814-5db6-4077-b34b-b141e11cc0eb">Cláusula Aggregate (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Max&lt;TSource,TResult&gt;">
      <MemberSignature Language="C#" Value="public static TResult Max&lt;TSource,TResult&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,TResult&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TResult Max&lt;TSource, TResult&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, !!TResult&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Max``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Max(Of TSource, TResult) (source As IEnumerable(Of TSource), selector As Func(Of TSource, TResult)) As TResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TResult&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static TResult Max(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Func&lt;TSource, TResult&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="static member Max : seq&lt;'Source&gt; * Func&lt;'Source, 'Result&gt; -&gt; 'Result" Usage="System.Linq.Enumerable.Max (source, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,TResult&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">O tipo dos elementos de <paramref name="source" />.</typeparam>
        <typeparam name="TResult">O tipo do valor retornado por <paramref name="selector" />.</typeparam>
        <param name="source">Uma sequência de valores para determinação do valor máximo.</param>
        <param name="selector">Uma função de transformação a ser aplicada a cada elemento.</param>
        <summary>Invoca uma função de transformação em cada elemento de uma sequência genérica e retorna o maior valor resultante.</summary>
        <returns>O valor máximo na sequência.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se tipo `TResult` implementa <xref:System.IComparable%601>, esse método usa essa implementação para comparar valores. Caso contrário, se tipo `TResult` implementa <xref:System.IComparable>, que a implementação é usada para comparar valores.  
  
 Na sintaxe de expressão de consulta do Visual Basic, uma `Aggregate Into Max()` cláusula se traduz em uma invocação de <xref:System.Linq.Enumerable.Max%2A>.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como usar <xref:System.Linq.Enumerable.Max%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Int32%7D%29> para determinar o valor máximo em uma sequência de valores projetados.  
  
 [!INCLUDE[sqo_diff_overload_example_func](~/includes/sqo-diff-overload-example-func-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#58](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#58)]
 [!code-vb[System.Linq.Enumerable#58](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#58)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> ou <paramref name="selector" /> é <see langword="null" />.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/1315a814-5db6-4077-b34b-b141e11cc0eb">Cláusula Aggregate (Visual Basic)</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Min">
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Retorna o valor mínimo em uma sequência de valores.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Min">
      <MemberSignature Language="C#" Value="public static decimal Min (this System.Collections.Generic.IEnumerable&lt;decimal&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Decimal Min(class System.Collections.Generic.IEnumerable`1&lt;valuetype System.Decimal&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Min(System.Collections.Generic.IEnumerable{System.Decimal})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Min (source As IEnumerable(Of Decimal)) As Decimal" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Decimal Min(System::Collections::Generic::IEnumerable&lt;System::Decimal&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Min : seq&lt;decimal&gt; -&gt; decimal" Usage="System.Linq.Enumerable.Min source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;System.Decimal&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Uma sequência de valores <see cref="T:System.Decimal" /> para determinação do valor mínimo.</param>
        <summary>Retorna o valor mínimo em uma sequência de valores <see cref="T:System.Decimal" />.</summary>
        <returns>O valor mínimo na sequência.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Linq.Enumerable.Min%28System.Collections.Generic.IEnumerable%7BSystem.Decimal%7D%29> usa o <xref:System.Decimal> implementação de <xref:System.IComparable%601> para comparar valores.  
  
 Na sintaxe de expressão de consulta do Visual Basic, uma `Aggregate Into Min()` cláusula se traduz em uma invocação de <xref:System.Linq.Enumerable.Min%2A>.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como usar <xref:System.Linq.Enumerable.Min%28System.Collections.Generic.IEnumerable%7BSystem.Double%7D%29> para determinar o valor mínimo em uma sequência.  
  
 [!INCLUDE[sqo_diff_overload_example_elementtype](~/includes/sqo-diff-overload-example-elementtype-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#60](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#60)]
 [!code-vb[System.Linq.Enumerable#60](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#60)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> é <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="source" /> não contém elementos.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/1315a814-5db6-4077-b34b-b141e11cc0eb">Cláusula Aggregate (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Min">
      <MemberSignature Language="C#" Value="public static double Min (this System.Collections.Generic.IEnumerable&lt;double&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Min(class System.Collections.Generic.IEnumerable`1&lt;float64&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Min(System.Collections.Generic.IEnumerable{System.Double})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Min (source As IEnumerable(Of Double)) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static double Min(System::Collections::Generic::IEnumerable&lt;double&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Min : seq&lt;double&gt; -&gt; double" Usage="System.Linq.Enumerable.Min source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;System.Double&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Uma sequência de valores <see cref="T:System.Double" /> para determinação do valor mínimo.</param>
        <summary>Retorna o valor mínimo em uma sequência de valores <see cref="T:System.Double" />.</summary>
        <returns>O valor mínimo na sequência.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Linq.Enumerable.Min%28System.Collections.Generic.IEnumerable%7BSystem.Double%7D%29> usa o <xref:System.Double> implementação de <xref:System.IComparable%601> para comparar valores.  
  
 Na sintaxe de expressão de consulta do Visual Basic, uma `Aggregate Into Min()` cláusula se traduz em uma invocação de <xref:System.Linq.Enumerable.Min%2A>.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como usar <xref:System.Linq.Enumerable.Min%28System.Collections.Generic.IEnumerable%7BSystem.Double%7D%29> para determinar o valor mínimo em uma sequência.  
  
 [!code-csharp[System.Linq.Enumerable#60](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#60)]
 [!code-vb[System.Linq.Enumerable#60](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#60)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> é <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="source" /> não contém elementos.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/1315a814-5db6-4077-b34b-b141e11cc0eb">Cláusula Aggregate (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Min">
      <MemberSignature Language="C#" Value="public static int Min (this System.Collections.Generic.IEnumerable&lt;int&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Min(class System.Collections.Generic.IEnumerable`1&lt;int32&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Min(System.Collections.Generic.IEnumerable{System.Int32})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Min (source As IEnumerable(Of Integer)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static int Min(System::Collections::Generic::IEnumerable&lt;int&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Min : seq&lt;int&gt; -&gt; int" Usage="System.Linq.Enumerable.Min source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;System.Int32&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Uma sequência de valores <see cref="T:System.Int32" /> para determinação do valor mínimo.</param>
        <summary>Retorna o valor mínimo em uma sequência de valores <see cref="T:System.Int32" />.</summary>
        <returns>O valor mínimo na sequência.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Linq.Enumerable.Min%28System.Collections.Generic.IEnumerable%7BSystem.Int32%7D%29> usa o <xref:System.Int32> implementação de <xref:System.IComparable%601> para comparar valores.  
  
 Na sintaxe de expressão de consulta do Visual Basic, uma `Aggregate Into Min()` cláusula se traduz em uma invocação de <xref:System.Linq.Enumerable.Min%2A>.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como usar <xref:System.Linq.Enumerable.Min%28System.Collections.Generic.IEnumerable%7BSystem.Double%7D%29> para determinar o valor mínimo em uma sequência.  
  
 [!INCLUDE[sqo_diff_overload_example_elementtype](~/includes/sqo-diff-overload-example-elementtype-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#60](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#60)]
 [!code-vb[System.Linq.Enumerable#60](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#60)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> é <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="source" /> não contém elementos.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/1315a814-5db6-4077-b34b-b141e11cc0eb">Cláusula Aggregate (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Min">
      <MemberSignature Language="C#" Value="public static long Min (this System.Collections.Generic.IEnumerable&lt;long&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 Min(class System.Collections.Generic.IEnumerable`1&lt;int64&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Min(System.Collections.Generic.IEnumerable{System.Int64})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Min (source As IEnumerable(Of Long)) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static long Min(System::Collections::Generic::IEnumerable&lt;long&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Min : seq&lt;int64&gt; -&gt; int64" Usage="System.Linq.Enumerable.Min source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;System.Int64&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Uma sequência de valores <see cref="T:System.Int64" /> para determinação do valor mínimo.</param>
        <summary>Retorna o valor mínimo em uma sequência de valores <see cref="T:System.Int64" />.</summary>
        <returns>O valor mínimo na sequência.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Linq.Enumerable.Min%28System.Collections.Generic.IEnumerable%7BSystem.Int64%7D%29> usa o <xref:System.Int64> implementação de <xref:System.IComparable%601> para comparar valores.  
  
 Na sintaxe de expressão de consulta do Visual Basic, uma `Aggregate Into Min()` cláusula se traduz em uma invocação de <xref:System.Linq.Enumerable.Min%2A>.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como usar <xref:System.Linq.Enumerable.Min%28System.Collections.Generic.IEnumerable%7BSystem.Double%7D%29> para determinar o valor mínimo em uma sequência.  
  
 [!INCLUDE[sqo_diff_overload_example_elementtype](~/includes/sqo-diff-overload-example-elementtype-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#60](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#60)]
 [!code-vb[System.Linq.Enumerable#60](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#60)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> é <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="source" /> não contém elementos.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/1315a814-5db6-4077-b34b-b141e11cc0eb">Cláusula Aggregate (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Min">
      <MemberSignature Language="C#" Value="public static Nullable&lt;decimal&gt; Min (this System.Collections.Generic.IEnumerable&lt;Nullable&lt;decimal&gt;&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;valuetype System.Decimal&gt; Min(class System.Collections.Generic.IEnumerable`1&lt;valuetype System.Nullable`1&lt;valuetype System.Decimal&gt;&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Min(System.Collections.Generic.IEnumerable{System.Nullable{System.Decimal}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Min (source As IEnumerable(Of Nullable(Of Decimal))) As Nullable(Of Decimal)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Nullable&lt;System::Decimal&gt; Min(System::Collections::Generic::IEnumerable&lt;Nullable&lt;System::Decimal&gt;&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Min : seq&lt;Nullable&lt;decimal&gt;&gt; -&gt; Nullable&lt;decimal&gt;" Usage="System.Linq.Enumerable.Min source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Decimal&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;System.Nullable&lt;System.Decimal&gt;&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Uma sequência de valores <see cref="T:System.Decimal" /> anuláveis dos quais determinar o valor mínimo.</param>
        <summary>Retorna o valor mínimo em uma sequência de valores <see cref="T:System.Decimal" /> anuláveis.</summary>
        <returns>Um valor do tipo <c>Nullable&lt;Decimal&gt;</c> em C# ou <c>Nullable(Of Decimal)</c> no Visual Basic que corresponde ao valor mínimo na sequência.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Linq.Enumerable.Min%28System.Collections.Generic.IEnumerable%7BSystem.Nullable%7BSystem.Decimal%7D%7D%29> usa o <xref:System.Decimal> implementação de <xref:System.IComparable%601> para comparar valores.  
  
 Se a sequência de origem estiver vazia ou contiver somente valores que são `null`, essa função retorna `null`.  
  
 Na sintaxe de expressão de consulta do Visual Basic, uma `Aggregate Into Min()` cláusula se traduz em uma invocação de <xref:System.Linq.Enumerable.Min%2A>.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como usar <xref:System.Linq.Enumerable.Min%28System.Collections.Generic.IEnumerable%7BSystem.Nullable%7BSystem.Int32%7D%7D%29> para determinar o valor mínimo em uma sequência.  
  
 [!INCLUDE[sqo_diff_overload_example_elementtype](~/includes/sqo-diff-overload-example-elementtype-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#63](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#63)]
 [!code-vb[System.Linq.Enumerable#63](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#63)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> é <see langword="null" />.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/1315a814-5db6-4077-b34b-b141e11cc0eb">Cláusula Aggregate (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Min">
      <MemberSignature Language="C#" Value="public static Nullable&lt;double&gt; Min (this System.Collections.Generic.IEnumerable&lt;Nullable&lt;double&gt;&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;float64&gt; Min(class System.Collections.Generic.IEnumerable`1&lt;valuetype System.Nullable`1&lt;float64&gt;&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Min(System.Collections.Generic.IEnumerable{System.Nullable{System.Double}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Min (source As IEnumerable(Of Nullable(Of Double))) As Nullable(Of Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Nullable&lt;double&gt; Min(System::Collections::Generic::IEnumerable&lt;Nullable&lt;double&gt;&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Min : seq&lt;Nullable&lt;double&gt;&gt; -&gt; Nullable&lt;double&gt;" Usage="System.Linq.Enumerable.Min source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Double&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;System.Nullable&lt;System.Double&gt;&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Uma sequência de valores <see cref="T:System.Double" /> anuláveis dos quais determinar o valor mínimo.</param>
        <summary>Retorna o valor mínimo em uma sequência de valores <see cref="T:System.Double" /> anuláveis.</summary>
        <returns>Um valor do tipo <c>Nullable&lt;Double&gt;</c> em C# ou <c>Nullable(Of Double)</c> no Visual Basic que corresponde ao valor mínimo na sequência.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Linq.Enumerable.Min%28System.Collections.Generic.IEnumerable%7BSystem.Nullable%7BSystem.Double%7D%7D%29> usa o <xref:System.Double> implementação de <xref:System.IComparable%601> para comparar valores.  
  
 Se a sequência de origem estiver vazia ou contiver somente valores que são `null`, essa função retorna `null`.  
  
 Na sintaxe de expressão de consulta do Visual Basic, uma `Aggregate Into Min()` cláusula se traduz em uma invocação de <xref:System.Linq.Enumerable.Min%2A>.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como usar <xref:System.Linq.Enumerable.Min%28System.Collections.Generic.IEnumerable%7BSystem.Nullable%7BSystem.Int32%7D%7D%29> para determinar o valor mínimo em uma sequência.  
  
 [!INCLUDE[sqo_diff_overload_example_elementtype](~/includes/sqo-diff-overload-example-elementtype-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#63](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#63)]
 [!code-vb[System.Linq.Enumerable#63](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#63)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> é <see langword="null" />.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/1315a814-5db6-4077-b34b-b141e11cc0eb">Cláusula Aggregate (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Min">
      <MemberSignature Language="C#" Value="public static Nullable&lt;int&gt; Min (this System.Collections.Generic.IEnumerable&lt;Nullable&lt;int&gt;&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;int32&gt; Min(class System.Collections.Generic.IEnumerable`1&lt;valuetype System.Nullable`1&lt;int32&gt;&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Min(System.Collections.Generic.IEnumerable{System.Nullable{System.Int32}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Min (source As IEnumerable(Of Nullable(Of Integer))) As Nullable(Of Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Nullable&lt;int&gt; Min(System::Collections::Generic::IEnumerable&lt;Nullable&lt;int&gt;&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Min : seq&lt;Nullable&lt;int&gt;&gt; -&gt; Nullable&lt;int&gt;" Usage="System.Linq.Enumerable.Min source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;System.Nullable&lt;System.Int32&gt;&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Uma sequência de valores <see cref="T:System.Int32" /> anuláveis dos quais determinar o valor mínimo.</param>
        <summary>Retorna o valor mínimo em uma sequência de valores <see cref="T:System.Int32" /> anuláveis.</summary>
        <returns>Um valor do tipo <c>Nullable&lt;Int32&gt;</c> em C# ou <c>Nullable(Of Int32)</c> no Visual Basic que corresponde ao valor mínimo na sequência.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Linq.Enumerable.Min%28System.Collections.Generic.IEnumerable%7BSystem.Nullable%7BSystem.Int32%7D%7D%29> usa o <xref:System.Int32> implementação de <xref:System.IComparable%601> para comparar valores.  
  
 Se a sequência de origem estiver vazia ou contiver somente valores que são `null`, essa função retorna `null`.  
  
 Na sintaxe de expressão de consulta do Visual Basic, uma `Aggregate Into Min()` cláusula se traduz em uma invocação de <xref:System.Linq.Enumerable.Min%2A>.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como usar <xref:System.Linq.Enumerable.Min%28System.Collections.Generic.IEnumerable%7BSystem.Nullable%7BSystem.Int32%7D%7D%29> para determinar o valor mínimo em uma sequência.  
  
 [!code-csharp[System.Linq.Enumerable#63](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#63)]
 [!code-vb[System.Linq.Enumerable#63](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#63)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> é <see langword="null" />.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/1315a814-5db6-4077-b34b-b141e11cc0eb">Cláusula Aggregate (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Min">
      <MemberSignature Language="C#" Value="public static Nullable&lt;long&gt; Min (this System.Collections.Generic.IEnumerable&lt;Nullable&lt;long&gt;&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;int64&gt; Min(class System.Collections.Generic.IEnumerable`1&lt;valuetype System.Nullable`1&lt;int64&gt;&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Min(System.Collections.Generic.IEnumerable{System.Nullable{System.Int64}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Min (source As IEnumerable(Of Nullable(Of Long))) As Nullable(Of Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Nullable&lt;long&gt; Min(System::Collections::Generic::IEnumerable&lt;Nullable&lt;long&gt;&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Min : seq&lt;Nullable&lt;int64&gt;&gt; -&gt; Nullable&lt;int64&gt;" Usage="System.Linq.Enumerable.Min source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Int64&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;System.Nullable&lt;System.Int64&gt;&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Uma sequência de valores <see cref="T:System.Int64" /> anuláveis dos quais determinar o valor mínimo.</param>
        <summary>Retorna o valor mínimo em uma sequência de valores <see cref="T:System.Int64" /> anuláveis.</summary>
        <returns>Um valor do tipo <c>Nullable&lt;Int64&gt;</c> em C# ou <c>Nullable(Of Int64)</c> no Visual Basic que corresponde ao valor mínimo na sequência.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Linq.Enumerable.Min%28System.Collections.Generic.IEnumerable%7BSystem.Nullable%7BSystem.Int64%7D%7D%29> usa o <xref:System.Int64> implementação de <xref:System.IComparable%601> para comparar valores.  
  
 Se a sequência de origem estiver vazia ou contiver somente valores que são `null`, essa função retorna `null`.  
  
 Na sintaxe de expressão de consulta do Visual Basic, uma `Aggregate Into Min()` cláusula se traduz em uma invocação de <xref:System.Linq.Enumerable.Min%2A>.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como usar <xref:System.Linq.Enumerable.Min%28System.Collections.Generic.IEnumerable%7BSystem.Nullable%7BSystem.Int32%7D%7D%29> para determinar o valor mínimo em uma sequência.  
  
 [!INCLUDE[sqo_diff_overload_example_elementtype](~/includes/sqo-diff-overload-example-elementtype-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#63](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#63)]
 [!code-vb[System.Linq.Enumerable#63](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#63)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> é <see langword="null" />.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/1315a814-5db6-4077-b34b-b141e11cc0eb">Cláusula Aggregate (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Min">
      <MemberSignature Language="C#" Value="public static Nullable&lt;float&gt; Min (this System.Collections.Generic.IEnumerable&lt;Nullable&lt;float&gt;&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;float32&gt; Min(class System.Collections.Generic.IEnumerable`1&lt;valuetype System.Nullable`1&lt;float32&gt;&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Min(System.Collections.Generic.IEnumerable{System.Nullable{System.Single}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Min (source As IEnumerable(Of Nullable(Of Single))) As Nullable(Of Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Nullable&lt;float&gt; Min(System::Collections::Generic::IEnumerable&lt;Nullable&lt;float&gt;&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Min : seq&lt;Nullable&lt;single&gt;&gt; -&gt; Nullable&lt;single&gt;" Usage="System.Linq.Enumerable.Min source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Single&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;System.Nullable&lt;System.Single&gt;&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Uma sequência de valores <see cref="T:System.Single" /> anuláveis dos quais determinar o valor mínimo.</param>
        <summary>Retorna o valor mínimo em uma sequência de valores <see cref="T:System.Single" /> anuláveis.</summary>
        <returns>Um valor do tipo <c>Nullable&lt;Single&gt;</c> em C# ou <c>Nullable(Of Single)</c> no Visual Basic que corresponde ao valor mínimo na sequência.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Linq.Enumerable.Min%28System.Collections.Generic.IEnumerable%7BSystem.Nullable%7BSystem.Single%7D%7D%29> usa o <xref:System.Single> implementação de <xref:System.IComparable%601> para comparar valores.  
  
 Se a sequência de origem estiver vazia ou contiver somente valores que são `null`, essa função retorna `null`.  
  
 Na sintaxe de expressão de consulta do Visual Basic, uma `Aggregate Into Min()` cláusula se traduz em uma invocação de <xref:System.Linq.Enumerable.Min%2A>.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como usar <xref:System.Linq.Enumerable.Min%28System.Collections.Generic.IEnumerable%7BSystem.Nullable%7BSystem.Int32%7D%7D%29> para determinar o valor mínimo em uma sequência.  
  
 [!INCLUDE[sqo_diff_overload_example_elementtype](~/includes/sqo-diff-overload-example-elementtype-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#63](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#63)]
 [!code-vb[System.Linq.Enumerable#63](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#63)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> é <see langword="null" />.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/1315a814-5db6-4077-b34b-b141e11cc0eb">Cláusula Aggregate (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Min">
      <MemberSignature Language="C#" Value="public static float Min (this System.Collections.Generic.IEnumerable&lt;float&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 Min(class System.Collections.Generic.IEnumerable`1&lt;float32&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Min(System.Collections.Generic.IEnumerable{System.Single})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Min (source As IEnumerable(Of Single)) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static float Min(System::Collections::Generic::IEnumerable&lt;float&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Min : seq&lt;single&gt; -&gt; single" Usage="System.Linq.Enumerable.Min source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;System.Single&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Uma sequência de valores <see cref="T:System.Single" /> para determinação do valor mínimo.</param>
        <summary>Retorna o valor mínimo em uma sequência de valores <see cref="T:System.Single" />.</summary>
        <returns>O valor mínimo na sequência.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Linq.Enumerable.Min%28System.Collections.Generic.IEnumerable%7BSystem.Single%7D%29> usa o <xref:System.Single> implementação de <xref:System.IComparable%601> para comparar valores.  
  
 Na sintaxe de expressão de consulta do Visual Basic, uma `Aggregate Into Min()` cláusula se traduz em uma invocação de <xref:System.Linq.Enumerable.Min%2A>.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como usar <xref:System.Linq.Enumerable.Min%28System.Collections.Generic.IEnumerable%7BSystem.Double%7D%29> para determinar o valor mínimo em uma sequência.  
  
 [!INCLUDE[sqo_diff_overload_example_elementtype](~/includes/sqo-diff-overload-example-elementtype-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#60](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#60)]
 [!code-vb[System.Linq.Enumerable#60](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#60)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> é <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="source" /> não contém elementos.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/1315a814-5db6-4077-b34b-b141e11cc0eb">Cláusula Aggregate (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Min&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static TSource Min&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TSource Min&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Min``1(System.Collections.Generic.IEnumerable{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Min(Of TSource) (source As IEnumerable(Of TSource)) As TSource" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static TSource Min(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Min : seq&lt;'Source&gt; -&gt; 'Source" Usage="System.Linq.Enumerable.Min source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TSource</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">O tipo dos elementos de <paramref name="source" />.</typeparam>
        <param name="source">Uma sequência de valores para determinação do valor mínimo.</param>
        <summary>Retorna o valor mínimo em uma sequência genérica.</summary>
        <returns>O valor mínimo na sequência.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se tipo `TSource` implementa <xref:System.IComparable%601>, esse método usa essa implementação para comparar valores. Caso contrário, se tipo `TSource` implementa <xref:System.IComparable>, que a implementação é usada para comparar valores.  
  
 Se `TSource` é um tipo de referência e a sequência de origem estiver vazia ou contiver somente valores que são `null`, essa função retorna `null`.  
  
 Na sintaxe de expressão de consulta do Visual Basic, uma `Aggregate Into Min()` cláusula se traduz em uma invocação de <xref:System.Linq.Enumerable.Min%2A>.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como usar <xref:System.Linq.Enumerable.Min%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%29> para determinar o valor mínimo em uma sequência de <xref:System.IComparable%601> objetos.  
  
 [!code-csharp[System.Linq.Enumerable#67](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#67)]
 [!code-vb[System.Linq.Enumerable#67](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#67)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> é <see langword="null" />.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/1315a814-5db6-4077-b34b-b141e11cc0eb">Cláusula Aggregate (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Min&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static decimal Min&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,decimal&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Decimal Min&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, valuetype System.Decimal&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Min``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Decimal})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Min(Of TSource) (source As IEnumerable(Of TSource), selector As Func(Of TSource, Decimal)) As Decimal" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Decimal Min(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Func&lt;TSource, System::Decimal&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="static member Min : seq&lt;'Source&gt; * Func&lt;'Source, decimal&gt; -&gt; decimal" Usage="System.Linq.Enumerable.Min (source, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Decimal&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">O tipo dos elementos de <paramref name="source" />.</typeparam>
        <param name="source">Uma sequência de valores para determinação do valor mínimo.</param>
        <param name="selector">Uma função de transformação a ser aplicada a cada elemento.</param>
        <summary>Invoca uma função de transformação em cada elemento de uma sequência e retorna o valor <see cref="T:System.Decimal" /> mínimo.</summary>
        <returns>O valor mínimo na sequência.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Linq.Enumerable.Min%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Decimal%7D%29> usa o <xref:System.Decimal> implementação de <xref:System.IComparable%601> para comparar valores.  
  
 Você pode aplicar esse método em uma sequência de valores arbitrários, se você fornecer uma função `selector`, que os membros de projetos `source` em um tipo numérico, especificamente <xref:System.Decimal>.  
  
 Na sintaxe de expressão de consulta do Visual Basic, uma `Aggregate Into Min()` cláusula se traduz em uma invocação de <xref:System.Linq.Enumerable.Min%2A>.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como usar <xref:System.Linq.Enumerable.Min%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Int32%7D%29> para determinar o valor mínimo em uma sequência de valores projetados.  
  
 [!INCLUDE[sqo_diff_overload_example_func](~/includes/sqo-diff-overload-example-func-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#68](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#68)]
 [!code-vb[System.Linq.Enumerable#68](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#68)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> ou <paramref name="selector" /> é <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="source" /> não contém elementos.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/1315a814-5db6-4077-b34b-b141e11cc0eb">Cláusula Aggregate (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Min&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static double Min&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,double&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Min&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, float64&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Min``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Double})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Min(Of TSource) (source As IEnumerable(Of TSource), selector As Func(Of TSource, Double)) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static double Min(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Func&lt;TSource, double&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="static member Min : seq&lt;'Source&gt; * Func&lt;'Source, double&gt; -&gt; double" Usage="System.Linq.Enumerable.Min (source, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Double&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">O tipo dos elementos de <paramref name="source" />.</typeparam>
        <param name="source">Uma sequência de valores para determinação do valor mínimo.</param>
        <param name="selector">Uma função de transformação a ser aplicada a cada elemento.</param>
        <summary>Invoca uma função de transformação em cada elemento de uma sequência e retorna o valor <see cref="T:System.Double" /> mínimo.</summary>
        <returns>O valor mínimo na sequência.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Linq.Enumerable.Min%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Double%7D%29> usa o <xref:System.Double> implementação de <xref:System.IComparable%601> para comparar valores.  
  
 Você pode aplicar esse método em uma sequência de valores arbitrários, se você fornecer uma função `selector`, que os membros de projetos `source` em um tipo numérico, especificamente <xref:System.Double>.  
  
 Na sintaxe de expressão de consulta do Visual Basic, uma `Aggregate Into Min()` cláusula se traduz em uma invocação de <xref:System.Linq.Enumerable.Min%2A>.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como usar <xref:System.Linq.Enumerable.Min%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Int32%7D%29> para determinar o valor mínimo em uma sequência de valores projetados.  
  
 [!INCLUDE[sqo_diff_overload_example_func](~/includes/sqo-diff-overload-example-func-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#68](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#68)]
 [!code-vb[System.Linq.Enumerable#68](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#68)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> ou <paramref name="selector" /> é <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="source" /> não contém elementos.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/1315a814-5db6-4077-b34b-b141e11cc0eb">Cláusula Aggregate (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Min&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static int Min&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,int&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Min&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, int32&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Min``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Int32})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Min(Of TSource) (source As IEnumerable(Of TSource), selector As Func(Of TSource, Integer)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static int Min(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Func&lt;TSource, int&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="static member Min : seq&lt;'Source&gt; * Func&lt;'Source, int&gt; -&gt; int" Usage="System.Linq.Enumerable.Min (source, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Int32&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">O tipo dos elementos de <paramref name="source" />.</typeparam>
        <param name="source">Uma sequência de valores para determinação do valor mínimo.</param>
        <param name="selector">Uma função de transformação a ser aplicada a cada elemento.</param>
        <summary>Invoca uma função de transformação em cada elemento de uma sequência e retorna o valor <see cref="T:System.Int32" /> mínimo.</summary>
        <returns>O valor mínimo na sequência.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Linq.Enumerable.Min%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Int32%7D%29> usa o <xref:System.Int32> implementação de <xref:System.IComparable%601> para comparar valores.  
  
 Você pode aplicar esse método em uma sequência de valores arbitrários, se você fornecer uma função `selector`, que os membros de projetos `source` em um tipo numérico, especificamente <xref:System.Int32>.  
  
 Na sintaxe de expressão de consulta do Visual Basic, uma `Aggregate Into Min()` cláusula se traduz em uma invocação de <xref:System.Linq.Enumerable.Min%2A>.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como usar <xref:System.Linq.Enumerable.Min%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Int32%7D%29> para determinar o valor mínimo em uma sequência de valores projetados.  
  
 [!code-csharp[System.Linq.Enumerable#68](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#68)]
 [!code-vb[System.Linq.Enumerable#68](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#68)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> ou <paramref name="selector" /> é <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="source" /> não contém elementos.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/1315a814-5db6-4077-b34b-b141e11cc0eb">Cláusula Aggregate (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Min&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static long Min&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,long&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 Min&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, int64&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Min``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Int64})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Min(Of TSource) (source As IEnumerable(Of TSource), selector As Func(Of TSource, Long)) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static long Min(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Func&lt;TSource, long&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="static member Min : seq&lt;'Source&gt; * Func&lt;'Source, int64&gt; -&gt; int64" Usage="System.Linq.Enumerable.Min (source, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Int64&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">O tipo dos elementos de <paramref name="source" />.</typeparam>
        <param name="source">Uma sequência de valores para determinação do valor mínimo.</param>
        <param name="selector">Uma função de transformação a ser aplicada a cada elemento.</param>
        <summary>Invoca uma função de transformação em cada elemento de uma sequência e retorna o valor <see cref="T:System.Int64" /> mínimo.</summary>
        <returns>O valor mínimo na sequência.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Linq.Enumerable.Min%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Int64%7D%29> usa o <xref:System.Int64> implementação de <xref:System.IComparable%601> para comparar valores.  
  
 Você pode aplicar esse método em uma sequência de valores arbitrários, se você fornecer uma função `selector`, que os membros de projetos `source` em um tipo numérico, especificamente <xref:System.Int64>.  
  
 Na sintaxe de expressão de consulta do Visual Basic, uma `Aggregate Into Min()` cláusula se traduz em uma invocação de <xref:System.Linq.Enumerable.Min%2A>.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como usar <xref:System.Linq.Enumerable.Min%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Int32%7D%29> para determinar o valor mínimo em uma sequência de valores projetados.  
  
 [!INCLUDE[sqo_diff_overload_example_func](~/includes/sqo-diff-overload-example-func-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#68](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#68)]
 [!code-vb[System.Linq.Enumerable#68](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#68)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> ou <paramref name="selector" /> é <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="source" /> não contém elementos.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/1315a814-5db6-4077-b34b-b141e11cc0eb">Cláusula Aggregate (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Min&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static Nullable&lt;decimal&gt; Min&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,Nullable&lt;decimal&gt;&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;valuetype System.Decimal&gt; Min&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, valuetype System.Nullable`1&lt;valuetype System.Decimal&gt;&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Min``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Nullable{System.Decimal}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Min(Of TSource) (source As IEnumerable(Of TSource), selector As Func(Of TSource, Nullable(Of Decimal))) As Nullable(Of Decimal)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Nullable&lt;System::Decimal&gt; Min(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Func&lt;TSource, Nullable&lt;System::Decimal&gt;&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="static member Min : seq&lt;'Source&gt; * Func&lt;'Source, Nullable&lt;decimal&gt;&gt; -&gt; Nullable&lt;decimal&gt;" Usage="System.Linq.Enumerable.Min (source, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Decimal&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Nullable&lt;System.Decimal&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">O tipo dos elementos de <paramref name="source" />.</typeparam>
        <param name="source">Uma sequência de valores para determinação do valor mínimo.</param>
        <param name="selector">Uma função de transformação a ser aplicada a cada elemento.</param>
        <summary>Invoca uma função de transformação em cada elemento de uma sequência e retorna o valor <see cref="T:System.Decimal" /> mínimo que permite valor nulo.</summary>
        <returns>O valor do tipo <c>Nullable&lt;Decimal&gt;</c> em C# ou <c>Nullable(Of Decimal)</c> no Visual Basic que corresponde ao valor mínimo na sequência.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Linq.Enumerable.Min%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Nullable%7BSystem.Decimal%7D%7D%29> usa o <xref:System.Decimal> implementação de <xref:System.IComparable%601> para comparar valores.  
  
 Você pode aplicar esse método em uma sequência de valores arbitrários, se você fornecer uma função `selector`, que os membros de projetos `source` em um tipo numérico, especificamente `Nullable<Decimal>` em c# ou `Nullable(Of Decimal)` no Visual Basic.  
  
 Na sintaxe de expressão de consulta do Visual Basic, uma `Aggregate Into Min()` cláusula se traduz em uma invocação de <xref:System.Linq.Enumerable.Min%2A>.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como usar <xref:System.Linq.Enumerable.Min%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Int32%7D%29> para determinar o valor mínimo em uma sequência de valores projetados.  
  
 [!INCLUDE[sqo_diff_overload_example_func](~/includes/sqo-diff-overload-example-func-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#68](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#68)]
 [!code-vb[System.Linq.Enumerable#68](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#68)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> ou <paramref name="selector" /> é <see langword="null" />.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/1315a814-5db6-4077-b34b-b141e11cc0eb">Cláusula Aggregate (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Min&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static Nullable&lt;double&gt; Min&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,Nullable&lt;double&gt;&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;float64&gt; Min&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, valuetype System.Nullable`1&lt;float64&gt;&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Min``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Nullable{System.Double}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Min(Of TSource) (source As IEnumerable(Of TSource), selector As Func(Of TSource, Nullable(Of Double))) As Nullable(Of Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Nullable&lt;double&gt; Min(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Func&lt;TSource, Nullable&lt;double&gt;&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="static member Min : seq&lt;'Source&gt; * Func&lt;'Source, Nullable&lt;double&gt;&gt; -&gt; Nullable&lt;double&gt;" Usage="System.Linq.Enumerable.Min (source, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Double&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Nullable&lt;System.Double&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">O tipo dos elementos de <paramref name="source" />.</typeparam>
        <param name="source">Uma sequência de valores para determinação do valor mínimo.</param>
        <param name="selector">Uma função de transformação a ser aplicada a cada elemento.</param>
        <summary>Invoca uma função de transformação em cada elemento de uma sequência e retorna o valor <see cref="T:System.Double" /> mínimo que permite valor nulo.</summary>
        <returns>O valor do tipo <c>Nullable&lt;Double&gt;</c> em C# ou <c>Nullable(Of Double)</c> no Visual Basic que corresponde ao valor mínimo na sequência.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Linq.Enumerable.Min%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Nullable%7BSystem.Double%7D%7D%29> usa o <xref:System.Double> implementação de <xref:System.IComparable%601> para comparar valores.  
  
 Você pode aplicar esse método em uma sequência de valores arbitrários, se você fornecer uma função `selector`, que os membros de projetos `source` em um tipo numérico, especificamente `Nullable<Double>` em c# ou `Nullable(Of Double)` no Visual Basic.  
  
 Na sintaxe de expressão de consulta do Visual Basic, uma `Aggregate Into Min()` cláusula se traduz em uma invocação de <xref:System.Linq.Enumerable.Min%2A>.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como usar <xref:System.Linq.Enumerable.Min%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Int32%7D%29> para determinar o valor mínimo em uma sequência de valores projetados.  
  
 [!INCLUDE[sqo_diff_overload_example_func](~/includes/sqo-diff-overload-example-func-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#68](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#68)]
 [!code-vb[System.Linq.Enumerable#68](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#68)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> ou <paramref name="selector" /> é <see langword="null" />.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/1315a814-5db6-4077-b34b-b141e11cc0eb">Cláusula Aggregate (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Min&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static Nullable&lt;int&gt; Min&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,Nullable&lt;int&gt;&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;int32&gt; Min&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, valuetype System.Nullable`1&lt;int32&gt;&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Min``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Nullable{System.Int32}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Min(Of TSource) (source As IEnumerable(Of TSource), selector As Func(Of TSource, Nullable(Of Integer))) As Nullable(Of Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Nullable&lt;int&gt; Min(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Func&lt;TSource, Nullable&lt;int&gt;&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="static member Min : seq&lt;'Source&gt; * Func&lt;'Source, Nullable&lt;int&gt;&gt; -&gt; Nullable&lt;int&gt;" Usage="System.Linq.Enumerable.Min (source, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Nullable&lt;System.Int32&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">O tipo dos elementos de <paramref name="source" />.</typeparam>
        <param name="source">Uma sequência de valores para determinação do valor mínimo.</param>
        <param name="selector">Uma função de transformação a ser aplicada a cada elemento.</param>
        <summary>Invoca uma função de transformação em cada elemento de uma sequência e retorna o valor <see cref="T:System.Int32" /> mínimo que permite valor nulo.</summary>
        <returns>O valor do tipo <c>Nullable&lt;Int32&gt;</c> em C# ou <c>Nullable(Of Int32)</c> no Visual Basic que corresponde ao valor mínimo na sequência.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Linq.Enumerable.Min%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Nullable%7BSystem.Int32%7D%7D%29> usa o <xref:System.Int32> implementação de <xref:System.IComparable%601> para comparar valores.  
  
 Você pode aplicar esse método em uma sequência de valores arbitrários, se você fornecer uma função `selector`, que projeta os membros de origem em um tipo numérico, especificamente `Nullable<Int32>` em c# ou `Nullable(Of Int32)` no Visual Basic.  
  
 Na sintaxe de expressão de consulta do Visual Basic, uma `Aggregate Into Min()` cláusula se traduz em uma invocação de <xref:System.Linq.Enumerable.Min%2A>.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como usar <xref:System.Linq.Enumerable.Min%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Int32%7D%29> para determinar o valor mínimo em uma sequência de valores projetados.  
  
 [!INCLUDE[sqo_diff_overload_example_func](~/includes/sqo-diff-overload-example-func-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#68](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#68)]
 [!code-vb[System.Linq.Enumerable#68](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#68)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> ou <paramref name="selector" /> é <see langword="null" />.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/1315a814-5db6-4077-b34b-b141e11cc0eb">Cláusula Aggregate (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Min&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static Nullable&lt;long&gt; Min&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,Nullable&lt;long&gt;&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;int64&gt; Min&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, valuetype System.Nullable`1&lt;int64&gt;&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Min``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Nullable{System.Int64}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Min(Of TSource) (source As IEnumerable(Of TSource), selector As Func(Of TSource, Nullable(Of Long))) As Nullable(Of Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Nullable&lt;long&gt; Min(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Func&lt;TSource, Nullable&lt;long&gt;&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="static member Min : seq&lt;'Source&gt; * Func&lt;'Source, Nullable&lt;int64&gt;&gt; -&gt; Nullable&lt;int64&gt;" Usage="System.Linq.Enumerable.Min (source, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Int64&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Nullable&lt;System.Int64&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">O tipo dos elementos de <paramref name="source" />.</typeparam>
        <param name="source">Uma sequência de valores para determinação do valor mínimo.</param>
        <param name="selector">Uma função de transformação a ser aplicada a cada elemento.</param>
        <summary>Invoca uma função de transformação em cada elemento de uma sequência e retorna o valor <see cref="T:System.Int64" /> mínimo que permite valor nulo.</summary>
        <returns>O valor do tipo <c>Nullable&lt;Int64&gt;</c> em C# ou <c>Nullable(Of Int64)</c> no Visual Basic que corresponde ao valor mínimo na sequência.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Linq.Enumerable.Min%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Nullable%7BSystem.Int64%7D%7D%29> usa o <xref:System.Int64> implementação de <xref:System.IComparable%601> para comparar valores.  
  
 Você pode aplicar esse método em uma sequência de valores arbitrários, se você fornecer uma função `selector`, que os membros de projetos `source` em um tipo numérico, especificamente `Nullable<Int64>` em c# ou `Nullable(Of Int64)` no Visual Basic.  
  
 Na sintaxe de expressão de consulta do Visual Basic, uma `Aggregate Into Min()` cláusula se traduz em uma invocação de <xref:System.Linq.Enumerable.Min%2A>.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como usar <xref:System.Linq.Enumerable.Min%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Int32%7D%29> para determinar o valor mínimo em uma sequência de valores projetados.  
  
 [!INCLUDE[sqo_diff_overload_example_func](~/includes/sqo-diff-overload-example-func-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#68](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#68)]
 [!code-vb[System.Linq.Enumerable#68](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#68)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> ou <paramref name="selector" /> é <see langword="null" />.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/1315a814-5db6-4077-b34b-b141e11cc0eb">Cláusula Aggregate (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Min&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static Nullable&lt;float&gt; Min&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,Nullable&lt;float&gt;&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;float32&gt; Min&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, valuetype System.Nullable`1&lt;float32&gt;&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Min``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Nullable{System.Single}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Min(Of TSource) (source As IEnumerable(Of TSource), selector As Func(Of TSource, Nullable(Of Single))) As Nullable(Of Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Nullable&lt;float&gt; Min(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Func&lt;TSource, Nullable&lt;float&gt;&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="static member Min : seq&lt;'Source&gt; * Func&lt;'Source, Nullable&lt;single&gt;&gt; -&gt; Nullable&lt;single&gt;" Usage="System.Linq.Enumerable.Min (source, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Single&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Nullable&lt;System.Single&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">O tipo dos elementos de <paramref name="source" />.</typeparam>
        <param name="source">Uma sequência de valores para determinação do valor mínimo.</param>
        <param name="selector">Uma função de transformação a ser aplicada a cada elemento.</param>
        <summary>Invoca uma função de transformação em cada elemento de uma sequência e retorna o valor <see cref="T:System.Single" /> mínimo que permite valor nulo.</summary>
        <returns>O valor do tipo <c>Nullable&lt;Single&gt;</c> em C# ou <c>Nullable(Of Single)</c> no Visual Basic que corresponde ao valor mínimo na sequência.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Linq.Enumerable.Min%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Nullable%7BSystem.Single%7D%7D%29> usa o <xref:System.Single> implementação de <xref:System.IComparable%601> para comparar valores.  
  
 Você pode aplicar esse método em uma sequência de valores arbitrários, se você fornecer uma função `selector`, que os membros de projetos `source` em um tipo numérico, especificamente `Nullable<Single>` em c# ou `Nullable(Of Single)` no Visual Basic.  
  
 Na sintaxe de expressão de consulta do Visual Basic, uma `Aggregate Into Min()` cláusula se traduz em uma invocação de <xref:System.Linq.Enumerable.Min%2A>.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como usar <xref:System.Linq.Enumerable.Min%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Int32%7D%29> para determinar o valor mínimo em uma sequência de valores projetados.  
  
 [!INCLUDE[sqo_diff_overload_example_func](~/includes/sqo-diff-overload-example-func-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#68](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#68)]
 [!code-vb[System.Linq.Enumerable#68](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#68)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> ou <paramref name="selector" /> é <see langword="null" />.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/1315a814-5db6-4077-b34b-b141e11cc0eb">Cláusula Aggregate (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Min&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static float Min&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,float&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 Min&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, float32&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Min``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Single})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Min(Of TSource) (source As IEnumerable(Of TSource), selector As Func(Of TSource, Single)) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static float Min(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Func&lt;TSource, float&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="static member Min : seq&lt;'Source&gt; * Func&lt;'Source, single&gt; -&gt; single" Usage="System.Linq.Enumerable.Min (source, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Single&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">O tipo dos elementos de <paramref name="source" />.</typeparam>
        <param name="source">Uma sequência de valores para determinação do valor mínimo.</param>
        <param name="selector">Uma função de transformação a ser aplicada a cada elemento.</param>
        <summary>Invoca uma função de transformação em cada elemento de uma sequência e retorna o valor <see cref="T:System.Single" /> mínimo.</summary>
        <returns>O valor mínimo na sequência.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Linq.Enumerable.Min%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Single%7D%29> usa o <xref:System.Single> implementação de <xref:System.IComparable%601> para comparar valores.  
  
 Você pode aplicar esse método em uma sequência de valores arbitrários, se você fornecer uma função `selector`, que os membros de projetos `source` em um tipo numérico, especificamente <xref:System.Single>.  
  
 Na sintaxe de expressão de consulta do Visual Basic, uma `Aggregate Into Min()` cláusula se traduz em uma invocação de <xref:System.Linq.Enumerable.Min%2A>.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como usar <xref:System.Linq.Enumerable.Min%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Int32%7D%29> para determinar o valor mínimo em uma sequência de valores projetados.  
  
 [!INCLUDE[sqo_diff_overload_example_func](~/includes/sqo-diff-overload-example-func-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#68](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#68)]
 [!code-vb[System.Linq.Enumerable#68](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#68)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> ou <paramref name="selector" /> é <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="source" /> não contém elementos.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/1315a814-5db6-4077-b34b-b141e11cc0eb">Cláusula Aggregate (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Min&lt;TSource,TResult&gt;">
      <MemberSignature Language="C#" Value="public static TResult Min&lt;TSource,TResult&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,TResult&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TResult Min&lt;TSource, TResult&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, !!TResult&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Min``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Min(Of TSource, TResult) (source As IEnumerable(Of TSource), selector As Func(Of TSource, TResult)) As TResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TResult&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static TResult Min(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Func&lt;TSource, TResult&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="static member Min : seq&lt;'Source&gt; * Func&lt;'Source, 'Result&gt; -&gt; 'Result" Usage="System.Linq.Enumerable.Min (source, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,TResult&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">O tipo dos elementos de <paramref name="source" />.</typeparam>
        <typeparam name="TResult">O tipo do valor retornado por <paramref name="selector" />.</typeparam>
        <param name="source">Uma sequência de valores da qual será determinado o valor mínimo.</param>
        <param name="selector">Uma função de transformação a ser aplicada a cada elemento.</param>
        <summary>Invoca uma função de transformação em cada elemento de uma sequência genérica e retorna o menor valor resultante.</summary>
        <returns>O valor mínimo na sequência.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se tipo `TResult` implementa <xref:System.IComparable%601>, esse método usa essa implementação para comparar valores. Caso contrário, se tipo `TResult` implementa <xref:System.IComparable>, que a implementação é usada para comparar valores.  
  
 Na sintaxe de expressão de consulta do Visual Basic, uma `Aggregate Into Min()` cláusula se traduz em uma invocação de <xref:System.Linq.Enumerable.Min%2A>.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como usar <xref:System.Linq.Enumerable.Min%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Int32%7D%29> para determinar o valor mínimo em uma sequência de valores projetados.  
  
 [!INCLUDE[sqo_diff_overload_example_func](~/includes/sqo-diff-overload-example-func-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#68](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#68)]
 [!code-vb[System.Linq.Enumerable#68](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#68)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> ou <paramref name="selector" /> é <see langword="null" />.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/1315a814-5db6-4077-b34b-b141e11cc0eb">Cláusula Aggregate (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="OfType&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;TResult&gt; OfType&lt;TResult&gt; (this System.Collections.IEnumerable source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;!!TResult&gt; OfType&lt;TResult&gt;(class System.Collections.IEnumerable source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.OfType``1(System.Collections.IEnumerable)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function OfType(Of TResult) (source As IEnumerable) As IEnumerable(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Collections::Generic::IEnumerable&lt;TResult&gt; ^ OfType(System::Collections::IEnumerable ^ source);" />
      <MemberSignature Language="F#" Value="static member OfType : System.Collections.IEnumerable -&gt; seq&lt;'Result&gt;" Usage="System.Linq.Enumerable.OfType source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.IEnumerable" RefType="this" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">O tipo no qual filtrar os elementos da sequência.</typeparam>
        <param name="source">O <see cref="T:System.Collections.IEnumerable" /> cujos elementos serão filtrados.</param>
        <summary>Filtra os elementos de um <see cref="T:System.Collections.IEnumerable" /> com base em um tipo especificado.</summary>
        <returns>Um <see cref="T:System.Collections.Generic.IEnumerable`1" /> que contém elementos da sequência de entrada de tipo <paramref name="TResult" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método é implementado usando a execução adiada. O imediata valor retornado é um objeto que armazena todas as informações necessárias para executar a ação. A consulta representada por esse método não é executada até que o objeto é enumerado chamando-se suas `GetEnumerator` método diretamente ou usando `foreach` no Visual c# ou `For Each` no Visual Basic.  
  
 O <xref:System.Linq.Enumerable.OfType%60%601%28System.Collections.IEnumerable%29> método retorna apenas os elementos no `source` que pode ser convertido no tipo `TResult`. Em vez disso, receba uma exceção se um elemento não pode ser convertido para o tipo `TResult`, use <xref:System.Linq.Enumerable.Cast%60%601%28System.Collections.IEnumerable%29>.  
  
 Esse método é um dos alguns métodos de operador de consulta padrão que podem ser aplicados a uma coleção que tem um tipo sem parâmetros, como um <xref:System.Collections.ArrayList>. Isso ocorre porque <xref:System.Linq.Enumerable.OfType%2A> estende o tipo <xref:System.Collections.IEnumerable>. <xref:System.Linq.Enumerable.OfType%2A> não pode ser aplicado somente às coleções que são baseadas em com os parâmetros <xref:System.Collections.Generic.IEnumerable%601> tipo, mas as coleções que se baseiam os sem parâmetros <xref:System.Collections.IEnumerable> tipo também.  
  
 Aplicando <xref:System.Linq.Enumerable.OfType%2A> em uma coleção que implementa <xref:System.Collections.IEnumerable>, você ganha a capacidade de consultar a coleção usando os operadores de consulta padrão. Por exemplo, especificar um argumento de tipo de <xref:System.Object> à <xref:System.Linq.Enumerable.OfType%2A> retornaria um objeto do tipo `IEnumerable<Object>` em c# ou `IEnumerable(Of Object)` no Visual Basic, para que os operadores de consulta padrão podem ser aplicados.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como usar <xref:System.Linq.Enumerable.OfType%2A> para filtrar os elementos de um <xref:System.Collections.IEnumerable>.  
  
 [!code-csharp[System.Linq.Enumerable#69](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#69)]
 [!code-vb[System.Linq.Enumerable#69](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#69)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="OrderBy&lt;TSource,TKey&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Classifica os elementos de uma sequência em ordem crescente.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="OrderBy&lt;TSource,TKey&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.IOrderedEnumerable&lt;TSource&gt; OrderBy&lt;TSource,TKey&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,TKey&gt; keySelector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.IOrderedEnumerable`1&lt;!!TSource&gt; OrderBy&lt;TSource, TKey&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, !!TKey&gt; keySelector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.OrderBy``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function OrderBy(Of TSource, TKey) (source As IEnumerable(Of TSource), keySelector As Func(Of TSource, TKey)) As IOrderedEnumerable(Of TSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TKey&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::IOrderedEnumerable&lt;TSource&gt; ^ OrderBy(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Func&lt;TSource, TKey&gt; ^ keySelector);" />
      <MemberSignature Language="F#" Value="static member OrderBy : seq&lt;'Source&gt; * Func&lt;'Source, 'Key&gt; -&gt; System.Linq.IOrderedEnumerable&lt;'Source&gt;" Usage="System.Linq.Enumerable.OrderBy (source, keySelector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.IOrderedEnumerable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TKey" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="keySelector" Type="System.Func&lt;TSource,TKey&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">O tipo dos elementos de <paramref name="source" />.</typeparam>
        <typeparam name="TKey">O tipo da chave retornada por <paramref name="keySelector" />.</typeparam>
        <param name="source">Uma sequência de valores a serem ordenados.</param>
        <param name="keySelector">Uma função para extrair uma chave de um elemento.</param>
        <summary>Classifica os elementos de uma sequência em ordem crescente de acordo com uma chave.</summary>
        <returns>Um <see cref="T:System.Linq.IOrderedEnumerable`1" /> cujos elementos são classificados de acordo com uma chave.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método é implementado usando a execução adiada. O imediata valor retornado é um objeto que armazena todas as informações necessárias para executar a ação. A consulta representada por esse método não é executada até que o objeto é enumerado chamando-se suas `GetEnumerator` método diretamente ou usando `foreach` no Visual c# ou `For Each` no Visual Basic.  
  
 Para solicitar uma sequência pelos valores dos próprios elementos, especifique a função identity (`x => x` no Visual c# ou `Function(x) x` no Visual Basic) para `keySelector`.  
  
 Dois métodos são definidos para estender o tipo <xref:System.Linq.IOrderedEnumerable%601>, que é o tipo de retorno desse método. Esses dois métodos, ou seja, `ThenBy` e `ThenByDescending`, permitem que você especifique os critérios adicionais de classificação para classificar uma sequência. `ThenBy` e `ThenByDescending` também retornam uma <xref:System.Linq.IOrderedEnumerable%601>, que significa que qualquer número de chamadas consecutivas para `ThenBy` ou `ThenByDescending` podem ser feitas.  
  
> [!NOTE]
>  Porque <xref:System.Linq.IOrderedEnumerable%601> herda <xref:System.Collections.Generic.IEnumerable%601>, você pode chamar <xref:System.Linq.Enumerable.OrderBy%2A> ou <xref:System.Linq.Enumerable.OrderByDescending%2A> nos resultados de uma chamada para <xref:System.Linq.Enumerable.OrderBy%2A>, <xref:System.Linq.Enumerable.OrderByDescending%2A>, <xref:System.Linq.Enumerable.ThenBy%2A> ou <xref:System.Linq.Enumerable.ThenByDescending%2A>. Isso apresenta um novo primário ordenação que ignora a ordem estabelecida anteriormente.  
  
 Esse método compara as chaves usando o comparador padrão <xref:System.Collections.Generic.Comparer%601.Default%2A>.  
  
 Esse método executa uma classificação estável; ou seja, se as chaves de dois elementos são iguais, a ordem dos elementos é preservada. Em contraste, uma classificação instável não preserva a ordem dos elementos que têm a mesma chave.  
  
 Na sintaxe de expressão de consulta, uma `orderby` (Visual c#) ou `Order By` cláusula (Visual Basic) se traduz em uma invocação de <xref:System.Linq.Enumerable.OrderBy%2A>.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como usar <xref:System.Linq.Enumerable.OrderBy%60%602%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2C%60%601%7D%29> para classificar os elementos de uma sequência.  
  
 [!code-csharp[System.Linq.Enumerable#70](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#70)]
 [!code-vb[System.Linq.Enumerable#70](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#70)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> ou <paramref name="keySelector" /> é <see langword="null" />.</exception>
        <altmember cref="M:System.Linq.Enumerable.OrderByDescending``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1})" />
        <altmember cref="M:System.Linq.Enumerable.OrderByDescending``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1},System.Collections.Generic.IComparer{``1})" />
        <related type="Article" href="https://msdn.microsoft.com/library/21f87f48-d69d-4e95-9a52-6fec47b37e1f">Cláusula orderby (Referência de C#)</related>
        <related type="Article" href="https://msdn.microsoft.com/library/fa911282-6b81-44c7-acfa-46b5bb93df75">Cláusula Order By (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="OrderBy&lt;TSource,TKey&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.IOrderedEnumerable&lt;TSource&gt; OrderBy&lt;TSource,TKey&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,TKey&gt; keySelector, System.Collections.Generic.IComparer&lt;TKey&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.IOrderedEnumerable`1&lt;!!TSource&gt; OrderBy&lt;TSource, TKey&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, !!TKey&gt; keySelector, class System.Collections.Generic.IComparer`1&lt;!!TKey&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.OrderBy``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1},System.Collections.Generic.IComparer{``1})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function OrderBy(Of TSource, TKey) (source As IEnumerable(Of TSource), keySelector As Func(Of TSource, TKey), comparer As IComparer(Of TKey)) As IOrderedEnumerable(Of TSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TKey&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::IOrderedEnumerable&lt;TSource&gt; ^ OrderBy(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Func&lt;TSource, TKey&gt; ^ keySelector, System::Collections::Generic::IComparer&lt;TKey&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="static member OrderBy : seq&lt;'Source&gt; * Func&lt;'Source, 'Key&gt; * System.Collections.Generic.IComparer&lt;'Key&gt; -&gt; System.Linq.IOrderedEnumerable&lt;'Source&gt;" Usage="System.Linq.Enumerable.OrderBy (source, keySelector, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.IOrderedEnumerable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TKey" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="keySelector" Type="System.Func&lt;TSource,TKey&gt;" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IComparer&lt;TKey&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">O tipo dos elementos de <paramref name="source" />.</typeparam>
        <typeparam name="TKey">O tipo da chave retornada por <paramref name="keySelector" />.</typeparam>
        <param name="source">Uma sequência de valores a serem ordenados.</param>
        <param name="keySelector">Uma função para extrair uma chave de um elemento.</param>
        <param name="comparer">Um <see cref="T:System.Collections.Generic.IComparer`1" /> para comparar chaves.</param>
        <summary>Classifica os elementos de uma sequência em ordem crescente usando um comparador especificado.</summary>
        <returns>Um <see cref="T:System.Linq.IOrderedEnumerable`1" /> cujos elementos são classificados de acordo com uma chave.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método é implementado usando a execução adiada. O imediata valor retornado é um objeto que armazena todas as informações necessárias para executar a ação. A consulta representada por esse método não é executada até que o objeto é enumerado chamando-se suas `GetEnumerator` método diretamente ou usando `foreach` no Visual c# ou `For Each` no Visual Basic.  
  
 Para solicitar uma sequência pelos valores dos próprios elementos, especifique a função identity (`x => x` no Visual c# ou `Function(x) x` no Visual Basic) para `keySelector`.  
  
 Dois métodos são definidos para estender o tipo <xref:System.Linq.IOrderedEnumerable%601>, que é o tipo de retorno desse método. Esses dois métodos, ou seja, `ThenBy` e `ThenByDescending`, permitem que você especifique os critérios adicionais de classificação para classificar uma sequência. `ThenBy` e `ThenByDescending` também retornam uma <xref:System.Linq.IOrderedEnumerable%601>, que significa que qualquer número de chamadas consecutivas para `ThenBy` ou `ThenByDescending` podem ser feitas.  
  
> [!NOTE]
>  Porque <xref:System.Linq.IOrderedEnumerable%601> herda <xref:System.Collections.Generic.IEnumerable%601>, você pode chamar <xref:System.Linq.Enumerable.OrderBy%2A> ou <xref:System.Linq.Enumerable.OrderByDescending%2A> nos resultados de uma chamada para <xref:System.Linq.Enumerable.OrderBy%2A>, <xref:System.Linq.Enumerable.OrderByDescending%2A>, <xref:System.Linq.Enumerable.ThenBy%2A> ou <xref:System.Linq.Enumerable.ThenByDescending%2A>. Isso apresenta um novo primário ordenação que ignora a ordem estabelecida anteriormente.  
  
 Se `comparer` está `null`, o comparador padrão <xref:System.Collections.Generic.Comparer%601.Default%2A> é usado para comparar chaves.  
  
 Esse método executa uma classificação estável; ou seja, se as chaves de dois elementos são iguais, a ordem dos elementos é preservada. Em contraste, uma classificação instável não preserva a ordem dos elementos que têm a mesma chave.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> ou <paramref name="keySelector" /> é <see langword="null" />.</exception>
        <altmember cref="M:System.Linq.Enumerable.OrderByDescending``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1})" />
        <altmember cref="M:System.Linq.Enumerable.OrderByDescending``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1},System.Collections.Generic.IComparer{``1})" />
      </Docs>
    </Member>
    <MemberGroup MemberName="OrderByDescending&lt;TSource,TKey&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Classifica os elementos de uma sequência em ordem decrescente.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="OrderByDescending&lt;TSource,TKey&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.IOrderedEnumerable&lt;TSource&gt; OrderByDescending&lt;TSource,TKey&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,TKey&gt; keySelector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.IOrderedEnumerable`1&lt;!!TSource&gt; OrderByDescending&lt;TSource, TKey&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, !!TKey&gt; keySelector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.OrderByDescending``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function OrderByDescending(Of TSource, TKey) (source As IEnumerable(Of TSource), keySelector As Func(Of TSource, TKey)) As IOrderedEnumerable(Of TSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TKey&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::IOrderedEnumerable&lt;TSource&gt; ^ OrderByDescending(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Func&lt;TSource, TKey&gt; ^ keySelector);" />
      <MemberSignature Language="F#" Value="static member OrderByDescending : seq&lt;'Source&gt; * Func&lt;'Source, 'Key&gt; -&gt; System.Linq.IOrderedEnumerable&lt;'Source&gt;" Usage="System.Linq.Enumerable.OrderByDescending (source, keySelector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.IOrderedEnumerable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TKey" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="keySelector" Type="System.Func&lt;TSource,TKey&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">O tipo dos elementos de <paramref name="source" />.</typeparam>
        <typeparam name="TKey">O tipo da chave retornada por <paramref name="keySelector" />.</typeparam>
        <param name="source">Uma sequência de valores a serem ordenados.</param>
        <param name="keySelector">Uma função para extrair uma chave de um elemento.</param>
        <summary>Classifica os elementos de uma sequência em ordem decrescente de acordo com uma chave.</summary>
        <returns>Um <see cref="T:System.Linq.IOrderedEnumerable`1" /> cujos elementos são classificados em ordem decrescente de acordo com uma chave.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método é implementado usando a execução adiada. O imediata valor retornado é um objeto que armazena todas as informações necessárias para executar a ação. A consulta representada por esse método não é executada até que o objeto é enumerado chamando-se suas `GetEnumerator` método diretamente ou usando `foreach` no Visual c# ou `For Each` no Visual Basic.  
  
 Para solicitar uma sequência pelos valores dos próprios elementos, especifique a função identity (`x => x` no Visual c# ou `Function(x) x` no Visual Basic) para `keySelector`.  
  
 Para obter um exemplo desse método, consulte <xref:System.Linq.Enumerable.OrderByDescending%60%602%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2C%60%601%7D%2CSystem.Collections.Generic.IComparer%7B%60%601%7D%29>.  
  
 Dois métodos são definidos para estender o tipo <xref:System.Linq.IOrderedEnumerable%601>, que é o tipo de retorno desse método. Esses dois métodos, ou seja, `ThenBy` e `ThenByDescending`, permitem que você especifique os critérios adicionais de classificação para classificar uma sequência. `ThenBy` e `ThenByDescending` também retornam uma <xref:System.Linq.IOrderedEnumerable%601>, que significa que qualquer número de chamadas consecutivas para `ThenBy` ou `ThenByDescending` podem ser feitas.  
  
> [!NOTE]
>  Porque <xref:System.Linq.IOrderedEnumerable%601> herda <xref:System.Collections.Generic.IEnumerable%601>, você pode chamar <xref:System.Linq.Enumerable.OrderBy%2A> ou <xref:System.Linq.Enumerable.OrderByDescending%2A> nos resultados de uma chamada para <xref:System.Linq.Enumerable.OrderBy%2A>, <xref:System.Linq.Enumerable.OrderByDescending%2A>, <xref:System.Linq.Enumerable.ThenBy%2A> ou <xref:System.Linq.Enumerable.ThenByDescending%2A>. Isso apresenta um novo primário ordenação que ignora a ordem estabelecida anteriormente.  
  
 Esse método compara as chaves usando o comparador padrão <xref:System.Collections.Generic.Comparer%601.Default%2A>.  
  
 Esse método executa uma classificação estável; ou seja, se as chaves de dois elementos são iguais, a ordem dos elementos é preservada. Em contraste, uma classificação instável não preserva a ordem dos elementos que têm a mesma chave.  
  
 Na sintaxe de expressão de consulta, uma `orderby descending` (Visual c#) ou `Order By Descending` cláusula (Visual Basic) se traduz em uma invocação de <xref:System.Linq.Enumerable.OrderByDescending%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> ou <paramref name="keySelector" /> é <see langword="null" />.</exception>
        <altmember cref="M:System.Linq.Enumerable.OrderBy``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1})" />
        <altmember cref="M:System.Linq.Enumerable.OrderBy``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1},System.Collections.Generic.IComparer{``1})" />
        <related type="Article" href="https://msdn.microsoft.com/library/21f87f48-d69d-4e95-9a52-6fec47b37e1f">Cláusula orderby (Referência de C#)</related>
        <related type="Article" href="https://msdn.microsoft.com/library/fa911282-6b81-44c7-acfa-46b5bb93df75">Cláusula Order By (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="OrderByDescending&lt;TSource,TKey&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.IOrderedEnumerable&lt;TSource&gt; OrderByDescending&lt;TSource,TKey&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,TKey&gt; keySelector, System.Collections.Generic.IComparer&lt;TKey&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.IOrderedEnumerable`1&lt;!!TSource&gt; OrderByDescending&lt;TSource, TKey&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, !!TKey&gt; keySelector, class System.Collections.Generic.IComparer`1&lt;!!TKey&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.OrderByDescending``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1},System.Collections.Generic.IComparer{``1})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function OrderByDescending(Of TSource, TKey) (source As IEnumerable(Of TSource), keySelector As Func(Of TSource, TKey), comparer As IComparer(Of TKey)) As IOrderedEnumerable(Of TSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TKey&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::IOrderedEnumerable&lt;TSource&gt; ^ OrderByDescending(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Func&lt;TSource, TKey&gt; ^ keySelector, System::Collections::Generic::IComparer&lt;TKey&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="static member OrderByDescending : seq&lt;'Source&gt; * Func&lt;'Source, 'Key&gt; * System.Collections.Generic.IComparer&lt;'Key&gt; -&gt; System.Linq.IOrderedEnumerable&lt;'Source&gt;" Usage="System.Linq.Enumerable.OrderByDescending (source, keySelector, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.IOrderedEnumerable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TKey" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="keySelector" Type="System.Func&lt;TSource,TKey&gt;" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IComparer&lt;TKey&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">O tipo dos elementos de <paramref name="source" />.</typeparam>
        <typeparam name="TKey">O tipo da chave retornada por <paramref name="keySelector" />.</typeparam>
        <param name="source">Uma sequência de valores a serem ordenados.</param>
        <param name="keySelector">Uma função para extrair uma chave de um elemento.</param>
        <param name="comparer">Um <see cref="T:System.Collections.Generic.IComparer`1" /> para comparar chaves.</param>
        <summary>Classifica os elementos de uma sequência em ordem decrescente usando um comparador especificado.</summary>
        <returns>Um <see cref="T:System.Linq.IOrderedEnumerable`1" /> cujos elementos são classificados em ordem decrescente de acordo com uma chave.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método é implementado usando a execução adiada. O imediata valor retornado é um objeto que armazena todas as informações necessárias para executar a ação. A consulta representada por esse método não é executada até que o objeto é enumerado chamando-se suas `GetEnumerator` método diretamente ou usando `foreach` no Visual c# ou `For Each` no Visual Basic.  
  
 Para solicitar uma sequência pelos valores dos próprios elementos, especifique a função identity (`x => x` no Visual c# ou `Function(x) x` no Visual Basic) para `keySelector`.  
  
 Dois métodos são definidos para estender o tipo <xref:System.Linq.IOrderedEnumerable%601>, que é o tipo de retorno desse método. Esses dois métodos, ou seja, `ThenBy` e `ThenByDescending`, permitem que você especifique os critérios adicionais de classificação para classificar uma sequência. `ThenBy` e `ThenByDescending` também retornam uma <xref:System.Linq.IOrderedEnumerable%601>, que significa que qualquer número de chamadas consecutivas para `ThenBy` ou `ThenByDescending` podem ser feitas.  
  
> [!NOTE]
>  Porque <xref:System.Linq.IOrderedEnumerable%601> herda <xref:System.Collections.Generic.IEnumerable%601>, você pode chamar <xref:System.Linq.Enumerable.OrderBy%2A> ou <xref:System.Linq.Enumerable.OrderByDescending%2A> nos resultados de uma chamada para <xref:System.Linq.Enumerable.OrderBy%2A>, <xref:System.Linq.Enumerable.OrderByDescending%2A>, <xref:System.Linq.Enumerable.ThenBy%2A> ou <xref:System.Linq.Enumerable.ThenByDescending%2A>. Isso apresenta um novo primário ordenação que ignora a ordem estabelecida anteriormente.  
  
 Se `comparer` está `null`, o comparador padrão <xref:System.Collections.Generic.Comparer%601.Default%2A> é usado para comparar chaves.  
  
 Esse método executa uma classificação estável; ou seja, se as chaves de dois elementos são iguais, a ordem dos elementos é preservada. Em contraste, uma classificação instável não preserva a ordem dos elementos que têm a mesma chave.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como usar <xref:System.Linq.Enumerable.OrderByDescending%60%602%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2C%60%601%7D%2CSystem.Collections.Generic.IComparer%7B%60%601%7D%29> para classificar os elementos de uma sequência em ordem decrescente usando uma função de transformação e um comparador personalizado.  
  
 [!code-csharp[System.Linq.Enumerable#71](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#71)]
 [!code-vb[System.Linq.Enumerable#71](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#71)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> ou <paramref name="keySelector" /> é <see langword="null" />.</exception>
        <altmember cref="M:System.Linq.Enumerable.OrderBy``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1})" />
        <altmember cref="M:System.Linq.Enumerable.OrderBy``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1},System.Collections.Generic.IComparer{``1})" />
      </Docs>
    </Member>
    <Member MemberName="Prepend&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;TSource&gt; Prepend&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, TSource element);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; Prepend&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, !!TSource element) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Prepend``1(System.Collections.Generic.IEnumerable{``0},``0)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Prepend(Of TSource) (source As IEnumerable(Of TSource), element As TSource) As IEnumerable(Of TSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ Prepend(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, TSource element);" />
      <MemberSignature Language="F#" Value="static member Prepend : seq&lt;'Source&gt; * 'Source -&gt; seq&lt;'Source&gt;" Usage="System.Linq.Enumerable.Prepend (source, element)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netstandard-2.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="element" Type="TSource" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">O tipo dos elementos de <paramref name="source" />.</typeparam>
        <param name="source">Uma sequência de valores.</param>
        <param name="element">O valor a ser precedido a <paramref name="source" />.</param>
        <summary>Adiciona um valor ao início da sequência.</summary>
        <returns>Uma nova sequência que começa com <paramref name="element" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[    
          
## Remarks  
  
> [!NOTE]
>  Esse método não modifica os elementos da coleção. Em vez disso, ele cria uma cópia da coleção com o novo elemento.
  
## Examples  
 O exemplo de código a seguir demonstra como usar <xref:System.Linq.Enumerable.Prepend%2A> preceder um valor para o início da sequência.  
  
 [!code-csharp[System.Linq.Enumerable#202](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#202)]
 [!code-vb[System.Linq.Enumerable#202](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#202)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Range">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;int&gt; Range (int start, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;int32&gt; Range(int32 start, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Range(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Range (start As Integer, count As Integer) As IEnumerable(Of Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Collections::Generic::IEnumerable&lt;int&gt; ^ Range(int start, int count);" />
      <MemberSignature Language="F#" Value="static member Range : int * int -&gt; seq&lt;int&gt;" Usage="System.Linq.Enumerable.Range (start, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="start" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="start">O valor do primeiro inteiro na sequência.</param>
        <param name="count">O número de inteiros sequenciais a serem gerados.</param>
        <summary>Gera uma sequência de números integrais dentro de um intervalo especificado.</summary>
        <returns>Um <c>IEnumerable&lt;Int32&gt;</c> em C# ou <c>IEnumerable(Of Int32)</c> no Visual Basic que contém um intervalo de números inteiros sequenciais.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método é implementado usando a execução adiada. O imediata valor retornado é um objeto que armazena todas as informações necessárias para executar a ação. A consulta representada por esse método não é executada até que o objeto é enumerado chamando-se suas `GetEnumerator` método diretamente ou usando `foreach` no Visual c# ou `For Each` no Visual Basic.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como usar <xref:System.Linq.Enumerable.Range%2A> para gerar uma sequência de valores.  
  
 [!code-csharp[System.Linq.Enumerable#72](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#72)]
 [!code-vb[System.Linq.Enumerable#72](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#72)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="count" /> é menor que 0.  
  
- ou - 
 <paramref name="start" /> + <paramref name="count" /> -1 é maior que <see cref="F:System.Int32.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Repeat&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;TResult&gt; Repeat&lt;TResult&gt; (TResult element, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;!!TResult&gt; Repeat&lt;TResult&gt;(!!TResult element, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Repeat``1(``0,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Repeat(Of TResult) (element As TResult, count As Integer) As IEnumerable(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; static System::Collections::Generic::IEnumerable&lt;TResult&gt; ^ Repeat(TResult element, int count);" />
      <MemberSignature Language="F#" Value="static member Repeat : 'Result * int -&gt; seq&lt;'Result&gt;" Usage="System.Linq.Enumerable.Repeat (element, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="element" Type="TResult" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">O tipo do valor a ser repetido na sequência de resultado.</typeparam>
        <param name="element">O valor a ser repetido.</param>
        <param name="count">O número de vezes para repetir o valor na sequência gerada.</param>
        <summary>Gera uma sequência que contém um valor repetido.</summary>
        <returns>Um <see cref="T:System.Collections.Generic.IEnumerable`1" /> que contém um valor repetido.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método é implementado usando a execução adiada. O imediata valor retornado é um objeto que armazena todas as informações necessárias para executar a ação. A consulta representada por esse método não é executada até que o objeto é enumerado chamando-se suas `GetEnumerator` método diretamente ou usando `foreach` no Visual c# ou `For Each` no Visual Basic.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como usar <xref:System.Linq.Enumerable.Repeat%2A> para gerar uma sequência de um valor repetido.  
  
 [!code-csharp[System.Linq.Enumerable#73](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#73)]
 [!code-vb[System.Linq.Enumerable#73](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#73)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="count" /> é menor que 0.</exception>
      </Docs>
    </Member>
    <Member MemberName="Reverse&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;TSource&gt; Reverse&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; Reverse&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Reverse``1(System.Collections.Generic.IEnumerable{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Reverse(Of TSource) (source As IEnumerable(Of TSource)) As IEnumerable(Of TSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ Reverse(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Reverse : seq&lt;'Source&gt; -&gt; seq&lt;'Source&gt;" Usage="System.Linq.Enumerable.Reverse source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">O tipo dos elementos de <paramref name="source" />.</typeparam>
        <param name="source">Uma sequência de valores a ser revertida.</param>
        <summary>Inverte a ordem dos elementos em uma sequência.</summary>
        <returns>Uma sequência cujos elementos correspondem aos elementos da sequência de entrada em ordem inversa.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método é implementado usando a execução adiada. O imediata valor retornado é um objeto que armazena todas as informações necessárias para executar a ação. A consulta representada por esse método não é executada até que o objeto é enumerado chamando-se suas `GetEnumerator` método diretamente ou usando `foreach` no Visual c# ou `For Each` no Visual Basic.  
  
 Ao contrário de <xref:System.Linq.Enumerable.OrderBy%2A>, esse método de classificação não considera os valores reais em si determinar a ordem. Em vez disso, ele retorna apenas os elementos na ordem inversa da qual eles são produzidos pela fonte subjacente.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como usar <xref:System.Linq.Enumerable.Reverse%2A> para inverter a ordem dos elementos em uma matriz.  
  
 [!code-csharp[System.Linq.Enumerable#74](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#74)]
 [!code-vb[System.Linq.Enumerable#74](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#74)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Select&lt;TSource,TResult&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Projeta cada elemento de uma sequência em um novo formulário.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Select&lt;TSource,TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;TResult&gt; Select&lt;TSource,TResult&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,int,TResult&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;!!TResult&gt; Select&lt;TSource, TResult&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`3&lt;!!TSource, int32, !!TResult&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Select``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Int32,``1})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Select(Of TSource, TResult) (source As IEnumerable(Of TSource), selector As Func(Of TSource, Integer, TResult)) As IEnumerable(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TResult&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Collections::Generic::IEnumerable&lt;TResult&gt; ^ Select(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Func&lt;TSource, int, TResult&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="static member Select : seq&lt;'Source&gt; * Func&lt;'Source, int, 'Result&gt; -&gt; seq&lt;'Result&gt;" Usage="System.Linq.Enumerable.Select (source, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Int32,TResult&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">O tipo dos elementos de <paramref name="source" />.</typeparam>
        <typeparam name="TResult">O tipo do valor retornado por <paramref name="selector" />.</typeparam>
        <param name="source">Uma sequência de valores na qual uma função de transformação será invocada.</param>
        <param name="selector">Uma função de transformação para aplicar a cada elemento de origem; o segundo parâmetro da função representa o índice do elemento de origem.</param>
        <summary>Projeta cada elemento de uma sequência em um novo formulário, incorporando o índice do elemento.</summary>
        <returns>Um <see cref="T:System.Collections.Generic.IEnumerable`1" /> cujos elementos são o resultado da invocação da função de transformação em cada elemento de <paramref name="source" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método é implementado usando a execução adiada. O imediata valor retornado é um objeto que armazena todas as informações necessárias para executar a ação. A consulta representada por esse método não é executada até que o objeto é enumerado chamando-se suas `GetEnumerator` método diretamente ou usando `foreach` no Visual c# ou `For Each` no Visual Basic.  
  
 O primeiro argumento para `selector` representa o elemento para processar. O segundo argumento para `selector` representa o índice baseado em zero do elemento na sequência de origem. Isso pode ser útil se os elementos estão em uma ordem conhecida e você deseja fazer algo com um elemento em um índice específico, por exemplo. Ele também pode ser útil se você quiser recuperar o índice de um ou mais elementos.  
  
 Esse método de projeção requer que a função de transformação `selector`, para produzir um valor para cada valor na sequência de origem, `source`. Se `selector` retorna um valor que é uma coleção, é responsabilidade do consumidor para percorrer as subsequências manualmente. Nessa situação, talvez seja melhor para a sua consulta retornar uma única sequência conciliada de valores. Para fazer isso, use o <xref:System.Linq.Enumerable.SelectMany%2A> método em vez de <xref:System.Linq.Enumerable.Select%2A>. Embora `SelectMany` funciona da mesma forma que `Select`, ele é diferente em que a função de transformação retorna uma coleção que, em seguida, é expandida por `SelectMany` antes de ser retornado.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como usar <xref:System.Linq.Enumerable.Select%60%602%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Int32%2C%60%601%7D%29> em uma sequência de valores de projeto e usar o índice de cada elemento.  
  
 [!code-csharp[System.Linq.Enumerable#76](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#76)]
 [!code-vb[System.Linq.Enumerable#76](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#76)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> ou <paramref name="selector" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Select&lt;TSource,TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;TResult&gt; Select&lt;TSource,TResult&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,TResult&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;!!TResult&gt; Select&lt;TSource, TResult&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, !!TResult&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Select``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Select(Of TSource, TResult) (source As IEnumerable(Of TSource), selector As Func(Of TSource, TResult)) As IEnumerable(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TResult&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Collections::Generic::IEnumerable&lt;TResult&gt; ^ Select(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Func&lt;TSource, TResult&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="static member Select : seq&lt;'Source&gt; * Func&lt;'Source, 'Result&gt; -&gt; seq&lt;'Result&gt;" Usage="System.Linq.Enumerable.Select (source, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,TResult&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">O tipo dos elementos de <paramref name="source" />.</typeparam>
        <typeparam name="TResult">O tipo do valor retornado por <paramref name="selector" />.</typeparam>
        <param name="source">Uma sequência de valores na qual uma função de transformação será invocada.</param>
        <param name="selector">Uma função de transformação a ser aplicada a cada elemento.</param>
        <summary>Projeta cada elemento de uma sequência em um novo formulário.</summary>
        <returns>Um <see cref="T:System.Collections.Generic.IEnumerable`1" /> cujos elementos são o resultado da invocação da função de transformação em cada elemento de <paramref name="source" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método é implementado usando a execução adiada. O imediata valor retornado é um objeto que armazena todas as informações necessárias para executar a ação. A consulta representada por esse método não é executada até que o objeto é enumerado chamando-se suas `GetEnumerator` método diretamente ou usando `foreach` no Visual c# ou `For Each` no Visual Basic.  
  
 Esse método de projeção requer que a função de transformação `selector`, para produzir um valor para cada valor na sequência de origem, `source`. Se `selector` retorna um valor que é uma coleção, é responsabilidade do consumidor para percorrer as subsequências manualmente. Nessa situação, talvez seja melhor para a sua consulta retornar uma única sequência conciliada de valores. Para fazer isso, use o <xref:System.Linq.Enumerable.SelectMany%2A> método em vez de <xref:System.Linq.Enumerable.Select%2A>. Embora `SelectMany` funciona da mesma forma que `Select`, ele é diferente em que a função de transformação retorna uma coleção que, em seguida, é expandida por `SelectMany` antes de ser retornado.  
  
 Na sintaxe de expressão de consulta, uma `select` (Visual c#) ou `Select` cláusula (Visual Basic) se traduz em uma invocação de <xref:System.Linq.Enumerable.Select%2A>.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como usar <xref:System.Linq.Enumerable.Select%60%602%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2C%60%601%7D%29> ao projeto em uma sequência de valores.  
  
 [!code-csharp[System.Linq.Enumerable#75](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#75)]
 [!code-vb[System.Linq.Enumerable#75](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#75)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> ou <paramref name="selector" /> é <see langword="null" />.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/df01e266-5781-4aaa-80c4-67cf28ea093f">Cláusula select (Referência de C#)</related>
        <related type="Article" href="https://msdn.microsoft.com/library/27a3f61c-5960-4692-9b91-4d0c4b6178fe">Cláusula Select (Visual Basic)</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="SelectMany&lt;TSource,TResult&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Projeta cada elemento de uma sequência em um <see cref="T:System.Collections.Generic.IEnumerable`1" /> e nivela as sequências resultantes em uma sequência.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SelectMany&lt;TSource,TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;TResult&gt; SelectMany&lt;TSource,TResult&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,System.Collections.Generic.IEnumerable&lt;TResult&gt;&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;!!TResult&gt; SelectMany&lt;TSource, TResult&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, class System.Collections.Generic.IEnumerable`1&lt;!!TResult&gt;&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.SelectMany``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Collections.Generic.IEnumerable{``1}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function SelectMany(Of TSource, TResult) (source As IEnumerable(Of TSource), selector As Func(Of TSource, IEnumerable(Of TResult))) As IEnumerable(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TResult&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Collections::Generic::IEnumerable&lt;TResult&gt; ^ SelectMany(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Func&lt;TSource, System::Collections::Generic::IEnumerable&lt;TResult&gt; ^&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="static member SelectMany : seq&lt;'Source&gt; * Func&lt;'Source, seq&lt;'Result&gt;&gt; -&gt; seq&lt;'Result&gt;" Usage="System.Linq.Enumerable.SelectMany (source, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Collections.Generic.IEnumerable&lt;TResult&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">O tipo dos elementos de <paramref name="source" />.</typeparam>
        <typeparam name="TResult">O tipo dos elementos da sequência retornada por <paramref name="selector" />.</typeparam>
        <param name="source">Uma sequência de valores a serem projetados.</param>
        <param name="selector">Uma função de transformação a ser aplicada a cada elemento.</param>
        <summary>Projeta cada elemento de uma sequência em um <see cref="T:System.Collections.Generic.IEnumerable`1" /> e nivela as sequências resultantes em uma sequência.</summary>
        <returns>Um <see cref="T:System.Collections.Generic.IEnumerable`1" /> cujos elementos são resultado da invocação da função de transformação de um para muitos em cada elemento da sequência de entrada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método é implementado usando a execução adiada. O imediata valor retornado é um objeto que armazena todas as informações necessárias para executar a ação. A consulta representada por esse método não é executada até que o objeto é enumerado chamando-se suas `GetEnumerator` método diretamente ou usando `foreach` no Visual c# ou `For Each` no Visual Basic.  
  
 O <xref:System.Linq.Enumerable.SelectMany%60%602%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Collections.Generic.IEnumerable%7B%60%601%7D%7D%29> método enumera a sequência de entrada, usa uma função de transformação para mapear cada elemento para um <xref:System.Collections.Generic.IEnumerable%601>e, em seguida, enumera e gera os elementos de cada tais <xref:System.Collections.Generic.IEnumerable%601> objeto. Ou seja, para cada elemento da `source`, `selector` é invocado e uma sequência de valores é retornada. <xref:System.Linq.Enumerable.SelectMany%60%602%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Collections.Generic.IEnumerable%7B%60%601%7D%7D%29> em seguida, mescla esta coleção bidimensional de coleções em um unidimensional <xref:System.Collections.Generic.IEnumerable%601> e o retorna. Por exemplo, se uma consulta usa <xref:System.Linq.Enumerable.SelectMany%60%602%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Collections.Generic.IEnumerable%7B%60%601%7D%7D%29> para obter os pedidos (do tipo `Order`) para cada cliente em um banco de dados, o resultado é do tipo `IEnumerable<Order>` em c# ou `IEnumerable(Of Order)` no Visual Basic. Se, em vez disso, a consulta usa <xref:System.Linq.Enumerable.Select%2A> para obter os pedidos, a coleção de coleções de pedidos não é combinada e o resultado é do tipo `IEnumerable<List<Order>>` em c# ou `IEnumerable(Of List(Of Order))` no Visual Basic.  
  
 Na sintaxe de expressão de consulta, cada `from` cláusula (Visual c#) ou `From` cláusula (Visual Basic) após inicial um se traduz em uma invocação de <xref:System.Linq.Enumerable.SelectMany%2A>.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como usar <xref:System.Linq.Enumerable.SelectMany%60%602%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Collections.Generic.IEnumerable%7B%60%601%7D%7D%29> para realizar uma projeção um-para-muitos em uma matriz.  
  
 [!code-csharp[System.Linq.Enumerable#77](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#77)]
 [!code-vb[System.Linq.Enumerable#77](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#77)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> ou <paramref name="selector" /> é <see langword="null" />.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/1aefd18c-1314-47f8-99ec-9bcefb09e699">Cláusula from (Referência de C#)</related>
        <related type="Article" href="https://msdn.microsoft.com/library/83e3665e-68a0-4540-a3a3-3d777a0f95d5">Cláusula From (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="SelectMany&lt;TSource,TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;TResult&gt; SelectMany&lt;TSource,TResult&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,int,System.Collections.Generic.IEnumerable&lt;TResult&gt;&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;!!TResult&gt; SelectMany&lt;TSource, TResult&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`3&lt;!!TSource, int32, class System.Collections.Generic.IEnumerable`1&lt;!!TResult&gt;&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.SelectMany``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Int32,System.Collections.Generic.IEnumerable{``1}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function SelectMany(Of TSource, TResult) (source As IEnumerable(Of TSource), selector As Func(Of TSource, Integer, IEnumerable(Of TResult))) As IEnumerable(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TResult&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Collections::Generic::IEnumerable&lt;TResult&gt; ^ SelectMany(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Func&lt;TSource, int, System::Collections::Generic::IEnumerable&lt;TResult&gt; ^&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="static member SelectMany : seq&lt;'Source&gt; * Func&lt;'Source, int, seq&lt;'Result&gt;&gt; -&gt; seq&lt;'Result&gt;" Usage="System.Linq.Enumerable.SelectMany (source, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Int32,System.Collections.Generic.IEnumerable&lt;TResult&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">O tipo dos elementos de <paramref name="source" />.</typeparam>
        <typeparam name="TResult">O tipo dos elementos da sequência retornada por <paramref name="selector" />.</typeparam>
        <param name="source">Uma sequência de valores a serem projetados.</param>
        <param name="selector">Uma função de transformação para aplicar a cada elemento de origem; o segundo parâmetro da função representa o índice do elemento de origem.</param>
        <summary>Projeta cada elemento de uma sequência em um <see cref="T:System.Collections.Generic.IEnumerable`1" /> e nivela as sequências resultantes em uma sequência. O índice de cada elemento de origem é usado no formulário projetado desse elemento.</summary>
        <returns>Um <see cref="T:System.Collections.Generic.IEnumerable`1" /> cujos elementos são o resultado da invocação da função de transformação um-para-muitos em cada elemento de uma sequência de entrada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método é implementado usando a execução adiada. O imediata valor retornado é um objeto que armazena todas as informações necessárias para executar a ação. A consulta representada por esse método não é executada até que o objeto é enumerado chamando-se suas `GetEnumerator` método diretamente ou usando `foreach` no Visual c# ou `For Each` no Visual Basic.  
  
 O <xref:System.Linq.Enumerable.SelectMany%60%602%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Int32%2CSystem.Collections.Generic.IEnumerable%7B%60%601%7D%7D%29> método enumera a sequência de entrada, usa uma função de transformação para mapear cada elemento para um <xref:System.Collections.Generic.IEnumerable%601>e, em seguida, enumera e gera os elementos de cada tais <xref:System.Collections.Generic.IEnumerable%601> objeto. Ou seja, para cada elemento da `source`, `selector` é invocado e uma sequência de valores é retornada. <xref:System.Linq.Enumerable.SelectMany%60%602%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Int32%2CSystem.Collections.Generic.IEnumerable%7B%60%601%7D%7D%29> em seguida, mescla esta coleção bidimensional de coleções em um unidimensional <xref:System.Collections.Generic.IEnumerable%601> e o retorna. Por exemplo, se uma consulta usa <xref:System.Linq.Enumerable.SelectMany%60%602%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Int32%2CSystem.Collections.Generic.IEnumerable%7B%60%601%7D%7D%29> para obter os pedidos (do tipo `Order`) para cada cliente em um banco de dados, o resultado é do tipo `IEnumerable<Order>` em c# ou `IEnumerable(Of Order)` no Visual Basic. Se, em vez disso, a consulta usa <xref:System.Linq.Enumerable.Select%2A> para obter os pedidos, a coleção de coleções de pedidos não é combinada e o resultado é do tipo `IEnumerable<List<Order>>` em c# ou `IEnumerable(Of List(Of Order))` no Visual Basic.  
  
 O primeiro argumento para `selector` representa o elemento para processar. O segundo argumento para `selector` representa o índice baseado em zero do elemento na sequência de origem. Isso pode ser útil se os elementos estão em uma ordem conhecida e você deseja fazer algo com um elemento em um índice específico, por exemplo. Ele também pode ser útil se você quiser recuperar o índice de um ou mais elementos.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como usar <xref:System.Linq.Enumerable.SelectMany%60%602%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Int32%2CSystem.Collections.Generic.IEnumerable%7B%60%601%7D%7D%29> para realizar uma projeção um-para-muitos em uma matriz e usar o índice de cada elemento externo.  
  
 [!code-csharp[System.Linq.Enumerable#78](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#78)]
 [!code-vb[System.Linq.Enumerable#78](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#78)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> ou <paramref name="selector" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="SelectMany&lt;TSource,TCollection,TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;TResult&gt; SelectMany&lt;TSource,TCollection,TResult&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,System.Collections.Generic.IEnumerable&lt;TCollection&gt;&gt; collectionSelector, Func&lt;TSource,TCollection,TResult&gt; resultSelector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;!!TResult&gt; SelectMany&lt;TSource, TCollection, TResult&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, class System.Collections.Generic.IEnumerable`1&lt;!!TCollection&gt;&gt; collectionSelector, class System.Func`3&lt;!!TSource, !!TCollection, !!TResult&gt; resultSelector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.SelectMany``3(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Collections.Generic.IEnumerable{``1}},System.Func{``0,``1,``2})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function SelectMany(Of TSource, TCollection, TResult) (source As IEnumerable(Of TSource), collectionSelector As Func(Of TSource, IEnumerable(Of TCollection)), resultSelector As Func(Of TSource, TCollection, TResult)) As IEnumerable(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TCollection, typename TResult&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Collections::Generic::IEnumerable&lt;TResult&gt; ^ SelectMany(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Func&lt;TSource, System::Collections::Generic::IEnumerable&lt;TCollection&gt; ^&gt; ^ collectionSelector, Func&lt;TSource, TCollection, TResult&gt; ^ resultSelector);" />
      <MemberSignature Language="F#" Value="static member SelectMany : seq&lt;'Source&gt; * Func&lt;'Source, seq&lt;'Collection&gt;&gt; * Func&lt;'Source, 'Collection, 'Result&gt; -&gt; seq&lt;'Result&gt;" Usage="System.Linq.Enumerable.SelectMany (source, collectionSelector, resultSelector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TCollection" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="collectionSelector" Type="System.Func&lt;TSource,System.Collections.Generic.IEnumerable&lt;TCollection&gt;&gt;" />
        <Parameter Name="resultSelector" Type="System.Func&lt;TSource,TCollection,TResult&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">O tipo dos elementos de <paramref name="source" />.</typeparam>
        <typeparam name="TCollection">O tipo dos elementos intermediários coletados por <paramref name="collectionSelector" />.</typeparam>
        <typeparam name="TResult">O tipo dos elementos da sequência resultante.</typeparam>
        <param name="source">Uma sequência de valores a serem projetados.</param>
        <param name="collectionSelector">Uma função de transformação a ser aplicada a cada elemento da sequência de entrada.</param>
        <param name="resultSelector">Uma função de transformação a ser aplicada a cada elemento da sequência intermediária.</param>
        <summary>Projeta cada elemento de uma sequência em um <see cref="T:System.Collections.Generic.IEnumerable`1" />, mescla as sequências resultantes em uma sequência e chama uma função de seletor de resultado em cada elemento contido nele.</summary>
        <returns>Um <see cref="T:System.Collections.Generic.IEnumerable`1" /> cujos elementos são o resultado de chamar a função de transformação de um para muitos <paramref name="collectionSelector" /> em cada elemento de <paramref name="source" /> e, em seguida, mapear cada um desses elementos de sequência e seu elemento de origem correspondente para um elemento de resultado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método é implementado usando a execução adiada. O imediata valor retornado é um objeto que armazena todas as informações necessárias para executar a ação. A consulta representada por esse método não é executada até que o objeto é enumerado chamando-se suas `GetEnumerator` método diretamente ou usando `foreach` no Visual c# ou `For Each` no Visual Basic.  
  
 O <xref:System.Linq.Enumerable.SelectMany%60%603%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Collections.Generic.IEnumerable%7B%60%601%7D%7D%2CSystem.Func%7B%60%600%2C%60%601%2C%60%602%7D%29> método é útil quando você precisa manter os elementos de `source` no escopo para a lógica de consulta que ocorre após a chamada para <xref:System.Linq.Enumerable.SelectMany%60%603%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Collections.Generic.IEnumerable%7B%60%601%7D%7D%2CSystem.Func%7B%60%600%2C%60%601%2C%60%602%7D%29>. Consulte a seção de exemplo para obter um exemplo de código. Se há uma relação bidirecional entre objetos do tipo `TSource` e objetos do tipo `TCollection`, ou seja, se um objeto do tipo `TCollection` fornece uma propriedade para recuperar o `TSource` objeto que o produziu, isso não é necessário sobrecarga de <xref:System.Linq.Enumerable.SelectMany%60%603%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Collections.Generic.IEnumerable%7B%60%601%7D%7D%2CSystem.Func%7B%60%600%2C%60%601%2C%60%602%7D%29>. Em vez disso, você pode usar <xref:System.Linq.Enumerable.SelectMany%60%602%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Collections.Generic.IEnumerable%7B%60%601%7D%7D%29> e navegue de volta para o `TSource` por meio do objeto a `TCollection` objeto.  
  
 Na sintaxe de expressão de consulta, cada `from` cláusula (Visual c#) ou `From` cláusula (Visual Basic) após inicial um se traduz em uma invocação de <xref:System.Linq.Enumerable.SelectMany%2A>.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como usar <xref:System.Linq.Enumerable.SelectMany%60%603%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Collections.Generic.IEnumerable%7B%60%601%7D%7D%2CSystem.Func%7B%60%600%2C%60%601%2C%60%602%7D%29> para executar uma projeção um-para-muitos em uma matriz e usar uma função de seletor de resultado para manter cada elemento correspondente da sequência de origem no escopo para a chamada final para `Select`.  
  
 [!code-csharp[System.Linq.Enumerable#124](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#124)]
 [!code-vb[System.Linq.Enumerable#124](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#124)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" />, <paramref name="collectionSelector" /> ou <paramref name="resultSelector" /> é <see langword="null" />.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/1aefd18c-1314-47f8-99ec-9bcefb09e699">Cláusula from (Referência de C#)</related>
        <related type="Article" href="https://msdn.microsoft.com/library/83e3665e-68a0-4540-a3a3-3d777a0f95d5">Cláusula From (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="SelectMany&lt;TSource,TCollection,TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;TResult&gt; SelectMany&lt;TSource,TCollection,TResult&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,int,System.Collections.Generic.IEnumerable&lt;TCollection&gt;&gt; collectionSelector, Func&lt;TSource,TCollection,TResult&gt; resultSelector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;!!TResult&gt; SelectMany&lt;TSource, TCollection, TResult&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`3&lt;!!TSource, int32, class System.Collections.Generic.IEnumerable`1&lt;!!TCollection&gt;&gt; collectionSelector, class System.Func`3&lt;!!TSource, !!TCollection, !!TResult&gt; resultSelector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.SelectMany``3(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Int32,System.Collections.Generic.IEnumerable{``1}},System.Func{``0,``1,``2})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function SelectMany(Of TSource, TCollection, TResult) (source As IEnumerable(Of TSource), collectionSelector As Func(Of TSource, Integer, IEnumerable(Of TCollection)), resultSelector As Func(Of TSource, TCollection, TResult)) As IEnumerable(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TCollection, typename TResult&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Collections::Generic::IEnumerable&lt;TResult&gt; ^ SelectMany(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Func&lt;TSource, int, System::Collections::Generic::IEnumerable&lt;TCollection&gt; ^&gt; ^ collectionSelector, Func&lt;TSource, TCollection, TResult&gt; ^ resultSelector);" />
      <MemberSignature Language="F#" Value="static member SelectMany : seq&lt;'Source&gt; * Func&lt;'Source, int, seq&lt;'Collection&gt;&gt; * Func&lt;'Source, 'Collection, 'Result&gt; -&gt; seq&lt;'Result&gt;" Usage="System.Linq.Enumerable.SelectMany (source, collectionSelector, resultSelector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TCollection" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="collectionSelector" Type="System.Func&lt;TSource,System.Int32,System.Collections.Generic.IEnumerable&lt;TCollection&gt;&gt;" />
        <Parameter Name="resultSelector" Type="System.Func&lt;TSource,TCollection,TResult&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">O tipo dos elementos de <paramref name="source" />.</typeparam>
        <typeparam name="TCollection">O tipo dos elementos intermediários coletados por <paramref name="collectionSelector" />.</typeparam>
        <typeparam name="TResult">O tipo dos elementos da sequência resultante.</typeparam>
        <param name="source">Uma sequência de valores a serem projetados.</param>
        <param name="collectionSelector">Uma função de transformação para aplicar a cada elemento de origem; o segundo parâmetro da função representa o índice do elemento de origem.</param>
        <param name="resultSelector">Uma função de transformação a ser aplicada a cada elemento da sequência intermediária.</param>
        <summary>Projeta cada elemento de uma sequência em um <see cref="T:System.Collections.Generic.IEnumerable`1" />, mescla as sequências resultantes em uma sequência e chama uma função de seletor de resultado em cada elemento contido nele. O índice de cada elemento de origem é usado no formulário projetado intermediário do elemento.</summary>
        <returns>Um <see cref="T:System.Collections.Generic.IEnumerable`1" /> cujos elementos são o resultado de chamar a função de transformação de um para muitos <paramref name="collectionSelector" /> em cada elemento de <paramref name="source" /> e, em seguida, mapear cada um desses elementos de sequência e seu elemento de origem correspondente para um elemento de resultado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método é implementado usando a execução adiada. O imediata valor retornado é um objeto que armazena todas as informações necessárias para executar a ação. A consulta representada por esse método não é executada até que o objeto é enumerado chamando-se suas `GetEnumerator` método diretamente ou usando `foreach` no Visual c# ou `For Each` no Visual Basic.  
  
 O <xref:System.Linq.Enumerable.SelectMany%60%603%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Int32%2CSystem.Collections.Generic.IEnumerable%7B%60%601%7D%7D%2CSystem.Func%7B%60%600%2C%60%601%2C%60%602%7D%29> método é útil quando você precisa manter os elementos de `source` no escopo para a lógica de consulta que ocorre após a chamada para <xref:System.Linq.Enumerable.SelectMany%60%603%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Int32%2CSystem.Collections.Generic.IEnumerable%7B%60%601%7D%7D%2CSystem.Func%7B%60%600%2C%60%601%2C%60%602%7D%29>. Consulte a seção de exemplo para obter um exemplo de código. Se há uma relação bidirecional entre objetos do tipo `TSource` e objetos do tipo `TCollection`, ou seja, se um objeto do tipo `TCollection` fornece uma propriedade para recuperar o `TSource` objeto que o produziu, isso não é necessário sobrecarga de <xref:System.Linq.Enumerable.SelectMany%60%603%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Int32%2CSystem.Collections.Generic.IEnumerable%7B%60%601%7D%7D%2CSystem.Func%7B%60%600%2C%60%601%2C%60%602%7D%29>. Em vez disso, você pode usar <xref:System.Linq.Enumerable.SelectMany%60%602%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Int32%2CSystem.Collections.Generic.IEnumerable%7B%60%601%7D%7D%29> e navegue de volta para o `TSource` por meio do objeto a `TCollection` objeto.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" />, <paramref name="collectionSelector" /> ou <paramref name="resultSelector" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="SequenceEqual&lt;TSource&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Determina se duas sequências são iguais de acordo com um comparador de igualdade.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SequenceEqual&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static bool SequenceEqual&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; first, System.Collections.Generic.IEnumerable&lt;TSource&gt; second);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool SequenceEqual&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; first, class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; second) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.SequenceEqual``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function SequenceEqual(Of TSource) (first As IEnumerable(Of TSource), second As IEnumerable(Of TSource)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static bool SequenceEqual(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ first, System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ second);" />
      <MemberSignature Language="F#" Value="static member SequenceEqual : seq&lt;'Source&gt; * seq&lt;'Source&gt; -&gt; bool" Usage="System.Linq.Enumerable.SequenceEqual (first, second)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="first" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="second" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">O tipo dos elementos das sequências de entrada.</typeparam>
        <param name="first">Um <see cref="T:System.Collections.Generic.IEnumerable`1" /> para comparar com <paramref name="second" />.</param>
        <param name="second">Um <see cref="T:System.Collections.Generic.IEnumerable`1" /> para comparar com a primeira sequência.</param>
        <summary>Determina se duas sequências são iguais comparando os elementos usando o comparador de igualdade padrão para o tipo.</summary>
        <returns><see langword="true" /> se as duas sequências de origem forem de mesmo comprimento e seus elementos correspondentes forem iguais de acordo com o comparador de igualdade padrão para seu tipo; caso contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Linq.Enumerable.SequenceEqual%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%29> método enumera as duas sequências de origem em paralelo e compara os elementos correspondentes usando o comparador de igualdade padrão para `TSource`, <xref:System.Collections.Generic.EqualityComparer%601.Default%2A>. O comparador de igualdade padrão, <xref:System.Collections.Generic.EqualityComparer%601.Default%2A>, é usado para comparar valores de tipos que implementam o <xref:System.Collections.Generic.IEqualityComparer%601> interface genérica. Para comparar um tipo de dados personalizado, você precisa implementar esta interface e fornecer seus próprios <xref:System.Object.GetHashCode%2A> e <xref:System.Object.Equals%2A> métodos para o tipo.  
  
   
  
## Examples  
 Os exemplos de código a seguir demonstram como usar <xref:System.Linq.Enumerable.SequenceEqual%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%29> para determinar se duas sequências são iguais. Nos dois primeiros exemplos, o método determina se as sequências comparadas contêm referências aos mesmos objetos. No terceiro e quarto exemplos, o método compara os dados reais dos objetos dentro das sequências.  
  
 Neste exemplo, as sequências são iguais.  
  
 [!code-csharp[System.Linq.Enumerable#32](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#32)]
 [!code-vb[System.Linq.Enumerable#32](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#32)]  
  
 O exemplo de código a seguir compara duas sequências que não são iguais. Observe que as sequências contêm dados idênticos, mas como os objetos que eles contêm têm referências diferentes, as sequências não são consideradas iguais.  
  
 [!code-csharp[System.Linq.Enumerable#33](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#33)]
 [!code-vb[System.Linq.Enumerable#33](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#33)]  
  
 Se você quiser comparar os dados reais dos objetos nas sequências em vez de apenas comparar suas referências, você precisa implementar o <xref:System.Collections.Generic.IEqualityComparer%601> interface genérica em sua classe. O exemplo de código a seguir mostra como implementar essa interface em uma classe auxiliar e fornecer <xref:System.Object.GetHashCode%2A> e <xref:System.Object.Equals%2A> métodos.  
  
 [!code-csharp[CSLINQEncapsulatedComparer#9](~/samples/snippets/csharp/VS_Snippets_VBCSharp/CsLINQEncapsulatedComparer/CS/EncapsulatedComparer.cs#9)]  
  
 Depois de implementar essa interface, você pode usar sequências de `ProductA` objetos no <xref:System.Linq.Enumerable.SequenceEqual%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%29> método, conforme mostrado no exemplo a seguir.  
  
 [!code-csharp[CSLINQEncapsulatedComparer#8](~/samples/snippets/csharp/VS_Snippets_VBCSharp/CsLINQEncapsulatedComparer/CS/EncapsulatedComparer.cs#8)]
 [!code-vb[CSLINQEncapsulatedComparer#8](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/CsLINQEncapsulatedComparer/VB/EncapsulatedComparer.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="first" /> ou <paramref name="second" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="SequenceEqual&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static bool SequenceEqual&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; first, System.Collections.Generic.IEnumerable&lt;TSource&gt; second, System.Collections.Generic.IEqualityComparer&lt;TSource&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool SequenceEqual&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; first, class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; second, class System.Collections.Generic.IEqualityComparer`1&lt;!!TSource&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.SequenceEqual``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEqualityComparer{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function SequenceEqual(Of TSource) (first As IEnumerable(Of TSource), second As IEnumerable(Of TSource), comparer As IEqualityComparer(Of TSource)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static bool SequenceEqual(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ first, System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ second, System::Collections::Generic::IEqualityComparer&lt;TSource&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="static member SequenceEqual : seq&lt;'Source&gt; * seq&lt;'Source&gt; * System.Collections.Generic.IEqualityComparer&lt;'Source&gt; -&gt; bool" Usage="System.Linq.Enumerable.SequenceEqual (first, second, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="first" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="second" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IEqualityComparer&lt;TSource&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">O tipo dos elementos das sequências de entrada.</typeparam>
        <param name="first">Um <see cref="T:System.Collections.Generic.IEnumerable`1" /> para comparar com <paramref name="second" />.</param>
        <param name="second">Um <see cref="T:System.Collections.Generic.IEnumerable`1" /> para comparar com a primeira sequência.</param>
        <param name="comparer">Um <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> a ser usado para comparar elementos.</param>
        <summary>Determina se duas sequências são iguais, comparando seus elementos usando um <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> especificado.</summary>
        <returns><see langword="true" /> se as duas sequências de origem tiverem o mesmo tamanho e seus elementos correspondentes forem comparados como iguais de acordo com o <paramref name="comparer" />; caso contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Linq.Enumerable.SequenceEqual%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Collections.Generic.IEqualityComparer%7B%60%600%7D%29> método enumera as duas sequências de origem em paralelo e compara os elementos correspondentes usando especificado <xref:System.Collections.Generic.IEqualityComparer%601>. Se `comparer` está `null`, o comparador de igualdade padrão, <xref:System.Collections.Generic.EqualityComparer%601.Default%2A>, é usado para comparar elementos.  
  
   
  
## Examples  
 O exemplo a seguir mostra como implementar um comparador de igualdade que pode ser usado no <xref:System.Linq.Enumerable.SequenceEqual%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Collections.Generic.IEqualityComparer%7B%60%600%7D%29> método.  
  
 [!code-csharp[CSLINQCustomComparer#1](~/samples/snippets/csharp/VS_Snippets_VBCSharp/CsLINQCustomComparer/CS/CustomComparer.cs#1)]
 [!code-vb[CSLINQCustomComparer#1](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/CsLINQCustomComparer/VB/CustomComparer.vb#1)]  
  
 Depois de implementar esse comparador, você pode usar sequências de `Product` objetos no <xref:System.Linq.Enumerable.SequenceEqual%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Collections.Generic.IEqualityComparer%7B%60%600%7D%29> método, conforme mostrado no exemplo a seguir.  
  
 [!code-csharp[CSLINQCustomComparer#8](~/samples/snippets/csharp/VS_Snippets_VBCSharp/CsLINQCustomComparer/CS/CustomComparer.cs#8)]
 [!code-vb[CSLINQCustomComparer#8](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/CsLINQCustomComparer/VB/CustomComparer.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="first" /> ou <paramref name="second" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Single&lt;TSource&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Retorna um único elemento específico de uma sequência.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Single&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static TSource Single&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TSource Single&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Single``1(System.Collections.Generic.IEnumerable{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Single(Of TSource) (source As IEnumerable(Of TSource)) As TSource" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static TSource Single(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Single : seq&lt;'Source&gt; -&gt; 'Source" Usage="System.Linq.Enumerable.Single source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TSource</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">O tipo dos elementos de <paramref name="source" />.</typeparam>
        <param name="source">Um <see cref="T:System.Collections.Generic.IEnumerable`1" /> do qual o único elemento será retornado.</param>
        <summary>Retornará o único elemento de uma sequência e lançará uma exceção se não houver exatamente um elemento na sequência.</summary>
        <returns>O único elemento de uma sequência de entrada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Linq.Enumerable.Single%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%29> método lança uma exceção se a sequência de entrada está vazia. Em vez disso, retornar `null` quando a sequência de entrada estiver vazia, use <xref:System.Linq.Enumerable.SingleOrDefault%2A>.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como usar <xref:System.Linq.Enumerable.Single%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%29> para selecionar o único elemento de uma matriz.  
  
 [!code-csharp[System.Linq.Enumerable#79](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#79)]
 [!code-vb[System.Linq.Enumerable#79](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#79)]  
  
 O exemplo de código a seguir demonstra que <xref:System.Linq.Enumerable.Single%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%29> lança uma exceção quando a sequência não contém exatamente um elemento.  
  
 [!code-csharp[System.Linq.Enumerable#80](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#80)]
 [!code-vb[System.Linq.Enumerable#80](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#80)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> é <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">A sequência de entrada contém mais de um elemento.  
  
- ou - 
A sequência de entrada está vazia.</exception>
      </Docs>
    </Member>
    <Member MemberName="Single&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static TSource Single&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,bool&gt; predicate);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TSource Single&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, bool&gt; predicate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Single``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Boolean})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Single(Of TSource) (source As IEnumerable(Of TSource), predicate As Func(Of TSource, Boolean)) As TSource" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static TSource Single(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Func&lt;TSource, bool&gt; ^ predicate);" />
      <MemberSignature Language="F#" Value="static member Single : seq&lt;'Source&gt; * Func&lt;'Source, bool&gt; -&gt; 'Source" Usage="System.Linq.Enumerable.Single (source, predicate)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TSource</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="predicate" Type="System.Func&lt;TSource,System.Boolean&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">O tipo dos elementos de <paramref name="source" />.</typeparam>
        <param name="source">Um <see cref="T:System.Collections.Generic.IEnumerable`1" /> do qual retornar um único elemento.</param>
        <param name="predicate">Uma função para testar um elemento em relação a uma condição.</param>
        <summary>Retorna o único elemento de uma sequência que satisfaz uma condição especificada e gera uma exceção se houver mais de um tal elemento.</summary>
        <returns>O único elemento da sequência de entrada que atende a uma condição.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Linq.Enumerable.Single%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Boolean%7D%29> método lança uma exceção se a sequência de entrada não contém elementos correspondentes. Em vez disso, retornar `null` quando nenhum elemento correspondente for encontrado, use <xref:System.Linq.Enumerable.SingleOrDefault%2A>.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como usar <xref:System.Linq.Enumerable.Single%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Boolean%7D%29> para selecionar o único elemento de uma matriz que satisfaz uma condição.  
  
 [!code-csharp[System.Linq.Enumerable#81](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#81)]
 [!code-vb[System.Linq.Enumerable#81](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#81)]  
  
 O exemplo de código a seguir demonstra que <xref:System.Linq.Enumerable.Single%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Boolean%7D%29> lança uma exceção quando a sequência não contém exatamente um elemento que satisfaz a condição.  
  
 [!code-csharp[System.Linq.Enumerable#82](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#82)]
 [!code-vb[System.Linq.Enumerable#82](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#82)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> ou <paramref name="predicate" /> é <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Nenhum elemento satisfaz a condição na <paramref name="predicate" />.  
  
- ou - 
Mais de um elemento satisfaz a condição na <paramref name="predicate" />.  
  
- ou - 
Uma sequência de origem está vazia.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="SingleOrDefault&lt;TSource&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Retornará um único elemento específico de uma sequência ou um valor padrão se esse elemento não for encontrado.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SingleOrDefault&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static TSource SingleOrDefault&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TSource SingleOrDefault&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.SingleOrDefault``1(System.Collections.Generic.IEnumerable{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function SingleOrDefault(Of TSource) (source As IEnumerable(Of TSource)) As TSource" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static TSource SingleOrDefault(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member SingleOrDefault : seq&lt;'Source&gt; -&gt; 'Source" Usage="System.Linq.Enumerable.SingleOrDefault source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TSource</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">O tipo dos elementos de <paramref name="source" />.</typeparam>
        <param name="source">Um <see cref="T:System.Collections.Generic.IEnumerable`1" /> do qual o único elemento será retornado.</param>
        <summary>Retorna o único elemento de uma sequência ou um valor padrão se a sequência é vazia; esse método gera uma exceção se há mais de um elemento na sequência.</summary>
        <returns>O único elemento da sequência de entrada, ou <see langword="default" />(<paramref name="TSource" />), se a sequência não contiver elementos.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O valor padrão para referência e tipos que permitem valor nulos é `null`.  
  
 O <xref:System.Linq.Enumerable.SingleOrDefault%2A> método não fornece uma maneira de especificar um valor padrão. Se você quiser especificar um valor padrão diferente de `default(TSource)`, use o <xref:System.Linq.Enumerable.DefaultIfEmpty%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2C%60%600%29> método conforme descrito na seção de exemplo.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como usar <xref:System.Linq.Enumerable.SingleOrDefault%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%29> para selecionar o único elemento de uma matriz.  
  
 [!code-csharp[System.Linq.Enumerable#83](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#83)]
 [!code-vb[System.Linq.Enumerable#83](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#83)]  
  
 O exemplo de código a seguir demonstra que <xref:System.Linq.Enumerable.SingleOrDefault%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%29> retorna um valor padrão quando a sequência não contém exatamente um elemento.  
  
 [!code-csharp[System.Linq.Enumerable#84](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#84)]
 [!code-vb[System.Linq.Enumerable#84](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#84)]  
  
 Às vezes, o valor de `default(TSource)` não é o valor padrão que você deseja usar se a coleção não contiver elementos. Em vez de verificar o resultado para o valor padrão indesejado e, em seguida, alterando-se necessário, você pode usar o <xref:System.Linq.Enumerable.DefaultIfEmpty%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2C%60%600%29> método para especificar o valor padrão que você deseja usar, se a coleção está vazia. Em seguida, chame <xref:System.Linq.Enumerable.Single%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%29> para obter o elemento. O exemplo de código a seguir usa ambas as técnicas para obter um valor padrão de 1, se uma coleção de números de página está vazia. Porque o valor padrão para um número inteiro é 0, que não é um número válido de página geralmente, o valor padrão deve ser especificado como 1 em vez disso. A primeira variável de resultado é verificada para o valor padrão indesejados após a conclusão da consulta em execução. A segunda variável de resultado é obtida usando <xref:System.Linq.Enumerable.DefaultIfEmpty%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2C%60%600%29> para especificar um valor padrão de 1.  
  
 [!code-csharp[System.Linq.Enumerable#128](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#128)]
 [!code-vb[System.Linq.Enumerable#128](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#128)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> é <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">A sequência de entrada contém mais de um elemento.</exception>
      </Docs>
    </Member>
    <Member MemberName="SingleOrDefault&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static TSource SingleOrDefault&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,bool&gt; predicate);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TSource SingleOrDefault&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, bool&gt; predicate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.SingleOrDefault``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Boolean})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function SingleOrDefault(Of TSource) (source As IEnumerable(Of TSource), predicate As Func(Of TSource, Boolean)) As TSource" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static TSource SingleOrDefault(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Func&lt;TSource, bool&gt; ^ predicate);" />
      <MemberSignature Language="F#" Value="static member SingleOrDefault : seq&lt;'Source&gt; * Func&lt;'Source, bool&gt; -&gt; 'Source" Usage="System.Linq.Enumerable.SingleOrDefault (source, predicate)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TSource</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="predicate" Type="System.Func&lt;TSource,System.Boolean&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">O tipo dos elementos de <paramref name="source" />.</typeparam>
        <param name="source">Um <see cref="T:System.Collections.Generic.IEnumerable`1" /> do qual retornar um único elemento.</param>
        <param name="predicate">Uma função para testar um elemento em relação a uma condição.</param>
        <summary>Retorna o único elemento de uma sequência que satisfaz uma condição especificada ou um valor padrão se esse elemento não existir. Esse método lança uma exceção se mais de um elemento satisfizer a condição.</summary>
        <returns>O único elemento da sequência de entrada que atende à condição ou <see langword="default" />(<paramref name="TSource" />) se esse elemento não for encontrado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O valor padrão para referência e tipos que permitem valor nulos é `null`.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como usar <xref:System.Linq.Enumerable.SingleOrDefault%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Boolean%7D%29> para selecionar o único elemento de uma matriz que satisfaz uma condição.  
  
 [!code-csharp[System.Linq.Enumerable#85](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#85)]
 [!code-vb[System.Linq.Enumerable#85](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#85)]  
  
 O exemplo de código a seguir demonstra que <xref:System.Linq.Enumerable.SingleOrDefault%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Boolean%7D%29> retorna um valor padrão quando a sequência não contém exatamente um elemento que satisfaz a condição.  
  
 [!code-csharp[System.Linq.Enumerable#86](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#86)]
 [!code-vb[System.Linq.Enumerable#86](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#86)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> ou <paramref name="predicate" /> é <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Mais de um elemento satisfaz a condição na <paramref name="predicate" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Skip&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;TSource&gt; Skip&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; Skip&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Skip``1(System.Collections.Generic.IEnumerable{``0},System.Int32)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Skip(Of TSource) (source As IEnumerable(Of TSource), count As Integer) As IEnumerable(Of TSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ Skip(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, int count);" />
      <MemberSignature Language="F#" Value="static member Skip : seq&lt;'Source&gt; * int -&gt; seq&lt;'Source&gt;" Usage="System.Linq.Enumerable.Skip (source, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">O tipo dos elementos de <paramref name="source" />.</typeparam>
        <param name="source">Um <see cref="T:System.Collections.Generic.IEnumerable`1" /> do qual os elementos serão retornados.</param>
        <param name="count">O número de elementos a serem ignorados antes de retornar os elementos restantes.</param>
        <summary>Ignora um número especificado de elementos em uma sequência e retorna os elementos restantes.</summary>
        <returns>Um <see cref="T:System.Collections.Generic.IEnumerable`1" /> que contém os elementos que ocorrem após o índice especificado na sequência de entrada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método é implementado usando a execução adiada. O imediata valor retornado é um objeto que armazena todas as informações necessárias para executar a ação. A consulta representada por esse método não é executada até que o objeto é enumerado chamando-se suas `GetEnumerator` método diretamente ou usando `foreach` no Visual c# ou `For Each` no Visual Basic.  
  
 Se `source` contiver menos `count` elementos, vazia <xref:System.Collections.Generic.IEnumerable%601> é retornado. Se `count` é menor ou igual a zero, todos os elementos de `source` são gerados.  
  
 O <xref:System.Linq.Enumerable.Take%2A> e <xref:System.Linq.Enumerable.Skip%2A> métodos são complementa funcional. Dada uma determinada sequência `coll` e um número inteiro `n`, concatenando os resultados de `coll.Take(n)` e `coll.Skip(n)` produz a mesma sequência que `coll`.  
  
 Na sintaxe de expressão de consulta do Visual Basic, uma `Skip` cláusula se traduz em uma invocação de <xref:System.Linq.Enumerable.Skip%2A>.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como usar <xref:System.Linq.Enumerable.Skip%2A> para ignorar um número especificado de elementos em uma matriz classificada e retornar os elementos restantes.  
  
 [!code-csharp[System.Linq.Enumerable#87](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#87)]
 [!code-vb[System.Linq.Enumerable#87](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#87)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> é <see langword="null" />.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/f00eb172-3907-4c43-9745-d8546ab86234">Cláusula Skip (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="SkipLast&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;TSource&gt; SkipLast&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; SkipLast&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.SkipLast``1(System.Collections.Generic.IEnumerable{``0},System.Int32)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function SkipLast(Of TSource) (source As IEnumerable(Of TSource), count As Integer) As IEnumerable(Of TSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ SkipLast(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, int count);" />
      <MemberSignature Language="F#" Value="static member SkipLast : seq&lt;'Source&gt; * int -&gt; seq&lt;'Source&gt;" Usage="System.Linq.Enumerable.SkipLast (source, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">To be added.</typeparam>
        <param name="source">To be added.</param>
        <param name="count">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="SkipWhile&lt;TSource&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Ignora elementos em uma sequência, contanto que uma condição especificada seja verdadeira e retorne os elementos restantes.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SkipWhile&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;TSource&gt; SkipWhile&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,bool&gt; predicate);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; SkipWhile&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, bool&gt; predicate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.SkipWhile``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Boolean})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function SkipWhile(Of TSource) (source As IEnumerable(Of TSource), predicate As Func(Of TSource, Boolean)) As IEnumerable(Of TSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ SkipWhile(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Func&lt;TSource, bool&gt; ^ predicate);" />
      <MemberSignature Language="F#" Value="static member SkipWhile : seq&lt;'Source&gt; * Func&lt;'Source, bool&gt; -&gt; seq&lt;'Source&gt;" Usage="System.Linq.Enumerable.SkipWhile (source, predicate)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="predicate" Type="System.Func&lt;TSource,System.Boolean&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">O tipo dos elementos de <paramref name="source" />.</typeparam>
        <param name="source">Um <see cref="T:System.Collections.Generic.IEnumerable`1" /> do qual os elementos serão retornados.</param>
        <param name="predicate">Uma função para testar cada elemento em relação a uma condição.</param>
        <summary>Ignora elementos em uma sequência, contanto que uma condição especificada seja verdadeira e retorne os elementos restantes.</summary>
        <returns>Um <see cref="T:System.Collections.Generic.IEnumerable`1" /> que contém os elementos da sequência de entrada, começando no primeiro elemento da série linear que não passa no teste especificado por <paramref name="predicate" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Linq.Enumerable.SkipWhile%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Boolean%7D%29> método é implementado usando a execução adiada. O imediata valor retornado é um objeto que armazena todas as informações necessárias para executar a ação. A consulta representada por esse método não é executada até que o objeto é enumerado chamando-se suas `GetEnumerator` método diretamente ou usando `foreach` no Visual c# ou `For Each` no Visual Basic.  
  
 Este método testa cada elemento da `source` por meio `predicate` e ignora o elemento se o resultado for `true`. Depois que a função de predicado retorna `false` de um elemento, esse elemento e os elementos restantes na `source` geradas e não há nenhum mais invocações de `predicate`.  
  
 Se `predicate` retorna `true` para todos os elementos na sequência, vazia <xref:System.Collections.Generic.IEnumerable%601> é retornado.  
  
 O <xref:System.Linq.Enumerable.TakeWhile%2A> e <xref:System.Linq.Enumerable.SkipWhile%2A> métodos são complementa funcional. Dada uma determinada sequência `coll` e uma função pura `p`, concatenando os resultados de `coll.TakeWhile(p)` e `coll.SkipWhile(p)` produz a mesma sequência que `coll`.  
  
 Na sintaxe de expressão de consulta do Visual Basic, uma `Skip While` cláusula se traduz em uma invocação de <xref:System.Linq.Enumerable.SkipWhile%2A>.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como usar <xref:System.Linq.Enumerable.SkipWhile%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Boolean%7D%29> para ignorar os elementos de uma matriz como uma condição seja verdadeira.  
  
 [!code-csharp[System.Linq.Enumerable#88](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#88)]
 [!code-vb[System.Linq.Enumerable#88](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#88)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> ou <paramref name="predicate" /> é <see langword="null" />.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/5dee8350-7520-4f1a-b00d-590cacd572d6">Ignorar cláusula While (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="SkipWhile&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;TSource&gt; SkipWhile&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,int,bool&gt; predicate);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; SkipWhile&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`3&lt;!!TSource, int32, bool&gt; predicate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.SkipWhile``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Int32,System.Boolean})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function SkipWhile(Of TSource) (source As IEnumerable(Of TSource), predicate As Func(Of TSource, Integer, Boolean)) As IEnumerable(Of TSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ SkipWhile(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Func&lt;TSource, int, bool&gt; ^ predicate);" />
      <MemberSignature Language="F#" Value="static member SkipWhile : seq&lt;'Source&gt; * Func&lt;'Source, int, bool&gt; -&gt; seq&lt;'Source&gt;" Usage="System.Linq.Enumerable.SkipWhile (source, predicate)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="predicate" Type="System.Func&lt;TSource,System.Int32,System.Boolean&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">O tipo dos elementos de <paramref name="source" />.</typeparam>
        <param name="source">Um <see cref="T:System.Collections.Generic.IEnumerable`1" /> do qual os elementos serão retornados.</param>
        <param name="predicate">Uma função para testar cada elemento de origem em relação a uma condição; o segundo parâmetro da função representa o índice do elemento de origem.</param>
        <summary>Ignora elementos em uma sequência, contanto que uma condição especificada seja verdadeira e retorne os elementos restantes. O índice do elemento é usado na lógica da função de predicado.</summary>
        <returns>Um <see cref="T:System.Collections.Generic.IEnumerable`1" /> que contém os elementos da sequência de entrada, começando no primeiro elemento da série linear que não passa no teste especificado por <paramref name="predicate" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método é implementado usando a execução adiada. O imediata valor retornado é um objeto que armazena todas as informações necessárias para executar a ação. A consulta representada por esse método não é executada até que o objeto é enumerado chamando-se suas `GetEnumerator` método diretamente ou usando `foreach` no Visual c# ou `For Each` no Visual Basic.  
  
 O <xref:System.Linq.Enumerable.SkipWhile%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Int32%2CSystem.Boolean%7D%29> método testa cada elemento de `source` usando `predicate` e ignora o elemento se o resultado for `true`. Depois que a função de predicado retorna `false` de um elemento, esse elemento e os elementos restantes na `source` geradas e não há nenhum mais invocações de `predicate`.  
  
 Se `predicate` retorna `true` para todos os elementos na sequência, vazia <xref:System.Collections.Generic.IEnumerable%601> é retornado.  
  
 O primeiro argumento do `predicate` representa o elemento a ser testado. O segundo argumento representa o índice baseado em zero do elemento no `source`.  
  
 O <xref:System.Linq.Enumerable.TakeWhile%2A> e <xref:System.Linq.Enumerable.SkipWhile%2A> métodos são complementa funcional. Dada uma determinada sequência `coll` e uma função pura `p`, concatenando os resultados de `coll.TakeWhile(p)` e `coll.SkipWhile(p)` produz a mesma sequência que `coll`.  
  
 Na sintaxe de expressão de consulta do Visual Basic, uma `Skip While` cláusula se traduz em uma invocação de <xref:System.Linq.Enumerable.SkipWhile%2A>.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como usar <xref:System.Linq.Enumerable.SkipWhile%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Int32%2CSystem.Boolean%7D%29> para ignorar os elementos de uma matriz como uma condição que depende do índice do elemento é verdadeira.  
  
 [!code-csharp[System.Linq.Enumerable#89](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#89)]
 [!code-vb[System.Linq.Enumerable#89](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#89)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> ou <paramref name="predicate" /> é <see langword="null" />.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/5dee8350-7520-4f1a-b00d-590cacd572d6">Ignorar cláusula While (Visual Basic)</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Sum">
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Computa a soma de uma sequência de valores numéricos.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Sum">
      <MemberSignature Language="C#" Value="public static decimal Sum (this System.Collections.Generic.IEnumerable&lt;decimal&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Decimal Sum(class System.Collections.Generic.IEnumerable`1&lt;valuetype System.Decimal&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Sum(System.Collections.Generic.IEnumerable{System.Decimal})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Sum (source As IEnumerable(Of Decimal)) As Decimal" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Decimal Sum(System::Collections::Generic::IEnumerable&lt;System::Decimal&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Sum : seq&lt;decimal&gt; -&gt; decimal" Usage="System.Linq.Enumerable.Sum source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;System.Decimal&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Uma sequência de valores <see cref="T:System.Decimal" /> para cálculo da soma.</param>
        <summary>Calcula a soma de uma sequência de valores <see cref="T:System.Decimal" />.</summary>
        <returns>A soma dos valores na sequência.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Linq.Enumerable.Sum%28System.Collections.Generic.IEnumerable%7BSystem.Decimal%7D%29> método retorna zero se `source` não contiver elementos.  
  
 Na sintaxe de expressão de consulta do Visual Basic, uma `Aggregate Into Sum()` cláusula se traduz em uma invocação de <xref:System.Linq.Enumerable.Sum%2A>.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como usar <xref:System.Linq.Enumerable.Sum%28System.Collections.Generic.IEnumerable%7BSystem.Single%7D%29> para somar os valores de uma sequência.  
  
 [!INCLUDE[sqo_diff_overload_example_elementtype](~/includes/sqo-diff-overload-example-elementtype-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#120](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#120)]
 [!code-vb[System.Linq.Enumerable#120](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#120)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> é <see langword="null" />.</exception>
        <exception cref="T:System.OverflowException">A soma é maior que <see cref="F:System.Decimal.MaxValue" />.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/1315a814-5db6-4077-b34b-b141e11cc0eb">Cláusula Aggregate (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Sum">
      <MemberSignature Language="C#" Value="public static double Sum (this System.Collections.Generic.IEnumerable&lt;double&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Sum(class System.Collections.Generic.IEnumerable`1&lt;float64&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Sum(System.Collections.Generic.IEnumerable{System.Double})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Sum (source As IEnumerable(Of Double)) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static double Sum(System::Collections::Generic::IEnumerable&lt;double&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Sum : seq&lt;double&gt; -&gt; double" Usage="System.Linq.Enumerable.Sum source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;System.Double&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Uma sequência de valores <see cref="T:System.Double" /> para cálculo da soma.</param>
        <summary>Calcula a soma de uma sequência de valores <see cref="T:System.Double" />.</summary>
        <returns>A soma dos valores na sequência.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método retornará zero se `source` não contiver elementos.  
  
 Na sintaxe de expressão de consulta do Visual Basic, uma `Aggregate Into Sum()` cláusula se traduz em uma invocação de <xref:System.Linq.Enumerable.Sum%2A>.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como usar <xref:System.Linq.Enumerable.Sum%28System.Collections.Generic.IEnumerable%7BSystem.Single%7D%29> para somar os valores de uma sequência.  
  
 [!INCLUDE[sqo_diff_overload_example_elementtype](~/includes/sqo-diff-overload-example-elementtype-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#120](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#120)]
 [!code-vb[System.Linq.Enumerable#120](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#120)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> é <see langword="null" />.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/1315a814-5db6-4077-b34b-b141e11cc0eb">Cláusula Aggregate (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Sum">
      <MemberSignature Language="C#" Value="public static int Sum (this System.Collections.Generic.IEnumerable&lt;int&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Sum(class System.Collections.Generic.IEnumerable`1&lt;int32&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Sum(System.Collections.Generic.IEnumerable{System.Int32})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Sum (source As IEnumerable(Of Integer)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static int Sum(System::Collections::Generic::IEnumerable&lt;int&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Sum : seq&lt;int&gt; -&gt; int" Usage="System.Linq.Enumerable.Sum source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;System.Int32&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Uma sequência de valores <see cref="T:System.Int32" /> para cálculo da soma.</param>
        <summary>Calcula a soma de uma sequência de valores <see cref="T:System.Int32" />.</summary>
        <returns>A soma dos valores na sequência.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método retornará zero se `source` não contiver elementos.  
  
 Na sintaxe de expressão de consulta do Visual Basic, uma `Aggregate Into Sum()` cláusula se traduz em uma invocação de <xref:System.Linq.Enumerable.Sum%2A>.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como usar <xref:System.Linq.Enumerable.Sum%28System.Collections.Generic.IEnumerable%7BSystem.Single%7D%29> para somar os valores de uma sequência.  
  
 [!INCLUDE[sqo_diff_overload_example_elementtype](~/includes/sqo-diff-overload-example-elementtype-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#120](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#120)]
 [!code-vb[System.Linq.Enumerable#120](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#120)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> é <see langword="null" />.</exception>
        <exception cref="T:System.OverflowException">A soma é maior que <see cref="F:System.Int32.MaxValue" />.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/1315a814-5db6-4077-b34b-b141e11cc0eb">Cláusula Aggregate (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Sum">
      <MemberSignature Language="C#" Value="public static long Sum (this System.Collections.Generic.IEnumerable&lt;long&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 Sum(class System.Collections.Generic.IEnumerable`1&lt;int64&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Sum(System.Collections.Generic.IEnumerable{System.Int64})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Sum (source As IEnumerable(Of Long)) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static long Sum(System::Collections::Generic::IEnumerable&lt;long&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Sum : seq&lt;int64&gt; -&gt; int64" Usage="System.Linq.Enumerable.Sum source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;System.Int64&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Uma sequência de valores <see cref="T:System.Int64" /> para cálculo da soma.</param>
        <summary>Calcula a soma de uma sequência de valores <see cref="T:System.Int64" />.</summary>
        <returns>A soma dos valores na sequência.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método retornará zero se `source` não contiver elementos.  
  
 Na sintaxe de expressão de consulta do Visual Basic, uma `Aggregate Into Sum()` cláusula se traduz em uma invocação de <xref:System.Linq.Enumerable.Sum%2A>.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como usar <xref:System.Linq.Enumerable.Sum%28System.Collections.Generic.IEnumerable%7BSystem.Single%7D%29> para somar os valores de uma sequência.  
  
 [!INCLUDE[sqo_diff_overload_example_elementtype](~/includes/sqo-diff-overload-example-elementtype-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#120](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#120)]
 [!code-vb[System.Linq.Enumerable#120](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#120)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> é <see langword="null" />.</exception>
        <exception cref="T:System.OverflowException">A soma é maior que <see cref="F:System.Int64.MaxValue" />.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/1315a814-5db6-4077-b34b-b141e11cc0eb">Cláusula Aggregate (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Sum">
      <MemberSignature Language="C#" Value="public static Nullable&lt;decimal&gt; Sum (this System.Collections.Generic.IEnumerable&lt;Nullable&lt;decimal&gt;&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;valuetype System.Decimal&gt; Sum(class System.Collections.Generic.IEnumerable`1&lt;valuetype System.Nullable`1&lt;valuetype System.Decimal&gt;&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Sum(System.Collections.Generic.IEnumerable{System.Nullable{System.Decimal}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Sum (source As IEnumerable(Of Nullable(Of Decimal))) As Nullable(Of Decimal)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Nullable&lt;System::Decimal&gt; Sum(System::Collections::Generic::IEnumerable&lt;Nullable&lt;System::Decimal&gt;&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Sum : seq&lt;Nullable&lt;decimal&gt;&gt; -&gt; Nullable&lt;decimal&gt;" Usage="System.Linq.Enumerable.Sum source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Decimal&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;System.Nullable&lt;System.Decimal&gt;&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Uma sequência de valores <see cref="T:System.Decimal" /> que permitem valores nulos para cálculo da soma.</param>
        <summary>Computa a soma de uma sequência de valores <see cref="T:System.Decimal" /> que permitem valores nulos.</summary>
        <returns>A soma dos valores na sequência.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método retornará zero se `source` não contiver elementos.  
  
 O resultado incluem valores que são `null`.  
  
 Na sintaxe de expressão de consulta do Visual Basic, uma `Aggregate Into Sum()` cláusula se traduz em uma invocação de <xref:System.Linq.Enumerable.Sum%2A>.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como usar <xref:System.Linq.Enumerable.Sum%28System.Collections.Generic.IEnumerable%7BSystem.Nullable%7BSystem.Single%7D%7D%29> para somar os valores de uma sequência.  
  
 [!INCLUDE[sqo_diff_overload_example_elementtype](~/includes/sqo-diff-overload-example-elementtype-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#121](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#121)]
 [!code-vb[System.Linq.Enumerable#121](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#121)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> é <see langword="null" />.</exception>
        <exception cref="T:System.OverflowException">A soma é maior que <see cref="F:System.Decimal.MaxValue" />.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/1315a814-5db6-4077-b34b-b141e11cc0eb">Cláusula Aggregate (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Sum">
      <MemberSignature Language="C#" Value="public static Nullable&lt;double&gt; Sum (this System.Collections.Generic.IEnumerable&lt;Nullable&lt;double&gt;&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;float64&gt; Sum(class System.Collections.Generic.IEnumerable`1&lt;valuetype System.Nullable`1&lt;float64&gt;&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Sum(System.Collections.Generic.IEnumerable{System.Nullable{System.Double}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Sum (source As IEnumerable(Of Nullable(Of Double))) As Nullable(Of Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Nullable&lt;double&gt; Sum(System::Collections::Generic::IEnumerable&lt;Nullable&lt;double&gt;&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Sum : seq&lt;Nullable&lt;double&gt;&gt; -&gt; Nullable&lt;double&gt;" Usage="System.Linq.Enumerable.Sum source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Double&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;System.Nullable&lt;System.Double&gt;&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Uma sequência de valores <see cref="T:System.Double" /> que permitem valores nulos para cálculo da soma.</param>
        <summary>Computa a soma de uma sequência de valores <see cref="T:System.Double" /> que permitem valores nulos.</summary>
        <returns>A soma dos valores na sequência.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método retornará zero se `source` não contiver elementos.  
  
 O resultado não inclui valores que são `null`.  
  
 Na sintaxe de expressão de consulta do Visual Basic, uma `Aggregate Into Sum()` cláusula se traduz em uma invocação de <xref:System.Linq.Enumerable.Sum%2A>.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como usar <xref:System.Linq.Enumerable.Sum%28System.Collections.Generic.IEnumerable%7BSystem.Nullable%7BSystem.Single%7D%7D%29> para somar os valores de uma sequência.  
  
 [!INCLUDE[sqo_diff_overload_example_elementtype](~/includes/sqo-diff-overload-example-elementtype-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#121](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#121)]
 [!code-vb[System.Linq.Enumerable#121](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#121)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> é <see langword="null" />.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/1315a814-5db6-4077-b34b-b141e11cc0eb">Cláusula Aggregate (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Sum">
      <MemberSignature Language="C#" Value="public static Nullable&lt;int&gt; Sum (this System.Collections.Generic.IEnumerable&lt;Nullable&lt;int&gt;&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;int32&gt; Sum(class System.Collections.Generic.IEnumerable`1&lt;valuetype System.Nullable`1&lt;int32&gt;&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Sum(System.Collections.Generic.IEnumerable{System.Nullable{System.Int32}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Sum (source As IEnumerable(Of Nullable(Of Integer))) As Nullable(Of Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Nullable&lt;int&gt; Sum(System::Collections::Generic::IEnumerable&lt;Nullable&lt;int&gt;&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Sum : seq&lt;Nullable&lt;int&gt;&gt; -&gt; Nullable&lt;int&gt;" Usage="System.Linq.Enumerable.Sum source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;System.Nullable&lt;System.Int32&gt;&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Uma sequência de valores <see cref="T:System.Int32" /> que permitem valores nulos para cálculo da soma.</param>
        <summary>Computa a soma de uma sequência de valores <see cref="T:System.Int32" /> que permitem valores nulos.</summary>
        <returns>A soma dos valores na sequência.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método retornará zero se `source` não contiver elementos.  
  
 O resultado não inclui valores que são `null`.  
  
 Na sintaxe de expressão de consulta do Visual Basic, uma `Aggregate Into Sum()` cláusula se traduz em uma invocação de <xref:System.Linq.Enumerable.Sum%2A>.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como usar <xref:System.Linq.Enumerable.Sum%28System.Collections.Generic.IEnumerable%7BSystem.Nullable%7BSystem.Single%7D%7D%29> para somar os valores de uma sequência.  
  
 [!INCLUDE[sqo_diff_overload_example_elementtype](~/includes/sqo-diff-overload-example-elementtype-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#121](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#121)]
 [!code-vb[System.Linq.Enumerable#121](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#121)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> é <see langword="null" />.</exception>
        <exception cref="T:System.OverflowException">A soma é maior que <see cref="F:System.Int32.MaxValue" />.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/1315a814-5db6-4077-b34b-b141e11cc0eb">Cláusula Aggregate (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Sum">
      <MemberSignature Language="C#" Value="public static Nullable&lt;long&gt; Sum (this System.Collections.Generic.IEnumerable&lt;Nullable&lt;long&gt;&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;int64&gt; Sum(class System.Collections.Generic.IEnumerable`1&lt;valuetype System.Nullable`1&lt;int64&gt;&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Sum(System.Collections.Generic.IEnumerable{System.Nullable{System.Int64}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Sum (source As IEnumerable(Of Nullable(Of Long))) As Nullable(Of Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Nullable&lt;long&gt; Sum(System::Collections::Generic::IEnumerable&lt;Nullable&lt;long&gt;&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Sum : seq&lt;Nullable&lt;int64&gt;&gt; -&gt; Nullable&lt;int64&gt;" Usage="System.Linq.Enumerable.Sum source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Int64&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;System.Nullable&lt;System.Int64&gt;&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Uma sequência de valores <see cref="T:System.Int64" /> que permitem valores nulos para cálculo da soma.</param>
        <summary>Computa a soma de uma sequência de valores <see cref="T:System.Int64" /> que permitem valores nulos.</summary>
        <returns>A soma dos valores na sequência.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método retornará zero se `source` não contiver elementos.  
  
 O resultado não inclui valores que são `null`.  
  
 Na sintaxe de expressão de consulta do Visual Basic, uma `Aggregate Into Sum()` cláusula se traduz em uma invocação de <xref:System.Linq.Enumerable.Sum%2A>.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como usar <xref:System.Linq.Enumerable.Sum%28System.Collections.Generic.IEnumerable%7BSystem.Nullable%7BSystem.Single%7D%7D%29> para somar os valores de uma sequência.  
  
 [!INCLUDE[sqo_diff_overload_example_elementtype](~/includes/sqo-diff-overload-example-elementtype-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#121](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#121)]
 [!code-vb[System.Linq.Enumerable#121](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#121)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> é <see langword="null" />.</exception>
        <exception cref="T:System.OverflowException">A soma é maior que <see cref="F:System.Int64.MaxValue" />.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/1315a814-5db6-4077-b34b-b141e11cc0eb">Cláusula Aggregate (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Sum">
      <MemberSignature Language="C#" Value="public static Nullable&lt;float&gt; Sum (this System.Collections.Generic.IEnumerable&lt;Nullable&lt;float&gt;&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;float32&gt; Sum(class System.Collections.Generic.IEnumerable`1&lt;valuetype System.Nullable`1&lt;float32&gt;&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Sum(System.Collections.Generic.IEnumerable{System.Nullable{System.Single}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Sum (source As IEnumerable(Of Nullable(Of Single))) As Nullable(Of Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Nullable&lt;float&gt; Sum(System::Collections::Generic::IEnumerable&lt;Nullable&lt;float&gt;&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Sum : seq&lt;Nullable&lt;single&gt;&gt; -&gt; Nullable&lt;single&gt;" Usage="System.Linq.Enumerable.Sum source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Single&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;System.Nullable&lt;System.Single&gt;&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Uma sequência de valores <see cref="T:System.Single" /> que permitem valores nulos para cálculo da soma.</param>
        <summary>Computa a soma de uma sequência de valores <see cref="T:System.Single" /> que permitem valores nulos.</summary>
        <returns>A soma dos valores na sequência.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método retornará zero se `source` não contiver elementos.  
  
 O resultado não inclui valores que são `null`.  
  
 Na sintaxe de expressão de consulta do Visual Basic, uma `Aggregate Into Sum()` cláusula se traduz em uma invocação de <xref:System.Linq.Enumerable.Sum%2A>.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como usar <xref:System.Linq.Enumerable.Sum%28System.Collections.Generic.IEnumerable%7BSystem.Nullable%7BSystem.Single%7D%7D%29> para somar os valores de uma sequência.  
  
 [!code-csharp[System.Linq.Enumerable#121](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#121)]
 [!code-vb[System.Linq.Enumerable#121](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#121)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> é <see langword="null" />.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/1315a814-5db6-4077-b34b-b141e11cc0eb">Cláusula Aggregate (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Sum">
      <MemberSignature Language="C#" Value="public static float Sum (this System.Collections.Generic.IEnumerable&lt;float&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 Sum(class System.Collections.Generic.IEnumerable`1&lt;float32&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Sum(System.Collections.Generic.IEnumerable{System.Single})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Sum (source As IEnumerable(Of Single)) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static float Sum(System::Collections::Generic::IEnumerable&lt;float&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Sum : seq&lt;single&gt; -&gt; single" Usage="System.Linq.Enumerable.Sum source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;System.Single&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Uma sequência de valores <see cref="T:System.Single" /> para cálculo da soma.</param>
        <summary>Calcula a soma de uma sequência de valores <see cref="T:System.Single" />.</summary>
        <returns>A soma dos valores na sequência.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método retornará zero se `source` não contiver elementos.  
  
 Na sintaxe de expressão de consulta do Visual Basic, uma `Aggregate Into Sum()` cláusula se traduz em uma invocação de <xref:System.Linq.Enumerable.Sum%2A>.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como usar <xref:System.Linq.Enumerable.Sum%28System.Collections.Generic.IEnumerable%7BSystem.Single%7D%29> para somar os valores de uma sequência.  
  
 [!code-csharp[System.Linq.Enumerable#120](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#120)]
 [!code-vb[System.Linq.Enumerable#120](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#120)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> é <see langword="null" />.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/1315a814-5db6-4077-b34b-b141e11cc0eb">Cláusula Aggregate (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Sum&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static decimal Sum&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,decimal&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Decimal Sum&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, valuetype System.Decimal&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Sum``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Decimal})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Sum(Of TSource) (source As IEnumerable(Of TSource), selector As Func(Of TSource, Decimal)) As Decimal" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Decimal Sum(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Func&lt;TSource, System::Decimal&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="static member Sum : seq&lt;'Source&gt; * Func&lt;'Source, decimal&gt; -&gt; decimal" Usage="System.Linq.Enumerable.Sum (source, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Decimal&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">O tipo dos elementos de <paramref name="source" />.</typeparam>
        <param name="source">Uma sequência de valores usados para calcular uma soma.</param>
        <param name="selector">Uma função de transformação a ser aplicada a cada elemento.</param>
        <summary>Calcula a soma da sequência de valores <see cref="T:System.Decimal" /> obtidos pela invocação de uma função de transformação em cada elemento da sequência de entrada.</summary>
        <returns>A soma dos valores projetados.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método retornará zero se `source` não contiver elementos.  
  
 Você pode aplicar esse método em uma sequência de valores arbitrários, se você fornecer uma função `selector`, que os membros de projetos `source` em um tipo numérico, especificamente <xref:System.Decimal>.  
  
 Na sintaxe de expressão de consulta do Visual Basic, uma `Aggregate Into Sum()` cláusula se traduz em uma invocação de <xref:System.Linq.Enumerable.Sum%2A>.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como usar <xref:System.Linq.Enumerable.Sum%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Double%7D%29> para somar os valores previstos de uma sequência.  
  
 [!INCLUDE[sqo_diff_overload_example_func](~/includes/sqo-diff-overload-example-func-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#98](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#98)]
 [!code-vb[System.Linq.Enumerable#98](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#98)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> ou <paramref name="selector" /> é <see langword="null" />.</exception>
        <exception cref="T:System.OverflowException">A soma é maior que <see cref="F:System.Decimal.MaxValue" />.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/1315a814-5db6-4077-b34b-b141e11cc0eb">Cláusula Aggregate (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Sum&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static double Sum&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,double&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Sum&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, float64&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Sum``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Double})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Sum(Of TSource) (source As IEnumerable(Of TSource), selector As Func(Of TSource, Double)) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static double Sum(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Func&lt;TSource, double&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="static member Sum : seq&lt;'Source&gt; * Func&lt;'Source, double&gt; -&gt; double" Usage="System.Linq.Enumerable.Sum (source, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Double&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">O tipo dos elementos de <paramref name="source" />.</typeparam>
        <param name="source">Uma sequência de valores usados para calcular uma soma.</param>
        <param name="selector">Uma função de transformação a ser aplicada a cada elemento.</param>
        <summary>Calcula a soma da sequência de valores <see cref="T:System.Double" /> obtidos pela invocação de uma função de transformação em cada elemento da sequência de entrada.</summary>
        <returns>A soma dos valores projetados.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método retornará zero se `source` não contiver elementos.  
  
 Você pode aplicar esse método em uma sequência de valores arbitrários, se você fornecer uma função `selector`, que os membros de projetos `source` em um tipo numérico, especificamente <xref:System.Double>.  
  
 Na sintaxe de expressão de consulta do Visual Basic, uma `Aggregate Into Sum()` cláusula se traduz em uma invocação de <xref:System.Linq.Enumerable.Sum%2A>.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como usar <xref:System.Linq.Enumerable.Sum%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Double%7D%29> para somar os valores previstos de uma sequência.  
  
 [!code-csharp[System.Linq.Enumerable#98](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#98)]
 [!code-vb[System.Linq.Enumerable#98](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#98)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> ou <paramref name="selector" /> é <see langword="null" />.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/1315a814-5db6-4077-b34b-b141e11cc0eb">Cláusula Aggregate (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Sum&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static int Sum&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,int&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Sum&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, int32&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Sum``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Int32})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Sum(Of TSource) (source As IEnumerable(Of TSource), selector As Func(Of TSource, Integer)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static int Sum(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Func&lt;TSource, int&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="static member Sum : seq&lt;'Source&gt; * Func&lt;'Source, int&gt; -&gt; int" Usage="System.Linq.Enumerable.Sum (source, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Int32&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">O tipo dos elementos de <paramref name="source" />.</typeparam>
        <param name="source">Uma sequência de valores usados para calcular uma soma.</param>
        <param name="selector">Uma função de transformação a ser aplicada a cada elemento.</param>
        <summary>Calcula a soma da sequência de valores <see cref="T:System.Int32" /> obtidos pela invocação de uma função de transformação em cada elemento da sequência de entrada.</summary>
        <returns>A soma dos valores projetados.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método retornará zero se `source` não contiver elementos.  
  
 Você pode aplicar esse método em uma sequência de valores arbitrários, se você fornecer uma função `selector`, que os membros de projetos `source` em um tipo numérico, especificamente <xref:System.Int32>.  
  
 Na sintaxe de expressão de consulta do Visual Basic, uma `Aggregate Into Sum()` cláusula se traduz em uma invocação de <xref:System.Linq.Enumerable.Sum%2A>.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como usar <xref:System.Linq.Enumerable.Sum%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Double%7D%29> para somar os valores previstos de uma sequência.  
  
 [!INCLUDE[sqo_diff_overload_example_func](~/includes/sqo-diff-overload-example-func-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#98](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#98)]
 [!code-vb[System.Linq.Enumerable#98](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#98)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> ou <paramref name="selector" /> é <see langword="null" />.</exception>
        <exception cref="T:System.OverflowException">A soma é maior que <see cref="F:System.Int32.MaxValue" />.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/1315a814-5db6-4077-b34b-b141e11cc0eb">Cláusula Aggregate (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Sum&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static long Sum&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,long&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 Sum&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, int64&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Sum``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Int64})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Sum(Of TSource) (source As IEnumerable(Of TSource), selector As Func(Of TSource, Long)) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static long Sum(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Func&lt;TSource, long&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="static member Sum : seq&lt;'Source&gt; * Func&lt;'Source, int64&gt; -&gt; int64" Usage="System.Linq.Enumerable.Sum (source, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Int64&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">O tipo dos elementos de <paramref name="source" />.</typeparam>
        <param name="source">Uma sequência de valores usados para calcular uma soma.</param>
        <param name="selector">Uma função de transformação a ser aplicada a cada elemento.</param>
        <summary>Calcula a soma da sequência de valores <see cref="T:System.Int64" /> obtidos pela invocação de uma função de transformação em cada elemento da sequência de entrada.</summary>
        <returns>A soma dos valores projetados.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método retornará zero se `source` não contiver elementos.  
  
 Você pode aplicar esse método em uma sequência de valores arbitrários, se você fornecer uma função `selector`, que os membros de projetos `source` em um tipo numérico, especificamente <xref:System.Int64>.  
  
 Na sintaxe de expressão de consulta do Visual Basic, uma `Aggregate Into Sum()` cláusula se traduz em uma invocação de <xref:System.Linq.Enumerable.Sum%2A>.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como usar <xref:System.Linq.Enumerable.Sum%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Double%7D%29> para somar os valores previstos de uma sequência.  
  
 [!INCLUDE[sqo_diff_overload_example_func](~/includes/sqo-diff-overload-example-func-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#98](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#98)]
 [!code-vb[System.Linq.Enumerable#98](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#98)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> ou <paramref name="selector" /> é <see langword="null" />.</exception>
        <exception cref="T:System.OverflowException">A soma é maior que <see cref="F:System.Int64.MaxValue" />.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/1315a814-5db6-4077-b34b-b141e11cc0eb">Cláusula Aggregate (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Sum&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static Nullable&lt;decimal&gt; Sum&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,Nullable&lt;decimal&gt;&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;valuetype System.Decimal&gt; Sum&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, valuetype System.Nullable`1&lt;valuetype System.Decimal&gt;&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Sum``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Nullable{System.Decimal}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Sum(Of TSource) (source As IEnumerable(Of TSource), selector As Func(Of TSource, Nullable(Of Decimal))) As Nullable(Of Decimal)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Nullable&lt;System::Decimal&gt; Sum(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Func&lt;TSource, Nullable&lt;System::Decimal&gt;&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="static member Sum : seq&lt;'Source&gt; * Func&lt;'Source, Nullable&lt;decimal&gt;&gt; -&gt; Nullable&lt;decimal&gt;" Usage="System.Linq.Enumerable.Sum (source, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Decimal&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Nullable&lt;System.Decimal&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">O tipo dos elementos de <paramref name="source" />.</typeparam>
        <param name="source">Uma sequência de valores usados para calcular uma soma.</param>
        <param name="selector">Uma função de transformação a ser aplicada a cada elemento.</param>
        <summary>Calcula a soma da sequência de valores <see cref="T:System.Decimal" /> anuláveis obtidos pela invocação de uma função de transformação em cada elemento da sequência de entrada.</summary>
        <returns>A soma dos valores projetados.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método retornará zero se `source` não contiver elementos.  
  
 O resultado não incluía valores que são `null`.  
  
 Você pode aplicar esse método em uma sequência de valores arbitrários, se você fornecer uma função `selector`, que os membros de projetos `source` em um tipo numérico, especificamente `Nullable<Decimal>` em c# ou `Nullable(Of Decimal)` no Visual Basic.  
  
 Na sintaxe de expressão de consulta do Visual Basic, uma `Aggregate Into Sum()` cláusula se traduz em uma invocação de <xref:System.Linq.Enumerable.Sum%2A>.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como usar <xref:System.Linq.Enumerable.Sum%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Double%7D%29> para somar os valores previstos de uma sequência.  
  
 [!INCLUDE[sqo_diff_overload_example_func](~/includes/sqo-diff-overload-example-func-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#98](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#98)]
 [!code-vb[System.Linq.Enumerable#98](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#98)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> ou <paramref name="selector" /> é <see langword="null" />.</exception>
        <exception cref="T:System.OverflowException">A soma é maior que <see cref="F:System.Decimal.MaxValue" />.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/1315a814-5db6-4077-b34b-b141e11cc0eb">Cláusula Aggregate (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Sum&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static Nullable&lt;double&gt; Sum&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,Nullable&lt;double&gt;&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;float64&gt; Sum&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, valuetype System.Nullable`1&lt;float64&gt;&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Sum``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Nullable{System.Double}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Sum(Of TSource) (source As IEnumerable(Of TSource), selector As Func(Of TSource, Nullable(Of Double))) As Nullable(Of Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Nullable&lt;double&gt; Sum(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Func&lt;TSource, Nullable&lt;double&gt;&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="static member Sum : seq&lt;'Source&gt; * Func&lt;'Source, Nullable&lt;double&gt;&gt; -&gt; Nullable&lt;double&gt;" Usage="System.Linq.Enumerable.Sum (source, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Double&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Nullable&lt;System.Double&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">O tipo dos elementos de <paramref name="source" />.</typeparam>
        <param name="source">Uma sequência de valores usados para calcular uma soma.</param>
        <param name="selector">Uma função de transformação a ser aplicada a cada elemento.</param>
        <summary>Calcula a soma da sequência de valores <see cref="T:System.Double" /> anuláveis obtidos pela invocação de uma função de transformação em cada elemento da sequência de entrada.</summary>
        <returns>A soma dos valores projetados.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método retornará zero se `source` não contiver elementos.  
  
 O resultado não inclui valores que são `null`.  
  
 Você pode aplicar esse método em uma sequência de valores arbitrários, se você fornecer uma função `selector`, que os membros de projetos `source` em um tipo numérico, especificamente `Nullable<Double>` em c# ou `Nullable(Of Double)` no Visual Basic.  
  
 Na sintaxe de expressão de consulta do Visual Basic, uma `Aggregate Into Sum()` cláusula se traduz em uma invocação de <xref:System.Linq.Enumerable.Sum%2A>.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como usar <xref:System.Linq.Enumerable.Sum%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Double%7D%29> para somar os valores previstos de uma sequência.  
  
 [!INCLUDE[sqo_diff_overload_example_func](~/includes/sqo-diff-overload-example-func-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#98](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#98)]
 [!code-vb[System.Linq.Enumerable#98](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#98)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> ou <paramref name="selector" /> é <see langword="null" />.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/1315a814-5db6-4077-b34b-b141e11cc0eb">Cláusula Aggregate (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Sum&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static Nullable&lt;int&gt; Sum&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,Nullable&lt;int&gt;&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;int32&gt; Sum&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, valuetype System.Nullable`1&lt;int32&gt;&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Sum``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Nullable{System.Int32}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Sum(Of TSource) (source As IEnumerable(Of TSource), selector As Func(Of TSource, Nullable(Of Integer))) As Nullable(Of Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Nullable&lt;int&gt; Sum(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Func&lt;TSource, Nullable&lt;int&gt;&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="static member Sum : seq&lt;'Source&gt; * Func&lt;'Source, Nullable&lt;int&gt;&gt; -&gt; Nullable&lt;int&gt;" Usage="System.Linq.Enumerable.Sum (source, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Nullable&lt;System.Int32&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">O tipo dos elementos de <paramref name="source" />.</typeparam>
        <param name="source">Uma sequência de valores usados para calcular uma soma.</param>
        <param name="selector">Uma função de transformação a ser aplicada a cada elemento.</param>
        <summary>Calcula a soma da sequência de valores <see cref="T:System.Int32" /> anuláveis obtidos pela invocação de uma função de transformação em cada elemento da sequência de entrada.</summary>
        <returns>A soma dos valores projetados.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método retornará zero se `source` não contiver elementos.  
  
 O resultado não inclui valores que são `null`.  
  
 Você pode aplicar esse método em uma sequência de valores arbitrários, se você fornecer uma função `selector`, que os membros de projetos `source` em um tipo numérico, especificamente `Nullable<Int32>` em c# ou `Nullable(Of Int32)` no Visual Basic.  
  
 Na sintaxe de expressão de consulta do Visual Basic, uma `Aggregate Into Sum()` cláusula se traduz em uma invocação de <xref:System.Linq.Enumerable.Sum%2A>.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como usar <xref:System.Linq.Enumerable.Sum%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Double%7D%29> para somar os valores previstos de uma sequência.  
  
 [!INCLUDE[sqo_diff_overload_example_func](~/includes/sqo-diff-overload-example-func-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#98](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#98)]
 [!code-vb[System.Linq.Enumerable#98](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#98)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> ou <paramref name="selector" /> é <see langword="null" />.</exception>
        <exception cref="T:System.OverflowException">A soma é maior que <see cref="F:System.Int32.MaxValue" />.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/1315a814-5db6-4077-b34b-b141e11cc0eb">Cláusula Aggregate (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Sum&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static Nullable&lt;long&gt; Sum&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,Nullable&lt;long&gt;&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;int64&gt; Sum&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, valuetype System.Nullable`1&lt;int64&gt;&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Sum``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Nullable{System.Int64}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Sum(Of TSource) (source As IEnumerable(Of TSource), selector As Func(Of TSource, Nullable(Of Long))) As Nullable(Of Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Nullable&lt;long&gt; Sum(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Func&lt;TSource, Nullable&lt;long&gt;&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="static member Sum : seq&lt;'Source&gt; * Func&lt;'Source, Nullable&lt;int64&gt;&gt; -&gt; Nullable&lt;int64&gt;" Usage="System.Linq.Enumerable.Sum (source, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Int64&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Nullable&lt;System.Int64&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">O tipo dos elementos de <paramref name="source" />.</typeparam>
        <param name="source">Uma sequência de valores usados para calcular uma soma.</param>
        <param name="selector">Uma função de transformação a ser aplicada a cada elemento.</param>
        <summary>Calcula a soma da sequência de valores <see cref="T:System.Int64" /> anuláveis obtidos pela invocação de uma função de transformação em cada elemento da sequência de entrada.</summary>
        <returns>A soma dos valores projetados.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método retornará zero se `source` não contiver elementos.  
  
 O resultado não inclui valores que são `null`.  
  
 Você pode aplicar esse método em uma sequência de valores arbitrários, se você fornecer uma função `selector`, que os membros de projetos `source` em um tipo numérico, especificamente `Nullable<Int64>` em c# ou `Nullable(Of Int64)` no Visual Basic  
  
 Na sintaxe de expressão de consulta do Visual Basic, uma `Aggregate Into Sum()` cláusula se traduz em uma invocação de <xref:System.Linq.Enumerable.Sum%2A>.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como usar <xref:System.Linq.Enumerable.Sum%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Double%7D%29> para somar os valores previstos de uma sequência.  
  
 [!INCLUDE[sqo_diff_overload_example_func](~/includes/sqo-diff-overload-example-func-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#98](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#98)]
 [!code-vb[System.Linq.Enumerable#98](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#98)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> ou <paramref name="selector" /> é <see langword="null" />.</exception>
        <exception cref="T:System.OverflowException">A soma é maior que <see cref="F:System.Int64.MaxValue" />.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/1315a814-5db6-4077-b34b-b141e11cc0eb">Cláusula Aggregate (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Sum&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static Nullable&lt;float&gt; Sum&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,Nullable&lt;float&gt;&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;float32&gt; Sum&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, valuetype System.Nullable`1&lt;float32&gt;&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Sum``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Nullable{System.Single}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Sum(Of TSource) (source As IEnumerable(Of TSource), selector As Func(Of TSource, Nullable(Of Single))) As Nullable(Of Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Nullable&lt;float&gt; Sum(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Func&lt;TSource, Nullable&lt;float&gt;&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="static member Sum : seq&lt;'Source&gt; * Func&lt;'Source, Nullable&lt;single&gt;&gt; -&gt; Nullable&lt;single&gt;" Usage="System.Linq.Enumerable.Sum (source, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Single&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Nullable&lt;System.Single&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">O tipo dos elementos de <paramref name="source" />.</typeparam>
        <param name="source">Uma sequência de valores usados para calcular uma soma.</param>
        <param name="selector">Uma função de transformação a ser aplicada a cada elemento.</param>
        <summary>Calcula a soma da sequência de valores <see cref="T:System.Single" /> anuláveis obtidos pela invocação de uma função de transformação em cada elemento da sequência de entrada.</summary>
        <returns>A soma dos valores projetados.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método retornará zero se `source` não contiver elementos.  
  
 O resultado não inclui valores que são `null`.  
  
 Você pode aplicar esse método em uma sequência de valores arbitrários, se você fornecer uma função `selector`, que os membros de projetos `source` em um tipo numérico, especificamente `Nullable<Single>` em c# ou `Nullable(Of Single)` no Visual Basic.  
  
 Na sintaxe de expressão de consulta do Visual Basic, uma `Aggregate Into Sum()` cláusula se traduz em uma invocação de <xref:System.Linq.Enumerable.Sum%2A>.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como usar <xref:System.Linq.Enumerable.Sum%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Double%7D%29> para somar os valores previstos de uma sequência.  
  
 [!INCLUDE[sqo_diff_overload_example_func](~/includes/sqo-diff-overload-example-func-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#98](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#98)]
 [!code-vb[System.Linq.Enumerable#98](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#98)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> ou <paramref name="selector" /> é <see langword="null" />.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/1315a814-5db6-4077-b34b-b141e11cc0eb">Cláusula Aggregate (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Sum&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static float Sum&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,float&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 Sum&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, float32&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Sum``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Single})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Sum(Of TSource) (source As IEnumerable(Of TSource), selector As Func(Of TSource, Single)) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static float Sum(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Func&lt;TSource, float&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="static member Sum : seq&lt;'Source&gt; * Func&lt;'Source, single&gt; -&gt; single" Usage="System.Linq.Enumerable.Sum (source, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Single&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">O tipo dos elementos de <paramref name="source" />.</typeparam>
        <param name="source">Uma sequência de valores usados para calcular uma soma.</param>
        <param name="selector">Uma função de transformação a ser aplicada a cada elemento.</param>
        <summary>Calcula a soma da sequência de valores <see cref="T:System.Single" /> obtidos pela invocação de uma função de transformação em cada elemento da sequência de entrada.</summary>
        <returns>A soma dos valores projetados.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Linq.Enumerable.Sum%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Single%7D%29> método retorna zero se `source` não contiver elementos.  
  
 Você pode aplicar esse método em uma sequência de valores arbitrários, se você fornecer uma função `selector`, que os membros de projetos `source` em um tipo numérico, especificamente <xref:System.Single>.  
  
 Na sintaxe de expressão de consulta do Visual Basic, uma `Aggregate Into Sum()` cláusula se traduz em uma invocação de <xref:System.Linq.Enumerable.Sum%2A>.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como usar <xref:System.Linq.Enumerable.Sum%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Double%7D%29> para somar os valores previstos de uma sequência.  
  
 [!INCLUDE[sqo_diff_overload_example_func](~/includes/sqo-diff-overload-example-func-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#98](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#98)]
 [!code-vb[System.Linq.Enumerable#98](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#98)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> ou <paramref name="selector" /> é <see langword="null" />.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/1315a814-5db6-4077-b34b-b141e11cc0eb">Cláusula Aggregate (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Take&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;TSource&gt; Take&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; Take&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Take``1(System.Collections.Generic.IEnumerable{``0},System.Int32)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Take(Of TSource) (source As IEnumerable(Of TSource), count As Integer) As IEnumerable(Of TSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ Take(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, int count);" />
      <MemberSignature Language="F#" Value="static member Take : seq&lt;'Source&gt; * int -&gt; seq&lt;'Source&gt;" Usage="System.Linq.Enumerable.Take (source, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">O tipo dos elementos de <paramref name="source" />.</typeparam>
        <param name="source">A sequência da qual os elementos serão retornados.</param>
        <param name="count">O número de elementos a serem retornados.</param>
        <summary>Retorna um número especificado de elementos contíguos do início de uma sequência.</summary>
        <returns>Um <see cref="T:System.Collections.Generic.IEnumerable`1" /> que contém o número especificado de elementos do início da sequência de entrada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método é implementado usando a execução adiada. O imediata valor retornado é um objeto que armazena todas as informações necessárias para executar a ação. A consulta representada por esse método não é executada até que o objeto é enumerado chamando-se suas `GetEnumerator` método diretamente ou usando `foreach` no Visual c# ou `For Each` no Visual Basic.  
  
 <xref:System.Linq.Enumerable.Take%2A> Enumera `source` e gera elementos de até `count` elementos foram produzidos ou `source` não contém mais nenhum elemento. Se `count` excede o número de elementos no `source`, todos os elementos de `source` são retornados.  
  
 Se `count` é menor que ou igual a zero, `source` não é enumerada e um vazio <xref:System.Collections.Generic.IEnumerable%601> é retornado.  
  
 O <xref:System.Linq.Enumerable.Take%2A> e <xref:System.Linq.Enumerable.Skip%2A> métodos são complementa funcional. Dada uma determinada sequência `coll` e um número inteiro `n`, concatenando os resultados de `coll.Take(n)` e `coll.Skip(n)` produz a mesma sequência que `coll`.  
  
 Na sintaxe de expressão de consulta do Visual Basic, uma `Take` cláusula se traduz em uma invocação de <xref:System.Linq.Enumerable.Take%2A>.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como usar <xref:System.Linq.Enumerable.Take%2A> para retornar os elementos desde o início de uma sequência.  
  
 [!code-csharp[System.Linq.Enumerable#99](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#99)]
 [!code-vb[System.Linq.Enumerable#99](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#99)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> é <see langword="null" />.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/77bf87b2-1476-4456-957f-fee922fbad8c">Cláusula Take (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="TakeLast&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;TSource&gt; TakeLast&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; TakeLast&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.TakeLast``1(System.Collections.Generic.IEnumerable{``0},System.Int32)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function TakeLast(Of TSource) (source As IEnumerable(Of TSource), count As Integer) As IEnumerable(Of TSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ TakeLast(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, int count);" />
      <MemberSignature Language="F#" Value="static member TakeLast : seq&lt;'Source&gt; * int -&gt; seq&lt;'Source&gt;" Usage="System.Linq.Enumerable.TakeLast (source, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">To be added.</typeparam>
        <param name="source">To be added.</param>
        <param name="count">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="TakeWhile&lt;TSource&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Retorna elementos de uma sequência contanto que uma condição especificada seja true e, em seguida, ignora os elementos restantes.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="TakeWhile&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;TSource&gt; TakeWhile&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,bool&gt; predicate);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; TakeWhile&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, bool&gt; predicate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.TakeWhile``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Boolean})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function TakeWhile(Of TSource) (source As IEnumerable(Of TSource), predicate As Func(Of TSource, Boolean)) As IEnumerable(Of TSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ TakeWhile(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Func&lt;TSource, bool&gt; ^ predicate);" />
      <MemberSignature Language="F#" Value="static member TakeWhile : seq&lt;'Source&gt; * Func&lt;'Source, bool&gt; -&gt; seq&lt;'Source&gt;" Usage="System.Linq.Enumerable.TakeWhile (source, predicate)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="predicate" Type="System.Func&lt;TSource,System.Boolean&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">O tipo dos elementos de <paramref name="source" />.</typeparam>
        <param name="source">Uma sequência a qual retornar os elementos.</param>
        <param name="predicate">Uma função para testar cada elemento em relação a uma condição.</param>
        <summary>Retorna os elementos de uma sequência contanto que uma condição especificada seja verdadeira.</summary>
        <returns>Um <see cref="T:System.Collections.Generic.IEnumerable`1" /> que contém elementos da sequência de entrada que ocorrem antes do elemento no qual o teste não é mais aprovado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método é implementado usando a execução adiada. O imediata valor retornado é um objeto que armazena todas as informações necessárias para executar a ação. A consulta representada por esse método não é executada até que o objeto é enumerado chamando-se suas `GetEnumerator` método diretamente ou usando `foreach` no Visual c# ou `For Each` no Visual Basic.  
  
 O <xref:System.Linq.Enumerable.TakeWhile%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Boolean%7D%29> método testa cada elemento de `source` usando `predicate` , gerando o elemento se o resultado for `true`. Enumeração interrompe quando a função de predicado retorna `false` para um elemento ou quando `source` não contém mais nenhum elemento.  
  
 O <xref:System.Linq.Enumerable.TakeWhile%2A> e <xref:System.Linq.Enumerable.SkipWhile%2A> métodos são complementa funcional. Dada uma determinada sequência `coll` e uma função pura `p`, concatenando os resultados de `coll.TakeWhile(p)` e `coll.SkipWhile(p)` produz a mesma sequência que `coll`.  
  
 Na sintaxe de expressão de consulta do Visual Basic, uma `Take While` cláusula se traduz em uma invocação de <xref:System.Linq.Enumerable.TakeWhile%2A>.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como usar <xref:System.Linq.Enumerable.TakeWhile%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Boolean%7D%29> para retornar elementos desde o início de uma sequência, desde que uma condição seja verdadeira.  
  
 [!code-csharp[System.Linq.Enumerable#100](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#100)]
 [!code-vb[System.Linq.Enumerable#100](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#100)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> ou <paramref name="predicate" /> é <see langword="null" />.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/db8f9f2f-fc9f-4a6c-b0b8-1bf048147e11">Cláusula Take While (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="TakeWhile&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;TSource&gt; TakeWhile&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,int,bool&gt; predicate);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; TakeWhile&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`3&lt;!!TSource, int32, bool&gt; predicate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.TakeWhile``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Int32,System.Boolean})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function TakeWhile(Of TSource) (source As IEnumerable(Of TSource), predicate As Func(Of TSource, Integer, Boolean)) As IEnumerable(Of TSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ TakeWhile(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Func&lt;TSource, int, bool&gt; ^ predicate);" />
      <MemberSignature Language="F#" Value="static member TakeWhile : seq&lt;'Source&gt; * Func&lt;'Source, int, bool&gt; -&gt; seq&lt;'Source&gt;" Usage="System.Linq.Enumerable.TakeWhile (source, predicate)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="predicate" Type="System.Func&lt;TSource,System.Int32,System.Boolean&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">O tipo dos elementos de <paramref name="source" />.</typeparam>
        <param name="source">A sequência da qual os elementos serão retornados.</param>
        <param name="predicate">Uma função para testar cada elemento de origem em relação a uma condição; o segundo parâmetro da função representa o índice do elemento de origem.</param>
        <summary>Retorna os elementos de uma sequência contanto que uma condição especificada seja verdadeira. O índice do elemento é usado na lógica da função de predicado.</summary>
        <returns>Um <see cref="T:System.Collections.Generic.IEnumerable`1" /> que contém elementos da sequência de entrada que ocorrem antes do elemento no qual o teste não é mais aprovado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método é implementado usando a execução adiada. O imediata valor retornado é um objeto que armazena todas as informações necessárias para executar a ação. A consulta representada por esse método não é executada até que o objeto é enumerado chamando-se suas `GetEnumerator` método diretamente ou usando `foreach` no Visual c# ou `For Each` no Visual Basic.  
  
 O <xref:System.Linq.Enumerable.TakeWhile%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Int32%2CSystem.Boolean%7D%29> método testa cada elemento de `source` usando `predicate` , gerando o elemento se o resultado for `true`. Enumeração interrompe quando a função de predicado retorna `false` para um elemento ou quando `source` não contém mais nenhum elemento.  
  
 O primeiro argumento do `predicate` representa o elemento a ser testado. O segundo argumento representa o índice baseado em zero do elemento no `source`.  
  
 O <xref:System.Linq.Enumerable.TakeWhile%2A> e <xref:System.Linq.Enumerable.SkipWhile%2A> métodos são complementa funcional. Dada uma determinada sequência `coll` e uma função pura `p`, concatenando os resultados de `coll.TakeWhile(p)` e `coll.SkipWhile(p)` produz a mesma sequência que `coll`.  
  
 Na sintaxe de expressão de consulta do Visual Basic, uma `Take While` cláusula se traduz em uma invocação de <xref:System.Linq.Enumerable.TakeWhile%2A>.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como usar <xref:System.Linq.Enumerable.TakeWhile%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Int32%2CSystem.Boolean%7D%29> para retornar elementos desde o início de uma sequência, desde que uma condição que usa o índice do elemento é verdadeira.  
  
 [!code-csharp[System.Linq.Enumerable#101](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#101)]
 [!code-vb[System.Linq.Enumerable#101](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#101)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> ou <paramref name="predicate" /> é <see langword="null" />.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/db8f9f2f-fc9f-4a6c-b0b8-1bf048147e11">Cláusula Take While (Visual Basic)</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="ThenBy&lt;TSource,TKey&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Executa uma ordenação posterior dos elementos em uma sequência em ordem crescente.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ThenBy&lt;TSource,TKey&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.IOrderedEnumerable&lt;TSource&gt; ThenBy&lt;TSource,TKey&gt; (this System.Linq.IOrderedEnumerable&lt;TSource&gt; source, Func&lt;TSource,TKey&gt; keySelector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.IOrderedEnumerable`1&lt;!!TSource&gt; ThenBy&lt;TSource, TKey&gt;(class System.Linq.IOrderedEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, !!TKey&gt; keySelector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.ThenBy``2(System.Linq.IOrderedEnumerable{``0},System.Func{``0,``1})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ThenBy(Of TSource, TKey) (source As IOrderedEnumerable(Of TSource), keySelector As Func(Of TSource, TKey)) As IOrderedEnumerable(Of TSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TKey&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::IOrderedEnumerable&lt;TSource&gt; ^ ThenBy(System::Linq::IOrderedEnumerable&lt;TSource&gt; ^ source, Func&lt;TSource, TKey&gt; ^ keySelector);" />
      <MemberSignature Language="F#" Value="static member ThenBy : System.Linq.IOrderedEnumerable&lt;'Source&gt; * Func&lt;'Source, 'Key&gt; -&gt; System.Linq.IOrderedEnumerable&lt;'Source&gt;" Usage="System.Linq.Enumerable.ThenBy (source, keySelector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.IOrderedEnumerable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TKey" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IOrderedEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="keySelector" Type="System.Func&lt;TSource,TKey&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">O tipo dos elementos de <paramref name="source" />.</typeparam>
        <typeparam name="TKey">O tipo da chave retornada por <paramref name="keySelector" />.</typeparam>
        <param name="source">Um <see cref="T:System.Linq.IOrderedEnumerable`1" /> que contém elementos a ser classificados.</param>
        <param name="keySelector">Uma função para extrair uma chave de cada elemento.</param>
        <summary>Executa uma ordenação posterior dos elementos em uma sequência em ordem crescente de acordo com uma chave.</summary>
        <returns>Um <see cref="T:System.Linq.IOrderedEnumerable`1" /> cujos elementos são classificados de acordo com uma chave.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método é implementado usando a execução adiada. O imediata valor retornado é um objeto que armazena todas as informações necessárias para executar a ação. A consulta representada por esse método não é executada até que o objeto é enumerado chamando-se suas `GetEnumerator` método diretamente ou usando `foreach` no Visual c# ou `For Each` no Visual Basic.  
  
 Para solicitar uma sequência pelos valores dos próprios elementos, especifique a função identity (`x => x` no Visual c# ou `Function(x) x` no Visual Basic) para `keySelector`.  
  
 <xref:System.Linq.Enumerable.ThenBy%2A> e <xref:System.Linq.Enumerable.ThenByDescending%2A> são definidos para estender o tipo <xref:System.Linq.IOrderedEnumerable%601>, que também é o tipo de retorno dos métodos a seguir. Esse design permite que você especificar vários critérios de classificação por meio da aplicação de qualquer número de <xref:System.Linq.Enumerable.ThenBy%2A> ou <xref:System.Linq.Enumerable.ThenByDescending%2A> métodos.  
  
> [!NOTE]
>  Porque <xref:System.Linq.IOrderedEnumerable%601> herda <xref:System.Collections.Generic.IEnumerable%601>, você pode chamar <xref:System.Linq.Enumerable.OrderBy%2A> ou <xref:System.Linq.Enumerable.OrderByDescending%2A> nos resultados de uma chamada para <xref:System.Linq.Enumerable.OrderBy%2A>, <xref:System.Linq.Enumerable.OrderByDescending%2A>, <xref:System.Linq.Enumerable.ThenBy%2A> ou <xref:System.Linq.Enumerable.ThenByDescending%2A>. Isso apresenta um novo primário ordenação que ignora a ordem estabelecida anteriormente.  
  
 Esse método compara as chaves usando o comparador padrão <xref:System.Collections.Generic.Comparer%601.Default%2A>.  
  
 Esse método executa uma classificação estável; ou seja, se as chaves de dois elementos são iguais, a ordem dos elementos é preservada. Em contraste, uma classificação instável não preserva a ordem dos elementos que têm a mesma chave.  
  
 Na sintaxe de expressão de consulta, uma `orderby [first criterion], [second criterion]` (Visual c#) ou `Order By [first criterion], [second criterion]` cláusula (Visual Basic) se traduz em uma invocação de <xref:System.Linq.Enumerable.ThenBy%2A>.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como usar <xref:System.Linq.Enumerable.ThenBy%60%602%28System.Linq.IOrderedEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2C%60%601%7D%29> para executar uma classificação secundária dos elementos em uma sequência.  
  
 [!code-csharp[System.Linq.Enumerable#102](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#102)]
 [!code-vb[System.Linq.Enumerable#102](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#102)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> ou <paramref name="keySelector" /> é <see langword="null" />.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/21f87f48-d69d-4e95-9a52-6fec47b37e1f">Cláusula orderby (Referência de C#)</related>
        <related type="Article" href="https://msdn.microsoft.com/library/fa911282-6b81-44c7-acfa-46b5bb93df75">Cláusula Order By (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="ThenBy&lt;TSource,TKey&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.IOrderedEnumerable&lt;TSource&gt; ThenBy&lt;TSource,TKey&gt; (this System.Linq.IOrderedEnumerable&lt;TSource&gt; source, Func&lt;TSource,TKey&gt; keySelector, System.Collections.Generic.IComparer&lt;TKey&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.IOrderedEnumerable`1&lt;!!TSource&gt; ThenBy&lt;TSource, TKey&gt;(class System.Linq.IOrderedEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, !!TKey&gt; keySelector, class System.Collections.Generic.IComparer`1&lt;!!TKey&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.ThenBy``2(System.Linq.IOrderedEnumerable{``0},System.Func{``0,``1},System.Collections.Generic.IComparer{``1})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ThenBy(Of TSource, TKey) (source As IOrderedEnumerable(Of TSource), keySelector As Func(Of TSource, TKey), comparer As IComparer(Of TKey)) As IOrderedEnumerable(Of TSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TKey&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::IOrderedEnumerable&lt;TSource&gt; ^ ThenBy(System::Linq::IOrderedEnumerable&lt;TSource&gt; ^ source, Func&lt;TSource, TKey&gt; ^ keySelector, System::Collections::Generic::IComparer&lt;TKey&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="static member ThenBy : System.Linq.IOrderedEnumerable&lt;'Source&gt; * Func&lt;'Source, 'Key&gt; * System.Collections.Generic.IComparer&lt;'Key&gt; -&gt; System.Linq.IOrderedEnumerable&lt;'Source&gt;" Usage="System.Linq.Enumerable.ThenBy (source, keySelector, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.IOrderedEnumerable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TKey" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IOrderedEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="keySelector" Type="System.Func&lt;TSource,TKey&gt;" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IComparer&lt;TKey&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">O tipo dos elementos de <paramref name="source" />.</typeparam>
        <typeparam name="TKey">O tipo da chave retornada por <paramref name="keySelector" />.</typeparam>
        <param name="source">Um <see cref="T:System.Linq.IOrderedEnumerable`1" /> que contém elementos a ser classificados.</param>
        <param name="keySelector">Uma função para extrair uma chave de cada elemento.</param>
        <param name="comparer">Um <see cref="T:System.Collections.Generic.IComparer`1" /> para comparar chaves.</param>
        <summary>Executa uma ordenação posterior dos elementos em uma sequência em ordem crescente usando um comparador especificado.</summary>
        <returns>Um <see cref="T:System.Linq.IOrderedEnumerable`1" /> cujos elementos são classificados de acordo com uma chave.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método é implementado usando a execução adiada. O imediata valor retornado é um objeto que armazena todas as informações necessárias para executar a ação. A consulta representada por esse método não é executada até que o objeto é enumerado chamando-se suas `GetEnumerator` método diretamente ou usando `foreach` no Visual c# ou `For Each` no Visual Basic.  
  
 Para solicitar uma sequência pelos valores dos próprios elementos, especifique a função identity (`x => x` no Visual c# ou `Function(x) x` no Visual Basic) para `keySelector`.  
  
 <xref:System.Linq.Enumerable.ThenBy%2A> e <xref:System.Linq.Enumerable.ThenByDescending%2A> são definidos para estender o tipo <xref:System.Linq.IOrderedEnumerable%601>, que também é o tipo de retorno dos métodos a seguir. Esse design permite que você especificar vários critérios de classificação por meio da aplicação de qualquer número de <xref:System.Linq.Enumerable.ThenBy%2A> ou <xref:System.Linq.Enumerable.ThenByDescending%2A> métodos.  
  
> [!NOTE]
>  Porque <xref:System.Linq.IOrderedEnumerable%601> herda <xref:System.Collections.Generic.IEnumerable%601>, você pode chamar <xref:System.Linq.Enumerable.OrderBy%2A> ou <xref:System.Linq.Enumerable.OrderByDescending%2A> nos resultados de uma chamada para <xref:System.Linq.Enumerable.OrderBy%2A>, <xref:System.Linq.Enumerable.OrderByDescending%2A>, <xref:System.Linq.Enumerable.ThenBy%2A> ou <xref:System.Linq.Enumerable.ThenByDescending%2A>. Isso apresenta um novo primário ordenação que ignora a ordem estabelecida anteriormente.  
  
 Se `comparer` está `null`, o comparador padrão <xref:System.Collections.Generic.Comparer%601.Default%2A> é usado para comparar chaves.  
  
 Esse método executa uma classificação estável; ou seja, se as chaves de dois elementos são iguais, a ordem dos elementos é preservada. Em contraste, uma classificação instável não preserva a ordem dos elementos que têm a mesma chave.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> ou <paramref name="keySelector" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="ThenByDescending&lt;TSource,TKey&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Executa uma ordenação posterior dos elementos em uma sequência em ordem decrescente.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ThenByDescending&lt;TSource,TKey&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.IOrderedEnumerable&lt;TSource&gt; ThenByDescending&lt;TSource,TKey&gt; (this System.Linq.IOrderedEnumerable&lt;TSource&gt; source, Func&lt;TSource,TKey&gt; keySelector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.IOrderedEnumerable`1&lt;!!TSource&gt; ThenByDescending&lt;TSource, TKey&gt;(class System.Linq.IOrderedEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, !!TKey&gt; keySelector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.ThenByDescending``2(System.Linq.IOrderedEnumerable{``0},System.Func{``0,``1})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ThenByDescending(Of TSource, TKey) (source As IOrderedEnumerable(Of TSource), keySelector As Func(Of TSource, TKey)) As IOrderedEnumerable(Of TSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TKey&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::IOrderedEnumerable&lt;TSource&gt; ^ ThenByDescending(System::Linq::IOrderedEnumerable&lt;TSource&gt; ^ source, Func&lt;TSource, TKey&gt; ^ keySelector);" />
      <MemberSignature Language="F#" Value="static member ThenByDescending : System.Linq.IOrderedEnumerable&lt;'Source&gt; * Func&lt;'Source, 'Key&gt; -&gt; System.Linq.IOrderedEnumerable&lt;'Source&gt;" Usage="System.Linq.Enumerable.ThenByDescending (source, keySelector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.IOrderedEnumerable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TKey" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IOrderedEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="keySelector" Type="System.Func&lt;TSource,TKey&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">O tipo dos elementos de <paramref name="source" />.</typeparam>
        <typeparam name="TKey">O tipo da chave retornada por <paramref name="keySelector" />.</typeparam>
        <param name="source">Um <see cref="T:System.Linq.IOrderedEnumerable`1" /> que contém elementos a ser classificados.</param>
        <param name="keySelector">Uma função para extrair uma chave de cada elemento.</param>
        <summary>Executa uma ordenação posterior dos elementos em uma sequência em ordem decrescente, de acordo com uma chave.</summary>
        <returns>Um <see cref="T:System.Linq.IOrderedEnumerable`1" /> cujos elementos são classificados em ordem decrescente de acordo com uma chave.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método é implementado usando a execução adiada. O imediata valor retornado é um objeto que armazena todas as informações necessárias para executar a ação. A consulta representada por esse método não é executada até que o objeto é enumerado chamando-se suas `GetEnumerator` método diretamente ou usando `foreach` no Visual c# ou `For Each` no Visual Basic.  
  
 Para solicitar uma sequência pelos valores dos próprios elementos, especifique a função identity (`x => x` no Visual c# ou `Function(x) x` no Visual Basic) para `keySelector`.  
  
 <xref:System.Linq.Enumerable.ThenBy%2A> e <xref:System.Linq.Enumerable.ThenByDescending%2A> são definidos para estender o tipo <xref:System.Linq.IOrderedEnumerable%601>, que também é o tipo de retorno dos métodos a seguir. Esse design permite que você especificar vários critérios de classificação por meio da aplicação de qualquer número de <xref:System.Linq.Enumerable.ThenBy%2A> ou <xref:System.Linq.Enumerable.ThenByDescending%2A> métodos.  
  
> [!NOTE]
>  Porque <xref:System.Linq.IOrderedEnumerable%601> herda <xref:System.Collections.Generic.IEnumerable%601>, você pode chamar <xref:System.Linq.Enumerable.OrderBy%2A> ou <xref:System.Linq.Enumerable.OrderByDescending%2A> nos resultados de uma chamada para <xref:System.Linq.Enumerable.OrderBy%2A>, <xref:System.Linq.Enumerable.OrderByDescending%2A>, <xref:System.Linq.Enumerable.ThenBy%2A> ou <xref:System.Linq.Enumerable.ThenByDescending%2A>. Isso apresenta um novo primário ordenação que ignora a ordem estabelecida anteriormente.  
  
 Esse método de classificação compara as chaves usando o comparador padrão <xref:System.Collections.Generic.Comparer%601.Default%2A>.  
  
 Esse método executa uma classificação estável; ou seja, se as chaves de dois elementos são iguais, a ordem dos elementos é preservada. Em contraste, uma classificação instável não preserva a ordem dos elementos que têm a mesma chave.  
  
 No Visual c# sintaxe de expressão de consulta, uma `orderby [first criterion], [second criterion] descending` cláusula se traduz em uma invocação de <xref:System.Linq.Enumerable.ThenByDescending%2A>.  
  
 Na sintaxe de expressão de consulta do Visual Basic, uma `Order By [first criterion], [second criterion] Descending` cláusula se traduz em uma invocação de <xref:System.Linq.Enumerable.ThenByDescending%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> ou <paramref name="keySelector" /> é <see langword="null" />.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/21f87f48-d69d-4e95-9a52-6fec47b37e1f">Cláusula orderby (Referência de C#)</related>
        <related type="Article" href="https://msdn.microsoft.com/library/fa911282-6b81-44c7-acfa-46b5bb93df75">Cláusula Order By (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="ThenByDescending&lt;TSource,TKey&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.IOrderedEnumerable&lt;TSource&gt; ThenByDescending&lt;TSource,TKey&gt; (this System.Linq.IOrderedEnumerable&lt;TSource&gt; source, Func&lt;TSource,TKey&gt; keySelector, System.Collections.Generic.IComparer&lt;TKey&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.IOrderedEnumerable`1&lt;!!TSource&gt; ThenByDescending&lt;TSource, TKey&gt;(class System.Linq.IOrderedEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, !!TKey&gt; keySelector, class System.Collections.Generic.IComparer`1&lt;!!TKey&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.ThenByDescending``2(System.Linq.IOrderedEnumerable{``0},System.Func{``0,``1},System.Collections.Generic.IComparer{``1})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ThenByDescending(Of TSource, TKey) (source As IOrderedEnumerable(Of TSource), keySelector As Func(Of TSource, TKey), comparer As IComparer(Of TKey)) As IOrderedEnumerable(Of TSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TKey&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::IOrderedEnumerable&lt;TSource&gt; ^ ThenByDescending(System::Linq::IOrderedEnumerable&lt;TSource&gt; ^ source, Func&lt;TSource, TKey&gt; ^ keySelector, System::Collections::Generic::IComparer&lt;TKey&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="static member ThenByDescending : System.Linq.IOrderedEnumerable&lt;'Source&gt; * Func&lt;'Source, 'Key&gt; * System.Collections.Generic.IComparer&lt;'Key&gt; -&gt; System.Linq.IOrderedEnumerable&lt;'Source&gt;" Usage="System.Linq.Enumerable.ThenByDescending (source, keySelector, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.IOrderedEnumerable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TKey" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IOrderedEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="keySelector" Type="System.Func&lt;TSource,TKey&gt;" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IComparer&lt;TKey&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">O tipo dos elementos de <paramref name="source" />.</typeparam>
        <typeparam name="TKey">O tipo da chave retornada por <paramref name="keySelector" />.</typeparam>
        <param name="source">Um <see cref="T:System.Linq.IOrderedEnumerable`1" /> que contém elementos a ser classificados.</param>
        <param name="keySelector">Uma função para extrair uma chave de cada elemento.</param>
        <param name="comparer">Um <see cref="T:System.Collections.Generic.IComparer`1" /> para comparar chaves.</param>
        <summary>Executa uma ordenação posterior dos elementos em uma sequência em ordem decrescente usando um comparador especificado.</summary>
        <returns>Um <see cref="T:System.Linq.IOrderedEnumerable`1" /> cujos elementos são classificados em ordem decrescente de acordo com uma chave.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método é implementado usando a execução adiada. O imediata valor retornado é um objeto que armazena todas as informações necessárias para executar a ação. A consulta representada por esse método não é executada até que o objeto é enumerado chamando-se suas `GetEnumerator` método diretamente ou usando `foreach` no Visual c# ou `For Each` no Visual Basic.  
  
 Para solicitar uma sequência pelos valores dos próprios elementos, especifique a função identity (`x => x` no Visual c# ou `Function(x) x` no Visual Basic) para `keySelector`.  
  
 <xref:System.Linq.Enumerable.ThenBy%2A> e <xref:System.Linq.Enumerable.ThenByDescending%2A> são definidos para estender o tipo <xref:System.Linq.IOrderedEnumerable%601>, que também é o tipo de retorno dos métodos a seguir. Esse design permite que você especificar vários critérios de classificação por meio da aplicação de qualquer número de <xref:System.Linq.Enumerable.ThenBy%2A> ou <xref:System.Linq.Enumerable.ThenByDescending%2A> métodos.  
  
> [!NOTE]
>  Porque <xref:System.Linq.IOrderedEnumerable%601> herda <xref:System.Collections.Generic.IEnumerable%601>, você pode chamar <xref:System.Linq.Enumerable.OrderBy%2A> ou <xref:System.Linq.Enumerable.OrderByDescending%2A> nos resultados de uma chamada para <xref:System.Linq.Enumerable.OrderBy%2A>, <xref:System.Linq.Enumerable.OrderByDescending%2A>, <xref:System.Linq.Enumerable.ThenBy%2A> ou <xref:System.Linq.Enumerable.ThenByDescending%2A>. Isso apresenta um novo primário ordenação que ignora a ordem estabelecida anteriormente.  
  
 Se `comparer` está `null`, o comparador padrão <xref:System.Collections.Generic.Comparer%601.Default%2A> é usado para comparar chaves.  
  
 Esse método executa uma classificação estável; ou seja, se as chaves de dois elementos são iguais, a ordem dos elementos é preservada. Em contraste, uma classificação instável não preserva a ordem dos elementos que têm a mesma chave.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como usar <xref:System.Linq.Enumerable.ThenByDescending%60%602%28System.Linq.IOrderedEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2C%60%601%7D%2CSystem.Collections.Generic.IComparer%7B%60%601%7D%29> para executar uma classificação secundária dos elementos em uma sequência em ordem decrescente usando um comparador personalizado.  
  
 [!code-csharp[System.Linq.Enumerable#103](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#103)]
 [!code-vb[System.Linq.Enumerable#103](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#103)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> ou <paramref name="keySelector" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ToArray&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static TSource[] ToArray&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TSource[] ToArray&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.ToArray``1(System.Collections.Generic.IEnumerable{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ToArray(Of TSource) (source As IEnumerable(Of TSource)) As TSource()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static cli::array &lt;TSource&gt; ^ ToArray(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member ToArray : seq&lt;'Source&gt; -&gt; 'Source[]" Usage="System.Linq.Enumerable.ToArray source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TSource[]</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">O tipo dos elementos de <paramref name="source" />.</typeparam>
        <param name="source">Um <see cref="T:System.Collections.Generic.IEnumerable`1" /> para criar uma matriz.</param>
        <summary>Cria uma matriz de um <see cref="T:System.Collections.Generic.IEnumerable`1" />.</summary>
        <returns>Uma matriz que contém os elementos da sequência de entrada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Linq.Enumerable.ToArray%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%29> método força a avaliação imediata de consulta e retorna uma matriz que contém os resultados da consulta. Você pode acrescentar esse método à sua consulta para obter uma cópia armazenada em cache os resultados da consulta.  
  
 <xref:System.Linq.Enumerable.ToList%2A> tem um comportamento semelhante mas retorna um <xref:System.Collections.Generic.List%601> em vez de uma matriz.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como usar <xref:System.Linq.Enumerable.ToArray%2A> para forçar a avaliação imediata de consulta e retornar uma matriz de resultados.  
  
 [!code-csharp[System.Linq.Enumerable#104](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#104)]
 [!code-vb[System.Linq.Enumerable#104](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#104)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="ToDictionary&lt;TSource,TKey&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Cria um <see cref="T:System.Collections.Generic.Dictionary`2" /> de um <see cref="T:System.Collections.Generic.IEnumerable`1" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ToDictionary&lt;TSource,TKey&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.Dictionary&lt;TKey,TSource&gt; ToDictionary&lt;TSource,TKey&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,TKey&gt; keySelector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.Dictionary`2&lt;!!TKey, !!TSource&gt; ToDictionary&lt;TSource, TKey&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, !!TKey&gt; keySelector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.ToDictionary``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ToDictionary(Of TSource, TKey) (source As IEnumerable(Of TSource), keySelector As Func(Of TSource, TKey)) As Dictionary(Of TKey, TSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TKey&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Collections::Generic::Dictionary&lt;TKey, TSource&gt; ^ ToDictionary(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Func&lt;TSource, TKey&gt; ^ keySelector);" />
      <MemberSignature Language="F#" Value="static member ToDictionary : seq&lt;'Source&gt; * Func&lt;'Source, 'Key&gt; -&gt; System.Collections.Generic.Dictionary&lt;'Key, 'Source&gt;" Usage="System.Linq.Enumerable.ToDictionary (source, keySelector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.Dictionary&lt;TKey,TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TKey" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="keySelector" Type="System.Func&lt;TSource,TKey&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">O tipo dos elementos de <paramref name="source" />.</typeparam>
        <typeparam name="TKey">O tipo da chave retornada por <paramref name="keySelector" />.</typeparam>
        <param name="source">Um <see cref="T:System.Collections.Generic.IEnumerable`1" /> por meio do qual um <see cref="T:System.Collections.Generic.Dictionary`2" /> será criado.</param>
        <param name="keySelector">Uma função para extrair uma chave de cada elemento.</param>
        <summary>Cria um <see cref="T:System.Collections.Generic.Dictionary`2" /> de um <see cref="T:System.Collections.Generic.IEnumerable`1" />, de acordo com uma função de seletor de chave especificada.</summary>
        <returns>Um <see cref="T:System.Collections.Generic.Dictionary`2" /> que contém chaves e valores.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Linq.Enumerable.ToDictionary%60%602%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2C%60%601%7D%29> método usa o comparador de igualdade padrão <xref:System.Collections.Generic.EqualityComparer%601.Default%2A> para comparar chaves.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como usar <xref:System.Linq.Enumerable.ToDictionary%60%602%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2C%60%601%7D%29> para criar um <xref:System.Collections.Generic.Dictionary%602> por meio de um seletor de chave.  
  
 [!code-csharp[System.Linq.Enumerable#105](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#105)]
 [!code-vb[System.Linq.Enumerable#105](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#105)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> ou <paramref name="keySelector" /> é <see langword="null" />.  
  
- ou - 
 <paramref name="keySelector" /> gera uma chave que é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="keySelector" /> gera chaves duplicatas para dois elementos.</exception>
      </Docs>
    </Member>
    <Member MemberName="ToDictionary&lt;TSource,TKey&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.Dictionary&lt;TKey,TSource&gt; ToDictionary&lt;TSource,TKey&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,TKey&gt; keySelector, System.Collections.Generic.IEqualityComparer&lt;TKey&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.Dictionary`2&lt;!!TKey, !!TSource&gt; ToDictionary&lt;TSource, TKey&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, !!TKey&gt; keySelector, class System.Collections.Generic.IEqualityComparer`1&lt;!!TKey&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.ToDictionary``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1},System.Collections.Generic.IEqualityComparer{``1})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ToDictionary(Of TSource, TKey) (source As IEnumerable(Of TSource), keySelector As Func(Of TSource, TKey), comparer As IEqualityComparer(Of TKey)) As Dictionary(Of TKey, TSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TKey&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Collections::Generic::Dictionary&lt;TKey, TSource&gt; ^ ToDictionary(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Func&lt;TSource, TKey&gt; ^ keySelector, System::Collections::Generic::IEqualityComparer&lt;TKey&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="static member ToDictionary : seq&lt;'Source&gt; * Func&lt;'Source, 'Key&gt; * System.Collections.Generic.IEqualityComparer&lt;'Key&gt; -&gt; System.Collections.Generic.Dictionary&lt;'Key, 'Source&gt;" Usage="System.Linq.Enumerable.ToDictionary (source, keySelector, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.Dictionary&lt;TKey,TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TKey" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="keySelector" Type="System.Func&lt;TSource,TKey&gt;" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IEqualityComparer&lt;TKey&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">O tipo dos elementos de <paramref name="source" />.</typeparam>
        <typeparam name="TKey">O tipo das chaves retornadas por <paramref name="keySelector" />.</typeparam>
        <param name="source">Um <see cref="T:System.Collections.Generic.IEnumerable`1" /> por meio do qual um <see cref="T:System.Collections.Generic.Dictionary`2" /> será criado.</param>
        <param name="keySelector">Uma função para extrair uma chave de cada elemento.</param>
        <param name="comparer">Um <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> para comparar chaves.</param>
        <summary>Cria um <see cref="T:System.Collections.Generic.Dictionary`2" /> de um <see cref="T:System.Collections.Generic.IEnumerable`1" />, de acordo com uma função de seletor de chave especificada e um comparador de chaves.</summary>
        <returns>Um <see cref="T:System.Collections.Generic.Dictionary`2" /> que contém chaves e valores.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se `comparer` está `null`, o comparador de igualdade padrão <xref:System.Collections.Generic.EqualityComparer%601.Default%2A> é usado para comparar chaves.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> ou <paramref name="keySelector" /> é <see langword="null" />.  
  
- ou - 
 <paramref name="keySelector" /> gera uma chave que é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="keySelector" /> gera chaves duplicatas para dois elementos.</exception>
      </Docs>
    </Member>
    <Member MemberName="ToDictionary&lt;TSource,TKey,TElement&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.Dictionary&lt;TKey,TElement&gt; ToDictionary&lt;TSource,TKey,TElement&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,TKey&gt; keySelector, Func&lt;TSource,TElement&gt; elementSelector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.Dictionary`2&lt;!!TKey, !!TElement&gt; ToDictionary&lt;TSource, TKey, TElement&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, !!TKey&gt; keySelector, class System.Func`2&lt;!!TSource, !!TElement&gt; elementSelector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.ToDictionary``3(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1},System.Func{``0,``2})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ToDictionary(Of TSource, TKey, TElement) (source As IEnumerable(Of TSource), keySelector As Func(Of TSource, TKey), elementSelector As Func(Of TSource, TElement)) As Dictionary(Of TKey, TElement)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TKey, typename TElement&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Collections::Generic::Dictionary&lt;TKey, TElement&gt; ^ ToDictionary(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Func&lt;TSource, TKey&gt; ^ keySelector, Func&lt;TSource, TElement&gt; ^ elementSelector);" />
      <MemberSignature Language="F#" Value="static member ToDictionary : seq&lt;'Source&gt; * Func&lt;'Source, 'Key&gt; * Func&lt;'Source, 'Element&gt; -&gt; System.Collections.Generic.Dictionary&lt;'Key, 'Element&gt;" Usage="System.Linq.Enumerable.ToDictionary (source, keySelector, elementSelector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.Dictionary&lt;TKey,TElement&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TKey" />
        <TypeParameter Name="TElement" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="keySelector" Type="System.Func&lt;TSource,TKey&gt;" />
        <Parameter Name="elementSelector" Type="System.Func&lt;TSource,TElement&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">O tipo dos elementos de <paramref name="source" />.</typeparam>
        <typeparam name="TKey">O tipo da chave retornada por <paramref name="keySelector" />.</typeparam>
        <typeparam name="TElement">O tipo do valor retornado por <paramref name="elementSelector" />.</typeparam>
        <param name="source">Um <see cref="T:System.Collections.Generic.IEnumerable`1" /> por meio do qual um <see cref="T:System.Collections.Generic.Dictionary`2" /> será criado.</param>
        <param name="keySelector">Uma função para extrair uma chave de cada elemento.</param>
        <param name="elementSelector">Uma função de transformação para produzir um valor de elemento de resultado de cada elemento.</param>
        <summary>Cria um <see cref="T:System.Collections.Generic.Dictionary`2" /> de um <see cref="T:System.Collections.Generic.IEnumerable`1" />, de acordo com as funções especificadas de seletor de chave e seletor de elemento.</summary>
        <returns>Um <see cref="T:System.Collections.Generic.Dictionary`2" /> que contém valores do tipo <paramref name="TElement" /> selecionados da sequência de entrada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Linq.Enumerable.ToDictionary%60%603%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2C%60%601%7D%2CSystem.Func%7B%60%600%2C%60%602%7D%29> método usa o comparador de igualdade padrão <xref:System.Collections.Generic.EqualityComparer%601.Default%2A> para comparar chaves.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" />, <paramref name="keySelector" /> ou <paramref name="elementSelector" /> é <see langword="null" />.  
  
- ou - 
 <paramref name="keySelector" /> gera uma chave que é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="keySelector" /> gera chaves duplicatas para dois elementos.</exception>
      </Docs>
    </Member>
    <Member MemberName="ToDictionary&lt;TSource,TKey,TElement&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.Dictionary&lt;TKey,TElement&gt; ToDictionary&lt;TSource,TKey,TElement&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,TKey&gt; keySelector, Func&lt;TSource,TElement&gt; elementSelector, System.Collections.Generic.IEqualityComparer&lt;TKey&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.Dictionary`2&lt;!!TKey, !!TElement&gt; ToDictionary&lt;TSource, TKey, TElement&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, !!TKey&gt; keySelector, class System.Func`2&lt;!!TSource, !!TElement&gt; elementSelector, class System.Collections.Generic.IEqualityComparer`1&lt;!!TKey&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.ToDictionary``3(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1},System.Func{``0,``2},System.Collections.Generic.IEqualityComparer{``1})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ToDictionary(Of TSource, TKey, TElement) (source As IEnumerable(Of TSource), keySelector As Func(Of TSource, TKey), elementSelector As Func(Of TSource, TElement), comparer As IEqualityComparer(Of TKey)) As Dictionary(Of TKey, TElement)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TKey, typename TElement&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Collections::Generic::Dictionary&lt;TKey, TElement&gt; ^ ToDictionary(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Func&lt;TSource, TKey&gt; ^ keySelector, Func&lt;TSource, TElement&gt; ^ elementSelector, System::Collections::Generic::IEqualityComparer&lt;TKey&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="static member ToDictionary : seq&lt;'Source&gt; * Func&lt;'Source, 'Key&gt; * Func&lt;'Source, 'Element&gt; * System.Collections.Generic.IEqualityComparer&lt;'Key&gt; -&gt; System.Collections.Generic.Dictionary&lt;'Key, 'Element&gt;" Usage="System.Linq.Enumerable.ToDictionary (source, keySelector, elementSelector, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.Dictionary&lt;TKey,TElement&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TKey" />
        <TypeParameter Name="TElement" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="keySelector" Type="System.Func&lt;TSource,TKey&gt;" />
        <Parameter Name="elementSelector" Type="System.Func&lt;TSource,TElement&gt;" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IEqualityComparer&lt;TKey&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">O tipo dos elementos de <paramref name="source" />.</typeparam>
        <typeparam name="TKey">O tipo da chave retornada por <paramref name="keySelector" />.</typeparam>
        <typeparam name="TElement">O tipo do valor retornado por <paramref name="elementSelector" />.</typeparam>
        <param name="source">Um <see cref="T:System.Collections.Generic.IEnumerable`1" /> por meio do qual um <see cref="T:System.Collections.Generic.Dictionary`2" /> será criado.</param>
        <param name="keySelector">Uma função para extrair uma chave de cada elemento.</param>
        <param name="elementSelector">Uma função de transformação para produzir um valor de elemento de resultado de cada elemento.</param>
        <param name="comparer">Um <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> para comparar chaves.</param>
        <summary>Cria um <see cref="T:System.Collections.Generic.Dictionary`2" /> de um <see cref="T:System.Collections.Generic.IEnumerable`1" /> de acordo com uma função de seletor de chave, um comparador e uma função de seletor de elemento especificados.</summary>
        <returns>Um <see cref="T:System.Collections.Generic.Dictionary`2" /> que contém valores do tipo <paramref name="TElement" /> selecionados da sequência de entrada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se `comparer` está `null`, o comparador de igualdade padrão <xref:System.Collections.Generic.EqualityComparer%601.Default%2A> é usado para comparar chaves.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" />, <paramref name="keySelector" /> ou <paramref name="elementSelector" /> é <see langword="null" />.  
  
- ou - 
 <paramref name="keySelector" /> gera uma chave que é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="keySelector" /> gera chaves duplicatas para dois elementos.</exception>
      </Docs>
    </Member>
    <Member MemberName="ToHashSet&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.HashSet&lt;TSource&gt; ToHashSet&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.HashSet`1&lt;!!TSource&gt; ToHashSet&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.ToHashSet``1(System.Collections.Generic.IEnumerable{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ToHashSet(Of TSource) (source As IEnumerable(Of TSource)) As HashSet(Of TSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Collections::Generic::HashSet&lt;TSource&gt; ^ ToHashSet(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member ToHashSet : seq&lt;'Source&gt; -&gt; System.Collections.Generic.HashSet&lt;'Source&gt;" Usage="System.Linq.Enumerable.ToHashSet source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.HashSet&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">O tipo dos elementos de <paramref name="source" />.</typeparam>
        <param name="source">Um <see cref="T:System.Collections.Generic.IEnumerable`1" /> por meio do qual um <see cref="T:System.Collections.Generic.HashSet`1" /> será criado.</param>
        <summary>Cria um <see cref="T:System.Collections.Generic.HashSet`1" /> de um <see cref="T:System.Collections.Generic.IEnumerable`1" />.</summary>
        <returns>Um <see cref="T:System.Collections.Generic.HashSet`1" /> que contém os valores do tipo TSource selecionados da sequência de entrada.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ToHashSet&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.HashSet&lt;TSource&gt; ToHashSet&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, System.Collections.Generic.IEqualityComparer&lt;TSource&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.HashSet`1&lt;!!TSource&gt; ToHashSet&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Collections.Generic.IEqualityComparer`1&lt;!!TSource&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.ToHashSet``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEqualityComparer{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ToHashSet(Of TSource) (source As IEnumerable(Of TSource), comparer As IEqualityComparer(Of TSource)) As HashSet(Of TSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Collections::Generic::HashSet&lt;TSource&gt; ^ ToHashSet(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, System::Collections::Generic::IEqualityComparer&lt;TSource&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="static member ToHashSet : seq&lt;'Source&gt; * System.Collections.Generic.IEqualityComparer&lt;'Source&gt; -&gt; System.Collections.Generic.HashSet&lt;'Source&gt;" Usage="System.Linq.Enumerable.ToHashSet (source, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.HashSet&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IEqualityComparer&lt;TSource&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">O tipo dos elementos de <paramref name="source" />.</typeparam>
        <param name="source">Um <see cref="T:System.Collections.Generic.IEnumerable`1" /> por meio do qual um <see cref="T:System.Collections.Generic.HashSet`1" /> será criado.</param>
        <param name="comparer">Um <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> para comparar chaves.</param>
        <summary>Cria um <see cref="T:System.Collections.Generic.HashSet`1" /> de um <see cref="T:System.Collections.Generic.IEnumerable`1" /> usando o <paramref name="comparer" /> para comparar chaves</summary>
        <returns>Um <see cref="T:System.Collections.Generic.HashSet`1" /> que contém valores do tipo <paramref name="TSource" /> selecionados da sequência de entrada.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ToList&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.List&lt;TSource&gt; ToList&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.List`1&lt;!!TSource&gt; ToList&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.ToList``1(System.Collections.Generic.IEnumerable{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ToList(Of TSource) (source As IEnumerable(Of TSource)) As List(Of TSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Collections::Generic::List&lt;TSource&gt; ^ ToList(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member ToList : seq&lt;'Source&gt; -&gt; System.Collections.Generic.List&lt;'Source&gt;" Usage="System.Linq.Enumerable.ToList source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.List&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">O tipo dos elementos de <paramref name="source" />.</typeparam>
        <param name="source">O <see cref="T:System.Collections.Generic.IEnumerable`1" /> por meio do qual um <see cref="T:System.Collections.Generic.List`1" /> será criado.</param>
        <summary>Cria um <see cref="T:System.Collections.Generic.List`1" /> de um <see cref="T:System.Collections.Generic.IEnumerable`1" />.</summary>
        <returns>Um <see cref="T:System.Collections.Generic.List`1" /> que contém elementos da sequência de entrada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Linq.Enumerable.ToList%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%29> método força a avaliação imediata de consulta e retorna um <xref:System.Collections.Generic.List%601> que contém os resultados da consulta. Você pode acrescentar esse método à sua consulta para obter uma cópia armazenada em cache os resultados da consulta.  
  
 <xref:System.Linq.Enumerable.ToArray%2A> tem um comportamento semelhante mas retorna uma matriz em vez de um <xref:System.Collections.Generic.List%601>.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como usar <xref:System.Linq.Enumerable.ToList%2A> para forçar a avaliação imediata de consulta e retornar um <xref:System.Collections.Generic.List%601> que contém os resultados da consulta.  
  
 [!code-csharp[System.Linq.Enumerable#106](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#106)]
 [!code-vb[System.Linq.Enumerable#106](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#106)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="ToLookup&lt;TSource,TKey&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Cria um <see cref="T:System.Linq.Lookup`2" /> genérico de um <see cref="T:System.Collections.Generic.IEnumerable`1" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ToLookup&lt;TSource,TKey&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.ILookup&lt;TKey,TSource&gt; ToLookup&lt;TSource,TKey&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,TKey&gt; keySelector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.ILookup`2&lt;!!TKey, !!TSource&gt; ToLookup&lt;TSource, TKey&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, !!TKey&gt; keySelector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.ToLookup``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ToLookup(Of TSource, TKey) (source As IEnumerable(Of TSource), keySelector As Func(Of TSource, TKey)) As ILookup(Of TKey, TSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TKey&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::ILookup&lt;TKey, TSource&gt; ^ ToLookup(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Func&lt;TSource, TKey&gt; ^ keySelector);" />
      <MemberSignature Language="F#" Value="static member ToLookup : seq&lt;'Source&gt; * Func&lt;'Source, 'Key&gt; -&gt; System.Linq.ILookup&lt;'Key, 'Source&gt;" Usage="System.Linq.Enumerable.ToLookup (source, keySelector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.ILookup&lt;TKey,TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TKey" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="keySelector" Type="System.Func&lt;TSource,TKey&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">O tipo dos elementos de <paramref name="source" />.</typeparam>
        <typeparam name="TKey">O tipo da chave retornada por <paramref name="keySelector" />.</typeparam>
        <param name="source">O <see cref="T:System.Collections.Generic.IEnumerable`1" /> por meio do qual um <see cref="T:System.Linq.Lookup`2" /> será criado.</param>
        <param name="keySelector">Uma função para extrair uma chave de cada elemento.</param>
        <summary>Cria um <see cref="T:System.Linq.Lookup`2" /> de um <see cref="T:System.Collections.Generic.IEnumerable`1" />, de acordo com uma função de seletor de chave especificada.</summary>
        <returns>Um <see cref="T:System.Linq.Lookup`2" /> que contém chaves e valores.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Linq.Enumerable.ToLookup%60%602%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2C%60%601%7D%29> método retorna um <xref:System.Linq.Lookup%602>, um dicionário de um-para-muitos que mapeia chaves para coleções de valores. Um <xref:System.Linq.Lookup%602> difere de um <xref:System.Collections.Generic.Dictionary%602>, que executa um mapeamento de chaves para valores únicos.  
  
 O comparador de igualdade padrão <xref:System.Collections.Generic.EqualityComparer%601.Default%2A> é usado para comparar chaves.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> ou <paramref name="keySelector" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ToLookup&lt;TSource,TKey&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.ILookup&lt;TKey,TSource&gt; ToLookup&lt;TSource,TKey&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,TKey&gt; keySelector, System.Collections.Generic.IEqualityComparer&lt;TKey&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.ILookup`2&lt;!!TKey, !!TSource&gt; ToLookup&lt;TSource, TKey&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, !!TKey&gt; keySelector, class System.Collections.Generic.IEqualityComparer`1&lt;!!TKey&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.ToLookup``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1},System.Collections.Generic.IEqualityComparer{``1})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ToLookup(Of TSource, TKey) (source As IEnumerable(Of TSource), keySelector As Func(Of TSource, TKey), comparer As IEqualityComparer(Of TKey)) As ILookup(Of TKey, TSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TKey&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::ILookup&lt;TKey, TSource&gt; ^ ToLookup(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Func&lt;TSource, TKey&gt; ^ keySelector, System::Collections::Generic::IEqualityComparer&lt;TKey&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="static member ToLookup : seq&lt;'Source&gt; * Func&lt;'Source, 'Key&gt; * System.Collections.Generic.IEqualityComparer&lt;'Key&gt; -&gt; System.Linq.ILookup&lt;'Key, 'Source&gt;" Usage="System.Linq.Enumerable.ToLookup (source, keySelector, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.ILookup&lt;TKey,TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TKey" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="keySelector" Type="System.Func&lt;TSource,TKey&gt;" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IEqualityComparer&lt;TKey&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">O tipo dos elementos de <paramref name="source" />.</typeparam>
        <typeparam name="TKey">O tipo da chave retornada por <paramref name="keySelector" />.</typeparam>
        <param name="source">O <see cref="T:System.Collections.Generic.IEnumerable`1" /> por meio do qual um <see cref="T:System.Linq.Lookup`2" /> será criado.</param>
        <param name="keySelector">Uma função para extrair uma chave de cada elemento.</param>
        <param name="comparer">Um <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> para comparar chaves.</param>
        <summary>Cria um <see cref="T:System.Linq.Lookup`2" /> de um <see cref="T:System.Collections.Generic.IEnumerable`1" />, de acordo com uma função de seletor de chave especificada e um comparador de chaves.</summary>
        <returns>Um <see cref="T:System.Linq.Lookup`2" /> que contém chaves e valores.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Linq.Enumerable.ToLookup%60%602%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2C%60%601%7D%2CSystem.Collections.Generic.IEqualityComparer%7B%60%601%7D%29> método retorna um <xref:System.Linq.Lookup%602>, um dicionário de um-para-muitos que mapeia chaves para coleções de valores. Um <xref:System.Linq.Lookup%602> é diferente para um <xref:System.Collections.Generic.Dictionary%602>, que executa um mapeamento de chaves para valores únicos.  
  
 Se `comparer` está `null`, o comparador de igualdade padrão <xref:System.Collections.Generic.EqualityComparer%601.Default%2A> é usado para comparar chaves.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> ou <paramref name="keySelector" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ToLookup&lt;TSource,TKey,TElement&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.ILookup&lt;TKey,TElement&gt; ToLookup&lt;TSource,TKey,TElement&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,TKey&gt; keySelector, Func&lt;TSource,TElement&gt; elementSelector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.ILookup`2&lt;!!TKey, !!TElement&gt; ToLookup&lt;TSource, TKey, TElement&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, !!TKey&gt; keySelector, class System.Func`2&lt;!!TSource, !!TElement&gt; elementSelector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.ToLookup``3(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1},System.Func{``0,``2})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ToLookup(Of TSource, TKey, TElement) (source As IEnumerable(Of TSource), keySelector As Func(Of TSource, TKey), elementSelector As Func(Of TSource, TElement)) As ILookup(Of TKey, TElement)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TKey, typename TElement&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::ILookup&lt;TKey, TElement&gt; ^ ToLookup(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Func&lt;TSource, TKey&gt; ^ keySelector, Func&lt;TSource, TElement&gt; ^ elementSelector);" />
      <MemberSignature Language="F#" Value="static member ToLookup : seq&lt;'Source&gt; * Func&lt;'Source, 'Key&gt; * Func&lt;'Source, 'Element&gt; -&gt; System.Linq.ILookup&lt;'Key, 'Element&gt;" Usage="System.Linq.Enumerable.ToLookup (source, keySelector, elementSelector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.ILookup&lt;TKey,TElement&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TKey" />
        <TypeParameter Name="TElement" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="keySelector" Type="System.Func&lt;TSource,TKey&gt;" />
        <Parameter Name="elementSelector" Type="System.Func&lt;TSource,TElement&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">O tipo dos elementos de <paramref name="source" />.</typeparam>
        <typeparam name="TKey">O tipo da chave retornada por <paramref name="keySelector" />.</typeparam>
        <typeparam name="TElement">O tipo do valor retornado por <paramref name="elementSelector" />.</typeparam>
        <param name="source">O <see cref="T:System.Collections.Generic.IEnumerable`1" /> por meio do qual um <see cref="T:System.Linq.Lookup`2" /> será criado.</param>
        <param name="keySelector">Uma função para extrair uma chave de cada elemento.</param>
        <param name="elementSelector">Uma função de transformação para produzir um valor de elemento de resultado de cada elemento.</param>
        <summary>Cria um <see cref="T:System.Linq.Lookup`2" /> de um <see cref="T:System.Collections.Generic.IEnumerable`1" />, de acordo com as funções especificadas de seletor de chave e seletor de elemento.</summary>
        <returns>Um <see cref="T:System.Linq.Lookup`2" /> que contém valores do tipo <paramref name="TElement" /> selecionados da sequência de entrada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Linq.Enumerable.ToLookup%60%603%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2C%60%601%7D%2CSystem.Func%7B%60%600%2C%60%602%7D%29> método retorna um <xref:System.Linq.Lookup%602>, um dicionário de um-para-muitos que mapeia chaves para coleções de valores. Um <xref:System.Linq.Lookup%602> difere de um <xref:System.Collections.Generic.Dictionary%602>, que executa um mapeamento de chaves para valores únicos.  
  
 O comparador de igualdade padrão <xref:System.Collections.Generic.EqualityComparer%601.Default%2A> é usado para comparar chaves.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como usar <xref:System.Linq.Enumerable.ToLookup%60%603%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2C%60%601%7D%2CSystem.Func%7B%60%600%2C%60%602%7D%29> para criar um <xref:System.Linq.Lookup%602> usando uma função de seletor de chave e uma função de seletor de elemento.  
  
 [!code-csharp[System.Linq.Enumerable#107](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#107)]
 [!code-vb[System.Linq.Enumerable#107](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#107)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" />, <paramref name="keySelector" /> ou <paramref name="elementSelector" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ToLookup&lt;TSource,TKey,TElement&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.ILookup&lt;TKey,TElement&gt; ToLookup&lt;TSource,TKey,TElement&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,TKey&gt; keySelector, Func&lt;TSource,TElement&gt; elementSelector, System.Collections.Generic.IEqualityComparer&lt;TKey&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.ILookup`2&lt;!!TKey, !!TElement&gt; ToLookup&lt;TSource, TKey, TElement&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, !!TKey&gt; keySelector, class System.Func`2&lt;!!TSource, !!TElement&gt; elementSelector, class System.Collections.Generic.IEqualityComparer`1&lt;!!TKey&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.ToLookup``3(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1},System.Func{``0,``2},System.Collections.Generic.IEqualityComparer{``1})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ToLookup(Of TSource, TKey, TElement) (source As IEnumerable(Of TSource), keySelector As Func(Of TSource, TKey), elementSelector As Func(Of TSource, TElement), comparer As IEqualityComparer(Of TKey)) As ILookup(Of TKey, TElement)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TKey, typename TElement&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::ILookup&lt;TKey, TElement&gt; ^ ToLookup(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Func&lt;TSource, TKey&gt; ^ keySelector, Func&lt;TSource, TElement&gt; ^ elementSelector, System::Collections::Generic::IEqualityComparer&lt;TKey&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="static member ToLookup : seq&lt;'Source&gt; * Func&lt;'Source, 'Key&gt; * Func&lt;'Source, 'Element&gt; * System.Collections.Generic.IEqualityComparer&lt;'Key&gt; -&gt; System.Linq.ILookup&lt;'Key, 'Element&gt;" Usage="System.Linq.Enumerable.ToLookup (source, keySelector, elementSelector, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.ILookup&lt;TKey,TElement&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TKey" />
        <TypeParameter Name="TElement" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="keySelector" Type="System.Func&lt;TSource,TKey&gt;" />
        <Parameter Name="elementSelector" Type="System.Func&lt;TSource,TElement&gt;" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IEqualityComparer&lt;TKey&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">O tipo dos elementos de <paramref name="source" />.</typeparam>
        <typeparam name="TKey">O tipo da chave retornada por <paramref name="keySelector" />.</typeparam>
        <typeparam name="TElement">O tipo do valor retornado por <paramref name="elementSelector" />.</typeparam>
        <param name="source">O <see cref="T:System.Collections.Generic.IEnumerable`1" /> por meio do qual um <see cref="T:System.Linq.Lookup`2" /> será criado.</param>
        <param name="keySelector">Uma função para extrair uma chave de cada elemento.</param>
        <param name="elementSelector">Uma função de transformação para produzir um valor de elemento de resultado de cada elemento.</param>
        <param name="comparer">Um <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> para comparar chaves.</param>
        <summary>Cria um <see cref="T:System.Linq.Lookup`2" /> de um <see cref="T:System.Collections.Generic.IEnumerable`1" /> de acordo com uma função de seletor de chave, um comparador e uma função de seletor de elemento especificados.</summary>
        <returns>Um <see cref="T:System.Linq.Lookup`2" /> que contém valores do tipo <paramref name="TElement" /> selecionados da sequência de entrada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Linq.Enumerable.ToLookup%60%603%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2C%60%601%7D%2CSystem.Func%7B%60%600%2C%60%602%7D%2CSystem.Collections.Generic.IEqualityComparer%7B%60%601%7D%29> método retorna um <xref:System.Linq.Lookup%602>, um dicionário de um-para-muitos que mapeia chaves para coleções de valores. Um <xref:System.Linq.Lookup%602> difere de um <xref:System.Collections.Generic.Dictionary%602>, que executa um mapeamento de chaves para valores únicos.  
  
 Se `comparer` está `null`, o comparador de igualdade padrão <xref:System.Collections.Generic.EqualityComparer%601.Default%2A> é usado para comparar chaves.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" />, <paramref name="keySelector" /> ou <paramref name="elementSelector" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Union&lt;TSource&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Produz a união de conjunto de duas sequências.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Union&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;TSource&gt; Union&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; first, System.Collections.Generic.IEnumerable&lt;TSource&gt; second);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; Union&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; first, class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; second) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Union``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Union(Of TSource) (first As IEnumerable(Of TSource), second As IEnumerable(Of TSource)) As IEnumerable(Of TSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ Union(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ first, System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ second);" />
      <MemberSignature Language="F#" Value="static member Union : seq&lt;'Source&gt; * seq&lt;'Source&gt; -&gt; seq&lt;'Source&gt;" Usage="System.Linq.Enumerable.Union (first, second)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="first" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="second" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">O tipo dos elementos das sequências de entrada.</typeparam>
        <param name="first">Um <see cref="T:System.Collections.Generic.IEnumerable`1" /> cujos elementos distintos formam o primeiro conjunto da união.</param>
        <param name="second">Um <see cref="T:System.Collections.Generic.IEnumerable`1" /> cujos elementos distintos formam o segundo conjunto da união.</param>
        <summary>Produz a união de conjunto de duas sequências usando o comparador de igualdade padrão.</summary>
        <returns>Um <see cref="T:System.Collections.Generic.IEnumerable`1" /> que contém os elementos de ambas as sequências de entrada, excluindo as duplicatas.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método é implementado usando a execução adiada. O imediata valor retornado é um objeto que armazena todas as informações necessárias para executar a ação. A consulta representada por esse método não é executada até que o objeto é enumerado chamando-se suas `GetEnumerator` método diretamente ou usando `foreach` no Visual c# ou `For Each` no Visual Basic.  
  
 Este método exclui duplicatas do conjunto de retorno. Isso é um comportamento diferente para o <xref:System.Linq.Enumerable.Concat%2A> método, que retorna todos os elementos nas sequências de entrada, incluindo duplicatas.  
  
 O comparador de igualdade padrão, <xref:System.Collections.Generic.EqualityComparer%601.Default%2A>, é usado para comparar valores de tipos que implementam o <xref:System.Collections.Generic.IEqualityComparer%601> interface genérica. Para comparar um tipo de dados personalizado, você precisa implementar esta interface e fornecer seus próprios <xref:System.Object.GetHashCode%2A> e <xref:System.Object.Equals%2A> métodos para o tipo.  
  
 Quando o objeto retornado por esse método é enumerado, <xref:System.Linq.Enumerable.Union%2A> enumera `first` e `second` nessa ordem e produz cada elemento que já não foram produzido.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como usar <xref:System.Linq.Enumerable.Union%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%29> para obter a união de duas sequências de inteiros.  
  
 [!code-csharp[System.Linq.Enumerable#109](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#109)]
 [!code-vb[System.Linq.Enumerable#109](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#109)]  
  
 Se você quiser comparar sequências de objetos de um tipo de dados personalizado, você precisa implementar o <xref:System.Collections.Generic.IEqualityComparer%601> interface genérica em um helperclass. O exemplo de código a seguir mostra como implementar essa interface em um tipo de dados personalizadas e fornecer <xref:System.Object.GetHashCode%2A> e <xref:System.Object.Equals%2A> métodos.  
  
 [!code-csharp[CSLINQEncapsulatedComparer#9](~/samples/snippets/csharp/VS_Snippets_VBCSharp/CsLINQEncapsulatedComparer/CS/EncapsulatedComparer.cs#9)]  
  
 Depois de implementar essa interface, você pode usar sequências de `ProductA` objetos no <xref:System.Linq.Enumerable.Union%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%29> método, conforme mostrado no exemplo a seguir.  
  
 [!code-csharp[CSLINQEncapsulatedComparer#10](~/samples/snippets/csharp/VS_Snippets_VBCSharp/CsLINQEncapsulatedComparer/CS/EncapsulatedComparer.cs#10)]  
[!code-csharp[CSLINQEncapsulatedComparer#4](~/samples/snippets/csharp/VS_Snippets_VBCSharp/CsLINQEncapsulatedComparer/CS/EncapsulatedComparer.cs#4)]
[!code-vb[CSLINQEncapsulatedComparer#4](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/CsLINQEncapsulatedComparer/VB/EncapsulatedComparer.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="first" /> ou <paramref name="second" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Union&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;TSource&gt; Union&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; first, System.Collections.Generic.IEnumerable&lt;TSource&gt; second, System.Collections.Generic.IEqualityComparer&lt;TSource&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; Union&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; first, class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; second, class System.Collections.Generic.IEqualityComparer`1&lt;!!TSource&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Union``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEqualityComparer{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Union(Of TSource) (first As IEnumerable(Of TSource), second As IEnumerable(Of TSource), comparer As IEqualityComparer(Of TSource)) As IEnumerable(Of TSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ Union(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ first, System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ second, System::Collections::Generic::IEqualityComparer&lt;TSource&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="static member Union : seq&lt;'Source&gt; * seq&lt;'Source&gt; * System.Collections.Generic.IEqualityComparer&lt;'Source&gt; -&gt; seq&lt;'Source&gt;" Usage="System.Linq.Enumerable.Union (first, second, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="first" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="second" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IEqualityComparer&lt;TSource&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">O tipo dos elementos das sequências de entrada.</typeparam>
        <param name="first">Um <see cref="T:System.Collections.Generic.IEnumerable`1" /> cujos elementos distintos formam o primeiro conjunto da união.</param>
        <param name="second">Um <see cref="T:System.Collections.Generic.IEnumerable`1" /> cujos elementos distintos formam o segundo conjunto da união.</param>
        <param name="comparer">O <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> para comparar valores.</param>
        <summary>Produz a união de conjunto de duas sequências usando o <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> especificado.</summary>
        <returns>Um <see cref="T:System.Collections.Generic.IEnumerable`1" /> que contém os elementos de ambas as sequências de entrada, excluindo as duplicatas.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método é implementado usando a execução adiada. O imediata valor retornado é um objeto que armazena todas as informações necessárias para executar a ação. A consulta representada por esse método não é executada até que o objeto é enumerado chamando-se suas `GetEnumerator` método diretamente ou usando `foreach` no Visual c# ou `For Each` no Visual Basic.  
  
 Se `comparer` está `null`, o comparador de igualdade padrão, <xref:System.Collections.Generic.EqualityComparer%601.Default%2A>, é usado para comparar valores.  
  
 Quando o objeto retornado por esse método é enumerado, <xref:System.Linq.Enumerable.Union%2A> enumera `first` e `second` nessa ordem e produz cada elemento que já não foram produzido.  
  
 O <xref:System.Linq.Enumerable.Concat%2A> difere do método de <xref:System.Linq.Enumerable.Union%2A> método porque o <xref:System.Linq.Enumerable.Concat%2A> método retorna todos os elementos nas sequências de entrada, incluindo as duplicatas, enquanto <xref:System.Linq.Enumerable.Union%2A> retorna apenas valores exclusivos.  
  
   
  
## Examples  
 O exemplo a seguir mostra como implementar um comparador de igualdade que pode ser usado no <xref:System.Linq.Enumerable.Union%2A> método.  
  
 [!code-csharp[CSLINQCustomComparer#1](~/samples/snippets/csharp/VS_Snippets_VBCSharp/CsLINQCustomComparer/CS/CustomComparer.cs#1)]
 [!code-vb[CSLINQCustomComparer#1](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/CsLINQCustomComparer/VB/CustomComparer.vb#1)]  
  
 Depois de implementar esse comparador, você pode usar sequências de `Product` objetos no <xref:System.Linq.Enumerable.Union%2A> método, conforme mostrado no exemplo a seguir.  
  
 [!code-csharp[CSLINQCustomComparer#2](~/samples/snippets/csharp/VS_Snippets_VBCSharp/CsLINQCustomComparer/CS/CustomComparer.cs#2)]
 [!code-vb[CSLINQCustomComparer#2](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/CsLINQCustomComparer/VB/CustomComparer.vb#2)]  
[!code-csharp[CSLINQCustomComparer#4](~/samples/snippets/csharp/VS_Snippets_VBCSharp/CsLINQCustomComparer/CS/CustomComparer.cs#4)]
[!code-vb[CSLINQCustomComparer#4](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/CsLINQCustomComparer/VB/CustomComparer.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="first" /> ou <paramref name="second" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Where&lt;TSource&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Filtra uma sequência de valores com base em um predicado.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Where&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;TSource&gt; Where&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,bool&gt; predicate);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; Where&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, bool&gt; predicate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Where``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Boolean})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Where(Of TSource) (source As IEnumerable(Of TSource), predicate As Func(Of TSource, Boolean)) As IEnumerable(Of TSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ Where(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Func&lt;TSource, bool&gt; ^ predicate);" />
      <MemberSignature Language="F#" Value="static member Where : seq&lt;'Source&gt; * Func&lt;'Source, bool&gt; -&gt; seq&lt;'Source&gt;" Usage="System.Linq.Enumerable.Where (source, predicate)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="predicate" Type="System.Func&lt;TSource,System.Boolean&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">O tipo dos elementos de <paramref name="source" />.</typeparam>
        <param name="source">Um <see cref="T:System.Collections.Generic.IEnumerable`1" /> a ser filtrado.</param>
        <param name="predicate">Uma função para testar cada elemento em relação a uma condição.</param>
        <summary>Filtra uma sequência de valores com base em um predicado.</summary>
        <returns>Um <see cref="T:System.Collections.Generic.IEnumerable`1" /> que contém elementos da sequência de entrada que atendem à condição.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método é implementado usando a execução adiada. O imediata valor retornado é um objeto que armazena todas as informações necessárias para executar a ação. A consulta representada por esse método não é executada até que o objeto é enumerado chamando-se suas `GetEnumerator` método diretamente ou usando `foreach` no Visual c# ou `For Each` no Visual Basic.  
  
 Na sintaxe de expressão de consulta, uma `where` (Visual c#) ou `Where` cláusula (Visual Basic) se traduz em uma invocação de <xref:System.Linq.Enumerable.Where%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Boolean%7D%29>.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como usar <xref:System.Linq.Enumerable.Where%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Boolean%7D%29> para filtrar uma sequência.  
  
 [!code-csharp[System.Linq.Enumerable#110](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#110)]
 [!code-vb[System.Linq.Enumerable#110](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#110)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> ou <paramref name="predicate" /> é <see langword="null" />.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/7f9bf952-7744-4f91-b676-cddb55d107c3">Cláusula where (Referência de C#)</related>
        <related type="Article" href="https://msdn.microsoft.com/library/48b5c2c5-3181-429c-8545-894296798c89">Cláusula Where (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Where&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;TSource&gt; Where&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,int,bool&gt; predicate);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; Where&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`3&lt;!!TSource, int32, bool&gt; predicate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Where``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Int32,System.Boolean})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Where(Of TSource) (source As IEnumerable(Of TSource), predicate As Func(Of TSource, Integer, Boolean)) As IEnumerable(Of TSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ Where(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Func&lt;TSource, int, bool&gt; ^ predicate);" />
      <MemberSignature Language="F#" Value="static member Where : seq&lt;'Source&gt; * Func&lt;'Source, int, bool&gt; -&gt; seq&lt;'Source&gt;" Usage="System.Linq.Enumerable.Where (source, predicate)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="predicate" Type="System.Func&lt;TSource,System.Int32,System.Boolean&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">O tipo dos elementos de <paramref name="source" />.</typeparam>
        <param name="source">Um <see cref="T:System.Collections.Generic.IEnumerable`1" /> a ser filtrado.</param>
        <param name="predicate">Uma função para testar cada elemento de origem em relação a uma condição; o segundo parâmetro da função representa o índice do elemento de origem.</param>
        <summary>Filtra uma sequência de valores com base em um predicado. O índice de cada elemento é usado na lógica da função de predicado.</summary>
        <returns>Um <see cref="T:System.Collections.Generic.IEnumerable`1" /> que contém elementos da sequência de entrada que atendem à condição.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método é implementado usando a execução adiada. O imediata valor retornado é um objeto que armazena todas as informações necessárias para executar a ação. A consulta representada por esse método não é executada até que o objeto é enumerado chamando-se suas `GetEnumerator` método diretamente ou usando `foreach` no Visual c# ou `For Each` no Visual Basic.  
  
 O primeiro argumento do `predicate` representa o elemento a ser testado. O segundo argumento representa o índice baseado em zero do elemento no `source`.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como usar <xref:System.Linq.Enumerable.Where%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Int32%2CSystem.Boolean%7D%29> para filtrar uma sequência com base em um predicado que envolve o índice de cada elemento.  
  
 [!code-csharp[System.Linq.Enumerable#111](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#111)]
 [!code-vb[System.Linq.Enumerable#111](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#111)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> ou <paramref name="predicate" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Zip&lt;TFirst,TSecond,TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;TResult&gt; Zip&lt;TFirst,TSecond,TResult&gt; (this System.Collections.Generic.IEnumerable&lt;TFirst&gt; first, System.Collections.Generic.IEnumerable&lt;TSecond&gt; second, Func&lt;TFirst,TSecond,TResult&gt; resultSelector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;!!TResult&gt; Zip&lt;TFirst, TSecond, TResult&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TFirst&gt; first, class System.Collections.Generic.IEnumerable`1&lt;!!TSecond&gt; second, class System.Func`3&lt;!!TFirst, !!TSecond, !!TResult&gt; resultSelector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Zip``3(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1},System.Func{``0,``1,``2})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Zip(Of TFirst, TSecond, TResult) (first As IEnumerable(Of TFirst), second As IEnumerable(Of TSecond), resultSelector As Func(Of TFirst, TSecond, TResult)) As IEnumerable(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TFirst, typename TSecond, typename TResult&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Collections::Generic::IEnumerable&lt;TResult&gt; ^ Zip(System::Collections::Generic::IEnumerable&lt;TFirst&gt; ^ first, System::Collections::Generic::IEnumerable&lt;TSecond&gt; ^ second, Func&lt;TFirst, TSecond, TResult&gt; ^ resultSelector);" />
      <MemberSignature Language="F#" Value="static member Zip : seq&lt;'First&gt; * seq&lt;'Second&gt; * Func&lt;'First, 'Second, 'Result&gt; -&gt; seq&lt;'Result&gt;" Usage="System.Linq.Enumerable.Zip (first, second, resultSelector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TFirst" />
        <TypeParameter Name="TSecond" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="first" Type="System.Collections.Generic.IEnumerable&lt;TFirst&gt;" RefType="this" />
        <Parameter Name="second" Type="System.Collections.Generic.IEnumerable&lt;TSecond&gt;" />
        <Parameter Name="resultSelector" Type="System.Func&lt;TFirst,TSecond,TResult&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TFirst">O tipo de elementos na primeira sequência de entrada.</typeparam>
        <typeparam name="TSecond">O tipo de elementos na segunda sequência de entrada.</typeparam>
        <typeparam name="TResult">O tipo de elementos na sequência de resultado.</typeparam>
        <param name="first">A primeira sequência a ser mesclada.</param>
        <param name="second">A segunda sequência a ser mesclada.</param>
        <param name="resultSelector">Uma função que especifica como mesclar os elementos das duas sequências.</param>
        <summary>Aplica uma função especificada para os elementos correspondentes de duas sequências, produzindo uma sequência dos resultados.</summary>
        <returns>Um <see cref="T:System.Collections.Generic.IEnumerable`1" /> que contém elementos mesclados de duas sequências de entrada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método é implementado usando a execução adiada. O imediata valor retornado é um objeto que armazena todas as informações necessárias para executar a ação. A consulta representada por esse método não é executada até que o objeto é enumerado chamando-se suas `GetEnumerator` método diretamente ou usando `foreach` no Visual c# ou `For Each` no Visual Basic.  
  
 O método mescla cada elemento da primeira sequência com um elemento que tem o mesmo índice na segunda sequência. Se as sequências não tiverem o mesmo número de elementos, o método mescla as sequências até atingir o final de um deles. Por exemplo, se uma sequência tem três elementos e o outro é tem quatro, a sequência de resultado terá apenas três elementos.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como usar o <xref:System.Linq.Enumerable.Zip%2A> método para mesclar duas sequências.  
  
 [!code-csharp[System.Linq.Enumerable#200](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#200)]
 [!code-vb[System.Linq.Enumerable#200](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#200)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="first" /> ou <paramref name="second" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
  </Members>
</Type>