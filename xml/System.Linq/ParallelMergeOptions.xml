<Type Name="ParallelMergeOptions" FullName="System.Linq.ParallelMergeOptions">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="67c7b5aaf5171cfcb74824b3721aec2ea41e73f0" />
    <Meta Name="ms.sourcegitcommit" Value="16d2d159872fd213cae4b8f371d7ae9c8b027c89" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="pt-BR" />
    <Meta Name="ms.lasthandoff" Value="11/17/2018" />
    <Meta Name="ms.locfileid" Value="51914560" />
  </Metadata>
  <TypeSignature Language="C#" Value="public enum ParallelMergeOptions" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed ParallelMergeOptions extends System.Enum" />
  <TypeSignature Language="DocId" Value="T:System.Linq.ParallelMergeOptions" />
  <TypeSignature Language="VB.NET" Value="Public Enum ParallelMergeOptions" />
  <TypeSignature Language="C++ CLI" Value="public enum class ParallelMergeOptions" />
  <TypeSignature Language="F#" Value="type ParallelMergeOptions = " />
  <AssemblyInfo>
    <AssemblyName>System.Linq.Parallel</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.3.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Core</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Enum</BaseTypeName>
  </Base>
  <Docs>
    <summary>Especifica o tipo preferencial de *mesclagem de saída* a ser usado em uma consulta. Em outras palavras, ele indica como o PLINQ deve mesclar os resultados de várias partições novamente em uma sequência de resultados. <span data-ttu-id="701d2-103">Isso é apenas uma dica e pode não ser respeitado pelo sistema ao paralelizar todas as consultas.</span><span class="sxs-lookup"><span data-stu-id="701d2-103">This is a hint only, and may not be respected by the system when parallelizing all queries.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="701d2-104">Use `NotBuffered` para consultas que serão consumidas e como fluxos de saída, isso tem a menor latência entre a execução da consulta inicial e os elementos que está sendo gerados.</span><span class="sxs-lookup"><span data-stu-id="701d2-104">Use `NotBuffered` for queries that will be consumed and output as streams, this has the lowest latency between beginning query execution and elements being yielded.</span></span> <span data-ttu-id="701d2-105">Para algumas consultas, como aquelas que envolvem uma classificação (OrderBy, OrderByDescending), o buffer é essencial e uma dica de NotBuffered ou AutoBuffered será ignorada.</span><span class="sxs-lookup"><span data-stu-id="701d2-105">For some queries, such as those involving a sort (OrderBy, OrderByDescending), buffering is essential and a hint of NotBuffered or AutoBuffered will be ignored.</span></span> <span data-ttu-id="701d2-106">No entanto, as consultas que são criadas usando o operador AsOrdered podem ser transmitidas desde que nenhuma classificação adicional é executada na própria consulta.</span><span class="sxs-lookup"><span data-stu-id="701d2-106">However, queries that are created by using the AsOrdered operator can be streamed as long as no further sorting is performed within the query itself.</span></span>  
  
 <span data-ttu-id="701d2-107">Use `AutoBuffered` na maioria dos casos; esse é o padrão.</span><span class="sxs-lookup"><span data-stu-id="701d2-107">Use `AutoBuffered` for most cases; this is the default.</span></span> <span data-ttu-id="701d2-108">Ela atinge um equilíbrio entre a latência e o desempenho geral.</span><span class="sxs-lookup"><span data-stu-id="701d2-108">It strikes a balance between latency and overall performance.</span></span>  
  
 <span data-ttu-id="701d2-109">Use `FullyBuffered` para consultas quando toda a saída pode ser processada antes que as informações são necessárias.</span><span class="sxs-lookup"><span data-stu-id="701d2-109">Use `FullyBuffered` for queries when the entire output can be processed before the information is needed.</span></span> <span data-ttu-id="701d2-110">Essa opção oferece o melhor desempenho quando toda a saída pode ser acumulada antes produzindo todas as informações que não seja adequado para o fluxo de processamento ou mostrando parcial resultados de consulta intermediária.</span><span class="sxs-lookup"><span data-stu-id="701d2-110">This option offers the best performance when all of the output can be accumulated before yielding any information, though it is not suitable for stream processing or showing partial results mid-query.</span></span>  
  
 ]]></format>
    </remarks>
    <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">
      <span data-ttu-id="701d2-111">LINQ paralelo (PLINQ)</span>
      <span class="sxs-lookup">
        <span data-stu-id="701d2-111">Parallel LINQ (PLINQ)</span>
      </span>
    </related>
    <related type="Article" href="https://msdn.microsoft.com/library/e8f7be3b-88de-4f33-ab14-dc008e76c1ba">
      <span data-ttu-id="701d2-112">Opções de mesclagem em PLINQ</span>
      <span class="sxs-lookup">
        <span data-stu-id="701d2-112">Merge Options in PLINQ</span>
      </span>
    </related>
    <related type="Article" href="https://msdn.microsoft.com/library/0f33b527-e91a-4550-a39a-e63e396fd831">
      <span data-ttu-id="701d2-113">Como especificar opções de mesclagem em PLINQ</span>
      <span class="sxs-lookup">
        <span data-stu-id="701d2-113">How to: Specify Merge Options in PLINQ</span>
      </span>
    </related>
  </Docs>
  <Members>
    <Member MemberName="AutoBuffered">
      <MemberSignature Language="C#" Value="AutoBuffered" />
      <MemberSignature Language="ILAsm" Value=".field public static literal valuetype System.Linq.ParallelMergeOptions AutoBuffered = int32(2)" />
      <MemberSignature Language="DocId" Value="F:System.Linq.ParallelMergeOptions.AutoBuffered" />
      <MemberSignature Language="VB.NET" Value="AutoBuffered" />
      <MemberSignature Language="C++ CLI" Value="AutoBuffered" />
      <MemberSignature Language="F#" Value="AutoBuffered = 2" Usage="System.Linq.ParallelMergeOptions.AutoBuffered" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.ParallelMergeOptions</ReturnType>
      </ReturnValue>
      <MemberValue>2</MemberValue>
      <Docs>
        <summary>
          <span data-ttu-id="701d2-114">Usar uma mesclagem com buffers de saída de um tamanho escolhido pelo sistema.</span>
          <span class="sxs-lookup">
            <span data-stu-id="701d2-114">Use a merge with output buffers of a size chosen by the system.</span>
          </span>
          <span data-ttu-id="701d2-115">Os resultados acumularão em um buffer de saída antes de estarem disponíveis para o consumidor da consulta.</span>
          <span class="sxs-lookup">
            <span data-stu-id="701d2-115">Results will accumulate into an output buffer before they are available to the consumer of the query.</span>
          </span>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="Default">
      <MemberSignature Language="C#" Value="Default" />
      <MemberSignature Language="ILAsm" Value=".field public static literal valuetype System.Linq.ParallelMergeOptions Default = int32(0)" />
      <MemberSignature Language="DocId" Value="F:System.Linq.ParallelMergeOptions.Default" />
      <MemberSignature Language="VB.NET" Value="Default" />
      <MemberSignature Language="C++ CLI" Value="Default" />
      <MemberSignature Language="F#" Value="Default = 0" Usage="System.Linq.ParallelMergeOptions.Default" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.ParallelMergeOptions</ReturnType>
      </ReturnValue>
      <MemberValue>0</MemberValue>
      <Docs>
        <summary>
          <span data-ttu-id="701d2-116">Usar o tipo de mesclagem padrão, que é AutoBuffered.</span>
          <span class="sxs-lookup">
            <span data-stu-id="701d2-116">Use the default merge type, which is AutoBuffered.</span>
          </span>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="FullyBuffered">
      <MemberSignature Language="C#" Value="FullyBuffered" />
      <MemberSignature Language="ILAsm" Value=".field public static literal valuetype System.Linq.ParallelMergeOptions FullyBuffered = int32(3)" />
      <MemberSignature Language="DocId" Value="F:System.Linq.ParallelMergeOptions.FullyBuffered" />
      <MemberSignature Language="VB.NET" Value="FullyBuffered" />
      <MemberSignature Language="C++ CLI" Value="FullyBuffered" />
      <MemberSignature Language="F#" Value="FullyBuffered = 3" Usage="System.Linq.ParallelMergeOptions.FullyBuffered" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.ParallelMergeOptions</ReturnType>
      </ReturnValue>
      <MemberValue>3</MemberValue>
      <Docs>
        <summary>
          <span data-ttu-id="701d2-117">Usar uma mesclagem com buffers de saída cheios.</span>
          <span class="sxs-lookup">
            <span data-stu-id="701d2-117">Use a merge with full output buffers.</span>
          </span>
          <span data-ttu-id="701d2-118">O sistema acumulará todos os resultados antes de disponibilizá-los para o consumidor da consulta.</span>
          <span class="sxs-lookup">
            <span data-stu-id="701d2-118">The system will accumulate all of the results before making any of them available to the consumer of the query.</span>
          </span>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="NotBuffered">
      <MemberSignature Language="C#" Value="NotBuffered" />
      <MemberSignature Language="ILAsm" Value=".field public static literal valuetype System.Linq.ParallelMergeOptions NotBuffered = int32(1)" />
      <MemberSignature Language="DocId" Value="F:System.Linq.ParallelMergeOptions.NotBuffered" />
      <MemberSignature Language="VB.NET" Value="NotBuffered" />
      <MemberSignature Language="C++ CLI" Value="NotBuffered" />
      <MemberSignature Language="F#" Value="NotBuffered = 1" Usage="System.Linq.ParallelMergeOptions.NotBuffered" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.ParallelMergeOptions</ReturnType>
      </ReturnValue>
      <MemberValue>1</MemberValue>
      <Docs>
        <summary>
          <span data-ttu-id="701d2-119">Usar uma mesclagem sem buffers de saída.</span>
          <span class="sxs-lookup">
            <span data-stu-id="701d2-119">Use a merge without output buffers.</span>
          </span>
          <span data-ttu-id="701d2-120">Assim que os elementos de resultado tiverem sido computados, disponibilizar esse elemento para o consumidor na consulta.</span>
          <span class="sxs-lookup">
            <span data-stu-id="701d2-120">As soon as result elements have been computed, make that element available to the consumer of the query.</span>
          </span>
        </summary>
      </Docs>
    </Member>
  </Members>
</Type>