<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="ParallelMergeOptions.xml" source-language="en-US" target-language="pt-BR">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-15c36f0" tool-company="Microsoft" />
      <xliffext:skl_file_name xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">02cd5861-7ce2-4a82-b358-31f8435a0ac53cc52c2fdc311942111dafa5de93e39f3ca04a7b.skl</xliffext:skl_file_name>
      <xliffext:version xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">1.2</xliffext:version>
      <xliffext:ms.openlocfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">3cc52c2fdc311942111dafa5de93e39f3ca04a7b</xliffext:ms.openlocfilehash>
      <xliffext:ms.sourcegitcommit xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b</xliffext:ms.sourcegitcommit>
      <xliffext:ms.lasthandoff xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">04/03/2018</xliffext:ms.lasthandoff>
      <xliffext:moniker_ids xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">netcore-1.0,netcore-1.1,netcore-2.0,netcore-2.1,netframework-4.5.1,netframework-4.5.2,netframework-4.5,netframework-4.6.1,netframework-4.6.2,netframework-4.6,netframework-4.7.1,netframework-4.7,netstandard-2.0,xamarinandroid-7.1,xamarinios-10.8,xamarinmac-3.0</xliffext:moniker_ids>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve" uid="T:System.Linq.ParallelMergeOptions">
          <source>Specifies the preferred type of <bpt id="p1">*</bpt>output merge<ept id="p1">*</ept> to use in a query.</source>
          <target state="translated">Especifica o tipo preferencial de <bpt id="p1">*</bpt>mesclagem de saída<ept id="p1">*</ept> a ser usado em uma consulta.</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve" uid="T:System.Linq.ParallelMergeOptions">
          <source>In other words, it indicates how PLINQ should merge the results from the various partitions back into a single result sequence.</source>
          <target state="translated">Em outras palavras, ele indica como o PLINQ deve mesclar os resultados de várias partições novamente em uma sequência de resultados.</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve" uid="T:System.Linq.ParallelMergeOptions">
          <source>This is a hint only, and may not be respected by the system when parallelizing all queries.</source>
          <target state="translated">Isso é apenas uma dica e pode não ser respeitado pelo sistema ao paralelizar todas as consultas.</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Linq.ParallelMergeOptions">
          <source>Use <ph id="ph1">`NotBuffered`</ph> for queries that will be consumed and output as streams, this has the lowest latency between beginning query execution and elements being yielded.</source>
          <target state="translated">Use <ph id="ph1">`NotBuffered`</ph> para consultas que serão consumidas e como fluxos de saída, isso tem a menor latência entre a execução de consulta de início e elementos que estão sendo gerou.</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Linq.ParallelMergeOptions">
          <source>For some queries, such as those involving a sort (OrderBy, OrderByDescending), buffering is essential and a hint of NotBuffered or AutoBuffered will be ignored.</source>
          <target state="translated">Para algumas consultas, como os que envolvem uma classificação (OrderBy, OrderByDescending), o buffer é essencial e uma dica de NotBuffered ou AutoBuffered será ignorada.</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Linq.ParallelMergeOptions">
          <source>However, queries that are created by using the AsOrdered operator can be streamed as long as no further sorting is performed within the query itself.</source>
          <target state="translated">No entanto, as consultas que são criadas usando o operador AsOrdered podem ser transmitidas como nenhuma classificação adicional é executada na própria consulta.</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Linq.ParallelMergeOptions">
          <source>Use <ph id="ph1">`AutoBuffered`</ph> for most cases; this is the default.</source>
          <target state="translated">Use <ph id="ph1">`AutoBuffered`</ph> na maioria dos casos; esse é o padrão.</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Linq.ParallelMergeOptions">
          <source>It strikes a balance between latency and overall performance.</source>
          <target state="translated">Apresenta um equilíbrio entre a latência e o desempenho geral.</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Linq.ParallelMergeOptions">
          <source>Use <ph id="ph1">`FullyBuffered`</ph> for queries when the entire output can be processed before the information is needed.</source>
          <target state="translated">Use <ph id="ph1">`FullyBuffered`</ph> para consultas quando toda a saída pode ser processada antes que as informações são necessárias.</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Linq.ParallelMergeOptions">
          <source>This option offers the best performance when all of the output can be accumulated before yielding any information, though it is not suitable for stream processing or showing partial results mid-query.</source>
          <target state="translated">Essa opção oferece o melhor desempenho quando toda a saída pode ser acumuladas antes gerando qualquer informação, embora ele não é adequado para o fluxo de processamento ou a exibição parcial resultados de consulta intermediário.</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve" uid="F:System.Linq.ParallelMergeOptions.AutoBuffered">
          <source>Use a merge with output buffers of a size chosen by the system.</source>
          <target state="translated">Usar uma mesclagem com buffers de saída de um tamanho escolhido pelo sistema.</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve" uid="F:System.Linq.ParallelMergeOptions.AutoBuffered">
          <source>Results will accumulate into an output buffer before they are available to the consumer of the query.</source>
          <target state="translated">Os resultados acumularão em um buffer de saída antes de estarem disponíveis para o consumidor da consulta.</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve" uid="F:System.Linq.ParallelMergeOptions.Default">
          <source>Use the default merge type, which is AutoBuffered.</source>
          <target state="translated">Usar o tipo de mesclagem padrão, que é AutoBuffered.</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve" uid="F:System.Linq.ParallelMergeOptions.FullyBuffered">
          <source>Use a merge with full output buffers.</source>
          <target state="translated">Usar uma mesclagem com buffers de saída cheios.</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve" uid="F:System.Linq.ParallelMergeOptions.FullyBuffered">
          <source>The system will accumulate all of the results before making any of them available to the consumer of the query.</source>
          <target state="translated">O sistema acumulará todos os resultados antes de disponibilizá-los para o consumidor da consulta.</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve" uid="F:System.Linq.ParallelMergeOptions.NotBuffered">
          <source>Use a merge without output buffers.</source>
          <target state="translated">Usar uma mesclagem sem buffers de saída.</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve" uid="F:System.Linq.ParallelMergeOptions.NotBuffered">
          <source>As soon as result elements have been computed, make that element available to the consumer of the query.</source>
          <target state="translated">Assim que os elementos de resultado tiverem sido computados, disponibilizar esse elemento para o consumidor na consulta.</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>