<Type Name="MetadataLoadContext" FullName="System.Reflection.MetadataLoadContext">
  <Metadata><Meta Name="ms.openlocfilehash" Value="9aaf43973195666dd08ebb47e5dd2fc7f8617f14" /><Meta Name="ms.sourcegitcommit" Value="2767b5903996fbd7e2b81eda1114dfc9d0d9db63" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="pt-BR" /><Meta Name="ms.lasthandoff" Value="05/02/2019" /><Meta Name="ms.locfileid" Value="64996700" /></Metadata><TypeSignature Language="C#" Value="public sealed class MetadataLoadContext : IDisposable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit MetadataLoadContext extends System.Object implements class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.Reflection.MetadataLoadContext" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class MetadataLoadContext&#xA;Implements IDisposable" />
  <TypeSignature Language="C++ CLI" Value="public ref class MetadataLoadContext sealed : IDisposable" />
  <TypeSignature Language="F#" Value="type MetadataLoadContext = class&#xA;    interface IDisposable" />
  <AssemblyInfo>
    <AssemblyName>System.Reflection.MetadataLoadContext</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Representa um universo fechado de objetos do tipo carregado para fins de inspeção. Cada MetadataLoadContext pode ter suas próprias regras de associação e é isolada de todas as outras MetadataLoadContexts.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  

## Remarks

Um `MetadataLoadContext` serve como um dicionário que associa os nomes de assembly para <xref:System.Reflection.Assembly> instâncias que foram previamente carregadas no contexto ou necessidade de ser carregado.

Assemblies são tratados estritamente como metadados. Não há nenhuma restrição sobre como carregar assemblies com base na plataforma de destino, a arquitetura de CPU ou o tamanho do ponteiro. Não há nenhuma restrição sobre o assembly designado como o principal assembly (**mscorlib**).

]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public MetadataLoadContext (System.Reflection.MetadataAssemblyResolver resolver, string coreAssemblyName = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Reflection.MetadataAssemblyResolver resolver, string coreAssemblyName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.MetadataLoadContext.#ctor(System.Reflection.MetadataAssemblyResolver,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (resolver As MetadataAssemblyResolver, Optional coreAssemblyName As String = null)" />
      <MemberSignature Language="F#" Value="new System.Reflection.MetadataLoadContext : System.Reflection.MetadataAssemblyResolver * string -&gt; System.Reflection.MetadataLoadContext" Usage="new System.Reflection.MetadataLoadContext (resolver, coreAssemblyName)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.MetadataLoadContext</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="resolver" Type="System.Reflection.MetadataAssemblyResolver" />
        <Parameter Name="coreAssemblyName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="resolver">Uma instância de <see cref="T:System.Reflection.MetadataAssemblyResolver" />.</param>
        <param name="coreAssemblyName">O nome do assembly que contém os tipos principais, como <see cref="T:System.Object" />. Normalmente, isso seria "mscorlib".</param>
        <summary>Cria um novo objeto <see cref="T:System.Reflection.MetadataLoadContext" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CoreAssembly">
      <MemberSignature Language="C#" Value="public System.Reflection.Assembly CoreAssembly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.Assembly CoreAssembly" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MetadataLoadContext.CoreAssembly" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CoreAssembly As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Reflection::Assembly ^ CoreAssembly { System::Reflection::Assembly ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.CoreAssembly : System.Reflection.Assembly" Usage="System.Reflection.MetadataLoadContext.CoreAssembly" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.MetadataLoadContext</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define o assembly que denota o "assembly de sistema" que hospeda os tipos conhecidos, como <see cref="T:System.Int32" />.</summary>
        <value>Uma instância <see cref="T:System.Reflection.Assembly" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

O assembly principal é tratado diferentemente de outros assemblies, porque as referências a esses tipos conhecidos não incluem a referência de assembly, ao contrário de tipos normais.
            
Normalmente, esse assembly é chamado "mscorlib" ou "netstandard". Se o assembly principal não for encontrado, o valor será `null`, e muitos outros métodos de reflexão, incluindo aqueles que analisam as assinaturas de método lançará uma exceção.
            
O `CoreAssembly` é determinado, passando a `coreAssemblyName` parâmetro passado para o <xref:System.Reflection.MetadataAssemblyResolver> construtor para o <xref:System.Reflection.MetadataAssemblyResolver.Resolve%2A?displayProperty=nameWithType> método.

Se nenhum `coreAssemblyName` argumento foi especificado no construtor do <xref:System.Reflection.MetadataLoadContext>, em seguida, os valores padrão são usados, incluindo "mscorlib", "System. Runtime" e "netstandard".
            
O assembly principal designado não precisa conter os tipos principais diretamente. Ele pode digitar encaminhá-los para outros assemblies. Portanto, é perfeitamente possível usar a fachada de mscorlib como o assembly principal designado.
            
Observe que <xref:System.Runtime> não é um assembly principal ideal porque ele exclui alguns dos tipos de atributo personalizado pseudo relacionados à interoperabilidade, como <xref:System.Runtime.InteropServices.DllImportAttribute>. No entanto, ela poderá servir se você não tenha interesse nesses atributos. A API CustomAttributes ignorará esses atributos se o assembly principal não inclui os tipos necessários.
            
O assembly principal não está carregado até que o necessário. As seguintes APIs não disparam a pesquisa para o assembly principal:

* <xref:System.Reflection.MetadataLoadContext.LoadFromStream%2A?displayProperty=nameWithType>
* <xref:System.Reflection.MetadataLoadContext.LoadFromAssemblyPath%2A?displayProperty=nameWithType>
* <xref:System.Reflection.MetadataLoadContext.LoadFromByteArray%2A?displayProperty=nameWithType>
* <System.Reflection.Assembly.GetName%2A?displayProperty=nameWithType>
* <System.Reflection.Assembly.FullName?displayProperty=nameWithType>
* <System.Reflection.Assembly.GetReferencedAssemblies%2A?displayProperty=nameWithType>
* <System.Reflection.Assembly.GetTypes%2A?displayProperty=nameWithType>
* <System.Reflection.Assembly.DefinedTypes?displayProperty=nameWithType>
* <System.Reflection.Assembly.GetExportedTypes%2A?displayProperty=nameWithType>
* <System.Reflection.Assembly.GetForwardedTypes%2A?displayProperty=nameWithType>
* <System.Reflection.Assembly.GetType(System.String,System.Boolean,System.Boolean)?displayProperty=nameWithType>
* <xref:System.Type.Name?displayProperty=nameWithType>
* <xref:System.Type.FullName?displayProperty=nameWithType>
* <xref:System.Type.AssemblyQualifiedName?displayProperty=nameWithType>
            
Se um assembly principal não pode ser encontrado ou se o assembly principal não tem os tipos, isso afetará o comportamento do <xref:System.Reflection.MetadataLoadContext> da seguinte maneira:
            
* As APIs que precisam analisar assinaturas ou typespecs e retornar os resultados como <xref:System.Type> objetos lançará uma exceção. Por exemplo:

 * <xref:System.Reflection.MethodInfo.ReturnType?displayProperty=nameWithType>
 * System.Reflection.MethodBase.GetParameters%2A?displayProperty=nameWithType>
 * <xref:System.Type.BaseType?displayProperty-nameWithType>
 * <xref:System.Type.GetInterfaces%2A?displayProperty=nameWithType>
            
* As APIs que precisa comparar tipos de núcleo bem conhecidos não lançará uma exceção e a comparação será avaliada como `false`. Por exemplo, se você não especificar um assembly de núcleo <xref:System.Type.IsPrimitive> retornarão `false` para tudo, até mesmo tipos denominados <xref:System.Int32>. Da mesma forma, <xref:System.Type.GetTypeCode%2A?displayProperty=nameWithType> retornará <xref:System.TypeCode.Object> para tudo.
            
* Se uma entidade de metadados define os sinalizadores que são exibidos como um atributo pseudo personalizado e o assembly principal não contém o tipo de atributo pseudo personalizado, o construtor necessário ou qualquer um dos tipos de parâmetro do construtor, o <xref:System.Reflection.MetadataLoadContext> não lançam. Ele omitirá o atributo pseudo personalizado da lista de atributos retornados.
          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.MetadataLoadContext.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberSignature Language="F#" Value="abstract member Dispose : unit -&gt; unit&#xA;override this.Dispose : unit -&gt; unit" Usage="metadataLoadContext.Dispose " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.MetadataLoadContext</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Libera todos os recursos nativos (como bloqueios de arquivo nos arquivos de assembly).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  

Após o descarte, não é seguro usar qualquer <xref:System.Reflection.Assembly> objetos liberados pelo <xref:System.Reflection.MetadataLoadContext> ou qualquer objeto de reflexão liberadas por aqueles <xref:System.Reflection.Assembly> objetos.

Embora os objetos fornecidos pelo <xref:System.Reflection.MetadataLoadContext> se esforçam para lançar um <xref:System.ObjectDisposedException>, isso não é garantido.

Algumas APIs podem retornar fixa ou dados em cache anteriormente. Acessando objetos *durante* um <xref:System.Reflection.MetadataLoadContext.Dispose%2A> chamada de método pode resultar em uma violação de acesso não gerenciado e failfast.
         ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetAssemblies">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;System.Reflection.Assembly&gt; GetAssemblies ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.IEnumerable`1&lt;class System.Reflection.Assembly&gt; GetAssemblies() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.MetadataLoadContext.GetAssemblies" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAssemblies () As IEnumerable(Of Assembly)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::IEnumerable&lt;System::Reflection::Assembly ^&gt; ^ GetAssemblies();" />
      <MemberSignature Language="F#" Value="member this.GetAssemblies : unit -&gt; seq&lt;System.Reflection.Assembly&gt;" Usage="metadataLoadContext.GetAssemblies " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.MetadataLoadContext</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Reflection.Assembly&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retornar um instantâneo atômico dos assemblies que foram carregados no <see cref="T:System.Reflection.MetadataLoadContext" />.</summary>
        <returns>Uma coleção enumerável de <see xref="T:System.Reflection.Assembly" /> objetos.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="LoadFromAssemblyName">
      <MemberSignature Language="C#" Value="public System.Reflection.Assembly LoadFromAssemblyName (System.Reflection.AssemblyName assemblyName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Assembly LoadFromAssemblyName(class System.Reflection.AssemblyName assemblyName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.MetadataLoadContext.LoadFromAssemblyName(System.Reflection.AssemblyName)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Assembly ^ LoadFromAssemblyName(System::Reflection::AssemblyName ^ assemblyName);" />
      <MemberSignature Language="F#" Value="member this.LoadFromAssemblyName : System.Reflection.AssemblyName -&gt; System.Reflection.Assembly" Usage="metadataLoadContext.LoadFromAssemblyName assemblyName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.MetadataLoadContext</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.Reflection.AssemblyName" />
      </Parameters>
      <Docs>
        <param name="assemblyName">Uma instância <see cref="T:System.Reflection.AssemblyName" />.</param>
        <summary>Resolve o nome do assembly fornecido a um assembly. Se um assembly foi associado anteriormente a esse nome, esse assembly será retornado. Caso contrário, o <see cref="T:System.Reflection.MetadataLoadContext" /> chama especificado <see cref="T:System.Reflection.MetadataAssemblyResolver" />.</summary>
        <returns>Uma instância <see cref="T:System.Reflection.Assembly" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[
## Remarks
Observe que o comportamento desse método corresponde o comportamento do <xref:System.Runtime.Loader.AssemblyLoadContext.LoadFromAssemblyName%2A?displayProperty=nameWithType> resolver o evento, mas não coincide com o comportamento de <xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A?displayProperty=nameWithType>. (O último desiste sem gerar o evento de resolução.)
          ]]></format>
        </remarks>
        <exception cref="T:System.IO.FileNotFoundException">O resolvedor retorna <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="LoadFromAssemblyName">
      <MemberSignature Language="C#" Value="public System.Reflection.Assembly LoadFromAssemblyName (string assemblyName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Assembly LoadFromAssemblyName(string assemblyName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.MetadataLoadContext.LoadFromAssemblyName(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function LoadFromAssemblyName (assemblyName As String) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Assembly ^ LoadFromAssemblyName(System::String ^ assemblyName);" />
      <MemberSignature Language="F#" Value="member this.LoadFromAssemblyName : string -&gt; System.Reflection.Assembly" Usage="metadataLoadContext.LoadFromAssemblyName assemblyName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.MetadataLoadContext</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="assemblyName">Um <see cref="T:System.String" /> que representa o nome do assembly.</param>
        <summary>Resolve o nome do assembly fornecido a um assembly. Se um assembly foi associado anteriormente a esse nome, esse assembly será retornado. Caso contrário, o <see cref="T:System.Reflection.MetadataLoadContext" /> chama especificado <see cref="T:System.Reflection.MetadataAssemblyResolver" />.</summary>
        <returns>Uma instância <see cref="T:System.Reflection.Assembly" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[
## Remarks
Observe que o comportamento desse método corresponde o comportamento de <xref:System.Runtime.Loader.AssemblyLoadContext.LoadFromAssemblyName%2A?displayProperty=nameWithType> resolver o evento, mas não coincide com o comportamento de < xxref:System.Reflection.Assembly.ReflectionOnlyLoad%2A?displayProperty=nameWithType >. (O último desiste sem gerar o evento de resolução.)
]]></format>
        </remarks>
        <exception cref="T:System.IO.FileNotFoundException">O resolvedor retorna <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="LoadFromAssemblyPath">
      <MemberSignature Language="C#" Value="public System.Reflection.Assembly LoadFromAssemblyPath (string assemblyPath);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Assembly LoadFromAssemblyPath(string assemblyPath) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.MetadataLoadContext.LoadFromAssemblyPath(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function LoadFromAssemblyPath (assemblyPath As String) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Assembly ^ LoadFromAssemblyPath(System::String ^ assemblyPath);" />
      <MemberSignature Language="F#" Value="member this.LoadFromAssemblyPath : string -&gt; System.Reflection.Assembly" Usage="metadataLoadContext.LoadFromAssemblyPath assemblyPath" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.MetadataLoadContext</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyPath" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="assemblyPath">Um <see cref="T:System.String" /> que representa o caminho para o assembly.</param>
        <summary>Carrega um assembly de um caminho específico no disco e associa o seu nome de assembly a ele no <see cref="T:System.Reflection.MetadataLoadContext" />. Se um assembly anterior com o mesmo nome já foi carregado para o <see cref="T:System.Reflection.MetadataLoadContext" />, o assembly anterior será retornado.</summary>
        <returns>Uma instância <see cref="T:System.Reflection.Assembly" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.IO.FileLoadException">Os dois assemblies não têm o mesmo Mvid.</exception>
      </Docs>
    </Member>
    <Member MemberName="LoadFromByteArray">
      <MemberSignature Language="C#" Value="public System.Reflection.Assembly LoadFromByteArray (byte[] assembly);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Assembly LoadFromByteArray(unsigned int8[] assembly) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.MetadataLoadContext.LoadFromByteArray(System.Byte[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Assembly ^ LoadFromByteArray(cli::array &lt;System::Byte&gt; ^ assembly);" />
      <MemberSignature Language="F#" Value="member this.LoadFromByteArray : byte[] -&gt; System.Reflection.Assembly" Usage="metadataLoadContext.LoadFromByteArray assembly" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.MetadataLoadContext</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assembly" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="assembly">Um <see cref="T:System.Byte[]" /> contendo um assembly.</param>
        <summary>Carrega um assembly de uma matriz de bytes e associa o seu nome de assembly a ele no <see cref="T:System.Reflection.MetadataLoadContext" />. Se um assembly anterior com o mesmo nome já foi carregado para o <see cref="T:System.Reflection.MetadataLoadContext" />, o assembly anterior será retornado.</summary>
        <returns>Uma instância <see cref="T:System.Reflection.Assembly" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.IO.FileLoadException">Os dois assemblies não têm o mesmo Mvid.</exception>
      </Docs>
    </Member>
    <Member MemberName="LoadFromStream">
      <MemberSignature Language="C#" Value="public System.Reflection.Assembly LoadFromStream (System.IO.Stream assembly);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Assembly LoadFromStream(class System.IO.Stream assembly) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.MetadataLoadContext.LoadFromStream(System.IO.Stream)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Assembly ^ LoadFromStream(System::IO::Stream ^ assembly);" />
      <MemberSignature Language="F#" Value="member this.LoadFromStream : System.IO.Stream -&gt; System.Reflection.Assembly" Usage="metadataLoadContext.LoadFromStream assembly" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.MetadataLoadContext</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assembly" Type="System.IO.Stream" />
      </Parameters>
      <Docs>
        <param name="assembly">Um <see cref="T:System.IO.Stream" /> contendo um assembly.</param>
        <summary>Carrega um assembly de um fluxo e associa o seu nome de assembly a ele no <see cref="T:System.Reflection.MetadataLoadContext" />. Se um assembly anterior com o mesmo nome já foi carregado para o <see cref="T:System.Reflection.MetadataLoadContext" />, o assembly anterior será retornado.</summary>
        <returns>To be added.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

> [!IMPORTANT]
> O <xref:System.Reflection.MetadataLoadContext> assumirá a propriedade do <xref:System.IO.Stream> passados para esse método. O proprietário original não deve modificar sua posição, descarte o <xref:System.IO.Stream>, ou, suponha que sua posição permanecerá inalterada.

]]></format>
        </remarks>
        <exception cref="T:System.IO.FileLoadException">Os dois assemblies não têm o mesmo Mvid.</exception>
      </Docs>
    </Member>
  </Members>
</Type>