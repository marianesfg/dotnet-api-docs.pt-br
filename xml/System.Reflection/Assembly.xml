<Type Name="Assembly" FullName="System.Reflection.Assembly">
  <Metadata><Meta Name="ms.openlocfilehash" Value="c5e3a1b3ca599f0f0d91e2339c100250a9fdfcb4" /><Meta Name="ms.sourcegitcommit" Value="9a6da88bd5455e8274257ca7ad259b42f1de114f" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="pt-BR" /><Meta Name="ms.lasthandoff" Value="05/22/2019" /><Meta Name="ms.locfileid" Value="66007213" /></Metadata><TypeSignature Language="C#" Value="public abstract class Assembly : System.Reflection.ICustomAttributeProvider, System.Runtime.InteropServices._Assembly, System.Runtime.Serialization.ISerializable, System.Security.IEvidenceFactory" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi abstract serializable beforefieldinit Assembly extends System.Object implements class System.Reflection.ICustomAttributeProvider, class System.Runtime.InteropServices._Assembly, class System.Runtime.Serialization.ISerializable, class System.Security.IEvidenceFactory" />
  <TypeSignature Language="DocId" Value="T:System.Reflection.Assembly" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class Assembly&#xA;Implements _Assembly, ICustomAttributeProvider, IEvidenceFactory, ISerializable" />
  <TypeSignature Language="C++ CLI" Value="public ref class Assembly abstract : System::Reflection::ICustomAttributeProvider, System::Runtime::InteropServices::_Assembly, System::Runtime::Serialization::ISerializable, System::Security::IEvidenceFactory" />
  <TypeSignature Language="F#" Value="type Assembly = class&#xA;    interface ICustomAttributeProvider&#xA;    interface _Assembly&#xA;    interface IEvidenceFactory&#xA;    interface ISerializable" />
  <AssemblyInfo>
    <AssemblyName>System.Reflection</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Reflection.ICustomAttributeProvider</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Runtime.InteropServices._Assembly</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Runtime.Serialization.ISerializable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Security.IEvidenceFactory</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ClassInterface(System.Runtime.InteropServices.ClassInterfaceType.None)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComDefaultInterface(typeof(System.Runtime.InteropServices._Assembly))</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary><span data-ttu-id="2cf0e-101">Representa um assembly, que é um bloco de construção autodescritivo, versátil e reutilizável de um aplicativo de common language runtime.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-101">Represents an assembly, which is a reusable, versionable, and self-describing building block of a common language runtime application.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2cf0e-102">Use o <xref:System.Reflection.Assembly> classe carregar assemblies, para explorar as partes constituintes e os metadados de assemblies, para descobrir os tipos contidos em assemblies e para criar instâncias desses tipos.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-102">Use the <xref:System.Reflection.Assembly> class to load assemblies, to explore the metadata and constituent parts of assemblies, to discover the types contained in assemblies, and to create instances of those types.</span></span>  
  
 <span data-ttu-id="2cf0e-103">Para obter uma matriz de <xref:System.Reflection.Assembly> objetos que representam os assemblies no momento, carregado em um domínio do aplicativo (por exemplo, o aplicativo domínio padrão de um projeto simple), use o <xref:System.AppDomain.GetAssemblies%2A?displayProperty=nameWithType> método.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-103">To get an array of <xref:System.Reflection.Assembly> objects representing the assemblies currently loaded into an application domain (for example, the default application domain of a simple project), use the <xref:System.AppDomain.GetAssemblies%2A?displayProperty=nameWithType> method.</span></span>  
  
 <span data-ttu-id="2cf0e-104">Para carregar assemblies dinamicamente, o <xref:System.Reflection.Assembly> classe fornece os seguintes métodos estáticos (`Shared` métodos no Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="2cf0e-104">To load assemblies dynamically, the <xref:System.Reflection.Assembly> class provides the following static methods (`Shared` methods in Visual Basic).</span></span> <span data-ttu-id="2cf0e-105">Assemblies são carregados no domínio do aplicativo onde ocorre a operação de carregamento.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-105">Assemblies are loaded into the application domain where the load operation occurs.</span></span>  
  
-   <span data-ttu-id="2cf0e-106">A maneira recomendada para carregar assemblies é usar o <xref:System.AppDomain.Load%2A> método, que identifica o assembly a ser carregado pelo seu nome de exibição (por exemplo, "Forms, versão = 2.0.0.0, Culture = neutral, PublicKeyToken = b77a5c561934e089").</span><span class="sxs-lookup"><span data-stu-id="2cf0e-106">The recommended way to load assemblies is to use the <xref:System.AppDomain.Load%2A> method, which identifies the assembly to be loaded by its display name (for example, "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089").</span></span> <span data-ttu-id="2cf0e-107">A pesquisa para o assembly segue as regras descritas em [como o tempo de execução Localiza Assemblies](~/docs/framework/deployment/how-the-runtime-locates-assemblies.md).</span><span class="sxs-lookup"><span data-stu-id="2cf0e-107">The search for the assembly follows the rules described in [How the Runtime Locates Assemblies](~/docs/framework/deployment/how-the-runtime-locates-assemblies.md).</span></span>  
  
-   <span data-ttu-id="2cf0e-108">O <xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A> e <xref:System.Reflection.Assembly.ReflectionOnlyLoadFrom%2A> métodos permitem que você carregar um assembly para reflexão, mas não para execução.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-108">The <xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A> and <xref:System.Reflection.Assembly.ReflectionOnlyLoadFrom%2A> methods enable you to load an assembly for reflection, but not for execution.</span></span> <span data-ttu-id="2cf0e-109">Por exemplo, um assembly que tem como alvo uma plataforma de 64 bits pode ser examinado pelo código que está em execução em uma plataforma de 32 bits.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-109">For example, an assembly that targets a 64-bit platform can be examined by code that is running on a 32-bit platform.</span></span>  
  
-   <span data-ttu-id="2cf0e-110">O <xref:System.Reflection.Assembly.LoadFile%2A> e <xref:System.Reflection.Assembly.LoadFrom%2A> métodos são fornecidos para cenários raros em que um assembly deve ser identificado pelo caminho.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-110">The <xref:System.Reflection.Assembly.LoadFile%2A> and <xref:System.Reflection.Assembly.LoadFrom%2A> methods are provided for rare scenarios in which an assembly must be identified by path.</span></span>  
  
 <span data-ttu-id="2cf0e-111">Para obter um <xref:System.Reflection.Assembly> objeto para o assembly em execução no momento, use o <xref:System.Reflection.Assembly.GetExecutingAssembly%2A> método.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-111">To get an <xref:System.Reflection.Assembly> object for the currently executing assembly, use the <xref:System.Reflection.Assembly.GetExecutingAssembly%2A> method.</span></span>  
  
 <span data-ttu-id="2cf0e-112">Número de membros do <xref:System.Reflection.Assembly> classe fornecem informações sobre um assembly.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-112">Many members of the <xref:System.Reflection.Assembly> class provide information about an assembly.</span></span> <span data-ttu-id="2cf0e-113">Por exemplo:</span><span class="sxs-lookup"><span data-stu-id="2cf0e-113">For example:</span></span>  
  
-   <span data-ttu-id="2cf0e-114">O <xref:System.Reflection.Assembly.GetName%2A> método retorna um <xref:System.Reflection.AssemblyName> objeto que fornece acesso às partes do nome de exibição do assembly.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-114">The <xref:System.Reflection.Assembly.GetName%2A> method returns an <xref:System.Reflection.AssemblyName> object that provides access to the parts of the assembly display name.</span></span>  
  
-   <span data-ttu-id="2cf0e-115">O <xref:System.Reflection.Assembly.GetCustomAttributes%2A> método lista os atributos aplicados ao assembly.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-115">The <xref:System.Reflection.Assembly.GetCustomAttributes%2A> method lists the attributes applied to the assembly.</span></span>  
  
-   <span data-ttu-id="2cf0e-116">O <xref:System.Reflection.Assembly.GetFiles%2A> método fornece acesso aos arquivos no manifesto do assembly.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-116">The <xref:System.Reflection.Assembly.GetFiles%2A> method provides access to the files in the assembly manifest.</span></span>  
  
-   <span data-ttu-id="2cf0e-117">O <xref:System.Reflection.Assembly.GetManifestResourceNames%2A> método fornece os nomes dos recursos no manifesto do assembly.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-117">The <xref:System.Reflection.Assembly.GetManifestResourceNames%2A> method provides the names of the resources in the assembly manifest.</span></span>  
  
 <span data-ttu-id="2cf0e-118">O <xref:System.Reflection.Assembly.GetTypes%2A> método lista todos os tipos no assembly.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-118">The <xref:System.Reflection.Assembly.GetTypes%2A> method lists all the types in the assembly.</span></span> <span data-ttu-id="2cf0e-119">O <xref:System.Reflection.Assembly.GetExportedTypes%2A> método lista os tipos que são visíveis para os chamadores fora do assembly.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-119">The <xref:System.Reflection.Assembly.GetExportedTypes%2A> method lists the types that are visible to callers outside the assembly.</span></span> <span data-ttu-id="2cf0e-120">O <xref:System.Reflection.Assembly.GetType%2A> método pode ser usado para pesquisar um determinado tipo no assembly.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-120">The <xref:System.Reflection.Assembly.GetType%2A> method can be used to search for a particular type in the assembly.</span></span> <span data-ttu-id="2cf0e-121">O <xref:System.Reflection.Assembly.CreateInstance%2A> método pode ser usado para procurar e criar instâncias de tipos no assembly.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-121">The <xref:System.Reflection.Assembly.CreateInstance%2A> method can be used to search for and create instances of types in the assembly.</span></span>  
  
 <span data-ttu-id="2cf0e-122">Para obter mais informações sobre assemblies, consulte a seção "Domínios e Assemblies do aplicativo" a [domínios de aplicativo](~/docs/framework/app-domains/application-domains.md) tópico.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-122">For more information on assemblies, see the "Application Domains and Assemblies" section in the [Application Domains](~/docs/framework/app-domains/application-domains.md) topic.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="2cf0e-123">O exemplo de código a seguir mostra como obter o assembly em execução no momento, crie uma instância de um tipo contido nesse assembly e chamar um dos métodos do tipo com associação tardia.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-123">The following code example shows how to obtain the currently executing assembly, create an instance of a type contained in that assembly, and invoke one of the type's methods with late binding.</span></span> <span data-ttu-id="2cf0e-124">Para essa finalidade, o exemplo de código define uma classe chamada `Example`, com um método denominado `SampleMethod`.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-124">For this purpose, the code example defines a class named `Example`, with a method named `SampleMethod`.</span></span> <span data-ttu-id="2cf0e-125">O construtor da classe aceita um inteiro, que é usado para calcular o valor de retorno do método.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-125">The constructor of the class accepts an integer, which is used to compute the return value of the method.</span></span>  
  
 <span data-ttu-id="2cf0e-126">O exemplo de código também demonstra o uso do <xref:System.Reflection.Assembly.GetName%2A> método para obter um <xref:System.Reflection.AssemblyName> objeto que pode ser usado para analisar o nome completo do assembly.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-126">The code example also demonstrates the use of the <xref:System.Reflection.Assembly.GetName%2A> method to obtain an <xref:System.Reflection.AssemblyName> object that can be used to parse the full name of the assembly.</span></span> <span data-ttu-id="2cf0e-127">O exemplo exibe o número de versão do assembly, o <xref:System.Reflection.Assembly.CodeBase%2A> propriedade e o <xref:System.Reflection.Assembly.EntryPoint%2A> propriedade.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-127">The example displays the version number of the assembly, the <xref:System.Reflection.Assembly.CodeBase%2A> property, and the <xref:System.Reflection.Assembly.EntryPoint%2A> property.</span></span>  
  
 [!code-cpp[AssemblyClass#1](~/samples/snippets/cpp/VS_Snippets_CLR/AssemblyClass/cpp/source.cpp#1)]
 [!code-csharp[AssemblyClass#1](~/samples/snippets/csharp/VS_Snippets_CLR/AssemblyClass/cs/source.cs#1)]
 [!code-vb[AssemblyClass#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AssemblyClass/vb/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <permission cref="F:System.Security.Permissions.SecurityAction.InheritanceDemand"><span data-ttu-id="2cf0e-128">para confiança total de herdeiros.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-128">for full trust for inheritors.</span></span> <span data-ttu-id="2cf0e-129">Esta classe não pode ser herdada pelo código parcialmente confiável.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-129">This class cannot be inherited by partially trusted code.</span></span></permission>
    <threadsafe><span data-ttu-id="2cf0e-130">Este tipo é thread-safe.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-130">This type is thread safe.</span></span></threadsafe>
    <altmember cref="T:System.AppDomain" />
    <altmember cref="T:System.Reflection.AssemblyName" />
    <related type="Article" href="~/docs/framework/app-domains/application-domains.md"><span data-ttu-id="2cf0e-131">Domínios do aplicativo</span><span class="sxs-lookup"><span data-stu-id="2cf0e-131">Application Domains</span></span></related>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Assembly ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Assembly();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="2cf0e-132">Inicializa uma nova instância da classe <see cref="T:System.Reflection.Assembly" />.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-132">Initializes a new instance of the <see cref="T:System.Reflection.Assembly" /> class.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2cf0e-133">Este construtor é chamado por classes derivadas durante a construção do <xref:System.Reflection.Assembly> objetos.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-133">This constructor is invoked by derived classes during the construction of <xref:System.Reflection.Assembly> objects.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CodeBase">
      <MemberSignature Language="C#" Value="public virtual string CodeBase { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string CodeBase" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.CodeBase" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property CodeBase As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ CodeBase { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.CodeBase : string" Usage="System.Reflection.Assembly.CodeBase" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Assembly.CodeBase</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="2cf0e-134">Obtém o local do assembly como especificado originalmente, por exemplo, em um objeto <see cref="T:System.Reflection.AssemblyName" />.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-134">Gets the location of the assembly as specified originally, for example, in an <see cref="T:System.Reflection.AssemblyName" /> object.</span></span></summary>
        <value><span data-ttu-id="2cf0e-135">O local do assembly como especificado originalmente.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-135">The location of the assembly as specified originally.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2cf0e-136">Para obter o caminho absoluto para o arquivo carregado que contém o manifesto, use o <xref:System.Reflection.Assembly.Location%2A?displayProperty=nameWithType> propriedade em vez disso.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-136">To get the absolute path to the loaded manifest-containing file, use the <xref:System.Reflection.Assembly.Location%2A?displayProperty=nameWithType> property instead.</span></span>  
  
 <span data-ttu-id="2cf0e-137">Se o assembly foi carregado como uma matriz de bytes, usando uma sobrecarga da <xref:System.Reflection.Assembly.Load%2A> método que usa uma matriz de bytes, essa propriedade retorna o local do chamador do método, não o local do assembly carregado.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-137">If the assembly was loaded as a byte array, using an overload of the <xref:System.Reflection.Assembly.Load%2A> method that takes an array of bytes, this property returns the location of the caller of the method, not the location of the loaded assembly.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="2cf0e-138">O exemplo a seguir usa o <xref:System.Reflection.Assembly.CodeBase%2A> propriedade.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-138">The following example uses the <xref:System.Reflection.Assembly.CodeBase%2A> property.</span></span>  
  
 [!code-cpp[System.Reflection.Assembly#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Assembly/CPP/codebase1.cpp#1)]
 [!code-csharp[System.Reflection.Assembly#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Assembly/CS/codebase1.cs#1)]
 [!code-vb[System.Reflection.Assembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Assembly/VB/codebase1.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.FileIOPermission"><span data-ttu-id="2cf0e-139">para acesso ao caminho.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-139">for access to the path.</span></span> <span data-ttu-id="2cf0e-140">Enumeração associada: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></span><span class="sxs-lookup"><span data-stu-id="2cf0e-140">Associated enumeration: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></span></span></permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateInstance">
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="2cf0e-141">Localiza um tipo nesse assembly e cria uma instância dele, usando o ativador do sistema.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-141">Locates a type from this assembly and creates an instance of it using the system activator.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public object CreateInstance (string typeName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object CreateInstance(string typeName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.CreateInstance(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateInstance (typeName As String) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ CreateInstance(System::String ^ typeName);" />
      <MemberSignature Language="F#" Value="abstract member CreateInstance : string -&gt; obj&#xA;override this.CreateInstance : string -&gt; obj" Usage="assembly.CreateInstance typeName" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.CreateInstance(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="typeName"><span data-ttu-id="2cf0e-142">O <see cref="P:System.Type.FullName" /> do tipo a se localizar.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-142">The <see cref="P:System.Type.FullName" /> of the type to locate.</span></span></param>
        <summary><span data-ttu-id="2cf0e-143">Localiza o tipo especificado desse assembly e cria uma instância dele usando o ativador de sistema, usando a pesquisa que diferencia maiúsculas de minúsculas.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-143">Locates the specified type from this assembly and creates an instance of it using the system activator, using case-sensitive search.</span></span></summary>
        <returns><span data-ttu-id="2cf0e-144">Uma instância do tipo especificado criada com o construtor padrão; ou <see langword="null" /> se <paramref name="typeName" /> não foi encontrado.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-144">An instance of the specified type created with the default constructor; or <see langword="null" /> if <paramref name="typeName" /> is not found.</span></span> <span data-ttu-id="2cf0e-145">O tipo é resolvido usando o associador padrão, sem especificar atributos de cultura ou de ativação, e com <see cref="T:System.Reflection.BindingFlags" /> definido como <see langword="Public" /> ou <see langword="Instance" />.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-145">The type is resolved using the default binder, without specifying culture or activation attributes, and with <see cref="T:System.Reflection.BindingFlags" /> set to <see langword="Public" /> or <see langword="Instance" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2cf0e-146">Se o tempo de execução não conseguir encontrar `typeName` no <xref:System.Reflection.Assembly> da instância, ele retorna `null` em vez de gerar uma exceção.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-146">If the runtime is unable to find `typeName` in the <xref:System.Reflection.Assembly> instance, it returns `null` instead of throwing an exception.</span></span> <span data-ttu-id="2cf0e-147">Isso pode acontecer porque:</span><span class="sxs-lookup"><span data-stu-id="2cf0e-147">This might happen because:</span></span>  
  
-   <span data-ttu-id="2cf0e-148">Você não especificou o nome totalmente qualificado do tipo.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-148">You haven't specified the fully qualified name of the type.</span></span>  
  
-   <span data-ttu-id="2cf0e-149">Você especificou o nome do tipo totalmente qualificado, mas seu caso de não corresponde ao caso do tipo <xref:System.Type.FullName%2A?displayProperty=nameWithType> propriedade.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-149">You've specified the fully qualified type name, but its case doesn't match the case of the type's <xref:System.Type.FullName%2A?displayProperty=nameWithType> property.</span></span> <span data-ttu-id="2cf0e-150">Para obter uma comparação não diferencia maiusculas de `typeName` com o nome do tipo completo, chamar o <xref:System.Reflection.Assembly.CreateInstance%28System.String%2CSystem.Boolean%29> sobrecarga e especificar `true` para o `ignoreCase` argumento.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-150">For a case-insensitive comparison of `typeName` with the type's full name, call the <xref:System.Reflection.Assembly.CreateInstance%28System.String%2CSystem.Boolean%29> overload and specify `true` for the `ignoreCase` argument.</span></span>  
  
-   <span data-ttu-id="2cf0e-151">O tipo não existe no atual <xref:System.Reflection.Assembly> instância.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-151">The type doesn't exist in the current <xref:System.Reflection.Assembly> instance.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="2cf0e-152">O exemplo a seguir define uma `Person` classe e chama o <xref:System.Reflection.Assembly.CreateInstance%28System.String%29> método instanciá-la.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-152">The following example defines a `Person` class and calls the <xref:System.Reflection.Assembly.CreateInstance%28System.String%29> method to instantiate it.</span></span>  
  
 [!code-csharp[System.Reflection.Assembly.CreateInstance#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.reflection.assembly.createinstance/cs/createinstance1.cs#1)]
 [!code-vb[System.Reflection.Assembly.CreateInstance#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.reflection.assembly.createinstance/vb/createinstance1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="2cf0e-153"><paramref name="typeName" /> é uma cadeia de caracteres vazia ("") ou que começa com um caractere nulo.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-153"><paramref name="typeName" /> is an empty string ("") or a string beginning with a null character.</span></span>  
  
<span data-ttu-id="2cf0e-154">- ou -</span><span class="sxs-lookup"><span data-stu-id="2cf0e-154">-or-</span></span> 
<span data-ttu-id="2cf0e-155">O assembly atual foi carregado no contexto de somente reflexão.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-155">The current assembly was loaded into the reflection-only context.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="2cf0e-156"><paramref name="typeName" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-156"><paramref name="typeName" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.MissingMethodException"><span data-ttu-id="2cf0e-157">Nenhum construtor correspondente foi encontrado.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-157">No matching constructor was found.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="2cf0e-158"><paramref name="typeName" /> exige um assembly dependente que não pôde ser encontrado.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-158"><paramref name="typeName" /> requires a dependent assembly that could not be found.</span></span></exception>
        <exception cref="T:System.IO.FileLoadException"><span data-ttu-id="2cf0e-159"><paramref name="typeName" /> exige um assembly dependente que foi encontrado, mas que não pôde ser carregado.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-159"><paramref name="typeName" /> requires a dependent assembly that was found but could not be loaded.</span></span>  
  
<span data-ttu-id="2cf0e-160">- ou -</span><span class="sxs-lookup"><span data-stu-id="2cf0e-160">-or-</span></span> 
<span data-ttu-id="2cf0e-161">O assembly atual foi carregado no contexto somente reflexão e o <paramref name="typeName" /> exige um assembly dependente que não foi pré-carregado.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-161">The current assembly was loaded into the reflection-only context, and <paramref name="typeName" /> requires a dependent assembly that was not preloaded.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="2cf0e-162"><paramref name="typeName" /> exige um assembly dependente, mas o arquivo não é um assembly válido.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-162"><paramref name="typeName" /> requires a dependent assembly, but the file is not a valid assembly.</span></span>  
  
<span data-ttu-id="2cf0e-163">- ou -</span><span class="sxs-lookup"><span data-stu-id="2cf0e-163">-or-</span></span> 
 <span data-ttu-id="2cf0e-164"><paramref name="typeName" /> requer um assembly dependente compilado para uma versão do tempo de execução que é posterior à versão atualmente carregada.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-164"><paramref name="typeName" /> requires a dependent assembly that was compiled for a version of the runtime that is later than the currently loaded version.</span></span></exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission"><span data-ttu-id="2cf0e-165">quando invocado com associação tardia por meio de mecanismos como <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-165">when invoked late-bound through mechanisms such as <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span></span> <span data-ttu-id="2cf0e-166">Enumeração associada: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span><span class="sxs-lookup"><span data-stu-id="2cf0e-166">Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public object CreateInstance (string typeName, bool ignoreCase);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object CreateInstance(string typeName, bool ignoreCase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.CreateInstance(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateInstance (typeName As String, ignoreCase As Boolean) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ CreateInstance(System::String ^ typeName, bool ignoreCase);" />
      <MemberSignature Language="F#" Value="abstract member CreateInstance : string * bool -&gt; obj&#xA;override this.CreateInstance : string * bool -&gt; obj" Usage="assembly.CreateInstance (typeName, ignoreCase)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.CreateInstance(System.String,System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="ignoreCase" Type="System.Boolean" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="typeName"><span data-ttu-id="2cf0e-167">O <see cref="P:System.Type.FullName" /> do tipo a se localizar.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-167">The <see cref="P:System.Type.FullName" /> of the type to locate.</span></span></param>
        <param name="ignoreCase"><span data-ttu-id="2cf0e-168"><see langword="true" /> para ignorar maiúsculas e minúsculas do nome do tipo; caso contrário, <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-168"><see langword="true" /> to ignore the case of the type name; otherwise, <see langword="false" />.</span></span></param>
        <summary><span data-ttu-id="2cf0e-169">Localiza o tipo especificado desse assembly e cria uma instância dele usando o ativador de sistema, com pesquisa que diferencia maiúsculas de minúsculas opcional.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-169">Locates the specified type from this assembly and creates an instance of it using the system activator, with optional case-sensitive search.</span></span></summary>
        <returns><span data-ttu-id="2cf0e-170">Uma instância do tipo especificado criada com o construtor padrão; ou <see langword="null" /> se <paramref name="typeName" /> não foi encontrado.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-170">An instance of the specified type created with the default constructor; or <see langword="null" /> if <paramref name="typeName" /> is not found.</span></span> <span data-ttu-id="2cf0e-171">O tipo é resolvido usando o associador padrão, sem especificar atributos de cultura ou de ativação, e com <see cref="T:System.Reflection.BindingFlags" /> definido como <see langword="Public" /> ou <see langword="Instance" />.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-171">The type is resolved using the default binder, without specifying culture or activation attributes, and with <see cref="T:System.Reflection.BindingFlags" /> set to <see langword="Public" /> or <see langword="Instance" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2cf0e-172">Se o tempo de execução não conseguir encontrar `typeName` no <xref:System.Reflection.Assembly> da instância, ele retorna `null` em vez de gerar uma exceção.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-172">If the runtime is unable to find `typeName` in the <xref:System.Reflection.Assembly> instance, it returns `null` instead of throwing an exception.</span></span> <span data-ttu-id="2cf0e-173">Isso pode acontecer porque:</span><span class="sxs-lookup"><span data-stu-id="2cf0e-173">This might happen because:</span></span>  
  
-   <span data-ttu-id="2cf0e-174">Você não especificou o nome totalmente qualificado do tipo.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-174">You haven't specified the fully qualified name of the type.</span></span>  
  
-   <span data-ttu-id="2cf0e-175">O tipo não existe no atual <xref:System.Reflection.Assembly> instância.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-175">The type doesn't exist in the current <xref:System.Reflection.Assembly> instance.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="2cf0e-176">O exemplo a seguir define uma `Person` classe.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-176">The following example defines a `Person` class.</span></span> <span data-ttu-id="2cf0e-177">Em seguida, ele chama o <xref:System.Reflection.Assembly.CreateInstance%28System.String%29> método instanciá-la, mas porque as maiusculas e minúsculas da `typeName` argumento não coincide com o tipo <xref:System.Type.FullName%2A> propriedade, o método retorna `null`.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-177">It then calls the <xref:System.Reflection.Assembly.CreateInstance%28System.String%29> method to instantiate it, but because the casing of the `typeName` argument doesn't match that of the type's <xref:System.Type.FullName%2A> property, the method returns `null`.</span></span> <span data-ttu-id="2cf0e-178">Quando o exemplo passa a mesma cadeia de caracteres para o <xref:System.Reflection.Assembly.CreateInstance%28System.String%2CSystem.Boolean%29> sobrecarga e especifica que a comparação deve diferenciar maiusculas de minúsculas, o `Person` classe for encontrado e um `Person` objeto é instanciado com êxito.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-178">When the example passes the same string to the <xref:System.Reflection.Assembly.CreateInstance%28System.String%2CSystem.Boolean%29> overload and specifies that the comparison should be case-insensitive, the `Person` class is found, and a `Person` object is successfully instantiated.</span></span>  
  
 [!code-csharp[System.Reflection.Assembly.CreateInstance#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.reflection.assembly.createinstance/cs/createinstance2.cs#2)]
 [!code-vb[System.Reflection.Assembly.CreateInstance#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.reflection.assembly.createinstance/vb/createinstance2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="2cf0e-179"><paramref name="typeName" /> é uma cadeia de caracteres vazia ("") ou que começa com um caractere nulo.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-179"><paramref name="typeName" /> is an empty string ("") or a string beginning with a null character.</span></span>  
  
<span data-ttu-id="2cf0e-180">- ou -</span><span class="sxs-lookup"><span data-stu-id="2cf0e-180">-or-</span></span> 
<span data-ttu-id="2cf0e-181">O assembly atual foi carregado no contexto de somente reflexão.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-181">The current assembly was loaded into the reflection-only context.</span></span></exception>
        <exception cref="T:System.MissingMethodException"><span data-ttu-id="2cf0e-182">Nenhum construtor correspondente foi encontrado.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-182">No matching constructor was found.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="2cf0e-183"><paramref name="typeName" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-183"><paramref name="typeName" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="2cf0e-184"><paramref name="typeName" /> exige um assembly dependente que não pôde ser encontrado.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-184"><paramref name="typeName" /> requires a dependent assembly that could not be found.</span></span></exception>
        <exception cref="T:System.IO.FileLoadException"><span data-ttu-id="2cf0e-185"><paramref name="typeName" /> exige um assembly dependente que foi encontrado, mas que não pôde ser carregado.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-185"><paramref name="typeName" /> requires a dependent assembly that was found but could not be loaded.</span></span>  
  
<span data-ttu-id="2cf0e-186">- ou -</span><span class="sxs-lookup"><span data-stu-id="2cf0e-186">-or-</span></span> 
<span data-ttu-id="2cf0e-187">O assembly atual foi carregado no contexto somente reflexão e o <paramref name="typeName" /> exige um assembly dependente que não foi pré-carregado.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-187">The current assembly was loaded into the reflection-only context, and <paramref name="typeName" /> requires a dependent assembly that was not preloaded.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="2cf0e-188"><paramref name="typeName" /> exige um assembly dependente, mas o arquivo não é um assembly válido.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-188"><paramref name="typeName" /> requires a dependent assembly, but the file is not a valid assembly.</span></span>  
  
<span data-ttu-id="2cf0e-189">- ou -</span><span class="sxs-lookup"><span data-stu-id="2cf0e-189">-or-</span></span> 
 <span data-ttu-id="2cf0e-190"><paramref name="typeName" /> requer um assembly dependente compilado para uma versão do tempo de execução que é posterior à versão atualmente carregada.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-190"><paramref name="typeName" /> requires a dependent assembly that was compiled for a version of the runtime that is later than the currently loaded version.</span></span></exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission"><span data-ttu-id="2cf0e-191">quando invocado com associação tardia por meio de mecanismos como <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-191">when invoked late-bound through mechanisms such as <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span></span> <span data-ttu-id="2cf0e-192">Enumeração associada: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span><span class="sxs-lookup"><span data-stu-id="2cf0e-192">Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public virtual object CreateInstance (string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object CreateInstance(string typeName, bool ignoreCase, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, object[] args, class System.Globalization.CultureInfo culture, object[] activationAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.CreateInstance(System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ CreateInstance(System::String ^ typeName, bool ignoreCase, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;System::Object ^&gt; ^ args, System::Globalization::CultureInfo ^ culture, cli::array &lt;System::Object ^&gt; ^ activationAttributes);" />
      <MemberSignature Language="F#" Value="abstract member CreateInstance : string * bool * System.Reflection.BindingFlags * System.Reflection.Binder * obj[] * System.Globalization.CultureInfo * obj[] -&gt; obj&#xA;override this.CreateInstance : string * bool * System.Reflection.BindingFlags * System.Reflection.Binder * obj[] * System.Globalization.CultureInfo * obj[] -&gt; obj" Usage="assembly.CreateInstance (typeName, ignoreCase, bindingAttr, binder, args, culture, activationAttributes)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.CreateInstance(System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="ignoreCase" Type="System.Boolean" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="binder" Type="System.Reflection.Binder" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="args" Type="System.Object[]" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" Index="5" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="activationAttributes" Type="System.Object[]" Index="6" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="typeName"><span data-ttu-id="2cf0e-193">O <see cref="P:System.Type.FullName" /> do tipo a se localizar.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-193">The <see cref="P:System.Type.FullName" /> of the type to locate.</span></span></param>
        <param name="ignoreCase"><span data-ttu-id="2cf0e-194"><see langword="true" /> para ignorar maiúsculas e minúsculas do nome do tipo; caso contrário, <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-194"><see langword="true" /> to ignore the case of the type name; otherwise, <see langword="false" />.</span></span></param>
        <param name="bindingAttr"><span data-ttu-id="2cf0e-195">Um bitmask que afeta a maneira pela qual a pesquisa é realizada.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-195">A bitmask that affects the way in which the search is conducted.</span></span> <span data-ttu-id="2cf0e-196">O valor é uma combinação dos sinalizadores de bit de <see cref="T:System.Reflection.BindingFlags" />.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-196">The value is a combination of bit flags from <see cref="T:System.Reflection.BindingFlags" />.</span></span></param>
        <param name="binder"><span data-ttu-id="2cf0e-197">Um objeto que permite a associação, a coerção de tipos de argumentos, invocação de membros e a recuperação de objetos <see langword="MemberInfo" /> por meio de reflexão.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-197">An object that enables the binding, coercion of argument types, invocation of members, and retrieval of <see langword="MemberInfo" /> objects via reflection.</span></span> <span data-ttu-id="2cf0e-198">Caso <paramref name="binder" /> seja <see langword="null" />, o associador padrão é usado.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-198">If <paramref name="binder" /> is <see langword="null" />, the default binder is used.</span></span></param>
        <param name="args"><span data-ttu-id="2cf0e-199">Uma matriz que contém os argumentos a serem passados ao construtor.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-199">An array that contains the arguments to be passed to the constructor.</span></span> <span data-ttu-id="2cf0e-200">Essa matriz de argumentos deve corresponder em número, ordem e tipo aos parâmetros do construtor a ser invocado.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-200">This array of arguments must match in number, order, and type the parameters of the constructor to be invoked.</span></span> <span data-ttu-id="2cf0e-201">Caso haja preferência por um construtor padrão, <paramref name="args" /> deverá ser uma matriz vazia ou <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-201">If the default constructor is desired, <paramref name="args" /> must be an empty array or <see langword="null" />.</span></span></param>
        <param name="culture"><span data-ttu-id="2cf0e-202">Uma instância de <see langword="CultureInfo" /> usada para determinar a coerção de tipos.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-202">An instance of <see langword="CultureInfo" /> used to govern the coercion of types.</span></span> <span data-ttu-id="2cf0e-203">Se isso for <see langword="null" />, será usado o <see langword="CultureInfo" /> para o thread atual.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-203">If this is <see langword="null" />, the <see langword="CultureInfo" /> for the current thread is used.</span></span> <span data-ttu-id="2cf0e-204">(Isso é necessário para converter um <see langword="String" /> que representa 1000 para um valor <see langword="Double" />, por exemplo, uma vez que 1000 é representado de forma diferente por diferentes culturas.)</span><span class="sxs-lookup"><span data-stu-id="2cf0e-204">(This is necessary to convert a <see langword="String" /> that represents 1000 to a <see langword="Double" /> value, for example, since 1000 is represented differently by different cultures.)</span></span></param>
        <param name="activationAttributes"><span data-ttu-id="2cf0e-205">Uma matriz de um ou mais atributos que podem participar da ativação.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-205">An array of one or more attributes that can participate in activation.</span></span> <span data-ttu-id="2cf0e-206">Normalmente, uma matriz que contém um único objeto <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> que especifica a URL necessária para ativar um objeto remoto.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-206">Typically, an array that contains a single <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> object that specifies the URL that is required to activate a remote object.</span></span>  <span data-ttu-id="2cf0e-207">Esse parâmetro está relacionado a objetos ativados pelo cliente.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-207">This parameter is related to client-activated objects.</span></span> <span data-ttu-id="2cf0e-208">A ativação do cliente é uma tecnologia herdada, mantida para compatibilidade com versões anteriores, mas não é recomendada para novos desenvolvimentos.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-208">Client activation is a legacy technology that is retained for backward compatibility but is not recommended for new development.</span></span> <span data-ttu-id="2cf0e-209">Em vez disso, os aplicativos distribuídos devem usar o Windows Communication Foundation.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-209">Distributed applications should instead use Windows Communication Foundation.</span></span></param>
        <summary><span data-ttu-id="2cf0e-210">Localiza o tipo especificado desse assembly e cria uma instância dele usando o ativador do sistema, com a pesquisa opcional que diferencia maiúsculas de minúsculas e com a cultura especificada, os argumentos e os atributos de associação e ativação.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-210">Locates the specified type from this assembly and creates an instance of it using the system activator, with optional case-sensitive search and having the specified culture, arguments, and binding and activation attributes.</span></span></summary>
        <returns><span data-ttu-id="2cf0e-211">Uma instância do tipo especificado ou <see langword="null" />, se <paramref name="typeName" /> não for encontrado.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-211">An instance of the specified type, or <see langword="null" /> if <paramref name="typeName" /> is not found.</span></span> <span data-ttu-id="2cf0e-212">Os argumentos fornecidos são usados para resolver o tipo e associar o construtor utilizado para criar a instância.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-212">The supplied arguments are used to resolve the type, and to bind the constructor that is used to create the instance.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="2cf0e-213"><paramref name="typeName" /> é uma cadeia de caracteres vazia ("") ou que começa com um caractere nulo.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-213"><paramref name="typeName" /> is an empty string ("") or a string beginning with a null character.</span></span>  
  
<span data-ttu-id="2cf0e-214">- ou -</span><span class="sxs-lookup"><span data-stu-id="2cf0e-214">-or-</span></span> 
<span data-ttu-id="2cf0e-215">O assembly atual foi carregado no contexto de somente reflexão.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-215">The current assembly was loaded into the reflection-only context.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="2cf0e-216"><paramref name="typeName" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-216"><paramref name="typeName" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.MissingMethodException"><span data-ttu-id="2cf0e-217">Nenhum construtor correspondente foi encontrado.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-217">No matching constructor was found.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="2cf0e-218">Uma matriz de atributos de ativação não vazia é passada a um tipo que não herda de <see cref="T:System.MarshalByRefObject" />.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-218">A non-empty activation attributes array is passed to a type that does not inherit from <see cref="T:System.MarshalByRefObject" />.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="2cf0e-219"><paramref name="typeName" /> requer um assembly dependente que não pôde ser encontrado.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-219"><paramref name="typeName" /> requires a dependent assembly that could not be found.</span></span></exception>
        <exception cref="T:System.IO.FileLoadException"><span data-ttu-id="2cf0e-220"><paramref name="typeName" /> exige um assembly dependente que foi encontrado, mas que não pôde ser carregado.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-220"><paramref name="typeName" /> requires a dependent assembly that was found but could not be loaded.</span></span>  
  
<span data-ttu-id="2cf0e-221">- ou -</span><span class="sxs-lookup"><span data-stu-id="2cf0e-221">-or-</span></span> 
<span data-ttu-id="2cf0e-222">O assembly atual foi carregado no contexto somente reflexão e o <paramref name="typeName" /> exige um assembly dependente que não foi pré-carregado.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-222">The current assembly was loaded into the reflection-only context, and <paramref name="typeName" /> requires a dependent assembly that was not preloaded.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="2cf0e-223"><paramref name="typeName" /> exige um assembly dependente, mas o arquivo não é um assembly válido.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-223"><paramref name="typeName" /> requires a dependent assembly, but the file is not a valid assembly.</span></span>  
  
<span data-ttu-id="2cf0e-224">- ou -</span><span class="sxs-lookup"><span data-stu-id="2cf0e-224">-or-</span></span> 
 <span data-ttu-id="2cf0e-225"><paramref name="typeName" /> requer um assembly dependente compilado para uma versão do tempo de execução posterior à versão carregada.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-225"><paramref name="typeName" /> requires a dependent assembly which that was compiled for a version of the runtime that is later than the currently loaded version.</span></span></exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission"><span data-ttu-id="2cf0e-226">quando invocado com associação tardia por meio de mecanismos como <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-226">when invoked late-bound through mechanisms such as <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span></span> <span data-ttu-id="2cf0e-227">Enumeração associada: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span><span class="sxs-lookup"><span data-stu-id="2cf0e-227">Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span></span></permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="2cf0e-228">para criar uma instância de um delegado.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-228">to create an instance of a delegate.</span></span> <span data-ttu-id="2cf0e-229">Enumeração associada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></span><span class="sxs-lookup"><span data-stu-id="2cf0e-229">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="CreateQualifiedName">
      <MemberSignature Language="C#" Value="public static string CreateQualifiedName (string assemblyName, string typeName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string CreateQualifiedName(string assemblyName, string typeName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.CreateQualifiedName(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateQualifiedName (assemblyName As String, typeName As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ CreateQualifiedName(System::String ^ assemblyName, System::String ^ typeName);" />
      <MemberSignature Language="F#" Value="static member CreateQualifiedName : string * string -&gt; string" Usage="System.Reflection.Assembly.CreateQualifiedName (assemblyName, typeName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="typeName" Type="System.String" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="assemblyName"><span data-ttu-id="2cf0e-230">O nome de exibição de um assembly.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-230">The display name of an assembly.</span></span></param>
        <param name="typeName"><span data-ttu-id="2cf0e-231">O nome completo de um tipo.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-231">The full name of a type.</span></span></param>
        <summary><span data-ttu-id="2cf0e-232">Cria o nome de um tipo, qualificado pelo nome de exibição do seu assembly.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-232">Creates the name of a type qualified by the display name of its assembly.</span></span></summary>
        <returns><span data-ttu-id="2cf0e-233">O nome completo do tipo, qualificado pelo nome de exibição do assembly.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-233">The full name of the type qualified by the display name of the assembly.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2cf0e-234">O formato da cadeia de caracteres retornada é:</span><span class="sxs-lookup"><span data-stu-id="2cf0e-234">The format of the returned string is:</span></span>  
  
 <span data-ttu-id="2cf0e-235">\<FullTypeName>, \<AssemblyDisplayName></span><span class="sxs-lookup"><span data-stu-id="2cf0e-235">\<FullTypeName>, \<AssemblyDisplayName></span></span>  
  
 <span data-ttu-id="2cf0e-236">Consulte <xref:System.Reflection.AssemblyName> para obter uma descrição do formato do nome para exibição de um assembly.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-236">See <xref:System.Reflection.AssemblyName> for a description of the format of the display name of an assembly.</span></span>  
  
 <span data-ttu-id="2cf0e-237">Para acomodar as alterações em versões do common language runtime, use esse método em vez de construir o nome qualificado por conta própria.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-237">To accommodate changes in versions of the common language runtime, use this method rather than constructing the qualified name yourself.</span></span>  <span data-ttu-id="2cf0e-238">Para obter informações sobre nomes de assembly qualificado, consulte <xref:System.Type.AssemblyQualifiedName%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-238">For information about qualified assembly names, see <xref:System.Type.AssemblyQualifiedName%2A?displayProperty=nameWithType>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CustomAttributes">
      <MemberSignature Language="C#" Value="public virtual System.Collections.Generic.IEnumerable&lt;System.Reflection.CustomAttributeData&gt; CustomAttributes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IEnumerable`1&lt;class System.Reflection.CustomAttributeData&gt; CustomAttributes" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.CustomAttributes" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property CustomAttributes As IEnumerable(Of CustomAttributeData)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Collections::Generic::IEnumerable&lt;System::Reflection::CustomAttributeData ^&gt; ^ CustomAttributes { System::Collections::Generic::IEnumerable&lt;System::Reflection::CustomAttributeData ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.CustomAttributes : seq&lt;System.Reflection.CustomAttributeData&gt;" Usage="System.Reflection.Assembly.CustomAttributes" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Reflection.CustomAttributeData&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="2cf0e-239">Obtém uma coleção que contém os atributos personalizados deste assembly.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-239">Gets a collection that contains this assembly's custom attributes.</span></span></summary>
        <value><span data-ttu-id="2cf0e-240">Uma coleção que contém os atributos personalizados deste assembly.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-240">A collection that contains this assembly's custom attributes.</span></span></value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DefinedTypes">
      <MemberSignature Language="C#" Value="public virtual System.Collections.Generic.IEnumerable&lt;System.Reflection.TypeInfo&gt; DefinedTypes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IEnumerable`1&lt;class System.Reflection.TypeInfo&gt; DefinedTypes" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.DefinedTypes" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property DefinedTypes As IEnumerable(Of TypeInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Collections::Generic::IEnumerable&lt;System::Reflection::TypeInfo ^&gt; ^ DefinedTypes { System::Collections::Generic::IEnumerable&lt;System::Reflection::TypeInfo ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DefinedTypes : seq&lt;System.Reflection.TypeInfo&gt;" Usage="System.Reflection.Assembly.DefinedTypes" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Reflection.TypeInfo&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="2cf0e-241">Obtém uma coleção dos tipos definidos nesse assembly.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-241">Gets a collection of the types defined in this assembly.</span></span></summary>
        <value><span data-ttu-id="2cf0e-242">Uma coleção dos tipos definidos neste assembly.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-242">A collection of the types defined in this assembly.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2cf0e-243">O <xref:System.Reflection.Assembly.DefinedTypes%2A> propriedade é comparável de <xref:System.Reflection.Assembly.GetTypes%2A?displayProperty=nameWithType> método, exceto que o <xref:System.Reflection.Assembly.DefinedTypes%2A> propriedade retorna uma coleção de <xref:System.Reflection.TypeInfo> objetos e o <xref:System.Reflection.Assembly.GetTypes%2A?displayProperty=nameWithType> método retorna uma matriz de <xref:System.Type> objetos.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-243">The <xref:System.Reflection.Assembly.DefinedTypes%2A> property is comparable to the <xref:System.Reflection.Assembly.GetTypes%2A?displayProperty=nameWithType> method, except that the <xref:System.Reflection.Assembly.DefinedTypes%2A> property returns a collection of <xref:System.Reflection.TypeInfo> objects, and the <xref:System.Reflection.Assembly.GetTypes%2A?displayProperty=nameWithType> method returns an array of <xref:System.Type> objects.</span></span>  
  
 <span data-ttu-id="2cf0e-244">A matriz retornada inclui tipos aninhados.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-244">The returned array includes nested types.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Reflection.Assembly.GetTypes" />
      </Docs>
    </Member>
    <Member MemberName="EntryPoint">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.MethodInfo EntryPoint { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.MethodInfo EntryPoint" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.EntryPoint" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property EntryPoint As MethodInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::MethodInfo ^ EntryPoint { System::Reflection::MethodInfo ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.EntryPoint : System.Reflection.MethodInfo" Usage="System.Reflection.Assembly.EntryPoint" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Assembly.EntryPoint</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="2cf0e-245">Obtém o ponto de entrada desse assembly.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-245">Gets the entry point of this assembly.</span></span></summary>
        <value><span data-ttu-id="2cf0e-246">Um objeto que representa o ponto de entrada desse assembly.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-246">An object that represents the entry point of this assembly.</span></span> <span data-ttu-id="2cf0e-247">Se nenhum ponto de entrada for encontrado (por exemplo, se o assembly for uma DLL), <see langword="null" /> será retornado.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-247">If no entry point is found (for example, the assembly is a DLL), <see langword="null" /> is returned.</span></span></value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object o);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object o) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (o As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ o);" />
      <MemberSignature Language="F#" Value="override this.Equals : obj -&gt; bool" Usage="assembly.Equals o" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.Equals(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="o" Type="System.Object" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="o"><span data-ttu-id="2cf0e-248">O objeto a ser comparado com essa instância.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-248">The object to compare with this instance.</span></span></param>
        <summary><span data-ttu-id="2cf0e-249">Determina se este assembly e o objeto especificado são iguais.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-249">Determines whether this assembly and the specified object are equal.</span></span></summary>
        <returns><span data-ttu-id="2cf0e-250"><see langword="true" /> se <paramref name="o" /> for igual a essa instância; caso contrário, <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-250"><see langword="true" /> if <paramref name="o" /> is equal to this instance; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2cf0e-251">O <xref:System.Reflection.Assembly.Equals%2A> método executa um teste de igualdade de referência determinar se a instância atual e `o` são iguais.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-251">The <xref:System.Reflection.Assembly.Equals%2A> method performs a test for reference equality to determine whether the current instance and `o` are equal.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EscapedCodeBase">
      <MemberSignature Language="C#" Value="public virtual string EscapedCodeBase { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string EscapedCodeBase" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.EscapedCodeBase" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property EscapedCodeBase As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ EscapedCodeBase { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.EscapedCodeBase : string" Usage="System.Reflection.Assembly.EscapedCodeBase" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Assembly.EscapedCodeBase</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="2cf0e-252">Obtém o URI, incluindo caracteres de escape, que representa a base de código.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-252">Gets the URI, including escape characters, that represents the codebase.</span></span></summary>
        <value><span data-ttu-id="2cf0e-253">Um URI com caracteres de escape.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-253">A URI with escape characters.</span></span></value>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.Permissions.FileIOPermission"><span data-ttu-id="2cf0e-254">para acesso ao caminho.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-254">for access to the path.</span></span> <span data-ttu-id="2cf0e-255">Enumeração associada: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></span><span class="sxs-lookup"><span data-stu-id="2cf0e-255">Associated enumeration: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="Evidence">
      <MemberSignature Language="C#" Value="public virtual System.Security.Policy.Evidence Evidence { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.Policy.Evidence Evidence" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.Evidence" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property Evidence As Evidence" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Security::Policy::Evidence ^ Evidence { System::Security::Policy::Evidence ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Evidence : System.Security.Policy.Evidence" Usage="System.Reflection.Assembly.Evidence" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Assembly.Evidence</InterfaceMember>
        <InterfaceMember>P:System.Security.IEvidenceFactory.Evidence</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Policy.Evidence</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="2cf0e-256">Obtém a evidência para esse assembly.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-256">Gets the evidence for this assembly.</span></span></summary>
        <value><span data-ttu-id="2cf0e-257">A evidência para esse assembly.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-257">The evidence for this assembly.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2cf0e-258">Evidência é o conjunto de informações que constitui a entrada para decisões de política de segurança, como quais permissões podem ser concedidas ao código.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-258">Evidence is the set of information that constitutes input to security policy decisions, such as what permissions can be granted to code.</span></span>  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="2cf0e-259">para carregar um assembly com evidências.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-259">to load an assembly with evidence.</span></span> <span data-ttu-id="2cf0e-260">Enumeração associada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></span><span class="sxs-lookup"><span data-stu-id="2cf0e-260">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></span></span></permission>
        <altmember cref="T:System.Security.Policy.Evidence" />
      </Docs>
    </Member>
    <Member MemberName="ExportedTypes">
      <MemberSignature Language="C#" Value="public virtual System.Collections.Generic.IEnumerable&lt;Type&gt; ExportedTypes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IEnumerable`1&lt;class System.Type&gt; ExportedTypes" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.ExportedTypes" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property ExportedTypes As IEnumerable(Of Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Collections::Generic::IEnumerable&lt;Type ^&gt; ^ ExportedTypes { System::Collections::Generic::IEnumerable&lt;Type ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ExportedTypes : seq&lt;Type&gt;" Usage="System.Reflection.Assembly.ExportedTypes" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Type&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="2cf0e-261">Obtém uma coleção dos tipos públicos definidos nesse assembly visíveis fora do assembly.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-261">Gets a collection of the public types defined in this assembly that are visible outside the assembly.</span></span></summary>
        <value><span data-ttu-id="2cf0e-262">Uma coleção dos tipos públicos definidos nesse assembly visíveis fora do assembly.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-262">A collection of the public types defined in this assembly that are visible outside the assembly.</span></span></value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FullName">
      <MemberSignature Language="C#" Value="public virtual string FullName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string FullName" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.FullName" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property FullName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ FullName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.FullName : string" Usage="System.Reflection.Assembly.FullName" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Assembly.FullName</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="2cf0e-263">Obtém o nome de exibição do assembly.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-263">Gets the display name of the assembly.</span></span></summary>
        <value><span data-ttu-id="2cf0e-264">O nome para exibição do assembly.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-264">The display name of the assembly.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2cf0e-265">Consulte <xref:System.Reflection.AssemblyName> para obter uma descrição do formato do nome para exibição de um assembly.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-265">See <xref:System.Reflection.AssemblyName> for a description of the format of the display name of an assembly.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="2cf0e-266">Não é recomendável escrever seu próprio código para analisar nomes de exibição.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-266">Writing your own code to parse display names is not recommended.</span></span> <span data-ttu-id="2cf0e-267">Em vez disso, passe o nome de exibição para o <xref:System.Reflection.AssemblyName.%23ctor%2A> construtor, que analisa-lo e preenche os campos apropriados do novo <xref:System.Reflection.AssemblyName>.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-267">Instead, pass the display name to the <xref:System.Reflection.AssemblyName.%23ctor%2A> constructor, which parses it and populates the appropriate fields of the new <xref:System.Reflection.AssemblyName>.</span></span>  
  
 <span data-ttu-id="2cf0e-268">No .NET Framework versão 2.0, a arquitetura do processador é adicionada à identidade do assembly e pode ser especificada como parte das cadeias de caracteres de nome do assembly.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-268">In the .NET Framework version 2.0, processor architecture is added to assembly identity, and can be specified as part of assembly name strings.</span></span> <span data-ttu-id="2cf0e-269">No entanto, ele não está incluído na cadeia de caracteres retornada pela propriedade <xref:System.Reflection.Assembly.FullName%2A>, por motivos de compatibilidade.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-269">However, it is not included in the string returned by the <xref:System.Reflection.Assembly.FullName%2A> property, for compatibility reasons.</span></span> <span data-ttu-id="2cf0e-270">Consulte <xref:System.Reflection.AssemblyName.ProcessorArchitecture%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-270">See <xref:System.Reflection.AssemblyName.ProcessorArchitecture%2A?displayProperty=nameWithType>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="2cf0e-271">O exemplo a seguir recupera o nome de exibição do assembly em execução no momento e o nome de exibição do assembly que contém o <xref:System.Int32> tipo (`int` em c#, `Integer` no Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="2cf0e-271">The following example retrieves the display name of the currently executing assembly, and the display name of the assembly that contains the <xref:System.Int32> type (`int` in C#, `Integer` in Visual Basic).</span></span>  
  
 [!code-cpp[Assembly.FullName#1](~/samples/snippets/cpp/VS_Snippets_CLR/Assembly.FullName/CPP/Example.cpp#1)]
 [!code-csharp[Assembly.FullName#1](~/samples/snippets/csharp/VS_Snippets_CLR/Assembly.FullName/CS/Example.cs#1)]
 [!code-vb[Assembly.FullName#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Assembly.FullName/VB/Example.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/specifying-fully-qualified-type-names.md"><span data-ttu-id="2cf0e-272">Especificando nomes de tipo totalmente qualificados</span><span class="sxs-lookup"><span data-stu-id="2cf0e-272">Specifying Fully Qualified Type Names</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="GetAssembly">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly GetAssembly (Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly GetAssembly(class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetAssembly(System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ GetAssembly(Type ^ type);" />
      <MemberSignature Language="F#" Value="static member GetAssembly : Type -&gt; System.Reflection.Assembly" Usage="System.Reflection.Assembly.GetAssembly type" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="type"><span data-ttu-id="2cf0e-273">Um objeto que representa um tipo no assembly que será retornado.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-273">An object representing a type in the assembly that will be returned.</span></span></param>
        <summary><span data-ttu-id="2cf0e-274">Obtém o assembly carregado no momento em que o tipo especificado é definido.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-274">Gets the currently loaded assembly in which the specified type is defined.</span></span></summary>
        <returns><span data-ttu-id="2cf0e-275">O assembly no qual o tipo especificado é definido.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-275">The assembly in which the specified type is defined.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2cf0e-276">Chamar esse método é equivalente a recuperar o valor da <xref:System.Type.Assembly?displayProperty=nameWithType> propriedade.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-276">Calling this method is equivalent to retrieving the value of the  <xref:System.Type.Assembly?displayProperty=nameWithType> property.</span></span> <span data-ttu-id="2cf0e-277">No entanto, o <xref:System.Type.Assembly?displayProperty=nameWithType> propriedade normalmente oferece desempenho superior.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-277">However, the <xref:System.Type.Assembly?displayProperty=nameWithType> property typically offers superior performance.</span></span>  
  
 <span data-ttu-id="2cf0e-278">Para chamar esse método, você deve ter um <xref:System.Type> objeto, o que significa que o assembly no qual a classe é definida já deve ser carregado.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-278">In order to call this method, you must have a <xref:System.Type> object, which means that the assembly in which the class is defined must already be loaded.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="2cf0e-279">O exemplo a seguir recupera o assembly que contém o <xref:System.Int32> digite e exibe seu nome e o arquivo local.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-279">The following example retrieves the assembly that contains the <xref:System.Int32> type and displays its name and file location.</span></span>  
  
 [!code-cpp[System.Reflection.Assembly#12](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Assembly/CPP/GetAssembly1.cpp#12)]
 [!code-csharp[System.Reflection.Assembly#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Assembly/CS/GetAssembly1.cs#12)]
 [!code-vb[System.Reflection.Assembly#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Assembly/VB/GetAssembly1.vb#12)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="2cf0e-280"><paramref name="type" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-280"><paramref name="type" /> is <see langword="null" />.</span></span></exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission"><span data-ttu-id="2cf0e-281">quando invocado com associação tardia por meio de mecanismos como <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-281">when invoked late-bound through mechanisms such as <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span></span> <span data-ttu-id="2cf0e-282">Enumeração associada: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span><span class="sxs-lookup"><span data-stu-id="2cf0e-282">Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="GetCallingAssembly">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly GetCallingAssembly ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly GetCallingAssembly() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetCallingAssembly" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetCallingAssembly () As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ GetCallingAssembly();" />
      <MemberSignature Language="F#" Value="static member GetCallingAssembly : unit -&gt; System.Reflection.Assembly" Usage="System.Reflection.Assembly.GetCallingAssembly " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="2cf0e-283">Retorna o <see cref="T:System.Reflection.Assembly" /> do método que invocou o método atualmente em execução.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-283">Returns the <see cref="T:System.Reflection.Assembly" /> of the method that invoked the currently executing method.</span></span></summary>
        <returns><span data-ttu-id="2cf0e-284">O objeto <see langword="Assembly" /> do método que invocou o método atualmente em execução.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-284">The <see langword="Assembly" /> object of the method that invoked the currently executing method.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2cf0e-285">Se o método que chama o <xref:System.Reflection.Assembly.GetCallingAssembly%2A> método é expandido embutido pelo compilador just-in-time (JIT), ou se seu chamador é expandido embutido, o assembly que é retornado pelo <xref:System.Reflection.Assembly.GetCallingAssembly%2A> podem diferir inesperadamente.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-285">If the method that calls the <xref:System.Reflection.Assembly.GetCallingAssembly%2A> method is expanded inline by the just-in-time (JIT) compiler, or if its caller is expanded inline, the assembly that is returned by <xref:System.Reflection.Assembly.GetCallingAssembly%2A> may differ unexpectedly.</span></span> <span data-ttu-id="2cf0e-286">Por exemplo, considere os seguintes métodos e assemblies:</span><span class="sxs-lookup"><span data-stu-id="2cf0e-286">For example, consider the following methods and assemblies:</span></span>  
  
-   <span data-ttu-id="2cf0e-287">Método `M1` no assembly `A1` chamadas <xref:System.Reflection.Assembly.GetCallingAssembly%2A>.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-287">Method `M1` in assembly `A1` calls <xref:System.Reflection.Assembly.GetCallingAssembly%2A>.</span></span>  
  
-   <span data-ttu-id="2cf0e-288">Método `M2` no assembly `A2` chamadas `M1`.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-288">Method `M2` in assembly `A2` calls `M1`.</span></span>  
  
-   <span data-ttu-id="2cf0e-289">Método `M3` no assembly `A3` chamadas `M2`.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-289">Method `M3` in assembly `A3` calls `M2`.</span></span>  
  
 <span data-ttu-id="2cf0e-290">Quando `M1` não é embutidos <xref:System.Reflection.Assembly.GetCallingAssembly%2A> retorna `A2`.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-290">When `M1` is not inlined, <xref:System.Reflection.Assembly.GetCallingAssembly%2A> returns `A2`.</span></span> <span data-ttu-id="2cf0e-291">Quando `M1` é embutidos <xref:System.Reflection.Assembly.GetCallingAssembly%2A> retorna `A3`.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-291">When `M1` is inlined, <xref:System.Reflection.Assembly.GetCallingAssembly%2A> returns `A3`.</span></span> <span data-ttu-id="2cf0e-292">Da mesma forma, quando `M2` não é embutidos <xref:System.Reflection.Assembly.GetCallingAssembly%2A> retorna `A2`.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-292">Similarly, when `M2` is not inlined, <xref:System.Reflection.Assembly.GetCallingAssembly%2A> returns `A2`.</span></span> <span data-ttu-id="2cf0e-293">Quando `M2` é embutidos <xref:System.Reflection.Assembly.GetCallingAssembly%2A> retorna `A3`.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-293">When `M2` is inlined, <xref:System.Reflection.Assembly.GetCallingAssembly%2A> returns `A3`.</span></span>  
  
 <span data-ttu-id="2cf0e-294">Esse efeito ocorre também quando `M1` é executado como uma chamada tail do `M2`, ou quando `M2` é executado como uma chamada tail do `M3`.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-294">This effect also occurs when `M1` executes as a tail call from `M2`, or when `M2` executes as a tail call from `M3`.</span></span> <span data-ttu-id="2cf0e-295">Você pode impedir que o compilador JIT de inlining o método que chama <xref:System.Reflection.Assembly.GetCallingAssembly%2A>, aplicando o <xref:System.Runtime.CompilerServices.MethodImplAttribute> do atributo com o <xref:System.Runtime.CompilerServices.MethodImplOptions.NoInlining?displayProperty=nameWithType> sinalizador, mas não há nenhum mecanismo semelhante para impedir chamadas tail.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-295">You can prevent the JIT compiler from inlining the method that calls <xref:System.Reflection.Assembly.GetCallingAssembly%2A>, by applying the <xref:System.Runtime.CompilerServices.MethodImplAttribute> attribute with the <xref:System.Runtime.CompilerServices.MethodImplOptions.NoInlining?displayProperty=nameWithType> flag, but there is no similar mechanism for preventing tail calls.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="2cf0e-296">O exemplo a seguir obtém o assembly de chamada do método atual.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-296">The following example gets the calling assembly of the current method.</span></span>  
  
 [!code-cpp[System.Reflection.Assembly#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Assembly/CPP/getcallingassembly1.cpp#4)]
 [!code-csharp[System.Reflection.Assembly#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Assembly/CS/getcallingassembly1.cs#4)]
 [!code-vb[System.Reflection.Assembly#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Assembly/VB/getcallingassembly1.vb#4)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetCustomAttributes">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="2cf0e-297">Obtém os atributos personalizados para esse assembly.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-297">Gets the custom attributes for this assembly.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetCustomAttributes">
      <MemberSignature Language="C#" Value="public virtual object[] GetCustomAttributes (bool inherit);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object[] GetCustomAttributes(bool inherit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetCustomAttributes(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetCustomAttributes (inherit As Boolean) As Object()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Object ^&gt; ^ GetCustomAttributes(bool inherit);" />
      <MemberSignature Language="F#" Value="abstract member GetCustomAttributes : bool -&gt; obj[]&#xA;override this.GetCustomAttributes : bool -&gt; obj[]" Usage="assembly.GetCustomAttributes inherit" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Reflection.ICustomAttributeProvider.GetCustomAttributes(System.Boolean)</InterfaceMember>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetCustomAttributes(System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="inherit" Type="System.Boolean" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="inherit"><span data-ttu-id="2cf0e-298">Este argumento é ignorado para objetos do tipo <see cref="T:System.Reflection.Assembly" />.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-298">This argument is ignored for objects of type <see cref="T:System.Reflection.Assembly" />.</span></span></param>
        <summary><span data-ttu-id="2cf0e-299">Obtém todos os atributos personalizados para esse assembly.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-299">Gets all the custom attributes for this assembly.</span></span></summary>
        <returns><span data-ttu-id="2cf0e-300">Uma matriz que contém os atributos personalizados para este assembly.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-300">An array that contains the custom attributes for this assembly.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2cf0e-301">Esse método implementa correspondente <xref:System.Reflection.ICustomAttributeProvider> método de interface.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-301">This method implements the corresponding <xref:System.Reflection.ICustomAttributeProvider> interface method.</span></span> <span data-ttu-id="2cf0e-302">Portanto, o `inherit` parâmetro deve ser especificado mesmo que ele será ignorado.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-302">Therefore, the `inherit` parameter must be specified even though it is ignored.</span></span>  
  
 <span data-ttu-id="2cf0e-303">Um atributo de pseudo indica os bits dos principais metadados que devem ser definidas quando o atributo estiver presente.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-303">A pseudo-attribute indicates bits of the core metadata that must be set when the attribute is present.</span></span> <span data-ttu-id="2cf0e-304">Ao contrário de um atributo personalizado que estende os metadados para um tipo e é salvo juntamente com o tipo, um atributo de pseudo modifica os metadados para o tipo e, em seguida, será descartado.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-304">Unlike a custom attribute that extends the metadata for a type and is saved along with the type, a pseudo-attribute modifies the metadata for the type and then is discarded.</span></span> <span data-ttu-id="2cf0e-305">Alguns dos bits resultantes não podem ser acessado usando APIs de reflexão existente.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-305">Some of the resulting bits cannot be accessed using existing reflection APIs.</span></span>  
  
 <span data-ttu-id="2cf0e-306">A tabela a seguir resume os diferentes atributos pseudo e os acessadores para os bits que estão disponíveis na reflexão.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-306">The following table summarizes the different pseudo-attributes and the accessors for the bits that are available in reflection.</span></span>  
  
|<span data-ttu-id="2cf0e-307">Atributo pseudo</span><span class="sxs-lookup"><span data-stu-id="2cf0e-307">Pseudo-Attribute</span></span>|<span data-ttu-id="2cf0e-308">Bits de metadados</span><span class="sxs-lookup"><span data-stu-id="2cf0e-308">Metadata Bits</span></span>|<span data-ttu-id="2cf0e-309">Acessador de reflexão</span><span class="sxs-lookup"><span data-stu-id="2cf0e-309">Reflection Accessor</span></span>|  
|-----------------------|-------------------|-------------------------|  
|<span data-ttu-id="2cf0e-310">DllImportAttribute</span><span class="sxs-lookup"><span data-stu-id="2cf0e-310">DllImportAttribute</span></span>|<span data-ttu-id="2cf0e-311">CorPInvokeMap</span><span class="sxs-lookup"><span data-stu-id="2cf0e-311">CorPInvokeMap</span></span><br /><br /> <span data-ttu-id="2cf0e-312">Nome da DLL</span><span class="sxs-lookup"><span data-stu-id="2cf0e-312">DLL name</span></span>|<span data-ttu-id="2cf0e-313">Nenhum acessador PInvokeMap método comum/global para atributos de método.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-313">No accessor for PInvokeMap for ordinary method/global method attributes.</span></span><br /><br /> <span data-ttu-id="2cf0e-314">Nenhum acessador para o nome da DLL.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-314">No accessor for DLL name.</span></span>|  
|<span data-ttu-id="2cf0e-315">GuidAttribute</span><span class="sxs-lookup"><span data-stu-id="2cf0e-315">GuidAttribute</span></span>|<span data-ttu-id="2cf0e-316">Armazenado como um atributo personalizado real.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-316">Stored as a real custom attribute.</span></span>|<span data-ttu-id="2cf0e-317">Acessado como um atributo personalizado real.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-317">Accessed as a real custom attribute.</span></span>|  
|<span data-ttu-id="2cf0e-318">ComImportAttribute</span><span class="sxs-lookup"><span data-stu-id="2cf0e-318">ComImportAttribute</span></span>|<span data-ttu-id="2cf0e-319">CorTypeAttr.tdImport</span><span class="sxs-lookup"><span data-stu-id="2cf0e-319">CorTypeAttr.tdImport</span></span>|<span data-ttu-id="2cf0e-320">Type.Attributes.Import</span><span class="sxs-lookup"><span data-stu-id="2cf0e-320">Type.Attributes.Import</span></span>|  
|<span data-ttu-id="2cf0e-321">SerializableAttribute</span><span class="sxs-lookup"><span data-stu-id="2cf0e-321">SerializableAttribute</span></span>|<span data-ttu-id="2cf0e-322">CorTypeAttr.tdSerializable</span><span class="sxs-lookup"><span data-stu-id="2cf0e-322">CorTypeAttr.tdSerializable</span></span>|<span data-ttu-id="2cf0e-323">Type.Attributes.Serializable</span><span class="sxs-lookup"><span data-stu-id="2cf0e-323">Type.Attributes.Serializable</span></span>|  
|<span data-ttu-id="2cf0e-324">NonSerializedAttribute</span><span class="sxs-lookup"><span data-stu-id="2cf0e-324">NonSerializedAttribute</span></span>|<span data-ttu-id="2cf0e-325">CorFieldAttr.fdNotSerialized</span><span class="sxs-lookup"><span data-stu-id="2cf0e-325">CorFieldAttr.fdNotSerialized</span></span>|<span data-ttu-id="2cf0e-326">FieldInfo.Attributes.NotSerialized</span><span class="sxs-lookup"><span data-stu-id="2cf0e-326">FieldInfo.Attributes.NotSerialized</span></span>|  
|<span data-ttu-id="2cf0e-327">MethodImplAttribute</span><span class="sxs-lookup"><span data-stu-id="2cf0e-327">MethodImplAttribute</span></span>|<span data-ttu-id="2cf0e-328">CorMethodImpl</span><span class="sxs-lookup"><span data-stu-id="2cf0e-328">CorMethodImpl</span></span>|<span data-ttu-id="2cf0e-329">MethodInfo.GetMethodImplementationFlags()</span><span class="sxs-lookup"><span data-stu-id="2cf0e-329">MethodInfo.GetMethodImplementationFlags()</span></span><br /><br /> <span data-ttu-id="2cf0e-330">ConstructorInfo.GetMethodImplementationFlags()</span><span class="sxs-lookup"><span data-stu-id="2cf0e-330">ConstructorInfo.GetMethodImplementationFlags()</span></span>|  
|<span data-ttu-id="2cf0e-331">MarshalAsAttribute</span><span class="sxs-lookup"><span data-stu-id="2cf0e-331">MarshalAsAttribute</span></span>|<span data-ttu-id="2cf0e-332">Vários bits.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-332">Various bits.</span></span>|<span data-ttu-id="2cf0e-333">Nenhum acessador.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-333">No accessor.</span></span>|  
|<span data-ttu-id="2cf0e-334">PreserveSigAttribute</span><span class="sxs-lookup"><span data-stu-id="2cf0e-334">PreserveSigAttribute</span></span>|<span data-ttu-id="2cf0e-335">CorMethodImpl.miOLE</span><span class="sxs-lookup"><span data-stu-id="2cf0e-335">CorMethodImpl.miOLE</span></span>|<span data-ttu-id="2cf0e-336">MethodInfo.GetMethodImplementationFlags().OLE</span><span class="sxs-lookup"><span data-stu-id="2cf0e-336">MethodInfo.GetMethodImplementationFlags().OLE</span></span><br /><br /> <span data-ttu-id="2cf0e-337">ConstructorInfo.GetMethodImplementationFlags().OLE</span><span class="sxs-lookup"><span data-stu-id="2cf0e-337">ConstructorInfo.GetMethodImplementationFlags().OLE</span></span>|  
|<span data-ttu-id="2cf0e-338">InAttribute</span><span class="sxs-lookup"><span data-stu-id="2cf0e-338">InAttribute</span></span>|<span data-ttu-id="2cf0e-339">CorParamAttr.pdIn</span><span class="sxs-lookup"><span data-stu-id="2cf0e-339">CorParamAttr.pdIn</span></span>|<span data-ttu-id="2cf0e-340">ParameterInfo.Attributes.In</span><span class="sxs-lookup"><span data-stu-id="2cf0e-340">ParameterInfo.Attributes.In</span></span>|  
|<span data-ttu-id="2cf0e-341">OutAttribute</span><span class="sxs-lookup"><span data-stu-id="2cf0e-341">OutAttribute</span></span>|<span data-ttu-id="2cf0e-342">CorParamAttr.pdOut</span><span class="sxs-lookup"><span data-stu-id="2cf0e-342">CorParamAttr.pdOut</span></span>|<span data-ttu-id="2cf0e-343">ParameterInfo.Attributes.Out</span><span class="sxs-lookup"><span data-stu-id="2cf0e-343">ParameterInfo.Attributes.Out</span></span>|  
|<span data-ttu-id="2cf0e-344">StructLayoutAttribute</span><span class="sxs-lookup"><span data-stu-id="2cf0e-344">StructLayoutAttribute</span></span>|<span data-ttu-id="2cf0e-345">CorTypeAttr.tdLayoutSequential</span><span class="sxs-lookup"><span data-stu-id="2cf0e-345">CorTypeAttr.tdLayoutSequential</span></span><br /><br /> <span data-ttu-id="2cf0e-346">CorTypeAttr.tdExplicitLayout</span><span class="sxs-lookup"><span data-stu-id="2cf0e-346">CorTypeAttr.tdExplicitLayout</span></span><br /><br /> <span data-ttu-id="2cf0e-347">CorTypeAttr.tdAnsiClass</span><span class="sxs-lookup"><span data-stu-id="2cf0e-347">CorTypeAttr.tdAnsiClass</span></span><br /><br /> <span data-ttu-id="2cf0e-348">CorTypeAttr.tdUnicodeClass</span><span class="sxs-lookup"><span data-stu-id="2cf0e-348">CorTypeAttr.tdUnicodeClass</span></span><br /><br /> <span data-ttu-id="2cf0e-349">CorTypeAttr.tdAutoClass</span><span class="sxs-lookup"><span data-stu-id="2cf0e-349">CorTypeAttr.tdAutoClass</span></span><br /><br /> <span data-ttu-id="2cf0e-350">Empacotamento de classe.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-350">Class packing.</span></span>|<span data-ttu-id="2cf0e-351">Type.Attributes.LayoutSequential</span><span class="sxs-lookup"><span data-stu-id="2cf0e-351">Type.Attributes.LayoutSequential</span></span><br /><br /> <span data-ttu-id="2cf0e-352">Type.Attributes.ExplicitLayout</span><span class="sxs-lookup"><span data-stu-id="2cf0e-352">Type.Attributes.ExplicitLayout</span></span><br /><br /> <span data-ttu-id="2cf0e-353">Type.Attributes.AnsiClass</span><span class="sxs-lookup"><span data-stu-id="2cf0e-353">Type.Attributes.AnsiClass</span></span><br /><br /> <span data-ttu-id="2cf0e-354">Type.Attributes.UnicodeClass</span><span class="sxs-lookup"><span data-stu-id="2cf0e-354">Type.Attributes.UnicodeClass</span></span><br /><br /> <span data-ttu-id="2cf0e-355">Type.Attributes.AutoClass</span><span class="sxs-lookup"><span data-stu-id="2cf0e-355">Type.Attributes.AutoClass</span></span><br /><br /> <span data-ttu-id="2cf0e-356">Nenhum acessador.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-356">No accessor.</span></span>|  
|<span data-ttu-id="2cf0e-357">FieldOffsetAttribute</span><span class="sxs-lookup"><span data-stu-id="2cf0e-357">FieldOffsetAttribute</span></span>|<span data-ttu-id="2cf0e-358">Deslocamento de campo.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-358">Field offset.</span></span>|<span data-ttu-id="2cf0e-359">Nenhum acessador.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-359">No accessor.</span></span>|  
|<span data-ttu-id="2cf0e-360">AssemblyLoadAttribute</span><span class="sxs-lookup"><span data-stu-id="2cf0e-360">AssemblyLoadAttribute</span></span>|<span data-ttu-id="2cf0e-361">CorAssemblyFlags</span><span class="sxs-lookup"><span data-stu-id="2cf0e-361">CorAssemblyFlags</span></span>|<span data-ttu-id="2cf0e-362">Nenhum acessador ou enumerador.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-362">No accessor or enumerator.</span></span>|  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.ReflectionPermission"><span data-ttu-id="2cf0e-363">quando invocado com associação tardia por meio de mecanismos como <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-363">when invoked late-bound through mechanisms such as <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span></span> <span data-ttu-id="2cf0e-364">Enumeração associada: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span><span class="sxs-lookup"><span data-stu-id="2cf0e-364">Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="GetCustomAttributes">
      <MemberSignature Language="C#" Value="public virtual object[] GetCustomAttributes (Type attributeType, bool inherit);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object[] GetCustomAttributes(class System.Type attributeType, bool inherit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetCustomAttributes(System.Type,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetCustomAttributes (attributeType As Type, inherit As Boolean) As Object()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Object ^&gt; ^ GetCustomAttributes(Type ^ attributeType, bool inherit);" />
      <MemberSignature Language="F#" Value="abstract member GetCustomAttributes : Type * bool -&gt; obj[]&#xA;override this.GetCustomAttributes : Type * bool -&gt; obj[]" Usage="assembly.GetCustomAttributes (attributeType, inherit)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Reflection.ICustomAttributeProvider.GetCustomAttributes(System.Type,System.Boolean)</InterfaceMember>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetCustomAttributes(System.Type,System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="attributeType" Type="System.Type" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="inherit" Type="System.Boolean" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="attributeType"><span data-ttu-id="2cf0e-365">O tipo para o qual os atributos personalizados devem ser retornados.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-365">The type for which the custom attributes are to be returned.</span></span></param>
        <param name="inherit"><span data-ttu-id="2cf0e-366">Este argumento é ignorado para objetos do tipo <see cref="T:System.Reflection.Assembly" />.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-366">This argument is ignored for objects of type <see cref="T:System.Reflection.Assembly" />.</span></span></param>
        <summary><span data-ttu-id="2cf0e-367">Obtém os atributos personalizados para esse assembly conforme especificado pelo tipo.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-367">Gets the custom attributes for this assembly as specified by type.</span></span></summary>
        <returns><span data-ttu-id="2cf0e-368">Uma matriz que contém os atributos personalizados para este assembly conforme especificado por <paramref name="attributeType" />.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-368">An array that contains the custom attributes for this assembly as specified by <paramref name="attributeType" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2cf0e-369">Esse método implementa correspondente <xref:System.Reflection.ICustomAttributeProvider> método de interface.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-369">This method implements the corresponding <xref:System.Reflection.ICustomAttributeProvider> interface method.</span></span> <span data-ttu-id="2cf0e-370">Portanto, o `inherit` parâmetro deve ser especificado mesmo que ele será ignorado.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-370">Therefore, the `inherit` parameter must be specified even though it is ignored.</span></span>  
  
 <span data-ttu-id="2cf0e-371">Um atributo de pseudo indica os bits dos principais metadados que devem ser definidas quando o atributo estiver presente.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-371">A pseudo-attribute indicates bits of the core metadata that must be set when the attribute is present.</span></span> <span data-ttu-id="2cf0e-372">Ao contrário de um atributo personalizado que estende os metadados para um tipo e é salvo juntamente com o tipo, um atributo de pseudo modifica os metadados para o tipo e, em seguida, será descartado.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-372">Unlike a custom attribute that extends the metadata for a type and is saved along with the type, a pseudo-attribute modifies the metadata for the type and then is discarded.</span></span> <span data-ttu-id="2cf0e-373">Alguns dos bits resultantes não podem ser acessado usando APIs de reflexão existente.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-373">Some of the resulting bits cannot be accessed using existing reflection APIs.</span></span>  
  
 <span data-ttu-id="2cf0e-374">A tabela a seguir resume os diferentes atributos pseudo e os acessadores para os bits que estão disponíveis na reflexão.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-374">The following table summarizes the different pseudo-attributes and the accessors for the bits that are available in reflection.</span></span>  
  
|<span data-ttu-id="2cf0e-375">Atributo pseudo</span><span class="sxs-lookup"><span data-stu-id="2cf0e-375">Pseudo-Attribute</span></span>|<span data-ttu-id="2cf0e-376">Bits de metadados</span><span class="sxs-lookup"><span data-stu-id="2cf0e-376">Metadata Bits</span></span>|<span data-ttu-id="2cf0e-377">Acessador de reflexão</span><span class="sxs-lookup"><span data-stu-id="2cf0e-377">Reflection Accessor</span></span>|  
|-----------------------|-------------------|-------------------------|  
|<span data-ttu-id="2cf0e-378">DllImportAttribute</span><span class="sxs-lookup"><span data-stu-id="2cf0e-378">DllImportAttribute</span></span>|<span data-ttu-id="2cf0e-379">CorPInvokeMap</span><span class="sxs-lookup"><span data-stu-id="2cf0e-379">CorPInvokeMap</span></span><br /><br /> <span data-ttu-id="2cf0e-380">Nome da DLL</span><span class="sxs-lookup"><span data-stu-id="2cf0e-380">DLL name</span></span>|<span data-ttu-id="2cf0e-381">Nenhum acessador PInvokeMap método comum/global para atributos de método.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-381">No accessor for PInvokeMap for ordinary method/global method attributes.</span></span><br /><br /> <span data-ttu-id="2cf0e-382">Nenhum acessador para o nome da DLL.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-382">No accessor for DLL name.</span></span>|  
|<span data-ttu-id="2cf0e-383">GuidAttribute</span><span class="sxs-lookup"><span data-stu-id="2cf0e-383">GuidAttribute</span></span>|<span data-ttu-id="2cf0e-384">Armazenado como um atributo personalizado real.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-384">Stored as a real custom attribute.</span></span>|<span data-ttu-id="2cf0e-385">Acessado como um atributo personalizado real.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-385">Accessed as a real custom attribute.</span></span>|  
|<span data-ttu-id="2cf0e-386">ComImportAttribute</span><span class="sxs-lookup"><span data-stu-id="2cf0e-386">ComImportAttribute</span></span>|<span data-ttu-id="2cf0e-387">CorTypeAttr.tdImport</span><span class="sxs-lookup"><span data-stu-id="2cf0e-387">CorTypeAttr.tdImport</span></span>|<span data-ttu-id="2cf0e-388">Type.Attributes.Import</span><span class="sxs-lookup"><span data-stu-id="2cf0e-388">Type.Attributes.Import</span></span>|  
|<span data-ttu-id="2cf0e-389">SerializableAttribute</span><span class="sxs-lookup"><span data-stu-id="2cf0e-389">SerializableAttribute</span></span>|<span data-ttu-id="2cf0e-390">CorTypeAttr.tdSerializable</span><span class="sxs-lookup"><span data-stu-id="2cf0e-390">CorTypeAttr.tdSerializable</span></span>|<span data-ttu-id="2cf0e-391">Type.Attributes.Serializable</span><span class="sxs-lookup"><span data-stu-id="2cf0e-391">Type.Attributes.Serializable</span></span>|  
|<span data-ttu-id="2cf0e-392">NonSerializedAttribute</span><span class="sxs-lookup"><span data-stu-id="2cf0e-392">NonSerializedAttribute</span></span>|<span data-ttu-id="2cf0e-393">CorFieldAttr.fdNotSerialized</span><span class="sxs-lookup"><span data-stu-id="2cf0e-393">CorFieldAttr.fdNotSerialized</span></span>|<span data-ttu-id="2cf0e-394">FieldInfo.Attributes.NotSerialized</span><span class="sxs-lookup"><span data-stu-id="2cf0e-394">FieldInfo.Attributes.NotSerialized</span></span>|  
|<span data-ttu-id="2cf0e-395">MethodImplAttribute</span><span class="sxs-lookup"><span data-stu-id="2cf0e-395">MethodImplAttribute</span></span>|<span data-ttu-id="2cf0e-396">CorMethodImpl</span><span class="sxs-lookup"><span data-stu-id="2cf0e-396">CorMethodImpl</span></span>|<span data-ttu-id="2cf0e-397">MethodInfo.GetMethodImplementationFlags()</span><span class="sxs-lookup"><span data-stu-id="2cf0e-397">MethodInfo.GetMethodImplementationFlags()</span></span><br /><br /> <span data-ttu-id="2cf0e-398">ConstructorInfo.GetMethodImplementationFlags()</span><span class="sxs-lookup"><span data-stu-id="2cf0e-398">ConstructorInfo.GetMethodImplementationFlags()</span></span>|  
|<span data-ttu-id="2cf0e-399">MarshalAsAttribute</span><span class="sxs-lookup"><span data-stu-id="2cf0e-399">MarshalAsAttribute</span></span>|<span data-ttu-id="2cf0e-400">Vários bits.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-400">Various bits.</span></span>|<span data-ttu-id="2cf0e-401">Nenhum acessador.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-401">No accessor.</span></span>|  
|<span data-ttu-id="2cf0e-402">PreserveSigAttribute</span><span class="sxs-lookup"><span data-stu-id="2cf0e-402">PreserveSigAttribute</span></span>|<span data-ttu-id="2cf0e-403">CorMethodImpl.miOLE</span><span class="sxs-lookup"><span data-stu-id="2cf0e-403">CorMethodImpl.miOLE</span></span>|<span data-ttu-id="2cf0e-404">MethodInfo.GetMethodImplementationFlags().OLE</span><span class="sxs-lookup"><span data-stu-id="2cf0e-404">MethodInfo.GetMethodImplementationFlags().OLE</span></span><br /><br /> <span data-ttu-id="2cf0e-405">ConstructorInfo.GetMethodImplementationFlags().OLE</span><span class="sxs-lookup"><span data-stu-id="2cf0e-405">ConstructorInfo.GetMethodImplementationFlags().OLE</span></span>|  
|<span data-ttu-id="2cf0e-406">InAttribute</span><span class="sxs-lookup"><span data-stu-id="2cf0e-406">InAttribute</span></span>|<span data-ttu-id="2cf0e-407">CorParamAttr.pdIn</span><span class="sxs-lookup"><span data-stu-id="2cf0e-407">CorParamAttr.pdIn</span></span>|<span data-ttu-id="2cf0e-408">ParameterInfo.Attributes.In</span><span class="sxs-lookup"><span data-stu-id="2cf0e-408">ParameterInfo.Attributes.In</span></span>|  
|<span data-ttu-id="2cf0e-409">OutAttribute</span><span class="sxs-lookup"><span data-stu-id="2cf0e-409">OutAttribute</span></span>|<span data-ttu-id="2cf0e-410">CorParamAttr.pdOut</span><span class="sxs-lookup"><span data-stu-id="2cf0e-410">CorParamAttr.pdOut</span></span>|<span data-ttu-id="2cf0e-411">ParameterInfo.Attributes.Out</span><span class="sxs-lookup"><span data-stu-id="2cf0e-411">ParameterInfo.Attributes.Out</span></span>|  
|<span data-ttu-id="2cf0e-412">StructLayoutAttribute</span><span class="sxs-lookup"><span data-stu-id="2cf0e-412">StructLayoutAttribute</span></span>|<span data-ttu-id="2cf0e-413">CorTypeAttr.tdLayoutSequential</span><span class="sxs-lookup"><span data-stu-id="2cf0e-413">CorTypeAttr.tdLayoutSequential</span></span><br /><br /> <span data-ttu-id="2cf0e-414">CorTypeAttr.tdExplicitLayout</span><span class="sxs-lookup"><span data-stu-id="2cf0e-414">CorTypeAttr.tdExplicitLayout</span></span><br /><br /> <span data-ttu-id="2cf0e-415">CorTypeAttr.tdAnsiClass</span><span class="sxs-lookup"><span data-stu-id="2cf0e-415">CorTypeAttr.tdAnsiClass</span></span><br /><br /> <span data-ttu-id="2cf0e-416">CorTypeAttr.tdUnicodeClass</span><span class="sxs-lookup"><span data-stu-id="2cf0e-416">CorTypeAttr.tdUnicodeClass</span></span><br /><br /> <span data-ttu-id="2cf0e-417">CorTypeAttr.tdAutoClass</span><span class="sxs-lookup"><span data-stu-id="2cf0e-417">CorTypeAttr.tdAutoClass</span></span><br /><br /> <span data-ttu-id="2cf0e-418">Empacotamento de classe.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-418">Class packing.</span></span>|<span data-ttu-id="2cf0e-419">Type.Attributes.LayoutSequential</span><span class="sxs-lookup"><span data-stu-id="2cf0e-419">Type.Attributes.LayoutSequential</span></span><br /><br /> <span data-ttu-id="2cf0e-420">Type.Attributes.ExplicitLayout</span><span class="sxs-lookup"><span data-stu-id="2cf0e-420">Type.Attributes.ExplicitLayout</span></span><br /><br /> <span data-ttu-id="2cf0e-421">Type.Attributes.AnsiClass</span><span class="sxs-lookup"><span data-stu-id="2cf0e-421">Type.Attributes.AnsiClass</span></span><br /><br /> <span data-ttu-id="2cf0e-422">Type.Attributes.UnicodeClass</span><span class="sxs-lookup"><span data-stu-id="2cf0e-422">Type.Attributes.UnicodeClass</span></span><br /><br /> <span data-ttu-id="2cf0e-423">Type.Attributes.AutoClass</span><span class="sxs-lookup"><span data-stu-id="2cf0e-423">Type.Attributes.AutoClass</span></span><br /><br /> <span data-ttu-id="2cf0e-424">Nenhum acessador.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-424">No accessor.</span></span>|  
|<span data-ttu-id="2cf0e-425">FieldOffsetAttribute</span><span class="sxs-lookup"><span data-stu-id="2cf0e-425">FieldOffsetAttribute</span></span>|<span data-ttu-id="2cf0e-426">Deslocamento de campo.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-426">Field offset.</span></span>|<span data-ttu-id="2cf0e-427">Nenhum acessador.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-427">No accessor.</span></span>|  
|<span data-ttu-id="2cf0e-428">AssemblyLoadAttribute</span><span class="sxs-lookup"><span data-stu-id="2cf0e-428">AssemblyLoadAttribute</span></span>|<span data-ttu-id="2cf0e-429">CorAssemblyFlags</span><span class="sxs-lookup"><span data-stu-id="2cf0e-429">CorAssemblyFlags</span></span>|<span data-ttu-id="2cf0e-430">Nenhum acessador ou enumerador.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-430">No accessor or enumerator.</span></span>|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="2cf0e-431"><paramref name="attributeType" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-431"><paramref name="attributeType" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="2cf0e-432"><paramref name="attributeType" /> não é um tipo de tempo de execução.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-432"><paramref name="attributeType" /> is not a runtime type.</span></span></exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission"><span data-ttu-id="2cf0e-433">quando invocado com associação tardia por meio de mecanismos como <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-433">when invoked late-bound through mechanisms such as <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span></span> <span data-ttu-id="2cf0e-434">Enumeração associada: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span><span class="sxs-lookup"><span data-stu-id="2cf0e-434">Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="GetCustomAttributesData">
      <MemberSignature Language="C#" Value="public virtual System.Collections.Generic.IList&lt;System.Reflection.CustomAttributeData&gt; GetCustomAttributesData ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Generic.IList`1&lt;class System.Reflection.CustomAttributeData&gt; GetCustomAttributesData() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetCustomAttributesData" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetCustomAttributesData () As IList(Of CustomAttributeData)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Collections::Generic::IList&lt;System::Reflection::CustomAttributeData ^&gt; ^ GetCustomAttributesData();" />
      <MemberSignature Language="F#" Value="abstract member GetCustomAttributesData : unit -&gt; System.Collections.Generic.IList&lt;System.Reflection.CustomAttributeData&gt;&#xA;override this.GetCustomAttributesData : unit -&gt; System.Collections.Generic.IList&lt;System.Reflection.CustomAttributeData&gt;" Usage="assembly.GetCustomAttributesData " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IList&lt;System.Reflection.CustomAttributeData&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="2cf0e-435">Retorna informações sobre os atributos que foram aplicados ao <see cref="T:System.Reflection.Assembly" /> atual, expressos como objetos <see cref="T:System.Reflection.CustomAttributeData" />.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-435">Returns information about the attributes that have been applied to the current <see cref="T:System.Reflection.Assembly" />, expressed as <see cref="T:System.Reflection.CustomAttributeData" /> objects.</span></span></summary>
        <returns><span data-ttu-id="2cf0e-436">Uma lista genérica de objetos <see cref="T:System.Reflection.CustomAttributeData" /> que representam dados sobre os atributos que foram aplicados ao assembly atual.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-436">A generic list of <see cref="T:System.Reflection.CustomAttributeData" /> objects representing data about the attributes that have been applied to the current assembly.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2cf0e-437">Use esse método para examinar os atributos personalizados de código no contexto somente reflexão, em casos em que os atributos personalizados em si são definidos no código que é carregado no contexto somente reflexão.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-437">Use this method to examine the custom attributes of code in the reflection-only context, in cases where the custom attributes themselves are defined in code that is loaded into the reflection-only context.</span></span> <span data-ttu-id="2cf0e-438">Métodos como <xref:System.Attribute.GetCustomAttributes%2A?displayProperty=nameWithType> e <xref:System.Reflection.Assembly.GetCustomAttributes%2A?displayProperty=nameWithType> não pode ser usado em tais casos, pois elas criam instâncias dos atributos.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-438">Methods like <xref:System.Attribute.GetCustomAttributes%2A?displayProperty=nameWithType> and <xref:System.Reflection.Assembly.GetCustomAttributes%2A?displayProperty=nameWithType> cannot be used in such cases, because they create instances of the attributes.</span></span> <span data-ttu-id="2cf0e-439">O código no contexto somente reflexão não pode ser executado.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-439">Code in the reflection-only context cannot be executed.</span></span> <span data-ttu-id="2cf0e-440">Para obter mais informações e exemplos de código, consulte o <xref:System.Reflection.CustomAttributeData> classe.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-440">For more information and for example code, see the <xref:System.Reflection.CustomAttributeData> class.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetEntryAssembly">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly GetEntryAssembly ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly GetEntryAssembly() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetEntryAssembly" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetEntryAssembly () As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ GetEntryAssembly();" />
      <MemberSignature Language="F#" Value="static member GetEntryAssembly : unit -&gt; System.Reflection.Assembly" Usage="System.Reflection.Assembly.GetEntryAssembly " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="2cf0e-441">Obtém o processo executável no domínio de aplicativo padrão.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-441">Gets the process executable in the default application domain.</span></span> <span data-ttu-id="2cf0e-442">Em outros domínios de aplicativo, é o primeiro executável que foi executado por <see cref="M:System.AppDomain.ExecuteAssembly(System.String)" />.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-442">In other application domains, this is the first executable that was executed by <see cref="M:System.AppDomain.ExecuteAssembly(System.String)" />.</span></span></summary>
        <returns><span data-ttu-id="2cf0e-443">O assembly é processo executável no domínio de aplicativo padrão ou o primeiro executável que foi executado por <see cref="M:System.AppDomain.ExecuteAssembly(System.String)" />.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-443">The assembly that is the process executable in the default application domain, or the first executable that was executed by <see cref="M:System.AppDomain.ExecuteAssembly(System.String)" />.</span></span> <span data-ttu-id="2cf0e-444">Pode retornar <see langword="null" /> quando chamado do código não gerenciado.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-444">Can return <see langword="null" /> when called from unmanaged code.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2cf0e-445">O <xref:System.Reflection.Assembly.GetEntryAssembly%2A> método pode retornar `null` quando um assembly gerenciado foi carregado de um aplicativo não gerenciado.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-445">The <xref:System.Reflection.Assembly.GetEntryAssembly%2A> method can return `null` when a managed assembly has been loaded from an unmanaged application.</span></span> <span data-ttu-id="2cf0e-446">Por exemplo, se um aplicativo não gerenciado cria uma instância de um componente COM escrito em c#, uma chamada para o <xref:System.Reflection.Assembly.GetEntryAssembly%2A> método do componente de c# retorna null, porque o ponto de entrada para o processo era o código não gerenciado em vez de um assembly gerenciado.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-446">For example, if an unmanaged application creates an instance of a COM component written in C#, a call to the <xref:System.Reflection.Assembly.GetEntryAssembly%2A> method from the C# component returns null, because the entry point for the process was unmanaged code rather than a managed assembly.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetExecutingAssembly">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly GetExecutingAssembly ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly GetExecutingAssembly() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetExecutingAssembly" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetExecutingAssembly () As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ GetExecutingAssembly();" />
      <MemberSignature Language="F#" Value="static member GetExecutingAssembly : unit -&gt; System.Reflection.Assembly" Usage="System.Reflection.Assembly.GetExecutingAssembly " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="2cf0e-447">Obtém o assembly que contém o código executado no momento.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-447">Gets the assembly that contains the code that is currently executing.</span></span></summary>
        <returns><span data-ttu-id="2cf0e-448">O assembly que contém o código que está sendo executado no momento.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-448">The assembly that contains the code that is currently executing.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2cf0e-449">Por motivos de desempenho, você deve chamar esse método somente quando você não souber em tempo de design assembly que está sendo executado.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-449">For performance reasons, you should call this method only when you do not know at design time what assembly is currently executing.</span></span> <span data-ttu-id="2cf0e-450">A maneira recomendada para recuperar um <xref:System.Reflection.Assembly> objeto que representa o assembly atual é usar o <xref:System.Type.Assembly%2A?displayProperty=nameWithType> propriedade de um tipo encontrado no assembly, como mostra o exemplo a seguir.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-450">The recommended way to retrieve an <xref:System.Reflection.Assembly> object that represents the current assembly is to use the <xref:System.Type.Assembly%2A?displayProperty=nameWithType> property of a type found in the assembly, as the following example illustrates.</span></span>  
  
 [!code-csharp[System.Reflection.Assembly.GetExecutingAssembly#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.reflection.assembly.getexecutingassembly/cs/assembly1.cs#1)]
 [!code-vb[System.Reflection.Assembly.GetExecutingAssembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.reflection.assembly.getexecutingassembly/vb/assembly1.vb#1)]  
  
 <span data-ttu-id="2cf0e-451">Para obter o assembly que contém o método que chamou o código em execução no momento, use <xref:System.Reflection.Assembly.GetCallingAssembly%2A>.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-451">To get the assembly that contains the method that called the currently executing code, use <xref:System.Reflection.Assembly.GetCallingAssembly%2A>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="2cf0e-452">O exemplo a seguir usa o <xref:System.Type.Assembly%2A?displayProperty=nameWithType> propriedade para obter o assembly em execução no momento com base em um tipo contido nesse assembly.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-452">The following example uses the <xref:System.Type.Assembly%2A?displayProperty=nameWithType> property to get the currently executing assembly based on a type contained in that assembly.</span></span> <span data-ttu-id="2cf0e-453">Ele também chama o <xref:System.Reflection.Assembly.GetExecutingAssembly%2A> método para mostrar que ele retorna um <xref:System.Reflection.Assembly> objeto que representa o mesmo assembly.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-453">It also calls the <xref:System.Reflection.Assembly.GetExecutingAssembly%2A> method to show that it returns an <xref:System.Reflection.Assembly> object that represents the same assembly.</span></span>  
  
 [!code-cpp[System.Reflection.Assembly.GetExecutingAssembly#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.reflection.assembly.getexecutingassembly/cpp/getexecutingassembly1.cpp#5)]
 [!code-csharp[System.Reflection.Assembly.GetExecutingAssembly#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.reflection.assembly.getexecutingassembly/cs/getexecutingassembly1.cs#5)]
 [!code-vb[System.Reflection.Assembly.GetExecutingAssembly#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.reflection.assembly.getexecutingassembly/vb/getexecutingassembly1.vb#5)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetExportedTypes">
      <MemberSignature Language="C#" Value="public virtual Type[] GetExportedTypes ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type[] GetExportedTypes() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetExportedTypes" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetExportedTypes () As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;Type ^&gt; ^ GetExportedTypes();" />
      <MemberSignature Language="F#" Value="abstract member GetExportedTypes : unit -&gt; Type[]&#xA;override this.GetExportedTypes : unit -&gt; Type[]" Usage="assembly.GetExportedTypes " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetExportedTypes</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="2cf0e-454">Obtém os tipos públicos definidos nesse assembly que são visíveis fora do assembly.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-454">Gets the public types defined in this assembly that are visible outside the assembly.</span></span></summary>
        <returns><span data-ttu-id="2cf0e-455">Uma matriz que representa os tipos definidos nesse assembly que são visíveis fora do assembly.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-455">An array that represents the types defined in this assembly that are visible outside the assembly.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2cf0e-456">Os únicos tipos visíveis fora de um assembly são os tipos públicos e tipos públicos aninhados dentro de outros tipos de públicos.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-456">The only types visible outside an assembly are public types and public types nested within other public types.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="2cf0e-457">O exemplo de código a seguir define um número de classes com vários níveis de acesso e chamadas <xref:System.Reflection.Assembly.GetExportedTypes%2A> para exibir os que são visíveis de fora do assembly.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-457">The following code sample defines a number of classes with various access levels, and calls <xref:System.Reflection.Assembly.GetExportedTypes%2A> to display the ones that are visible from outside the assembly.</span></span>  
  
 [!code-cpp[Assembly.GetExportedTypes#1](~/samples/snippets/cpp/VS_Snippets_CLR/Assembly.GetExportedTypes/CPP/source.cpp#1)]
 [!code-csharp[Assembly.GetExportedTypes#1](~/samples/snippets/csharp/VS_Snippets_CLR/Assembly.GetExportedTypes/CS/source.cs#1)]
 [!code-vb[Assembly.GetExportedTypes#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Assembly.GetExportedTypes/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="2cf0e-458">O assembly é um assembly dinâmico.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-458">The assembly is a dynamic assembly.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="2cf0e-459">Não é possível carregar um assembly dependente.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-459">Unable to load a dependent assembly.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="GetFile">
      <MemberSignature Language="C#" Value="public virtual System.IO.FileStream GetFile (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IO.FileStream GetFile(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetFile(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetFile (name As String) As FileStream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IO::FileStream ^ GetFile(System::String ^ name);" />
      <MemberSignature Language="F#" Value="abstract member GetFile : string -&gt; System.IO.FileStream&#xA;override this.GetFile : string -&gt; System.IO.FileStream" Usage="assembly.GetFile name" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetFile(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.FileStream</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="2cf0e-460">O nome do arquivo especificado.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-460">The name of the specified file.</span></span> <span data-ttu-id="2cf0e-461">Não inclua o caminho para o arquivo.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-461">Do not include the path to the file.</span></span></param>
        <summary><span data-ttu-id="2cf0e-462">Obtém um <see cref="T:System.IO.FileStream" /> para o arquivo especificado na tabela de arquivo do manifesto desse assembly.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-462">Gets a <see cref="T:System.IO.FileStream" /> for the specified file in the file table of the manifest of this assembly.</span></span></summary>
        <returns><span data-ttu-id="2cf0e-463">Um fluxo que contém o arquivo especificado ou <see langword="null" /> se o arquivo não for encontrado.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-463">A stream that contains the specified file, or <see langword="null" /> if the file is not found.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2cf0e-464">Esse método funciona em ambos os arquivos de recursos públicos e privados.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-464">This method works on both public and private resource files.</span></span>  
  
 <span data-ttu-id="2cf0e-465">O `name` não deve incluir o caminho para o arquivo.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-465">The `name` should not include the path to the file.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.FileLoadException"><span data-ttu-id="2cf0e-466">Não foi possível carregar um arquivo que foi encontrado.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-466">A file that was found could not be loaded.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="2cf0e-467">O parâmetro <paramref name="name" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-467">The <paramref name="name" /> parameter is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="2cf0e-468">O parâmetro <paramref name="name" /> é uma cadeia de caracteres vazia ("").</span><span class="sxs-lookup"><span data-stu-id="2cf0e-468">The <paramref name="name" /> parameter is an empty string ("").</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="2cf0e-469"><paramref name="name" /> não foi encontrado.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-469"><paramref name="name" /> was not found.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="2cf0e-470"><paramref name="name" /> não é um assembly válido.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-470"><paramref name="name" /> is not a valid assembly.</span></span></exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission"><span data-ttu-id="2cf0e-471">para acessar o caminho e para ler o arquivo especificado.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-471">for access to the path and for reading the specified file.</span></span> <span data-ttu-id="2cf0e-472">Enumerações associadas: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /> e <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></span><span class="sxs-lookup"><span data-stu-id="2cf0e-472">Associated enumerations: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /> and <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></span></span></permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetFiles">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="2cf0e-473">Obtém os arquivos na tabela de arquivo de um manifesto do assembly.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-473">Gets the files in the file table of an assembly manifest.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetFiles">
      <MemberSignature Language="C#" Value="public virtual System.IO.FileStream[] GetFiles ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IO.FileStream[] GetFiles() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetFiles" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetFiles () As FileStream()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::IO::FileStream ^&gt; ^ GetFiles();" />
      <MemberSignature Language="F#" Value="abstract member GetFiles : unit -&gt; System.IO.FileStream[]&#xA;override this.GetFiles : unit -&gt; System.IO.FileStream[]" Usage="assembly.GetFiles " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetFiles</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.FileStream[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="2cf0e-474">Obtém os arquivos na tabela de arquivo de um manifesto do assembly.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-474">Gets the files in the file table of an assembly manifest.</span></span></summary>
        <returns><span data-ttu-id="2cf0e-475">Uma matriz de fluxos que contêm os arquivos.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-475">An array of streams that contain the files.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2cf0e-476">Esse método funciona em arquivos de recursos públicos e privados.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-476">This method works on public and private resource files.</span></span>  
  
 <span data-ttu-id="2cf0e-477">Essa sobrecarga é equivalente a chamar o <xref:System.Reflection.Assembly.GetFiles%28System.Boolean%29> sobrecarga e especificando `false`.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-477">This overload is equivalent to calling the <xref:System.Reflection.Assembly.GetFiles%28System.Boolean%29> overload and specifying `false`.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.FileLoadException"><span data-ttu-id="2cf0e-478">Não foi possível carregar um arquivo que foi encontrado.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-478">A file that was found could not be loaded.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="2cf0e-479">Um arquivo não foi encontrado.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-479">A file was not found.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="2cf0e-480">Um arquivo não é um assembly válido.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-480">A file was not a valid assembly.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="GetFiles">
      <MemberSignature Language="C#" Value="public virtual System.IO.FileStream[] GetFiles (bool getResourceModules);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IO.FileStream[] GetFiles(bool getResourceModules) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetFiles(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetFiles (getResourceModules As Boolean) As FileStream()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::IO::FileStream ^&gt; ^ GetFiles(bool getResourceModules);" />
      <MemberSignature Language="F#" Value="abstract member GetFiles : bool -&gt; System.IO.FileStream[]&#xA;override this.GetFiles : bool -&gt; System.IO.FileStream[]" Usage="assembly.GetFiles getResourceModules" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetFiles(System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.FileStream[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="getResourceModules" Type="System.Boolean" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="getResourceModules"><span data-ttu-id="2cf0e-481"><see langword="true" /> para incluir os módulos de recursos; caso contrário, <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-481"><see langword="true" /> to include resource modules; otherwise, <see langword="false" />.</span></span></param>
        <summary><span data-ttu-id="2cf0e-482">Obtém os arquivos na tabela de arquivos de um manifesto do assembly, especificando se deseja-se incluir os módulos de recursos.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-482">Gets the files in the file table of an assembly manifest, specifying whether to include resource modules.</span></span></summary>
        <returns><span data-ttu-id="2cf0e-483">Uma matriz de fluxos que contêm os arquivos.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-483">An array of streams that contain the files.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2cf0e-484">Esse método funciona em arquivos de recursos públicos e privados.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-484">This method works on public and private resource files.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.FileLoadException"><span data-ttu-id="2cf0e-485">Não foi possível carregar um arquivo que foi encontrado.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-485">A file that was found could not be loaded.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="2cf0e-486">Um arquivo não foi encontrado.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-486">A file was not found.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="2cf0e-487">Um arquivo não é um assembly válido.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-487">A file was not a valid assembly.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="GetForwardedTypes">
      <MemberSignature Language="C#" Value="public virtual Type[] GetForwardedTypes ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type[] GetForwardedTypes() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetForwardedTypes" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetForwardedTypes () As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;Type ^&gt; ^ GetForwardedTypes();" />
      <MemberSignature Language="F#" Value="abstract member GetForwardedTypes : unit -&gt; Type[]&#xA;override this.GetForwardedTypes : unit -&gt; Type[]" Usage="assembly.GetForwardedTypes " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="assembly.GetHashCode " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetHashCode</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="2cf0e-488">Retorna o código hash para essa instância.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-488">Returns the hash code for this instance.</span></span></summary>
        <returns><span data-ttu-id="2cf0e-489">Um código de hash do inteiro assinado de 32 bits.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-489">A 32-bit signed integer hash code.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetLoadedModules">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="2cf0e-490">Obtém todos os módulos carregados que fazem parte desse assembly.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-490">Gets all the loaded modules that are part of this assembly.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetLoadedModules">
      <MemberSignature Language="C#" Value="public System.Reflection.Module[] GetLoadedModules ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Module[] GetLoadedModules() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetLoadedModules" />
      <MemberSignature Language="VB.NET" Value="Public Function GetLoadedModules () As Module()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::Module ^&gt; ^ GetLoadedModules();" />
      <MemberSignature Language="F#" Value="abstract member GetLoadedModules : unit -&gt; System.Reflection.Module[]&#xA;override this.GetLoadedModules : unit -&gt; System.Reflection.Module[]" Usage="assembly.GetLoadedModules " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetLoadedModules</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Module[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="2cf0e-491">Obtém todos os módulos carregados que fazem parte desse assembly.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-491">Gets all the loaded modules that are part of this assembly.</span></span></summary>
        <returns><span data-ttu-id="2cf0e-492">Uma matriz de módulos.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-492">An array of modules.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetLoadedModules">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.Module[] GetLoadedModules (bool getResourceModules);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Module[] GetLoadedModules(bool getResourceModules) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetLoadedModules(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetLoadedModules (getResourceModules As Boolean) As Module()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::Module ^&gt; ^ GetLoadedModules(bool getResourceModules);" />
      <MemberSignature Language="F#" Value="abstract member GetLoadedModules : bool -&gt; System.Reflection.Module[]&#xA;override this.GetLoadedModules : bool -&gt; System.Reflection.Module[]" Usage="assembly.GetLoadedModules getResourceModules" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetLoadedModules(System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Module[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="getResourceModules" Type="System.Boolean" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="getResourceModules"><span data-ttu-id="2cf0e-493"><see langword="true" /> para incluir os módulos de recursos; caso contrário, <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-493"><see langword="true" /> to include resource modules; otherwise, <see langword="false" />.</span></span></param>
        <summary><span data-ttu-id="2cf0e-494">Obtém todos os módulos carregados que fazem parte desse assembly, especificando se os módulos de recursos devem ser incluídos.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-494">Gets all the loaded modules that are part of this assembly, specifying whether to include resource modules.</span></span></summary>
        <returns><span data-ttu-id="2cf0e-495">Uma matriz de módulos.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-495">An array of modules.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetManifestResourceInfo">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.ManifestResourceInfo GetManifestResourceInfo (string resourceName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.ManifestResourceInfo GetManifestResourceInfo(string resourceName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetManifestResourceInfo(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetManifestResourceInfo (resourceName As String) As ManifestResourceInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::ManifestResourceInfo ^ GetManifestResourceInfo(System::String ^ resourceName);" />
      <MemberSignature Language="F#" Value="abstract member GetManifestResourceInfo : string -&gt; System.Reflection.ManifestResourceInfo&#xA;override this.GetManifestResourceInfo : string -&gt; System.Reflection.ManifestResourceInfo" Usage="assembly.GetManifestResourceInfo resourceName" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetManifestResourceInfo(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.ManifestResourceInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="resourceName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="resourceName"><span data-ttu-id="2cf0e-496">O nome do recurso, que diferencia maiúsculas de minúsculas.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-496">The case-sensitive name of the resource.</span></span></param>
        <summary><span data-ttu-id="2cf0e-497">Retorna informações sobre como o recurso em questão foi persistido.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-497">Returns information about how the given resource has been persisted.</span></span></summary>
        <returns><span data-ttu-id="2cf0e-498">Um objeto que é populado com informações sobre a topologia do recurso ou <see langword="null" />, se o recurso não for encontrado.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-498">An object that is populated with information about the resource's topology, or <see langword="null" /> if the resource is not found.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2cf0e-499">Informações sobre o recurso é retornado somente se o recurso está visível para o chamador ou o chamador tenha <xref:System.Security.Permissions.ReflectionPermission>.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-499">Resource information is returned only if the resource is visible to the caller, or the caller has <xref:System.Security.Permissions.ReflectionPermission>.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="2cf0e-500"><paramref name="resourceName" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-500"><paramref name="resourceName" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="2cf0e-501">O parâmetro <paramref name="resourceName" /> é uma cadeia de caracteres vazia ("").</span><span class="sxs-lookup"><span data-stu-id="2cf0e-501">The <paramref name="resourceName" /> parameter is an empty string ("").</span></span></exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission"><span data-ttu-id="2cf0e-502">quando invocado com associação tardia por meio de mecanismos como <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-502">when invoked late-bound through mechanisms such as <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span></span> <span data-ttu-id="2cf0e-503">Enumeração associada: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span><span class="sxs-lookup"><span data-stu-id="2cf0e-503">Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span></span></permission>
        <altmember cref="M:System.Reflection.Assembly.GetManifestResourceNames" />
      </Docs>
    </Member>
    <Member MemberName="GetManifestResourceNames">
      <MemberSignature Language="C#" Value="public virtual string[] GetManifestResourceNames ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string[] GetManifestResourceNames() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetManifestResourceNames" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetManifestResourceNames () As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::String ^&gt; ^ GetManifestResourceNames();" />
      <MemberSignature Language="F#" Value="abstract member GetManifestResourceNames : unit -&gt; string[]&#xA;override this.GetManifestResourceNames : unit -&gt; string[]" Usage="assembly.GetManifestResourceNames " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetManifestResourceNames</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="2cf0e-504">Retorna os nomes de todos os recursos nesse assembly.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-504">Returns the names of all the resources in this assembly.</span></span></summary>
        <returns><span data-ttu-id="2cf0e-505">Uma matriz que contém os nomes de todos os recursos.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-505">An array that contains the names of all the resources.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2cf0e-506">Você pode usar o nome de cada recurso na matriz retornada por esse método, da seguinte maneira:</span><span class="sxs-lookup"><span data-stu-id="2cf0e-506">You can use each resource name in the array returned by this method as follows:</span></span>  
  
-   <span data-ttu-id="2cf0e-507">Você pode passar o nome do recurso para o <xref:System.Reflection.Assembly.GetManifestResourceInfo%2A> método para obter informações adicionais sobre o recurso.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-507">You can pass the resource name to the <xref:System.Reflection.Assembly.GetManifestResourceInfo%2A> method to get additional information about the resource.</span></span>  
  
-   <span data-ttu-id="2cf0e-508">Se o nome identifica um arquivo. Resources binários, você pode remover a extensão do arquivo. Resources e passá-lo para o <xref:System.Resources.ResourceManager.%23ctor%28System.String%2CSystem.Reflection.Assembly%29?displayProperty=nameWithType> construtor para instanciar o Gerenciador de recursos.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-508">If the name identifies a binary .resources file, you can remove its .resources file extension and pass it to the <xref:System.Resources.ResourceManager.%23ctor%28System.String%2CSystem.Reflection.Assembly%29?displayProperty=nameWithType> constructor to instantiate the resource manager.</span></span>  
  
-   <span data-ttu-id="2cf0e-509">Você pode passar o nome do recurso para o <xref:System.Reflection.Assembly.GetManifestResourceStream%2A> método para recuperar uma <xref:System.IO.Stream> objeto, em seguida, você pode passar para o <xref:System.Resources.ResourceReader.%23ctor%28System.IO.Stream%29?displayProperty=nameWithType> construtor.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-509">You can pass the resource name to the <xref:System.Reflection.Assembly.GetManifestResourceStream%2A> method to retrieve a <xref:System.IO.Stream> object that you can then pass to the <xref:System.Resources.ResourceReader.%23ctor%28System.IO.Stream%29?displayProperty=nameWithType> constructor.</span></span>  
  
-   <span data-ttu-id="2cf0e-510">Você pode passar o nome do recurso para o <xref:System.Reflection.Assembly.GetManifestResourceStream%2A> método para recuperar uma <xref:System.IO.Stream> objeto, em seguida, você pode passar para o <xref:System.Resources.ResourceSet.%23ctor%28System.IO.Stream%29?displayProperty=nameWithType> construtor.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-510">You can pass the resource name to the <xref:System.Reflection.Assembly.GetManifestResourceStream%2A> method to retrieve a <xref:System.IO.Stream> object that you can then pass to the <xref:System.Resources.ResourceSet.%23ctor%28System.IO.Stream%29?displayProperty=nameWithType> constructor.</span></span>  
  
 <span data-ttu-id="2cf0e-511">Informações sobre o recurso é retornado somente se o recurso está visível para o chamador ou o chamador tenha <xref:System.Security.Permissions.ReflectionPermission>.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-511">Resource information is returned only if the resource is visible to the caller, or the caller has <xref:System.Security.Permissions.ReflectionPermission>.</span></span>  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.ReflectionPermission"><span data-ttu-id="2cf0e-512">quando invocado com associação tardia por meio de mecanismos como <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-512">when invoked late-bound through mechanisms such as <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span></span> <span data-ttu-id="2cf0e-513">Enumeração associada: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span><span class="sxs-lookup"><span data-stu-id="2cf0e-513">Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span></span></permission>
        <altmember cref="M:System.Reflection.Assembly.GetManifestResourceStream(System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetManifestResourceStream">
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="2cf0e-514">Carrega o recurso de manifesto especificado desse assembly.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-514">Loads the specified manifest resource from this assembly.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetManifestResourceStream">
      <MemberSignature Language="C#" Value="public virtual System.IO.Stream GetManifestResourceStream (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IO.Stream GetManifestResourceStream(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetManifestResourceStream(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetManifestResourceStream (name As String) As Stream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IO::Stream ^ GetManifestResourceStream(System::String ^ name);" />
      <MemberSignature Language="F#" Value="abstract member GetManifestResourceStream : string -&gt; System.IO.Stream&#xA;override this.GetManifestResourceStream : string -&gt; System.IO.Stream" Usage="assembly.GetManifestResourceStream name" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetManifestResourceStream(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="2cf0e-515">O nome que diferencia maiúsculas de minúsculas do recurso de manifesto solicitado.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-515">The case-sensitive name of the manifest resource being requested.</span></span></param>
        <summary><span data-ttu-id="2cf0e-516">Carrega o recurso de manifesto especificado desse assembly.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-516">Loads the specified manifest resource from this assembly.</span></span></summary>
        <returns><span data-ttu-id="2cf0e-517">O recurso de manifesto; ou <see langword="null" /> se nenhum recurso foi especificado durante a compilação ou se o recurso não é visível para o chamador.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-517">The manifest resource; or <see langword="null" /> if no resources were specified during compilation or if the resource is not visible to the caller.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2cf0e-518">Um recurso de manifesto é um recurso (como um arquivo de imagem) que está incorporado no assembly em tempo de compilação.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-518">A manifest resource is a resource (such as an image file) that is embedded in the assembly at compile time.</span></span> <span data-ttu-id="2cf0e-519">Para obter mais informações sobre os recursos de manifesto, consulte [Noções básicas de recursos do Microsoft .NET Framework](https://go.microsoft.com/fwlink/?LinkId=204554) na biblioteca MSDN.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-519">For more information about manifest resources, see [Microsoft .NET Framework Resource Basics](https://go.microsoft.com/fwlink/?LinkId=204554) in the MSDN Library.</span></span>  
  
 <span data-ttu-id="2cf0e-520">Informações sobre o recurso é retornado somente se o recurso está visível para o chamador ou o chamador tenha <xref:System.Security.Permissions.ReflectionPermission>.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-520">Resource information is returned only if the resource is visible to the caller, or the caller has <xref:System.Security.Permissions.ReflectionPermission>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="2cf0e-521">Esse método retornará `null` se um recurso particular em outro assembly é acessado e o chamador não tem <xref:System.Security.Permissions.ReflectionPermission> com o <xref:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess?displayProperty=nameWithType> sinalizador.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-521">This method returns `null` if a private resource in another assembly is accessed and the caller does not have <xref:System.Security.Permissions.ReflectionPermission> with the <xref:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess?displayProperty=nameWithType> flag.</span></span>  
  
 <span data-ttu-id="2cf0e-522">Se um arquivo de recurso de listar o manifesto do assembly <xref:System.Reflection.Assembly.GetManifestResourceStream%2A> retorna um <xref:System.IO.Stream> objeto mesmo se o arquivo de recurso não pode ser encontrado no disco no momento.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-522">If the assembly manifest lists a resource file, <xref:System.Reflection.Assembly.GetManifestResourceStream%2A> returns a <xref:System.IO.Stream> object even if the resource file cannot be found on disk at the time.</span></span> <span data-ttu-id="2cf0e-523">Se o arquivo de recurso não for encontrado, passando resultante <xref:System.IO.Stream> do objeto para o <xref:System.Resources.ResourceReader> faz com que o construtor um <xref:System.ArgumentException>.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-523">If the resource file is not found, passing the resulting <xref:System.IO.Stream> object to the <xref:System.Resources.ResourceReader> constructor causes an <xref:System.ArgumentException>.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="2cf0e-524">O parâmetro <paramref name="name" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-524">The <paramref name="name" /> parameter is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="2cf0e-525">O parâmetro <paramref name="name" /> é uma cadeia de caracteres vazia ("").</span><span class="sxs-lookup"><span data-stu-id="2cf0e-525">The <paramref name="name" /> parameter is an empty string ("").</span></span></exception>
        <exception cref="T:System.IO.FileLoadException"><block subset="none" type="note">
            <para>  
 <span data-ttu-id="2cf0e-526">Em vez disso, no <see href="https://go.microsoft.com/fwlink/?LinkID=247912">.NET para aplicativos da Windows Store</see> ou na <see href="https://docs.microsoft.com/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library">Biblioteca de Classes Portátil</see>, capture a exceção de classe base, <see cref="T:System.IO.IOException" />.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-526">In the <see href="https://go.microsoft.com/fwlink/?LinkID=247912">.NET for Windows Store apps</see> or the <see href="https://docs.microsoft.com/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library">Portable Class Library</see>, catch the base class exception, <see cref="T:System.IO.IOException" />, instead.</span></span>  
  
</para>
          </block>  
  
 <span data-ttu-id="2cf0e-527">Não foi possível carregar um arquivo que foi encontrado.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-527">A file that was found could not be loaded.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="2cf0e-528"><paramref name="name" /> não foi encontrado.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-528"><paramref name="name" /> was not found.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="2cf0e-529"><paramref name="name" /> não é um assembly válido.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-529"><paramref name="name" /> is not a valid assembly.</span></span></exception>
        <exception cref="T:System.NotImplementedException"><span data-ttu-id="2cf0e-530">O tamanho do recurso é maior que <see cref="F:System.Int64.MaxValue" />.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-530">Resource length is greater than <see cref="F:System.Int64.MaxValue" />.</span></span></exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission"><span data-ttu-id="2cf0e-531">quando invocado com associação tardia por meio de mecanismos como <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-531">when invoked late-bound through mechanisms such as <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span></span> <span data-ttu-id="2cf0e-532">Enumeração associada: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span><span class="sxs-lookup"><span data-stu-id="2cf0e-532">Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span></span></permission>
        <altmember cref="M:System.Reflection.Assembly.GetManifestResourceNames" />
        <related type="Article" href="~/docs/framework/app-domains/assembly-manifest.md"><span data-ttu-id="2cf0e-533">Manifesto de um assembly</span><span class="sxs-lookup"><span data-stu-id="2cf0e-533">Assembly Manifest</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="GetManifestResourceStream">
      <MemberSignature Language="C#" Value="public virtual System.IO.Stream GetManifestResourceStream (Type type, string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IO.Stream GetManifestResourceStream(class System.Type type, string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetManifestResourceStream(System.Type,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IO::Stream ^ GetManifestResourceStream(Type ^ type, System::String ^ name);" />
      <MemberSignature Language="F#" Value="abstract member GetManifestResourceStream : Type * string -&gt; System.IO.Stream&#xA;override this.GetManifestResourceStream : Type * string -&gt; System.IO.Stream" Usage="assembly.GetManifestResourceStream (type, name)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetManifestResourceStream(System.Type,System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="name" Type="System.String" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="type"><span data-ttu-id="2cf0e-534">O tipo cujo namespace é usado para definir o escopo do nome de recurso de manifesto.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-534">The type whose namespace is used to scope the manifest resource name.</span></span></param>
        <param name="name"><span data-ttu-id="2cf0e-535">O nome que diferencia maiúsculas de minúsculas do recurso de manifesto solicitado.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-535">The case-sensitive name of the manifest resource being requested.</span></span></param>
        <summary><span data-ttu-id="2cf0e-536">Carrega o recurso de manifesto especificado, o escopo pelo namespace do tipo especificado, desse assembly.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-536">Loads the specified manifest resource, scoped by the namespace of the specified type, from this assembly.</span></span></summary>
        <returns><span data-ttu-id="2cf0e-537">O recurso de manifesto; ou <see langword="null" /> se nenhum recurso foi especificado durante a compilação ou se o recurso não é visível para o chamador.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-537">The manifest resource; or <see langword="null" /> if no resources were specified during compilation or if the resource is not visible to the caller.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2cf0e-538">Por exemplo, se o nome completo especificado para `type` é "MyNameSpace.MyClasses" e `name` é "Net", este método pesquisa um recurso chamado "MyNameSpace.Net" de sobrecarga.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-538">For example, if the full name specified for `type` is "MyNameSpace.MyClasses" and `name` is "Net", this method overload searches for a resource named "MyNameSpace.Net".</span></span>  
  
 <span data-ttu-id="2cf0e-539">Um recurso de manifesto é um recurso (como um arquivo de imagem) que está incorporado no assembly em tempo de compilação.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-539">A manifest resource is a resource (such as an image file) that is embedded in the assembly at compile time.</span></span> <span data-ttu-id="2cf0e-540">Para obter mais informações sobre os recursos de manifesto, consulte [Noções básicas de recursos do Microsoft .NET Framework](https://go.microsoft.com/fwlink/?LinkId=204554) na biblioteca MSDN.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-540">For more information about manifest resources, see [Microsoft .NET Framework Resource Basics](https://go.microsoft.com/fwlink/?LinkId=204554) in the MSDN Library.</span></span>  
  
 <span data-ttu-id="2cf0e-541">Informações sobre o recurso é retornado somente se o recurso está visível para o chamador ou o chamador tenha <xref:System.Security.Permissions.ReflectionPermission>.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-541">Resource information is returned only if the resource is visible to the caller, or the caller has <xref:System.Security.Permissions.ReflectionPermission>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="2cf0e-542">Esse método retornará `null` se um recurso particular em outro assembly é acessado e o chamador não tem <xref:System.Security.Permissions.ReflectionPermission> com o <xref:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess?displayProperty=nameWithType> sinalizador.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-542">This method returns `null` if a private resource in another assembly is accessed and the caller does not have <xref:System.Security.Permissions.ReflectionPermission> with the <xref:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess?displayProperty=nameWithType> flag.</span></span>  
  
 <span data-ttu-id="2cf0e-543">Se um arquivo de recurso de listar o manifesto do assembly <xref:System.Reflection.Assembly.GetManifestResourceStream%2A> retorna um <xref:System.IO.Stream> objeto mesmo se o arquivo de recurso não pode ser encontrado no disco no momento.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-543">If the assembly manifest lists a resource file, <xref:System.Reflection.Assembly.GetManifestResourceStream%2A> returns a <xref:System.IO.Stream> object even if the resource file cannot be found on disk at the time.</span></span> <span data-ttu-id="2cf0e-544">Se o arquivo de recurso não for encontrado, passando resultante <xref:System.IO.Stream> do objeto para o <xref:System.Resources.ResourceReader> faz com que o construtor um <xref:System.ArgumentException>.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-544">If the resource file is not found, passing the resulting <xref:System.IO.Stream> object to the <xref:System.Resources.ResourceReader> constructor causes an <xref:System.ArgumentException>.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="2cf0e-545">O parâmetro <paramref name="name" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-545">The <paramref name="name" /> parameter is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="2cf0e-546">O parâmetro <paramref name="name" /> é uma cadeia de caracteres vazia ("").</span><span class="sxs-lookup"><span data-stu-id="2cf0e-546">The <paramref name="name" /> parameter is an empty string ("").</span></span></exception>
        <exception cref="T:System.IO.FileLoadException"><span data-ttu-id="2cf0e-547">Não foi possível carregar um arquivo que foi encontrado.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-547">A file that was found could not be loaded.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="2cf0e-548"><paramref name="name" /> não foi encontrado.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-548"><paramref name="name" /> was not found.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="2cf0e-549"><paramref name="name" /> não é um assembly válido.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-549"><paramref name="name" /> is not a valid assembly.</span></span></exception>
        <exception cref="T:System.NotImplementedException"><span data-ttu-id="2cf0e-550">O tamanho do recurso é maior que <see cref="F:System.Int64.MaxValue" />.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-550">Resource length is greater than <see cref="F:System.Int64.MaxValue" />.</span></span></exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission"><span data-ttu-id="2cf0e-551">quando invocado com associação tardia por meio de mecanismos como <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-551">when invoked late-bound through mechanisms such as <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span></span> <span data-ttu-id="2cf0e-552">Enumeração associada: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span><span class="sxs-lookup"><span data-stu-id="2cf0e-552">Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span></span></permission>
        <altmember cref="M:System.Reflection.Assembly.GetManifestResourceNames" />
        <related type="Article" href="~/docs/framework/app-domains/assembly-manifest.md"><span data-ttu-id="2cf0e-553">Manifesto de um assembly</span><span class="sxs-lookup"><span data-stu-id="2cf0e-553">Assembly Manifest</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="GetModule">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.Module GetModule (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Module GetModule(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetModule(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetModule (name As String) As Module" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Module ^ GetModule(System::String ^ name);" />
      <MemberSignature Language="F#" Value="abstract member GetModule : string -&gt; System.Reflection.Module&#xA;override this.GetModule : string -&gt; System.Reflection.Module" Usage="assembly.GetModule name" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetModule(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Module</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="2cf0e-554">O nome do módulo que está sendo solicitado.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-554">The name of the module being requested.</span></span></param>
        <summary><span data-ttu-id="2cf0e-555">Obtém o módulo especificado nesse assembly.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-555">Gets the specified module in this assembly.</span></span></summary>
        <returns><span data-ttu-id="2cf0e-556">O módulo que está sendo solicitado ou <see langword="null" />, se o módulo não tiver sido encontrado.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-556">The module being requested, or <see langword="null" /> if the module is not found.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2cf0e-557">Esse método funciona em nomes de arquivo.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-557">This method works on file names.</span></span>  
  
 <span data-ttu-id="2cf0e-558">As classes de `Reflection.Emit` namespace emitir o nome do escopo para um módulo dinâmico.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-558">Classes in the `Reflection.Emit` namespace emit the scope name for a dynamic module.</span></span> <span data-ttu-id="2cf0e-559">O nome do escopo pode ser determinado pelo <xref:System.Reflection.Module.ScopeName%2A?displayProperty=nameWithType> propriedade.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-559">The scope name can be determined by the <xref:System.Reflection.Module.ScopeName%2A?displayProperty=nameWithType> property.</span></span> <span data-ttu-id="2cf0e-560">Passar o tipo de módulo a ser `Assembly.GetModule`.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-560">Pass the kind of module you want to `Assembly.GetModule`.</span></span> <span data-ttu-id="2cf0e-561">Por exemplo, se você quiser que o módulo que contém o manifesto do assembly, passe o nome do escopo do módulo para `GetModule`.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-561">For example, if you want the module that contains the assembly manifest, pass the scope name of the module to `GetModule`.</span></span> <span data-ttu-id="2cf0e-562">Caso contrário, passe o nome de arquivo do módulo.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-562">Otherwise, pass the file name of the module.</span></span> <span data-ttu-id="2cf0e-563">Os assemblies carregados por um do `Load` métodos que têm um parâmetro do byte [] têm apenas um módulo, e isso é o módulo de manifesto.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-563">Assemblies loaded by one of the `Load` methods that have a byte[] parameter have only one module, and that is the manifest module.</span></span> <span data-ttu-id="2cf0e-564">Esses módulos usando o nome do escopo de busca sempre.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-564">Always seek these modules using the scope name.</span></span>  
  
 <span data-ttu-id="2cf0e-565">Um tipo pode ser recuperado de um módulo específico usando <xref:System.Reflection.Module.GetType%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-565">A type can be retrieved from a specific module using <xref:System.Reflection.Module.GetType%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="2cf0e-566">Chamar `Module.GetType` no módulo que contém o manifesto não iniciará uma pesquisa de todo o assembly.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-566">Calling `Module.GetType` on the module containing the manifest will not initiate a search of the entire assembly.</span></span> <span data-ttu-id="2cf0e-567">Para recuperar um tipo de um assembly, independentemente de qual módulo ele está, você deve chamar <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-567">To retrieve a type from an assembly, regardless of which module it is in, you must call <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType>.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="2cf0e-568">O parâmetro <paramref name="name" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-568">The <paramref name="name" /> parameter is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="2cf0e-569">O parâmetro <paramref name="name" /> é uma cadeia de caracteres vazia ("").</span><span class="sxs-lookup"><span data-stu-id="2cf0e-569">The <paramref name="name" /> parameter is an empty string ("").</span></span></exception>
        <exception cref="T:System.IO.FileLoadException"><span data-ttu-id="2cf0e-570">Não foi possível carregar um arquivo que foi encontrado.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-570">A file that was found could not be loaded.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="2cf0e-571"><paramref name="name" /> não foi encontrado.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-571"><paramref name="name" /> was not found.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="2cf0e-572"><paramref name="name" /> não é um assembly válido.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-572"><paramref name="name" /> is not a valid assembly.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetModules">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="2cf0e-573">Obtém todos os módulos que fazem parte desse assembly.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-573">Gets all the modules that are part of this assembly.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetModules">
      <MemberSignature Language="C#" Value="public System.Reflection.Module[] GetModules ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Module[] GetModules() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetModules" />
      <MemberSignature Language="VB.NET" Value="Public Function GetModules () As Module()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::Module ^&gt; ^ GetModules();" />
      <MemberSignature Language="F#" Value="abstract member GetModules : unit -&gt; System.Reflection.Module[]&#xA;override this.GetModules : unit -&gt; System.Reflection.Module[]" Usage="assembly.GetModules " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetModules</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Module[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="2cf0e-574">Obtém todos os módulos que fazem parte desse assembly.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-574">Gets all the modules that are part of this assembly.</span></span></summary>
        <returns><span data-ttu-id="2cf0e-575">Uma matriz de módulos.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-575">An array of modules.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2cf0e-576">Esse método funciona em arquivos de recursos públicos e privados.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-576">This method works on public and private resource files.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="2cf0e-577">Módulos deverão ser emitidos com extensões de nome de arquivo.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-577">Modules must be emitted with file name extensions.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="2cf0e-578">O exemplo a seguir exibe o nome do módulo na matriz retornada que contém o manifesto do assembly.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-578">The following example displays the name of the module in the returned array that contains the assembly manifest.</span></span>  
  
 [!code-cpp[Classic Assembly.GetModules Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Assembly.GetModules Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Assembly.GetModules Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Assembly.GetModules Example/CS/source.cs#1)]
 [!code-vb[Classic Assembly.GetModules Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Assembly.GetModules Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="2cf0e-579">O módulo a ser carregado não especifica uma extensão de nome de arquivo.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-579">The module to be loaded does not specify a file name extension.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="GetModules">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.Module[] GetModules (bool getResourceModules);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Module[] GetModules(bool getResourceModules) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetModules(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetModules (getResourceModules As Boolean) As Module()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::Module ^&gt; ^ GetModules(bool getResourceModules);" />
      <MemberSignature Language="F#" Value="abstract member GetModules : bool -&gt; System.Reflection.Module[]&#xA;override this.GetModules : bool -&gt; System.Reflection.Module[]" Usage="assembly.GetModules getResourceModules" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetModules(System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Module[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="getResourceModules" Type="System.Boolean" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="getResourceModules"><span data-ttu-id="2cf0e-580"><see langword="true" /> para incluir os módulos de recursos; caso contrário, <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-580"><see langword="true" /> to include resource modules; otherwise, <see langword="false" />.</span></span></param>
        <summary><span data-ttu-id="2cf0e-581">Obtém todos os módulos que fazem parte desse assembly, especificando se os módulos de recursos devem ser incluídos.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-581">Gets all the modules that are part of this assembly, specifying whether to include resource modules.</span></span></summary>
        <returns><span data-ttu-id="2cf0e-582">Uma matriz de módulos.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-582">An array of modules.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2cf0e-583">Esse método funciona em arquivos de recursos públicos e privados.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-583">This method works on public and private resource files.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="2cf0e-584">Módulos deverão ser emitidos com extensões de nome de arquivo.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-584">Modules must be emitted with file name extensions.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetName">
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="2cf0e-585">Obtém um <see cref="T:System.Reflection.AssemblyName" /> para esse assembly.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-585">Gets an <see cref="T:System.Reflection.AssemblyName" /> for this assembly.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetName">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.AssemblyName GetName ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.AssemblyName GetName() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetName" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetName () As AssemblyName" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::AssemblyName ^ GetName();" />
      <MemberSignature Language="F#" Value="abstract member GetName : unit -&gt; System.Reflection.AssemblyName&#xA;override this.GetName : unit -&gt; System.Reflection.AssemblyName" Usage="assembly.GetName " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetName</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.AssemblyName</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="2cf0e-586">Obtém um <see cref="T:System.Reflection.AssemblyName" /> para esse assembly.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-586">Gets an <see cref="T:System.Reflection.AssemblyName" /> for this assembly.</span></span></summary>
        <returns><span data-ttu-id="2cf0e-587">Um objeto que contém o nome de exibição totalmente analisado para esse assembly.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-587">An object that contains the fully parsed display name for this assembly.</span></span></returns>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.Permissions.FileIOPermission"><span data-ttu-id="2cf0e-588">para acessar o caminho do assembly.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-588">for access to the path of the assembly.</span></span> <span data-ttu-id="2cf0e-589">Enumeração associada: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></span><span class="sxs-lookup"><span data-stu-id="2cf0e-589">Associated enumeration: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="GetName">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.AssemblyName GetName (bool copiedName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.AssemblyName GetName(bool copiedName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetName(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetName (copiedName As Boolean) As AssemblyName" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::AssemblyName ^ GetName(bool copiedName);" />
      <MemberSignature Language="F#" Value="abstract member GetName : bool -&gt; System.Reflection.AssemblyName&#xA;override this.GetName : bool -&gt; System.Reflection.AssemblyName" Usage="assembly.GetName copiedName" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetName(System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.AssemblyName</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="copiedName" Type="System.Boolean" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="copiedName"><span data-ttu-id="2cf0e-590"><see langword="true" /> para definir o <see cref="P:System.Reflection.Assembly.CodeBase" /> com o local do assembly depois que tiver sido feita uma cópia de sombra dele; <see langword="false" /> para definir <see cref="P:System.Reflection.Assembly.CodeBase" /> com o local original.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-590"><see langword="true" /> to set the <see cref="P:System.Reflection.Assembly.CodeBase" /> to the location of the assembly after it was shadow copied; <see langword="false" /> to set <see cref="P:System.Reflection.Assembly.CodeBase" /> to the original location.</span></span></param>
        <summary><span data-ttu-id="2cf0e-591">Obtém um <see cref="T:System.Reflection.AssemblyName" /> para esse assembly, definindo a base de código como especificado por <paramref name="copiedName" />.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-591">Gets an <see cref="T:System.Reflection.AssemblyName" /> for this assembly, setting the codebase as specified by <paramref name="copiedName" />.</span></span></summary>
        <returns><span data-ttu-id="2cf0e-592">Um objeto que contém o nome de exibição totalmente analisado para esse assembly.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-592">An object that contains the fully parsed display name for this assembly.</span></span></returns>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.Permissions.FileIOPermission"><span data-ttu-id="2cf0e-593">para acessar o caminho do assembly.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-593">for access to the path of the assembly.</span></span> <span data-ttu-id="2cf0e-594">Enumeração associada: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></span><span class="sxs-lookup"><span data-stu-id="2cf0e-594">Associated enumeration: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="GetObjectData">
      <MemberSignature Language="C#" Value="public virtual void GetObjectData (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void GetObjectData(class System.Runtime.Serialization.SerializationInfo info, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub GetObjectData (info As SerializationInfo, context As StreamingContext)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void GetObjectData(System::Runtime::Serialization::SerializationInfo ^ info, System::Runtime::Serialization::StreamingContext context);" />
      <MemberSignature Language="F#" Value="abstract member GetObjectData : System.Runtime.Serialization.SerializationInfo * System.Runtime.Serialization.StreamingContext -&gt; unit&#xA;override this.GetObjectData : System.Runtime.Serialization.SerializationInfo * System.Runtime.Serialization.StreamingContext -&gt; unit" Usage="assembly.GetObjectData (info, context)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)</InterfaceMember>
        <InterfaceMember>M:System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="info" Type="System.Runtime.Serialization.SerializationInfo" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="info"><span data-ttu-id="2cf0e-595">O objeto a ser populado com informações de serialização.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-595">The object to be populated with serialization information.</span></span></param>
        <param name="context"><span data-ttu-id="2cf0e-596">O contexto de destino da serialização.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-596">The destination context of the serialization.</span></span></param>
        <summary><span data-ttu-id="2cf0e-597">Obtém informações de serialização com todos os dados necessários para recriar uma instância desse assembly.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-597">Gets serialization information with all of the data needed to reinstantiate this assembly.</span></span></summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="2cf0e-598"><paramref name="info" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-598"><paramref name="info" /> is <see langword="null" />.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="2cf0e-599">Requer confiança total para o chamador imediato.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-599">Requires full trust for the immediate caller.</span></span> <span data-ttu-id="2cf0e-600">Este membro não pode ser usado pelo código transparente ou parcialmente confiável.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-600">This member cannot be used by partially trusted or transparent code.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="GetReferencedAssemblies">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.AssemblyName[] GetReferencedAssemblies ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.AssemblyName[] GetReferencedAssemblies() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetReferencedAssemblies" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetReferencedAssemblies () As AssemblyName()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::AssemblyName ^&gt; ^ GetReferencedAssemblies();" />
      <MemberSignature Language="F#" Value="abstract member GetReferencedAssemblies : unit -&gt; System.Reflection.AssemblyName[]&#xA;override this.GetReferencedAssemblies : unit -&gt; System.Reflection.AssemblyName[]" Usage="assembly.GetReferencedAssemblies " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetReferencedAssemblies</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.AssemblyName[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="2cf0e-601">Obtém os objetos <see cref="T:System.Reflection.AssemblyName" /> para todos os assemblies referenciados por esse assembly.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-601">Gets the <see cref="T:System.Reflection.AssemblyName" /> objects for all the assemblies referenced by this assembly.</span></span></summary>
        <returns><span data-ttu-id="2cf0e-602">Uma matriz que contém os nomes de exibição totalmente analisados de todos os assemblies referenciados por esse assembly.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-602">An array that contains the fully parsed display names of all the assemblies referenced by this assembly.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  <span data-ttu-id="2cf0e-603">Começando com o [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], o <xref:System.Reflection.AssemblyName.HashAlgorithm%2A> propriedade de um <xref:System.Reflection.AssemblyName> objeto que é retornado por esse método é <xref:System.Configuration.Assemblies.AssemblyHashAlgorithm.None?displayProperty=nameWithType> se não houver nenhum algoritmo de hash para o assembly referenciado, ou se o algoritmo de hash do assembly referenciado não for identificado pelo <xref:System.Configuration.Assemblies.AssemblyHashAlgorithm?displayProperty=nameWithType> enumeração.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-603">Starting with the [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], the <xref:System.Reflection.AssemblyName.HashAlgorithm%2A> property of an <xref:System.Reflection.AssemblyName> object that is returned by this method is <xref:System.Configuration.Assemblies.AssemblyHashAlgorithm.None?displayProperty=nameWithType> if there is no hash algorithm for the referenced assembly, or if the hash algorithm of the referenced assembly is not identified by the <xref:System.Configuration.Assemblies.AssemblyHashAlgorithm?displayProperty=nameWithType> enumeration.</span></span> <span data-ttu-id="2cf0e-604">Nas versões anteriores do .NET Framework, o <xref:System.Reflection.AssemblyName.HashAlgorithm%2A> propriedade retornada <xref:System.Configuration.Assemblies.AssemblyHashAlgorithm.SHA1?displayProperty=nameWithType> nessa situação.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-604">In previous versions of the .NET Framework, the <xref:System.Reflection.AssemblyName.HashAlgorithm%2A> property returned <xref:System.Configuration.Assemblies.AssemblyHashAlgorithm.SHA1?displayProperty=nameWithType> in this situation.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="2cf0e-605">O exemplo de código a seguir demonstra a chamada a <xref:System.Reflection.Assembly.GetReferencedAssemblies%2A> método.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-605">The following code example demonstrates calling the <xref:System.Reflection.Assembly.GetReferencedAssemblies%2A> method.</span></span> <span data-ttu-id="2cf0e-606">Este exemplo de código é parte de um exemplo maior fornecido para o <xref:System.Reflection.Assembly> classe.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-606">This code example is part of a larger example provided for the <xref:System.Reflection.Assembly> class.</span></span>  
  
 [!code-cpp[Reflection#1](~/samples/snippets/cpp/VS_Snippets_CLR/Reflection/CPP/reflection.cpp#1)]
 [!code-csharp[Reflection#1](~/samples/snippets/csharp/VS_Snippets_CLR/Reflection/CS/Reflection.cs#1)]
 [!code-vb[Reflection#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Reflection/VB/Reflection.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetSatelliteAssembly">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="2cf0e-607">Obtém o assembly satélite.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-607">Gets the satellite assembly.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetSatelliteAssembly">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.Assembly GetSatelliteAssembly (System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Assembly GetSatelliteAssembly(class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetSatelliteAssembly(System.Globalization.CultureInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetSatelliteAssembly (culture As CultureInfo) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Assembly ^ GetSatelliteAssembly(System::Globalization::CultureInfo ^ culture);" />
      <MemberSignature Language="F#" Value="abstract member GetSatelliteAssembly : System.Globalization.CultureInfo -&gt; System.Reflection.Assembly&#xA;override this.GetSatelliteAssembly : System.Globalization.CultureInfo -&gt; System.Reflection.Assembly" Usage="assembly.GetSatelliteAssembly culture" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetSatelliteAssembly(System.Globalization.CultureInfo)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="culture"><span data-ttu-id="2cf0e-608">A cultura especificada.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-608">The specified culture.</span></span></param>
        <summary><span data-ttu-id="2cf0e-609">Obtém o assembly satélite para a cultura especificada.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-609">Gets the satellite assembly for the specified culture.</span></span></summary>
        <returns><span data-ttu-id="2cf0e-610">O assembly satélite especificado.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-610">The specified satellite assembly.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2cf0e-611">Assemblies satélite contêm recursos localizados, como os distintos de assemblies de aplicativo principal, que contêm código executável não localizável e os recursos para uma única cultura que servem como a cultura neutra ou padrão.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-611">Satellite assemblies contain localized resources, as distinct from main application assemblies, which contain non-localizable executable code and resources for a single culture that serve as the default or neutral culture.</span></span>  
  
 <span data-ttu-id="2cf0e-612">Chame esse método para usar a versão do assembly atual.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-612">Call this method to use your current assembly version.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="2cf0e-613"><paramref name="culture" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-613"><paramref name="culture" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="2cf0e-614">Não foi possível localizar o assembly.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-614">The assembly cannot be found.</span></span></exception>
        <exception cref="T:System.IO.FileLoadException"><span data-ttu-id="2cf0e-615">O assembly satélite com um nome de arquivo correspondente foi encontrado, mas o <see langword="CultureInfo" /> não correspondia ao especificado.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-615">The satellite assembly with a matching file name was found, but the <see langword="CultureInfo" /> did not match the one specified.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="2cf0e-616">O assembly satélite não é um assembly válido.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-616">The satellite assembly is not a valid assembly.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="GetSatelliteAssembly">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.Assembly GetSatelliteAssembly (System.Globalization.CultureInfo culture, Version version);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Assembly GetSatelliteAssembly(class System.Globalization.CultureInfo culture, class System.Version version) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetSatelliteAssembly(System.Globalization.CultureInfo,System.Version)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Assembly ^ GetSatelliteAssembly(System::Globalization::CultureInfo ^ culture, Version ^ version);" />
      <MemberSignature Language="F#" Value="abstract member GetSatelliteAssembly : System.Globalization.CultureInfo * Version -&gt; System.Reflection.Assembly&#xA;override this.GetSatelliteAssembly : System.Globalization.CultureInfo * Version -&gt; System.Reflection.Assembly" Usage="assembly.GetSatelliteAssembly (culture, version)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetSatelliteAssembly(System.Globalization.CultureInfo,System.Version)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="version" Type="System.Version" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="culture"><span data-ttu-id="2cf0e-617">A cultura especificada.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-617">The specified culture.</span></span></param>
        <param name="version"><span data-ttu-id="2cf0e-618">A versão do assembly satélite.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-618">The version of the satellite assembly.</span></span></param>
        <summary><span data-ttu-id="2cf0e-619">Obtém a versão especificada do assembly satélite para a cultura especificada.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-619">Gets the specified version of the satellite assembly for the specified culture.</span></span></summary>
        <returns><span data-ttu-id="2cf0e-620">O assembly satélite especificado.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-620">The specified satellite assembly.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2cf0e-621">Assemblies satélite contêm recursos localizados, como os distintos de assemblies de aplicativo principal, que contêm código executável não localizável e os recursos para uma única cultura que servem como a cultura neutra ou padrão.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-621">Satellite assemblies contain localized resources, as distinct from main application assemblies, which contain non-localizable executable code and resources for a single culture that serve as the default or neutral culture.</span></span>  
  
 <span data-ttu-id="2cf0e-622">Chamar o <xref:System.Reflection.Assembly.GetSatelliteAssembly%28System.Globalization.CultureInfo%29> sobrecarga para usar a versão do assembly atual.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-622">Call the <xref:System.Reflection.Assembly.GetSatelliteAssembly%28System.Globalization.CultureInfo%29> overload to use your current assembly version.</span></span>  
  
 <span data-ttu-id="2cf0e-623">Se `version` é `null`, a versão do assembly atual será usada se o recurso e os principais assemblies são assinados.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-623">If `version` is `null`, the current assembly version is used if both the resource and main assemblies are signed.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="2cf0e-624"><paramref name="culture" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-624"><paramref name="culture" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.IO.FileLoadException"><span data-ttu-id="2cf0e-625">O assembly satélite com um nome de arquivo correspondente foi encontrado, mas o <see langword="CultureInfo" /> ou a versão não correspondia ao especificado.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-625">The satellite assembly with a matching file name was found, but the <see langword="CultureInfo" /> or the version did not match the one specified.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="2cf0e-626">Não foi possível localizar o assembly.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-626">The assembly cannot be found.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="2cf0e-627">O assembly satélite não é um assembly válido.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-627">The satellite assembly is not a valid assembly.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetType">
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="2cf0e-628">Obtém o objeto <see cref="T:System.Type" /> que representa o tipo especificado.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-628">Gets the <see cref="T:System.Type" /> object that represents the specified type.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public Type GetType ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetType" />
      <MemberSignature Language="VB.NET" Value="Public Function GetType () As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ GetType();" />
      <MemberSignature Language="F#" Value="override this.GetType : unit -&gt; Type" Usage="assembly.GetType " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public virtual Type GetType (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetType(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetType(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetType (name As String) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ GetType(System::String ^ name);" />
      <MemberSignature Language="F#" Value="override this.GetType : string -&gt; Type" Usage="assembly.GetType name" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetType(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="2cf0e-629">O nome completo do tipo.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-629">The full name of the type.</span></span></param>
        <summary><span data-ttu-id="2cf0e-630">Obtém o objeto <see cref="T:System.Type" /> com o nome especificado na instância do assembly.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-630">Gets the <see cref="T:System.Type" /> object with the specified name in the assembly instance.</span></span></summary>
        <returns><span data-ttu-id="2cf0e-631">Um objeto que representa a classe especificada ou <see langword="null" /> se a classe não for encontrada.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-631">An object that represents the specified class, or <see langword="null" /> if the class is not found.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2cf0e-632">Esse método somente pesquisará a instância atual do assembly.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-632">This method only searches the current assembly instance.</span></span> <span data-ttu-id="2cf0e-633">O `name` parâmetro inclui o namespace, mas não o assembly.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-633">The `name` parameter includes the namespace but not the assembly.</span></span> <span data-ttu-id="2cf0e-634">Para pesquisar outros assemblies para um tipo, use o <xref:System.Type.GetType%28System.String%29?displayProperty=nameWithType> sobrecarga de método, que, opcionalmente, pode incluir um nome de exibição do assembly como parte do nome do tipo.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-634">To search other assemblies for a type, use the <xref:System.Type.GetType%28System.String%29?displayProperty=nameWithType> method overload, which can optionally include an assembly display name as part of the type name.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="2cf0e-635">Se o tipo foi encaminhado para outro assembly, ele ainda é retornado por esse método.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-635">If the type has been forwarded to another assembly, it is still returned by this method.</span></span> <span data-ttu-id="2cf0e-636">Para obter informações sobre o encaminhamento de tipo, consulte [encaminhamento de tipo no Common Language Runtime](~/docs/framework/app-domains/type-forwarding-in-the-common-language-runtime.md).</span><span class="sxs-lookup"><span data-stu-id="2cf0e-636">For information on type forwarding, see [Type Forwarding in the Common Language Runtime](~/docs/framework/app-domains/type-forwarding-in-the-common-language-runtime.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="2cf0e-637">O exemplo a seguir define uma abstrata `MeansOfTransportation` classe o `Transportation` namespace.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-637">The following example defines an abstract `MeansOfTransportation` class in the `Transportation` namespace.</span></span> <span data-ttu-id="2cf0e-638">Ele chama o <xref:System.Reflection.Assembly.GetType%28System.String%29> método para recuperar seu <xref:System.Type> objeto, chama o <xref:System.Type.GetProperties%2A?displayProperty=nameWithType> método para obter uma matriz de <xref:System.Reflection.PropertyInfo> objetos que representam as propriedades do tipo e, em seguida, exibe informações sobre o tipo abstraem as propriedades.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-638">It calls the <xref:System.Reflection.Assembly.GetType%28System.String%29> method to retrieve its <xref:System.Type> object, calls the <xref:System.Type.GetProperties%2A?displayProperty=nameWithType> method to get an array of <xref:System.Reflection.PropertyInfo> objects that represent the type's properties, and then displays information on the type's abstract properties.</span></span> <span data-ttu-id="2cf0e-639">Observe que a chamada para o <xref:System.Reflection.Assembly.GetType%28System.String%29> método usa o nome do tipo totalmente qualificado (isto é, seu namespace, juntamente com seu nome de tipo).</span><span class="sxs-lookup"><span data-stu-id="2cf0e-639">Note that the call to the <xref:System.Reflection.Assembly.GetType%28System.String%29> method uses the type's fully qualified name (that is, its namespace along with its type name).</span></span>  
  
 [!code-csharp[System.Reflection.Assembly.GetType#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.reflection.assembly.gettype/cs/gettype1.cs#1)]
 [!code-vb[System.Reflection.Assembly.GetType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.reflection.assembly.gettype/vb/gettype1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="2cf0e-640"><paramref name="name" /> é inválido.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-640"><paramref name="name" /> is invalid.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="2cf0e-641"><paramref name="name" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-641"><paramref name="name" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="2cf0e-642"><paramref name="name" /> exige um assembly dependente que não pôde ser encontrado.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-642"><paramref name="name" /> requires a dependent assembly that could not be found.</span></span></exception>
        <exception cref="T:System.IO.FileLoadException"><block subset="none" type="note">
            <para>  
 <span data-ttu-id="2cf0e-643">Em vez disso, no <see href="https://go.microsoft.com/fwlink/?LinkID=247912">.NET para aplicativos da Windows Store</see> ou na <see href="https://docs.microsoft.com/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library">Biblioteca de Classes Portátil</see>, capture a exceção de classe base, <see cref="T:System.IO.IOException" />.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-643">In the <see href="https://go.microsoft.com/fwlink/?LinkID=247912">.NET for Windows Store apps</see> or the <see href="https://docs.microsoft.com/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library">Portable Class Library</see>, catch the base class exception, <see cref="T:System.IO.IOException" />, instead.</span></span>  
  
</para>
          </block><span data-ttu-id="2cf0e-644">
          <paramref name="name" /> exige um assembly dependente que foi encontrado, mas que não pôde ser carregado.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-644">
          <paramref name="name" /> requires a dependent assembly that was found but could not be loaded.</span></span>  
  
<span data-ttu-id="2cf0e-645">- ou -</span><span class="sxs-lookup"><span data-stu-id="2cf0e-645">-or-</span></span> 
<span data-ttu-id="2cf0e-646">O assembly atual foi carregado no contexto somente reflexão e o <paramref name="name" /> exige um assembly dependente que não foi pré-carregado.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-646">The current assembly was loaded into the reflection-only context, and <paramref name="name" /> requires a dependent assembly that was not preloaded.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="2cf0e-647"><paramref name="name" /> exige um assembly dependente, mas o arquivo não é um assembly válido.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-647"><paramref name="name" /> requires a dependent assembly, but the file is not a valid assembly.</span></span>  
  
<span data-ttu-id="2cf0e-648">- ou -</span><span class="sxs-lookup"><span data-stu-id="2cf0e-648">-or-</span></span> 
 <span data-ttu-id="2cf0e-649"><paramref name="name" /> exige um assembly dependente que foi compilado para uma versão do tempo de execução posterior à versão carregada no momento.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-649"><paramref name="name" /> requires a dependent assembly which was compiled for a version of the runtime later than the currently loaded version.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public virtual Type GetType (string name, bool throwOnError);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetType(string name, bool throwOnError) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetType(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetType (name As String, throwOnError As Boolean) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ GetType(System::String ^ name, bool throwOnError);" />
      <MemberSignature Language="F#" Value="override this.GetType : string * bool -&gt; Type" Usage="assembly.GetType (name, throwOnError)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetType(System.String,System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="throwOnError" Type="System.Boolean" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="2cf0e-650">O nome completo do tipo.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-650">The full name of the type.</span></span></param>
        <param name="throwOnError"><span data-ttu-id="2cf0e-651"><see langword="true" /> para gerar uma exceção se não for possível encontrar o tipo; <see langword="false" /> para retornar <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-651"><see langword="true" /> to throw an exception if the type is not found; <see langword="false" /> to return <see langword="null" />.</span></span></param>
        <summary><span data-ttu-id="2cf0e-652">Obtém o objeto <see cref="T:System.Type" /> com o nome especificado na instância do assembly e, opcionalmente, lança uma exceção se o tipo não for encontrado.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-652">Gets the <see cref="T:System.Type" /> object with the specified name in the assembly instance and optionally throws an exception if the type is not found.</span></span></summary>
        <returns><span data-ttu-id="2cf0e-653">Um objeto que representa a classe especificada.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-653">An object that represents the specified class.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2cf0e-654">Esse método somente pesquisará a instância atual do assembly.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-654">This method only searches the current assembly instance.</span></span> <span data-ttu-id="2cf0e-655">O `name` parâmetro inclui o namespace, mas não o assembly.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-655">The `name` parameter includes the namespace but not the assembly.</span></span> <span data-ttu-id="2cf0e-656">Para pesquisar outros assemblies para um tipo, use o <xref:System.Type.GetType%28System.String%29?displayProperty=nameWithType> sobrecarga de método, que, opcionalmente, pode incluir um nome de exibição do assembly como parte do nome do tipo.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-656">To search other assemblies for a type, use the <xref:System.Type.GetType%28System.String%29?displayProperty=nameWithType> method overload, which can optionally include an assembly display name as part of the type name.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="2cf0e-657">Se o tipo foi encaminhado para outro assembly, ele ainda é retornado por esse método.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-657">If the type has been forwarded to another assembly, it is still returned by this method.</span></span> <span data-ttu-id="2cf0e-658">Para obter informações sobre o encaminhamento de tipo, consulte [encaminhamento de tipo no Common Language Runtime](~/docs/framework/app-domains/type-forwarding-in-the-common-language-runtime.md).</span><span class="sxs-lookup"><span data-stu-id="2cf0e-658">For information on type forwarding, see [Type Forwarding in the Common Language Runtime](~/docs/framework/app-domains/type-forwarding-in-the-common-language-runtime.md).</span></span>  
  
 <span data-ttu-id="2cf0e-659">O `throwOnError` parâmetro afeta somente o que acontece quando o tipo não for encontrado.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-659">The `throwOnError` parameter only affects what happens when the type is not found.</span></span> <span data-ttu-id="2cf0e-660">Ele não afeta outras exceções que podem ser geradas.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-660">It does not affect any other exceptions that might be thrown.</span></span> <span data-ttu-id="2cf0e-661">Em particular, se o tipo é encontrado, mas não pode ser carregado, <xref:System.TypeLoadException> pode ser gerada, mesmo que `throwOnError` é `false`.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-661">In particular, if the type is found but cannot be loaded, <xref:System.TypeLoadException> can be thrown even if `throwOnError` is `false`.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="2cf0e-662"><paramref name="name" /> é inválido.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-662"><paramref name="name" /> is invalid.</span></span>  
  
<span data-ttu-id="2cf0e-663">- ou -</span><span class="sxs-lookup"><span data-stu-id="2cf0e-663">-or-</span></span> 
<span data-ttu-id="2cf0e-664">O comprimento de <paramref name="name" /> excede 1024 caracteres.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-664">The length of <paramref name="name" /> exceeds 1024 characters.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="2cf0e-665"><paramref name="name" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-665"><paramref name="name" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.TypeLoadException"><span data-ttu-id="2cf0e-666"><paramref name="throwOnError" /> é <see langword="true" /> e o tipo não pode ser encontrado.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-666"><paramref name="throwOnError" /> is <see langword="true" />, and the type cannot be found.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="2cf0e-667"><paramref name="name" /> exige um assembly dependente que não pôde ser encontrado.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-667"><paramref name="name" /> requires a dependent assembly that could not be found.</span></span></exception>
        <exception cref="T:System.IO.FileLoadException"><span data-ttu-id="2cf0e-668"><paramref name="name" /> exige um assembly dependente que foi encontrado, mas que não pôde ser carregado.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-668"><paramref name="name" /> requires a dependent assembly that was found but could not be loaded.</span></span>  
  
<span data-ttu-id="2cf0e-669">- ou -</span><span class="sxs-lookup"><span data-stu-id="2cf0e-669">-or-</span></span> 
<span data-ttu-id="2cf0e-670">O assembly atual foi carregado no contexto somente reflexão e o <paramref name="name" /> exige um assembly dependente que não foi pré-carregado.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-670">The current assembly was loaded into the reflection-only context, and <paramref name="name" /> requires a dependent assembly that was not preloaded.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="2cf0e-671"><paramref name="name" /> exige um assembly dependente, mas o arquivo não é um assembly válido.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-671"><paramref name="name" /> requires a dependent assembly, but the file is not a valid assembly.</span></span>  
  
<span data-ttu-id="2cf0e-672">- ou -</span><span class="sxs-lookup"><span data-stu-id="2cf0e-672">-or-</span></span> 
 <span data-ttu-id="2cf0e-673"><paramref name="name" /> exige um assembly dependente que foi compilado para uma versão do tempo de execução posterior à versão carregada no momento.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-673"><paramref name="name" /> requires a dependent assembly which was compiled for a version of the runtime later than the currently loaded version.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public virtual Type GetType (string name, bool throwOnError, bool ignoreCase);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetType(string name, bool throwOnError, bool ignoreCase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetType(System.String,System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetType (name As String, throwOnError As Boolean, ignoreCase As Boolean) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ GetType(System::String ^ name, bool throwOnError, bool ignoreCase);" />
      <MemberSignature Language="F#" Value="override this.GetType : string * bool * bool -&gt; Type" Usage="assembly.GetType (name, throwOnError, ignoreCase)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetType(System.String,System.Boolean,System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="throwOnError" Type="System.Boolean" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="ignoreCase" Type="System.Boolean" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="2cf0e-674">O nome completo do tipo.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-674">The full name of the type.</span></span></param>
        <param name="throwOnError"><span data-ttu-id="2cf0e-675"><see langword="true" /> para gerar uma exceção se não for possível encontrar o tipo; <see langword="false" /> para retornar <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-675"><see langword="true" /> to throw an exception if the type is not found; <see langword="false" /> to return <see langword="null" />.</span></span></param>
        <param name="ignoreCase"><span data-ttu-id="2cf0e-676"><see langword="true" /> para ignorar maiúsculas e minúsculas do nome do tipo; caso contrário, <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-676"><see langword="true" /> to ignore the case of the type name; otherwise, <see langword="false" />.</span></span></param>
        <summary><span data-ttu-id="2cf0e-677">Obtém o objeto <see cref="T:System.Type" /> com o nome especificado na instância do assembly, com a opção de ignorar a diferença entre maiúsculas e minúsculas e de gerar uma exceção se o tipo não for encontrado.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-677">Gets the <see cref="T:System.Type" /> object with the specified name in the assembly instance, with the options of ignoring the case, and of throwing an exception if the type is not found.</span></span></summary>
        <returns><span data-ttu-id="2cf0e-678">Um objeto que representa a classe especificada.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-678">An object that represents the specified class.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2cf0e-679">Esse método somente pesquisará a instância atual do assembly.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-679">This method only searches the current assembly instance.</span></span> <span data-ttu-id="2cf0e-680">O `name` parâmetro inclui o namespace, mas não o assembly.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-680">The `name` parameter includes the namespace but not the assembly.</span></span> <span data-ttu-id="2cf0e-681">Para pesquisar outros assemblies para um tipo, use o <xref:System.Type.GetType%28System.String%29?displayProperty=nameWithType> sobrecarga de método, que, opcionalmente, pode incluir um nome de exibição do assembly como parte do nome do tipo.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-681">To search other assemblies for a type, use the <xref:System.Type.GetType%28System.String%29?displayProperty=nameWithType> method overload, which can optionally include an assembly display name as part of the type name.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="2cf0e-682">Se o tipo foi encaminhado para outro assembly, ele ainda é retornado por esse método.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-682">If the type has been forwarded to another assembly, it is still returned by this method.</span></span> <span data-ttu-id="2cf0e-683">Para obter informações sobre o encaminhamento de tipo, consulte [encaminhamento de tipo no Common Language Runtime](~/docs/framework/app-domains/type-forwarding-in-the-common-language-runtime.md).</span><span class="sxs-lookup"><span data-stu-id="2cf0e-683">For information on type forwarding, see [Type Forwarding in the Common Language Runtime](~/docs/framework/app-domains/type-forwarding-in-the-common-language-runtime.md).</span></span>  
  
 <span data-ttu-id="2cf0e-684">O `throwOnError` parâmetro afeta somente o que acontece quando o tipo não for encontrado.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-684">The `throwOnError` parameter only affects what happens when the type is not found.</span></span> <span data-ttu-id="2cf0e-685">Ele não afeta outras exceções que podem ser geradas.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-685">It does not affect any other exceptions that might be thrown.</span></span> <span data-ttu-id="2cf0e-686">Em particular, se o tipo é encontrado, mas não pode ser carregado, <xref:System.TypeLoadException> pode ser gerada, mesmo que `throwOnError` é `false`.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-686">In particular, if the type is found but cannot be loaded, <xref:System.TypeLoadException> can be thrown even if `throwOnError` is `false`.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="2cf0e-687"><paramref name="name" /> é inválido.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-687"><paramref name="name" /> is invalid.</span></span>  
  
<span data-ttu-id="2cf0e-688">- ou -</span><span class="sxs-lookup"><span data-stu-id="2cf0e-688">-or-</span></span> 
<span data-ttu-id="2cf0e-689">O comprimento de <paramref name="name" /> excede 1024 caracteres.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-689">The length of <paramref name="name" /> exceeds 1024 characters.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="2cf0e-690"><paramref name="name" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-690"><paramref name="name" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.TypeLoadException"><span data-ttu-id="2cf0e-691"><paramref name="throwOnError" /> é <see langword="true" /> e o tipo não pode ser encontrado.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-691"><paramref name="throwOnError" /> is <see langword="true" />, and the type cannot be found.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="2cf0e-692"><paramref name="name" /> exige um assembly dependente que não pôde ser encontrado.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-692"><paramref name="name" /> requires a dependent assembly that could not be found.</span></span></exception>
        <exception cref="T:System.IO.FileLoadException"><span data-ttu-id="2cf0e-693"><paramref name="name" /> exige um assembly dependente que foi encontrado, mas que não pôde ser carregado.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-693"><paramref name="name" /> requires a dependent assembly that was found but could not be loaded.</span></span>  
  
<span data-ttu-id="2cf0e-694">- ou -</span><span class="sxs-lookup"><span data-stu-id="2cf0e-694">-or-</span></span> 
<span data-ttu-id="2cf0e-695">O assembly atual foi carregado no contexto somente reflexão e o <paramref name="name" /> exige um assembly dependente que não foi pré-carregado.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-695">The current assembly was loaded into the reflection-only context, and <paramref name="name" /> requires a dependent assembly that was not preloaded.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="2cf0e-696"><paramref name="name" /> exige um assembly dependente, mas o arquivo não é um assembly válido.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-696"><paramref name="name" /> requires a dependent assembly, but the file is not a valid assembly.</span></span>  
  
<span data-ttu-id="2cf0e-697">- ou -</span><span class="sxs-lookup"><span data-stu-id="2cf0e-697">-or-</span></span> 
 <span data-ttu-id="2cf0e-698"><paramref name="name" /> exige um assembly dependente que foi compilado para uma versão do tempo de execução posterior à versão carregada no momento.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-698"><paramref name="name" /> requires a dependent assembly which was compiled for a version of the runtime later than the currently loaded version.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="GetTypes">
      <MemberSignature Language="C#" Value="public virtual Type[] GetTypes ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type[] GetTypes() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetTypes" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetTypes () As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;Type ^&gt; ^ GetTypes();" />
      <MemberSignature Language="F#" Value="abstract member GetTypes : unit -&gt; Type[]&#xA;override this.GetTypes : unit -&gt; Type[]" Usage="assembly.GetTypes " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetTypes</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="2cf0e-699">Obtém os tipos definidos neste assembly.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-699">Gets the types defined in this assembly.</span></span></summary>
        <returns><span data-ttu-id="2cf0e-700">Uma matriz que contém todos os tipos que são definidos nesse assembly.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-700">An array that contains all the types that are defined in this assembly.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2cf0e-701">A matriz retornada inclui tipos aninhados.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-701">The returned array includes nested types.</span></span>  
  
 <span data-ttu-id="2cf0e-702">Se o <xref:System.Reflection.Assembly.GetTypes%2A> método é chamado em um assembly e um tipo nesse assembly é dependente de um tipo em um assembly que não tenha sido carregado (por exemplo, se ele deriva de um tipo no assembly segundo), um <xref:System.Reflection.ReflectionTypeLoadException> é gerada.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-702">If the <xref:System.Reflection.Assembly.GetTypes%2A> method is called on an assembly and a type in that assembly is dependent on a type in an assembly that has not been loaded (for example, if it derives from a type in the second assembly), a <xref:System.Reflection.ReflectionTypeLoadException> is thrown.</span></span> <span data-ttu-id="2cf0e-703">Por exemplo, isso pode acontecer se o primeiro assembly foi carregado com o <xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A> ou <xref:System.Reflection.Assembly.ReflectionOnlyLoadFrom%2A> métodos e o segundo conjunto não foi carregado.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-703">For example, this can happen if the first assembly was loaded with the <xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A> or <xref:System.Reflection.Assembly.ReflectionOnlyLoadFrom%2A> methods, and the second assembly was not loaded.</span></span> <span data-ttu-id="2cf0e-704">Isso também pode acontecer com os assemblies carregados usando o <xref:System.Reflection.Assembly.Load%2A> e <xref:System.Reflection.Assembly.LoadFile%2A> métodos se o segundo conjunto não pode ser localizado quando a <xref:System.Reflection.Assembly.GetTypes%2A> método é chamado.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-704">It can also happen with assemblies loaded using the <xref:System.Reflection.Assembly.Load%2A> and <xref:System.Reflection.Assembly.LoadFile%2A> methods if the second assembly cannot be located when the <xref:System.Reflection.Assembly.GetTypes%2A> method is called.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="2cf0e-705">Se um tipo foi encaminhado para outro assembly, ele não está incluído na matriz retornada.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-705">If a type has been forwarded to another assembly, it is not included in the returned array.</span></span> <span data-ttu-id="2cf0e-706">Para obter informações sobre o encaminhamento de tipo, consulte [encaminhamento de tipo no Common Language Runtime](~/docs/framework/app-domains/type-forwarding-in-the-common-language-runtime.md).</span><span class="sxs-lookup"><span data-stu-id="2cf0e-706">For information on type forwarding, see [Type Forwarding in the Common Language Runtime](~/docs/framework/app-domains/type-forwarding-in-the-common-language-runtime.md).</span></span>  
  
 <span data-ttu-id="2cf0e-707">Para recuperar uma coleção de <xref:System.Reflection.TypeInfo> objetos em vez de uma matriz de <xref:System.Type> objetos, use o <xref:System.Reflection.Assembly.DefinedTypes%2A?displayProperty=nameWithType> propriedade.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-707">To retrieve a collection of <xref:System.Reflection.TypeInfo> objects instead of an array of <xref:System.Type> objects, use the <xref:System.Reflection.Assembly.DefinedTypes%2A?displayProperty=nameWithType> property.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="2cf0e-708">O exemplo a seguir exibe os parâmetros de um método em um tipo no assembly especificado.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-708">The following example displays parameters of one method on a type in the specified assembly.</span></span>  
  
 [!code-cpp[System.Reflection.Assembly#11](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Assembly/CPP/assembly.cpp#11)]
 [!code-csharp[System.Reflection.Assembly#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Assembly/CS/assembly.cs#11)]
 [!code-vb[System.Reflection.Assembly#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Assembly/VB/assembly.vb#11)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.ReflectionTypeLoadException"><span data-ttu-id="2cf0e-709">O assembly contém um ou mais tipos que não podem ser carregados.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-709">The assembly contains one or more types that cannot be loaded.</span></span> <span data-ttu-id="2cf0e-710">A matriz retornada pela propriedade <see cref="P:System.Reflection.ReflectionTypeLoadException.Types" /> dessa exceção contém um objeto <see cref="T:System.Type" /> para cada tipo que foi carregado e <see langword="null" /> para cada tipo que não pôde ser carregado, enquanto a propriedade <see cref="P:System.Reflection.ReflectionTypeLoadException.LoaderExceptions" /> contém uma exceção para cada tipo que não pôde ser carregado.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-710">The array returned by the <see cref="P:System.Reflection.ReflectionTypeLoadException.Types" /> property of this exception contains a <see cref="T:System.Type" /> object for each type that was loaded and <see langword="null" /> for each type that could not be loaded, while the <see cref="P:System.Reflection.ReflectionTypeLoadException.LoaderExceptions" /> property contains an exception for each type that could not be loaded.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="GlobalAssemblyCache">
      <MemberSignature Language="C#" Value="public virtual bool GlobalAssemblyCache { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool GlobalAssemblyCache" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.GlobalAssemblyCache" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property GlobalAssemblyCache As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool GlobalAssemblyCache { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.GlobalAssemblyCache : bool" Usage="System.Reflection.Assembly.GlobalAssemblyCache" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Assembly.GlobalAssemblyCache</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="2cf0e-711">Obtém um valor que indica se o assembly foi carregado do cache de assembly global.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-711">Gets a value indicating whether the assembly was loaded from the global assembly cache.</span></span></summary>
        <value><span data-ttu-id="2cf0e-712"><see langword="true" /> Se o assembly foi carregado do cache de assembly global; Caso contrário, <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-712"><see langword="true" /> if the assembly was loaded from the global assembly cache; otherwise, <see langword="false" />.</span></span></value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="HostContext">
      <MemberSignature Language="C#" Value="public virtual long HostContext { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 HostContext" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.HostContext" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property HostContext As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property long HostContext { long get(); };" />
      <MemberSignature Language="F#" Value="member this.HostContext : int64" Usage="System.Reflection.Assembly.HostContext" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="2cf0e-713">Obtém o contexto de host com o qual o assembly foi carregado.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-713">Gets the host context with which the assembly was loaded.</span></span></summary>
        <value><span data-ttu-id="2cf0e-714">Um valor <see cref="T:System.Int64" /> que indica o contexto de host com o qual o assembly foi carregado, se houver.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-714">An <see cref="T:System.Int64" /> value that indicates the host context with which the assembly was loaded, if any.</span></span></value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ImageRuntimeVersion">
      <MemberSignature Language="C#" Value="public virtual string ImageRuntimeVersion { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ImageRuntimeVersion" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.ImageRuntimeVersion" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property ImageRuntimeVersion As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ ImageRuntimeVersion { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ImageRuntimeVersion : string" Usage="System.Reflection.Assembly.ImageRuntimeVersion" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="2cf0e-715">Obtém uma cadeia de caracteres que representa a versão do CLR (Common Language Runtime) salva no arquivo que contém o manifesto.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-715">Gets a string representing the version of the common language runtime (CLR) saved in the file containing the manifest.</span></span></summary>
        <value><span data-ttu-id="2cf0e-716">O nome da pasta da versão do CLR.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-716">The CLR version folder name.</span></span> <span data-ttu-id="2cf0e-717">Este não é um caminho completo.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-717">This is not a full path.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2cf0e-718">Por exemplo, o valor para o .NET Framework versão 1.1 seria v1.1.4322.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-718">For example, the value for the .NET Framework version 1.1 would be v1.1.4322.</span></span> <span data-ttu-id="2cf0e-719">Os arquivos binários do que a versão deve ser localizados no caminho % windir%\Microsoft.NET\Framework\v1.1.4322.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-719">The binary files for that version would be located in the path %windir%\Microsoft.NET\Framework\v1.1.4322.</span></span>  
  
 <span data-ttu-id="2cf0e-720">Por padrão, <xref:System.Reflection.Assembly.ImageRuntimeVersion%2A> está definido para a versão do CLR usado para compilar o assembly.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-720">By default, <xref:System.Reflection.Assembly.ImageRuntimeVersion%2A> is set to the version of the CLR used to build the assembly.</span></span> <span data-ttu-id="2cf0e-721">No entanto, ele pode ter sido definido com outro valor no tempo de compilação.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-721">However, it might have been set to another value at compile time.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsCollectible">
      <MemberSignature Language="C#" Value="public virtual bool IsCollectible { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsCollectible" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.IsCollectible" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsCollectible As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsCollectible { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsCollectible : bool" Usage="System.Reflection.Assembly.IsCollectible" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="2cf0e-722">Obtém um valor que indica se este assembly é mantido em uma coleção <see cref="T:System.Runtime.Loader.AssemblyLoadContext" />.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-722">Gets a value that indicates whether this assembly is held in a collectible <see cref="T:System.Runtime.Loader.AssemblyLoadContext" />.</span></span></summary>
        <value><span data-ttu-id="2cf0e-723"><see langword="true" /> Se esse assembly é mantido em uma coleção <see cref="T:System.Runtime.Loader.AssemblyLoadContext" />; caso contrário, <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-723"><see langword="true" /> if this assembly is held in a collectible <see cref="T:System.Runtime.Loader.AssemblyLoadContext" />; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="2cf0e-724">Para obter mais informações, consulte [como usar e depurar unloadability assembly no .NET Core](~/docs/standard/assembly/unloadability-howto.md).</span><span class="sxs-lookup"><span data-stu-id="2cf0e-724">For more information, see [How to use and debug assembly unloadability in .NET Core](~/docs/standard/assembly/unloadability-howto.md).</span></span>

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsDefined">
      <MemberSignature Language="C#" Value="public virtual bool IsDefined (Type attributeType, bool inherit);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsDefined(class System.Type attributeType, bool inherit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.IsDefined(System.Type,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function IsDefined (attributeType As Type, inherit As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool IsDefined(Type ^ attributeType, bool inherit);" />
      <MemberSignature Language="F#" Value="abstract member IsDefined : Type * bool -&gt; bool&#xA;override this.IsDefined : Type * bool -&gt; bool" Usage="assembly.IsDefined (attributeType, inherit)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Reflection.ICustomAttributeProvider.IsDefined(System.Type,System.Boolean)</InterfaceMember>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.IsDefined(System.Type,System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="attributeType" Type="System.Type" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="inherit" Type="System.Boolean" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="attributeType"><span data-ttu-id="2cf0e-725">O tipo do atributo a ser verificado para esse assembly.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-725">The type of the attribute to be checked for this assembly.</span></span></param>
        <param name="inherit"><span data-ttu-id="2cf0e-726">Este argumento é ignorado para objetos deste tipo.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-726">This argument is ignored for objects of this type.</span></span></param>
        <summary><span data-ttu-id="2cf0e-727">Indica se um atributo especificado foi ou não foi aplicado ao assembly.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-727">Indicates whether or not a specified attribute has been applied to the assembly.</span></span></summary>
        <returns><span data-ttu-id="2cf0e-728"><see langword="true" /> se o atributo foi aplicado ao assembly; caso contrário, <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-728"><see langword="true" /> if the attribute has been applied to the assembly; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="2cf0e-729">O exemplo de código a seguir aplica-se a <xref:System.Reflection.AssemblyTitleAttribute> atributo em um assembly e, em seguida, usa <xref:System.Reflection.Assembly.IsDefined%2A> para indicar se ela foi aplicada.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-729">The following code example applies the <xref:System.Reflection.AssemblyTitleAttribute> attribute to an assembly and then uses <xref:System.Reflection.Assembly.IsDefined%2A> to indicate whether it was applied.</span></span> <span data-ttu-id="2cf0e-730">Ele também testa um atributo que não foi aplicado.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-730">It also tests an attribute that was not applied.</span></span>  
  
 [!code-csharp[System.Reflection.Assembly.IsDefined#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.reflection.assembly.isdefined/CS/isdefined.cs#1)]
 [!code-vb[System.Reflection.Assembly.IsDefined#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.reflection.assembly.isdefined/VB/isdefined.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="2cf0e-731"><paramref name="attributeType" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-731"><paramref name="attributeType" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="2cf0e-732"><paramref name="attributeType" /> usa um tipo inválido.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-732"><paramref name="attributeType" /> uses an invalid type.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="IsDynamic">
      <MemberSignature Language="C#" Value="public virtual bool IsDynamic { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsDynamic" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.IsDynamic" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsDynamic As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsDynamic { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsDynamic : bool" Usage="System.Reflection.Assembly.IsDynamic" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="2cf0e-733">Obtém um valor que indica se o assembly atual foi gerado dinamicamente no processo atual através da emissão de reflexo.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-733">Gets a value that indicates whether the current assembly was generated dynamically in the current process by using reflection emit.</span></span></summary>
        <value><span data-ttu-id="2cf0e-734"><see langword="true" /> Se o assembly atual foi gerado dinamicamente no processo atual; Caso contrário, <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-734"><see langword="true" /> if the current assembly was generated dynamically in the current process; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2cf0e-735">Assemblies dinâmicos são representados pela classe derivada <xref:System.Reflection.Emit.AssemblyBuilder>.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-735">Dynamic assemblies are represented by the derived class <xref:System.Reflection.Emit.AssemblyBuilder>.</span></span>  
  
 <span data-ttu-id="2cf0e-736">Quando um assembly dinâmico é salvo em disco, o assembly salvo não é dinâmico.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-736">When a dynamic assembly is saved to disk, the saved assembly is not dynamic.</span></span> <span data-ttu-id="2cf0e-737">Se o assembly salvo é carregado no outro domínio de aplicativo ou processo, o <xref:System.Reflection.Assembly.IsDynamic%2A> propriedade retorna `false`.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-737">If the saved assembly is loaded into another application domain or process, the <xref:System.Reflection.Assembly.IsDynamic%2A> property returns `false`.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsFullyTrusted">
      <MemberSignature Language="C#" Value="public bool IsFullyTrusted { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsFullyTrusted" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.IsFullyTrusted" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsFullyTrusted As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsFullyTrusted { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsFullyTrusted : bool" Usage="System.Reflection.Assembly.IsFullyTrusted" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="2cf0e-738">Obtém um valor que indica se o assembly atual é carregado com confiança total.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-738">Gets a value that indicates whether the current assembly is loaded with full trust.</span></span></summary>
        <value><span data-ttu-id="2cf0e-739"><see langword="true" /> se o assembly atual for carregado com confiança total; caso contrário, <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-739"><see langword="true" /> if the current assembly is loaded with full trust; otherwise, <see langword="false" />.</span></span></value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Load">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="2cf0e-740">Carrega um assembly.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-740">Loads an assembly.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly Load (byte[] rawAssembly);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly Load(unsigned int8[] rawAssembly) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.Load(System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Load (rawAssembly As Byte()) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ Load(cli::array &lt;System::Byte&gt; ^ rawAssembly);" />
      <MemberSignature Language="F#" Value="static member Load : byte[] -&gt; System.Reflection.Assembly" Usage="System.Reflection.Assembly.Load rawAssembly" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rawAssembly" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="rawAssembly"><span data-ttu-id="2cf0e-741">Uma matriz de byte que é uma imagem baseada em COFF contendo um assembly emitido.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-741">A byte array that is a COFF-based image containing an emitted assembly.</span></span></param>
        <summary><span data-ttu-id="2cf0e-742">Carrega o assembly com uma imagem baseada em formato COFF, contendo um assembly emitido.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-742">Loads the assembly with a common object file format (COFF)-based image containing an emitted assembly.</span></span> <span data-ttu-id="2cf0e-743">O assembly é carregado no domínio de aplicativo do chamador.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-743">The assembly is loaded into the application domain of the caller.</span></span></summary>
        <returns><span data-ttu-id="2cf0e-744">O assembly carregado.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-744">The loaded assembly.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2cf0e-745">O nível de confiança de um assembly que é carregado usando esse método é o mesmo que o nível de confiança do assembly de chamada.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-745">The trust level of an assembly that is loaded by using this method is the same as the trust level of the calling assembly.</span></span> <span data-ttu-id="2cf0e-746">Para carregar um assembly de uma matriz de bytes com o nível de confiança do domínio do aplicativo, use o <xref:System.Reflection.Assembly.Load%28System.Byte%5B%5D%2CSystem.Byte%5B%5D%2CSystem.Security.SecurityContextSource%29> sobrecarga de método.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-746">To load an assembly from a byte array with the trust level of the application domain, use the <xref:System.Reflection.Assembly.Load%28System.Byte%5B%5D%2CSystem.Byte%5B%5D%2CSystem.Security.SecurityContextSource%29> method overload.</span></span> <span data-ttu-id="2cf0e-747">Para obter mais informações sobre o uso de evidências com sobrecargas do <xref:System.Reflection.Assembly.Load%2A> método que levam a matrizes de bytes, consulte o <xref:System.Reflection.Assembly.Load%28System.Byte%5B%5D%2CSystem.Byte%5B%5D%2CSystem.Security.Policy.Evidence%29> sobrecarga de método.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-747">For more information about the use of evidence with overloads of the <xref:System.Reflection.Assembly.Load%2A> method that take byte arrays, see the <xref:System.Reflection.Assembly.Load%28System.Byte%5B%5D%2CSystem.Byte%5B%5D%2CSystem.Security.Policy.Evidence%29> method overload.</span></span>  
  
 <span data-ttu-id="2cf0e-748">Refletir em arquivos executáveis C++ pode gerar um <xref:System.BadImageFormatException>.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-748">Reflecting on C++ executable files might throw a <xref:System.BadImageFormatException>.</span></span> <span data-ttu-id="2cf0e-749">Isso provavelmente é causado pelo compilador C++ os endereços de realocação ou a `.reloc` seção do seu arquivo executável.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-749">This is most likely caused by the C++ compiler stripping the relocation addresses or the `.reloc` section from your executable file.</span></span> <span data-ttu-id="2cf0e-750">Para preservar os `.reloc` endereço para seu arquivo executável do C++, especifique `/fixed:no` quando você está vinculando.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-750">To preserve the `.reloc` address for your C++ executable file, specify `/fixed:no` when you are linking.</span></span>  
  
 <span data-ttu-id="2cf0e-751">Observe que essa sobrecarga de método sempre cria um novo <xref:System.Reflection.Assembly> objeto com seu próprio mapeamento.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-751">Note that this method overload always creates a new <xref:System.Reflection.Assembly> object with its own mapping.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="2cf0e-752"><paramref name="rawAssembly" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-752"><paramref name="rawAssembly" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="2cf0e-753"><paramref name="rawAssembly" /> não é um assembly válido.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-753"><paramref name="rawAssembly" /> is not a valid assembly.</span></span>  
  
<span data-ttu-id="2cf0e-754">- ou -</span><span class="sxs-lookup"><span data-stu-id="2cf0e-754">-or-</span></span> 
<span data-ttu-id="2cf0e-755">A versão 2,0 ou posterior do Common Language Runtime está carregada e <paramref name="rawAssembly" /> foi compilada com uma versão posterior.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-755">Version 2.0 or later of the common language runtime is currently loaded and <paramref name="rawAssembly" /> was compiled with a later version.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly Load (System.Reflection.AssemblyName assemblyRef);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly Load(class System.Reflection.AssemblyName assemblyRef) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.Load(System.Reflection.AssemblyName)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Load (assemblyRef As AssemblyName) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ Load(System::Reflection::AssemblyName ^ assemblyRef);" />
      <MemberSignature Language="F#" Value="static member Load : System.Reflection.AssemblyName -&gt; System.Reflection.Assembly" Usage="System.Reflection.Assembly.Load assemblyRef" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyRef" Type="System.Reflection.AssemblyName" />
      </Parameters>
      <Docs>
        <param name="assemblyRef"><span data-ttu-id="2cf0e-756">O objeto que descreve o assembly a ser carregado.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-756">The object that describes the assembly to be loaded.</span></span></param>
        <summary><span data-ttu-id="2cf0e-757">Carrega um assembly de acordo com seu <see cref="T:System.Reflection.AssemblyName" />.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-757">Loads an assembly given its <see cref="T:System.Reflection.AssemblyName" />.</span></span></summary>
        <returns><span data-ttu-id="2cf0e-758">O assembly carregado.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-758">The loaded assembly.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2cf0e-759"><xref:System.IO.FileLoadException> será gerada se `assemblyRef` Especifica o nome completo do assembly e o assembly primeiro que corresponda ao nome simple tem uma versão diferente, uma cultura ou um token de chave pública.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-759"><xref:System.IO.FileLoadException> is thrown if `assemblyRef` specifies the full assembly name and the first assembly that matches the simple name has a different version, culture, or public key token.</span></span> <span data-ttu-id="2cf0e-760">O carregador não continuar a sondagem de outros assemblies que correspondem ao nome simple.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-760">The loader does not continue probing for other assemblies that match the simple name.</span></span> <span data-ttu-id="2cf0e-761">Começando com o .NET Framework 4, porque a execução do código em assemblies remotos está desabilitada por padrão, uma <xref:System.IO.FileLoadException> também será gerada se `assemblyRef` Especifica um assembly remoto.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-761">Starting with .NET Framework 4, because execution of code in remote assemblies is disabled by default, a <xref:System.IO.FileLoadException> is also thrown if `assemblyRef` specifies a remote assembly.</span></span> <span data-ttu-id="2cf0e-762">Para habilitar a execução de código carregado a partir de locais remotos, você pode usar o [ `<loadFromRemoteSources>` ](~/docs/framework/configure-apps/file-schema/runtime/loadfromremotesources-element.md) elemento de configuração.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-762">To enable execution of code loaded from remote locations, you can use the [`<loadFromRemoteSources>`](~/docs/framework/configure-apps/file-schema/runtime/loadfromremotesources-element.md) configuration element.</span></span>     
  
> [!NOTE]
>  <span data-ttu-id="2cf0e-763">Não use uma <xref:System.Reflection.AssemblyName> apenas com o <xref:System.Reflection.AssemblyName.CodeBase%2A> conjunto de propriedades.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-763">Do not use an <xref:System.Reflection.AssemblyName> with only the <xref:System.Reflection.AssemblyName.CodeBase%2A> property set.</span></span> <span data-ttu-id="2cf0e-764">O <xref:System.Reflection.AssemblyName.CodeBase%2A> propriedade não fornece todos os elementos da identidade do assembly (por exemplo, nome ou versão), então, carregando não ocorra de acordo com as regras de carregamento por identidade, como você esperaria do <xref:System.Reflection.Assembly.Load%2A> método.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-764">The <xref:System.Reflection.AssemblyName.CodeBase%2A> property does not supply any elements of the assembly identity (such as name or version), so loading does not occur according to load-by-identity rules, as you would expect from the <xref:System.Reflection.Assembly.Load%2A> method.</span></span> <span data-ttu-id="2cf0e-765">Em vez disso, o assembly é carregado usando as regras de carga.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-765">Instead, the assembly is loaded using load-from rules.</span></span> <span data-ttu-id="2cf0e-766">Para obter informações sobre as desvantagens de usar o contexto de carga, consulte o <xref:System.Reflection.Assembly.LoadFrom%2A?displayProperty=nameWithType> sobrecarga de método ou [as práticas recomendadas para carregamento de Assembly](~/docs/framework/deployment/best-practices-for-assembly-loading.md).</span><span class="sxs-lookup"><span data-stu-id="2cf0e-766">For information about the disadvantages of using the load-from context, see the <xref:System.Reflection.Assembly.LoadFrom%2A?displayProperty=nameWithType> method overload or [Best Practices for Assembly Loading](~/docs/framework/deployment/best-practices-for-assembly-loading.md).</span></span>  
  
 <span data-ttu-id="2cf0e-767">Se determinadas permissões são concedidas ou não a um assembly é algo que se baseia na evidência.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-767">Whether certain permissions are granted or not granted to an assembly is based on evidence.</span></span> <span data-ttu-id="2cf0e-768">As regras para o assembly e a mesclagem de evidência de segurança são da seguinte maneira:</span><span class="sxs-lookup"><span data-stu-id="2cf0e-768">The rules for assembly and security evidence merging are as follows:</span></span>  
  
-   <span data-ttu-id="2cf0e-769">Quando você usa um <xref:System.Reflection.Assembly.Load%2A> método sem nenhum <xref:System.Security.Policy.Evidence> parâmetro, o assembly é carregado com a evidência que fornece o carregador.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-769">When you use a <xref:System.Reflection.Assembly.Load%2A> method with no <xref:System.Security.Policy.Evidence> parameter, the assembly is loaded with the evidence that the loader supplies.</span></span>  
  
-   <span data-ttu-id="2cf0e-770">Quando você usa um <xref:System.Reflection.Assembly.Load%2A> método com um <xref:System.Security.Policy.Evidence> parâmetro, partes de evidências são mesclados.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-770">When you use a <xref:System.Reflection.Assembly.Load%2A> method with an <xref:System.Security.Policy.Evidence> parameter, pieces of evidence are merged.</span></span> <span data-ttu-id="2cf0e-771">Partes de evidências fornecida como um argumento para o <xref:System.Reflection.Assembly.Load%2A> método substituir partes de evidências fornecida pelo carregador.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-771">Pieces of evidence supplied as an argument to the <xref:System.Reflection.Assembly.Load%2A> method supersede pieces of evidence supplied by the loader.</span></span>  
  
-   <span data-ttu-id="2cf0e-772">Quando você usa um <xref:System.Reflection.Assembly.Load%2A> sobrecarga de método com um `Byte[]` parâmetro para carregar uma objeto arquivo formato COFF imagem comum, evidência é herdado do assembly de chamada.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-772">When you use a <xref:System.Reflection.Assembly.Load%2A> method overload with a `Byte[]` parameter to load a common object file format (COFF) image, evidence is inherited from the calling assembly.</span></span> <span data-ttu-id="2cf0e-773">Isso se aplica ao .NET Framework versão 1.1 Service Pack 1 (SP1) e versões posteriores.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-773">This applies to the .NET Framework version 1.1 Service Pack 1 (SP1) and subsequent releases.</span></span>  
  
    > [!NOTE]
    >  <span data-ttu-id="2cf0e-774">No .NET Framework versão 1.0 e na versão 1.1, sem o SP1, quando você usa um <xref:System.Reflection.Assembly.Load%2A> sobrecarga de método com um `Byte[]` parâmetro para carregar uma imagem COFF, evidência é combinado.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-774">In the .NET Framework version 1.0 and in version 1.1 without SP1, when you use a <xref:System.Reflection.Assembly.Load%2A> method overload with a `Byte[]` parameter to load a COFF image, evidence is combined.</span></span> <span data-ttu-id="2cf0e-775">`Zone`, `Url` e `Site` são herdadas do assembly de chamada, e `Hash` e `StrongName` são obtidos do assembly COFF.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-775">`Zone`, `Url` and `Site` are inherited from the calling assembly, and `Hash` and `StrongName` are taken from the COFF assembly.</span></span>  
  
-   <span data-ttu-id="2cf0e-776">Quando você usa um <xref:System.Reflection.Assembly.Load%2A> método com um `Byte[]` parâmetro e <xref:System.Security.Policy.Evidence> para carregar uma imagem COFF, somente a evidência fornecida é usada.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-776">When you use a <xref:System.Reflection.Assembly.Load%2A> method with a `Byte[]` parameter and <xref:System.Security.Policy.Evidence> to load a COFF image, only the supplied evidence is used.</span></span> <span data-ttu-id="2cf0e-777">Evidência do assembly de chamada e evidência da imagem COFF são ignorados.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-777">Evidence of the calling assembly and evidence of the COFF image is ignored.</span></span>  
  
 <span data-ttu-id="2cf0e-778">Refletir em arquivos executáveis C++ pode gerar um <xref:System.BadImageFormatException>.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-778">Reflecting on C++ executable files might throw a <xref:System.BadImageFormatException>.</span></span> <span data-ttu-id="2cf0e-779">Isso provavelmente é causado pelo compilador C++ os endereços de realocação ou a `.reloc` seção do seu arquivo executável.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-779">This is most likely caused by the C++ compiler stripping the relocation addresses or the `.reloc` section from your executable file.</span></span> <span data-ttu-id="2cf0e-780">Para preservar os `.reloc` endereço para seu arquivo executável do C++, especifique `/fixed:no` quando você está vinculando.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-780">To preserve the `.reloc` address for your C++ executable file, specify `/fixed:no` when you are linking.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="2cf0e-781">Se ambos o <xref:System.Reflection.AssemblyName.Name%2A?displayProperty=nameWithType> propriedade e o <xref:System.Reflection.AssemblyName.CodeBase%2A?displayProperty=nameWithType> estiverem definidas, a primeira tentativa de carregar o assembly usa o nome de exibição (incluindo a versão, cultura e assim por diante, conforme retornado pelo <xref:System.Reflection.Assembly.FullName%2A?displayProperty=nameWithType> propriedade).</span><span class="sxs-lookup"><span data-stu-id="2cf0e-781">If both the <xref:System.Reflection.AssemblyName.Name%2A?displayProperty=nameWithType> property and the <xref:System.Reflection.AssemblyName.CodeBase%2A?displayProperty=nameWithType> property are set, the first attempt to load the assembly uses the display name (including version, culture, and so on, as returned by the <xref:System.Reflection.Assembly.FullName%2A?displayProperty=nameWithType> property).</span></span> <span data-ttu-id="2cf0e-782">Se o arquivo não for encontrado, <xref:System.Reflection.AssemblyName.CodeBase%2A> é usado para pesquisar o assembly.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-782">If the file is not found, <xref:System.Reflection.AssemblyName.CodeBase%2A> is used to search for the assembly.</span></span> <span data-ttu-id="2cf0e-783">Se o assembly for encontrado usando <xref:System.Reflection.AssemblyName.CodeBase%2A>, o nome de exibição é comparado com o assembly.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-783">If the assembly is found using <xref:System.Reflection.AssemblyName.CodeBase%2A>, the display name is matched against the assembly.</span></span> <span data-ttu-id="2cf0e-784">Se a correspondência falhar, um <xref:System.IO.FileLoadException> é gerada.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-784">If the match fails, a <xref:System.IO.FileLoadException> is thrown.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="2cf0e-785">O exemplo a seguir instancia um <xref:System.Reflection.AssemblyName> do objeto e o utiliza para carregar o `sysglobal.dll` assembly.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-785">The following example instantiates an <xref:System.Reflection.AssemblyName> object and uses it to load the `sysglobal.dll` assembly.</span></span> <span data-ttu-id="2cf0e-786">O exemplo, em seguida, exibe o nome completo de tipos de público do assembly.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-786">The example then displays the full name of the assembly's public types.</span></span>  
  
 [!code-csharp[System.Reflection.Assembly.Load#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.reflection.assembly.load/cs/Load2.cs#2)]
 [!code-vb[System.Reflection.Assembly.Load#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.reflection.assembly.load/vb/Load2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="2cf0e-787"><paramref name="assemblyRef" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-787"><paramref name="assemblyRef" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="2cf0e-788"><paramref name="assemblyRef" /> não foi encontrado.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-788"><paramref name="assemblyRef" /> is not found.</span></span></exception>
        <exception cref="T:System.IO.FileLoadException"><block subset="none" type="note">
            <para>  
 <span data-ttu-id="2cf0e-789">Em vez disso, no <see href="https://go.microsoft.com/fwlink/?LinkID=247912">.NET para aplicativos da Windows Store</see> ou na <see href="https://docs.microsoft.com/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library">Biblioteca de Classes Portátil</see>, capture a exceção de classe base, <see cref="T:System.IO.IOException" />.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-789">In the <see href="https://go.microsoft.com/fwlink/?LinkID=247912">.NET for Windows Store apps</see> or the <see href="https://docs.microsoft.com/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library">Portable Class Library</see>, catch the base class exception, <see cref="T:System.IO.IOException" />, instead.</span></span>  
  
</para>
          </block>  
  
 <span data-ttu-id="2cf0e-790">Não foi possível carregar um arquivo que foi encontrado.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-790">A file that was found could not be loaded.</span></span>

<span data-ttu-id="2cf0e-791">- ou -</span><span class="sxs-lookup"><span data-stu-id="2cf0e-791">-or-</span></span>

<span data-ttu-id="2cf0e-792"><paramref name="assemblyRef" /> especifica um assembly remoto, mas a capacidade de executar código em assemblies remotos é desabilitada.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-792"><paramref name="assemblyRef" /> specifies a remote assembly, but the ability to execute code in remote assemblies is disabled.</span></span> <span data-ttu-id="2cf0e-793">Veja <see href="https://docs.microsoft.com/dotnet/framework/configure-apps/file-schema/runtime/loadfromremotesources-element">&lt;loadFromRemoteSources&gt;</see>.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-793">See <see href="https://docs.microsoft.com/dotnet/framework/configure-apps/file-schema/runtime/loadfromremotesources-element">&lt;loadFromRemoteSources&gt;</see>.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="2cf0e-794"><paramref name="assemblyRef" /> não é um assembly válido.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-794"><paramref name="assemblyRef" /> is not a valid assembly.</span></span> <span data-ttu-id="2cf0e-795">- ou -</span><span class="sxs-lookup"><span data-stu-id="2cf0e-795">-or-</span></span> 
<span data-ttu-id="2cf0e-796">A versão 2,0 ou posterior do Common Language Runtime está carregada e <paramref name="assemblyRef" /> foi compilada com uma versão posterior.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-796">Version 2.0 or later of the common language runtime is currently loaded and <paramref name="assemblyRef" /> was compiled with a later version.</span></span></exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission"><span data-ttu-id="2cf0e-797">para acesso de leitura de um arquivo ou um diretório, e para acesso às informações no próprio caminho.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-797">for access to read from a file or directory, and for access to the information in the path itself.</span></span> <span data-ttu-id="2cf0e-798">Enumerações associadas: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></span><span class="sxs-lookup"><span data-stu-id="2cf0e-798">Associated enumerations: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></span></span></permission>
        <permission cref="T:System.Net.WebPermission"><span data-ttu-id="2cf0e-799">para ler um URI que não começa com "file://".</span><span class="sxs-lookup"><span data-stu-id="2cf0e-799">for reading a URI that does not begin with "file://".</span></span></permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="2cf0e-800">para carregar um assembly com evidências.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-800">to load an assembly with evidence.</span></span> <span data-ttu-id="2cf0e-801">Enumeração associada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></span><span class="sxs-lookup"><span data-stu-id="2cf0e-801">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></span></span></permission>
        <altmember cref="T:System.Reflection.AssemblyName" />
        <related type="Article" href="~/docs/framework/deployment/how-the-runtime-locates-assemblies.md"><span data-ttu-id="2cf0e-802">Como o tempo de execução localiza assemblies</span><span class="sxs-lookup"><span data-stu-id="2cf0e-802">How the Runtime Locates Assemblies</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly Load (string assemblyString);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly Load(string assemblyString) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.Load(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Load (assemblyString As String) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ Load(System::String ^ assemblyString);" />
      <MemberSignature Language="F#" Value="static member Load : string -&gt; System.Reflection.Assembly" Usage="System.Reflection.Assembly.Load assemblyString" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyString" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="assemblyString"><span data-ttu-id="2cf0e-803">O formato longo do nome do assembly.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-803">The long form of the assembly name.</span></span></param>
        <summary><span data-ttu-id="2cf0e-804">Carrega um assembly tendo o formato longo de seu nome.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-804">Loads an assembly given the long form of its name.</span></span></summary>
        <returns><span data-ttu-id="2cf0e-805">O assembly carregado.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-805">The loaded assembly.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2cf0e-806">O formato longo de um nome de assembly consiste em seu nome simple (como "sistema" para o assembly System. dll), juntamente com sua versão, cultura, token de chave pública e, opcionalmente, sua arquitetura de processador.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-806">The long form of an assembly name consists of its simple name (such as "System" for the System.dll assembly) along with its version, culture, public key token, and optionally its processor architecture.</span></span> <span data-ttu-id="2cf0e-807">Ele corresponde do assembly <xref:System.Reflection.Assembly.FullName%2A> propriedade.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-807">It corresponds to the assembly's <xref:System.Reflection.Assembly.FullName%2A> property.</span></span> <span data-ttu-id="2cf0e-808">O exemplo a seguir ilustra o uso de um nome longo para carregar o assembly System. dll para o .NET Framework 4.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-808">The following example illustrates the use of a long name to load the System.dll assembly for the .NET Framework 4.</span></span>  
  
 [!code-csharp[System.Reflection.Assembly.Load#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.reflection.assembly.load/cs/load1.cs#1)]
 [!code-vb[System.Reflection.Assembly.Load#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.reflection.assembly.load/vb/load1.vb#1)]  
  
 <span data-ttu-id="2cf0e-809"><xref:System.IO.FileLoadException> será gerada se `assemblyString` Especifica o nome completo do assembly e o primeiro conjunto que corresponde ao nome simple tem uma versão diferente, uma cultura ou um token de chave pública.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-809"><xref:System.IO.FileLoadException> is thrown if `assemblyString` specifies the full assembly name, and the first assembly that matches the simple name has a different version, culture, or public key token.</span></span> <span data-ttu-id="2cf0e-810">O carregador não continuar a sondagem de outros assemblies que correspondem ao nome simple.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-810">The loader does not continue probing for other assemblies that match the simple name.</span></span>  
  
 <span data-ttu-id="2cf0e-811">Se determinadas permissões são concedidas ou não a um assembly é algo que se baseia na evidência.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-811">Whether certain permissions are granted or not granted to an assembly is based on evidence.</span></span> <span data-ttu-id="2cf0e-812">As regras para o assembly e a mesclagem de evidência de segurança são da seguinte maneira:</span><span class="sxs-lookup"><span data-stu-id="2cf0e-812">The rules for assembly and security evidence merging are as follows:</span></span>  
  
-   <span data-ttu-id="2cf0e-813">Quando você usa um <xref:System.Reflection.Assembly.Load%2A> método sem nenhum <xref:System.Security.Policy.Evidence> parâmetro, o assembly é carregado com a evidência que fornece o carregador.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-813">When you use a <xref:System.Reflection.Assembly.Load%2A> method with no <xref:System.Security.Policy.Evidence> parameter, the assembly is loaded with the evidence that the loader supplies.</span></span>  
  
-   <span data-ttu-id="2cf0e-814">Quando você usa um <xref:System.Reflection.Assembly.Load%2A> método com um <xref:System.Security.Policy.Evidence> parâmetro, partes de evidências são mesclados.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-814">When you use a <xref:System.Reflection.Assembly.Load%2A> method with an <xref:System.Security.Policy.Evidence> parameter, pieces of evidence are merged.</span></span> <span data-ttu-id="2cf0e-815">Partes de evidências fornecida como um argumento para o <xref:System.Reflection.Assembly.Load%2A> método substituir partes de evidências fornecida pelo carregador.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-815">Pieces of evidence supplied as an argument to the <xref:System.Reflection.Assembly.Load%2A> method supersede pieces of evidence supplied by the loader.</span></span>  
  
-   <span data-ttu-id="2cf0e-816">Quando você usa um <xref:System.Reflection.Assembly.Load%2A> sobrecarga de método com um `Byte[]` parâmetro para carregar uma objeto arquivo formato COFF imagem comum, evidência é herdado do assembly de chamada.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-816">When you use a <xref:System.Reflection.Assembly.Load%2A> method overload with a `Byte[]` parameter to load a common object file format (COFF) image, evidence is inherited from the calling assembly.</span></span> <span data-ttu-id="2cf0e-817">Isso se aplica ao .NET Framework versão 1.1 Service Pack 1 (SP1) e versões posteriores.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-817">This applies to the .NET Framework version 1.1 Service Pack 1 (SP1) and subsequent releases.</span></span>  
  
    > [!NOTE]
    >  <span data-ttu-id="2cf0e-818">No .NET Framework versão 1.0 e na versão 1.1, sem o SP1, quando você usa um <xref:System.Reflection.Assembly.Load%2A> sobrecarga de método com um `Byte[]` parâmetro para carregar uma imagem COFF, evidência é combinado.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-818">In the .NET Framework version 1.0 and in version 1.1 without SP1, when you use a <xref:System.Reflection.Assembly.Load%2A> method overload with a `Byte[]` parameter to load a COFF image, evidence is combined.</span></span> <span data-ttu-id="2cf0e-819">`Zone`, `Url` e `Site` são herdadas do assembly de chamada, e `Hash` e `StrongName` são obtidos do assembly COFF.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-819">`Zone`, `Url` and `Site` are inherited from the calling assembly, and `Hash` and `StrongName` are taken from the COFF assembly.</span></span>  
  
-   <span data-ttu-id="2cf0e-820">Quando você usa um <xref:System.Reflection.Assembly.Load%2A> método com um `Byte[]` parâmetro e <xref:System.Security.Policy.Evidence> para carregar uma imagem COFF, somente a evidência fornecida é usada.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-820">When you use a <xref:System.Reflection.Assembly.Load%2A> method with a `Byte[]` parameter and <xref:System.Security.Policy.Evidence> to load a COFF image, only the supplied evidence is used.</span></span> <span data-ttu-id="2cf0e-821">Evidência do assembly de chamada e evidência da imagem COFF são ignorados.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-821">Evidence of the calling assembly and evidence of the COFF image is ignored.</span></span>  
  
 <span data-ttu-id="2cf0e-822">Refletir em arquivos executáveis C++ pode gerar um <xref:System.BadImageFormatException>.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-822">Reflecting on C++ executable files might throw a <xref:System.BadImageFormatException>.</span></span> <span data-ttu-id="2cf0e-823">Isso provavelmente é causado pelo compilador C++ os endereços de realocação ou a `.reloc` seção do seu arquivo executável.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-823">This is most likely caused by the C++ compiler stripping the relocation addresses or the `.reloc` section from your executable file.</span></span> <span data-ttu-id="2cf0e-824">Para preservar os `.reloc` endereço para seu arquivo executável do C++, especifique `/fixed:no` quando você está vinculando.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-824">To preserve the `.reloc` address for your C++ executable file, specify `/fixed:no` when you are linking.</span></span>  
  
 <span data-ttu-id="2cf0e-825">No .NET Framework versão 2.0, a arquitetura do processador é adicionada à identidade do assembly e pode ser especificada como parte das cadeias de caracteres de nome do assembly.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-825">In the .NET Framework version 2.0, processor architecture is added to assembly identity, and can be specified as part of assembly name strings.</span></span> <span data-ttu-id="2cf0e-826">Por exemplo, "ProcessorArchitecture=msil".</span><span class="sxs-lookup"><span data-stu-id="2cf0e-826">For example, "ProcessorArchitecture=msil".</span></span> <span data-ttu-id="2cf0e-827">No entanto, a maneira recomendada para especificar um nome de assembly é criar uma <xref:System.Reflection.AssemblyName> do objeto e passá-lo para uma sobrecarga apropriada do <xref:System.Reflection.Assembly.Load%2A> método.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-827">However, the recommended way to specify an assembly name is to create an <xref:System.Reflection.AssemblyName> object and pass it to an appropriate overload of the <xref:System.Reflection.Assembly.Load%2A> method.</span></span> <span data-ttu-id="2cf0e-828">Consulte <xref:System.Reflection.AssemblyName.ProcessorArchitecture%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-828">See <xref:System.Reflection.AssemblyName.ProcessorArchitecture%2A?displayProperty=nameWithType>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="2cf0e-829">O exemplo a seguir carrega um assembly dado seu nome totalmente qualificado e lista todos os tipos contidos no assembly especificado.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-829">The following example loads an assembly given its fully qualified name, and lists all the types contained in the specified assembly.</span></span> <span data-ttu-id="2cf0e-830">Para este exemplo de código ser executado, você deve fornecer o nome de assembly totalmente qualificado.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-830">For this code example to run, you must provide the fully qualified assembly name.</span></span> <span data-ttu-id="2cf0e-831">Para obter informações sobre como obter o nome totalmente qualificado do assembly, consulte [nomes de Assembly](~/docs/framework/app-domains/assembly-names.md).</span><span class="sxs-lookup"><span data-stu-id="2cf0e-831">For information about how to obtain the fully qualified assembly name, see [Assembly Names](~/docs/framework/app-domains/assembly-names.md).</span></span>  
  
 [!code-cpp[assembly.load1#1](~/samples/snippets/cpp/VS_Snippets_CLR/Assembly.Load1/CPP/load1.cpp#1)]
 [!code-csharp[assembly.load1#1](~/samples/snippets/csharp/VS_Snippets_CLR/Assembly.Load1/CS/load1.cs#1)]
 [!code-vb[assembly.load1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Assembly.Load1/VB/load1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="2cf0e-832"><paramref name="assemblyString" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-832"><paramref name="assemblyString" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="2cf0e-833"><paramref name="assemblyString" /> é uma cadeia de comprimento zero.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-833"><paramref name="assemblyString" /> is a zero-length string.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="2cf0e-834"><paramref name="assemblyString" /> não foi encontrado.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-834"><paramref name="assemblyString" /> is not found.</span></span></exception>
        <exception cref="T:System.IO.FileLoadException"><span data-ttu-id="2cf0e-835">Não foi possível carregar um arquivo que foi encontrado.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-835">A file that was found could not be loaded.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="2cf0e-836"><paramref name="assemblyString" /> não é um assembly válido.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-836"><paramref name="assemblyString" /> is not a valid assembly.</span></span>  
  
<span data-ttu-id="2cf0e-837">- ou -</span><span class="sxs-lookup"><span data-stu-id="2cf0e-837">-or-</span></span> 
<span data-ttu-id="2cf0e-838">A versão 2,0 ou posterior do Common Language Runtime está carregada e <paramref name="assemblyString" /> foi compilada com uma versão posterior.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-838">Version 2.0 or later of the common language runtime is currently loaded and <paramref name="assemblyString" /> was compiled with a later version.</span></span></exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="2cf0e-839">para carregar um assembly com evidências.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-839">to load an assembly with evidence.</span></span> <span data-ttu-id="2cf0e-840">Enumeração associada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></span><span class="sxs-lookup"><span data-stu-id="2cf0e-840">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></span></span></permission>
        <altmember cref="T:System.Reflection.AssemblyName" />
        <altmember cref="M:System.Reflection.Assembly.LoadFrom(System.String)" />
        <related type="Article" href="~/docs/framework/deployment/how-the-runtime-locates-assemblies.md"><span data-ttu-id="2cf0e-841">Como o tempo de execução localiza assemblies</span><span class="sxs-lookup"><span data-stu-id="2cf0e-841">How the Runtime Locates Assemblies</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly Load (byte[] rawAssembly, byte[] rawSymbolStore);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly Load(unsigned int8[] rawAssembly, unsigned int8[] rawSymbolStore) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.Load(System.Byte[],System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Load (rawAssembly As Byte(), rawSymbolStore As Byte()) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ Load(cli::array &lt;System::Byte&gt; ^ rawAssembly, cli::array &lt;System::Byte&gt; ^ rawSymbolStore);" />
      <MemberSignature Language="F#" Value="static member Load : byte[] * byte[] -&gt; System.Reflection.Assembly" Usage="System.Reflection.Assembly.Load (rawAssembly, rawSymbolStore)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rawAssembly" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="rawSymbolStore" Type="System.Byte[]" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="rawAssembly"><span data-ttu-id="2cf0e-842">Uma matriz de byte que é uma imagem baseada em COFF contendo um assembly emitido.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-842">A byte array that is a COFF-based image containing an emitted assembly.</span></span></param>
        <param name="rawSymbolStore"><span data-ttu-id="2cf0e-843">Uma matriz de bytes que contém os bytes brutos que representam os símbolos do assembly.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-843">A byte array that contains the raw bytes representing the symbols for the assembly.</span></span></param>
        <summary><span data-ttu-id="2cf0e-844">Carrega o assembly com uma imagem baseada em formato COFF, contendo um assembly emitido e com a opção de incluir símbolos para o assembly.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-844">Loads the assembly with a common object file format (COFF)-based image containing an emitted assembly, optionally including symbols for the assembly.</span></span> <span data-ttu-id="2cf0e-845">O assembly é carregado no domínio de aplicativo do chamador.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-845">The assembly is loaded into the application domain of the caller.</span></span></summary>
        <returns><span data-ttu-id="2cf0e-846">O assembly carregado.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-846">The loaded assembly.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2cf0e-847">O nível de confiança de um assembly que é carregado usando esse método é o mesmo que o nível de confiança do assembly de chamada.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-847">The trust level of an assembly that is loaded by using this method is the same as the trust level of the calling assembly.</span></span> <span data-ttu-id="2cf0e-848">Para carregar um assembly de uma matriz de bytes com o nível de confiança do domínio do aplicativo, use o <xref:System.Reflection.Assembly.Load%28System.Byte%5B%5D%2CSystem.Byte%5B%5D%2CSystem.Security.SecurityContextSource%29> sobrecarga de método.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-848">To load an assembly from a byte array with the trust level of the application domain, use the <xref:System.Reflection.Assembly.Load%28System.Byte%5B%5D%2CSystem.Byte%5B%5D%2CSystem.Security.SecurityContextSource%29> method overload.</span></span> <span data-ttu-id="2cf0e-849">Para obter mais informações sobre o uso de evidências com sobrecargas do <xref:System.Reflection.Assembly.Load%2A> método que levam a matrizes de bytes, consulte o <xref:System.Reflection.Assembly.Load%28System.Byte%5B%5D%2CSystem.Byte%5B%5D%2CSystem.Security.Policy.Evidence%29> sobrecarga de método.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-849">For more information about the use of evidence with overloads of the <xref:System.Reflection.Assembly.Load%2A> method that take byte arrays, see the <xref:System.Reflection.Assembly.Load%28System.Byte%5B%5D%2CSystem.Byte%5B%5D%2CSystem.Security.Policy.Evidence%29> method overload.</span></span>  
  
 <span data-ttu-id="2cf0e-850">Refletir em arquivos executáveis C++ pode gerar um <xref:System.BadImageFormatException>.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-850">Reflecting on C++ executable files might throw a <xref:System.BadImageFormatException>.</span></span> <span data-ttu-id="2cf0e-851">Isso provavelmente é causado pelo compilador C++ os endereços de realocação ou a `.reloc` seção do seu arquivo executável.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-851">This is most likely caused by the C++ compiler stripping the relocation addresses or the `.reloc` section from your executable file.</span></span> <span data-ttu-id="2cf0e-852">Para preservar os `.reloc` endereço para seu arquivo executável do C++, especifique `/fixed:no` quando você está vinculando.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-852">To preserve the `.reloc` address for your C++ executable file, specify `/fixed:no` when you are linking.</span></span>  
  
 <span data-ttu-id="2cf0e-853">Observe que essa sobrecarga de método sempre cria um novo <xref:System.Reflection.Assembly> objeto com seu próprio mapeamento.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-853">Note that this method overload always creates a new <xref:System.Reflection.Assembly> object with its own mapping.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="2cf0e-854"><paramref name="rawAssembly" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-854"><paramref name="rawAssembly" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="2cf0e-855"><paramref name="rawAssembly" /> não é um assembly válido.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-855"><paramref name="rawAssembly" /> is not a valid assembly.</span></span>  
  
<span data-ttu-id="2cf0e-856">- ou -</span><span class="sxs-lookup"><span data-stu-id="2cf0e-856">-or-</span></span> 
<span data-ttu-id="2cf0e-857">A versão 2,0 ou posterior do Common Language Runtime está carregada e <paramref name="rawAssembly" /> foi compilada com uma versão posterior.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-857">Version 2.0 or later of the common language runtime is currently loaded and <paramref name="rawAssembly" /> was compiled with a later version.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly Load (System.Reflection.AssemblyName assemblyRef, System.Security.Policy.Evidence assemblySecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly Load(class System.Reflection.AssemblyName assemblyRef, class System.Security.Policy.Evidence assemblySecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.Load(System.Reflection.AssemblyName,System.Security.Policy.Evidence)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Load (assemblyRef As AssemblyName, assemblySecurity As Evidence) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ Load(System::Reflection::AssemblyName ^ assemblyRef, System::Security::Policy::Evidence ^ assemblySecurity);" />
      <MemberSignature Language="F#" Value="static member Load : System.Reflection.AssemblyName * System.Security.Policy.Evidence -&gt; System.Reflection.Assembly" Usage="System.Reflection.Assembly.Load (assemblyRef, assemblySecurity)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("This method is obsolete and will be removed in a future release of the .NET Framework. Please use an overload of Load which does not take an Evidence parameter. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyRef" Type="System.Reflection.AssemblyName" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="assemblySecurity" Type="System.Security.Policy.Evidence" Index="1" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="assemblyRef"><span data-ttu-id="2cf0e-858">O objeto que descreve o assembly a ser carregado.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-858">The object that describes the assembly to be loaded.</span></span></param>
        <param name="assemblySecurity"><span data-ttu-id="2cf0e-859">Evidência para carregar o assembly.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-859">Evidence for loading the assembly.</span></span></param>
        <summary><span data-ttu-id="2cf0e-860">Carrega um assembly de acordo com seu <see cref="T:System.Reflection.AssemblyName" />.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-860">Loads an assembly given its <see cref="T:System.Reflection.AssemblyName" />.</span></span> <span data-ttu-id="2cf0e-861">O assembly é carregado no domínio do chamador usando a evidência fornecida.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-861">The assembly is loaded into the domain of the caller using the supplied evidence.</span></span></summary>
        <returns><span data-ttu-id="2cf0e-862">O assembly carregado.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-862">The loaded assembly.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2cf0e-863"><xref:System.IO.FileLoadException> será gerada se `assemblyRef` Especifica o nome completo do assembly e o primeiro conjunto que corresponde ao nome simple tem uma versão diferente, uma cultura ou um token de chave pública.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-863"><xref:System.IO.FileLoadException> is thrown if `assemblyRef` specifies the full assembly name, and the first assembly that matches the simple name has a different version, culture, or public key token.</span></span> <span data-ttu-id="2cf0e-864">O carregador não continuar a sondagem de outros assemblies que correspondem ao nome simple.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-864">The loader does not continue probing for other assemblies that match the simple name.</span></span>  <span data-ttu-id="2cf0e-865">Começando com o .NET Framework 4, porque a execução do código em assemblies remotos está desabilitada por padrão, uma <xref:System.IO.FileLoadException> também será gerada se `assemblyRef` Especifica um assembly remoto.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-865">Starting with .NET Framework 4, because execution of code in remote assemblies is disabled by default, a <xref:System.IO.FileLoadException> is also thrown if `assemblyRef` specifies a remote assembly.</span></span> <span data-ttu-id="2cf0e-866">Para habilitar a execução de código carregado a partir de locais remotos, você pode usar o [ `<loadFromRemoteSources>` ](~/docs/framework/configure-apps/file-schema/runtime/loadfromremotesources-element.md) elemento de configuração.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-866">To enable execution of code loaded from remote locations, you can use the [`<loadFromRemoteSources>`](~/docs/framework/configure-apps/file-schema/runtime/loadfromremotesources-element.md) configuration element.</span></span>   
  
> [!NOTE]
>  <span data-ttu-id="2cf0e-867">Não use uma <xref:System.Reflection.AssemblyName> apenas com o <xref:System.Reflection.AssemblyName.CodeBase%2A> conjunto de propriedades.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-867">Do not use an <xref:System.Reflection.AssemblyName> with only the <xref:System.Reflection.AssemblyName.CodeBase%2A> property set.</span></span> <span data-ttu-id="2cf0e-868">O <xref:System.Reflection.AssemblyName.CodeBase%2A> propriedade não fornece todos os elementos da identidade do assembly (por exemplo, nome ou versão), então, carregando não ocorra de acordo com as regras de carregamento por identidade, como você esperaria do <xref:System.Reflection.Assembly.Load%2A> método.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-868">The <xref:System.Reflection.AssemblyName.CodeBase%2A> property does not supply any elements of the assembly identity (such as name or version), so loading does not occur according to load-by-identity rules, as you would expect from the <xref:System.Reflection.Assembly.Load%2A> method.</span></span> <span data-ttu-id="2cf0e-869">Em vez disso, o assembly é carregado usando as regras de carga.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-869">Instead, the assembly is loaded using load-from rules.</span></span> <span data-ttu-id="2cf0e-870">Para obter informações sobre as desvantagens de usar o contexto de carga, consulte o <xref:System.Reflection.Assembly.LoadFrom%2A?displayProperty=nameWithType> sobrecarga de método ou [as práticas recomendadas para carregamento de Assembly](~/docs/framework/deployment/best-practices-for-assembly-loading.md).</span><span class="sxs-lookup"><span data-stu-id="2cf0e-870">For information about the disadvantages of using the load-from context, see the <xref:System.Reflection.Assembly.LoadFrom%2A?displayProperty=nameWithType> method overload or [Best Practices for Assembly Loading](~/docs/framework/deployment/best-practices-for-assembly-loading.md).</span></span>  
  
 <span data-ttu-id="2cf0e-871">Se determinadas permissões são concedidas ou não a um assembly é algo que se baseia na evidência.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-871">Whether certain permissions are granted or not granted to an assembly is based on evidence.</span></span> <span data-ttu-id="2cf0e-872">As regras para o assembly e a mesclagem de evidência de segurança são da seguinte maneira:</span><span class="sxs-lookup"><span data-stu-id="2cf0e-872">The rules for assembly and security evidence merging are as follows:</span></span>  
  
-   <span data-ttu-id="2cf0e-873">Quando você usa um <xref:System.Reflection.Assembly.Load%2A> método sem nenhum <xref:System.Security.Policy.Evidence> parâmetro, o assembly é carregado com a evidência que fornece o carregador.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-873">When you use a <xref:System.Reflection.Assembly.Load%2A> method with no <xref:System.Security.Policy.Evidence> parameter, the assembly is loaded with the evidence that the loader supplies.</span></span>  
  
-   <span data-ttu-id="2cf0e-874">Quando você usa um <xref:System.Reflection.Assembly.Load%2A> método com um <xref:System.Security.Policy.Evidence> parâmetro, partes de evidências são mesclados.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-874">When you use a <xref:System.Reflection.Assembly.Load%2A> method with an <xref:System.Security.Policy.Evidence> parameter, pieces of evidence are merged.</span></span> <span data-ttu-id="2cf0e-875">Partes de evidências fornecida como um argumento para o <xref:System.Reflection.Assembly.Load%2A> método substituir partes de evidências fornecida pelo carregador.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-875">Pieces of evidence supplied as an argument to the <xref:System.Reflection.Assembly.Load%2A> method supersede pieces of evidence supplied by the loader.</span></span>  
  
-   <span data-ttu-id="2cf0e-876">Quando você usa um <xref:System.Reflection.Assembly.Load%2A> sobrecarga de método com um `Byte[]` parâmetro para carregar uma objeto arquivo formato COFF imagem comum, evidência é herdado do assembly de chamada.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-876">When you use a <xref:System.Reflection.Assembly.Load%2A> method overload with a `Byte[]` parameter to load a common object file format (COFF) image, evidence is inherited from the calling assembly.</span></span> <span data-ttu-id="2cf0e-877">Isso se aplica ao .NET Framework versão 1.1 Service Pack 1 (SP1) e versões posteriores.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-877">This applies to the .NET Framework version 1.1 Service Pack 1 (SP1) and subsequent releases.</span></span>  
  
    > [!NOTE]
    >  <span data-ttu-id="2cf0e-878">No .NET Framework versão 1.0 e na versão 1.1, sem o SP1, quando você usa um <xref:System.Reflection.Assembly.Load%2A> sobrecarga de método com um `Byte[]` parâmetro para carregar uma imagem COFF, evidência é combinado.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-878">In the .NET Framework version 1.0 and in version 1.1 without SP1, when you use a <xref:System.Reflection.Assembly.Load%2A> method overload with a `Byte[]` parameter to load a COFF image, evidence is combined.</span></span> <span data-ttu-id="2cf0e-879">`Zone`, `Url` e `Site` são herdadas do assembly de chamada, e `Hash` e `StrongName` são obtidos do assembly COFF.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-879">`Zone`, `Url` and `Site` are inherited from the calling assembly, and `Hash` and `StrongName` are taken from the COFF assembly.</span></span>  
  
-   <span data-ttu-id="2cf0e-880">Quando você usa um <xref:System.Reflection.Assembly.Load%2A> método com um `Byte[]` parâmetro e <xref:System.Security.Policy.Evidence> para carregar uma imagem COFF, somente a evidência fornecida é usada.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-880">When you use a <xref:System.Reflection.Assembly.Load%2A> method with a `Byte[]` parameter and <xref:System.Security.Policy.Evidence> to load a COFF image, only the supplied evidence is used.</span></span> <span data-ttu-id="2cf0e-881">Evidência do assembly de chamada e evidência da imagem COFF são ignorados.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-881">Evidence of the calling assembly and evidence of the COFF image is ignored.</span></span>  
  
 <span data-ttu-id="2cf0e-882">Refletir em arquivos executáveis C++ pode gerar um <xref:System.BadImageFormatException>.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-882">Reflecting on C++ executable files might throw a <xref:System.BadImageFormatException>.</span></span> <span data-ttu-id="2cf0e-883">Isso provavelmente é causado pelo compilador C++ os endereços de realocação ou a `.reloc` seção do seu arquivo executável.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-883">This is most likely caused by the C++ compiler stripping the relocation addresses or the `.reloc` section from your executable file.</span></span> <span data-ttu-id="2cf0e-884">Para preservar os `.reloc` endereço para seu arquivo executável do C++, especifique `/fixed:no` quando você está vinculando.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-884">To preserve the `.reloc` address for your C++ executable file, specify `/fixed:no` when you are linking.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="2cf0e-885">Se ambos o <xref:System.Reflection.AssemblyName.Name%2A?displayProperty=nameWithType> propriedade e o <xref:System.Reflection.AssemblyName.CodeBase%2A?displayProperty=nameWithType> estiverem definidas, a primeira tentativa de carregar o assembly usa o nome de exibição (incluindo a versão, cultura e assim por diante, conforme retornado pelo <xref:System.Reflection.Assembly.FullName%2A?displayProperty=nameWithType> propriedade).</span><span class="sxs-lookup"><span data-stu-id="2cf0e-885">If both the <xref:System.Reflection.AssemblyName.Name%2A?displayProperty=nameWithType> property and the <xref:System.Reflection.AssemblyName.CodeBase%2A?displayProperty=nameWithType> property are set, the first attempt to load the assembly uses the display name (including version, culture, and so on, as returned by the <xref:System.Reflection.Assembly.FullName%2A?displayProperty=nameWithType> property).</span></span> <span data-ttu-id="2cf0e-886">Se o arquivo não for encontrado, <xref:System.Reflection.AssemblyName.CodeBase%2A> é usado para pesquisar o assembly.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-886">If the file is not found, <xref:System.Reflection.AssemblyName.CodeBase%2A> is used to search for the assembly.</span></span> <span data-ttu-id="2cf0e-887">Se o assembly for encontrado usando <xref:System.Reflection.AssemblyName.CodeBase%2A>, o nome de exibição é comparado com o assembly.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-887">If the assembly is found using <xref:System.Reflection.AssemblyName.CodeBase%2A>, the display name is matched against the assembly.</span></span> <span data-ttu-id="2cf0e-888">Se a correspondência falhar, um <xref:System.IO.FileLoadException> é gerada.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-888">If the match fails, a <xref:System.IO.FileLoadException> is thrown.</span></span>  
  
 <span data-ttu-id="2cf0e-889">Se você chamar o <xref:System.Reflection.Assembly.Load%2A> método mais de uma vez no mesmo assembly, mas com uma evidência diferente especificada, o common language runtime não gerará um <xref:System.IO.FileLoadException> porque a igualdade e a integridade das especificações de evidências diferentes não podem ser determinado.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-889">If you call the <xref:System.Reflection.Assembly.Load%2A> method more than once on the same assembly but with a different evidence specified, the common language runtime does not throw a <xref:System.IO.FileLoadException> because the equality and integrity of the different evidence specifications cannot be determined.</span></span> <span data-ttu-id="2cf0e-890">A evidência que vem primeiro é a evidência que é usada.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-890">The evidence that first succeeds is the evidence that is used.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="2cf0e-891"><paramref name="assemblyRef" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-891"><paramref name="assemblyRef" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="2cf0e-892"><paramref name="assemblyRef" /> não foi encontrado.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-892"><paramref name="assemblyRef" /> is not found.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="2cf0e-893"><paramref name="assemblyRef" /> não é um assembly válido.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-893"><paramref name="assemblyRef" /> is not a valid assembly.</span></span>  
  
<span data-ttu-id="2cf0e-894">- ou -</span><span class="sxs-lookup"><span data-stu-id="2cf0e-894">-or-</span></span> 
<span data-ttu-id="2cf0e-895">A versão 2,0 ou posterior do Common Language Runtime está carregada e <paramref name="assemblyRef" /> foi compilada com uma versão posterior.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-895">Version 2.0 or later of the common language runtime is currently loaded and <paramref name="assemblyRef" /> was compiled with a later version.</span></span></exception>
        <exception cref="T:System.IO.FileLoadException"><span data-ttu-id="2cf0e-896">Um assembly ou módulo foi carregado duas vezes em com duas evidências diferentes.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-896">An assembly or module was loaded twice with two different evidences.</span></span>

<span data-ttu-id="2cf0e-897">- ou -</span><span class="sxs-lookup"><span data-stu-id="2cf0e-897">-or-</span></span>

<span data-ttu-id="2cf0e-898"><paramref name="assemblyRef" /> especifica um assembly remoto, mas a capacidade de executar código em assemblies remotos é desabilitada.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-898"><paramref name="assemblyRef" /> specifies a remote assembly, but the ability to execute code in remote assemblies is disabled.</span></span> <span data-ttu-id="2cf0e-899">Veja <see href="https://docs.microsoft.com/dotnet/framework/configure-apps/file-schema/runtime/loadfromremotesources-element">&lt;loadFromRemoteSources&gt;</see>.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-899">See <see href="https://docs.microsoft.com/dotnet/framework/configure-apps/file-schema/runtime/loadfromremotesources-element">&lt;loadFromRemoteSources&gt;</see>.</span></span></exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission"><span data-ttu-id="2cf0e-900">para acesso de leitura de um arquivo ou um diretório, e para acesso às informações no próprio caminho.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-900">for access to read from a file or directory, and for access to the information in the path itself.</span></span> <span data-ttu-id="2cf0e-901">Enumerações associadas: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></span><span class="sxs-lookup"><span data-stu-id="2cf0e-901">Associated enumerations: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></span></span></permission>
        <permission cref="T:System.Net.WebPermission"><span data-ttu-id="2cf0e-902">para ler um URI que não começa com "file://".</span><span class="sxs-lookup"><span data-stu-id="2cf0e-902">for reading a URI that does not begin with "file://".</span></span></permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="2cf0e-903">para carregar um assembly com evidências.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-903">to load an assembly with evidence.</span></span> <span data-ttu-id="2cf0e-904">Enumeração associada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></span><span class="sxs-lookup"><span data-stu-id="2cf0e-904">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></span></span></permission>
        <altmember cref="T:System.Security.Policy.Evidence" />
        <related type="Article" href="~/docs/framework/deployment/how-the-runtime-locates-assemblies.md"><span data-ttu-id="2cf0e-905">Como o tempo de execução localiza assemblies</span><span class="sxs-lookup"><span data-stu-id="2cf0e-905">How the Runtime Locates Assemblies</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly Load (string assemblyString, System.Security.Policy.Evidence assemblySecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly Load(string assemblyString, class System.Security.Policy.Evidence assemblySecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.Load(System.String,System.Security.Policy.Evidence)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Load (assemblyString As String, assemblySecurity As Evidence) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ Load(System::String ^ assemblyString, System::Security::Policy::Evidence ^ assemblySecurity);" />
      <MemberSignature Language="F#" Value="static member Load : string * System.Security.Policy.Evidence -&gt; System.Reflection.Assembly" Usage="System.Reflection.Assembly.Load (assemblyString, assemblySecurity)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("This method is obsolete and will be removed in a future release of the .NET Framework. Please use an overload of Load which does not take an Evidence parameter. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyString" Type="System.String" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="assemblySecurity" Type="System.Security.Policy.Evidence" Index="1" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="assemblyString"><span data-ttu-id="2cf0e-906">O nome para exibição do assembly.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-906">The display name of the assembly.</span></span></param>
        <param name="assemblySecurity"><span data-ttu-id="2cf0e-907">Evidência para carregar o assembly.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-907">Evidence for loading the assembly.</span></span></param>
        <summary><span data-ttu-id="2cf0e-908">Carrega um assembly dado seu nome de exibição, carregando-o no domínio do chamador usando a evidência fornecida.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-908">Loads an assembly given its display name, loading the assembly into the domain of the caller using the supplied evidence.</span></span></summary>
        <returns><span data-ttu-id="2cf0e-909">O assembly carregado.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-909">The loaded assembly.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2cf0e-910"><xref:System.IO.FileLoadException> será gerada se `assemblyString` Especifica o nome completo do assembly e o primeiro conjunto que corresponde ao nome simple tem uma versão diferente, uma cultura ou um token de chave pública.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-910"><xref:System.IO.FileLoadException> is thrown if `assemblyString` specifies the full assembly name, and the first assembly that matches the simple name has a different version, culture, or public key token.</span></span> <span data-ttu-id="2cf0e-911">O carregador não continuar a sondagem de outros assemblies que correspondem ao nome simple.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-911">The loader does not continue probing for other assemblies that match the simple name.</span></span>  
  
 <span data-ttu-id="2cf0e-912">Se determinadas permissões são concedidas ou não a um assembly é algo que se baseia na evidência.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-912">Whether certain permissions are granted or not granted to an assembly is based on evidence.</span></span> <span data-ttu-id="2cf0e-913">As regras para o assembly e a mesclagem de evidência de segurança são da seguinte maneira:</span><span class="sxs-lookup"><span data-stu-id="2cf0e-913">The rules for assembly and security evidence merging are as follows:</span></span>  
  
-   <span data-ttu-id="2cf0e-914">Quando você usa um <xref:System.Reflection.Assembly.Load%2A> método sem nenhum <xref:System.Security.Policy.Evidence> parâmetro, o assembly é carregado com a evidência que fornece o carregador.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-914">When you use a <xref:System.Reflection.Assembly.Load%2A> method with no <xref:System.Security.Policy.Evidence> parameter, the assembly is loaded with the evidence that the loader supplies.</span></span>  
  
-   <span data-ttu-id="2cf0e-915">Quando você usa um <xref:System.Reflection.Assembly.Load%2A> método com um <xref:System.Security.Policy.Evidence> parâmetro, partes de evidências são mesclados.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-915">When you use a <xref:System.Reflection.Assembly.Load%2A> method with an <xref:System.Security.Policy.Evidence> parameter, pieces of evidence are merged.</span></span> <span data-ttu-id="2cf0e-916">Partes de evidências fornecida como um argumento para o <xref:System.Reflection.Assembly.Load%2A> método substituir partes de evidências fornecida pelo carregador.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-916">Pieces of evidence supplied as an argument to the <xref:System.Reflection.Assembly.Load%2A> method supersede pieces of evidence supplied by the loader.</span></span>  
  
-   <span data-ttu-id="2cf0e-917">Quando você usa um <xref:System.Reflection.Assembly.Load%2A> sobrecarga de método com um `Byte[]` parâmetro para carregar uma objeto arquivo formato COFF imagem comum, evidência é herdado do assembly de chamada.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-917">When you use a <xref:System.Reflection.Assembly.Load%2A> method overload with a `Byte[]` parameter to load a common object file format (COFF) image, evidence is inherited from the calling assembly.</span></span> <span data-ttu-id="2cf0e-918">Isso se aplica ao .NET Framework versão 1.1 Service Pack 1 (SP1) e versões posteriores.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-918">This applies to the .NET Framework version 1.1 Service Pack 1 (SP1) and subsequent releases.</span></span>  
  
    > [!NOTE]
    >  <span data-ttu-id="2cf0e-919">No .NET Framework versão 1.0 e na versão 1.1, sem o SP1, quando você usa um <xref:System.Reflection.Assembly.Load%2A> sobrecarga de método com um `Byte[]` parâmetro para carregar uma imagem COFF, evidência é combinado.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-919">In the .NET Framework version 1.0 and in version 1.1 without SP1, when you use a <xref:System.Reflection.Assembly.Load%2A> method overload with a `Byte[]` parameter to load a COFF image, evidence is combined.</span></span> <span data-ttu-id="2cf0e-920">`Zone`, `Url` e `Site` são herdadas do assembly de chamada, e `Hash` e `StrongName` são obtidos do assembly COFF.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-920">`Zone`, `Url` and `Site` are inherited from the calling assembly, and `Hash` and `StrongName` are taken from the COFF assembly.</span></span>  
  
-   <span data-ttu-id="2cf0e-921">Quando você usa um <xref:System.Reflection.Assembly.Load%2A> método com um `Byte[]` parâmetro e <xref:System.Security.Policy.Evidence> para carregar uma imagem COFF, somente a evidência fornecida é usada.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-921">When you use a <xref:System.Reflection.Assembly.Load%2A> method with a `Byte[]` parameter and <xref:System.Security.Policy.Evidence> to load a COFF image, only the supplied evidence is used.</span></span> <span data-ttu-id="2cf0e-922">Evidência do assembly de chamada e evidência da imagem COFF são ignorados.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-922">Evidence of the calling assembly and evidence of the COFF image is ignored.</span></span>  
  
 <span data-ttu-id="2cf0e-923">Refletir em arquivos executáveis C++ pode gerar um <xref:System.BadImageFormatException>.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-923">Reflecting on C++ executable files might throw a <xref:System.BadImageFormatException>.</span></span> <span data-ttu-id="2cf0e-924">Isso provavelmente é causado pelo compilador C++ os endereços de realocação ou a `.reloc` seção do seu arquivo executável.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-924">This is most likely caused by the C++ compiler stripping the relocation addresses or the `.reloc` section from your executable file.</span></span> <span data-ttu-id="2cf0e-925">Para preservar os `.reloc` endereço para seu arquivo executável do C++, especifique `/fixed:no` quando você está vinculando.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-925">To preserve the `.reloc` address for your C++ executable file, specify `/fixed:no` when you are linking.</span></span>  
  
 <span data-ttu-id="2cf0e-926">Se você chamar esse método mais de uma vez no mesmo assembly, mas com uma evidência diferente especificada, o common language runtime não lança uma <xref:System.IO.FileLoadException> porque não não possível determinar a igualdade e a integridade das especificações de evidências diferentes.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-926">If you call this method more than once on the same assembly but with a different evidence specified, the common language runtime does not throw a <xref:System.IO.FileLoadException> because the equality and integrity of the different evidence specifications cannot be determined.</span></span> <span data-ttu-id="2cf0e-927">A evidência que vem primeiro é a evidência que é usada.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-927">The evidence that first succeeds is the evidence that is used.</span></span>  
  
 <span data-ttu-id="2cf0e-928">No .NET Framework versão 2.0, a arquitetura do processador é adicionada à identidade do assembly e pode ser especificada como parte das cadeias de caracteres de nome do assembly.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-928">In the .NET Framework version 2.0, processor architecture is added to assembly identity, and can be specified as part of assembly name strings.</span></span> <span data-ttu-id="2cf0e-929">Por exemplo, "ProcessorArchitecture=msil".</span><span class="sxs-lookup"><span data-stu-id="2cf0e-929">For example, "ProcessorArchitecture=msil".</span></span> <span data-ttu-id="2cf0e-930">No entanto, a maneira recomendada para especificar um nome de assembly é criar uma <xref:System.Reflection.AssemblyName> do objeto e passá-lo para uma sobrecarga apropriada do <xref:System.Reflection.Assembly.Load%2A> método.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-930">However, the recommended way to specify an assembly name is to create an <xref:System.Reflection.AssemblyName> object and pass it to an appropriate overload of the <xref:System.Reflection.Assembly.Load%2A> method.</span></span> <span data-ttu-id="2cf0e-931">Consulte <xref:System.Reflection.AssemblyName.ProcessorArchitecture%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-931">See <xref:System.Reflection.AssemblyName.ProcessorArchitecture%2A?displayProperty=nameWithType>.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="2cf0e-932"><paramref name="assemblyString" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-932"><paramref name="assemblyString" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="2cf0e-933"><paramref name="assemblyString" /> não foi encontrado.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-933"><paramref name="assemblyString" /> is not found.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="2cf0e-934"><paramref name="assemblyString" /> não é um assembly válido.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-934"><paramref name="assemblyString" /> is not a valid assembly.</span></span>  
  
<span data-ttu-id="2cf0e-935">- ou -</span><span class="sxs-lookup"><span data-stu-id="2cf0e-935">-or-</span></span> 
<span data-ttu-id="2cf0e-936">A versão 2,0 ou posterior do Common Language Runtime está carregada e <paramref name="assemblyString" /> foi compilada com uma versão posterior.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-936">Version 2.0 or later of the common language runtime is currently loaded and <paramref name="assemblyString" /> was compiled with a later version.</span></span></exception>
        <exception cref="T:System.IO.FileLoadException"><span data-ttu-id="2cf0e-937">Não foi possível carregar um arquivo que foi encontrado.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-937">A file that was found could not be loaded.</span></span>  
  
<span data-ttu-id="2cf0e-938">- ou -</span><span class="sxs-lookup"><span data-stu-id="2cf0e-938">-or-</span></span> 
<span data-ttu-id="2cf0e-939">Um assembly ou módulo foi carregado duas vezes em com duas evidências diferentes.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-939">An assembly or module was loaded twice with two different evidences.</span></span></exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="2cf0e-940">para carregar um assembly com evidências.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-940">to load an assembly with evidence.</span></span> <span data-ttu-id="2cf0e-941">Enumeração associada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></span><span class="sxs-lookup"><span data-stu-id="2cf0e-941">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></span></span></permission>
        <altmember cref="T:System.Security.Policy.Evidence" />
        <related type="Article" href="~/docs/framework/deployment/how-the-runtime-locates-assemblies.md"><span data-ttu-id="2cf0e-942">Como o tempo de execução localiza assemblies</span><span class="sxs-lookup"><span data-stu-id="2cf0e-942">How the Runtime Locates Assemblies</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly Load (byte[] rawAssembly, byte[] rawSymbolStore, System.Security.Policy.Evidence securityEvidence);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly Load(unsigned int8[] rawAssembly, unsigned int8[] rawSymbolStore, class System.Security.Policy.Evidence securityEvidence) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.Load(System.Byte[],System.Byte[],System.Security.Policy.Evidence)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Load (rawAssembly As Byte(), rawSymbolStore As Byte(), securityEvidence As Evidence) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ Load(cli::array &lt;System::Byte&gt; ^ rawAssembly, cli::array &lt;System::Byte&gt; ^ rawSymbolStore, System::Security::Policy::Evidence ^ securityEvidence);" />
      <MemberSignature Language="F#" Value="static member Load : byte[] * byte[] * System.Security.Policy.Evidence -&gt; System.Reflection.Assembly" Usage="System.Reflection.Assembly.Load (rawAssembly, rawSymbolStore, securityEvidence)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("This method is obsolete and will be removed in a future release of the .NET Framework. Please use an overload of Load which does not take an Evidence parameter. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rawAssembly" Type="System.Byte[]" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="rawSymbolStore" Type="System.Byte[]" Index="1" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="securityEvidence" Type="System.Security.Policy.Evidence" Index="2" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="rawAssembly"><span data-ttu-id="2cf0e-943">Uma matriz de byte que é uma imagem baseada em COFF contendo um assembly emitido.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-943">A byte array that is a COFF-based image containing an emitted assembly.</span></span></param>
        <param name="rawSymbolStore"><span data-ttu-id="2cf0e-944">Uma matriz de bytes que contém os bytes brutos que representam os símbolos do assembly.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-944">A byte array that contains the raw bytes representing the symbols for the assembly.</span></span></param>
        <param name="securityEvidence"><span data-ttu-id="2cf0e-945">Evidência para carregar o assembly.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-945">Evidence for loading the assembly.</span></span></param>
        <summary><span data-ttu-id="2cf0e-946">Carrega o assembly com uma imagem baseada em formato COFF, contendo um assembly emitido, incluindo, opcionalmente, símbolos e evidência para o assembly.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-946">Loads the assembly with a common object file format (COFF)-based image containing an emitted assembly, optionally including symbols and evidence for the assembly.</span></span> <span data-ttu-id="2cf0e-947">O assembly é carregado no domínio de aplicativo do chamador.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-947">The assembly is loaded into the application domain of the caller.</span></span></summary>
        <returns><span data-ttu-id="2cf0e-948">O assembly carregado.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-948">The loaded assembly.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2cf0e-949">O assembly é carregado no domínio do chamador usando a evidência fornecida.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-949">The assembly is loaded into the domain of the caller using the supplied evidence.</span></span> <span data-ttu-id="2cf0e-950">Os bytes brutos que representam os símbolos para o assembly também são carregados.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-950">The raw bytes representing the symbols for the assembly are also loaded.</span></span>  
  
 <span data-ttu-id="2cf0e-951">Se determinadas permissões são concedidas ou não a um assembly é algo que se baseia na evidência.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-951">Whether certain permissions are granted or not granted to an assembly is based on evidence.</span></span> <span data-ttu-id="2cf0e-952">As regras para o assembly e a mesclagem de evidência de segurança são da seguinte maneira:</span><span class="sxs-lookup"><span data-stu-id="2cf0e-952">The rules for assembly and security evidence merging are as follows:</span></span>  
  
-   <span data-ttu-id="2cf0e-953">Quando você usa um <xref:System.Reflection.Assembly.Load%2A> método sem nenhum <xref:System.Security.Policy.Evidence> parâmetro, o assembly é carregado com a evidência que fornece o carregador.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-953">When you use a <xref:System.Reflection.Assembly.Load%2A> method with no <xref:System.Security.Policy.Evidence> parameter, the assembly is loaded with the evidence that the loader supplies.</span></span>  
  
-   <span data-ttu-id="2cf0e-954">Quando você usa um <xref:System.Reflection.Assembly.Load%2A> método com um <xref:System.Security.Policy.Evidence> parâmetro, partes de evidências são mesclados.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-954">When you use a <xref:System.Reflection.Assembly.Load%2A> method with an <xref:System.Security.Policy.Evidence> parameter, pieces of evidence are merged.</span></span> <span data-ttu-id="2cf0e-955">Partes de evidências fornecida como um argumento para o <xref:System.Reflection.Assembly.Load%2A> método substituir partes de evidências fornecida pelo carregador.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-955">Pieces of evidence supplied as an argument to the <xref:System.Reflection.Assembly.Load%2A> method supersede pieces of evidence supplied by the loader.</span></span>  
  
-   <span data-ttu-id="2cf0e-956">Quando você usa um <xref:System.Reflection.Assembly.Load%2A> sobrecarga de método com um `Byte[]` parâmetro para carregar uma imagem COFF, evidência é herdado do assembly de chamada.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-956">When you use a <xref:System.Reflection.Assembly.Load%2A> method overload with a `Byte[]` parameter to load a COFF image, evidence is inherited from the calling assembly.</span></span> <span data-ttu-id="2cf0e-957">Isso se aplica ao .NET Framework versão 1.1 Service Pack 1 (SP1) e versões posteriores.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-957">This applies to the .NET Framework version 1.1 Service Pack 1 (SP1) and subsequent releases.</span></span>  
  
    > [!NOTE]
    >  <span data-ttu-id="2cf0e-958">No .NET Framework versão 1.0 e na versão 1.1, sem o SP1, quando você usa um <xref:System.Reflection.Assembly.Load%2A> sobrecarga de método com um `Byte[]` parâmetro para carregar uma imagem COFF, evidência é combinado.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-958">In the .NET Framework version 1.0 and in version 1.1 without SP1, when you use a <xref:System.Reflection.Assembly.Load%2A> method overload with a `Byte[]` parameter to load a COFF image, evidence is combined.</span></span> <span data-ttu-id="2cf0e-959">`Zone`, `Url` e `Site` são herdadas do assembly de chamada, e `Hash` e `StrongName` são obtidos do assembly COFF.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-959">`Zone`, `Url` and `Site` are inherited from the calling assembly, and `Hash` and `StrongName` are taken from the COFF assembly.</span></span>  
  
-   <span data-ttu-id="2cf0e-960">Quando você usa um <xref:System.Reflection.Assembly.Load%2A> método com um `Byte[]` parâmetro e <xref:System.Security.Policy.Evidence> para carregar uma imagem COFF, somente a evidência fornecida é usada.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-960">When you use a <xref:System.Reflection.Assembly.Load%2A> method with a `Byte[]` parameter and <xref:System.Security.Policy.Evidence> to load a COFF image, only the supplied evidence is used.</span></span> <span data-ttu-id="2cf0e-961">Evidência do assembly de chamada e evidência da imagem COFF são ignorados.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-961">Evidence of the calling assembly and evidence of the COFF image are ignored.</span></span>  
  
 <span data-ttu-id="2cf0e-962">Refletir em arquivos executáveis C++ pode gerar um <xref:System.BadImageFormatException>.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-962">Reflecting on C++ executable files might throw a <xref:System.BadImageFormatException>.</span></span> <span data-ttu-id="2cf0e-963">Isso provavelmente é causado pelo compilador C++ os endereços de realocação ou a `.reloc` seção do seu arquivo executável.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-963">This is most likely caused by the C++ compiler stripping the relocation addresses or the `.reloc` section from your executable file.</span></span> <span data-ttu-id="2cf0e-964">Para preservar os `.reloc` endereço para seu arquivo executável do C++, especifique `/fixed:no` quando você está vinculando.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-964">To preserve the `.reloc` address for your C++ executable file, specify `/fixed:no` when you are linking.</span></span>  
  
 <span data-ttu-id="2cf0e-965">Se você chamar o [\], bytes\<XRef:System.Reflection.Assembly.Load%2A > método mais de uma vez no mesmo assembly, mas com uma evidência diferente especificada, o common language runtime não gerará um <xref:System.IO.FileLoadException> porque o igualdade e a integridade das especificações de evidências diferentes não podem ser determinados.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-965">If you call the [\], Byte\<xref:System.Reflection.Assembly.Load%2A> method more than once on the same assembly but with a different evidence specified, the common language runtime does not throw a <xref:System.IO.FileLoadException> because the equality and integrity of the different evidence specifications cannot be determined.</span></span> <span data-ttu-id="2cf0e-966">A evidência que vem primeiro é a evidência que é usada.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-966">The evidence that first succeeds is the evidence that is used.</span></span>  
  
 <span data-ttu-id="2cf0e-967">Observe que essa sobrecarga de método sempre cria um novo <xref:System.Reflection.Assembly> objeto com seu próprio mapeamento.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-967">Note that this method overload always creates a new <xref:System.Reflection.Assembly> object with its own mapping.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="2cf0e-968"><paramref name="rawAssembly" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-968"><paramref name="rawAssembly" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="2cf0e-969"><paramref name="rawAssembly" /> não é um assembly válido.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-969"><paramref name="rawAssembly" /> is not a valid assembly.</span></span>  
  
<span data-ttu-id="2cf0e-970">- ou -</span><span class="sxs-lookup"><span data-stu-id="2cf0e-970">-or-</span></span> 
<span data-ttu-id="2cf0e-971">A versão 2,0 ou posterior do Common Language Runtime está carregada e <paramref name="rawAssembly" /> foi compilada com uma versão posterior.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-971">Version 2.0 or later of the common language runtime is currently loaded and <paramref name="rawAssembly" /> was compiled with a later version.</span></span></exception>
        <exception cref="T:System.IO.FileLoadException"><span data-ttu-id="2cf0e-972">Um assembly ou módulo foi carregado duas vezes em com duas evidências diferentes.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-972">An assembly or module was loaded twice with two different evidences.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="2cf0e-973"><paramref name="securityEvidence" /> não é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-973"><paramref name="securityEvidence" /> is not <see langword="null" />.</span></span>  <span data-ttu-id="2cf0e-974">Por padrão, a política CAS herdada não está habilitada no [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]; quando ela não está habilitada, <paramref name="securityEvidence" /> deve ser <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-974">By default, legacy CAS policy is not enabled in the [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]; when it is not enabled, <paramref name="securityEvidence" /> must be <see langword="null" />.</span></span></exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="2cf0e-975">para a capacidade de fornecer a evidência.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-975">for the ability to supply evidence.</span></span> <span data-ttu-id="2cf0e-976">Enumeração associada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-976">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</span></span> <span data-ttu-id="2cf0e-977">Ação de segurança: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-977">Security action: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly Load (byte[] rawAssembly, byte[] rawSymbolStore, System.Security.SecurityContextSource securityContextSource);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly Load(unsigned int8[] rawAssembly, unsigned int8[] rawSymbolStore, valuetype System.Security.SecurityContextSource securityContextSource) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.Load(System.Byte[],System.Byte[],System.Security.SecurityContextSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ Load(cli::array &lt;System::Byte&gt; ^ rawAssembly, cli::array &lt;System::Byte&gt; ^ rawSymbolStore, System::Security::SecurityContextSource securityContextSource);" />
      <MemberSignature Language="F#" Value="static member Load : byte[] * byte[] * System.Security.SecurityContextSource -&gt; System.Reflection.Assembly" Usage="System.Reflection.Assembly.Load (rawAssembly, rawSymbolStore, securityContextSource)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rawAssembly" Type="System.Byte[]" Index="0" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="rawSymbolStore" Type="System.Byte[]" Index="1" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="securityContextSource" Type="System.Security.SecurityContextSource" Index="2" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="rawAssembly"><span data-ttu-id="2cf0e-978">Uma matriz de byte que é uma imagem baseada em COFF contendo um assembly emitido.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-978">A byte array that is a COFF-based image containing an emitted assembly.</span></span></param>
        <param name="rawSymbolStore"><span data-ttu-id="2cf0e-979">Uma matriz de bytes que contém os bytes brutos que representam os símbolos do assembly.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-979">A byte array that contains the raw bytes representing the symbols for the assembly.</span></span></param>
        <param name="securityContextSource"><span data-ttu-id="2cf0e-980">A origem do contexto de segurança.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-980">The source of the security context.</span></span></param>
        <summary><span data-ttu-id="2cf0e-981">Carrega o assembly com uma imagem baseada no formato COFF contendo um assembly emitido, opcionalmente incluindo símbolos e especificando a fonte para o contexto de segurança.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-981">Loads the assembly with a common object file format (COFF)-based image containing an emitted assembly, optionally including symbols and specifying the source for the security context.</span></span> <span data-ttu-id="2cf0e-982">O assembly é carregado no domínio de aplicativo do chamador.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-982">The assembly is loaded into the application domain of the caller.</span></span></summary>
        <returns><span data-ttu-id="2cf0e-983">O assembly carregado.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-983">The loaded assembly.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2cf0e-984">O assembly é carregado no domínio de aplicativo do chamador usando a origem especificada para o contexto de segurança.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-984">The assembly is loaded into the application domain of the caller using the specified source for the security context.</span></span> <span data-ttu-id="2cf0e-985">Se `rawSymbolStore` foi especificado, os bytes brutos que representam os símbolos para o assembly também são carregados.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-985">If `rawSymbolStore` was specified, the raw bytes that represent the symbols for the assembly are also loaded.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="2cf0e-986"><paramref name="rawAssembly" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-986"><paramref name="rawAssembly" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="2cf0e-987"><paramref name="rawAssembly" /> não é um assembly válido.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-987"><paramref name="rawAssembly" /> is not a valid assembly.</span></span>  
  
<span data-ttu-id="2cf0e-988">- ou -</span><span class="sxs-lookup"><span data-stu-id="2cf0e-988">-or-</span></span> 
 <span data-ttu-id="2cf0e-989"><paramref name="rawAssembly" /> foi compilado com uma versão posterior do Common Language Runtime do que a versão carregada atualmente.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-989"><paramref name="rawAssembly" /> was compiled with a later version of the common language runtime than the version that is currently loaded.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="2cf0e-990">O valor atribuído de <paramref name="securityContextSource" /> não é um dos valores de enumeração.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-990">The value of <paramref name="securityContextSource" /> is not one of the enumeration values.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="LoadFile">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="2cf0e-991">Carrega o conteúdo de um arquivo do assembly.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-991">Loads the contents of an assembly file.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="LoadFile">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly LoadFile (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly LoadFile(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.LoadFile(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LoadFile (path As String) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ LoadFile(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member LoadFile : string -&gt; System.Reflection.Assembly" Usage="System.Reflection.Assembly.LoadFile path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="path"><span data-ttu-id="2cf0e-992">O caminho totalmente qualificado do arquivo a ser carregado.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-992">The fully qualified path of the file to load.</span></span></param>
        <summary><span data-ttu-id="2cf0e-993">Carrega o conteúdo de um arquivo do assembly no caminho especificado.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-993">Loads the contents of an assembly file on the specified path.</span></span></summary>
        <returns><span data-ttu-id="2cf0e-994">O assembly carregado.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-994">The loaded assembly.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2cf0e-995">Use o <xref:System.Reflection.Assembly.LoadFile%2A> método para carregar e examinar os assemblies que têm a mesma identidade, mas estão localizados em diferentes caminhos.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-995">Use the <xref:System.Reflection.Assembly.LoadFile%2A> method to load and examine assemblies that have the same identity, but are located in different paths.</span></span> <span data-ttu-id="2cf0e-996"><xref:System.Reflection.Assembly.LoadFile%2A> não carregar arquivos em um contexto de carga e não resolver dependências usando o caminho de carga, como o <xref:System.Reflection.Assembly.LoadFrom%2A> método faz.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-996"><xref:System.Reflection.Assembly.LoadFile%2A> does not load files into the load-from  context, and does not resolve dependencies using the load path, as the <xref:System.Reflection.Assembly.LoadFrom%2A> method does.</span></span> <span data-ttu-id="2cf0e-997"><xref:System.Reflection.Assembly.LoadFile%2A> é útil neste cenário limitada porque <xref:System.Reflection.Assembly.LoadFrom%2A> não pode ser usado para carregar assemblies que têm as mesmas identidades, mas diferentes caminhos; ele carregará somente as primeiras tal assembly.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-997"><xref:System.Reflection.Assembly.LoadFile%2A> is useful in this limited scenario because <xref:System.Reflection.Assembly.LoadFrom%2A> cannot be used to load assemblies that have the same identities but different paths; it will load only the first such assembly.</span></span>  

<span data-ttu-id="2cf0e-998">Começando com o .NET Framework 4, se `path` Especifica um assembly em um local remoto, o carregamento do assembly é desabilitado por padrão e o `LoadFile` método lança um <xref:System.IO.FileLoadException>.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-998">Starting with .NET Framework 4, if `path` specifies an assembly in a remote location, assembly loading is disabled by default, and the `LoadFile` method throws a <xref:System.IO.FileLoadException>.</span></span> <span data-ttu-id="2cf0e-999">Para habilitar a execução de código carregado a partir de locais remotos, você pode usar o [ `<loadFromRemoteSources>` ](~/docs/framework/configure-apps/file-schema/runtime/loadfromremotesources-element.md) elemento de configuração.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-999">To enable execution of code loaded from remote locations, you can use the [`<loadFromRemoteSources>`](~/docs/framework/configure-apps/file-schema/runtime/loadfromremotesources-element.md) configuration element.</span></span>    
    
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="2cf0e-1000">O argumento <paramref name="path" /> não é um caminho absoluto.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1000">The <paramref name="path" /> argument is not an absolute path.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="2cf0e-1001">O parâmetro <paramref name="path" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1001">The <paramref name="path" /> parameter is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.IO.FileLoadException"><span data-ttu-id="2cf0e-1002">Não foi possível carregar um arquivo que foi encontrado.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1002">A file that was found could not be loaded.</span></span>

<span data-ttu-id="2cf0e-1003">- ou -</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1003">-or-</span></span>

<span data-ttu-id="2cf0e-1004">A capacidade de executar código em assemblies remotos está desabilitada.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1004">The ability to execute code in remote assemblies is disabled.</span></span> <span data-ttu-id="2cf0e-1005">Veja <see href="https://docs.microsoft.com/dotnet/framework/configure-apps/file-schema/runtime/loadfromremotesources-element">&lt;loadFromRemoteSources&gt;</see>.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1005">See <see href="https://docs.microsoft.com/dotnet/framework/configure-apps/file-schema/runtime/loadfromremotesources-element">&lt;loadFromRemoteSources&gt;</see>.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="2cf0e-1006">O parâmetro <paramref name="path" /> é uma cadeia de caracteres vazia ("") ou não existe.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1006">The <paramref name="path" /> parameter is an empty string ("") or does not exist.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="2cf0e-1007"><paramref name="path" /> não é um assembly válido.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1007"><paramref name="path" /> is not a valid assembly.</span></span>  
  
<span data-ttu-id="2cf0e-1008">- ou -</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1008">-or-</span></span> 
<span data-ttu-id="2cf0e-1009">A versão 2,0 ou posterior do Common Language Runtime está carregada e <paramref name="path" /> foi compilada com uma versão posterior.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1009">Version 2.0 or later of the common language runtime is currently loaded and <paramref name="path" /> was compiled with a later version.</span></span></exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission"><span data-ttu-id="2cf0e-1010">para acesso de leitura de um arquivo ou um diretório, e para acesso às informações no próprio caminho.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1010">for access to read from a file or directory, and for access to the information in the path itself.</span></span> <span data-ttu-id="2cf0e-1011">Enumerações associadas: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></span><span class="sxs-lookup"><span data-stu-id="2cf0e-1011">Associated enumerations: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></span></span></permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="2cf0e-1012">para carregar um assembly com evidências.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1012">to load an assembly with evidence.</span></span> <span data-ttu-id="2cf0e-1013">Enumeração associada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></span><span class="sxs-lookup"><span data-stu-id="2cf0e-1013">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="LoadFile">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly LoadFile (string path, System.Security.Policy.Evidence securityEvidence);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly LoadFile(string path, class System.Security.Policy.Evidence securityEvidence) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.LoadFile(System.String,System.Security.Policy.Evidence)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LoadFile (path As String, securityEvidence As Evidence) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ LoadFile(System::String ^ path, System::Security::Policy::Evidence ^ securityEvidence);" />
      <MemberSignature Language="F#" Value="static member LoadFile : string * System.Security.Policy.Evidence -&gt; System.Reflection.Assembly" Usage="System.Reflection.Assembly.LoadFile (path, securityEvidence)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("This method is obsolete and will be removed in a future release of the .NET Framework. Please use an overload of LoadFile which does not take an Evidence parameter. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="securityEvidence" Type="System.Security.Policy.Evidence" Index="1" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="path"><span data-ttu-id="2cf0e-1014">O caminho totalmente qualificado do arquivo do assembly.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1014">The fully qualified path of the assembly file.</span></span></param>
        <param name="securityEvidence"><span data-ttu-id="2cf0e-1015">Evidência para carregar o assembly.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1015">Evidence for loading the assembly.</span></span></param>
        <summary><span data-ttu-id="2cf0e-1016">Carrega um assembly de acordo com seu caminho, carregando o assembly no domínio do chamador usando a evidência fornecida.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1016">Loads an assembly given its path, loading the assembly into the domain of the caller using the supplied evidence.</span></span></summary>
        <returns><span data-ttu-id="2cf0e-1017">O assembly carregado.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1017">The loaded assembly.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2cf0e-1018">Use o <xref:System.Reflection.Assembly.LoadFile%2A> método para carregar e examinar os assemblies que têm a mesma identidade, mas estão localizados em diferentes caminhos.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1018">Use the <xref:System.Reflection.Assembly.LoadFile%2A> method to load and examine assemblies that have the same identity, but are located in different paths.</span></span> <span data-ttu-id="2cf0e-1019"><xref:System.Reflection.Assembly.LoadFile%2A> não carregar arquivos para o <xref:System.Reflection.Assembly.LoadFrom%2A> contexto e não resolver as dependências usando o caminho de carga, como o <xref:System.Reflection.Assembly.LoadFrom%2A> método faz.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1019"><xref:System.Reflection.Assembly.LoadFile%2A> does not load files into the <xref:System.Reflection.Assembly.LoadFrom%2A> context, and does not resolve dependencies using the load path, as the <xref:System.Reflection.Assembly.LoadFrom%2A> method does.</span></span> <span data-ttu-id="2cf0e-1020"><xref:System.Reflection.Assembly.LoadFile%2A> é útil neste cenário limitada porque <xref:System.Reflection.Assembly.LoadFrom%2A> não pode ser usado para carregar assemblies que têm as mesmas identidades, mas diferentes caminhos; ele carregará somente as primeiras tal assembly.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1020"><xref:System.Reflection.Assembly.LoadFile%2A> is useful in this limited scenario because <xref:System.Reflection.Assembly.LoadFrom%2A> cannot be used to load assemblies that have the same identities but different paths; it will load only the first such assembly.</span></span>  

<span data-ttu-id="2cf0e-1021">Começando com o .NET Framework 4, se `path` Especifica um assembly em um local remoto, o carregamento do assembly é desabilitado por padrão e o `LoadFile` método lança um <xref:System.IO.FileLoadException>.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1021">Starting with .NET Framework 4, if `path` specifies an assembly in a remote location, assembly loading is disabled by default, and the `LoadFile` method throws a <xref:System.IO.FileLoadException>.</span></span> <span data-ttu-id="2cf0e-1022">Para habilitar a execução de código carregado a partir de locais remotos, você pode usar o [ `<loadFromRemoteSources>` ](~/docs/framework/configure-apps/file-schema/runtime/loadfromremotesources-element.md) elemento de configuração.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1022">To enable execution of code loaded from remote locations, you can use the [`<loadFromRemoteSources>`](~/docs/framework/configure-apps/file-schema/runtime/loadfromremotesources-element.md) configuration element.</span></span>    

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="2cf0e-1023">O argumento <paramref name="path" /> não é um caminho absoluto.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1023">The <paramref name="path" /> argument is not an absolute path.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="2cf0e-1024">O parâmetro <paramref name="path" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1024">The <paramref name="path" /> parameter is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="2cf0e-1025">O parâmetro <paramref name="path" /> é uma cadeia de caracteres vazia ("") ou não existe.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1025">The <paramref name="path" /> parameter is an empty string ("") or does not exist.</span></span></exception>
        <exception cref="T:System.IO.FileLoadException"><span data-ttu-id="2cf0e-1026">Não foi possível carregar um arquivo que foi encontrado.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1026">A file that was found could not be loaded.</span></span>

<span data-ttu-id="2cf0e-1027">- ou -</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1027">-or-</span></span>

<span data-ttu-id="2cf0e-1028">A capacidade de executar código em assemblies remotos está desabilitada.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1028">The ability to execute code in remote assemblies is disabled.</span></span> <span data-ttu-id="2cf0e-1029">Veja <see href="https://docs.microsoft.com/dotnet/framework/configure-apps/file-schema/runtime/loadfromremotesources-element">&lt;loadFromRemoteSources&gt;</see>.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1029">See <see href="https://docs.microsoft.com/dotnet/framework/configure-apps/file-schema/runtime/loadfromremotesources-element">&lt;loadFromRemoteSources&gt;</see>.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="2cf0e-1030"><paramref name="path" /> não é um assembly válido.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1030"><paramref name="path" /> is not a valid assembly.</span></span>  
  
<span data-ttu-id="2cf0e-1031">- ou -</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1031">-or-</span></span> 
<span data-ttu-id="2cf0e-1032">A versão 2,0 ou posterior do Common Language Runtime está carregada e <paramref name="path" /> foi compilada com uma versão posterior.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1032">Version 2.0 or later of the common language runtime is currently loaded and <paramref name="path" /> was compiled with a later version.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="2cf0e-1033"><paramref name="securityEvidence" /> não é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1033"><paramref name="securityEvidence" /> is not <see langword="null" />.</span></span> <span data-ttu-id="2cf0e-1034">Por padrão, a política CAS herdada não está habilitada no [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]; quando ela não está habilitada, <paramref name="securityEvidence" /> deve ser <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1034">By default, legacy CAS policy is not enabled in the [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]; when it is not enabled, <paramref name="securityEvidence" /> must be <see langword="null" />.</span></span></exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission"><span data-ttu-id="2cf0e-1035">para acesso de leitura de um arquivo ou um diretório, e para acesso às informações no próprio caminho.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1035">for access to read from a file or directory, and for access to the information in the path itself.</span></span> <span data-ttu-id="2cf0e-1036">Enumerações associadas: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></span><span class="sxs-lookup"><span data-stu-id="2cf0e-1036">Associated enumerations: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></span></span></permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="2cf0e-1037">para carregar um assembly com evidências.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1037">to load an assembly with evidence.</span></span> <span data-ttu-id="2cf0e-1038">Enumeração associada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></span><span class="sxs-lookup"><span data-stu-id="2cf0e-1038">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></span></span></permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="LoadFrom">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="2cf0e-1039">Carrega um assembly.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1039">Loads an assembly.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
             
## Remarks

<span data-ttu-id="2cf0e-1040">A partir do .NET Framework 4, a capacidade de executar código em assemblies carregados a partir de locais remotos é desabilitada por padrão e a chamada para o `LoadFrom` método lança um <xref:System.IO.FileLoadException>.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1040">Starting with .NET Framework 4, the ability to execute code in assemblies loaded from remote locations is disabled by default, and the call to the `LoadFrom` method throws a <xref:System.IO.FileLoadException>.</span></span> <span data-ttu-id="2cf0e-1041">Para carregar o assembly e executar seu código, você deve:</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1041">To load the assembly and execute its code, you must either:</span></span>

- <span data-ttu-id="2cf0e-1042">Crie explicitamente uma área restrita para o assembly.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1042">Explicitly create a sandbox for the assembly.</span></span> <span data-ttu-id="2cf0e-1043">(Confira [Como: Executar código parcialmente confiável em uma área restrita](~/docs/framework/misc/how-to-run-partially-trusted-code-in-a-sandbox.md).)</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1043">(See [How to: Run Partially Trusted Code in a Sandbox](~/docs/framework/misc/how-to-run-partially-trusted-code-in-a-sandbox.md).)</span></span>

- <span data-ttu-id="2cf0e-1044">Executar o código do assembly em confiança total, definindo o `enabled` atributo o [ `<loadFromRemoteSources>` elemento de configuração](~/docs/framework/configure-apps/file-schema/runtime/loadfromremotesources-element.md) para `true`.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1044">Run the assembly's code in full trust by setting the `enabled` attribute of the [`<loadFromRemoteSources>` configuration element](~/docs/framework/configure-apps/file-schema/runtime/loadfromremotesources-element.md) to `true`.</span></span> <span data-ttu-id="2cf0e-1045">Para obter mais informações, consulte o [ `<loadFromRemoteSources>` elemento de configuração](~/docs/framework/configure-apps/file-schema/runtime/loadfromremotesources-element.md) artigo.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1045">For more information, see the [`<loadFromRemoteSources>` configuration element](~/docs/framework/configure-apps/file-schema/runtime/loadfromremotesources-element.md) article.</span></span>

       ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="LoadFrom">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly LoadFrom (string assemblyFile);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly LoadFrom(string assemblyFile) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.LoadFrom(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LoadFrom (assemblyFile As String) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ LoadFrom(System::String ^ assemblyFile);" />
      <MemberSignature Language="F#" Value="static member LoadFrom : string -&gt; System.Reflection.Assembly" Usage="System.Reflection.Assembly.LoadFrom assemblyFile" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="assemblyFile"><span data-ttu-id="2cf0e-1046">O nome ou o caminho do arquivo que contém o manifesto do assembly.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1046">The name or path of the file that contains the manifest of the assembly.</span></span></param>
        <summary><span data-ttu-id="2cf0e-1047">Carrega um assembly de acordo com o nome de arquivo ou caminho.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1047">Loads an assembly given its file name or path.</span></span></summary>
        <returns><span data-ttu-id="2cf0e-1048">O assembly carregado.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1048">The loaded assembly.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2cf0e-1049">O `assemblyFile` parâmetro deve se referir a um URI sem caracteres de escape.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1049">The `assemblyFile` parameter must refer to a URI without escape characters.</span></span> <span data-ttu-id="2cf0e-1050">Esse método fornece os caracteres de escape para todos os caracteres inválidos no URI.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1050">This method supplies escape characters for all invalid characters in the URI.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="2cf0e-1051">Não há suporte para o protocolo de transferência de arquivo (FTP).</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1051">File transfer protocol (FTP) is not supported.</span></span> <span data-ttu-id="2cf0e-1052">Se o URI fornecido para `assemblyFile` é um endereço FTP, o assembly não é carregado.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1052">If the URI supplied for `assemblyFile` is an FTP address, the assembly is not loaded.</span></span> <span data-ttu-id="2cf0e-1053">Nenhuma exceção é lançada.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1053">No exception is thrown.</span></span>  
  
 <span data-ttu-id="2cf0e-1054">`assemblyFile` pode ser absoluto ou relativo para o diretório atual, e o assembly é carregado para o domínio do chamador.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1054">`assemblyFile` may be absolute or relative to the current directory, and the assembly is loaded into the domain of the caller.</span></span>  
  
 <span data-ttu-id="2cf0e-1055">Assemblies podem ser carregados em um dos três contextos ou podem ser carregados sem contexto:</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1055">Assemblies can be loaded into one of three contexts, or can be loaded without context:</span></span>  
  
-   <span data-ttu-id="2cf0e-1056">O contexto de carregamento contém assemblies localizados investigando: no GAC, em um assembly de host armazenadas se o tempo de execução é hospedado ou na <xref:System.AppDomainSetup.ApplicationBase%2A> e <xref:System.AppDomainSetup.PrivateBinPath%2A> do domínio do aplicativo.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1056">The load context contains assemblies found by probing: in the GAC, in a host assembly store if the runtime is hosted, or in the <xref:System.AppDomainSetup.ApplicationBase%2A> and <xref:System.AppDomainSetup.PrivateBinPath%2A> of the application domain.</span></span> <span data-ttu-id="2cf0e-1057">A maioria das sobrecargas do método <xref:System.Reflection.Assembly.Load%2A> carrega os assemblies nesse contexto.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1057">Most overloads of the <xref:System.Reflection.Assembly.Load%2A> method load assemblies into this context.</span></span>  
  
-   <span data-ttu-id="2cf0e-1058">O contexto de carregamento contém assemblies para os quais o usuário forneceu um caminho que não está incluído nos diretórios pesquisados por sondagem.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1058">The load-from context contains assemblies for which the user provided a path not included in the directories searched by probing.</span></span> <span data-ttu-id="2cf0e-1059"><xref:System.Reflection.Assembly.LoadFrom%2A>, <xref:System.AppDomain.CreateInstanceFrom%2A> e <xref:System.AppDomain.ExecuteAssembly%2A> são exemplos de métodos que carregam pelo caminho.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1059"><xref:System.Reflection.Assembly.LoadFrom%2A>, <xref:System.AppDomain.CreateInstanceFrom%2A>, and <xref:System.AppDomain.ExecuteAssembly%2A> are examples of methods that load by path.</span></span> 

    <span data-ttu-id="2cf0e-1060">Começando com o .NET Framework 4, se o URI do `assemblyFile` Especifica um local remoto, carregamento de assembly está desabilitado por padrão e o `LoadFrom` método lança um <xref:System.IO.FileLoadException>.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1060">Starting with .NET Framework 4, if the URI of `assemblyFile` specifies a remote location, assembly loading is disabled by default, and the `LoadFrom` method throws a <xref:System.IO.FileLoadException>.</span></span> <span data-ttu-id="2cf0e-1061">Para habilitar a execução de código carregado a partir de locais remotos, você pode usar o [ `<loadFromRemoteSources>` ](~/docs/framework/configure-apps/file-schema/runtime/loadfromremotesources-element.md) elemento de configuração.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1061">To enable execution of code loaded from remote locations, you can use the [`<loadFromRemoteSources>`](~/docs/framework/configure-apps/file-schema/runtime/loadfromremotesources-element.md) configuration element.</span></span>    
  
-   <span data-ttu-id="2cf0e-1062">O contexto de somente reflexão contém assemblies carregados com o <xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A> e <xref:System.Reflection.Assembly.ReflectionOnlyLoadFrom%2A> métodos; o código nesses contextos não podem ser executados.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1062">The reflection-only context contains assemblies loaded with the <xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A> and <xref:System.Reflection.Assembly.ReflectionOnlyLoadFrom%2A> methods; code in these contexts cannot be executed.</span></span>  
  
-   <span data-ttu-id="2cf0e-1063">Se o usuário gerado ou localizado o assembly, não é em qualquer contexto.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1063">If the user generated or found the assembly, it is not in any context.</span></span> <span data-ttu-id="2cf0e-1064">Isso se aplica aos assemblies carregados usando sobrecargas do <xref:System.Reflection.Assembly.Load%2A> método que especifique uma matriz de bytes que contém um assembly e para os assemblies dinâmicos transitórios criados com a reflexão emite e não são salvas em disco.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1064">This applies to assemblies loaded using overloads of the <xref:System.Reflection.Assembly.Load%2A> method that specify a byte array containing an assembly, and to transient dynamic assemblies created with reflection emit and not saved to disk.</span></span>  
  
 <span data-ttu-id="2cf0e-1065">O contexto de carga permite que um assembly a ser carregado de um caminho que não está incluído na investigação e ainda permite que as dependências nesse caminho a ser encontrado e carregado porque as informações de caminho são mantidas pelo contexto.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1065">The load-from context allows an assembly to be loaded from a path not included in probing, and yet allows dependencies on that path to be found and loaded because the path information is maintained by the context.</span></span>  
  
 <span data-ttu-id="2cf0e-1066">O <xref:System.Reflection.Assembly.LoadFrom%2A> método tem as seguintes desvantagens.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1066">The <xref:System.Reflection.Assembly.LoadFrom%2A> method has the following disadvantages.</span></span> <span data-ttu-id="2cf0e-1067">Considere o uso de <xref:System.Reflection.Assembly.Load%2A> em seu lugar.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1067">Consider using <xref:System.Reflection.Assembly.Load%2A> instead.</span></span>  
  
-   <span data-ttu-id="2cf0e-1068">Se um assembly com a mesma identidade já estiver carregado, <xref:System.Reflection.Assembly.LoadFrom%2A> retornará o assembly carregado, mesmo se um caminho diferente foi especificado.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1068">If an assembly with the same identity is already loaded, <xref:System.Reflection.Assembly.LoadFrom%2A> returns the loaded assembly even if a different path was specified.</span></span>  
  
-   <span data-ttu-id="2cf0e-1069">Se um assembly é carregado com <xref:System.Reflection.Assembly.LoadFrom%2A>e posteriormente um assembly no contexto de carga tenta carregar o mesmo assembly por nome de exibição, a tentativa de carregamento falhará.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1069">If an assembly is loaded with <xref:System.Reflection.Assembly.LoadFrom%2A>, and later an assembly in the load context attempts to load the same assembly by display name, the load attempt fails.</span></span> <span data-ttu-id="2cf0e-1070">Isso pode ocorrer quando um assembly é desserializado.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1070">This can occur when an assembly is de-serialized.</span></span>  
  
-   <span data-ttu-id="2cf0e-1071">Se um assembly é carregado com <xref:System.Reflection.Assembly.LoadFrom%2A>, e o caminho de investigação inclui um assembly com a mesma identidade, um local diferente, mas uma <xref:System.InvalidCastException>, <xref:System.MissingMethodException>, ou outro comportamento inesperado pode ocorrer.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1071">If an assembly is loaded with <xref:System.Reflection.Assembly.LoadFrom%2A>, and the probing path includes an assembly with the same identity but a different location, an <xref:System.InvalidCastException>, <xref:System.MissingMethodException>, or other unexpected behavior can occur.</span></span>  
  
-   <span data-ttu-id="2cf0e-1072"><xref:System.Reflection.Assembly.LoadFrom%2A> exige <xref:System.Security.Permissions.FileIOPermissionAccess.Read?displayProperty=nameWithType> e <xref:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery?displayProperty=nameWithType>, ou <xref:System.Net.WebPermission>, no caminho especificado.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1072"><xref:System.Reflection.Assembly.LoadFrom%2A> demands <xref:System.Security.Permissions.FileIOPermissionAccess.Read?displayProperty=nameWithType> and <xref:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery?displayProperty=nameWithType>, or <xref:System.Net.WebPermission>, on the specified path.</span></span>  
  
-   <span data-ttu-id="2cf0e-1073">Se não houver uma imagem nativa para `assemblyFile`, ele não é usado.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1073">If a native image exists for `assemblyFile`, it is not used.</span></span> <span data-ttu-id="2cf0e-1074">O assembly não pode ser carregado como domínio neutro.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1074">The assembly cannot be loaded as domain neutral.</span></span>  
  
-   <span data-ttu-id="2cf0e-1075">No .NET Framework versão 1.0 e 1.1, a política não é aplicada.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1075">In the .NET Framework version 1.0 and 1.1, policy is not applied.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="2cf0e-1076">O exemplo a seguir carrega um assembly dado seu nome de arquivo ou caminho.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1076">The following example loads an assembly given its file name or path.</span></span>  
  
 [!code-cpp[System.Reflection.Assembly#11](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Assembly/CPP/assembly.cpp#11)]
 [!code-csharp[System.Reflection.Assembly#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Assembly/CS/assembly.cs#11)]
 [!code-vb[System.Reflection.Assembly#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Assembly/VB/assembly.vb#11)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="2cf0e-1077"><paramref name="assemblyFile" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1077"><paramref name="assemblyFile" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="2cf0e-1078"><paramref name="assemblyFile" /> não foi encontrado, ou o módulo que você está tentando carregar não especifica uma extensão de nome de arquivo.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1078"><paramref name="assemblyFile" /> is not found, or the module you are trying to load does not specify a filename extension.</span></span></exception>
        <exception cref="T:System.IO.FileLoadException"><span data-ttu-id="2cf0e-1079">Não foi possível carregar um arquivo que foi encontrado.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1079">A file that was found could not be loaded.</span></span>

<span data-ttu-id="2cf0e-1080">- ou -</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1080">-or-</span></span>

<span data-ttu-id="2cf0e-1081">A capacidade de executar código em assemblies remotos está desabilitada.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1081">The ability to execute code in remote assemblies is disabled.</span></span> <span data-ttu-id="2cf0e-1082">Veja <see href="https://docs.microsoft.com/dotnet/framework/configure-apps/file-schema/runtime/loadfromremotesources-element">&lt;loadFromRemoteSources&gt;</see>.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1082">See <see href="https://docs.microsoft.com/dotnet/framework/configure-apps/file-schema/runtime/loadfromremotesources-element">&lt;loadFromRemoteSources&gt;</see>.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="2cf0e-1083"><paramref name="assemblyFile" /> não é um assembly válido; por exemplo, um assembly de 32 bits em um processo de 64 bits.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1083"><paramref name="assemblyFile" /> is not a valid assembly; for example, a 32-bit assembly in a 64-bit process.</span></span> <span data-ttu-id="2cf0e-1084">Consulte o tópico de exceção para obter mais informações.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1084">See the exception topic for more information.</span></span>  
  
<span data-ttu-id="2cf0e-1085">- ou -</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1085">-or-</span></span> 
<span data-ttu-id="2cf0e-1086">A versão 2,0 ou posterior do Common Language Runtime está carregada e <paramref name="assemblyFile" /> foi compilada com uma versão posterior.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1086">Version 2.0 or later of the common language runtime is currently loaded and <paramref name="assemblyFile" /> was compiled with a later version.</span></span></exception>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="2cf0e-1087">Uma base de código que não é iniciada com “file://” foi especificada sem o <see cref="T:System.Net.WebPermission" /> necessário.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1087">A codebase that does not start with "file://" was specified without the required <see cref="T:System.Net.WebPermission" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="2cf0e-1088">O parâmetro <paramref name="assemblyFile" /> é uma cadeia de caracteres vazia ("").</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1088">The <paramref name="assemblyFile" /> parameter is an empty string ("").</span></span></exception>
        <exception cref="T:System.IO.PathTooLongException"><span data-ttu-id="2cf0e-1089">O nome do assembly excede o tamanho máximo definido pelo sistema.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1089">The assembly name exceeds the system-defined maximum length.</span></span></exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission"><span data-ttu-id="2cf0e-1090">para ler um URI que começa com "file://".</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1090">for reading a URI that begins with "file://".</span></span> <span data-ttu-id="2cf0e-1091">Enumeração associada: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></span><span class="sxs-lookup"><span data-stu-id="2cf0e-1091">Associated enumeration: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></span></span></permission>
        <permission cref="T:System.Net.WebPermission"><span data-ttu-id="2cf0e-1092">para ler um URI que não começa com "file://".</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1092">for reading a URI that does not begin with "file://".</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="LoadFrom">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly LoadFrom (string assemblyFile, System.Security.Policy.Evidence securityEvidence);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly LoadFrom(string assemblyFile, class System.Security.Policy.Evidence securityEvidence) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.LoadFrom(System.String,System.Security.Policy.Evidence)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LoadFrom (assemblyFile As String, securityEvidence As Evidence) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ LoadFrom(System::String ^ assemblyFile, System::Security::Policy::Evidence ^ securityEvidence);" />
      <MemberSignature Language="F#" Value="static member LoadFrom : string * System.Security.Policy.Evidence -&gt; System.Reflection.Assembly" Usage="System.Reflection.Assembly.LoadFrom (assemblyFile, securityEvidence)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("This method is obsolete and will be removed in a future release of the .NET Framework. Please use an overload of LoadFrom which does not take an Evidence parameter. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="securityEvidence" Type="System.Security.Policy.Evidence" Index="1" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="assemblyFile"><span data-ttu-id="2cf0e-1093">O nome ou o caminho do arquivo que contém o manifesto do assembly.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1093">The name or path of the file that contains the manifest of the assembly.</span></span></param>
        <param name="securityEvidence"><span data-ttu-id="2cf0e-1094">Evidência para carregar o assembly.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1094">Evidence for loading the assembly.</span></span></param>
        <summary><span data-ttu-id="2cf0e-1095">Carrega um assembly dado seu nome de arquivo ou caminho e fornecendo evidência de segurança.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1095">Loads an assembly given its file name or path and supplying security evidence.</span></span></summary>
        <returns><span data-ttu-id="2cf0e-1096">O assembly carregado.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1096">The loaded assembly.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2cf0e-1097">O `assemblyFile` parâmetro deve se referir a um URI sem caracteres de escape.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1097">The `assemblyFile` parameter must refer to a URI without escape characters.</span></span> <span data-ttu-id="2cf0e-1098">Esse método fornece os caracteres de escape para todos os caracteres inválidos no URI.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1098">This method supplies escape characters for all invalid characters in the URI.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="2cf0e-1099">Não há suporte para o protocolo de transferência de arquivo (FTP).</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1099">File transfer protocol (FTP) is not supported.</span></span> <span data-ttu-id="2cf0e-1100">Se o URI fornecido para `assemblyFile` é um endereço FTP, o assembly não é carregado.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1100">If the URI supplied for `assemblyFile` is an FTP address, the assembly is not loaded.</span></span> <span data-ttu-id="2cf0e-1101">Nenhuma exceção é lançada.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1101">No exception is thrown.</span></span>  
  
 <span data-ttu-id="2cf0e-1102">`assemblyFile` pode ser absoluto ou relativo para o diretório atual, e o assembly é carregado para o domínio do chamador.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1102">`assemblyFile` may be absolute or  relative to the current directory, and the assembly is loaded into the domain of the caller.</span></span>  
  
 <span data-ttu-id="2cf0e-1103">Assemblies podem ser carregados em um dos três contextos ou podem ser carregados sem contexto:</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1103">Assemblies can be loaded into one of three contexts, or can be loaded without context:</span></span>  
  
-   <span data-ttu-id="2cf0e-1104">O contexto de carregamento contém assemblies localizados investigando: no GAC, em um assembly de host armazenadas se o tempo de execução é hospedado ou na <xref:System.AppDomainSetup.ApplicationBase%2A> e <xref:System.AppDomainSetup.PrivateBinPath%2A> do domínio do aplicativo.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1104">The load context contains assemblies found by probing: in the GAC, in a host assembly store if the runtime is hosted, or in the <xref:System.AppDomainSetup.ApplicationBase%2A> and <xref:System.AppDomainSetup.PrivateBinPath%2A> of the application domain.</span></span> <span data-ttu-id="2cf0e-1105">A maioria das sobrecargas do método <xref:System.Reflection.Assembly.Load%2A> carrega os assemblies nesse contexto.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1105">Most overloads of the <xref:System.Reflection.Assembly.Load%2A> method load assemblies into this context.</span></span>  
  
-   <span data-ttu-id="2cf0e-1106">O contexto de carregamento contém assemblies para os quais o usuário forneceu um caminho que não está incluído nos diretórios pesquisados por sondagem.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1106">The load-from context contains assemblies for which the user provided a path not included in the directories searched by probing.</span></span> <span data-ttu-id="2cf0e-1107"><xref:System.Reflection.Assembly.LoadFrom%2A>, <xref:System.AppDomain.CreateInstanceFrom%2A> e <xref:System.AppDomain.ExecuteAssembly%2A> são exemplos de métodos que carregam pelo caminho.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1107"><xref:System.Reflection.Assembly.LoadFrom%2A>, <xref:System.AppDomain.CreateInstanceFrom%2A>, and <xref:System.AppDomain.ExecuteAssembly%2A> are examples of methods that load by path.</span></span>

    <span data-ttu-id="2cf0e-1108">Começando com o .NET Framework 4, se o URI do `assemblyFile` Especifica um local remoto, carregamento de assembly está desabilitado por padrão e o `LoadFrom` método lança um <xref:System.IO.FileLoadException>.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1108">Starting with .NET Framework 4, if the URI of `assemblyFile` specifies a remote location, assembly loading is disabled by default, and the `LoadFrom` method throws a <xref:System.IO.FileLoadException>.</span></span> <span data-ttu-id="2cf0e-1109">Para habilitar a execução de código carregado a partir de locais remotos, você pode usar o [ `<loadFromRemoteSources>` ](~/docs/framework/configure-apps/file-schema/runtime/loadfromremotesources-element.md) elemento de configuração.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1109">To enable execution of code loaded from remote locations, you can use the [`<loadFromRemoteSources>`](~/docs/framework/configure-apps/file-schema/runtime/loadfromremotesources-element.md) configuration element.</span></span>    
  
-   <span data-ttu-id="2cf0e-1110">O contexto de somente reflexão contém assemblies carregados com o <xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A> e <xref:System.Reflection.Assembly.ReflectionOnlyLoadFrom%2A> métodos; o código nesses contextos não podem ser executados.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1110">The reflection-only context contains assemblies loaded with the <xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A> and <xref:System.Reflection.Assembly.ReflectionOnlyLoadFrom%2A> methods; code in these contexts cannot be executed.</span></span>  
  
-   <span data-ttu-id="2cf0e-1111">Se o usuário gerado ou localizado o assembly, não é em qualquer contexto.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1111">If the user generated or found the assembly, it is not in any context.</span></span> <span data-ttu-id="2cf0e-1112">Isso se aplica aos assemblies carregados usando sobrecargas do <xref:System.Reflection.Assembly.Load%2A> método que especifique uma matriz de bytes que contém um assembly e para os assemblies dinâmicos transitórios criados com a reflexão emite e não são salvas em disco.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1112">This applies to assemblies loaded using overloads of the <xref:System.Reflection.Assembly.Load%2A> method that specify a byte array containing an assembly, and to transient dynamic assemblies created with reflection emit and not saved to disk.</span></span>  
  
 <span data-ttu-id="2cf0e-1113">O contexto de carga permite que um assembly a ser carregado de um caminho que não está incluído na investigação e ainda permite que as dependências nesse caminho a ser encontrado e carregado porque as informações de caminho são mantidas pelo contexto.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1113">The load-from context allows an assembly to be loaded from a path not included in probing, and yet allows dependencies on that path to be found and loaded because the path information is maintained by the context.</span></span>  
  
 <span data-ttu-id="2cf0e-1114">O <xref:System.Reflection.Assembly.LoadFrom%2A> método tem as seguintes desvantagens.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1114">The <xref:System.Reflection.Assembly.LoadFrom%2A> method has the following disadvantages.</span></span> <span data-ttu-id="2cf0e-1115">Considere o uso de <xref:System.Reflection.Assembly.Load%2A> em seu lugar.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1115">Consider using <xref:System.Reflection.Assembly.Load%2A> instead.</span></span>  
  
-   <span data-ttu-id="2cf0e-1116">Se um assembly com a mesma identidade já estiver carregado, <xref:System.Reflection.Assembly.LoadFrom%2A> retornará o assembly carregado, mesmo se um caminho diferente foi especificado.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1116">If an assembly with the same identity is already loaded, <xref:System.Reflection.Assembly.LoadFrom%2A> returns the loaded assembly even if a different path was specified.</span></span>  
  
-   <span data-ttu-id="2cf0e-1117">Se um assembly é carregado com <xref:System.Reflection.Assembly.LoadFrom%2A>e posteriormente um assembly no contexto de carga tenta carregar o mesmo assembly por nome de exibição, a tentativa de carregamento falhará.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1117">If an assembly is loaded with <xref:System.Reflection.Assembly.LoadFrom%2A>, and later an assembly in the load context attempts to load the same assembly by display name, the load attempt fails.</span></span> <span data-ttu-id="2cf0e-1118">Isso pode ocorrer quando um assembly é desserializado.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1118">This can occur when an assembly is deserialized.</span></span>  
  
-   <span data-ttu-id="2cf0e-1119">Se um assembly é carregado com <xref:System.Reflection.Assembly.LoadFrom%2A>, e o caminho de investigação inclui um assembly com a mesma identidade, um local diferente, mas uma <xref:System.InvalidCastException>, <xref:System.MissingMethodException>, ou outro comportamento inesperado pode ocorrer.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1119">If an assembly is loaded with <xref:System.Reflection.Assembly.LoadFrom%2A>, and the probing path includes an assembly with the same identity but a different location, an <xref:System.InvalidCastException>, <xref:System.MissingMethodException>, or other unexpected behavior can occur.</span></span>  
  
-   <span data-ttu-id="2cf0e-1120"><xref:System.Reflection.Assembly.LoadFrom%2A> exige <xref:System.Security.Permissions.FileIOPermissionAccess.Read?displayProperty=nameWithType> e <xref:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery?displayProperty=nameWithType>, ou <xref:System.Net.WebPermission>, no caminho especificado.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1120"><xref:System.Reflection.Assembly.LoadFrom%2A> demands <xref:System.Security.Permissions.FileIOPermissionAccess.Read?displayProperty=nameWithType> and <xref:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery?displayProperty=nameWithType>, or <xref:System.Net.WebPermission>, on the specified path.</span></span>  
  
-   <span data-ttu-id="2cf0e-1121">Se não houver uma imagem nativa para `assemblyFile`, ele não é usado.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1121">If a native image exists for `assemblyFile`, it is not used.</span></span> <span data-ttu-id="2cf0e-1122">O assembly não pode ser carregado como domínio neutro.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1122">The assembly cannot be loaded as domain neutral.</span></span>  
  
-   <span data-ttu-id="2cf0e-1123">No .NET Framework versão 1.0 e 1.1, a política não é aplicada.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1123">In the .NET Framework version 1.0 and 1.1, policy is not applied.</span></span>  
  
 <span data-ttu-id="2cf0e-1124">Se determinadas permissões são concedidas ou não a um assembly é algo que se baseia na evidência.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1124">Whether certain permissions are granted or not granted to an assembly is based on evidence.</span></span> <span data-ttu-id="2cf0e-1125">As regras para o assembly e a mesclagem de evidência de segurança são da seguinte maneira:</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1125">The rules for assembly and security evidence merging are as follows:</span></span>  
  
-   <span data-ttu-id="2cf0e-1126">Quando você usa um <xref:System.Reflection.Assembly.LoadFrom%2A> método sem nenhum <xref:System.Security.Policy.Evidence> parâmetro, o assembly é carregado com a evidência que fornece o carregador.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1126">When you use a <xref:System.Reflection.Assembly.LoadFrom%2A> method with no <xref:System.Security.Policy.Evidence> parameter, the assembly is loaded with the evidence that the loader supplies.</span></span>  
  
-   <span data-ttu-id="2cf0e-1127">Quando você usa um <xref:System.Reflection.Assembly.LoadFrom%2A> método com um <xref:System.Security.Policy.Evidence> parâmetro, partes de evidências são mesclados.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1127">When you use a <xref:System.Reflection.Assembly.LoadFrom%2A> method with an <xref:System.Security.Policy.Evidence> parameter, pieces of evidence are merged.</span></span> <span data-ttu-id="2cf0e-1128">Partes de evidências fornecida como um argumento para o <xref:System.Reflection.Assembly.LoadFrom%2A> método substituir partes de evidências fornecida pelo carregador.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1128">Pieces of evidence supplied as an argument to the <xref:System.Reflection.Assembly.LoadFrom%2A> method supersede pieces of evidence supplied by the loader.</span></span>  
  
-   <span data-ttu-id="2cf0e-1129">Se você chamar esse método mais de uma vez no mesmo assembly, mas com uma evidência diferente especificada, o common language runtime não lança uma <xref:System.IO.FileLoadException> porque não não possível determinar a igualdade e a integridade das especificações de evidências diferentes.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1129">If you call this method more than once on the same assembly but with a different evidence specified, the common language runtime does not throw a <xref:System.IO.FileLoadException> because the equality and integrity of the different evidence specifications cannot be determined.</span></span> <span data-ttu-id="2cf0e-1130">A evidência que vem primeiro é a evidência que é usada.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1130">The evidence that first succeeds is the evidence that is used.</span></span>  
  
-   <span data-ttu-id="2cf0e-1131">Quando você usa um <xref:System.Reflection.Assembly.LoadFrom%2A> método com um `Byte[]` parâmetro para carregar uma objeto arquivo formato COFF imagem comum, evidência é combinado.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1131">When you use a <xref:System.Reflection.Assembly.LoadFrom%2A> method with a `Byte[]` parameter to load a common object file format (COFF) image, evidence is combined.</span></span> <span data-ttu-id="2cf0e-1132">`Zone`, `Url` e `Site` são herdadas do assembly de chamada, e `Hash` e `StrongName` são obtidos do assembly COFF.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1132">`Zone`, `Url` and `Site` are inherited from the calling assembly, and `Hash` and `StrongName` are taken from the COFF assembly.</span></span>  
  
-   <span data-ttu-id="2cf0e-1133">Quando você usa um <xref:System.Reflection.Assembly.LoadFrom%2A> método com um `Byte[]` parâmetro e <xref:System.Security.Policy.Evidence> para carregar uma imagem COFF, somente a evidência fornecida é usada.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1133">When you use a <xref:System.Reflection.Assembly.LoadFrom%2A> method with a `Byte[]` parameter and <xref:System.Security.Policy.Evidence> to load a COFF image, only the supplied evidence is used.</span></span> <span data-ttu-id="2cf0e-1134">Evidência do assembly de chamada e evidência da imagem COFF são ignorados.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1134">Evidence of the calling assembly and evidence of the COFF image is ignored.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="2cf0e-1135"><paramref name="assemblyFile" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1135"><paramref name="assemblyFile" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="2cf0e-1136"><paramref name="assemblyFile" /> não foi encontrado, ou o módulo que você está tentando carregar não especifica uma extensão de nome de arquivo.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1136"><paramref name="assemblyFile" /> is not found, or the module you are trying to load does not specify a filename extension.</span></span></exception>
        <exception cref="T:System.IO.FileLoadException"><span data-ttu-id="2cf0e-1137">Não foi possível carregar um arquivo que foi encontrado.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1137">A file that was found could not be loaded.</span></span>  
  
<span data-ttu-id="2cf0e-1138">- ou -</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1138">-or-</span></span> 
<span data-ttu-id="2cf0e-1139">O <paramref name="securityEvidence" /> não é ambíguo e é determinado como inválido.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1139">The <paramref name="securityEvidence" /> is not ambiguous and is determined to be invalid.</span></span>

<span data-ttu-id="2cf0e-1140">- ou -</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1140">-or-</span></span>

<span data-ttu-id="2cf0e-1141">A capacidade de executar código em assemblies remotos está desabilitada.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1141">The ability to execute code in remote assemblies is disabled.</span></span> <span data-ttu-id="2cf0e-1142">Veja <see href="https://docs.microsoft.com/dotnet/framework/configure-apps/file-schema/runtime/loadfromremotesources-element">&lt;loadFromRemoteSources&gt;</see>.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1142">See <see href="https://docs.microsoft.com/dotnet/framework/configure-apps/file-schema/runtime/loadfromremotesources-element">&lt;loadFromRemoteSources&gt;</see>.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="2cf0e-1143"><paramref name="assemblyFile" /> não é um assembly válido; por exemplo, um assembly de 32 bits em um processo de 64 bits.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1143"><paramref name="assemblyFile" /> is not a valid assembly; for example, a 32-bit assembly in a 64-bit process.</span></span> <span data-ttu-id="2cf0e-1144">Consulte o tópico de exceção para obter mais informações.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1144">See the exception topic for more information.</span></span>  
  
<span data-ttu-id="2cf0e-1145">- ou -</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1145">-or-</span></span> 
<span data-ttu-id="2cf0e-1146">A versão 2,0 ou posterior do Common Language Runtime está carregada e <paramref name="assemblyFile" /> foi compilada com uma versão posterior.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1146">Version 2.0 or later of the common language runtime is currently loaded and <paramref name="assemblyFile" /> was compiled with a later version.</span></span></exception>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="2cf0e-1147">Uma base de código que não é iniciada com “file://” foi especificada sem o <see cref="T:System.Net.WebPermission" /> necessário.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1147">A codebase that does not start with "file://" was specified without the required <see cref="T:System.Net.WebPermission" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="2cf0e-1148">O parâmetro <paramref name="assemblyFile" /> é uma cadeia de caracteres vazia ("").</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1148">The <paramref name="assemblyFile" /> parameter is an empty string ("").</span></span></exception>
        <exception cref="T:System.IO.PathTooLongException"><span data-ttu-id="2cf0e-1149">O nome do assembly excede o tamanho máximo definido pelo sistema.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1149">The assembly name exceeds the system-defined maximum length.</span></span></exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="2cf0e-1150">para carregar um assembly com evidências.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1150">to load an assembly with evidence.</span></span> <span data-ttu-id="2cf0e-1151">Enumeração associada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></span><span class="sxs-lookup"><span data-stu-id="2cf0e-1151">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></span></span></permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission"><span data-ttu-id="2cf0e-1152">para ler um URI que começa com "file://".</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1152">for reading a URI that begins with "file://".</span></span> <span data-ttu-id="2cf0e-1153">Enumeração associada: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></span><span class="sxs-lookup"><span data-stu-id="2cf0e-1153">Associated enumeration: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></span></span></permission>
        <permission cref="T:System.Net.WebPermission"><span data-ttu-id="2cf0e-1154">para ler um URI que não começa com "file://".</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1154">for reading a URI that does not begin with "file://".</span></span></permission>
        <altmember cref="T:System.Security.Policy.Evidence" />
      </Docs>
    </Member>
    <Member MemberName="LoadFrom">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly LoadFrom (string assemblyFile, byte[] hashValue, System.Configuration.Assemblies.AssemblyHashAlgorithm hashAlgorithm);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly LoadFrom(string assemblyFile, unsigned int8[] hashValue, valuetype System.Configuration.Assemblies.AssemblyHashAlgorithm hashAlgorithm) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.LoadFrom(System.String,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LoadFrom (assemblyFile As String, hashValue As Byte(), hashAlgorithm As AssemblyHashAlgorithm) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ LoadFrom(System::String ^ assemblyFile, cli::array &lt;System::Byte&gt; ^ hashValue, System::Configuration::Assemblies::AssemblyHashAlgorithm hashAlgorithm);" />
      <MemberSignature Language="F#" Value="static member LoadFrom : string * byte[] * System.Configuration.Assemblies.AssemblyHashAlgorithm -&gt; System.Reflection.Assembly" Usage="System.Reflection.Assembly.LoadFrom (assemblyFile, hashValue, hashAlgorithm)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="hashValue" Type="System.Byte[]" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="hashAlgorithm" Type="System.Configuration.Assemblies.AssemblyHashAlgorithm" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="assemblyFile"><span data-ttu-id="2cf0e-1155">O nome ou o caminho do arquivo que contém o manifesto do assembly.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1155">The name or path of the file that contains the manifest of the assembly.</span></span></param>
        <param name="hashValue"><span data-ttu-id="2cf0e-1156">O valor do código hash calculado.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1156">The value of the computed hash code.</span></span></param>
        <param name="hashAlgorithm"><span data-ttu-id="2cf0e-1157">O algoritmo de hash usado para arquivos de hash e para gerar o nome forte.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1157">The hash algorithm used for hashing files and for generating the strong name.</span></span></param>
        <summary><span data-ttu-id="2cf0e-1158">Carrega um assembly de acordo com o nome de arquivo ou caminho, valor e algoritmo de hash.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1158">Loads an assembly given its file name or path, hash value, and hash algorithm.</span></span></summary>
        <returns><span data-ttu-id="2cf0e-1159">O assembly carregado.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1159">The loaded assembly.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2cf0e-1160">O `assemblyFile` parâmetro deve se referir a um URI sem caracteres de escape.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1160">The `assemblyFile` parameter must refer to a URI without escape characters.</span></span> <span data-ttu-id="2cf0e-1161">Esse método fornece os caracteres de escape para todos os caracteres inválidos no URI.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1161">This method supplies escape characters for all invalid characters in the URI.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="2cf0e-1162">Não há suporte para o protocolo de transferência de arquivo (FTP).</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1162">File transfer protocol (FTP) is not supported.</span></span> <span data-ttu-id="2cf0e-1163">Se o URI fornecido para `assemblyFile` é um endereço FTP, o assembly não é carregado.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1163">If the URI supplied for `assemblyFile` is an FTP address, the assembly is not loaded.</span></span> <span data-ttu-id="2cf0e-1164">Nenhuma exceção é lançada.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1164">No exception is thrown.</span></span>  
  
 <span data-ttu-id="2cf0e-1165">`assemblyFile` pode ser absoluto ou relativo para o diretório atual, e o assembly é carregado para o domínio do chamador.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1165">`assemblyFile` may be absolute or relative to the current directory, and the assembly is loaded into the domain of the caller.</span></span>  
  
 <span data-ttu-id="2cf0e-1166">Assemblies podem ser carregados em um dos três contextos ou podem ser carregados sem contexto:</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1166">Assemblies can be loaded into one of three contexts, or can be loaded without context:</span></span>  
  
-   <span data-ttu-id="2cf0e-1167">O contexto de carregamento contém assemblies localizados investigando: no cache de assembly global, em um assembly de host armazenadas se o tempo de execução é hospedado ou na <xref:System.AppDomainSetup.ApplicationBase%2A> e <xref:System.AppDomainSetup.PrivateBinPath%2A> do domínio do aplicativo.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1167">The load context contains assemblies found by probing: in the global assembly cache, in a host assembly store if the runtime is hosted, or in the <xref:System.AppDomainSetup.ApplicationBase%2A> and <xref:System.AppDomainSetup.PrivateBinPath%2A> of the application domain.</span></span> <span data-ttu-id="2cf0e-1168">A maioria das sobrecargas do método <xref:System.Reflection.Assembly.Load%2A> carrega os assemblies nesse contexto.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1168">Most overloads of the <xref:System.Reflection.Assembly.Load%2A> method load assemblies into this context.</span></span>  
  
-   <span data-ttu-id="2cf0e-1169">O contexto de carregamento contém assemblies para os quais o usuário forneceu um caminho que não está incluído na investigação.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1169">The load-from context contains assemblies for which the user provided a path that is not included in probing.</span></span> <span data-ttu-id="2cf0e-1170"><xref:System.Reflection.Assembly.LoadFrom%2A>, <xref:System.AppDomain.CreateInstanceFrom%2A> e <xref:System.AppDomain.ExecuteAssembly%2A> são exemplos de métodos que carregam pelo caminho.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1170"><xref:System.Reflection.Assembly.LoadFrom%2A>, <xref:System.AppDomain.CreateInstanceFrom%2A>, and <xref:System.AppDomain.ExecuteAssembly%2A> are examples of methods that load by path.</span></span>  

    <span data-ttu-id="2cf0e-1171">Começando com o .NET Framework 4, se o URI do `assemblyFile` Especifica um local remoto, carregamento de assembly está desabilitado por padrão e o `LoadFrom` método lança um <xref:System.IO.FileLoadException>.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1171">Starting with .NET Framework 4, if the URI of `assemblyFile` specifies a remote location, assembly loading is disabled by default, and the `LoadFrom` method throws a <xref:System.IO.FileLoadException>.</span></span> <span data-ttu-id="2cf0e-1172">Para habilitar a execução de código carregado a partir de locais remotos, você pode usar o [ `<loadFromRemoteSources>` ](~/docs/framework/configure-apps/file-schema/runtime/loadfromremotesources-element.md) elemento de configuração.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1172">To enable execution of code loaded from remote locations, you can use the [`<loadFromRemoteSources>`](~/docs/framework/configure-apps/file-schema/runtime/loadfromremotesources-element.md) configuration element.</span></span>    
  
-   <span data-ttu-id="2cf0e-1173">O contexto de somente reflexão contém assemblies carregados com o <xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A> e <xref:System.Reflection.Assembly.ReflectionOnlyLoadFrom%2A> métodos; o código nesses contextos não podem ser executados.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1173">The reflection-only context contains assemblies loaded with the <xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A> and <xref:System.Reflection.Assembly.ReflectionOnlyLoadFrom%2A> methods; code in these contexts cannot be executed.</span></span>  
  
-   <span data-ttu-id="2cf0e-1174">Se o usuário gerado ou localizado o assembly, não é em qualquer contexto.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1174">If the user generated or found the assembly, it is not in any context.</span></span> <span data-ttu-id="2cf0e-1175">Isso se aplica aos assemblies carregados usando sobrecargas do <xref:System.Reflection.Assembly.Load%2A> método que especifique uma matriz de bytes que contém um assembly e para os assemblies dinâmicos transitórios criados com a reflexão emite e não são salvas em disco.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1175">This applies to assemblies loaded using overloads of the <xref:System.Reflection.Assembly.Load%2A> method that specify a byte array containing an assembly, and to transient dynamic assemblies created with reflection emit and not saved to disk.</span></span>  
  
 <span data-ttu-id="2cf0e-1176">O contexto de carga permite que um assembly a ser carregado de um caminho que não está incluído na investigação e ainda permite que as dependências nesse caminho a ser encontrado e carregado porque as informações de caminho são mantidas pelo contexto.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1176">The load-from context allows an assembly to be loaded from a path that is not included in probing, and yet allows dependencies on that path to be found and loaded because the path information is maintained by the context.</span></span>  
  
 <span data-ttu-id="2cf0e-1177">O <xref:System.Reflection.Assembly.LoadFrom%2A> método tem as seguintes desvantagens.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1177">The <xref:System.Reflection.Assembly.LoadFrom%2A> method has the following disadvantages.</span></span> <span data-ttu-id="2cf0e-1178">Considere o uso de <xref:System.Reflection.Assembly.Load%2A> em seu lugar.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1178">Consider using <xref:System.Reflection.Assembly.Load%2A> instead.</span></span>  
  
-   <span data-ttu-id="2cf0e-1179">Se um assembly com a mesma identidade já estiver carregado, <xref:System.Reflection.Assembly.LoadFrom%2A> retornará o assembly carregado, mesmo se um caminho diferente foi especificado.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1179">If an assembly with the same identity is already loaded, <xref:System.Reflection.Assembly.LoadFrom%2A> returns the loaded assembly even if a different path was specified.</span></span>  
  
-   <span data-ttu-id="2cf0e-1180">Se um assembly é carregado com <xref:System.Reflection.Assembly.LoadFrom%2A>e posteriormente um assembly no contexto de carga tenta carregar o mesmo assembly por nome de exibição, a tentativa de carregamento falhará.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1180">If an assembly is loaded with <xref:System.Reflection.Assembly.LoadFrom%2A>, and later an assembly in the load context attempts to load the same assembly by display name, the load attempt fails.</span></span> <span data-ttu-id="2cf0e-1181">Isso pode ocorrer quando um assembly é desserializado.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1181">This can occur when an assembly is deserialized.</span></span>  
  
-   <span data-ttu-id="2cf0e-1182">Se um assembly é carregado com <xref:System.Reflection.Assembly.LoadFrom%2A>, e o caminho de investigação inclui um assembly com a mesma identidade, um local diferente, mas uma <xref:System.InvalidCastException>, <xref:System.MissingMethodException>, ou outro comportamento inesperado pode ocorrer.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1182">If an assembly is loaded with <xref:System.Reflection.Assembly.LoadFrom%2A>, and the probing path includes an assembly with the same identity but a different location, an <xref:System.InvalidCastException>, <xref:System.MissingMethodException>, or other unexpected behavior can occur.</span></span>  
  
-   <span data-ttu-id="2cf0e-1183"><xref:System.Reflection.Assembly.LoadFrom%2A> exige <xref:System.Security.Permissions.FileIOPermissionAccess.Read?displayProperty=nameWithType> e <xref:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery?displayProperty=nameWithType>, ou <xref:System.Net.WebPermission>, no caminho especificado.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1183"><xref:System.Reflection.Assembly.LoadFrom%2A> demands <xref:System.Security.Permissions.FileIOPermissionAccess.Read?displayProperty=nameWithType> and <xref:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery?displayProperty=nameWithType>, or <xref:System.Net.WebPermission>, on the specified path.</span></span>  
  
-   <span data-ttu-id="2cf0e-1184">Se não houver uma imagem nativa para `assemblyFile`, ele não é usado.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1184">If a native image exists for `assemblyFile`, it is not used.</span></span> <span data-ttu-id="2cf0e-1185">O assembly não pode ser carregado como de domínio neutro.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1185">The assembly cannot be loaded as domain-neutral.</span></span>  
  
 <span data-ttu-id="2cf0e-1186">O assembly é carregado com a evidência que fornece o carregador.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1186">The assembly is loaded with the evidence that the loader supplies.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="2cf0e-1187"><paramref name="assemblyFile" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1187"><paramref name="assemblyFile" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="2cf0e-1188"><paramref name="assemblyFile" /> não foi encontrado ou o módulo que você está tentando carregar não especifica uma extensão de nome de arquivo.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1188"><paramref name="assemblyFile" /> is not found, or the module you are trying to load does not specify a file name extension.</span></span></exception>
        <exception cref="T:System.IO.FileLoadException"><span data-ttu-id="2cf0e-1189">Não foi possível carregar um arquivo que foi encontrado.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1189">A file that was found could not be loaded.</span></span>

<span data-ttu-id="2cf0e-1190">- ou -</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1190">-or-</span></span>

<span data-ttu-id="2cf0e-1191">A capacidade de executar código em assemblies remotos está desabilitada.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1191">The ability to execute code in remote assemblies is disabled.</span></span> <span data-ttu-id="2cf0e-1192">Veja <see href="https://docs.microsoft.com/dotnet/framework/configure-apps/file-schema/runtime/loadfromremotesources-element">&lt;loadFromRemoteSources&gt;</see>.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1192">See <see href="https://docs.microsoft.com/dotnet/framework/configure-apps/file-schema/runtime/loadfromremotesources-element">&lt;loadFromRemoteSources&gt;</see>.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="2cf0e-1193"><paramref name="assemblyFile" /> não é um assembly válido; por exemplo, um assembly de 32 bits em um processo de 64 bits.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1193"><paramref name="assemblyFile" /> is not a valid assembly; for example, a 32-bit assembly in a 64-bit process.</span></span> <span data-ttu-id="2cf0e-1194">Consulte o tópico de exceção para obter mais informações.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1194">See the exception topic for more information.</span></span>  
  
<span data-ttu-id="2cf0e-1195">- ou -</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1195">-or-</span></span> 
 <span data-ttu-id="2cf0e-1196"><paramref name="assemblyFile" /> foi compilado com uma versão posterior do Common Language Runtime do que a versão carregada atualmente.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1196"><paramref name="assemblyFile" /> was compiled with a later version of the common language runtime than the version that is currently loaded.</span></span></exception>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="2cf0e-1197">Uma base de código que não é iniciada com “file://” foi especificada sem o <see cref="T:System.Net.WebPermission" /> necessário.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1197">A codebase that does not start with "file://" was specified without the required <see cref="T:System.Net.WebPermission" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="2cf0e-1198">O parâmetro <paramref name="assemblyFile" /> é uma cadeia de caracteres vazia ("").</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1198">The <paramref name="assemblyFile" /> parameter is an empty string ("").</span></span></exception>
        <exception cref="T:System.IO.PathTooLongException"><span data-ttu-id="2cf0e-1199">O nome do assembly excede o tamanho máximo definido pelo sistema.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1199">The assembly name exceeds the system-defined maximum length.</span></span></exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="2cf0e-1200">para carregar um assembly com evidências.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1200">to load an assembly with evidence.</span></span> <span data-ttu-id="2cf0e-1201">Enumeração associada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></span><span class="sxs-lookup"><span data-stu-id="2cf0e-1201">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></span></span></permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission"><span data-ttu-id="2cf0e-1202">para ler um URI que começa com "file://".</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1202">for reading a URI that begins with "file://".</span></span> <span data-ttu-id="2cf0e-1203">Enumeração associada: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></span><span class="sxs-lookup"><span data-stu-id="2cf0e-1203">Associated enumeration: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></span></span></permission>
        <permission cref="T:System.Net.WebPermission"><span data-ttu-id="2cf0e-1204">para ler um URI que não começa com "file://".</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1204">for reading a URI that does not begin with "file://".</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="LoadFrom">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly LoadFrom (string assemblyFile, System.Security.Policy.Evidence securityEvidence, byte[] hashValue, System.Configuration.Assemblies.AssemblyHashAlgorithm hashAlgorithm);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly LoadFrom(string assemblyFile, class System.Security.Policy.Evidence securityEvidence, unsigned int8[] hashValue, valuetype System.Configuration.Assemblies.AssemblyHashAlgorithm hashAlgorithm) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.LoadFrom(System.String,System.Security.Policy.Evidence,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LoadFrom (assemblyFile As String, securityEvidence As Evidence, hashValue As Byte(), hashAlgorithm As AssemblyHashAlgorithm) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ LoadFrom(System::String ^ assemblyFile, System::Security::Policy::Evidence ^ securityEvidence, cli::array &lt;System::Byte&gt; ^ hashValue, System::Configuration::Assemblies::AssemblyHashAlgorithm hashAlgorithm);" />
      <MemberSignature Language="F#" Value="static member LoadFrom : string * System.Security.Policy.Evidence * byte[] * System.Configuration.Assemblies.AssemblyHashAlgorithm -&gt; System.Reflection.Assembly" Usage="System.Reflection.Assembly.LoadFrom (assemblyFile, securityEvidence, hashValue, hashAlgorithm)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("This method is obsolete and will be removed in a future release of the .NET Framework. Please use an overload of LoadFrom which does not take an Evidence parameter. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="securityEvidence" Type="System.Security.Policy.Evidence" Index="1" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="hashValue" Type="System.Byte[]" Index="2" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="hashAlgorithm" Type="System.Configuration.Assemblies.AssemblyHashAlgorithm" Index="3" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="assemblyFile"><span data-ttu-id="2cf0e-1205">O nome ou o caminho do arquivo que contém o manifesto do assembly.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1205">The name or path of the file that contains the manifest of the assembly.</span></span></param>
        <param name="securityEvidence"><span data-ttu-id="2cf0e-1206">Evidência para carregar o assembly.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1206">Evidence for loading the assembly.</span></span></param>
        <param name="hashValue"><span data-ttu-id="2cf0e-1207">O valor do código hash calculado.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1207">The value of the computed hash code.</span></span></param>
        <param name="hashAlgorithm"><span data-ttu-id="2cf0e-1208">O algoritmo de hash usado para arquivos de hash e para gerar o nome forte.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1208">The hash algorithm used for hashing files and for generating the strong name.</span></span></param>
        <summary><span data-ttu-id="2cf0e-1209">Carrega um assembly considerando seu nome de arquivo ou caminho, sua evidência de segurança, seu valor de hash e seu algoritmo de hash.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1209">Loads an assembly given its file name or path, security evidence, hash value, and hash algorithm.</span></span></summary>
        <returns><span data-ttu-id="2cf0e-1210">O assembly carregado.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1210">The loaded assembly.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2cf0e-1211">O `assemblyFile` parâmetro deve se referir a um URI sem caracteres de escape.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1211">The `assemblyFile` parameter must refer to a URI without escape characters.</span></span> <span data-ttu-id="2cf0e-1212">Esse método fornece os caracteres de escape para todos os caracteres inválidos no URI.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1212">This method supplies escape characters for all invalid characters in the URI.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="2cf0e-1213">Não há suporte para o protocolo de transferência de arquivo (FTP).</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1213">File transfer protocol (FTP) is not supported.</span></span> <span data-ttu-id="2cf0e-1214">Se o URI fornecido para `assemblyFile` é um endereço FTP, o assembly não é carregado.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1214">If the URI supplied for `assemblyFile` is an FTP address, the assembly is not loaded.</span></span> <span data-ttu-id="2cf0e-1215">Nenhuma exceção é lançada.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1215">No exception is thrown.</span></span>  
  
 <span data-ttu-id="2cf0e-1216">`assemblyFile` pode ser absoluto ou relativo para o diretório atual, e o assembly é carregado para o domínio do chamador.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1216">`assemblyFile` may be absolute or relative to the current directory, and the assembly is loaded into the domain of the caller.</span></span>  
  
 <span data-ttu-id="2cf0e-1217">Assemblies podem ser carregados em um dos três contextos ou podem ser carregados sem contexto:</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1217">Assemblies can be loaded into one of three contexts, or can be loaded without context:</span></span>  
  
-   <span data-ttu-id="2cf0e-1218">O contexto de carregamento contém assemblies localizados investigando: no GAC, em um assembly de host armazenadas se o tempo de execução é hospedado ou na <xref:System.AppDomainSetup.ApplicationBase%2A> e <xref:System.AppDomainSetup.PrivateBinPath%2A> do domínio do aplicativo.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1218">The load context contains assemblies found by probing: in the GAC, in a host assembly store if the runtime is hosted, or in the <xref:System.AppDomainSetup.ApplicationBase%2A> and <xref:System.AppDomainSetup.PrivateBinPath%2A> of the application domain.</span></span> <span data-ttu-id="2cf0e-1219">A maioria das sobrecargas do método <xref:System.Reflection.Assembly.Load%2A> carrega os assemblies nesse contexto.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1219">Most overloads of the <xref:System.Reflection.Assembly.Load%2A> method load assemblies into this context.</span></span>  
  
-   <span data-ttu-id="2cf0e-1220">O contexto de carregamento contém assemblies para os quais o usuário forneceu um caminho que não está incluído nos diretórios pesquisados por sondagem.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1220">The load-from context contains assemblies for which the user provided a path not included in the directories searched by probing.</span></span> <span data-ttu-id="2cf0e-1221"><xref:System.Reflection.Assembly.LoadFrom%2A>, <xref:System.AppDomain.CreateInstanceFrom%2A> e <xref:System.AppDomain.ExecuteAssembly%2A> são exemplos de métodos que carregam pelo caminho.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1221"><xref:System.Reflection.Assembly.LoadFrom%2A>, <xref:System.AppDomain.CreateInstanceFrom%2A>, and <xref:System.AppDomain.ExecuteAssembly%2A> are examples of methods that load by path.</span></span>  

    <span data-ttu-id="2cf0e-1222">Começando com o .NET Framework 4, se o URI do `assemblyFile` Especifica um local remoto, carregamento de assembly está desabilitado por padrão e o `LoadFrom` método lança um <xref:System.IO.FileLoadException>.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1222">Starting with .NET Framework 4, if the URI of `assemblyFile` specifies a remote location, assembly loading is disabled by default, and the `LoadFrom` method throws a <xref:System.IO.FileLoadException>.</span></span> <span data-ttu-id="2cf0e-1223">Para habilitar a execução de código carregado a partir de locais remotos, você pode usar o [ `<loadFromRemoteSources>` ](~/docs/framework/configure-apps/file-schema/runtime/loadfromremotesources-element.md) elemento de configuração.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1223">To enable execution of code loaded from remote locations, you can use the [`<loadFromRemoteSources>`](~/docs/framework/configure-apps/file-schema/runtime/loadfromremotesources-element.md) configuration element.</span></span>    
  
-   <span data-ttu-id="2cf0e-1224">O contexto de somente reflexão contém assemblies carregados com o <xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A> e <xref:System.Reflection.Assembly.ReflectionOnlyLoadFrom%2A> métodos; o código nesses contextos não podem ser executados.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1224">The reflection-only context contains assemblies loaded with the <xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A> and <xref:System.Reflection.Assembly.ReflectionOnlyLoadFrom%2A> methods; code in these contexts cannot be executed.</span></span>  
  
-   <span data-ttu-id="2cf0e-1225">Se o usuário gerado ou localizado o assembly, não é em qualquer contexto.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1225">If the user generated or found the assembly, it is not in any context.</span></span> <span data-ttu-id="2cf0e-1226">Isso se aplica aos assemblies carregados usando sobrecargas do <xref:System.Reflection.Assembly.Load%2A> método que especifique uma matriz de bytes que contém um assembly e para os assemblies dinâmicos transitórios criados com a reflexão emite e não são salvas em disco.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1226">This applies to assemblies loaded using overloads of the <xref:System.Reflection.Assembly.Load%2A> method that specify a byte array containing an assembly, and to transient dynamic assemblies created with reflection emit and not saved to disk.</span></span>  
  
 <span data-ttu-id="2cf0e-1227">O contexto de carga permite que um assembly a ser carregado de um caminho que não está incluído na investigação e ainda permite que as dependências nesse caminho a ser encontrado e carregado porque as informações de caminho são mantidas pelo contexto.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1227">The load-from context allows an assembly to be loaded from a path not included in probing, and yet allows dependencies on that path to be found and loaded because the path information is maintained by the context.</span></span>  
  
 <span data-ttu-id="2cf0e-1228">O <xref:System.Reflection.Assembly.LoadFrom%2A> método tem as seguintes desvantagens.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1228">The <xref:System.Reflection.Assembly.LoadFrom%2A> method has the following disadvantages.</span></span> <span data-ttu-id="2cf0e-1229">Considere o uso de <xref:System.Reflection.Assembly.Load%2A> em seu lugar.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1229">Consider using <xref:System.Reflection.Assembly.Load%2A> instead.</span></span>  
  
-   <span data-ttu-id="2cf0e-1230">Se um assembly com a mesma identidade já estiver carregado, <xref:System.Reflection.Assembly.LoadFrom%2A> retornará o assembly carregado, mesmo se um caminho diferente foi especificado.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1230">If an assembly with the same identity is already loaded, <xref:System.Reflection.Assembly.LoadFrom%2A> returns the loaded assembly even if a different path was specified.</span></span>  
  
-   <span data-ttu-id="2cf0e-1231">Se um assembly é carregado com <xref:System.Reflection.Assembly.LoadFrom%2A>e posteriormente um assembly no contexto de carga tenta carregar o mesmo assembly por nome de exibição, a tentativa de carregamento falhará.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1231">If an assembly is loaded with <xref:System.Reflection.Assembly.LoadFrom%2A>, and later an assembly in the load context attempts to load the same assembly by display name, the load attempt fails.</span></span> <span data-ttu-id="2cf0e-1232">Isso pode ocorrer quando um assembly é desserializado.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1232">This can occur when an assembly is deserialized.</span></span>  
  
-   <span data-ttu-id="2cf0e-1233">Se um assembly é carregado com <xref:System.Reflection.Assembly.LoadFrom%2A>, e o caminho de investigação inclui um assembly com a mesma identidade, um local diferente, mas uma <xref:System.InvalidCastException>, <xref:System.MissingMethodException>, ou outro comportamento inesperado pode ocorrer.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1233">If an assembly is loaded with <xref:System.Reflection.Assembly.LoadFrom%2A>, and the probing path includes an assembly with the same identity but a different location, an <xref:System.InvalidCastException>, <xref:System.MissingMethodException>, or other unexpected behavior can occur.</span></span>  
  
-   <span data-ttu-id="2cf0e-1234"><xref:System.Reflection.Assembly.LoadFrom%2A> exige <xref:System.Security.Permissions.FileIOPermissionAccess.Read?displayProperty=nameWithType> e <xref:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery?displayProperty=nameWithType>, ou <xref:System.Net.WebPermission>, no caminho especificado.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1234"><xref:System.Reflection.Assembly.LoadFrom%2A> demands <xref:System.Security.Permissions.FileIOPermissionAccess.Read?displayProperty=nameWithType> and <xref:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery?displayProperty=nameWithType>, or <xref:System.Net.WebPermission>, on the specified path.</span></span>  
  
-   <span data-ttu-id="2cf0e-1235">Se não houver uma imagem nativa para `assemblyFile`, ele não é usado.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1235">If a native image exists for `assemblyFile`, it is not used.</span></span> <span data-ttu-id="2cf0e-1236">O assembly não pode ser carregado como domínio neutro.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1236">The assembly cannot be loaded as domain neutral.</span></span>  
  
-   <span data-ttu-id="2cf0e-1237">No .NET Framework versão 1.0 e 1.1, a política não é aplicada.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1237">In the .NET Framework version 1.0 and 1.1, policy is not applied.</span></span>  
  
 <span data-ttu-id="2cf0e-1238">Se determinadas permissões são concedidas ou não a um assembly é algo que se baseia na evidência.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1238">Whether certain permissions are granted or not granted to an assembly is based on evidence.</span></span> <span data-ttu-id="2cf0e-1239">As regras para o assembly e a mesclagem de evidência de segurança são da seguinte maneira:</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1239">The rules for assembly and security evidence merging are as follows:</span></span>  
  
-   <span data-ttu-id="2cf0e-1240">Quando você usa um <xref:System.Reflection.Assembly.LoadFrom%2A> método sem nenhum <xref:System.Security.Policy.Evidence> parâmetro, o assembly é carregado com a evidência que fornece o carregador.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1240">When you use a <xref:System.Reflection.Assembly.LoadFrom%2A> method with no <xref:System.Security.Policy.Evidence> parameter, the assembly is loaded with the evidence that the loader supplies.</span></span>  
  
-   <span data-ttu-id="2cf0e-1241">Quando você usa um <xref:System.Reflection.Assembly.LoadFrom%2A> método com um <xref:System.Security.Policy.Evidence> parâmetro, partes de evidências são mesclados.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1241">When you use a <xref:System.Reflection.Assembly.LoadFrom%2A> method with an <xref:System.Security.Policy.Evidence> parameter, pieces of evidence are merged.</span></span> <span data-ttu-id="2cf0e-1242">Partes de evidências fornecida como um argumento para o <xref:System.Reflection.Assembly.LoadFrom%2A> método substituir partes de evidências fornecida pelo carregador.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1242">Pieces of evidence supplied as an argument to the <xref:System.Reflection.Assembly.LoadFrom%2A> method supersede pieces of evidence supplied by the loader.</span></span>  
  
-   <span data-ttu-id="2cf0e-1243">Se você chamar esse método mais de uma vez no mesmo assembly, mas com uma evidência diferente especificada, o common language runtime não lança uma <xref:System.IO.FileLoadException> porque não não possível determinar a igualdade e a integridade das especificações de evidências diferentes.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1243">If you call this method more than once on the same assembly but with a different evidence specified, the common language runtime does not throw a <xref:System.IO.FileLoadException> because the equality and integrity of the different evidence specifications cannot be determined.</span></span> <span data-ttu-id="2cf0e-1244">A evidência que vem primeiro é a evidência que é usada.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1244">The evidence that first succeeds is the evidence that is used.</span></span>  
  
-   <span data-ttu-id="2cf0e-1245">Quando você usa um <xref:System.Reflection.Assembly.LoadFrom%2A> método com um `Byte[]` parâmetro para carregar uma objeto arquivo formato COFF imagem comum, evidência é combinado.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1245">When you use a <xref:System.Reflection.Assembly.LoadFrom%2A> method with a `Byte[]` parameter to load a common object file format (COFF) image, evidence is combined.</span></span> <span data-ttu-id="2cf0e-1246">`Zone`, `Url` e `Site` são herdadas do assembly de chamada, e `Hash` e `StrongName` são obtidos do assembly COFF.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1246">`Zone`, `Url` and `Site` are inherited from the calling assembly, and `Hash` and `StrongName` are taken from the COFF assembly.</span></span>  
  
-   <span data-ttu-id="2cf0e-1247">Quando você usa um <xref:System.Reflection.Assembly.LoadFrom%2A> método com um `Byte[]` parâmetro e <xref:System.Security.Policy.Evidence> para carregar uma imagem COFF, somente a evidência fornecida é usada.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1247">When you use a <xref:System.Reflection.Assembly.LoadFrom%2A> method with a `Byte[]` parameter and <xref:System.Security.Policy.Evidence> to load a COFF image, only the supplied evidence is used.</span></span> <span data-ttu-id="2cf0e-1248">Evidência do assembly de chamada e evidência da imagem COFF são ignorados.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1248">Evidence of the calling assembly and evidence of the COFF image is ignored.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="2cf0e-1249"><paramref name="assemblyFile" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1249"><paramref name="assemblyFile" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="2cf0e-1250"><paramref name="assemblyFile" /> não foi encontrado, ou o módulo que você está tentando carregar não especifica uma extensão de nome de arquivo.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1250"><paramref name="assemblyFile" /> is not found, or the module you are trying to load does not specify a filename extension.</span></span></exception>
        <exception cref="T:System.IO.FileLoadException"><span data-ttu-id="2cf0e-1251">Não foi possível carregar um arquivo que foi encontrado.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1251">A file that was found could not be loaded.</span></span>  
  
<span data-ttu-id="2cf0e-1252">- ou -</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1252">-or-</span></span> 
<span data-ttu-id="2cf0e-1253">O <paramref name="securityEvidence" /> não é ambíguo e é determinado como inválido.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1253">The <paramref name="securityEvidence" /> is not ambiguous and is determined to be invalid.</span></span>

<span data-ttu-id="2cf0e-1254">- ou -</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1254">-or-</span></span>

<span data-ttu-id="2cf0e-1255">A capacidade de executar código em assemblies remotos está desabilitada.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1255">The ability to execute code in remote assemblies is disabled.</span></span> <span data-ttu-id="2cf0e-1256">Veja <see href="https://docs.microsoft.com/dotnet/framework/configure-apps/file-schema/runtime/loadfromremotesources-element">&lt;loadFromRemoteSources&gt;</see>.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1256">See <see href="https://docs.microsoft.com/dotnet/framework/configure-apps/file-schema/runtime/loadfromremotesources-element">&lt;loadFromRemoteSources&gt;</see>.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="2cf0e-1257"><paramref name="assemblyFile" /> não é um assembly válido; por exemplo, um assembly de 32 bits em um processo de 64 bits.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1257"><paramref name="assemblyFile" /> is not a valid assembly; for example, a 32-bit assembly in a 64-bit process.</span></span> <span data-ttu-id="2cf0e-1258">Consulte o tópico de exceção para obter mais informações.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1258">See the exception topic for more information.</span></span>  
  
<span data-ttu-id="2cf0e-1259">- ou -</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1259">-or-</span></span> 
<span data-ttu-id="2cf0e-1260">A versão 2,0 ou posterior do Common Language Runtime está carregada e <paramref name="assemblyFile" /> foi compilada com uma versão posterior.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1260">Version 2.0 or later of the common language runtime is currently loaded and <paramref name="assemblyFile" /> was compiled with a later version.</span></span></exception>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="2cf0e-1261">Uma base de código que não é iniciada com “file://” foi especificada sem o <see cref="T:System.Net.WebPermission" /> necessário.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1261">A codebase that does not start with "file://" was specified without the required <see cref="T:System.Net.WebPermission" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="2cf0e-1262">O parâmetro <paramref name="assemblyFile" /> é uma cadeia de caracteres vazia ("").</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1262">The <paramref name="assemblyFile" /> parameter is an empty string ("").</span></span></exception>
        <exception cref="T:System.IO.PathTooLongException"><span data-ttu-id="2cf0e-1263">O nome do assembly excede o tamanho máximo definido pelo sistema.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1263">The assembly name exceeds the system-defined maximum length.</span></span></exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="2cf0e-1264">para carregar um assembly com evidências.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1264">to load an assembly with evidence.</span></span> <span data-ttu-id="2cf0e-1265">Enumeração associada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></span><span class="sxs-lookup"><span data-stu-id="2cf0e-1265">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></span></span></permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission"><span data-ttu-id="2cf0e-1266">para ler um URI que começa com "file://".</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1266">for reading a URI that begins with "file://".</span></span> <span data-ttu-id="2cf0e-1267">Enumeração associada: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></span><span class="sxs-lookup"><span data-stu-id="2cf0e-1267">Associated enumeration: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></span></span></permission>
        <permission cref="T:System.Net.WebPermission"><span data-ttu-id="2cf0e-1268">para ler um URI que não começa com "file://".</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1268">for reading a URI that does not begin with "file://".</span></span></permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="LoadModule">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="2cf0e-1269">Carrega o módulo interno para este assembly.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1269">Loads the module internal to this assembly.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="LoadModule">
      <MemberSignature Language="C#" Value="public System.Reflection.Module LoadModule (string moduleName, byte[] rawModule);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Module LoadModule(string moduleName, unsigned int8[] rawModule) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.LoadModule(System.String,System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Function LoadModule (moduleName As String, rawModule As Byte()) As Module" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Module ^ LoadModule(System::String ^ moduleName, cli::array &lt;System::Byte&gt; ^ rawModule);" />
      <MemberSignature Language="F#" Value="abstract member LoadModule : string * byte[] -&gt; System.Reflection.Module&#xA;override this.LoadModule : string * byte[] -&gt; System.Reflection.Module" Usage="assembly.LoadModule (moduleName, rawModule)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.LoadModule(System.String,System.Byte[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Module</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="moduleName" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="rawModule" Type="System.Byte[]" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="moduleName"><span data-ttu-id="2cf0e-1270">O nome do módulo.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1270">The name of the module.</span></span> <span data-ttu-id="2cf0e-1271">Essa cadeia de caracteres deve corresponder a um nome de arquivo no manifesto deste assembly.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1271">This string must correspond to a file name in this assembly's manifest.</span></span></param>
        <param name="rawModule"><span data-ttu-id="2cf0e-1272">Uma matriz de bytes que é uma imagem baseada em COFF que contém módulo omitido ou um recurso.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1272">A byte array that is a COFF-based image containing an emitted module, or a resource.</span></span></param>
        <summary><span data-ttu-id="2cf0e-1273">Carrega o módulo, interno a esse assembly, com uma imagem baseada no formato COFF que contém um módulo emitido ou um arquivo de recurso.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1273">Loads the module, internal to this assembly, with a common object file format (COFF)-based image containing an emitted module, or a resource file.</span></span></summary>
        <returns><span data-ttu-id="2cf0e-1274">O módulo carregado.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1274">The loaded module.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="2cf0e-1275"><paramref name="moduleName" /> ou <paramref name="rawModule" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1275"><paramref name="moduleName" /> or <paramref name="rawModule" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="2cf0e-1276"><paramref name="moduleName" /> não coincide com uma entrada de arquivo no manifesto deste assembly.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1276"><paramref name="moduleName" /> does not match a file entry in this assembly's manifest.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="2cf0e-1277"><paramref name="rawModule" /> não é um módulo válido.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1277"><paramref name="rawModule" /> is not a valid module.</span></span></exception>
        <exception cref="T:System.IO.FileLoadException"><span data-ttu-id="2cf0e-1278">Não foi possível carregar um arquivo que foi encontrado.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1278">A file that was found could not be loaded.</span></span></exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="2cf0e-1279">para fornecer evidência.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1279">to provide evidence.</span></span> <span data-ttu-id="2cf0e-1280">Enumeração associada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></span><span class="sxs-lookup"><span data-stu-id="2cf0e-1280">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="LoadModule">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.Module LoadModule (string moduleName, byte[] rawModule, byte[] rawSymbolStore);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Module LoadModule(string moduleName, unsigned int8[] rawModule, unsigned int8[] rawSymbolStore) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.LoadModule(System.String,System.Byte[],System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function LoadModule (moduleName As String, rawModule As Byte(), rawSymbolStore As Byte()) As Module" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Module ^ LoadModule(System::String ^ moduleName, cli::array &lt;System::Byte&gt; ^ rawModule, cli::array &lt;System::Byte&gt; ^ rawSymbolStore);" />
      <MemberSignature Language="F#" Value="abstract member LoadModule : string * byte[] * byte[] -&gt; System.Reflection.Module&#xA;override this.LoadModule : string * byte[] * byte[] -&gt; System.Reflection.Module" Usage="assembly.LoadModule (moduleName, rawModule, rawSymbolStore)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.LoadModule(System.String,System.Byte[],System.Byte[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Module</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="moduleName" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="rawModule" Type="System.Byte[]" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="rawSymbolStore" Type="System.Byte[]" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="moduleName"><span data-ttu-id="2cf0e-1281">O nome do módulo.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1281">The name of the module.</span></span> <span data-ttu-id="2cf0e-1282">Essa cadeia de caracteres deve corresponder a um nome de arquivo no manifesto deste assembly.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1282">This string must correspond to a file name in this assembly's manifest.</span></span></param>
        <param name="rawModule"><span data-ttu-id="2cf0e-1283">Uma matriz de bytes que é uma imagem baseada em COFF que contém módulo omitido ou um recurso.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1283">A byte array that is a COFF-based image containing an emitted module, or a resource.</span></span></param>
        <param name="rawSymbolStore"><span data-ttu-id="2cf0e-1284">Uma matriz de bytes contendo os bytes brutos que representam os símbolos para o módulo.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1284">A byte array containing the raw bytes representing the symbols for the module.</span></span> <span data-ttu-id="2cf0e-1285">Deve ser <see langword="null" /> quando se trata de um arquivo de recurso.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1285">Must be <see langword="null" /> if this is a resource file.</span></span></param>
        <summary><span data-ttu-id="2cf0e-1286">Carrega o módulo, interno a esse assembly, com uma imagem baseada no formato COFF que contém um módulo emitido ou um arquivo de recurso.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1286">Loads the module, internal to this assembly, with a common object file format (COFF)-based image containing an emitted module, or a resource file.</span></span> <span data-ttu-id="2cf0e-1287">Os bytes brutos que representam os símbolos para o módulo também são carregados.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1287">The raw bytes representing the symbols for the module are also loaded.</span></span></summary>
        <returns><span data-ttu-id="2cf0e-1288">O módulo carregado.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1288">The loaded module.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="2cf0e-1289"><paramref name="moduleName" /> ou <paramref name="rawModule" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1289"><paramref name="moduleName" /> or <paramref name="rawModule" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="2cf0e-1290"><paramref name="moduleName" /> não coincide com uma entrada de arquivo no manifesto deste assembly.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1290"><paramref name="moduleName" /> does not match a file entry in this assembly's manifest.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="2cf0e-1291"><paramref name="rawModule" /> não é um módulo válido.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1291"><paramref name="rawModule" /> is not a valid module.</span></span></exception>
        <exception cref="T:System.IO.FileLoadException"><span data-ttu-id="2cf0e-1292">Não foi possível carregar um arquivo que foi encontrado.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1292">A file that was found could not be loaded.</span></span></exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="2cf0e-1293">para fornecer evidência.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1293">to provide evidence.</span></span> <span data-ttu-id="2cf0e-1294">Enumeração associada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></span><span class="sxs-lookup"><span data-stu-id="2cf0e-1294">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></span></span></permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="LoadWithPartialName">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="2cf0e-1295">Carrega um assembly do diretório do aplicativo ou do cache de assembly global usando um nome parcial.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1295">Loads an assembly from the application directory or from the global assembly cache using a partial name.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  <span data-ttu-id="2cf0e-1296">As sobrecargas de <xref:System.Reflection.Assembly.LoadWithPartialName%2A?displayProperty=nameWithType> método são obsoleto e tiver sido mantido para compatibilidade com versões anteriores.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1296">The overloads of the <xref:System.Reflection.Assembly.LoadWithPartialName%2A?displayProperty=nameWithType> method are obsolete and have been retained for backward compatibility.</span></span> <span data-ttu-id="2cf0e-1297">A alternativa não obsoleta é <xref:System.Reflection.Assembly.Load%28System.String%29?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1297">The non-obsolete alternative is <xref:System.Reflection.Assembly.Load%28System.String%29?displayProperty=nameWithType>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="LoadWithPartialName">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly LoadWithPartialName (string partialName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly LoadWithPartialName(string partialName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.LoadWithPartialName(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LoadWithPartialName (partialName As String) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ LoadWithPartialName(System::String ^ partialName);" />
      <MemberSignature Language="F#" Value="static member LoadWithPartialName : string -&gt; System.Reflection.Assembly" Usage="System.Reflection.Assembly.LoadWithPartialName partialName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.Obsolete("This method has been deprecated. Please use Assembly.Load() instead. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-3.0;netstandard-2.1">
          <AttributeName>System.Obsolete("This method has been deprecated. Please use Assembly.Load() instead. https://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="partialName" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="partialName"><span data-ttu-id="2cf0e-1298">O nome para exibição do assembly.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1298">The display name of the assembly.</span></span></param>
        <summary><span data-ttu-id="2cf0e-1299">Carrega um assembly do diretório do aplicativo ou do cache de assembly global usando um nome parcial.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1299">Loads an assembly from the application directory or from the global assembly cache using a partial name.</span></span></summary>
        <returns><span data-ttu-id="2cf0e-1300">O assembly carregado.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1300">The loaded assembly.</span></span> <span data-ttu-id="2cf0e-1301">Se <paramref name="partialName" /> não foi encontrado, este método retorn <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1301">If <paramref name="partialName" /> is not found, this method returns <see langword="null" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  <span data-ttu-id="2cf0e-1302">O <xref:System.Reflection.Assembly.LoadWithPartialName%28System.String%29> método é obsoleto e foi mantido para compatibilidade com versões anteriores.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1302">The <xref:System.Reflection.Assembly.LoadWithPartialName%28System.String%29> method is obsolete and has been retained for backward compatibility.</span></span> <span data-ttu-id="2cf0e-1303">A alternativa não obsoleta é <xref:System.Reflection.Assembly.Load%28System.String%29?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1303">The non-obsolete alternative is <xref:System.Reflection.Assembly.Load%28System.String%29?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="2cf0e-1304">Aplicativos que carregam os assemblies com esse método serão afetados pelas atualizações desses assemblies.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1304">Applications that load assemblies with this method will be affected by upgrades of those assemblies.</span></span> <span data-ttu-id="2cf0e-1305">Portanto, não use esse método; recriar o aplicativo para usar o <xref:System.Reflection.Assembly.Load%28System.String%29> sobrecarga de método ou o <xref:System.Reflection.Assembly.LoadFrom%28System.String%29> sobrecarga de método.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1305">Therefore, do not use this method; redesign the application to use the <xref:System.Reflection.Assembly.Load%28System.String%29> method overload or the <xref:System.Reflection.Assembly.LoadFrom%28System.String%29> method overload.</span></span>  
  
 <span data-ttu-id="2cf0e-1306">Esse método primeiro chama <xref:System.Reflection.Assembly.Load%2A>.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1306">This method first calls <xref:System.Reflection.Assembly.Load%2A>.</span></span> <span data-ttu-id="2cf0e-1307">Se o assembly não for encontrado, esse método retorna o assembly do cache de assembly global que tem o mesmo nome simples e o maior número de versão.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1307">If the assembly is not found, this method returns the assembly from the global assembly cache that has the same simple name, and the highest version number.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="2cf0e-1308">O parâmetro <paramref name="partialName" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1308">The <paramref name="partialName" /> parameter is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="2cf0e-1309"><paramref name="assemblyFile" /> não é um assembly válido.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1309"><paramref name="assemblyFile" /> is not a valid assembly.</span></span>  
  
<span data-ttu-id="2cf0e-1310">- ou -</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1310">-or-</span></span> 
<span data-ttu-id="2cf0e-1311">A versão 2,0 ou posterior do Common Language Runtime está carregada e <paramref name="partialName" /> foi compilada com uma versão posterior.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1311">Version 2.0 or later of the common language runtime is currently loaded and <paramref name="partialName" /> was compiled with a later version.</span></span></exception>
        <altmember cref="M:System.Reflection.Assembly.Load(System.String)" />
        <altmember cref="M:System.Reflection.Assembly.LoadFrom(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="LoadWithPartialName">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly LoadWithPartialName (string partialName, System.Security.Policy.Evidence securityEvidence);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly LoadWithPartialName(string partialName, class System.Security.Policy.Evidence securityEvidence) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.LoadWithPartialName(System.String,System.Security.Policy.Evidence)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LoadWithPartialName (partialName As String, securityEvidence As Evidence) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ LoadWithPartialName(System::String ^ partialName, System::Security::Policy::Evidence ^ securityEvidence);" />
      <MemberSignature Language="F#" Value="static member LoadWithPartialName : string * System.Security.Policy.Evidence -&gt; System.Reflection.Assembly" Usage="System.Reflection.Assembly.LoadWithPartialName (partialName, securityEvidence)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("This method has been deprecated. Please use Assembly.Load() instead. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="partialName" Type="System.String" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="securityEvidence" Type="System.Security.Policy.Evidence" Index="1" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="partialName"><span data-ttu-id="2cf0e-1312">O nome para exibição do assembly.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1312">The display name of the assembly.</span></span></param>
        <param name="securityEvidence"><span data-ttu-id="2cf0e-1313">Evidência para carregar o assembly.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1313">Evidence for loading the assembly.</span></span></param>
        <summary><span data-ttu-id="2cf0e-1314">Carrega um assembly do diretório do aplicativo ou do cache de assembly global usando um nome parcial.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1314">Loads an assembly from the application directory or from the global assembly cache using a partial name.</span></span> <span data-ttu-id="2cf0e-1315">O assembly é carregado no domínio do chamador usando a evidência fornecida.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1315">The assembly is loaded into the domain of the caller using the supplied evidence.</span></span></summary>
        <returns><span data-ttu-id="2cf0e-1316">O assembly carregado.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1316">The loaded assembly.</span></span> <span data-ttu-id="2cf0e-1317">Se <paramref name="partialName" /> não foi encontrado, este método retorn <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1317">If <paramref name="partialName" /> is not found, this method returns <see langword="null" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  <span data-ttu-id="2cf0e-1318">O <xref:System.Reflection.Assembly.LoadWithPartialName%28System.String%2CSystem.Security.Policy.Evidence%29> método é obsoleto e foi mantido para compatibilidade com versões anteriores.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1318">The <xref:System.Reflection.Assembly.LoadWithPartialName%28System.String%2CSystem.Security.Policy.Evidence%29> method is obsolete and has been retained for backward compatibility.</span></span> <span data-ttu-id="2cf0e-1319">A alternativa não obsoleta é <xref:System.Reflection.Assembly.Load%28System.String%29?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1319">The non-obsolete alternative is <xref:System.Reflection.Assembly.Load%28System.String%29?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="2cf0e-1320">Evidência é o conjunto de informações que constitui a entrada para decisões de política de segurança, como quais permissões podem ser concedidas ao código.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1320">Evidence is the set of information that constitutes input to security policy decisions, such as what permissions can be granted to code.</span></span>  
  
 <span data-ttu-id="2cf0e-1321">Aplicativos que carregam os assemblies com esse método serão afetados pelas atualizações desses assemblies.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1321">Applications that load assemblies with this method will be affected by upgrades of those assemblies.</span></span> <span data-ttu-id="2cf0e-1322">Portanto, não use esse método; recriar o aplicativo para usar o <xref:System.Reflection.Assembly.Load%2A> método ou o <xref:System.Reflection.Assembly.LoadFrom%2A> método.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1322">Therefore, do not use this method; redesign the application to use the <xref:System.Reflection.Assembly.Load%2A> method or the <xref:System.Reflection.Assembly.LoadFrom%2A> method.</span></span>  
  
 <span data-ttu-id="2cf0e-1323">Esse método primeiro chama <xref:System.Reflection.Assembly.Load%2A>.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1323">This method first calls <xref:System.Reflection.Assembly.Load%2A>.</span></span> <span data-ttu-id="2cf0e-1324">Se o assembly não for encontrado, esse método retorna o assembly do cache de assembly global que tem o mesmo nome simples e o maior número de versão.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1324">If the assembly is not found, this method returns the assembly from the global assembly cache that has the same simple name, and the highest version number.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.FileLoadException"><span data-ttu-id="2cf0e-1325">Um assembly ou módulo foi carregado duas vezes com dois conjuntos de evidências.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1325">An assembly or module was loaded twice with two different sets of evidence.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="2cf0e-1326">O parâmetro <paramref name="partialName" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1326">The <paramref name="partialName" /> parameter is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="2cf0e-1327"><paramref name="assemblyFile" /> não é um assembly válido.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1327"><paramref name="assemblyFile" /> is not a valid assembly.</span></span>  
  
<span data-ttu-id="2cf0e-1328">- ou -</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1328">-or-</span></span> 
<span data-ttu-id="2cf0e-1329">A versão 2,0 ou posterior do Common Language Runtime está carregada e <paramref name="partialName" /> foi compilada com uma versão posterior.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1329">Version 2.0 or later of the common language runtime is currently loaded and <paramref name="partialName" /> was compiled with a later version.</span></span></exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="2cf0e-1330">para chamar código não gerenciado e carregar um assembly com evidências.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1330">for calling unmanaged code and to load an assembly with evidence.</span></span> <span data-ttu-id="2cf0e-1331">Enumeração associada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></span><span class="sxs-lookup"><span data-stu-id="2cf0e-1331">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></span></span></permission>
        <altmember cref="M:System.Reflection.Assembly.Load(System.String)" />
        <altmember cref="M:System.Reflection.Assembly.LoadFrom(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="Location">
      <MemberSignature Language="C#" Value="public virtual string Location { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Location" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.Location" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property Location As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ Location { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Location : string" Usage="System.Reflection.Assembly.Location" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Assembly.Location</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="2cf0e-1332">Obtém o caminho completo ou uma localização UNC do arquivo carregado que contém o manifesto.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1332">Gets the full path or UNC location of the loaded file that contains the manifest.</span></span></summary>
        <value><span data-ttu-id="2cf0e-1333">A localização do arquivo carregado que contém o manifesto.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1333">The location of the loaded file that contains the manifest.</span></span> <span data-ttu-id="2cf0e-1334">Se o arquivo carregado tiver uma cópia de sombra, o local é a do arquivo após a cópia de sombra.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1334">If the loaded file was shadow-copied, the location is that of the file after being shadow-copied.</span></span> <span data-ttu-id="2cf0e-1335">Se o assembly for carregado de uma matriz de bytes, como ao usar a sobrecarga de método <see cref="M:System.Reflection.Assembly.Load(System.Byte[])" />, o valor retornado será uma cadeia de caracteres vazia ("").</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1335">If the assembly is loaded from a byte array, such as when using the <see cref="M:System.Reflection.Assembly.Load(System.Byte[])" /> method overload, the value returned is an empty string ("").</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2cf0e-1336">Para obter o local antes do arquivo tiver sido copiado de sombra, use o <xref:System.Reflection.Assembly.CodeBase%2A> propriedade.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1336">To get the location before the file has been shadow-copied, use the <xref:System.Reflection.Assembly.CodeBase%2A> property.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="2cf0e-1337">O exemplo a seguir exibe o local do arquivo carregado que contém o manifesto.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1337">The following example displays the location of the loaded file that contains the manifest.</span></span>  
  
 [!code-cpp[System.Reflection.Assembly#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Assembly/CPP/assembly.cpp#3)]
 [!code-csharp[System.Reflection.Assembly#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Assembly/CS/assembly.cs#3)]
 [!code-vb[System.Reflection.Assembly#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Assembly/VB/assembly.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="2cf0e-1338">O assembly atual é um assembly dinâmico, representado por um objeto <see cref="T:System.Reflection.Emit.AssemblyBuilder" />.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1338">The current assembly is a dynamic assembly, represented by an <see cref="T:System.Reflection.Emit.AssemblyBuilder" /> object.</span></span></exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission"><span data-ttu-id="2cf0e-1339">para acesso ao caminho.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1339">for access to the path.</span></span> <span data-ttu-id="2cf0e-1340">Enumeração associada: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></span><span class="sxs-lookup"><span data-stu-id="2cf0e-1340">Associated enumeration: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></span></span></permission>
        <related type="Article" href="~/docs/framework/app-domains/shadow-copy-assemblies.md"><span data-ttu-id="2cf0e-1341">Criando cópias de sombra de assemblies</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1341">Shadow Copying Assemblies</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="ManifestModule">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.Module ManifestModule { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.Module ManifestModule" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.ManifestModule" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property ManifestModule As Module" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::Module ^ ManifestModule { System::Reflection::Module ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ManifestModule : System.Reflection.Module" Usage="System.Reflection.Assembly.ManifestModule" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Module</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="2cf0e-1342">Obtém o módulo que contém o manifesto do assembly atual.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1342">Gets the module that contains the manifest for the current assembly.</span></span></summary>
        <value><span data-ttu-id="2cf0e-1343">O módulo que contém o manifesto do assembly.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1343">The module that contains the manifest for the assembly.</span></span></value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ModuleResolve">
      <MemberSignature Language="C#" Value="public virtual event System.Reflection.ModuleResolveEventHandler ModuleResolve;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Reflection.ModuleResolveEventHandler ModuleResolve" />
      <MemberSignature Language="DocId" Value="E:System.Reflection.Assembly.ModuleResolve" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Custom Event ModuleResolve As ModuleResolveEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Reflection::ModuleResolveEventHandler ^ ModuleResolve;" />
      <MemberSignature Language="F#" Value="member this.ModuleResolve : System.Reflection.ModuleResolveEventHandler " Usage="member this.ModuleResolve : System.Reflection.ModuleResolveEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Runtime.InteropServices._Assembly.ModuleResolve</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>add: System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>remove: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.ModuleResolveEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="2cf0e-1344">Ocorre quando o carregador de classe do Common Language Runtime não é capaz de resolver uma referência a um módulo interno de um assembly por meios normais.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1344">Occurs when the common language runtime class loader cannot resolve a reference to an internal module of an assembly through normal means.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2cf0e-1345">Este evento dá o retorno de chamada a oportunidade de localizar e carregar o módulo em si e retorná-lo.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1345">This event gives the callback a chance to find and load the module itself and return it.</span></span>  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="2cf0e-1346">Requer confiança total para o chamador imediato.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1346">Requires full trust for the immediate caller.</span></span> <span data-ttu-id="2cf0e-1347">Este membro não pode ser usado pelo código transparente ou parcialmente confiável.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1347">This member cannot be used by partially trusted or transparent code.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="Modules">
      <MemberSignature Language="C#" Value="public virtual System.Collections.Generic.IEnumerable&lt;System.Reflection.Module&gt; Modules { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IEnumerable`1&lt;class System.Reflection.Module&gt; Modules" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.Modules" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property Modules As IEnumerable(Of Module)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Collections::Generic::IEnumerable&lt;System::Reflection::Module ^&gt; ^ Modules { System::Collections::Generic::IEnumerable&lt;System::Reflection::Module ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Modules : seq&lt;System.Reflection.Module&gt;" Usage="System.Reflection.Assembly.Modules" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Reflection.Module&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="2cf0e-1348">Obtém uma coleção que contém os módulos neste assembly.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1348">Gets a collection that contains the modules in this assembly.</span></span></summary>
        <value><span data-ttu-id="2cf0e-1349">Uma coleção que contém os módulos neste assembly.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1349">A collection that contains the modules in this assembly.</span></span></value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (System.Reflection.Assembly left, System.Reflection.Assembly right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(class System.Reflection.Assembly left, class System.Reflection.Assembly right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.op_Equality(System.Reflection.Assembly,System.Reflection.Assembly)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator == (left As Assembly, right As Assembly) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator ==(System::Reflection::Assembly ^ left, System::Reflection::Assembly ^ right);" />
      <MemberSignature Language="F#" Value="static member ( = ) : System.Reflection.Assembly * System.Reflection.Assembly -&gt; bool" Usage="left = right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Reflection.Assembly" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="right" Type="System.Reflection.Assembly" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="2cf0e-1350">O assembly a ser comparado com <paramref name="right" />.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1350">The assembly to compare to <paramref name="right" />.</span></span></param>
        <param name="right"><span data-ttu-id="2cf0e-1351">O assembly a ser comparado com <paramref name="left" />.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1351">The assembly to compare to <paramref name="left" />.</span></span></param>
        <summary><span data-ttu-id="2cf0e-1352">Indica se dois objetos <see cref="T:System.Reflection.Assembly" /> são iguais.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1352">Indicates whether two <see cref="T:System.Reflection.Assembly" /> objects are equal.</span></span></summary>
        <returns><span data-ttu-id="2cf0e-1353"><see langword="true" /> se <paramref name="left" /> for igual a <paramref name="right" />; caso contrário, <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1353"><see langword="true" /> if <paramref name="left" /> is equal to <paramref name="right" />; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (System.Reflection.Assembly left, System.Reflection.Assembly right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(class System.Reflection.Assembly left, class System.Reflection.Assembly right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.op_Inequality(System.Reflection.Assembly,System.Reflection.Assembly)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator != (left As Assembly, right As Assembly) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator !=(System::Reflection::Assembly ^ left, System::Reflection::Assembly ^ right);" />
      <MemberSignature Language="F#" Value="static member op_Inequality : System.Reflection.Assembly * System.Reflection.Assembly -&gt; bool" Usage="System.Reflection.Assembly.op_Inequality (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Reflection.Assembly" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="right" Type="System.Reflection.Assembly" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="2cf0e-1354">O assembly a ser comparado com <paramref name="right" />.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1354">The assembly to compare to <paramref name="right" />.</span></span></param>
        <param name="right"><span data-ttu-id="2cf0e-1355">O assembly a ser comparado com <paramref name="left" />.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1355">The assembly to compare to <paramref name="left" />.</span></span></param>
        <summary><span data-ttu-id="2cf0e-1356">Indica se dois objetos <see cref="T:System.Reflection.Assembly" /> não são iguais.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1356">Indicates whether two <see cref="T:System.Reflection.Assembly" /> objects are not equal.</span></span></summary>
        <returns><span data-ttu-id="2cf0e-1357"><see langword="true" /> se <paramref name="left" /> não for igual a <paramref name="right" />; caso contrário, <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1357"><see langword="true" /> if <paramref name="left" /> is not equal to <paramref name="right" />; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PermissionSet">
      <MemberSignature Language="C#" Value="public virtual System.Security.PermissionSet PermissionSet { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.PermissionSet PermissionSet" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.PermissionSet" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property PermissionSet As PermissionSet" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Security::PermissionSet ^ PermissionSet { System::Security::PermissionSet ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.PermissionSet : System.Security.PermissionSet" Usage="System.Reflection.Assembly.PermissionSet" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Security.PermissionSet</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="2cf0e-1358">Obtém o conjunto de concessões do assembly atual.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1358">Gets the grant set of the current assembly.</span></span></summary>
        <value><span data-ttu-id="2cf0e-1359">O conjunto de concessões do assembly atual.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1359">The grant set of the current assembly.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2cf0e-1360"><xref:System.Security.PermissionSet> objetos podem conter informações confidenciais, como caminhos.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1360"><xref:System.Security.PermissionSet> objects can contain sensitive information such as paths.</span></span> <span data-ttu-id="2cf0e-1361">Portanto, a confiança total é necessária para acessar esses objetos.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1361">Therefore, full trust is required to access these objects.</span></span>  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="2cf0e-1362">requer confiança total para o chamador imediato.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1362">requires full trust for the immediate caller.</span></span> <span data-ttu-id="2cf0e-1363">Este membro não pode ser usado pelo código transparente ou parcialmente confiável.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1363">This member cannot be used by partially trusted or transparent code.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="ReflectionOnly">
      <MemberSignature Language="C#" Value="public virtual bool ReflectionOnly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ReflectionOnly" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.ReflectionOnly" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property ReflectionOnly As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool ReflectionOnly { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.ReflectionOnly : bool" Usage="System.Reflection.Assembly.ReflectionOnly" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="2cf0e-1364">Obtém um valor <see cref="T:System.Boolean" /> que indica se esse assembly foi carregado no contexto de somente reflexão.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1364">Gets a <see cref="T:System.Boolean" /> value indicating whether this assembly was loaded into the reflection-only context.</span></span></summary>
        <value><span data-ttu-id="2cf0e-1365"><see langword="true" /> Se o assembly foi carregado no contexto somente reflexão, em vez do contexto de execução; Caso contrário, <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1365"><see langword="true" /> if the assembly was loaded into the reflection-only context, rather than the execution context; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2cf0e-1366">Se um assembly foi carregado no contexto somente reflexão, usando o <xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A> método, você não pode executar o código no assembly.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1366">If an assembly has been loaded into the reflection-only context, using the <xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A> method, you cannot execute code in the assembly.</span></span> <span data-ttu-id="2cf0e-1367">Para executar o código, o assembly deve ser carregado no contexto de execução.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1367">To execute code, the assembly must be loaded into the execution context.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="ReflectionOnlyLoad">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="2cf0e-1368">Carrega um assembly no contexto de somente reflexão, em que ele possa ser examinado, mas não executado.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1368">Loads an assembly into the reflection-only context, where it can be examined but not executed.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReflectionOnlyLoad">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly ReflectionOnlyLoad (byte[] rawAssembly);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly ReflectionOnlyLoad(unsigned int8[] rawAssembly) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.ReflectionOnlyLoad(System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReflectionOnlyLoad (rawAssembly As Byte()) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ ReflectionOnlyLoad(cli::array &lt;System::Byte&gt; ^ rawAssembly);" />
      <MemberSignature Language="F#" Value="static member ReflectionOnlyLoad : byte[] -&gt; System.Reflection.Assembly" Usage="System.Reflection.Assembly.ReflectionOnlyLoad rawAssembly" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rawAssembly" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="rawAssembly"><span data-ttu-id="2cf0e-1369">Uma matriz de byte que é uma imagem baseada em COFF contendo um assembly emitido.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1369">A byte array that is a COFF-based image containing an emitted assembly.</span></span></param>
        <summary><span data-ttu-id="2cf0e-1370">Carrega o assembly de uma imagem baseada em formato COFF contendo um assembly emitido.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1370">Loads the assembly from a common object file format (COFF)-based image containing an emitted assembly.</span></span> <span data-ttu-id="2cf0e-1371">O assembly é carregado no contexto de somente reflexão do domínio do aplicativo do chamador.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1371">The assembly is loaded into the reflection-only context of the caller's application domain.</span></span></summary>
        <returns><span data-ttu-id="2cf0e-1372">O assembly carregado.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1372">The loaded assembly.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2cf0e-1373">Você não pode executar o código de um assembly carregado no contexto somente reflexão.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1373">You cannot execute code from an assembly loaded into the reflection-only context.</span></span> <span data-ttu-id="2cf0e-1374">Para executar o código, o assembly deve ser carregado no contexto de execução, também, usando o <xref:System.Reflection.Assembly.Load%2A> método.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1374">To execute code, the assembly must be loaded into the execution context as well, using the <xref:System.Reflection.Assembly.Load%2A> method.</span></span>  
  
 <span data-ttu-id="2cf0e-1375">O contexto de somente reflexão não é diferente de outros contextos.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1375">The reflection-only context is no different from other contexts.</span></span> <span data-ttu-id="2cf0e-1376">Assemblies são carregados no contexto podem ser descarregados somente por descarregar o domínio de aplicativo.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1376">Assemblies that are loaded into the context can be unloaded only by unloading the application domain.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="2cf0e-1377"><paramref name="rawAssembly" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1377"><paramref name="rawAssembly" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="2cf0e-1378"><paramref name="rawAssembly" /> não é um assembly válido.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1378"><paramref name="rawAssembly" /> is not a valid assembly.</span></span>  
  
<span data-ttu-id="2cf0e-1379">- ou -</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1379">-or-</span></span> 
<span data-ttu-id="2cf0e-1380">A versão 2,0 ou posterior do Common Language Runtime está carregada e <paramref name="rawAssembly" /> foi compilada com uma versão posterior.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1380">Version 2.0 or later of the common language runtime is currently loaded and <paramref name="rawAssembly" /> was compiled with a later version.</span></span></exception>
        <exception cref="T:System.IO.FileLoadException"><span data-ttu-id="2cf0e-1381"><paramref name="rawAssembly" /> não pode ser carregado.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1381"><paramref name="rawAssembly" /> cannot be loaded.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ReflectionOnlyLoad">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly ReflectionOnlyLoad (string assemblyString);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly ReflectionOnlyLoad(string assemblyString) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.ReflectionOnlyLoad(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReflectionOnlyLoad (assemblyString As String) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ ReflectionOnlyLoad(System::String ^ assemblyString);" />
      <MemberSignature Language="F#" Value="static member ReflectionOnlyLoad : string -&gt; System.Reflection.Assembly" Usage="System.Reflection.Assembly.ReflectionOnlyLoad assemblyString" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyString" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="assemblyString"><span data-ttu-id="2cf0e-1382">O nome de exibição do assembly, conforme retornado pela propriedade <see cref="P:System.Reflection.AssemblyName.FullName" />.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1382">The display name of the assembly, as returned by the <see cref="P:System.Reflection.AssemblyName.FullName" /> property.</span></span></param>
        <summary><span data-ttu-id="2cf0e-1383">Carrega um assembly no contexto somente de reflexão, dado seu nome de exibição.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1383">Loads an assembly into the reflection-only context, given its display name.</span></span></summary>
        <returns><span data-ttu-id="2cf0e-1384">O assembly carregado.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1384">The loaded assembly.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2cf0e-1385">Dependências não são automaticamente carregadas no contexto somente reflexão.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1385">Dependencies are not automatically loaded into the reflection-only context.</span></span>  
  
 <span data-ttu-id="2cf0e-1386">Você não pode executar o código de um assembly carregado no contexto somente reflexão.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1386">You cannot execute code from an assembly loaded into the reflection-only context.</span></span> <span data-ttu-id="2cf0e-1387">Para executar o código, o assembly deve ser carregado no contexto de execução, também, usando o <xref:System.Reflection.Assembly.Load%2A> método.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1387">To execute code, the assembly must be loaded into the execution context as well, using the <xref:System.Reflection.Assembly.Load%2A> method.</span></span>  
  
 <span data-ttu-id="2cf0e-1388">Se determinadas permissões são concedidas ou não a um assembly é algo que se baseia na evidência.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1388">Whether certain permissions are granted or not granted to an assembly is based on evidence.</span></span> <span data-ttu-id="2cf0e-1389">As regras para o assembly e a mesclagem de evidência de segurança são da seguinte maneira:</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1389">The rules for assembly and security evidence merging are as follows:</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="2cf0e-1390">Refletir em arquivos executáveis compilados em C++ pode gerar um <xref:System.IO.FileLoadException>.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1390">Reflecting on executable files compiled in C++ might throw a <xref:System.IO.FileLoadException>.</span></span> <span data-ttu-id="2cf0e-1391">Isso provavelmente é causado pelo compilador C++ os endereços de realocação ou a seção reloc do seu arquivo executável.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1391">This is most likely caused by the C++ compiler stripping the relocation addresses or the .reloc section from your executable file.</span></span> <span data-ttu-id="2cf0e-1392">Para preservar o endereço reloc, especifique `/fixed:no` quando você está vinculando.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1392">To preserve the .reloc address, specify `/fixed:no` when you are linking.</span></span>  
  
 <span data-ttu-id="2cf0e-1393">O contexto de somente reflexão não é diferente de outros contextos.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1393">The reflection-only context is no different from other contexts.</span></span> <span data-ttu-id="2cf0e-1394">Assemblies são carregados no contexto podem ser descarregados somente por descarregar o domínio de aplicativo.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1394">Assemblies that are loaded into the context can be unloaded only by unloading the application domain.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="2cf0e-1395"><paramref name="assemblyString" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1395"><paramref name="assemblyString" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="2cf0e-1396"><paramref name="assemblyString" /> é uma cadeia de caracteres vazia ("").</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1396"><paramref name="assemblyString" /> is an empty string ("").</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="2cf0e-1397"><paramref name="assemblyString" /> não foi encontrado.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1397"><paramref name="assemblyString" /> is not found.</span></span></exception>
        <exception cref="T:System.IO.FileLoadException"><span data-ttu-id="2cf0e-1398"><paramref name="assemblyString" /> foi encontrado, mas não pode ser carregado.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1398"><paramref name="assemblyString" /> is found, but cannot be loaded.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="2cf0e-1399"><paramref name="assemblyString" /> não é um assembly válido.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1399"><paramref name="assemblyString" /> is not a valid assembly.</span></span>  
  
<span data-ttu-id="2cf0e-1400">- ou -</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1400">-or-</span></span> 
<span data-ttu-id="2cf0e-1401">A versão 2,0 ou posterior do Common Language Runtime está carregada e <paramref name="assemblyString" /> foi compilada com uma versão posterior.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1401">Version 2.0 or later of the common language runtime is currently loaded and <paramref name="assemblyString" /> was compiled with a later version.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ReflectionOnlyLoadFrom">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly ReflectionOnlyLoadFrom (string assemblyFile);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly ReflectionOnlyLoadFrom(string assemblyFile) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.ReflectionOnlyLoadFrom(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReflectionOnlyLoadFrom (assemblyFile As String) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ ReflectionOnlyLoadFrom(System::String ^ assemblyFile);" />
      <MemberSignature Language="F#" Value="static member ReflectionOnlyLoadFrom : string -&gt; System.Reflection.Assembly" Usage="System.Reflection.Assembly.ReflectionOnlyLoadFrom assemblyFile" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="assemblyFile"><span data-ttu-id="2cf0e-1402">O caminho do arquivo que contém o manifesto do assembly.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1402">The path of the file that contains the manifest of the assembly.</span></span></param>
        <summary><span data-ttu-id="2cf0e-1403">Carrega um assembly no contexto somente de reflexão, dado seu caminho.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1403">Loads an assembly into the reflection-only context, given its path.</span></span></summary>
        <returns><span data-ttu-id="2cf0e-1404">O assembly carregado.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1404">The loaded assembly.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2cf0e-1405">Dependências não são automaticamente carregadas no contexto somente reflexão.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1405">Dependencies are not automatically loaded into the reflection-only context.</span></span> <span data-ttu-id="2cf0e-1406">Para carregar automaticamente as dependências, lidar com o <xref:System.AppDomain.ReflectionOnlyAssemblyResolve> eventos e carregar a dependência no manipulador de eventos.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1406">To automatically load dependencies, handle the <xref:System.AppDomain.ReflectionOnlyAssemblyResolve> event and load the dependency in the event handler.</span></span>  
  
 <span data-ttu-id="2cf0e-1407">Você não pode executar o código de um assembly que foi carregado no contexto somente reflexão.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1407">You cannot execute code from an assembly that has been loaded into the reflection-only context.</span></span> <span data-ttu-id="2cf0e-1408">Para executar o código, carregar o assembly com o <xref:System.Reflection.Assembly.LoadFile%2A> método.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1408">To execute the code, load the assembly with the <xref:System.Reflection.Assembly.LoadFile%2A> method.</span></span>  
  
 <span data-ttu-id="2cf0e-1409">O `assemblyFile` parâmetro deve se referir a um URI sem caracteres de escape.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1409">The `assemblyFile` parameter must refer to a URI without escape characters.</span></span> <span data-ttu-id="2cf0e-1410">Esse método fornece os caracteres de escape para todos os caracteres inválidos no URI.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1410">This method supplies escape characters for all invalid characters in the URI.</span></span>  
  
 <span data-ttu-id="2cf0e-1411">O caminho especificado para `assemblyFile` é relativo ao diretório atual.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1411">The path specified for `assemblyFile` is relative to the current directory.</span></span> <span data-ttu-id="2cf0e-1412">O assembly é carregado para o domínio do chamador.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1412">The assembly is loaded into the domain of the caller.</span></span>  
  
 <span data-ttu-id="2cf0e-1413">O contexto de somente reflexão não é diferente de outros contextos.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1413">The reflection-only context is no different from other contexts.</span></span> <span data-ttu-id="2cf0e-1414">Assemblies são carregados no contexto podem ser descarregados somente por descarregar o domínio de aplicativo.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1414">Assemblies that are loaded into the context can be unloaded only by unloading the application domain.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="2cf0e-1415"><paramref name="assemblyFile" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1415"><paramref name="assemblyFile" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="2cf0e-1416"><paramref name="assemblyFile" /> não foi encontrado ou o módulo que você está tentando carregar não especifica uma extensão de nome de arquivo.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1416"><paramref name="assemblyFile" /> is not found, or the module you are trying to load does not specify a file name extension.</span></span></exception>
        <exception cref="T:System.IO.FileLoadException"><span data-ttu-id="2cf0e-1417"><paramref name="assemblyFile" /> foi encontrado, mas não pôde ser carregado.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1417"><paramref name="assemblyFile" /> is found, but could not be loaded.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="2cf0e-1418"><paramref name="assemblyFile" /> não é um assembly válido.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1418"><paramref name="assemblyFile" /> is not a valid assembly.</span></span>  
  
<span data-ttu-id="2cf0e-1419">- ou -</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1419">-or-</span></span> 
<span data-ttu-id="2cf0e-1420">A versão 2,0 ou posterior do Common Language Runtime está carregada e <paramref name="assemblyFile" /> foi compilada com uma versão posterior.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1420">Version 2.0 or later of the common language runtime is currently loaded and <paramref name="assemblyFile" /> was compiled with a later version.</span></span></exception>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="2cf0e-1421">Uma base de código que não é iniciada com “file://” foi especificada sem o <see cref="T:System.Net.WebPermission" /> necessário.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1421">A codebase that does not start with "file://" was specified without the required <see cref="T:System.Net.WebPermission" />.</span></span></exception>
        <exception cref="T:System.IO.PathTooLongException"><span data-ttu-id="2cf0e-1422">O nome do assembly excede o tamanho máximo definido pelo sistema.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1422">The assembly name exceeds the system-defined maximum length.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="2cf0e-1423"><paramref name="assemblyFile" /> é uma cadeia de caracteres vazia ("").</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1423"><paramref name="assemblyFile" /> is an empty string ("").</span></span></exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission"><span data-ttu-id="2cf0e-1424">para ler um URI que começa com "file://".</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1424">for reading a URI that begins with "file://".</span></span> <span data-ttu-id="2cf0e-1425">Enumerações associadas: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></span><span class="sxs-lookup"><span data-stu-id="2cf0e-1425">Associated enumerations: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></span></span></permission>
        <permission cref="T:System.Net.WebPermission"><span data-ttu-id="2cf0e-1426">para ler um URI que não começa com "file://".</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1426">for reading a URI that does not begin with "file://".</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="SecurityRuleSet">
      <MemberSignature Language="C#" Value="public virtual System.Security.SecurityRuleSet SecurityRuleSet { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Security.SecurityRuleSet SecurityRuleSet" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.SecurityRuleSet" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property SecurityRuleSet As SecurityRuleSet" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Security::SecurityRuleSet SecurityRuleSet { System::Security::SecurityRuleSet get(); };" />
      <MemberSignature Language="F#" Value="member this.SecurityRuleSet : System.Security.SecurityRuleSet" Usage="System.Reflection.Assembly.SecurityRuleSet" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.SecurityRuleSet</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="2cf0e-1427">Obtém um valor que indica qual conjunto de regras de segurança o CLR (Common Language Runtime) impõe a este assembly.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1427">Gets a value that indicates which set of security rules the common language runtime (CLR) enforces for this assembly.</span></span></summary>
        <value><span data-ttu-id="2cf0e-1428">O conjunto de regras de segurança que o CLR impõe para esse assembly.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1428">The security rule set that the CLR enforces for this assembly.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2cf0e-1429">Por padrão, os assemblies que você compila com a [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)] ter [nível 2](~/docs/framework/misc/security-transparent-code-level-2.md) transparência, embora você pode torná-los explicitamente [nível 1](~/docs/framework/misc/security-transparent-code-level-1.md) em vez disso.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1429">By default, assemblies that you compile with the [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)] have [level 2](~/docs/framework/misc/security-transparent-code-level-2.md) transparency, although you can explicitly make them [level 1](~/docs/framework/misc/security-transparent-code-level-1.md) instead.</span></span> <span data-ttu-id="2cf0e-1430">Os assemblies que foram compilados com versões anteriores do .NET Framework ter transparência de nível 1.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1430">Assemblies that were compiled with earlier versions of the .NET Framework have level 1 transparency.</span></span>  
  
 <span data-ttu-id="2cf0e-1431">Consulte [Alterações de segurança](~/docs/framework/security/security-changes.md).</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1431">See [Security Changes](~/docs/framework/security/security-changes.md).</span></span>  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/misc/security-transparent-code.md"><span data-ttu-id="2cf0e-1432">Código transparente de segurança</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1432">Security-Transparent Code</span></span></related>
        <related type="Article" href="~/docs/framework/security/security-changes.md"><span data-ttu-id="2cf0e-1433">Alterações de segurança no .NET Framework 4</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1433">Security Changes in the .NET Framework 4</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="System.Reflection.ICustomAttributeProvider.GetCustomAttributes">
      <MemberSignature Language="C#" Value="object[] ICustomAttributeProvider.GetCustomAttributes (bool inherit);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance object[] System.Reflection.ICustomAttributeProvider.GetCustomAttributes(bool inherit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.System#Reflection#ICustomAttributeProvider#GetCustomAttributes(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Function GetCustomAttributes (inherit As Boolean) As Object() Implements ICustomAttributeProvider.GetCustomAttributes" />
      <MemberSignature Language="C++ CLI" Value=" virtual cli::array &lt;System::Object ^&gt; ^ System.Reflection.ICustomAttributeProvider.GetCustomAttributes(bool inherit) = System::Reflection::ICustomAttributeProvider::GetCustomAttributes;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Reflection.ICustomAttributeProvider.GetCustomAttributes(System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="inherit" Type="System.Boolean" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netstandard-1.5;netstandard-1.6" />
      </Parameters>
      <Docs>
        <param name="inherit">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Reflection.ICustomAttributeProvider.GetCustomAttributes">
      <MemberSignature Language="C#" Value="object[] ICustomAttributeProvider.GetCustomAttributes (Type attributeType, bool inherit);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance object[] System.Reflection.ICustomAttributeProvider.GetCustomAttributes(class System.Type attributeType, bool inherit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.System#Reflection#ICustomAttributeProvider#GetCustomAttributes(System.Type,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Function GetCustomAttributes (attributeType As Type, inherit As Boolean) As Object() Implements ICustomAttributeProvider.GetCustomAttributes" />
      <MemberSignature Language="C++ CLI" Value=" virtual cli::array &lt;System::Object ^&gt; ^ System.Reflection.ICustomAttributeProvider.GetCustomAttributes(Type ^ attributeType, bool inherit) = System::Reflection::ICustomAttributeProvider::GetCustomAttributes;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Reflection.ICustomAttributeProvider.GetCustomAttributes(System.Type,System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="attributeType" Type="System.Type" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netstandard-1.5;netstandard-1.6" />
        <Parameter Name="inherit" Type="System.Boolean" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netstandard-1.5;netstandard-1.6" />
      </Parameters>
      <Docs>
        <param name="attributeType">To be added.</param>
        <param name="inherit">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Reflection.ICustomAttributeProvider.IsDefined">
      <MemberSignature Language="C#" Value="bool ICustomAttributeProvider.IsDefined (Type attributeType, bool inherit);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.Reflection.ICustomAttributeProvider.IsDefined(class System.Type attributeType, bool inherit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.System#Reflection#ICustomAttributeProvider#IsDefined(System.Type,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Function IsDefined (attributeType As Type, inherit As Boolean) As Boolean Implements ICustomAttributeProvider.IsDefined" />
      <MemberSignature Language="C++ CLI" Value=" virtual bool System.Reflection.ICustomAttributeProvider.IsDefined(Type ^ attributeType, bool inherit) = System::Reflection::ICustomAttributeProvider::IsDefined;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Reflection.ICustomAttributeProvider.IsDefined(System.Type,System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="attributeType" Type="System.Type" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netstandard-1.5;netstandard-1.6" />
        <Parameter Name="inherit" Type="System.Boolean" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netstandard-1.5;netstandard-1.6" />
      </Parameters>
      <Docs>
        <param name="attributeType">To be added.</param>
        <param name="inherit">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._Assembly.GetType">
      <MemberSignature Language="C#" Value="Type _Assembly.GetType ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Type System.Runtime.InteropServices._Assembly.GetType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.System#Runtime#InteropServices#_Assembly#GetType" />
      <MemberSignature Language="VB.NET" Value="Function GetType () As Type Implements _Assembly.GetType" />
      <MemberSignature Language="C++ CLI" Value=" virtual Type ^ System.Runtime.InteropServices._Assembly.GetType() = System::Runtime::InteropServices::_Assembly::GetType;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="2cf0e-1434">Retorna o tipo da instância atual.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1434">Returns the type of the current instance.</span></span></summary>
        <returns><span data-ttu-id="2cf0e-1435">Um objeto que representa o tipo <see cref="T:System.Reflection.Assembly" />.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1435">An object that represents the <see cref="T:System.Reflection.Assembly" /> type.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="assembly.ToString " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.ToString</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="2cf0e-1436">Retorna o nome completo do assembly, também conhecido como o nome de exibição.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1436">Returns the full name of the assembly, also known as the display name.</span></span></summary>
        <returns><span data-ttu-id="2cf0e-1437">O nome completo do assembly ou o nome de classe, se o nome completo do assembly não puder ser determinado.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1437">The full name of the assembly, or the class name if the full name of the assembly cannot be determined.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="UnsafeLoadFrom">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly UnsafeLoadFrom (string assemblyFile);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly UnsafeLoadFrom(string assemblyFile) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.UnsafeLoadFrom(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function UnsafeLoadFrom (assemblyFile As String) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ UnsafeLoadFrom(System::String ^ assemblyFile);" />
      <MemberSignature Language="F#" Value="static member UnsafeLoadFrom : string -&gt; System.Reflection.Assembly" Usage="System.Reflection.Assembly.UnsafeLoadFrom assemblyFile" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="assemblyFile"><span data-ttu-id="2cf0e-1438">O nome ou o caminho do arquivo que contém o manifesto do assembly.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1438">The name or path of the file that contains the manifest of the assembly.</span></span></param>
        <summary><span data-ttu-id="2cf0e-1439">Carrega um assembly no contexto de carga, ignorando algumas verificações de segurança.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1439">Loads an assembly into the load-from context, bypassing some security checks.</span></span></summary>
        <returns><span data-ttu-id="2cf0e-1440">O assembly carregado.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1440">The loaded assembly.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2cf0e-1441">Use esse método para carregar um assembly local que o sistema operacional foi sinalizada como tendo sido carregados da Web (por exemplo, um arquivo temporário que foi baixado da Internet ou intranet).</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1441">Use this method to load a local assembly that the operating system has flagged as having been loaded from the Web (for example, a temporary file that was downloaded from the Internet or intranet).</span></span> <span data-ttu-id="2cf0e-1442">Antes do [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], esses assemblies foram automaticamente carregados em um domínio de aplicativo em área restrita.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1442">Before the [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], such assemblies were automatically loaded into a sandboxed application domain.</span></span> <span data-ttu-id="2cf0e-1443">Começando com o [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)], eles são carregados com confiança total.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1443">Starting with the [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)], they are loaded with full trust.</span></span>  
  
 <span data-ttu-id="2cf0e-1444">Como uma alternativa ao uso desse método, você pode aplicar a [ &lt;NetFx40_LegacySecurityPolicy&gt; elemento](~/docs/framework/configure-apps/file-schema/runtime/netfx40-legacysecuritypolicy-element.md) no seu arquivo de configuração do aplicativo.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1444">As an alternative to using this method, you can apply the [&lt;NetFx40_LegacySecurityPolicy&gt; Element](~/docs/framework/configure-apps/file-schema/runtime/netfx40-legacysecuritypolicy-element.md) in your application configuration file.</span></span> <span data-ttu-id="2cf0e-1445">Isso faz com que o common language runtime reverter para a política de segurança do [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)].</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1445">This causes the common language runtime to revert to the security policy of the [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)].</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="2cf0e-1446">Se você usar qualquer uma dessas soluções, você deve ter certeza de que é seguro carregar `assemblyFile` com confiança total.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1446">If you use either of these solutions, you must be certain that it is safe to load `assemblyFile` with full trust.</span></span>  
  
 <span data-ttu-id="2cf0e-1447">Para obter uma discussão sobre contextos de carga, incluindo o contexto de carga, consulte o <xref:System.Reflection.Assembly.LoadFrom%28System.String%29> sobrecarga de método.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1447">For a discussion of load contexts, including the load-from context, see the <xref:System.Reflection.Assembly.LoadFrom%28System.String%29> method overload.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="2cf0e-1448"><paramref name="assemblyFile" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1448"><paramref name="assemblyFile" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="2cf0e-1449"><paramref name="assemblyFile" /> não foi encontrado, ou o módulo que você está tentando carregar não especifica uma extensão de nome de arquivo.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1449"><paramref name="assemblyFile" /> is not found, or the module you are trying to load does not specify a filename extension.</span></span></exception>
        <exception cref="T:System.IO.FileLoadException"><span data-ttu-id="2cf0e-1450">Não foi possível carregar um arquivo que foi encontrado.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1450">A file that was found could not be loaded.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="2cf0e-1451"><paramref name="assemblyFile" /> não é um assembly válido.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1451"><paramref name="assemblyFile" /> is not a valid assembly.</span></span>  
  
<span data-ttu-id="2cf0e-1452">- ou -</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1452">-or-</span></span> 
 <span data-ttu-id="2cf0e-1453"><paramref name="assemblyFile" /> foi compilado com uma versão posterior do Common Language Runtime do que a versão carregada atualmente.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1453"><paramref name="assemblyFile" /> was compiled with a later version of the common language runtime than the version that is currently loaded.</span></span></exception>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="2cf0e-1454">Uma base de código que não é iniciada com “file://” foi especificada sem o <see cref="T:System.Net.WebPermission" /> necessário.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1454">A codebase that does not start with "file://" was specified without the required <see cref="T:System.Net.WebPermission" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="2cf0e-1455">O parâmetro <paramref name="assemblyFile" /> é uma cadeia de caracteres vazia ("").</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1455">The <paramref name="assemblyFile" /> parameter is an empty string ("").</span></span></exception>
        <exception cref="T:System.IO.PathTooLongException"><span data-ttu-id="2cf0e-1456">O nome do assembly excede o tamanho máximo definido pelo sistema.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1456">The assembly name exceeds the system-defined maximum length.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="2cf0e-1457">requer confiança total para o chamador imediato.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1457">requires full trust for the immediate caller.</span></span> <span data-ttu-id="2cf0e-1458">Este membro não pode ser usado pelo código transparente ou parcialmente confiável.</span><span class="sxs-lookup"><span data-stu-id="2cf0e-1458">This member cannot be used by partially trusted or transparent code.</span></span></permission>
      </Docs>
    </Member>
  </Members>
</Type>
