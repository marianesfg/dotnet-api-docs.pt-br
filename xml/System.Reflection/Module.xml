<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="Module.xml" source-language="en-US" target-language="pt-BR">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-15c36f0" tool-company="Microsoft" />
      <xliffext:skl_file_name xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">02cd5861-7ce2-4a82-b358-31f8435a0ac599434ae0ca2ae257e847cbb424c20883be128c2c.skl</xliffext:skl_file_name>
      <xliffext:version xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">1.2</xliffext:version>
      <xliffext:ms.openlocfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">99434ae0ca2ae257e847cbb424c20883be128c2c</xliffext:ms.openlocfilehash>
      <xliffext:ms.sourcegitcommit xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b</xliffext:ms.sourcegitcommit>
      <xliffext:ms.lasthandoff xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">04/03/2018</xliffext:ms.lasthandoff>
      <xliffext:moniker_ids xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">netcore-1.0,netcore-1.1,netcore-2.0,netcore-2.1,netframework-4.5.1,netframework-4.5.2,netframework-4.5,netframework-4.6.1,netframework-4.6.2,netframework-4.6,netframework-4.7.1,netframework-4.7,netstandard-1.0,netstandard-1.1,netstandard-1.2,netstandard-1.3,netstandard-1.4,netstandard-1.5,netstandard-1.6,netstandard-2.0,xamarinandroid-7.1,xamarinios-10.8,xamarinmac-3.0</xliffext:moniker_ids>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve" uid="T:System.Reflection.Module">
          <source>Performs reflection on a module.</source>
          <target state="translated">Executa a reflexão em um módulo.</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Module">
          <source>A module is a portable executable file, such as type.dll or application.exe, consisting of one or more classes and interfaces.</source>
          <target state="translated">Um módulo é um arquivo executável portátil, como type.dll ou application.exe, consiste em uma ou mais classes e interfaces.</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Module">
          <source>There may be multiple namespaces contained in a single module, and a namespace may span multiple modules.</source>
          <target state="translated">Pode haver vários namespaces contidas em um único módulo e um namespace pode abranger vários módulos.</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Module">
          <source>One or more modules deployed as a unit compose an assembly.</source>
          <target state="translated">Um ou vários módulos implantados como uma unidade compõem um assembly.</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Module">
          <source>For information about creating an assembly with more than one module, see <bpt id="p1">[</bpt>Multifile Assemblies<ept id="p1">](~/docs/framework/app-domains/multifile-assemblies.md)</ept>.</source>
          <target state="translated">Para obter informações sobre como criar um assembly com mais de um módulo, consulte <bpt id="p1">[</bpt>Assemblies de vários arquivos<ept id="p1">](~/docs/framework/app-domains/multifile-assemblies.md)</ept>.</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Module">
          <source>Note that a .NET Framework module is not the same as a module in Visual Basic, which is used by a programmers to organize functions and subroutines in an application.</source>
          <target state="translated">Observe que um módulo do .NET Framework não é o mesmo que um módulo no Visual Basic, que é usado por um programadores para organizar as funções e sub-rotinas em um aplicativo.</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Module">
          <source>The following code examples show how to use reflection to get information about modules:</source>
          <target state="translated">Os exemplos de código a seguir mostram como usar reflexão para obter informações sobre os módulos:</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Module">
          <source>for full trust for inheritors.</source>
          <target state="translated">para confiança total de herdeiros.</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Module">
          <source>This class cannot be inherited by partially trusted code.</source>
          <target state="translated">Esta classe não pode ser herdada pelo código parcialmente confiável.</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.#ctor">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Reflection.Module" /&gt;</ph> class.</source>
          <target state="translated">Inicializa uma nova instância da classe <ph id="ph1">&lt;see cref="T:System.Reflection.Module" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.#ctor">
          <source>This constructor is invoked by derived classes during the construction of <ph id="ph1">&lt;xref:System.Reflection.Module&gt;</ph> objects.</source>
          <target state="translated">Este construtor é chamado por classes derivadas durante a construção do <ph id="ph1">&lt;xref:System.Reflection.Module&gt;</ph> objetos.</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve" uid="P:System.Reflection.Module.Assembly">
          <source>Gets the appropriate <ph id="ph1">&lt;see cref="T:System.Reflection.Assembly" /&gt;</ph> for this instance of <ph id="ph2">&lt;see cref="T:System.Reflection.Module" /&gt;</ph>.</source>
          <target state="translated">Obtém o <ph id="ph1">&lt;see cref="T:System.Reflection.Assembly" /&gt;</ph> apropriado para essa instância do <ph id="ph2">&lt;see cref="T:System.Reflection.Module" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Module.Assembly">
          <source>An <ph id="ph1">&lt;see langword="Assembly" /&gt;</ph> object.</source>
          <target state="translated">Um objeto <ph id="ph1">&lt;see langword="Assembly" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Module.Assembly">
          <source>The following example displays the full name of the specified assembly in the specified module.</source>
          <target state="translated">O exemplo a seguir exibe o nome completo do assembly especificado no módulo especificado.</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve" uid="P:System.Reflection.Module.CustomAttributes">
          <source>Gets a collection that contains this module's custom attributes.</source>
          <target state="translated">Obtém uma coleção que contém os atributos personalizados deste módulo.</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Module.CustomAttributes">
          <source>A collection that contains this module's custom attributes.</source>
          <target state="translated">Uma coleção que contém os atributos personalizados deste módulo.</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.Equals(System.Object)">
          <source>The object to compare with this instance.</source>
          <target state="translated">O objeto a ser comparado com essa instância.</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.Equals(System.Object)">
          <source>Determines whether this module and the specified object are equal.</source>
          <target state="translated">Determina se este módulo e o objeto especificado são iguais.</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.Equals(System.Object)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if <ph id="ph2">&lt;paramref name="o" /&gt;</ph> is equal to this instance; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> se <ph id="ph2">&lt;paramref name="o" /&gt;</ph> for igual a essa instância; caso contrário, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve" uid="F:System.Reflection.Module.FilterTypeName">
          <source>A <ph id="ph1">&lt;see langword="TypeFilter" /&gt;</ph> object that filters the list of types defined in this module based upon the name.</source>
          <target state="translated">Um objeto <ph id="ph1">&lt;see langword="TypeFilter" /&gt;</ph> que filtra a lista de tipos definidos neste módulo com base no nome.</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve" uid="F:System.Reflection.Module.FilterTypeName">
          <source>This field is case-sensitive and read-only.</source>
          <target state="translated">Este campo diferencia maiúsculas de minúsculas e é somente leitura.</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Module.FilterTypeName">
          <source>The filter supports a trailing "*" wildcard.</source>
          <target state="translated">O filtro dá suporte à direita "*" curinga.</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Module.FilterTypeName">
          <source>The following example displays the module names that match the specified search criteria.</source>
          <target state="translated">O exemplo a seguir exibe os nomes de módulo que correspondem aos critérios de pesquisa especificados.</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve" uid="F:System.Reflection.Module.FilterTypeNameIgnoreCase">
          <source>A <ph id="ph1">&lt;see langword="TypeFilter" /&gt;</ph> object that filters the list of types defined in this module based upon the name.</source>
          <target state="translated">Um objeto <ph id="ph1">&lt;see langword="TypeFilter" /&gt;</ph> que filtra a lista de tipos definidos neste módulo com base no nome.</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve" uid="F:System.Reflection.Module.FilterTypeNameIgnoreCase">
          <source>This field is case-insensitive and read-only.</source>
          <target state="translated">Este campo não diferencia maiúsculas de minúsculas e é somente leitura.</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Module.FilterTypeNameIgnoreCase">
          <source>The filter supports a trailing "*" wildcard.</source>
          <target state="translated">O filtro dá suporte à direita "*" curinga.</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Module.FilterTypeNameIgnoreCase">
          <source>The following example displays the module names that match the specified search criteria, ignoring the case.</source>
          <target state="translated">O exemplo a seguir exibe os nomes de módulo que correspondem aos critérios de pesquisa especificada, ignorando as maiusculas e minúsculas.</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.FindTypes(System.Reflection.TypeFilter,System.Object)">
          <source>The delegate used to filter the classes.</source>
          <target state="translated">O delegado usado para filtrar as classes.</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.FindTypes(System.Reflection.TypeFilter,System.Object)">
          <source>An Object used to filter the classes.</source>
          <target state="translated">Um objeto usado para filtrar as classes.</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.FindTypes(System.Reflection.TypeFilter,System.Object)">
          <source>Returns an array of classes accepted by the given filter and filter criteria.</source>
          <target state="translated">Retorna uma matriz de classes aceitas pelo filtro e critérios de filtro determinados.</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.FindTypes(System.Reflection.TypeFilter,System.Object)">
          <source>An array of type <ph id="ph1">&lt;see langword="Type" /&gt;</ph> containing classes that were accepted by the filter.</source>
          <target state="translated">Uma matriz do tipo <ph id="ph1">&lt;see langword="Type" /&gt;</ph> que contém classes que foram aceitas pelo filtro.</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.FindTypes(System.Reflection.TypeFilter,System.Object)">
          <source><ph id="ph1">&lt;xref:System.Reflection.ReflectionTypeLoadException&gt;</ph> is a special class load exception.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Reflection.ReflectionTypeLoadException&gt;</ph> é uma exceção de carregamento de classe especial.</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.FindTypes(System.Reflection.TypeFilter,System.Object)">
          <source>The <ph id="ph1">`ReflectionTypeLoadException.Types`</ph> property contains the array of classes that were defined in the module and were loaded.</source>
          <target state="translated">O <ph id="ph1">`ReflectionTypeLoadException.Types`</ph> propriedade contém a matriz de classes que foram definidas no módulo e que foram carregados.</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.FindTypes(System.Reflection.TypeFilter,System.Object)">
          <source>This array may contain some null values.</source>
          <target state="translated">Esta matriz pode conter alguns valores nulos.</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.FindTypes(System.Reflection.TypeFilter,System.Object)">
          <source>The <ph id="ph1">`ReflectionTypeLoadException.LoaderExceptions`</ph> property is an array of exceptions that represent the exceptions that were thrown by the class loader.</source>
          <target state="translated">O <ph id="ph1">`ReflectionTypeLoadException.LoaderExceptions`</ph> propriedade é uma matriz de exceções que representam as exceções que foram lançadas pelo carregador de classes.</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.FindTypes(System.Reflection.TypeFilter,System.Object)">
          <source>The holes in the class array line up with the exceptions.</source>
          <target state="translated">Falhas na matriz de classe alinharem com as exceções.</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.FindTypes(System.Reflection.TypeFilter,System.Object)">
          <source>The delegate given by <ph id="ph1">`filter`</ph> is called for each class in the module, passing along the <ph id="ph2">`Type`</ph> object representing the class as well as the given <ph id="ph3">`filterCriteria`</ph>.</source>
          <target state="translated">O representante fornecido por <ph id="ph1">`filter`</ph> é chamado para cada classe no módulo, passando o <ph id="ph2">`Type`</ph> que representa a classe de objeto, bem como a determinado <ph id="ph3">`filterCriteria`</ph>.</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.FindTypes(System.Reflection.TypeFilter,System.Object)">
          <source>If <ph id="ph1">`filter`</ph> returns a particular class, that class will be included in the returned array.</source>
          <target state="translated">Se <ph id="ph1">`filter`</ph> retorna uma determinada classe, que a classe será incluída na matriz retornada.</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.FindTypes(System.Reflection.TypeFilter,System.Object)">
          <source>If <ph id="ph1">`filter`</ph> returns <ph id="ph2">`null`</ph>, all classes are returned and <ph id="ph3">`filterCriteria`</ph> is ignored.</source>
          <target state="translated">Se <ph id="ph1">`filter`</ph> retorna <ph id="ph2">`null`</ph>, todas as classes são retornadas e <ph id="ph3">`filterCriteria`</ph> será ignorado.</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.FindTypes(System.Reflection.TypeFilter,System.Object)">
          <source><ph id="ph1">`FindTypes`</ph> cannot be used to look up parameterized types such as arrays.</source>
          <target state="translated"><ph id="ph1">`FindTypes`</ph> não pode ser usado para pesquisar tipos parametrizados como matrizes.</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.FindTypes(System.Reflection.TypeFilter,System.Object)">
          <source>The following example demonstrates the <ph id="ph1">`FindTypes`</ph> method.</source>
          <target state="translated">O exemplo a seguir demonstra o <ph id="ph1">`FindTypes`</ph> método.</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.FindTypes(System.Reflection.TypeFilter,System.Object)">
          <source>One or more classes in a module could not be loaded.</source>
          <target state="translated">Uma ou mais classes em um módulo não puderam ser carregadas.</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve" uid="P:System.Reflection.Module.FullyQualifiedName">
          <source>Gets a string representing the fully qualified name and path to this module.</source>
          <target state="translated">Obtém uma cadeia de caracteres que representa o nome totalmente qualificado e o caminho para esse módulo.</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Module.FullyQualifiedName">
          <source>The fully qualified module name.</source>
          <target state="translated">O nome do módulo totalmente qualificado.</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Module.FullyQualifiedName">
          <source>To get the name without the path, use <ph id="ph1">&lt;xref:System.Reflection.Module.Name%2A&gt;</ph>.</source>
          <target state="translated">Para obter o nome sem o caminho, use <ph id="ph1">&lt;xref:System.Reflection.Module.Name%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Module.FullyQualifiedName">
          <source>If the assembly for this module was loaded from a byte array then the <ph id="ph1">`FullyQualifiedName`</ph> for the module will be: <ph id="ph2">\&lt;</ph>Unknown&gt;.</source>
          <target state="translated">Se o assembly para esse módulo foi carregado de uma matriz de bytes a <ph id="ph1">`FullyQualifiedName`</ph> para o módulo será: <ph id="ph2">\&lt;</ph>desconhecido &gt;.</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Module.FullyQualifiedName">
          <source>The case of module name is platform-dependent.</source>
          <target state="translated">No caso de nome do módulo é dependente de plataforma.</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Module.FullyQualifiedName">
          <source>The following example displays the fully qualified name of the specified module.</source>
          <target state="translated">O exemplo a seguir exibe o nome totalmente qualificado do módulo especificado.</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve" uid="P:System.Reflection.Module.FullyQualifiedName">
          <source>The caller does not have the required permissions.</source>
          <target state="translated">O chamador não tem as permissões necessárias.</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Module.FullyQualifiedName">
          <source>for access to information in the path.</source>
          <target state="translated">para acessar informações no caminho.</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Module.FullyQualifiedName">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /&gt;</ph>.</source>
          <target state="translated">Enumeração associada: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve" uid="T:System.Reflection.Module">
          <source>Returns custom attributes.</source>
          <target state="translated">Retorna os atributos personalizados.</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetCustomAttributes(System.Boolean)">
          <source>This argument is ignored for objects of this type.</source>
          <target state="translated">Este argumento é ignorado para objetos deste tipo.</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetCustomAttributes(System.Boolean)">
          <source>Returns all custom attributes.</source>
          <target state="translated">Retorna todos os atributos personalizados.</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetCustomAttributes(System.Boolean)">
          <source>An array of type <ph id="ph1">&lt;see langword="Object" /&gt;</ph> containing all custom attributes.</source>
          <target state="translated">Uma matriz do tipo <ph id="ph1">&lt;see langword="Object" /&gt;</ph> que contém todos os atributos personalizados.</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.GetCustomAttributes(System.Boolean)">
          <source>The following example displays the module names that match the specified search criteria.</source>
          <target state="translated">O exemplo a seguir exibe os nomes de módulo que correspondem aos critérios de pesquisa especificados.</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetCustomAttributes(System.Type,System.Boolean)">
          <source>The type of attribute to get.</source>
          <target state="translated">O tipo de atributo a obter.</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetCustomAttributes(System.Type,System.Boolean)">
          <source>This argument is ignored for objects of this type.</source>
          <target state="translated">Este argumento é ignorado para objetos deste tipo.</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetCustomAttributes(System.Type,System.Boolean)">
          <source>Gets custom attributes of the specified type.</source>
          <target state="translated">Obtém os atributos personalizados do tipo especificado.</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetCustomAttributes(System.Type,System.Boolean)">
          <source>An array of type <ph id="ph1">&lt;see langword="Object" /&gt;</ph> containing all custom attributes of the specified type.</source>
          <target state="translated">Uma matriz do tipo <ph id="ph1">&lt;see langword="Object" /&gt;</ph> que contém todos os atributos personalizados do tipo especificado.</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.GetCustomAttributes(System.Type,System.Boolean)">
          <source>The following example displays the module names of the specified type that match the specified search criteria.</source>
          <target state="translated">O exemplo a seguir exibe os nomes do módulo do tipo especificado que correspondem aos critérios de pesquisa especificados.</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetCustomAttributes(System.Type,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="attributeType" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="attributeType" /&gt;</ph> é <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetCustomAttributes(System.Type,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="attributeType" /&gt;</ph> is not a <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> object supplied by the runtime.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="attributeType" /&gt;</ph> não é um objeto <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> fornecido pelo tempo de execução.</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetCustomAttributes(System.Type,System.Boolean)">
          <source>For example, <ph id="ph1">&lt;paramref name="attributeType" /&gt;</ph> is a <ph id="ph2">&lt;see cref="T:System.Reflection.Emit.TypeBuilder" /&gt;</ph> object.</source>
          <target state="translated">Por exemplo, <ph id="ph1">&lt;paramref name="attributeType" /&gt;</ph> é um objeto <ph id="ph2">&lt;see cref="T:System.Reflection.Emit.TypeBuilder" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetCustomAttributesData">
          <source>Returns a list of <ph id="ph1">&lt;see cref="T:System.Reflection.CustomAttributeData" /&gt;</ph> objects for the current module, which can be used in the reflection-only context.</source>
          <target state="translated">Retorna uma lista de objetos <ph id="ph1">&lt;see cref="T:System.Reflection.CustomAttributeData" /&gt;</ph> para o módulo atual, que pode ser usado no contexto somente para reflexão.</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetCustomAttributesData">
          <source>A generic list of <ph id="ph1">&lt;see cref="T:System.Reflection.CustomAttributeData" /&gt;</ph> objects representing data about the attributes that have been applied to the current module.</source>
          <target state="translated">Uma lista genérica de objetos <ph id="ph1">&lt;see cref="T:System.Reflection.CustomAttributeData" /&gt;</ph> que representam dados sobre os atributos que foram aplicados ao módulo atual.</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.GetCustomAttributesData">
          <source>Use this method to examine the custom attributes of code in the reflection-only context, in cases where the custom attributes themselves are defined in code that is loaded into the reflection-only context.</source>
          <target state="translated">Use esse método para examinar os atributos personalizados de código no contexto exclusivo de reflexão, em casos onde os atributos personalizados próprios são definidos no código que é carregado no contexto exclusivo de reflexão.</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.GetCustomAttributesData">
          <source>Methods such as <ph id="ph1">&lt;xref:System.Attribute.GetCustomAttributes%2A?displayProperty=nameWithType&gt;</ph> and <ph id="ph2">&lt;xref:System.Reflection.Module.GetCustomAttributes%2A?displayProperty=nameWithType&gt;</ph> cannot be used in such cases, because they create instances of the attributes.</source>
          <target state="translated">Métodos como <ph id="ph1">&lt;xref:System.Attribute.GetCustomAttributes%2A?displayProperty=nameWithType&gt;</ph> e <ph id="ph2">&lt;xref:System.Reflection.Module.GetCustomAttributes%2A?displayProperty=nameWithType&gt;</ph> não pode ser usado em tais casos, porque eles criar instâncias dos atributos.</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.GetCustomAttributesData">
          <source>Code in the reflection-only context cannot be executed.</source>
          <target state="translated">O código no contexto exclusivo de reflexão não pode ser executado.</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.GetCustomAttributesData">
          <source>For more information and example code, see the <ph id="ph1">&lt;xref:System.Reflection.CustomAttributeData&gt;</ph> class.</source>
          <target state="translated">Para obter mais informações e exemplo de código, consulte o <ph id="ph1">&lt;xref:System.Reflection.CustomAttributeData&gt;</ph> classe.</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve" uid="T:System.Reflection.Module">
          <source>Returns a specified field.</source>
          <target state="translated">Retorna um campo especificado.</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetField(System.String)">
          <source>The field name.</source>
          <target state="translated">O nome do campo.</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetField(System.String)">
          <source>Returns a field having the specified name.</source>
          <target state="translated">Retorna um campo que tem o nome especificado.</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetField(System.String)">
          <source>A <ph id="ph1">&lt;see langword="FieldInfo" /&gt;</ph> object having the specified name, or <ph id="ph2">&lt;see langword="null" /&gt;</ph> if the field does not exist.</source>
          <target state="translated">Um objeto <ph id="ph1">&lt;see langword="FieldInfo" /&gt;</ph> com o nome especificado ou <ph id="ph2">&lt;see langword="null" /&gt;</ph>, se o campo não existir.</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetField(System.String)">
          <source>The <ph id="ph1">&lt;paramref name="name" /&gt;</ph> parameter is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">O parâmetro <ph id="ph1">&lt;paramref name="name" /&gt;</ph> é <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetField(System.String,System.Reflection.BindingFlags)">
          <source>The field name.</source>
          <target state="translated">O nome do campo.</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetField(System.String,System.Reflection.BindingFlags)">
          <source>One of the <ph id="ph1">&lt;see langword="BindingFlags" /&gt;</ph> bit flags used to control the search.</source>
          <target state="translated">Um dos sinalizadores de bit <ph id="ph1">&lt;see langword="BindingFlags" /&gt;</ph> usados para controlar a pesquisa.</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetField(System.String,System.Reflection.BindingFlags)">
          <source>Returns a field having the specified name and binding attributes.</source>
          <target state="translated">Retorna um campo com o nome e os atributos de associação especificados.</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetField(System.String,System.Reflection.BindingFlags)">
          <source>A <ph id="ph1">&lt;see langword="FieldInfo" /&gt;</ph> object having the specified name and binding attributes, or <ph id="ph2">&lt;see langword="null" /&gt;</ph> if the field does not exist.</source>
          <target state="translated">Um objeto <ph id="ph1">&lt;see langword="FieldInfo" /&gt;</ph> com o nome e os atributos de associação especificados ou <ph id="ph2">&lt;see langword="null" /&gt;</ph>, se o campo não existir.</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetField(System.String,System.Reflection.BindingFlags)">
          <source>The <ph id="ph1">&lt;paramref name="name" /&gt;</ph> parameter is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">O parâmetro <ph id="ph1">&lt;paramref name="name" /&gt;</ph> é <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve" uid="T:System.Reflection.Module">
          <source>Returns the global fields defined on the module.</source>
          <target state="translated">Retorna os campos globais definidos no módulo.</target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetFields">
          <source>Returns the global fields defined on the module.</source>
          <target state="translated">Retorna os campos globais definidos no módulo.</target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetFields">
          <source>An array of <ph id="ph1">&lt;see cref="T:System.Reflection.FieldInfo" /&gt;</ph> objects representing the global fields defined on the module; if there are no global fields, an empty array is returned.</source>
          <target state="translated">Uma matriz de objetos <ph id="ph1">&lt;see cref="T:System.Reflection.FieldInfo" /&gt;</ph> que representam os campos globais definidos no módulo; se não houver campos globais, uma matriz vazia será retornada.</target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.GetFields">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.Module.GetFields%2A&gt;</ph> method does not return fields in a particular order, such as alphabetical or declaration order.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Reflection.Module.GetFields%2A&gt;</ph> método não retornar campos em uma ordem específica, como em ordem alfabética ou ordem de declaração.</target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.GetFields">
          <source>Your code must not depend on the order in which fields are returned, because that order can vary.</source>
          <target state="translated">Seu código deve não dependam da ordem na qual os campos são retornados, como ordem pode variar.</target>       </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetFields(System.Reflection.BindingFlags)">
          <source>A bitwise combination of <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph> values that limit the search.</source>
          <target state="translated">Uma combinação bit a bit de valores <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph> que limitam a pesquisa.</target>       </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetFields(System.Reflection.BindingFlags)">
          <source>Returns the global fields defined on the module that match the specified binding flags.</source>
          <target state="translated">Retorna os campos globais definidos no módulo que correspondem aos sinalizadores de associação especificados.</target>       </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetFields(System.Reflection.BindingFlags)">
          <source>An array of type <ph id="ph1">&lt;see cref="T:System.Reflection.FieldInfo" /&gt;</ph> representing the global fields defined on the module that match the specified binding flags; if no global fields match the binding flags, an empty array is returned.</source>
          <target state="translated">Uma matriz do tipo <ph id="ph1">&lt;see cref="T:System.Reflection.FieldInfo" /&gt;</ph> que representa os campos globais definidos no módulo que correspondem aos sinalizadores de associação especificados; se nenhum campo global corresponder aos sinalizadores de associação, uma matriz vazia será retornada.</target>       </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.GetFields(System.Reflection.BindingFlags)">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.Module.GetFields%2A&gt;</ph> method does not return fields in a particular order, such as alphabetical or declaration order.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Reflection.Module.GetFields%2A&gt;</ph> método não retornar campos em uma ordem específica, como em ordem alfabética ou ordem de declaração.</target>       </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.GetFields(System.Reflection.BindingFlags)">
          <source>Your code must not depend on the order in which fields are returned, because that order can vary.</source>
          <target state="translated">Seu código deve não dependam da ordem na qual os campos são retornados, como ordem pode variar.</target>       </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetHashCode">
          <source>Returns the hash code for this instance.</source>
          <target state="translated">Retorna o código hash para essa instância.</target>       </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetHashCode">
          <source>A 32-bit signed integer hash code.</source>
          <target state="translated">Um código de hash do inteiro assinado de 32 bits.</target>       </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve" uid="T:System.Reflection.Module">
          <source>Returns a method having the specified criteria.</source>
          <target state="translated">Retorna um método com os critérios especificados.</target>       </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetMethod(System.String)">
          <source>The method name.</source>
          <target state="translated">O nome do método.</target>       </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetMethod(System.String)">
          <source>Returns a method having the specified name.</source>
          <target state="translated">Retorna um método com o nome especificado.</target>       </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetMethod(System.String)">
          <source>A <ph id="ph1">&lt;see langword="MethodInfo" /&gt;</ph> object having the specified name, or <ph id="ph2">&lt;see langword="null" /&gt;</ph> if the method does not exist.</source>
          <target state="translated">Um objeto <ph id="ph1">&lt;see langword="MethodInfo" /&gt;</ph> com o nome especificado ou <ph id="ph2">&lt;see langword="null" /&gt;</ph>, se o método não existir.</target>       </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetMethod(System.String)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> é <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetMethod(System.String,System.Type[])">
          <source>The method name.</source>
          <target state="translated">O nome do método.</target>       </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetMethod(System.String,System.Type[])">
          <source>The parameter types to search for.</source>
          <target state="translated">Os tipos de parâmetro pelos quais pesquisar.</target>       </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetMethod(System.String,System.Type[])">
          <source>Returns a method having the specified name and parameter types.</source>
          <target state="translated">Retorna um método com os tipos de parâmetro e nome especificados.</target>       </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetMethod(System.String,System.Type[])">
          <source>A <ph id="ph1">&lt;see langword="MethodInfo" /&gt;</ph> object in accordance with the specified criteria, or <ph id="ph2">&lt;see langword="null" /&gt;</ph> if the method does not exist.</source>
          <target state="translated">Um objeto <ph id="ph1">&lt;see langword="MethodInfo" /&gt;</ph> de acordo com os critérios especificados ou <ph id="ph2">&lt;see langword="null" /&gt;</ph> se o método não existir.</target>       </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetMethod(System.String,System.Type[])">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>, <ph id="ph3">&lt;paramref name="types" /&gt;</ph> is <ph id="ph4">&lt;see langword="null" /&gt;</ph>, or <ph id="ph5">&lt;paramref name="types" /&gt;</ph> (i) is <ph id="ph6">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> é <ph id="ph2">&lt;see langword="null" /&gt;</ph>, <ph id="ph3">&lt;paramref name="types" /&gt;</ph> é <ph id="ph4">&lt;see langword="null" /&gt;</ph> ou <ph id="ph5">&lt;paramref name="types" /&gt;</ph> (i) é <ph id="ph6">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>The method name.</source>
          <target state="translated">O nome do método.</target>       </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>One of the <ph id="ph1">&lt;see langword="BindingFlags" /&gt;</ph> bit flags used to control the search.</source>
          <target state="translated">Um dos sinalizadores de bit <ph id="ph1">&lt;see langword="BindingFlags" /&gt;</ph> usados para controlar a pesquisa.</target>       </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>An object that implements <ph id="ph1">&lt;see langword="Binder" /&gt;</ph>, containing properties related to this method.</source>
          <target state="translated">Um objeto que implementa <ph id="ph1">&lt;see langword="Binder" /&gt;</ph>, contendo as propriedades relacionadas a este método.</target>       </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>The calling convention for the method.</source>
          <target state="translated">A convenção de chamada para o método.</target>       </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>The parameter types to search for.</source>
          <target state="translated">Os tipos de parâmetro pelos quais pesquisar.</target>       </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>An array of parameter modifiers used to make binding work with parameter signatures in which the types have been modified.</source>
          <target state="translated">Uma matriz de modificadores de parâmetro usados para fazer a associação funcionar com assinaturas de parâmetro nos quais os tipos foram modificados.</target>       </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Returns a method having the specified name, binding information, calling convention, and parameter types and modifiers.</source>
          <target state="translated">Retorna um método contendo o nome especificado, informações de associação, convenção de chamada e tipos de parâmetro e modificadores.</target>       </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>A <ph id="ph1">&lt;see langword="MethodInfo" /&gt;</ph> object in accordance with the specified criteria, or <ph id="ph2">&lt;see langword="null" /&gt;</ph> if the method does not exist.</source>
          <target state="translated">Um objeto <ph id="ph1">&lt;see langword="MethodInfo" /&gt;</ph> de acordo com os critérios especificados ou <ph id="ph2">&lt;see langword="null" /&gt;</ph> se o método não existir.</target>       </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>, <ph id="ph3">&lt;paramref name="types" /&gt;</ph> is <ph id="ph4">&lt;see langword="null" /&gt;</ph>, or <ph id="ph5">&lt;paramref name="types" /&gt;</ph> (i) is <ph id="ph6">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> é <ph id="ph2">&lt;see langword="null" /&gt;</ph>, <ph id="ph3">&lt;paramref name="types" /&gt;</ph> é <ph id="ph4">&lt;see langword="null" /&gt;</ph> ou <ph id="ph5">&lt;paramref name="types" /&gt;</ph> (i) é <ph id="ph6">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>The method name.</source>
          <target state="translated">O nome do método.</target>       </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>One of the <ph id="ph1">&lt;see langword="BindingFlags" /&gt;</ph> bit flags used to control the search.</source>
          <target state="translated">Um dos sinalizadores de bit <ph id="ph1">&lt;see langword="BindingFlags" /&gt;</ph> usados para controlar a pesquisa.</target>       </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>An object that implements <ph id="ph1">&lt;see langword="Binder" /&gt;</ph>, containing properties related to this method.</source>
          <target state="translated">Um objeto que implementa <ph id="ph1">&lt;see langword="Binder" /&gt;</ph>, contendo as propriedades relacionadas a este método.</target>       </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>The calling convention for the method.</source>
          <target state="translated">A convenção de chamada para o método.</target>       </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>The parameter types to search for.</source>
          <target state="translated">Os tipos de parâmetro pelos quais pesquisar.</target>       </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>An array of parameter modifiers used to make binding work with parameter signatures in which the types have been modified.</source>
          <target state="translated">Uma matriz de modificadores de parâmetro usados para fazer a associação funcionar com assinaturas de parâmetro nos quais os tipos foram modificados.</target>       </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Returns the method implementation in accordance with the specified criteria.</source>
          <target state="translated">Retorna a implementação do método de acordo com os critérios especificados.</target>       </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>A <ph id="ph1">&lt;see langword="MethodInfo" /&gt;</ph> object containing implementation information as specified, or <ph id="ph2">&lt;see langword="null" /&gt;</ph> if the method does not exist.</source>
          <target state="translated">Um objeto <ph id="ph1">&lt;see langword="MethodInfo" /&gt;</ph> que contém informações de implementação conforme especificado ou <ph id="ph2">&lt;see langword="null" /&gt;</ph>, se o método não existir.</target>       </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source><ph id="ph1">&lt;paramref name="types" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="types" /&gt;</ph> é <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve" uid="T:System.Reflection.Module">
          <source>Returns the global methods defined on the module</source>
          <target state="translated">Retorna os métodos globais definidos no módulo</target>       </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetMethods">
          <source>Returns the global methods defined on the module.</source>
          <target state="translated">Retorna os métodos globais definidos no módulo.</target>       </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetMethods">
          <source>An array of <ph id="ph1">&lt;see cref="T:System.Reflection.MethodInfo" /&gt;</ph> objects representing all the global methods defined on the module; if there are no global methods, an empty array is returned.</source>
          <target state="translated">Uma matriz de objetos <ph id="ph1">&lt;see cref="T:System.Reflection.MethodInfo" /&gt;</ph> que representam todos os métodos globais definidos no módulo; se não houver métodos globais, uma matriz vazia será retornada.</target>       </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetMethods(System.Reflection.BindingFlags)">
          <source>A bitwise combination of <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph> values that limit the search.</source>
          <target state="translated">Uma combinação bit a bit de valores <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph> que limitam a pesquisa.</target>       </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetMethods(System.Reflection.BindingFlags)">
          <source>Returns the global methods defined on the module that match the specified binding flags.</source>
          <target state="translated">Retorna os métodos globais definidos no módulo que correspondem aos sinalizadores de associação especificados.</target>       </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetMethods(System.Reflection.BindingFlags)">
          <source>An array of type <ph id="ph1">&lt;see cref="T:System.Reflection.MethodInfo" /&gt;</ph> representing the global methods defined on the module that match the specified binding flags; if no global methods match the binding flags, an empty array is returned.</source>
          <target state="translated">Uma matriz do tipo <ph id="ph1">&lt;see cref="T:System.Reflection.MethodInfo" /&gt;</ph> que representa os métodos globais definidos no módulo que correspondem aos sinalizadores de associação especificados; se nenhum método global corresponder aos sinalizadores de associação, uma matriz vazia será retornada.</target>       </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
          <source>The information and data needed to serialize or deserialize an object.</source>
          <target state="translated">As informações e os dados necessários para serializar ou desserializar um objeto.</target>       </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
          <source>The context for the serialization.</source>
          <target state="translated">O contexto da serialização.</target>       </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
          <source>Provides an <ph id="ph1">&lt;see cref="T:System.Runtime.Serialization.ISerializable" /&gt;</ph> implementation for serialized objects.</source>
          <target state="translated">Fornece uma implementação <ph id="ph1">&lt;see cref="T:System.Runtime.Serialization.ISerializable" /&gt;</ph> para objetos serializados.</target>       </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
          <source><ph id="ph1">&lt;paramref name="info" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="info" /&gt;</ph> é <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
          <source>Requires full trust for the immediate caller.</source>
          <target state="translated">Requer confiança total para o chamador imediato.</target>       </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Este membro não pode ser usado pelo código transparente ou parcialmente confiável.</target>       </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetPEKind(System.Reflection.PortableExecutableKinds@,System.Reflection.ImageFileMachine@)">
          <source>When this method returns, a combination of the <ph id="ph1">&lt;see cref="T:System.Reflection.PortableExecutableKinds" /&gt;</ph> values indicating the nature of the code in the module.</source>
          <target state="translated">Quando este método retorna, uma combinação dos valores <ph id="ph1">&lt;see cref="T:System.Reflection.PortableExecutableKinds" /&gt;</ph> indicando a natureza do código no módulo.</target>       </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetPEKind(System.Reflection.PortableExecutableKinds@,System.Reflection.ImageFileMachine@)">
          <source>When this method returns, one of the <ph id="ph1">&lt;see cref="T:System.Reflection.ImageFileMachine" /&gt;</ph> values indicating the platform targeted by the module.</source>
          <target state="translated">Quando este método retorna, um dos valores <ph id="ph1">&lt;see cref="T:System.Reflection.ImageFileMachine" /&gt;</ph> indicando a plataforma de destino no módulo.</target>       </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetPEKind(System.Reflection.PortableExecutableKinds@,System.Reflection.ImageFileMachine@)">
          <source>Gets a pair of values indicating the nature of the code in a module and the platform targeted by the module.</source>
          <target state="translated">Obtém um par de valores que indica a natureza do código em um módulo e a plataforma de destino do módulo.</target>       </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetSignerCertificate">
          <source>Returns an <ph id="ph1">&lt;see langword="X509Certificate" /&gt;</ph> object corresponding to the certificate included in the Authenticode signature of the assembly which this module belongs to.</source>
          <target state="translated">Retorna um objeto <ph id="ph1">&lt;see langword="X509Certificate" /&gt;</ph> correspondente ao certificado incluído na assinatura Authenticode do assembly ao qual este módulo pertence.</target>       </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetSignerCertificate">
          <source>If the assembly has not been Authenticode signed, <ph id="ph1">&lt;see langword="null" /&gt;</ph> is returned.</source>
          <target state="translated">Se o assembly não tiver sido assinado por Authenticode, <ph id="ph1">&lt;see langword="null" /&gt;</ph> será retornado.</target>       </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetSignerCertificate">
          <source>An <ph id="ph1">&lt;see langword="X509Certificate" /&gt;</ph> object, or <ph id="ph2">&lt;see langword="null" /&gt;</ph> if the assembly to which this module belongs has not been Authenticode signed.</source>
          <target state="translated">Um objeto <ph id="ph1">&lt;see langword="X509Certificate" /&gt;</ph> ou <ph id="ph2">&lt;see langword="null" /&gt;</ph>, se o assembly ao qual este módulo pertence não tiver sido assinado por Authenticode.</target>       </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve" uid="T:System.Reflection.Module">
          <source>Returns the specified type.</source>
          <target state="translated">Retorna o tipo especificado.</target>       </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetType(System.String)">
          <source>The name of the type to locate.</source>
          <target state="translated">O nome do tipo a ser localizado.</target>       </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetType(System.String)">
          <source>The name must be fully qualified with the namespace.</source>
          <target state="translated">O nome deve ser totalmente qualificado com o namespace.</target>       </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetType(System.String)">
          <source>Returns the specified type, performing a case-sensitive search.</source>
          <target state="translated">Retorna o tipo especificado, executando uma pesquisa que diferencia maiúsculas de minúsculas.</target>       </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetType(System.String)">
          <source>A <ph id="ph1">&lt;see langword="Type" /&gt;</ph> object representing the given type, if the type is in this module; otherwise, <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Um objeto <ph id="ph1">&lt;see langword="Type" /&gt;</ph> que representará o tipo especificado se o tipo estiver nesse módulo; caso contrário, <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.GetType(System.String)">
          <source>If the type has been forwarded to another assembly, it is still returned by this method.</source>
          <target state="translated">Se o tipo foi encaminhado para outro conjunto, ele ainda é retornado por este método.</target>       </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.GetType(System.String)">
          <source>For information on type forwarding, see <bpt id="p1">[</bpt>Type Forwarding in the Common Language Runtime<ept id="p1">](~/docs/framework/app-domains/type-forwarding-in-the-common-language-runtime.md)</ept>.</source>
          <target state="translated">Para obter informações sobre o encaminhamento de tipo, consulte <bpt id="p1">[</bpt>encaminhamento de tipo no Common Language Runtime<ept id="p1">](~/docs/framework/app-domains/type-forwarding-in-the-common-language-runtime.md)</ept>.</target>       </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.GetType(System.String)">
          <source>A type can be retrieved from a specific module using <ph id="ph1">&lt;xref:System.Reflection.Module.GetType%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Um tipo pode ser recuperado de um módulo específico usando <ph id="ph1">&lt;xref:System.Reflection.Module.GetType%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.GetType(System.String)">
          <source>Calling <ph id="ph1">&lt;xref:System.Reflection.Module.GetType%2A?displayProperty=nameWithType&gt;</ph> on the module that contains the manifest will not search the entire assembly.</source>
          <target state="translated">Chamando <ph id="ph1">&lt;xref:System.Reflection.Module.GetType%2A?displayProperty=nameWithType&gt;</ph> no módulo que contém o manifesto não procurará o conjunto inteiro.</target>       </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.GetType(System.String)">
          <source>To retrieve a type from an assembly, regardless of which module it is in, you must call <ph id="ph1">&lt;xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Para recuperar um tipo de um assembly, independentemente de qual módulo está em, você deve chamar <ph id="ph1">&lt;xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.GetType(System.String)">
          <source>The following example displays the name of a type in the specified module.</source>
          <target state="translated">O exemplo a seguir exibe o nome de um tipo no módulo especificado.</target>       </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetType(System.String)">
          <source><ph id="ph1">&lt;paramref name="className" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="className" /&gt;</ph> é <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetType(System.String)">
          <source>The class initializers are invoked and an exception is thrown.</source>
          <target state="translated">Os inicializadores de classe são invocados e uma exceção é gerada.</target>       </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetType(System.String)">
          <source><ph id="ph1">&lt;paramref name="className" /&gt;</ph> is a zero-length string.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="className" /&gt;</ph> é uma cadeia de comprimento zero.</target>       </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetType(System.String)">
          <source><ph id="ph1">&lt;paramref name="className" /&gt;</ph> requires a dependent assembly that could not be found.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="className" /&gt;</ph> exige um assembly dependente que não pôde ser encontrado.</target>       </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetType(System.String)">
          <source><ph id="ph1">&lt;paramref name="className" /&gt;</ph> requires a dependent assembly that was found but could not be loaded.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="className" /&gt;</ph> exige um assembly dependente que foi encontrado, mas que não pôde ser carregado.</target>       </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetType(System.String)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetType(System.String)">
          <source>The current assembly was loaded into the reflection-only context, and <ph id="ph1">&lt;paramref name="className" /&gt;</ph> requires a dependent assembly that was not preloaded.</source>
          <target state="translated">O assembly atual foi carregado no contexto somente reflexão e o <ph id="ph1">&lt;paramref name="className" /&gt;</ph> exige um assembly dependente que não foi pré-carregado.</target>       </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetType(System.String)">
          <source><ph id="ph1">&lt;paramref name="className" /&gt;</ph> requires a dependent assembly, but the file is not a valid assembly.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="className" /&gt;</ph> exige um assembly dependente, mas o arquivo não é um assembly válido.</target>       </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetType(System.String)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetType(System.String)">
          <source><ph id="ph1">&lt;paramref name="className" /&gt;</ph> requires a dependent assembly which was compiled for a version of the runtime later than the currently loaded version.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="className" /&gt;</ph> exige um assembly dependente que foi compilado para uma versão do tempo de execução posterior à versão carregada no momento.</target>       </trans-unit>
        <trans-unit id="260" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetType(System.String,System.Boolean)">
          <source>The name of the type to locate.</source>
          <target state="translated">O nome do tipo a ser localizado.</target>       </trans-unit>
        <trans-unit id="261" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetType(System.String,System.Boolean)">
          <source>The name must be fully qualified with the namespace.</source>
          <target state="translated">O nome deve ser totalmente qualificado com o namespace.</target>       </trans-unit>
        <trans-unit id="262" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetType(System.String,System.Boolean)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> for case-insensitive search; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> para a pesquisa que não diferencia maiúsculas de minúsculas; caso contrário, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="263" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetType(System.String,System.Boolean)">
          <source>Returns the specified type, searching the module with the specified case sensitivity.</source>
          <target state="translated">Retorna o tipo especificado, pesquisando o módulo com a diferenciação de maiúsculas e minúsculas especificada.</target>       </trans-unit>
        <trans-unit id="264" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetType(System.String,System.Boolean)">
          <source>A <ph id="ph1">&lt;see langword="Type" /&gt;</ph> object representing the given type, if the type is in this module; otherwise, <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Um objeto <ph id="ph1">&lt;see langword="Type" /&gt;</ph> que representará o tipo especificado se o tipo estiver nesse módulo; caso contrário, <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="265" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.GetType(System.String,System.Boolean)">
          <source>If the type has been forwarded to another assembly, it is still returned by this method.</source>
          <target state="translated">Se o tipo foi encaminhado para outro conjunto, ele ainda é retornado por este método.</target>       </trans-unit>
        <trans-unit id="266" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.GetType(System.String,System.Boolean)">
          <source>For information on type forwarding, see <bpt id="p1">[</bpt>Type Forwarding in the Common Language Runtime<ept id="p1">](~/docs/framework/app-domains/type-forwarding-in-the-common-language-runtime.md)</ept>.</source>
          <target state="translated">Para obter informações sobre o encaminhamento de tipo, consulte <bpt id="p1">[</bpt>encaminhamento de tipo no Common Language Runtime<ept id="p1">](~/docs/framework/app-domains/type-forwarding-in-the-common-language-runtime.md)</ept>.</target>       </trans-unit>
        <trans-unit id="267" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.GetType(System.String,System.Boolean)">
          <source>A type can be retrieved from a specific module using <ph id="ph1">&lt;xref:System.Reflection.Module.GetType%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Um tipo pode ser recuperado de um módulo específico usando <ph id="ph1">&lt;xref:System.Reflection.Module.GetType%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="268" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.GetType(System.String,System.Boolean)">
          <source>Calling <ph id="ph1">&lt;xref:System.Reflection.Module.GetType%2A?displayProperty=nameWithType&gt;</ph> on the module that contains the manifest will not search the entire assembly.</source>
          <target state="translated">Chamando <ph id="ph1">&lt;xref:System.Reflection.Module.GetType%2A?displayProperty=nameWithType&gt;</ph> no módulo que contém o manifesto não procurará o conjunto inteiro.</target>       </trans-unit>
        <trans-unit id="269" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.GetType(System.String,System.Boolean)">
          <source>To retrieve a type from an assembly, regardless of which module it is in, you must call <ph id="ph1">&lt;xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Para recuperar um tipo de um assembly, independentemente de qual módulo está em, você deve chamar <ph id="ph1">&lt;xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="270" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.GetType(System.String,System.Boolean)">
          <source>The following example displays the name of a type in the specified module, specifying <ph id="ph1">`false`</ph> for the <ph id="ph2">`ignoreCase`</ph> parameter so that case will not be ignored.</source>
          <target state="translated">O exemplo a seguir exibe o nome de um tipo no módulo especificado, especificando <ph id="ph1">`false`</ph> para o <ph id="ph2">`ignoreCase`</ph> parâmetro para esse caso não será ignorado.</target>       </trans-unit>
        <trans-unit id="271" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetType(System.String,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="className" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="className" /&gt;</ph> é <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="272" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetType(System.String,System.Boolean)">
          <source>The class initializers are invoked and an exception is thrown.</source>
          <target state="translated">Os inicializadores de classe são invocados e uma exceção é gerada.</target>       </trans-unit>
        <trans-unit id="273" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetType(System.String,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="className" /&gt;</ph> is a zero-length string.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="className" /&gt;</ph> é uma cadeia de comprimento zero.</target>       </trans-unit>
        <trans-unit id="274" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetType(System.String,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="className" /&gt;</ph> requires a dependent assembly that could not be found.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="className" /&gt;</ph> exige um assembly dependente que não pôde ser encontrado.</target>       </trans-unit>
        <trans-unit id="275" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetType(System.String,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="className" /&gt;</ph> requires a dependent assembly that was found but could not be loaded.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="className" /&gt;</ph> exige um assembly dependente que foi encontrado, mas que não pôde ser carregado.</target>       </trans-unit>
        <trans-unit id="276" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetType(System.String,System.Boolean)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="277" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetType(System.String,System.Boolean)">
          <source>The current assembly was loaded into the reflection-only context, and <ph id="ph1">&lt;paramref name="className" /&gt;</ph> requires a dependent assembly that was not preloaded.</source>
          <target state="translated">O assembly atual foi carregado no contexto somente reflexão e o <ph id="ph1">&lt;paramref name="className" /&gt;</ph> exige um assembly dependente que não foi pré-carregado.</target>       </trans-unit>
        <trans-unit id="278" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetType(System.String,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="className" /&gt;</ph> requires a dependent assembly, but the file is not a valid assembly.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="className" /&gt;</ph> exige um assembly dependente, mas o arquivo não é um assembly válido.</target>       </trans-unit>
        <trans-unit id="279" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetType(System.String,System.Boolean)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="280" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetType(System.String,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="className" /&gt;</ph> requires a dependent assembly which was compiled for a version of the runtime later than the currently loaded version.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="className" /&gt;</ph> exige um assembly dependente que foi compilado para uma versão do tempo de execução posterior à versão carregada no momento.</target>       </trans-unit>
        <trans-unit id="281" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetType(System.String,System.Boolean,System.Boolean)">
          <source>The name of the type to locate.</source>
          <target state="translated">O nome do tipo a ser localizado.</target>       </trans-unit>
        <trans-unit id="282" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetType(System.String,System.Boolean,System.Boolean)">
          <source>The name must be fully qualified with the namespace.</source>
          <target state="translated">O nome deve ser totalmente qualificado com o namespace.</target>       </trans-unit>
        <trans-unit id="283" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetType(System.String,System.Boolean,System.Boolean)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> to throw an exception if the type cannot be found; <ph id="ph2">&lt;see langword="false" /&gt;</ph> to return <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> para gerar uma exceção se não for possível encontrar o tipo; <ph id="ph2">&lt;see langword="false" /&gt;</ph> para retornar <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="284" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetType(System.String,System.Boolean,System.Boolean)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> for case-insensitive search; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> para a pesquisa que não diferencia maiúsculas de minúsculas; caso contrário, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="285" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetType(System.String,System.Boolean,System.Boolean)">
          <source>Returns the specified type, specifying whether to make a case-sensitive search of the module and whether to throw an exception if the type cannot be found.</source>
          <target state="translated">Retorna o tipo especificado, especificando se deve ser feita uma pesquisa que diferencia maiúsculas de minúsculas do módulo e gerar uma exceção se não for possível localizar o tipo.</target>       </trans-unit>
        <trans-unit id="286" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetType(System.String,System.Boolean,System.Boolean)">
          <source>A <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> object representing the specified type, if the type is declared in this module; otherwise, <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Um objeto <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> que representa o tipo especificado, se o tipo for declarado neste módulo; caso contrário, <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="287" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.GetType(System.String,System.Boolean,System.Boolean)">
          <source>The <ph id="ph1">`throwOnError`</ph> parameter affects only what happens when the type is not found.</source>
          <target state="translated">O <ph id="ph1">`throwOnError`</ph> parâmetro afeta somente o que acontece quando o tipo não foi encontrado.</target>       </trans-unit>
        <trans-unit id="288" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.GetType(System.String,System.Boolean,System.Boolean)">
          <source>It does not affect any other exceptions that might be thrown.</source>
          <target state="translated">Ele não afeta todas as exceções que podem ser geradas.</target>       </trans-unit>
        <trans-unit id="289" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.GetType(System.String,System.Boolean,System.Boolean)">
          <source>In particular, if the type is found but cannot be loaded, <ph id="ph1">&lt;xref:System.TypeLoadException&gt;</ph> can be thrown even if <ph id="ph2">`throwOnError`</ph> is <ph id="ph3">`false`</ph>.</source>
          <target state="translated">Em particular, se o tipo é encontrado, mas não pode ser carregado, <ph id="ph1">&lt;xref:System.TypeLoadException&gt;</ph> pode ser acionada mesmo se <ph id="ph2">`throwOnError`</ph> é <ph id="ph3">`false`</ph>.</target>       </trans-unit>
        <trans-unit id="290" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.GetType(System.String,System.Boolean,System.Boolean)">
          <source>If the type has been forwarded to another assembly, it is still returned by this method.</source>
          <target state="translated">Se o tipo foi encaminhado para outro conjunto, ele ainda é retornado por este método.</target>       </trans-unit>
        <trans-unit id="291" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.GetType(System.String,System.Boolean,System.Boolean)">
          <source>For information on type forwarding, see <bpt id="p1">[</bpt>Type Forwarding in the Common Language Runtime<ept id="p1">](~/docs/framework/app-domains/type-forwarding-in-the-common-language-runtime.md)</ept>.</source>
          <target state="translated">Para obter informações sobre o encaminhamento de tipo, consulte <bpt id="p1">[</bpt>encaminhamento de tipo no Common Language Runtime<ept id="p1">](~/docs/framework/app-domains/type-forwarding-in-the-common-language-runtime.md)</ept>.</target>       </trans-unit>
        <trans-unit id="292" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.GetType(System.String,System.Boolean,System.Boolean)">
          <source>A type can be retrieved from a specific module using <ph id="ph1">&lt;xref:System.Reflection.Module.GetType%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Um tipo pode ser recuperado de um módulo específico usando <ph id="ph1">&lt;xref:System.Reflection.Module.GetType%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="293" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.GetType(System.String,System.Boolean,System.Boolean)">
          <source>Calling <ph id="ph1">&lt;xref:System.Reflection.Module.GetType%2A?displayProperty=nameWithType&gt;</ph> on the module that contains the manifest will not search the entire assembly.</source>
          <target state="translated">Chamando <ph id="ph1">&lt;xref:System.Reflection.Module.GetType%2A?displayProperty=nameWithType&gt;</ph> no módulo que contém o manifesto não procurará o conjunto inteiro.</target>       </trans-unit>
        <trans-unit id="294" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.GetType(System.String,System.Boolean,System.Boolean)">
          <source>To retrieve a type from an assembly, regardless of which module it is in, you must call <ph id="ph1">&lt;xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Para recuperar um tipo de um assembly, independentemente de qual módulo está em, você deve chamar <ph id="ph1">&lt;xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="295" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.GetType(System.String,System.Boolean,System.Boolean)">
          <source>The following example displays the name of a type in the specified module.</source>
          <target state="translated">O exemplo a seguir exibe o nome de um tipo no módulo especificado.</target>       </trans-unit>
        <trans-unit id="296" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.GetType(System.String,System.Boolean,System.Boolean)">
          <source>The <ph id="ph1">`throwOnError`</ph> and <ph id="ph2">`ignoreCase`</ph> parameters are specified as <ph id="ph3">`false`</ph>.</source>
          <target state="translated">O <ph id="ph1">`throwOnError`</ph> e <ph id="ph2">`ignoreCase`</ph> são especificados como <ph id="ph3">`false`</ph>.</target>       </trans-unit>
        <trans-unit id="297" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetType(System.String,System.Boolean,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="className" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="className" /&gt;</ph> é <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="298" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetType(System.String,System.Boolean,System.Boolean)">
          <source>The class initializers are invoked and an exception is thrown.</source>
          <target state="translated">Os inicializadores de classe são invocados e uma exceção é gerada.</target>       </trans-unit>
        <trans-unit id="299" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetType(System.String,System.Boolean,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="className" /&gt;</ph> is a zero-length string.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="className" /&gt;</ph> é uma cadeia de comprimento zero.</target>       </trans-unit>
        <trans-unit id="300" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetType(System.String,System.Boolean,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="throwOnError" /&gt;</ph> is <ph id="ph2">&lt;see langword="true" /&gt;</ph>, and the type cannot be found.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="throwOnError" /&gt;</ph> é <ph id="ph2">&lt;see langword="true" /&gt;</ph> e o tipo não pode ser encontrado.</target>       </trans-unit>
        <trans-unit id="301" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetType(System.String,System.Boolean,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="className" /&gt;</ph> requires a dependent assembly that could not be found.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="className" /&gt;</ph> exige um assembly dependente que não pôde ser encontrado.</target>       </trans-unit>
        <trans-unit id="302" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetType(System.String,System.Boolean,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="className" /&gt;</ph> requires a dependent assembly that was found but could not be loaded.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="className" /&gt;</ph> exige um assembly dependente que foi encontrado, mas que não pôde ser carregado.</target>       </trans-unit>
        <trans-unit id="303" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetType(System.String,System.Boolean,System.Boolean)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="304" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetType(System.String,System.Boolean,System.Boolean)">
          <source>The current assembly was loaded into the reflection-only context, and <ph id="ph1">&lt;paramref name="className" /&gt;</ph> requires a dependent assembly that was not preloaded.</source>
          <target state="translated">O assembly atual foi carregado no contexto somente reflexão e o <ph id="ph1">&lt;paramref name="className" /&gt;</ph> exige um assembly dependente que não foi pré-carregado.</target>       </trans-unit>
        <trans-unit id="305" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetType(System.String,System.Boolean,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="className" /&gt;</ph> requires a dependent assembly, but the file is not a valid assembly.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="className" /&gt;</ph> exige um assembly dependente, mas o arquivo não é um assembly válido.</target>       </trans-unit>
        <trans-unit id="306" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetType(System.String,System.Boolean,System.Boolean)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="307" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetType(System.String,System.Boolean,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="className" /&gt;</ph> requires a dependent assembly which was compiled for a version of the runtime later than the currently loaded version.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="className" /&gt;</ph> exige um assembly dependente que foi compilado para uma versão do tempo de execução posterior à versão carregada no momento.</target>       </trans-unit>
        <trans-unit id="308" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetTypes">
          <source>Returns all the types defined within this module.</source>
          <target state="translated">Retorna todos os tipos definidos nesse módulo.</target>       </trans-unit>
        <trans-unit id="309" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetTypes">
          <source>An array of type <ph id="ph1">&lt;see langword="Type" /&gt;</ph> containing types defined within the module that is reflected by this instance.</source>
          <target state="translated">Uma matriz do tipo <ph id="ph1">&lt;see langword="Type" /&gt;</ph> que contém os tipos definidos no módulo que é refletido por essa instância.</target>       </trans-unit>
        <trans-unit id="310" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.GetTypes">
          <source><ph id="ph1">`ReflectionTypeLoadException`</ph> is a special load exception.</source>
          <target state="translated"><ph id="ph1">`ReflectionTypeLoadException`</ph> é uma exceção ao carregar especial.</target>       </trans-unit>
        <trans-unit id="311" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.GetTypes">
          <source>The <ph id="ph1">`ReflectionTypeLoadException.Types`</ph> property contains the array of types that were defined in the module and were loaded.</source>
          <target state="translated">O <ph id="ph1">`ReflectionTypeLoadException.Types`</ph> propriedade contém a matriz de tipos que foram definidas no módulo e foram carregados.</target>       </trans-unit>
        <trans-unit id="312" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.GetTypes">
          <source>This array may contain some null values.</source>
          <target state="translated">Esta matriz pode conter alguns valores nulos.</target>       </trans-unit>
        <trans-unit id="313" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.GetTypes">
          <source>The <ph id="ph1">`ReflectionTypeLoadException.LoaderExceptions`</ph> property is an array of exceptions that represent the exceptions that were thrown by the loader.</source>
          <target state="translated">O <ph id="ph1">`ReflectionTypeLoadException.LoaderExceptions`</ph> propriedade é uma matriz de exceções que representam as exceções que foram lançadas pelo carregador.</target>       </trans-unit>
        <trans-unit id="314" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.GetTypes">
          <source>The holes in the class array line up with the exceptions.</source>
          <target state="translated">Falhas na matriz de classe alinharem com as exceções.</target>       </trans-unit>
        <trans-unit id="315" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.GetTypes">
          <source>For example, if the class initializers of one of the classes throws an exception while it is being loaded, a <ph id="ph1">`TargetInvocationException`</ph> is stored in the corresponding element of the <ph id="ph2">`LoaderExceptions`</ph> array.</source>
          <target state="translated">Por exemplo, se os inicializadores de classe de uma das classes de lançar uma exceção enquanto ele está sendo carregado, um <ph id="ph1">`TargetInvocationException`</ph> é armazenado no elemento correspondente a <ph id="ph2">`LoaderExceptions`</ph> matriz.</target>       </trans-unit>
        <trans-unit id="316" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.GetTypes">
          <source>If a type has been forwarded to another assembly, it is not included in the returned array.</source>
          <target state="translated">Se um tipo foi encaminhado para outro conjunto, ele não está incluído na matriz retornada.</target>       </trans-unit>
        <trans-unit id="317" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.GetTypes">
          <source>For information on type forwarding, see <bpt id="p1">[</bpt>Type Forwarding in the Common Language Runtime<ept id="p1">](~/docs/framework/app-domains/type-forwarding-in-the-common-language-runtime.md)</ept>.</source>
          <target state="translated">Para obter informações sobre o encaminhamento de tipo, consulte <bpt id="p1">[</bpt>encaminhamento de tipo no Common Language Runtime<ept id="p1">](~/docs/framework/app-domains/type-forwarding-in-the-common-language-runtime.md)</ept>.</target>       </trans-unit>
        <trans-unit id="318" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetTypes">
          <source>One or more classes in a module could not be loaded.</source>
          <target state="translated">Uma ou mais classes em um módulo não puderam ser carregadas.</target>       </trans-unit>
        <trans-unit id="319" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetTypes">
          <source>The caller does not have the required permission.</source>
          <target state="translated">O chamador não tem a permissão necessária.</target>       </trans-unit>
        <trans-unit id="320" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.GetTypes">
          <source>Reflection permission for the current module.</source>
          <target state="translated">Permissão de reflexão para o módulo atual.</target>       </trans-unit>
        <trans-unit id="321" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.IsDefined(System.Type,System.Boolean)">
          <source>The type of custom attribute to test for.</source>
          <target state="translated">O tipo de atributo personalizado para o qual testar.</target>       </trans-unit>
        <trans-unit id="322" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.IsDefined(System.Type,System.Boolean)">
          <source>This argument is ignored for objects of this type.</source>
          <target state="translated">Este argumento é ignorado para objetos deste tipo.</target>       </trans-unit>
        <trans-unit id="323" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.IsDefined(System.Type,System.Boolean)">
          <source>Returns a value that indicates whether the specified attribute type has been applied to this module.</source>
          <target state="translated">Retorna um valor que indica se o tipo de atributo especificado foi aplicado a este módulo.</target>       </trans-unit>
        <trans-unit id="324" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.IsDefined(System.Type,System.Boolean)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if one or more instances of <ph id="ph2">&lt;paramref name="attributeType" /&gt;</ph> have been applied to this module; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> se uma ou mais instâncias de <ph id="ph2">&lt;paramref name="attributeType" /&gt;</ph> tiver sido aplicada a este módulo; caso contrário, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="325" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.IsDefined(System.Type,System.Boolean)">
          <source>The following example demonstrates a use of the <ph id="ph1">`IsDefined`</ph> method.</source>
          <target state="translated">O exemplo a seguir demonstra um uso de <ph id="ph1">`IsDefined`</ph> método.</target>       </trans-unit>
        <trans-unit id="326" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.IsDefined(System.Type,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="attributeType" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="attributeType" /&gt;</ph> é <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="327" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.IsDefined(System.Type,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="attributeType" /&gt;</ph> is not a <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> object supplied by the runtime.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="attributeType" /&gt;</ph> não é um objeto <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> fornecido pelo tempo de execução.</target>       </trans-unit>
        <trans-unit id="328" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.IsDefined(System.Type,System.Boolean)">
          <source>For example, <ph id="ph1">&lt;paramref name="attributeType" /&gt;</ph> is a <ph id="ph2">&lt;see cref="T:System.Reflection.Emit.TypeBuilder" /&gt;</ph> object.</source>
          <target state="translated">Por exemplo, <ph id="ph1">&lt;paramref name="attributeType" /&gt;</ph> é um objeto <ph id="ph2">&lt;see cref="T:System.Reflection.Emit.TypeBuilder" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="329" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.IsResource">
          <source>Gets a value indicating whether the object is a resource.</source>
          <target state="translated">Obtém um valor que indica se o objeto é um recurso.</target>       </trans-unit>
        <trans-unit id="330" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.IsResource">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the object is a resource; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> se o objeto for um recurso; caso contrário, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="331" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.IsResource">
          <source>The following example demonstrates a use of the <ph id="ph1">`IsResource`</ph> method.</source>
          <target state="translated">O exemplo a seguir demonstra um uso de <ph id="ph1">`IsResource`</ph> método.</target>       </trans-unit>
        <trans-unit id="332" translate="yes" xml:space="preserve" uid="P:System.Reflection.Module.MDStreamVersion">
          <source>Gets the metadata stream version.</source>
          <target state="translated">Obtém a versão de fluxo de metadados.</target>       </trans-unit>
        <trans-unit id="333" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Module.MDStreamVersion">
          <source>A 32-bit integer representing the metadata stream version.</source>
          <target state="translated">Um inteiro de 32 bits que representa a versão de fluxo de metadados.</target>       </trans-unit>
        <trans-unit id="334" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Module.MDStreamVersion">
          <source>The high-order two bytes represent the major version number, and the low-order two bytes represent the minor version number.</source>
          <target state="translated">Os dois bytes de ordem superior representam o número de versão principal e as ordem inferior dois bytes representam o número de versão secundária.</target>       </trans-unit>
        <trans-unit id="335" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Module.MDStreamVersion">
          <source>For more information on the metadata header, see "Partition II: Metadata Definition and Semantics" in the Common Language Infrastructure (CLI) documentation.</source>
          <target state="translated">Para obter mais informações sobre o cabeçalho de metadados, consulte "Partição II: metadados definição e semântica" na documentação do Common Language Infrastructure (CLI).</target>       </trans-unit>
        <trans-unit id="336" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Module.MDStreamVersion">
          <source>The documentation is available online; see <bpt id="p1">[</bpt>ECMA C# and Common Language Infrastructure Standards<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=99212)</ept> on MSDN and <bpt id="p2">[</bpt>Standard ECMA-335 - Common Language Infrastructure (CLI)<ept id="p2">](http://go.microsoft.com/fwlink/?LinkID=65552)</ept> on the ECMA Web site.</source>
          <target state="translated">A documentação está disponível online; consulte <bpt id="p1">[</bpt>ECMA para c# e padrões de infra-estrutura de linguagem comum<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=99212)</ept> no MSDN e <bpt id="p2">[</bpt>padrão ECMA-335 - infraestrutura de linguagem comum (CLI)<ept id="p2">](http://go.microsoft.com/fwlink/?LinkID=65552)</ept> no site da Web de ECMA.</target>       </trans-unit>
        <trans-unit id="337" translate="yes" xml:space="preserve" uid="P:System.Reflection.Module.MetadataToken">
          <source>Gets a token that identifies the module in metadata.</source>
          <target state="translated">Obtém um token que identifica o módulo nos metadados.</target>       </trans-unit>
        <trans-unit id="338" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Module.MetadataToken">
          <source>An integer token that identifies the current module in metadata.</source>
          <target state="translated">Um token de número inteiro que identifica o módulo atual nos metadados.</target>       </trans-unit>
        <trans-unit id="339" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Module.MetadataToken">
          <source>The tokens obtained using this property can be passed to the unmanaged Reflection API.</source>
          <target state="translated">Os símbolos obtidos usando essa propriedade podem ser passados para a API não gerenciada de reflexão.</target>       </trans-unit>
        <trans-unit id="340" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Module.MetadataToken">
          <source>For more information, see <bpt id="p1">[</bpt>Unmanaged Reflection API<ept id="p1">](http://msdn.microsoft.com/library/0c5bb9de-0cf6-438d-ba47-134e6c775fb8)</ept>.</source>
          <target state="translated">Para obter mais informações, consulte <bpt id="p1">[</bpt>API não gerenciada de reflexão<ept id="p1">](http://msdn.microsoft.com/library/0c5bb9de-0cf6-438d-ba47-134e6c775fb8)</ept>.</target>       </trans-unit>
        <trans-unit id="341" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Module.MetadataToken">
          <source>Information about metadata tokens can be found in the Common Language Infrastructure (CLI) documentation, especially "Partition II: Metadata Definition and Semantics".</source>
          <target state="translated">Informações sobre tokens de metadados podem ser encontradas na documentação do Common Language Infrastructure (CLI), especialmente "partição II: metadados definição e semântica".</target>       </trans-unit>
        <trans-unit id="342" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Module.MetadataToken">
          <source>The documentation is available online; see <bpt id="p1">[</bpt>ECMA C# and Common Language Infrastructure Standards<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=99212)</ept> on MSDN and <bpt id="p2">[</bpt>Standard ECMA-335 - Common Language Infrastructure (CLI)<ept id="p2">](http://go.microsoft.com/fwlink/?LinkID=65552)</ept> on the ECMA Web site.</source>
          <target state="translated">A documentação está disponível online; consulte <bpt id="p1">[</bpt>ECMA para c# e padrões de infra-estrutura de linguagem comum<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=99212)</ept> no MSDN e <bpt id="p2">[</bpt>padrão ECMA-335 - infraestrutura de linguagem comum (CLI)<ept id="p2">](http://go.microsoft.com/fwlink/?LinkID=65552)</ept> no site da Web de ECMA.</target>       </trans-unit>
        <trans-unit id="343" translate="yes" xml:space="preserve" uid="P:System.Reflection.Module.ModuleHandle">
          <source>Gets a handle for the module.</source>
          <target state="translated">Obtém um identificador para o módulo.</target>       </trans-unit>
        <trans-unit id="344" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Module.ModuleHandle">
          <source>A <ph id="ph1">&lt;see cref="T:System.ModuleHandle" /&gt;</ph> structure for the current module.</source>
          <target state="translated">Um <ph id="ph1">&lt;see cref="T:System.ModuleHandle" /&gt;</ph> estrutura para o módulo atual.</target>       </trans-unit>
        <trans-unit id="345" translate="yes" xml:space="preserve" uid="P:System.Reflection.Module.ModuleVersionId">
          <source>Gets a universally unique identifier (UUID) that can be used to distinguish between two versions of a module.</source>
          <target state="translated">Obtém um UUID (identificador universal exclusivo) que pode ser usado para distinguir entre duas versões de um módulo.</target>       </trans-unit>
        <trans-unit id="346" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Module.ModuleVersionId">
          <source>A <ph id="ph1">&lt;see cref="T:System.Guid" /&gt;</ph> that can be used to distinguish between two versions of a module.</source>
          <target state="translated">Um <ph id="ph1">&lt;see cref="T:System.Guid" /&gt;</ph> que pode ser usado para distinguir entre duas versões de um módulo.</target>       </trans-unit>
        <trans-unit id="347" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Module.ModuleVersionId">
          <source>In unmanaged metadata, the GUID returned by the <ph id="ph1">&lt;xref:System.Reflection.Module.ModuleVersionId%2A&gt;</ph> property is referred to as the <ph id="ph2">`mvid`</ph>, and is stored in the GUID heap.</source>
          <target state="translated">Em metadados não gerenciado, o GUID retornado pelo <ph id="ph1">&lt;xref:System.Reflection.Module.ModuleVersionId%2A&gt;</ph> propriedade é conhecida como o <ph id="ph2">`mvid`</ph>e é armazenado no heap de GUID.</target>       </trans-unit>
        <trans-unit id="348" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Module.ModuleVersionId">
          <source>More information about metadata can be found in the Common Language Infrastructure (CLI) documentation, especially "Partition II: Metadata Definition and Semantics".</source>
          <target state="translated">Para obter mais informações sobre metadados podem ser encontradas na documentação do Common Language Infrastructure (CLI), especialmente "partição II: metadados definição e semântica".</target>       </trans-unit>
        <trans-unit id="349" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Module.ModuleVersionId">
          <source>The documentation is available online; see <bpt id="p1">[</bpt>ECMA C# and Common Language Infrastructure Standards<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=99212)</ept> on MSDN and <bpt id="p2">[</bpt>Standard ECMA-335 - Common Language Infrastructure (CLI)<ept id="p2">](http://go.microsoft.com/fwlink/?LinkID=65552)</ept> on the ECMA Web site.</source>
          <target state="translated">A documentação está disponível online; consulte <bpt id="p1">[</bpt>ECMA para c# e padrões de infra-estrutura de linguagem comum<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=99212)</ept> no MSDN e <bpt id="p2">[</bpt>padrão ECMA-335 - infraestrutura de linguagem comum (CLI)<ept id="p2">](http://go.microsoft.com/fwlink/?LinkID=65552)</ept> no site da Web de ECMA.</target>       </trans-unit>
        <trans-unit id="350" translate="yes" xml:space="preserve" uid="P:System.Reflection.Module.Name">
          <source>Gets a <ph id="ph1">&lt;see langword="String" /&gt;</ph> representing the name of the module with the path removed.</source>
          <target state="translated">Obtém um <ph id="ph1">&lt;see langword="String" /&gt;</ph> que representa o nome do módulo com o caminho removido.</target>       </trans-unit>
        <trans-unit id="351" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Module.Name">
          <source>The module name with no path.</source>
          <target state="translated">O nome do módulo sem caminho.</target>       </trans-unit>
        <trans-unit id="352" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Module.Name">
          <source><ph id="ph1">`Name`</ph> is a platform-dependent string.</source>
          <target state="translated"><ph id="ph1">`Name`</ph> é uma cadeia de caracteres dependente de plataforma.</target>       </trans-unit>
        <trans-unit id="353" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Module.Name">
          <source>If the assembly for this module was loaded from a byte array then the <ph id="ph1">`FullyQualifiedName`</ph> for the module will be: <ph id="ph2">\&lt;</ph>Unknown&gt;.</source>
          <target state="translated">Se o assembly para esse módulo foi carregado de uma matriz de bytes a <ph id="ph1">`FullyQualifiedName`</ph> para o módulo será: <ph id="ph2">\&lt;</ph>desconhecido &gt;.</target>       </trans-unit>
        <trans-unit id="354" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Module.Name">
          <source>To get the name and the path, use <ph id="ph1">&lt;xref:System.Reflection.Module.FullyQualifiedName%2A&gt;</ph>.</source>
          <target state="translated">Para obter o nome e o caminho, use <ph id="ph1">&lt;xref:System.Reflection.Module.FullyQualifiedName%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="355" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Module.Name">
          <source>This example shows the effect of the <ph id="ph1">`ScopeName`</ph>, <ph id="ph2">`FullyQualifiedName`</ph>, and <ph id="ph3">`Name`</ph> properties.</source>
          <target state="translated">Este exemplo mostra o efeito de <ph id="ph1">`ScopeName`</ph>, <ph id="ph2">`FullyQualifiedName`</ph>, e <ph id="ph3">`Name`</ph> propriedades.</target>       </trans-unit>
        <trans-unit id="356" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.op_Equality(System.Reflection.Module,System.Reflection.Module)">
          <source>The first object to compare.</source>
          <target state="translated">O primeiro objeto a ser comparado.</target>       </trans-unit>
        <trans-unit id="357" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.op_Equality(System.Reflection.Module,System.Reflection.Module)">
          <source>The second object to compare.</source>
          <target state="translated">O segundo objeto a ser comparado.</target>       </trans-unit>
        <trans-unit id="358" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.op_Equality(System.Reflection.Module,System.Reflection.Module)">
          <source>Indicates whether two <ph id="ph1">&lt;see cref="T:System.Reflection.Module" /&gt;</ph> objects are equal.</source>
          <target state="translated">Indica se dois objetos <ph id="ph1">&lt;see cref="T:System.Reflection.Module" /&gt;</ph> são iguais.</target>       </trans-unit>
        <trans-unit id="359" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.op_Equality(System.Reflection.Module,System.Reflection.Module)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if <ph id="ph2">&lt;paramref name="left" /&gt;</ph> is equal to <ph id="ph3">&lt;paramref name="right" /&gt;</ph>; otherwise, <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> se <ph id="ph2">&lt;paramref name="left" /&gt;</ph> for igual a <ph id="ph3">&lt;paramref name="right" /&gt;</ph>; caso contrário, <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="360" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.op_Inequality(System.Reflection.Module,System.Reflection.Module)">
          <source>The first object to compare.</source>
          <target state="translated">O primeiro objeto a ser comparado.</target>       </trans-unit>
        <trans-unit id="361" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.op_Inequality(System.Reflection.Module,System.Reflection.Module)">
          <source>The second object to compare.</source>
          <target state="translated">O segundo objeto a ser comparado.</target>       </trans-unit>
        <trans-unit id="362" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.op_Inequality(System.Reflection.Module,System.Reflection.Module)">
          <source>Indicates whether two <ph id="ph1">&lt;see cref="T:System.Reflection.Module" /&gt;</ph> objects are not equal.</source>
          <target state="translated">Indica se dois objetos <ph id="ph1">&lt;see cref="T:System.Reflection.Module" /&gt;</ph> não são iguais.</target>       </trans-unit>
        <trans-unit id="363" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.op_Inequality(System.Reflection.Module,System.Reflection.Module)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if <ph id="ph2">&lt;paramref name="left" /&gt;</ph> is not equal to <ph id="ph3">&lt;paramref name="right" /&gt;</ph>; otherwise, <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> se <ph id="ph2">&lt;paramref name="left" /&gt;</ph> não for igual a <ph id="ph3">&lt;paramref name="right" /&gt;</ph>; caso contrário, <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="364" translate="yes" xml:space="preserve" uid="T:System.Reflection.Module">
          <source>Returns the field identified by a metadata token.</source>
          <target state="translated">Retorna o campo identificado por um token de metadados.</target>       </trans-unit>
        <trans-unit id="365" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.ResolveField(System.Int32)">
          <source>A metadata token that identifies a field in the module.</source>
          <target state="translated">Um token de metadados que identifica um campo no módulo.</target>       </trans-unit>
        <trans-unit id="366" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.ResolveField(System.Int32)">
          <source>Returns the field identified by the specified metadata token.</source>
          <target state="translated">Retorna o campo identificado pelo token de metadados especificado.</target>       </trans-unit>
        <trans-unit id="367" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.ResolveField(System.Int32)">
          <source>A <ph id="ph1">&lt;see cref="T:System.Reflection.FieldInfo" /&gt;</ph> object representing the field that is identified by the specified metadata token.</source>
          <target state="translated">Um objeto <ph id="ph1">&lt;see cref="T:System.Reflection.FieldInfo" /&gt;</ph> que representa o campo que é identificado pelo token de metadados especificado.</target>       </trans-unit>
        <trans-unit id="368" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.ResolveField(System.Int32)">
          <source>To resolve a metadata token that identifies a field whose parent <ph id="ph1">`TypeSpec`</ph> has a signature containing element type <ph id="ph2">`ELEMENT_TYPE_VAR`</ph> or <ph id="ph3">`ELEMENT_TYPE_MVAR`</ph>, use the <ph id="ph4">&lt;xref:System.Reflection.Module.ResolveField%28System.Int32%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%29&gt;</ph> method overload, which allows you to supply the necessary context.</source>
          <target state="translated">Para resolver um token de metadados que identifica um campo cujo pai <ph id="ph1">`TypeSpec`</ph> tem uma assinatura que contém o tipo de elemento <ph id="ph2">`ELEMENT_TYPE_VAR`</ph> ou <ph id="ph3">`ELEMENT_TYPE_MVAR`</ph>, use o <ph id="ph4">&lt;xref:System.Reflection.Module.ResolveField%28System.Int32%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%29&gt;</ph> sobrecarga de método, o que permite que você fornecer o contexto necessário.</target>       </trans-unit>
        <trans-unit id="369" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.ResolveField(System.Int32)">
          <source>That is, when you are resolving a metadata token for a field that depends on the generic type parameters of the generic type and/or the generic method in which the token is embedded, you must use the overload that allows you to supply those type parameters.</source>
          <target state="translated">Ou seja, quando você está resolvendo um token de metadados para um campo que depende dos parâmetros de tipo genérico do tipo genérico e/ou o método genérico no qual o token é inserido, você deve usar a sobrecarga que permite que você forneça os parâmetros de tipo.</target>       </trans-unit>
        <trans-unit id="370" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.ResolveField(System.Int32)">
          <source>Information about metadata tokens can be found in the Common Language Infrastructure (CLI) documentation, especially "Partition II: Metadata Definition and Semantics".</source>
          <target state="translated">Informações sobre tokens de metadados podem ser encontradas na documentação do Common Language Infrastructure (CLI), especialmente "partição II: metadados definição e semântica".</target>       </trans-unit>
        <trans-unit id="371" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.ResolveField(System.Int32)">
          <source>The documentation is available online; see <bpt id="p1">[</bpt>ECMA C# and Common Language Infrastructure Standards<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=99212)</ept> on MSDN and <bpt id="p2">[</bpt>Standard ECMA-335 - Common Language Infrastructure (CLI)<ept id="p2">](http://go.microsoft.com/fwlink/?LinkID=65552)</ept> on the ECMA Web site.</source>
          <target state="translated">A documentação está disponível online; consulte <bpt id="p1">[</bpt>ECMA para c# e padrões de infra-estrutura de linguagem comum<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=99212)</ept> no MSDN e <bpt id="p2">[</bpt>padrão ECMA-335 - infraestrutura de linguagem comum (CLI)<ept id="p2">](http://go.microsoft.com/fwlink/?LinkID=65552)</ept> no site da Web de ECMA.</target>       </trans-unit>
        <trans-unit id="372" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.ResolveField(System.Int32)">
          <source>For code that demonstrates token resolution using the generic context (that is, the generic type parameters of the generic type and/or the generic method in which the token is embedded) see the <ph id="ph1">&lt;xref:System.Reflection.Module.ResolveMethod%28System.Int32%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%29&gt;</ph> method.</source>
          <target state="translated">Para o código que demonstra a resolução de token usando o contexto genérico (ou seja, os parâmetros de tipo genérico do tipo genérico e/ou o método genérico na qual o token é incorporado) consulte o <ph id="ph1">&lt;xref:System.Reflection.Module.ResolveMethod%28System.Int32%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%29&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="373" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.ResolveField(System.Int32)">
          <source><ph id="ph1">&lt;paramref name="metadataToken" /&gt;</ph> is not a token for a field in the scope of the current module.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="metadataToken" /&gt;</ph> não é um token para um campo no escopo do módulo atual.</target>       </trans-unit>
        <trans-unit id="374" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.ResolveField(System.Int32)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="375" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.ResolveField(System.Int32)">
          <source><ph id="ph1">&lt;paramref name="metadataToken" /&gt;</ph> identifies a field whose parent <ph id="ph2">&lt;see langword="TypeSpec" /&gt;</ph> has a signature containing element type <ph id="ph3">&lt;see langword="var" /&gt;</ph> (a type parameter of a generic type) or <ph id="ph4">&lt;see langword="mvar" /&gt;</ph> (a type parameter of a generic method).</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="metadataToken" /&gt;</ph> identifica um campo cujo <ph id="ph2">&lt;see langword="TypeSpec" /&gt;</ph> pai tem uma assinatura que contém o tipo de elemento <ph id="ph3">&lt;see langword="var" /&gt;</ph> (um parâmetro de tipo de um tipo genérico) ou <ph id="ph4">&lt;see langword="mvar" /&gt;</ph> (um parâmetro de tipo de um método genérico).</target>       </trans-unit>
        <trans-unit id="376" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.ResolveField(System.Int32)">
          <source><ph id="ph1">&lt;paramref name="metadataToken" /&gt;</ph> is not a valid token in the scope of the current module.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="metadataToken" /&gt;</ph> não é um token válido no escopo do módulo atual.</target>       </trans-unit>
        <trans-unit id="377" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.ResolveField(System.Int32,System.Type[],System.Type[])">
          <source>A metadata token that identifies a field in the module.</source>
          <target state="translated">Um token de metadados que identifica um campo no módulo.</target>       </trans-unit>
        <trans-unit id="378" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.ResolveField(System.Int32,System.Type[],System.Type[])">
          <source>An array of <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> objects representing the generic type arguments of the type where the token is in scope, or <ph id="ph2">&lt;see langword="null" /&gt;</ph> if that type is not generic.</source>
          <target state="translated">Uma matriz de objetos <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> que representam os argumentos de tipo genérico do tipo em que o token está no escopo ou <ph id="ph2">&lt;see langword="null" /&gt;</ph> se esse tipo não for genérico.</target>       </trans-unit>
        <trans-unit id="379" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.ResolveField(System.Int32,System.Type[],System.Type[])">
          <source>An array of <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> objects representing the generic type arguments of the method where the token is in scope, or <ph id="ph2">&lt;see langword="null" /&gt;</ph> if that method is not generic.</source>
          <target state="translated">Uma matriz de objetos <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> que representam os argumentos de tipo genérico do método em que o token está no escopo ou <ph id="ph2">&lt;see langword="null" /&gt;</ph> se esse método não for genérico.</target>       </trans-unit>
        <trans-unit id="380" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.ResolveField(System.Int32,System.Type[],System.Type[])">
          <source>Returns the field identified by the specified metadata token, in the context defined by the specified generic type parameters.</source>
          <target state="translated">Retorna o campo identificado pelo token de metadados especificado, no contexto definido pelos parâmetros de tipo genérico especificados.</target>       </trans-unit>
        <trans-unit id="381" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.ResolveField(System.Int32,System.Type[],System.Type[])">
          <source>A <ph id="ph1">&lt;see cref="T:System.Reflection.FieldInfo" /&gt;</ph> object representing the field that is identified by the specified metadata token.</source>
          <target state="translated">Um objeto <ph id="ph1">&lt;see cref="T:System.Reflection.FieldInfo" /&gt;</ph> que representa o campo que é identificado pelo token de metadados especificado.</target>       </trans-unit>
        <trans-unit id="382" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.ResolveField(System.Int32,System.Type[],System.Type[])">
          <source>Use the <ph id="ph1">&lt;xref:System.Type.GetGenericArguments%2A?displayProperty=nameWithType&gt;</ph> method on the type where <ph id="ph2">`metadataToken`</ph> is in scope to obtain an array of generic type arguments for <ph id="ph3">`genericTypeArguments`</ph>.</source>
          <target state="translated">Use o <ph id="ph1">&lt;xref:System.Type.GetGenericArguments%2A?displayProperty=nameWithType&gt;</ph> método do tipo onde <ph id="ph2">`metadataToken`</ph> está no escopo para obter uma matriz de argumentos de tipo genérico para <ph id="ph3">`genericTypeArguments`</ph>.</target>       </trans-unit>
        <trans-unit id="383" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.ResolveField(System.Int32,System.Type[],System.Type[])">
          <source>Use the <ph id="ph1">&lt;xref:System.Reflection.MethodInfo.GetGenericArguments%2A?displayProperty=nameWithType&gt;</ph> method on the method where <ph id="ph2">`metadataToken`</ph> is in scope to obtain an array of generic type arguments for <ph id="ph3">`genericTypeArguments`</ph>.</source>
          <target state="translated">Use o <ph id="ph1">&lt;xref:System.Reflection.MethodInfo.GetGenericArguments%2A?displayProperty=nameWithType&gt;</ph> método no método onde <ph id="ph2">`metadataToken`</ph> está no escopo para obter uma matriz de argumentos de tipo genérico para <ph id="ph3">`genericTypeArguments`</ph>.</target>       </trans-unit>
        <trans-unit id="384" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.ResolveField(System.Int32,System.Type[],System.Type[])">
          <source>It is always safe to provide these arguments, even when they are not needed.</source>
          <target state="translated">É sempre seguro fornecer esses argumentos, mesmo quando eles não são necessários.</target>       </trans-unit>
        <trans-unit id="385" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.ResolveField(System.Int32,System.Type[],System.Type[])">
          <source>Information about metadata tokens can be found in the Common Language Infrastructure (CLI) documentation, especially "Partition II: Metadata Definition and Semantics".</source>
          <target state="translated">Informações sobre tokens de metadados podem ser encontradas na documentação do Common Language Infrastructure (CLI), especialmente "partição II: metadados definição e semântica".</target>       </trans-unit>
        <trans-unit id="386" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.ResolveField(System.Int32,System.Type[],System.Type[])">
          <source>The documentation is available online; see <bpt id="p1">[</bpt>ECMA C# and Common Language Infrastructure Standards<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=99212)</ept> on MSDN and <bpt id="p2">[</bpt>Standard ECMA-335 - Common Language Infrastructure (CLI)<ept id="p2">](http://go.microsoft.com/fwlink/?LinkID=65552)</ept> on the ECMA Web site.</source>
          <target state="translated">A documentação está disponível online; consulte <bpt id="p1">[</bpt>ECMA para c# e padrões de infra-estrutura de linguagem comum<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=99212)</ept> no MSDN e <bpt id="p2">[</bpt>padrão ECMA-335 - infraestrutura de linguagem comum (CLI)<ept id="p2">](http://go.microsoft.com/fwlink/?LinkID=65552)</ept> no site da Web de ECMA.</target>       </trans-unit>
        <trans-unit id="387" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.ResolveField(System.Int32,System.Type[],System.Type[])">
          <source>For code that demonstrates token resolution using the generic context (that is, the generic type parameters of the generic type and/or the generic method in which the token is embedded) see the <ph id="ph1">&lt;xref:System.Reflection.Module.ResolveMethod%28System.Int32%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%29&gt;</ph> method.</source>
          <target state="translated">Para o código que demonstra a resolução de token usando o contexto genérico (ou seja, os parâmetros de tipo genérico do tipo genérico e/ou o método genérico na qual o token é incorporado) consulte o <ph id="ph1">&lt;xref:System.Reflection.Module.ResolveMethod%28System.Int32%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%29&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="388" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.ResolveField(System.Int32,System.Type[],System.Type[])">
          <source><ph id="ph1">&lt;paramref name="metadataToken" /&gt;</ph> is not a token for a field in the scope of the current module.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="metadataToken" /&gt;</ph> não é um token para um campo no escopo do módulo atual.</target>       </trans-unit>
        <trans-unit id="389" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.ResolveField(System.Int32,System.Type[],System.Type[])">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="390" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.ResolveField(System.Int32,System.Type[],System.Type[])">
          <source><ph id="ph1">&lt;paramref name="metadataToken" /&gt;</ph> identifies a field whose parent <ph id="ph2">&lt;see langword="TypeSpec" /&gt;</ph> has a signature containing element type <ph id="ph3">&lt;see langword="var" /&gt;</ph> (a type parameter of a generic type) or <ph id="ph4">&lt;see langword="mvar" /&gt;</ph> (a type parameter of a generic method), and the necessary generic type arguments were not supplied for either or both of <ph id="ph5">&lt;paramref name="genericTypeArguments" /&gt;</ph> and <ph id="ph6">&lt;paramref name="genericMethodArguments" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="metadataToken" /&gt;</ph> identifica um campo cujo <ph id="ph2">&lt;see langword="TypeSpec" /&gt;</ph> pai tem uma assinatura que contém o tipo de elemento <ph id="ph3">&lt;see langword="var" /&gt;</ph> (um parâmetro de tipo de um tipo genérico) ou <ph id="ph4">&lt;see langword="mvar" /&gt;</ph> (um parâmetro de tipo de um método genérico) e os argumentos de tipo genérico necessários não foram fornecidos para <ph id="ph5">&lt;paramref name="genericTypeArguments" /&gt;</ph> ou <ph id="ph6">&lt;paramref name="genericMethodArguments" /&gt;</ph> ou ambos.</target>       </trans-unit>
        <trans-unit id="391" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.ResolveField(System.Int32,System.Type[],System.Type[])">
          <source><ph id="ph1">&lt;paramref name="metadataToken" /&gt;</ph> is not a valid token in the scope of the current module.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="metadataToken" /&gt;</ph> não é um token válido no escopo do módulo atual.</target>       </trans-unit>
        <trans-unit id="392" translate="yes" xml:space="preserve" uid="T:System.Reflection.Module">
          <source>Returns the type or member identified by a metadata token.</source>
          <target state="translated">Retorna o tipo ou o membro identificado por um token de metadados.</target>       </trans-unit>
        <trans-unit id="393" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.ResolveMember(System.Int32)">
          <source>A metadata token that identifies a type or member in the module.</source>
          <target state="translated">Um token de metadados que identifica um tipo ou membro no módulo.</target>       </trans-unit>
        <trans-unit id="394" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.ResolveMember(System.Int32)">
          <source>Returns the type or member identified by the specified metadata token.</source>
          <target state="translated">Retorna o tipo ou o membro identificado pelo token de metadados especificado.</target>       </trans-unit>
        <trans-unit id="395" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.ResolveMember(System.Int32)">
          <source>A <ph id="ph1">&lt;see cref="T:System.Reflection.MemberInfo" /&gt;</ph> object representing the type or member that is identified by the specified metadata token.</source>
          <target state="translated">Um objeto <ph id="ph1">&lt;see cref="T:System.Reflection.MemberInfo" /&gt;</ph> que representa o tipo ou o membro que é identificado pelo token de metadados especificado.</target>       </trans-unit>
        <trans-unit id="396" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.ResolveMember(System.Int32)">
          <source>To resolve a metadata token for a <ph id="ph1">`MethodSpec`</ph> or <ph id="ph2">`TypeSpec`</ph> whose signature contains element type <ph id="ph3">`ELEMENT_TYPE_VAR`</ph> or <ph id="ph4">`ELEMENT_TYPE_MVAR`</ph>, use the <ph id="ph5">&lt;xref:System.Reflection.Module.ResolveMember%28System.Int32%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%29&gt;</ph> method overload, which allows you to supply the necessary context.</source>
          <target state="translated">Para resolver um token de metadados para um <ph id="ph1">`MethodSpec`</ph> ou <ph id="ph2">`TypeSpec`</ph> cuja assinatura contém o tipo de elemento <ph id="ph3">`ELEMENT_TYPE_VAR`</ph> ou <ph id="ph4">`ELEMENT_TYPE_MVAR`</ph>, use o <ph id="ph5">&lt;xref:System.Reflection.Module.ResolveMember%28System.Int32%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%29&gt;</ph> sobrecarga de método, o que permite que você fornecer o contexto necessário.</target>       </trans-unit>
        <trans-unit id="397" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.ResolveMember(System.Int32)">
          <source>That is, when you are resolving a metadata token for a member that depends on the generic type parameters of the generic type and/or the generic method in which the token is embedded, you must use the overload that allows you to supply those type parameters.</source>
          <target state="translated">Ou seja, quando você está resolvendo um token de metadados para um membro que depende dos parâmetros de tipo genérico do tipo genérico e/ou o método genérico no qual o token é inserido, você deve usar a sobrecarga que permite que você forneça os parâmetros de tipo.</target>       </trans-unit>
        <trans-unit id="398" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.ResolveMember(System.Int32)">
          <source>Information about metadata tokens can be found in the Common Language Infrastructure (CLI) documentation, especially "Partition II: Metadata Definition and Semantics".</source>
          <target state="translated">Informações sobre tokens de metadados podem ser encontradas na documentação do Common Language Infrastructure (CLI), especialmente "partição II: metadados definição e semântica".</target>       </trans-unit>
        <trans-unit id="399" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.ResolveMember(System.Int32)">
          <source>The documentation is available online; see <bpt id="p1">[</bpt>ECMA C# and Common Language Infrastructure Standards<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=99212)</ept> on MSDN and <bpt id="p2">[</bpt>Standard ECMA-335 - Common Language Infrastructure (CLI)<ept id="p2">](http://go.microsoft.com/fwlink/?LinkID=65552)</ept> on the ECMA Web site.</source>
          <target state="translated">A documentação está disponível online; consulte <bpt id="p1">[</bpt>ECMA para c# e padrões de infra-estrutura de linguagem comum<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=99212)</ept> no MSDN e <bpt id="p2">[</bpt>padrão ECMA-335 - infraestrutura de linguagem comum (CLI)<ept id="p2">](http://go.microsoft.com/fwlink/?LinkID=65552)</ept> no site da Web de ECMA.</target>       </trans-unit>
        <trans-unit id="400" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.ResolveMember(System.Int32)">
          <source>For code that demonstrates token resolution using the generic context (that is, the generic type parameters of the generic type and/or the generic method in which the token is embedded) see the <ph id="ph1">&lt;xref:System.Reflection.Module.ResolveMethod%28System.Int32%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%29&gt;</ph> method.</source>
          <target state="translated">Para o código que demonstra a resolução de token usando o contexto genérico (ou seja, os parâmetros de tipo genérico do tipo genérico e/ou o método genérico na qual o token é incorporado) consulte o <ph id="ph1">&lt;xref:System.Reflection.Module.ResolveMethod%28System.Int32%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%29&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="401" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.ResolveMember(System.Int32)">
          <source><ph id="ph1">&lt;paramref name="metadataToken" /&gt;</ph> is not a token for a type or member in the scope of the current module.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="metadataToken" /&gt;</ph> não é um token para um tipo ou membro no escopo do módulo atual.</target>       </trans-unit>
        <trans-unit id="402" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.ResolveMember(System.Int32)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="403" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.ResolveMember(System.Int32)">
          <source><ph id="ph1">&lt;paramref name="metadataToken" /&gt;</ph> is a <ph id="ph2">&lt;see langword="MethodSpec" /&gt;</ph> or <ph id="ph3">&lt;see langword="TypeSpec" /&gt;</ph> whose signature contains element type <ph id="ph4">&lt;see langword="var" /&gt;</ph> (a type parameter of a generic type) or <ph id="ph5">&lt;see langword="mvar" /&gt;</ph> (a type parameter of a generic method).</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="metadataToken" /&gt;</ph> é um <ph id="ph2">&lt;see langword="MethodSpec" /&gt;</ph> ou <ph id="ph3">&lt;see langword="TypeSpec" /&gt;</ph> cuja assinatura contém o tipo de elemento <ph id="ph4">&lt;see langword="var" /&gt;</ph> (um parâmetro de tipo de um tipo genérico) ou <ph id="ph5">&lt;see langword="mvar" /&gt;</ph> (um parâmetro de tipo de um método genérico).</target>       </trans-unit>
        <trans-unit id="404" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.ResolveMember(System.Int32)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="405" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.ResolveMember(System.Int32)">
          <source><ph id="ph1">&lt;paramref name="metadataToken" /&gt;</ph> identifies a property or event.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="metadataToken" /&gt;</ph> identifica uma propriedade ou evento.</target>       </trans-unit>
        <trans-unit id="406" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.ResolveMember(System.Int32)">
          <source><ph id="ph1">&lt;paramref name="metadataToken" /&gt;</ph> is not a valid token in the scope of the current module.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="metadataToken" /&gt;</ph> não é um token válido no escopo do módulo atual.</target>       </trans-unit>
        <trans-unit id="407" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.ResolveMember(System.Int32,System.Type[],System.Type[])">
          <source>A metadata token that identifies a type or member in the module.</source>
          <target state="translated">Um token de metadados que identifica um tipo ou membro no módulo.</target>       </trans-unit>
        <trans-unit id="408" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.ResolveMember(System.Int32,System.Type[],System.Type[])">
          <source>An array of <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> objects representing the generic type arguments of the type where the token is in scope, or <ph id="ph2">&lt;see langword="null" /&gt;</ph> if that type is not generic.</source>
          <target state="translated">Uma matriz de objetos <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> que representam os argumentos de tipo genérico do tipo em que o token está no escopo ou <ph id="ph2">&lt;see langword="null" /&gt;</ph> se esse tipo não for genérico.</target>       </trans-unit>
        <trans-unit id="409" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.ResolveMember(System.Int32,System.Type[],System.Type[])">
          <source>An array of <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> objects representing the generic type arguments of the method where the token is in scope, or <ph id="ph2">&lt;see langword="null" /&gt;</ph> if that method is not generic.</source>
          <target state="translated">Uma matriz de objetos <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> que representam os argumentos de tipo genérico do método em que o token está no escopo ou <ph id="ph2">&lt;see langword="null" /&gt;</ph> se esse método não for genérico.</target>       </trans-unit>
        <trans-unit id="410" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.ResolveMember(System.Int32,System.Type[],System.Type[])">
          <source>Returns the type or member identified by the specified metadata token, in the context defined by the specified generic type parameters.</source>
          <target state="translated">Retorna o tipo ou o membro identificado pelo token de metadados especificado, no contexto definido pelos parâmetros de tipo genérico especificados.</target>       </trans-unit>
        <trans-unit id="411" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.ResolveMember(System.Int32,System.Type[],System.Type[])">
          <source>A <ph id="ph1">&lt;see cref="T:System.Reflection.MemberInfo" /&gt;</ph> object representing the type or member that is identified by the specified metadata token.</source>
          <target state="translated">Um objeto <ph id="ph1">&lt;see cref="T:System.Reflection.MemberInfo" /&gt;</ph> que representa o tipo ou o membro que é identificado pelo token de metadados especificado.</target>       </trans-unit>
        <trans-unit id="412" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.ResolveMember(System.Int32,System.Type[],System.Type[])">
          <source>Use the <ph id="ph1">&lt;xref:System.Type.GetGenericArguments%2A?displayProperty=nameWithType&gt;</ph> method on the type where <ph id="ph2">`metadataToken`</ph> is in scope to obtain an array of generic type arguments for <ph id="ph3">`genericTypeArguments`</ph>.</source>
          <target state="translated">Use o <ph id="ph1">&lt;xref:System.Type.GetGenericArguments%2A?displayProperty=nameWithType&gt;</ph> método do tipo onde <ph id="ph2">`metadataToken`</ph> está no escopo para obter uma matriz de argumentos de tipo genérico para <ph id="ph3">`genericTypeArguments`</ph>.</target>       </trans-unit>
        <trans-unit id="413" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.ResolveMember(System.Int32,System.Type[],System.Type[])">
          <source>Use the <ph id="ph1">&lt;xref:System.Reflection.MethodInfo.GetGenericArguments%2A?displayProperty=nameWithType&gt;</ph> method on the method where <ph id="ph2">`metadataToken`</ph> is in scope to obtain an array of generic type arguments for <ph id="ph3">`genericTypeArguments`</ph>.</source>
          <target state="translated">Use o <ph id="ph1">&lt;xref:System.Reflection.MethodInfo.GetGenericArguments%2A?displayProperty=nameWithType&gt;</ph> método no método onde <ph id="ph2">`metadataToken`</ph> está no escopo para obter uma matriz de argumentos de tipo genérico para <ph id="ph3">`genericTypeArguments`</ph>.</target>       </trans-unit>
        <trans-unit id="414" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.ResolveMember(System.Int32,System.Type[],System.Type[])">
          <source>It is always safe to provide these arguments, even when they are not needed.</source>
          <target state="translated">É sempre seguro fornecer esses argumentos, mesmo quando eles não são necessários.</target>       </trans-unit>
        <trans-unit id="415" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.ResolveMember(System.Int32,System.Type[],System.Type[])">
          <source>Information about metadata tokens can be found in the Common Language Infrastructure (CLI) documentation, especially "Partition II: Metadata Definition and Semantics".</source>
          <target state="translated">Informações sobre tokens de metadados podem ser encontradas na documentação do Common Language Infrastructure (CLI), especialmente "partição II: metadados definição e semântica".</target>       </trans-unit>
        <trans-unit id="416" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.ResolveMember(System.Int32,System.Type[],System.Type[])">
          <source>The documentation is available online; see <bpt id="p1">[</bpt>ECMA C# and Common Language Infrastructure Standards<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=99212)</ept> on MSDN and <bpt id="p2">[</bpt>Standard ECMA-335 - Common Language Infrastructure (CLI)<ept id="p2">](http://go.microsoft.com/fwlink/?LinkID=65552)</ept> on the ECMA Web site.</source>
          <target state="translated">A documentação está disponível online; consulte <bpt id="p1">[</bpt>ECMA para c# e padrões de infra-estrutura de linguagem comum<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=99212)</ept> no MSDN e <bpt id="p2">[</bpt>padrão ECMA-335 - infraestrutura de linguagem comum (CLI)<ept id="p2">](http://go.microsoft.com/fwlink/?LinkID=65552)</ept> no site da Web de ECMA.</target>       </trans-unit>
        <trans-unit id="417" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.ResolveMember(System.Int32,System.Type[],System.Type[])">
          <source>For code that demonstrates token resolution using the generic context (that is, the generic type parameters of the generic type and/or the generic method in which the token is embedded) see the <ph id="ph1">&lt;xref:System.Reflection.Module.ResolveMethod%28System.Int32%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%29&gt;</ph> method.</source>
          <target state="translated">Para o código que demonstra a resolução de token usando o contexto genérico (ou seja, os parâmetros de tipo genérico do tipo genérico e/ou o método genérico na qual o token é incorporado) consulte o <ph id="ph1">&lt;xref:System.Reflection.Module.ResolveMethod%28System.Int32%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%29&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="418" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.ResolveMember(System.Int32,System.Type[],System.Type[])">
          <source><ph id="ph1">&lt;paramref name="metadataToken" /&gt;</ph> is not a token for a type or member in the scope of the current module.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="metadataToken" /&gt;</ph> não é um token para um tipo ou membro no escopo do módulo atual.</target>       </trans-unit>
        <trans-unit id="419" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.ResolveMember(System.Int32,System.Type[],System.Type[])">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="420" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.ResolveMember(System.Int32,System.Type[],System.Type[])">
          <source><ph id="ph1">&lt;paramref name="metadataToken" /&gt;</ph> is a <ph id="ph2">&lt;see langword="MethodSpec" /&gt;</ph> or <ph id="ph3">&lt;see langword="TypeSpec" /&gt;</ph> whose signature contains element type <ph id="ph4">&lt;see langword="var" /&gt;</ph> (a type parameter of a generic type) or <ph id="ph5">&lt;see langword="mvar" /&gt;</ph> (a type parameter of a generic method), and the necessary generic type arguments were not supplied for either or both of <ph id="ph6">&lt;paramref name="genericTypeArguments" /&gt;</ph> and <ph id="ph7">&lt;paramref name="genericMethodArguments" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="metadataToken" /&gt;</ph> é um <ph id="ph2">&lt;see langword="MethodSpec" /&gt;</ph> ou <ph id="ph3">&lt;see langword="TypeSpec" /&gt;</ph> cuja assinatura contém o tipo de elemento <ph id="ph4">&lt;see langword="var" /&gt;</ph> (um parâmetro de tipo de um tipo genérico) ou <ph id="ph5">&lt;see langword="mvar" /&gt;</ph> (um parâmetro de tipo de um método genérico) e os argumentos de tipo genérico necessários não foram fornecidos para <ph id="ph6">&lt;paramref name="genericTypeArguments" /&gt;</ph> ou <ph id="ph7">&lt;paramref name="genericMethodArguments" /&gt;</ph> ou ambos.</target>       </trans-unit>
        <trans-unit id="421" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.ResolveMember(System.Int32,System.Type[],System.Type[])">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="422" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.ResolveMember(System.Int32,System.Type[],System.Type[])">
          <source><ph id="ph1">&lt;paramref name="metadataToken" /&gt;</ph> identifies a property or event.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="metadataToken" /&gt;</ph> identifica uma propriedade ou evento.</target>       </trans-unit>
        <trans-unit id="423" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.ResolveMember(System.Int32,System.Type[],System.Type[])">
          <source><ph id="ph1">&lt;paramref name="metadataToken" /&gt;</ph> is not a valid token in the scope of the current module.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="metadataToken" /&gt;</ph> não é um token válido no escopo do módulo atual.</target>       </trans-unit>
        <trans-unit id="424" translate="yes" xml:space="preserve" uid="T:System.Reflection.Module">
          <source>Returns the method identified by a metadata token.</source>
          <target state="translated">Retorna o método identificado por um token de metadados.</target>       </trans-unit>
        <trans-unit id="425" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.ResolveMethod(System.Int32)">
          <source>A metadata token that identifies a method or constructor in the module.</source>
          <target state="translated">Um token de metadados que identifica um método ou um construtor no módulo.</target>       </trans-unit>
        <trans-unit id="426" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.ResolveMethod(System.Int32)">
          <source>Returns the method or constructor identified by the specified metadata token.</source>
          <target state="translated">Retorna o método ou o construtor identificado pelo token de metadados especificado.</target>       </trans-unit>
        <trans-unit id="427" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.ResolveMethod(System.Int32)">
          <source>A <ph id="ph1">&lt;see cref="T:System.Reflection.MethodBase" /&gt;</ph> object representing the method or constructor that is identified by the specified metadata token.</source>
          <target state="translated">Um objeto <ph id="ph1">&lt;see cref="T:System.Reflection.MethodBase" /&gt;</ph> que representa o método ou construtor identificado pelo token de metadados especificado.</target>       </trans-unit>
        <trans-unit id="428" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.ResolveMethod(System.Int32)">
          <source>To resolve a metadata token for a <ph id="ph1">`MethodSpec`</ph> whose signature contains element type <ph id="ph2">`ELEMENT_TYPE_VAR`</ph> or <ph id="ph3">`ELEMENT_TYPE_MVAR`</ph>, use the <ph id="ph4">&lt;xref:System.Reflection.Module.ResolveMethod%28System.Int32%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%29&gt;</ph> method overload, which allows you to supply the necessary context.</source>
          <target state="translated">Para resolver um token de metadados para um <ph id="ph1">`MethodSpec`</ph> cuja assinatura contém o tipo de elemento <ph id="ph2">`ELEMENT_TYPE_VAR`</ph> ou <ph id="ph3">`ELEMENT_TYPE_MVAR`</ph>, use o <ph id="ph4">&lt;xref:System.Reflection.Module.ResolveMethod%28System.Int32%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%29&gt;</ph> sobrecarga de método, o que permite que você fornecer o contexto necessário.</target>       </trans-unit>
        <trans-unit id="429" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.ResolveMethod(System.Int32)">
          <source>That is, when you are resolving a metadata token for a method that depends on the generic type parameters of the generic type and/or the generic method in which the token is embedded, you must use the overload that allows you to supply those type parameters.</source>
          <target state="translated">Ou seja, quando você está resolvendo um token de metadados para um método que depende dos parâmetros de tipo genérico do tipo genérico e/ou o método genérico no qual o token é inserido, você deve usar a sobrecarga que permite que você forneça os parâmetros de tipo.</target>       </trans-unit>
        <trans-unit id="430" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.ResolveMethod(System.Int32)">
          <source>Information about metadata tokens can be found in the Common Language Infrastructure (CLI) documentation, especially "Partition II: Metadata Definition and Semantics".</source>
          <target state="translated">Informações sobre tokens de metadados podem ser encontradas na documentação do Common Language Infrastructure (CLI), especialmente "partição II: metadados definição e semântica".</target>       </trans-unit>
        <trans-unit id="431" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.ResolveMethod(System.Int32)">
          <source>The documentation is available online; see <bpt id="p1">[</bpt>ECMA C# and Common Language Infrastructure Standards<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=99212)</ept> on MSDN and <bpt id="p2">[</bpt>Standard ECMA-335 - Common Language Infrastructure (CLI)<ept id="p2">](http://go.microsoft.com/fwlink/?LinkID=65552)</ept> on the ECMA Web site.</source>
          <target state="translated">A documentação está disponível online; consulte <bpt id="p1">[</bpt>ECMA para c# e padrões de infra-estrutura de linguagem comum<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=99212)</ept> no MSDN e <bpt id="p2">[</bpt>padrão ECMA-335 - infraestrutura de linguagem comum (CLI)<ept id="p2">](http://go.microsoft.com/fwlink/?LinkID=65552)</ept> no site da Web de ECMA.</target>       </trans-unit>
        <trans-unit id="432" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.ResolveMethod(System.Int32)">
          <source>The following example shows how to use the two overloads of the <ph id="ph1">&lt;xref:System.Reflection.Module.ResolveMethod%2A&gt;</ph> method to resolve metadata tokens from call sites in generic and non-generic contexts.</source>
          <target state="translated">O exemplo a seguir mostra como usar as duas sobrecargas do <ph id="ph1">&lt;xref:System.Reflection.Module.ResolveMethod%2A&gt;</ph> método para resolver os tokens de metadados de chamada de sites não genéricos e contextos.</target>       </trans-unit>
        <trans-unit id="433" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.ResolveMethod(System.Int32)">
          <source>The code example defines two generic types, <ph id="ph1">`G1&lt;Tg1&gt;`</ph> and <ph id="ph2">`G2&lt;Tg2&gt;`</ph> (<ph id="ph3">`G1(Of Tg1)`</ph> and <ph id="ph4">`G2(Of Tg2)`</ph> in Visual Basic), each of which has a generic method.</source>
          <target state="translated">O exemplo de código define dois tipos genéricos, <ph id="ph1">`G1&lt;Tg1&gt;`</ph> e <ph id="ph2">`G2&lt;Tg2&gt;`</ph> (<ph id="ph3">`G1(Of Tg1)`</ph> e <ph id="ph4">`G2(Of Tg2)`</ph> no Visual Basic), cada qual com um método genérico.</target>       </trans-unit>
        <trans-unit id="434" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.ResolveMethod(System.Int32)">
          <source><ph id="ph1">`G1&lt;Tg1&gt;`</ph> also has a non-generic method that uses the type parameter <ph id="ph2">`Tg1`</ph> for its parameter.</source>
          <target state="translated"><ph id="ph1">`G1&lt;Tg1&gt;`</ph> também tem um método não genérico que usa o parâmetro de tipo <ph id="ph2">`Tg1`</ph> como parâmetro.</target>       </trans-unit>
        <trans-unit id="435" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.ResolveMethod(System.Int32)">
          <source>The generic method <ph id="ph1">`GM2&lt;Tgm2&gt;`</ph> in type <ph id="ph2">`G2&lt;Tg2&gt;`</ph> contains several method calls:</source>
          <target state="translated">O método genérico <ph id="ph1">`GM2&lt;Tgm2&gt;`</ph> no tipo <ph id="ph2">`G2&lt;Tg2&gt;`</ph> contém várias chamadas de método:</target>       </trans-unit>
        <trans-unit id="436" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.ResolveMethod(System.Int32)">
          <source>Case 1: The generic method <ph id="ph1">`GM1&lt;Tgm1&gt;`</ph> is called, using the type parameters of <ph id="ph2">`G2&lt;Tg2&gt;`</ph> and <ph id="ph3">`GM2&lt;Tgm2&gt;`</ph> as the type arguments.</source>
          <target state="translated">Caso 1: O método genérico <ph id="ph1">`GM1&lt;Tgm1&gt;`</ph> é chamado, usando os parâmetros de tipo de <ph id="ph2">`G2&lt;Tg2&gt;`</ph> e <ph id="ph3">`GM2&lt;Tgm2&gt;`</ph> como argumentos de tipo.</target>       </trans-unit>
        <trans-unit id="437" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.ResolveMethod(System.Int32)">
          <source>In other words, the parameter types of the called method will depend on the types that are used to construct a closed generic type from the type definition for <ph id="ph1">`G2&lt;Tg2&gt;`</ph>.</source>
          <target state="translated">Em outras palavras, os tipos de parâmetro do método chamado dependerá de tipos que são usados para construir um tipo genérico fechado da definição de tipo para <ph id="ph1">`G2&lt;Tg2&gt;`</ph>.</target>       </trans-unit>
        <trans-unit id="438" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.ResolveMethod(System.Int32)">
          <source>Case 2: The non-generic method <ph id="ph1">`M1`</ph> is called.</source>
          <target state="translated">Caso 2: O método não genérico <ph id="ph1">`M1`</ph> é chamado.</target>       </trans-unit>
        <trans-unit id="439" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.ResolveMethod(System.Int32)">
          <source>The parameter of this method uses the type parameter of the defining type, <ph id="ph1">`G1&lt;Tg1&gt;`</ph>, which is replaced in this case by the type parameter of the enclosing type, <ph id="ph2">`G2&lt;Tg2&gt;`</ph>.</source>
          <target state="translated">O parâmetro deste método usa o parâmetro de tipo de definição de tipo, <ph id="ph1">`G1&lt;Tg1&gt;`</ph>, que é substituído nesse caso, o parâmetro de tipo do tipo delimitador, <ph id="ph2">`G2&lt;Tg2&gt;`</ph>.</target>       </trans-unit>
        <trans-unit id="440" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.ResolveMethod(System.Int32)">
          <source>Case 3: The generic method <ph id="ph1">`GM1&lt;Tgm1&gt;`</ph> is called, specifying <ph id="ph2">&lt;xref:System.Int32&gt;</ph> and <ph id="ph3">&lt;xref:System.Object&gt;</ph> for the type arguments of the generic type and the generic method, respectively.</source>
          <target state="translated">Caso 3: O método genérico <ph id="ph1">`GM1&lt;Tgm1&gt;`</ph> é chamado, especificando <ph id="ph2">&lt;xref:System.Int32&gt;</ph> e <ph id="ph3">&lt;xref:System.Object&gt;</ph> para os argumentos de tipo do tipo genérico e o método genérico, respectivamente.</target>       </trans-unit>
        <trans-unit id="441" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.ResolveMethod(System.Int32)">
          <source>This method call does not depend on the type parameters of the enclosing type or method.</source>
          <target state="translated">Esta chamada de método não depende dos parâmetros de tipo de método ou tipo de delimitador.</target>       </trans-unit>
        <trans-unit id="442" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.ResolveMethod(System.Int32)">
          <source>Case 4: The non-generic method <ph id="ph1">`M1`</ph> of the <ph id="ph2">`Example`</ph> class is called.</source>
          <target state="translated">Caso 4: O método não genérico <ph id="ph1">`M1`</ph> do <ph id="ph2">`Example`</ph> classe é chamada.</target>       </trans-unit>
        <trans-unit id="443" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.ResolveMethod(System.Int32)">
          <source>This method call does not depend on the type parameters of the enclosing type or method.</source>
          <target state="translated">Esta chamada de método não depende dos parâmetros de tipo de método ou tipo de delimitador.</target>       </trans-unit>
        <trans-unit id="444" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.ResolveMethod(System.Int32)">
          <source>In addition, the example defines the non-generic <ph id="ph1">`Example`</ph> class.</source>
          <target state="translated">Além disso, o exemplo define não genéricas <ph id="ph1">`Example`</ph> classe.</target>       </trans-unit>
        <trans-unit id="445" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.ResolveMethod(System.Int32)">
          <source>This class has a method <ph id="ph1">`M`</ph> that makes a call to a generic method:</source>
          <target state="translated">Essa classe tem um método <ph id="ph1">`M`</ph> que faz uma chamada para um método genérico:</target>       </trans-unit>
        <trans-unit id="446" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.ResolveMethod(System.Int32)">
          <source>Case 5: The generic method <ph id="ph1">`GM1`</ph> is called, specifying <ph id="ph2">&lt;xref:System.Int32&gt;</ph> and <ph id="ph3">&lt;xref:System.Object&gt;</ph> for the type arguments of the generic type and the generic method, respectively.</source>
          <target state="translated">Caso 5: O método genérico <ph id="ph1">`GM1`</ph> é chamado, especificando <ph id="ph2">&lt;xref:System.Int32&gt;</ph> e <ph id="ph3">&lt;xref:System.Object&gt;</ph> para os argumentos de tipo do tipo genérico e o método genérico, respectivamente.</target>       </trans-unit>
        <trans-unit id="447" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.ResolveMethod(System.Int32)">
          <source>The context for this method has no enclosing generic type or generic method.</source>
          <target state="translated">O contexto para esse método não tem nenhum delimitador tipo genérico ou método genérico.</target>       </trans-unit>
        <trans-unit id="448" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.ResolveMethod(System.Int32)">
          <source>For each case, the example first constructs a <ph id="ph1">&lt;xref:System.Reflection.MethodInfo&gt;</ph> that represents the called method, and then resolves the token using the <ph id="ph2">&lt;xref:System.Reflection.Module.ResolveMethod%28System.Int32%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%29&gt;</ph> method overload, using the <ph id="ph3">&lt;xref:System.Type.GetGenericArguments%2A?displayProperty=nameWithType&gt;</ph> and <ph id="ph4">&lt;xref:System.Reflection.MethodInfo.GetGenericArguments%2A?displayProperty=nameWithType&gt;</ph> methods to get the values for the <ph id="ph5">`genericTypeArguments`</ph> and <ph id="ph6">`genericMethodArguments`</ph> parameters.</source>
          <target state="translated">Para cada caso, o exemplo primeiro constrói um <ph id="ph1">&lt;xref:System.Reflection.MethodInfo&gt;</ph> que representa o método chamado e, em seguida, resolve o token usando o <ph id="ph2">&lt;xref:System.Reflection.Module.ResolveMethod%28System.Int32%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%29&gt;</ph> sobrecarga do método, usando o <ph id="ph3">&lt;xref:System.Type.GetGenericArguments%2A?displayProperty=nameWithType&gt;</ph> e <ph id="ph4">&lt;xref:System.Reflection.MethodInfo.GetGenericArguments%2A?displayProperty=nameWithType&gt;</ph> métodos para obter os valores para o <ph id="ph5">`genericTypeArguments`</ph> e <ph id="ph6">`genericMethodArguments`</ph> parâmetros.</target>       </trans-unit>
        <trans-unit id="449" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.ResolveMethod(System.Int32)">
          <source>This technique works in all cases, because the methods return <ph id="ph1">&lt;xref:System.Type.EmptyTypes?displayProperty=nameWithType&gt;</ph> for non-generic contexts.</source>
          <target state="translated">Essa técnica funciona em todos os casos, porque os métodos retornam <ph id="ph1">&lt;xref:System.Type.EmptyTypes?displayProperty=nameWithType&gt;</ph> para contextos não genérico.</target>       </trans-unit>
        <trans-unit id="450" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.ResolveMethod(System.Int32)">
          <source>The example compares the resolved <ph id="ph1">&lt;xref:System.Reflection.MethodInfo&gt;</ph> with the constructed <ph id="ph2">&lt;xref:System.Reflection.MethodInfo&gt;</ph>.</source>
          <target state="translated">O exemplo compara o resolvido <ph id="ph1">&lt;xref:System.Reflection.MethodInfo&gt;</ph> com o construído <ph id="ph2">&lt;xref:System.Reflection.MethodInfo&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="451" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.ResolveMethod(System.Int32)">
          <source>The example then attempts to use the <ph id="ph1">&lt;xref:System.Reflection.Module.ResolveMethod%28System.Int32%29&gt;</ph> method overload to resolve the token.</source>
          <target state="translated">O exemplo, em seguida, tenta usar o <ph id="ph1">&lt;xref:System.Reflection.Module.ResolveMethod%28System.Int32%29&gt;</ph> sobrecarga do método para resolver o token.</target>       </trans-unit>
        <trans-unit id="452" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.ResolveMethod(System.Int32)">
          <source>This works in cases 3, 4, and 5, because the method calls do not depend on the generic context.</source>
          <target state="translated">Isso funciona em casos 3, 4 e 5, porque as chamadas de método não dependem do contexto genérico.</target>       </trans-unit>
        <trans-unit id="453" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.ResolveMethod(System.Int32)">
          <source>In cases 1 and 2, an exception is thrown because there is insufficient information to resolve the token.</source>
          <target state="translated">Em casos 1 e 2, uma exceção é gerada porque não há informações suficientes para resolver o token.</target>       </trans-unit>
        <trans-unit id="454" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.ResolveMethod(System.Int32)">
          <source>The metadata token values are hard-coded as an enumeration.</source>
          <target state="translated">Os valores do token de metadados são codificados como uma enumeração.</target>       </trans-unit>
        <trans-unit id="455" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.ResolveMethod(System.Int32)">
          <source>If you change this code example, the token values are likely to change.</source>
          <target state="translated">Se você alterar este exemplo de código, os valores do token são provavelmente será alterado.</target>       </trans-unit>
        <trans-unit id="456" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.ResolveMethod(System.Int32)">
          <source>To determine the new token values, compile the code and use Ildasm.exe with the <bpt id="p1">**</bpt>/TOKENS<ept id="p1">**</ept> option to examine the assembly.</source>
          <target state="translated">Para determinar os novos valores de token, compile o código e usar Ildasm.exe com o <bpt id="p1">**</bpt>/TOKENS<ept id="p1">**</ept> opção para examinar o assembly.</target>       </trans-unit>
        <trans-unit id="457" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.ResolveMethod(System.Int32)">
          <source>The tokens can be found at the points of call.</source>
          <target state="translated">Os tokens podem ser encontrados nos pontos de chamada.</target>       </trans-unit>
        <trans-unit id="458" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.ResolveMethod(System.Int32)">
          <source>Insert the new values into the enumeration, and recompile the example.</source>
          <target state="translated">Insira os novos valores na enumeração e recompilar o exemplo.</target>       </trans-unit>
        <trans-unit id="459" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.ResolveMethod(System.Int32)">
          <source><ph id="ph1">&lt;paramref name="metadataToken" /&gt;</ph> is not a token for a method or constructor in the scope of the current module.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="metadataToken" /&gt;</ph> não é um token de um método ou construtor no escopo do módulo atual.</target>       </trans-unit>
        <trans-unit id="460" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.ResolveMethod(System.Int32)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="461" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.ResolveMethod(System.Int32)">
          <source><ph id="ph1">&lt;paramref name="metadataToken" /&gt;</ph> is a <ph id="ph2">&lt;see langword="MethodSpec" /&gt;</ph> whose signature contains element type <ph id="ph3">&lt;see langword="var" /&gt;</ph> (a type parameter of a generic type) or <ph id="ph4">&lt;see langword="mvar" /&gt;</ph> (a type parameter of a generic method).</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="metadataToken" /&gt;</ph> é um <ph id="ph2">&lt;see langword="MethodSpec" /&gt;</ph> cuja assinatura contém o tipo de elemento <ph id="ph3">&lt;see langword="var" /&gt;</ph> (um parâmetro de tipo de um tipo genérico) ou <ph id="ph4">&lt;see langword="mvar" /&gt;</ph> (um parâmetro de tipo de um método genérico).</target>       </trans-unit>
        <trans-unit id="462" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.ResolveMethod(System.Int32)">
          <source><ph id="ph1">&lt;paramref name="metadataToken" /&gt;</ph> is not a valid token in the scope of the current module.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="metadataToken" /&gt;</ph> não é um token válido no escopo do módulo atual.</target>       </trans-unit>
        <trans-unit id="463" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.ResolveMethod(System.Int32,System.Type[],System.Type[])">
          <source>A metadata token that identifies a method or constructor in the module.</source>
          <target state="translated">Um token de metadados que identifica um método ou um construtor no módulo.</target>       </trans-unit>
        <trans-unit id="464" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.ResolveMethod(System.Int32,System.Type[],System.Type[])">
          <source>An array of <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> objects representing the generic type arguments of the type where the token is in scope, or <ph id="ph2">&lt;see langword="null" /&gt;</ph> if that type is not generic.</source>
          <target state="translated">Uma matriz de objetos <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> que representam os argumentos de tipo genérico do tipo em que o token está no escopo ou <ph id="ph2">&lt;see langword="null" /&gt;</ph> se esse tipo não for genérico.</target>       </trans-unit>
        <trans-unit id="465" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.ResolveMethod(System.Int32,System.Type[],System.Type[])">
          <source>An array of <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> objects representing the generic type arguments of the method where the token is in scope, or <ph id="ph2">&lt;see langword="null" /&gt;</ph> if that method is not generic.</source>
          <target state="translated">Uma matriz de objetos <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> que representam os argumentos de tipo genérico do método em que o token está no escopo ou <ph id="ph2">&lt;see langword="null" /&gt;</ph> se esse método não for genérico.</target>       </trans-unit>
        <trans-unit id="466" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.ResolveMethod(System.Int32,System.Type[],System.Type[])">
          <source>Returns the method or constructor identified by the specified metadata token, in the context defined by the specified generic type parameters.</source>
          <target state="translated">Retorna o método ou o construtor identificado pelo token de metadados especificado, no contexto definido pelos parâmetros de tipo genérico especificados.</target>       </trans-unit>
        <trans-unit id="467" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.ResolveMethod(System.Int32,System.Type[],System.Type[])">
          <source>A <ph id="ph1">&lt;see cref="T:System.Reflection.MethodBase" /&gt;</ph> object representing the method that is identified by the specified metadata token.</source>
          <target state="translated">Um objeto <ph id="ph1">&lt;see cref="T:System.Reflection.MethodBase" /&gt;</ph> que representa o método que é identificado pelo token de metadados especificado.</target>       </trans-unit>
        <trans-unit id="468" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.ResolveMethod(System.Int32,System.Type[],System.Type[])">
          <source>Use the <ph id="ph1">&lt;xref:System.Type.GetGenericArguments%2A?displayProperty=nameWithType&gt;</ph> method on the type where <ph id="ph2">`metadataToken`</ph> is in scope to obtain an array of generic type arguments for <ph id="ph3">`genericTypeArguments`</ph>.</source>
          <target state="translated">Use o <ph id="ph1">&lt;xref:System.Type.GetGenericArguments%2A?displayProperty=nameWithType&gt;</ph> método do tipo onde <ph id="ph2">`metadataToken`</ph> está no escopo para obter uma matriz de argumentos de tipo genérico para <ph id="ph3">`genericTypeArguments`</ph>.</target>       </trans-unit>
        <trans-unit id="469" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.ResolveMethod(System.Int32,System.Type[],System.Type[])">
          <source>Use the <ph id="ph1">&lt;xref:System.Reflection.MethodInfo.GetGenericArguments%2A?displayProperty=nameWithType&gt;</ph> method on the method where <ph id="ph2">`metadataToken`</ph> is in scope to obtain an array of generic type arguments for <ph id="ph3">`genericMethodArguments`</ph>.</source>
          <target state="translated">Use o <ph id="ph1">&lt;xref:System.Reflection.MethodInfo.GetGenericArguments%2A?displayProperty=nameWithType&gt;</ph> método no método onde <ph id="ph2">`metadataToken`</ph> está no escopo para obter uma matriz de argumentos de tipo genérico para <ph id="ph3">`genericMethodArguments`</ph>.</target>       </trans-unit>
        <trans-unit id="470" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.ResolveMethod(System.Int32,System.Type[],System.Type[])">
          <source>It is always safe to provide these arguments, even when they are not needed.</source>
          <target state="translated">É sempre seguro fornecer esses argumentos, mesmo quando eles não são necessários.</target>       </trans-unit>
        <trans-unit id="471" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.ResolveMethod(System.Int32,System.Type[],System.Type[])">
          <source>Information about metadata tokens can be found in the Common Language Infrastructure (CLI) documentation, especially "Partition II: Metadata Definition and Semantics".</source>
          <target state="translated">Informações sobre tokens de metadados podem ser encontradas na documentação do Common Language Infrastructure (CLI), especialmente "partição II: metadados definição e semântica".</target>       </trans-unit>
        <trans-unit id="472" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.ResolveMethod(System.Int32,System.Type[],System.Type[])">
          <source>The documentation is available online; see <bpt id="p1">[</bpt>ECMA C# and Common Language Infrastructure Standards<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=99212)</ept> on MSDN and <bpt id="p2">[</bpt>Standard ECMA-335 - Common Language Infrastructure (CLI)<ept id="p2">](http://go.microsoft.com/fwlink/?LinkID=65552)</ept> on the ECMA Web site.</source>
          <target state="translated">A documentação está disponível online; consulte <bpt id="p1">[</bpt>ECMA para c# e padrões de infra-estrutura de linguagem comum<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=99212)</ept> no MSDN e <bpt id="p2">[</bpt>padrão ECMA-335 - infraestrutura de linguagem comum (CLI)<ept id="p2">](http://go.microsoft.com/fwlink/?LinkID=65552)</ept> no site da Web de ECMA.</target>       </trans-unit>
        <trans-unit id="473" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.ResolveMethod(System.Int32,System.Type[],System.Type[])">
          <source>The following example shows how to use the two overloads of the <ph id="ph1">&lt;xref:System.Reflection.Module.ResolveMethod%2A&gt;</ph> method to resolve metadata tokens from call sites in generic and non-generic contexts.</source>
          <target state="translated">O exemplo a seguir mostra como usar as duas sobrecargas do <ph id="ph1">&lt;xref:System.Reflection.Module.ResolveMethod%2A&gt;</ph> método para resolver os tokens de metadados de chamada de sites não genéricos e contextos.</target>       </trans-unit>
        <trans-unit id="474" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.ResolveMethod(System.Int32,System.Type[],System.Type[])">
          <source>The code example defines two generic types, <ph id="ph1">`G1&lt;Tg1&gt;`</ph> and <ph id="ph2">`G2&lt;Tg2&gt;`</ph>, each of which has a generic method.</source>
          <target state="translated">O exemplo de código define dois tipos genéricos, <ph id="ph1">`G1&lt;Tg1&gt;`</ph> e <ph id="ph2">`G2&lt;Tg2&gt;`</ph>, cada um deles tem um método genérico.</target>       </trans-unit>
        <trans-unit id="475" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.ResolveMethod(System.Int32,System.Type[],System.Type[])">
          <source><ph id="ph1">`G1&lt;Tg1&gt;`</ph> also has a non-generic method that uses the type parameter <ph id="ph2">`Tg1`</ph> for its parameter.</source>
          <target state="translated"><ph id="ph1">`G1&lt;Tg1&gt;`</ph> também tem um método não genérico que usa o parâmetro de tipo <ph id="ph2">`Tg1`</ph> como parâmetro.</target>       </trans-unit>
        <trans-unit id="476" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.ResolveMethod(System.Int32,System.Type[],System.Type[])">
          <source>The generic method <ph id="ph1">`GM2&lt;Tgm2&gt;`</ph> in type <ph id="ph2">`G2&lt;Tg2&gt;`</ph> contains several method calls:</source>
          <target state="translated">O método genérico <ph id="ph1">`GM2&lt;Tgm2&gt;`</ph> no tipo <ph id="ph2">`G2&lt;Tg2&gt;`</ph> contém várias chamadas de método:</target>       </trans-unit>
        <trans-unit id="477" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.ResolveMethod(System.Int32,System.Type[],System.Type[])">
          <source>Case 1: The generic method <ph id="ph1">`GM1&lt;Tgm1&gt;`</ph> is called, using the type parameters of <ph id="ph2">`G2&lt;Tg2&gt;`</ph> and <ph id="ph3">`GM2&lt;Tgm2&gt;`</ph> as the type arguments.</source>
          <target state="translated">Caso 1: O método genérico <ph id="ph1">`GM1&lt;Tgm1&gt;`</ph> é chamado, usando os parâmetros de tipo de <ph id="ph2">`G2&lt;Tg2&gt;`</ph> e <ph id="ph3">`GM2&lt;Tgm2&gt;`</ph> como argumentos de tipo.</target>       </trans-unit>
        <trans-unit id="478" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.ResolveMethod(System.Int32,System.Type[],System.Type[])">
          <source>In other words, the parameter types of the called method will depend on the types that are used to construct a closed generic type from the type definition for <ph id="ph1">`G2&lt;Tg2&gt;`</ph>.</source>
          <target state="translated">Em outras palavras, os tipos de parâmetro do método chamado dependerá de tipos que são usados para construir um tipo genérico fechado da definição de tipo para <ph id="ph1">`G2&lt;Tg2&gt;`</ph>.</target>       </trans-unit>
        <trans-unit id="479" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.ResolveMethod(System.Int32,System.Type[],System.Type[])">
          <source>Case 2: The non-generic method <ph id="ph1">`M1`</ph> is called.</source>
          <target state="translated">Caso 2: O método não genérico <ph id="ph1">`M1`</ph> é chamado.</target>       </trans-unit>
        <trans-unit id="480" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.ResolveMethod(System.Int32,System.Type[],System.Type[])">
          <source>The parameter of this method uses the type parameter of the defining type, <ph id="ph1">`G1&lt;Tg1&gt;`</ph>, which is replaced in this case by the type parameter of the enclosing type, <ph id="ph2">`G2&lt;Tg2&gt;`</ph>.</source>
          <target state="translated">O parâmetro deste método usa o parâmetro de tipo de definição de tipo, <ph id="ph1">`G1&lt;Tg1&gt;`</ph>, que é substituído nesse caso, o parâmetro de tipo do tipo delimitador, <ph id="ph2">`G2&lt;Tg2&gt;`</ph>.</target>       </trans-unit>
        <trans-unit id="481" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.ResolveMethod(System.Int32,System.Type[],System.Type[])">
          <source>Case 3: The generic method <ph id="ph1">`GM1&lt;Tgm1&gt;`</ph> is called, specifying <ph id="ph2">&lt;xref:System.Int32&gt;</ph> and <ph id="ph3">&lt;xref:System.Object&gt;</ph> for the type arguments of the generic type and the generic method, respectively.</source>
          <target state="translated">Caso 3: O método genérico <ph id="ph1">`GM1&lt;Tgm1&gt;`</ph> é chamado, especificando <ph id="ph2">&lt;xref:System.Int32&gt;</ph> e <ph id="ph3">&lt;xref:System.Object&gt;</ph> para os argumentos de tipo do tipo genérico e o método genérico, respectivamente.</target>       </trans-unit>
        <trans-unit id="482" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.ResolveMethod(System.Int32,System.Type[],System.Type[])">
          <source>This method call does not depend on the type parameters of the enclosing type or method.</source>
          <target state="translated">Esta chamada de método não depende dos parâmetros de tipo de método ou tipo de delimitador.</target>       </trans-unit>
        <trans-unit id="483" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.ResolveMethod(System.Int32,System.Type[],System.Type[])">
          <source>Case 4: The non-generic method <ph id="ph1">`M1`</ph> of the <ph id="ph2">`Example`</ph> class is called.</source>
          <target state="translated">Caso 4: O método não genérico <ph id="ph1">`M1`</ph> do <ph id="ph2">`Example`</ph> classe é chamada.</target>       </trans-unit>
        <trans-unit id="484" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.ResolveMethod(System.Int32,System.Type[],System.Type[])">
          <source>This method call does not depend on the type parameters of the enclosing type or method.</source>
          <target state="translated">Esta chamada de método não depende dos parâmetros de tipo de método ou tipo de delimitador.</target>       </trans-unit>
        <trans-unit id="485" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.ResolveMethod(System.Int32,System.Type[],System.Type[])">
          <source>In addition, the example defines the non-generic <ph id="ph1">`Example`</ph> class.</source>
          <target state="translated">Além disso, o exemplo define não genéricas <ph id="ph1">`Example`</ph> classe.</target>       </trans-unit>
        <trans-unit id="486" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.ResolveMethod(System.Int32,System.Type[],System.Type[])">
          <source>This class has a method <ph id="ph1">`M`</ph> that makes a call to a generic method.</source>
          <target state="translated">Essa classe tem um método <ph id="ph1">`M`</ph> que faz uma chamada para um método genérico.</target>       </trans-unit>
        <trans-unit id="487" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.ResolveMethod(System.Int32,System.Type[],System.Type[])">
          <source>Case 5: The generic method <ph id="ph1">`GM1&lt;Tgm1&gt;`</ph> is called, specifying <ph id="ph2">&lt;xref:System.Int32&gt;</ph> and <ph id="ph3">&lt;xref:System.Object&gt;</ph> for the type arguments of the generic type and the generic method, respectively.</source>
          <target state="translated">Caso 5: O método genérico <ph id="ph1">`GM1&lt;Tgm1&gt;`</ph> é chamado, especificando <ph id="ph2">&lt;xref:System.Int32&gt;</ph> e <ph id="ph3">&lt;xref:System.Object&gt;</ph> para os argumentos de tipo do tipo genérico e o método genérico, respectivamente.</target>       </trans-unit>
        <trans-unit id="488" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.ResolveMethod(System.Int32,System.Type[],System.Type[])">
          <source>The context for this method has no enclosing generic type or generic method.</source>
          <target state="translated">O contexto para esse método não tem nenhum delimitador tipo genérico ou método genérico.</target>       </trans-unit>
        <trans-unit id="489" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.ResolveMethod(System.Int32,System.Type[],System.Type[])">
          <source>For each case, the example first constructs a <ph id="ph1">&lt;xref:System.Reflection.MethodInfo&gt;</ph> that represents the called method, and then resolves the token using the <ph id="ph2">&lt;xref:System.Reflection.Module.ResolveMethod%28System.Int32%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%29&gt;</ph> method overload, using the <ph id="ph3">&lt;xref:System.Type.GetGenericArguments%2A?displayProperty=nameWithType&gt;</ph> and <ph id="ph4">&lt;xref:System.Reflection.MethodInfo.GetGenericArguments%2A?displayProperty=nameWithType&gt;</ph> methods to get the values for the <ph id="ph5">`genericTypeArguments`</ph> and <ph id="ph6">`genericMethodArguments`</ph> parameters.</source>
          <target state="translated">Para cada caso, o exemplo primeiro constrói um <ph id="ph1">&lt;xref:System.Reflection.MethodInfo&gt;</ph> que representa o método chamado e, em seguida, resolve o token usando o <ph id="ph2">&lt;xref:System.Reflection.Module.ResolveMethod%28System.Int32%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%29&gt;</ph> sobrecarga do método, usando o <ph id="ph3">&lt;xref:System.Type.GetGenericArguments%2A?displayProperty=nameWithType&gt;</ph> e <ph id="ph4">&lt;xref:System.Reflection.MethodInfo.GetGenericArguments%2A?displayProperty=nameWithType&gt;</ph> métodos para obter os valores para o <ph id="ph5">`genericTypeArguments`</ph> e <ph id="ph6">`genericMethodArguments`</ph> parâmetros.</target>       </trans-unit>
        <trans-unit id="490" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.ResolveMethod(System.Int32,System.Type[],System.Type[])">
          <source>This technique works in all cases, because the methods return <ph id="ph1">&lt;xref:System.Type.EmptyTypes?displayProperty=nameWithType&gt;</ph> for non-generic contexts.</source>
          <target state="translated">Essa técnica funciona em todos os casos, porque os métodos retornam <ph id="ph1">&lt;xref:System.Type.EmptyTypes?displayProperty=nameWithType&gt;</ph> para contextos não genérico.</target>       </trans-unit>
        <trans-unit id="491" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.ResolveMethod(System.Int32,System.Type[],System.Type[])">
          <source>The example compares the resolved <ph id="ph1">&lt;xref:System.Reflection.MethodInfo&gt;</ph> with the constructed <ph id="ph2">&lt;xref:System.Reflection.MethodInfo&gt;</ph>.</source>
          <target state="translated">O exemplo compara o resolvido <ph id="ph1">&lt;xref:System.Reflection.MethodInfo&gt;</ph> com o construído <ph id="ph2">&lt;xref:System.Reflection.MethodInfo&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="492" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.ResolveMethod(System.Int32,System.Type[],System.Type[])">
          <source>The example then attempts to use the <ph id="ph1">&lt;xref:System.Reflection.Module.ResolveMethod%28System.Int32%29&gt;</ph> method overload to resolve the token.</source>
          <target state="translated">O exemplo, em seguida, tenta usar o <ph id="ph1">&lt;xref:System.Reflection.Module.ResolveMethod%28System.Int32%29&gt;</ph> sobrecarga do método para resolver o token.</target>       </trans-unit>
        <trans-unit id="493" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.ResolveMethod(System.Int32,System.Type[],System.Type[])">
          <source>This works in cases 3, 4, and 5, because the method calls do not depend on the generic context.</source>
          <target state="translated">Isso funciona em casos 3, 4 e 5, porque as chamadas de método não dependem do contexto genérico.</target>       </trans-unit>
        <trans-unit id="494" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.ResolveMethod(System.Int32,System.Type[],System.Type[])">
          <source>In cases 1 and 2, an exception is thrown because there is insufficient information to resolve the token.</source>
          <target state="translated">Em casos 1 e 2, uma exceção é gerada porque não há informações suficientes para resolver o token.</target>       </trans-unit>
        <trans-unit id="495" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.ResolveMethod(System.Int32,System.Type[],System.Type[])">
          <source>The metadata token values are hard-coded as an enumeration.</source>
          <target state="translated">Os valores do token de metadados são codificados como uma enumeração.</target>       </trans-unit>
        <trans-unit id="496" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.ResolveMethod(System.Int32,System.Type[],System.Type[])">
          <source>If you change this code example, the token values are likely to change.</source>
          <target state="translated">Se você alterar este exemplo de código, os valores do token são provavelmente será alterado.</target>       </trans-unit>
        <trans-unit id="497" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.ResolveMethod(System.Int32,System.Type[],System.Type[])">
          <source>To determine the new token values, compile the code and use Ildasm.exe with the <bpt id="p1">**</bpt>/TOKENS<ept id="p1">**</ept> option to examine the assembly.</source>
          <target state="translated">Para determinar os novos valores de token, compile o código e usar Ildasm.exe com o <bpt id="p1">**</bpt>/TOKENS<ept id="p1">**</ept> opção para examinar o assembly.</target>       </trans-unit>
        <trans-unit id="498" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.ResolveMethod(System.Int32,System.Type[],System.Type[])">
          <source>The tokens can be found at the points of call.</source>
          <target state="translated">Os tokens podem ser encontrados nos pontos de chamada.</target>       </trans-unit>
        <trans-unit id="499" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.ResolveMethod(System.Int32,System.Type[],System.Type[])">
          <source>Insert the new values into the enumeration, and recompile the example.</source>
          <target state="translated">Insira os novos valores na enumeração e recompilar o exemplo.</target>       </trans-unit>
        <trans-unit id="500" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.ResolveMethod(System.Int32,System.Type[],System.Type[])">
          <source><ph id="ph1">&lt;paramref name="metadataToken" /&gt;</ph> is not a token for a method or constructor in the scope of the current module.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="metadataToken" /&gt;</ph> não é um token de um método ou construtor no escopo do módulo atual.</target>       </trans-unit>
        <trans-unit id="501" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.ResolveMethod(System.Int32,System.Type[],System.Type[])">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="502" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.ResolveMethod(System.Int32,System.Type[],System.Type[])">
          <source><ph id="ph1">&lt;paramref name="metadataToken" /&gt;</ph> is a <ph id="ph2">&lt;see langword="MethodSpec" /&gt;</ph> whose signature contains element type <ph id="ph3">&lt;see langword="var" /&gt;</ph> (a type parameter of a generic type) or <ph id="ph4">&lt;see langword="mvar" /&gt;</ph> (a type parameter of a generic method), and the necessary generic type arguments were not supplied for either or both of <ph id="ph5">&lt;paramref name="genericTypeArguments" /&gt;</ph> and <ph id="ph6">&lt;paramref name="genericMethodArguments" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="metadataToken" /&gt;</ph> é um <ph id="ph2">&lt;see langword="MethodSpec" /&gt;</ph> cuja assinatura contém o tipo de elemento <ph id="ph3">&lt;see langword="var" /&gt;</ph> (um parâmetro de tipo de um tipo genérico) ou <ph id="ph4">&lt;see langword="mvar" /&gt;</ph> (um parâmetro de tipo de um método genérico) e os argumentos de tipo genérico necessários não foram fornecidos para <ph id="ph5">&lt;paramref name="genericTypeArguments" /&gt;</ph> ou <ph id="ph6">&lt;paramref name="genericMethodArguments" /&gt;</ph>, ou para ambos.</target>       </trans-unit>
        <trans-unit id="503" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.ResolveMethod(System.Int32,System.Type[],System.Type[])">
          <source><ph id="ph1">&lt;paramref name="metadataToken" /&gt;</ph> is not a valid token in the scope of the current module.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="metadataToken" /&gt;</ph> não é um token válido no escopo do módulo atual.</target>       </trans-unit>
        <trans-unit id="504" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.ResolveSignature(System.Int32)">
          <source>A metadata token that identifies a signature in the module.</source>
          <target state="translated">Um token de metadados que identifica uma assinatura no módulo.</target>       </trans-unit>
        <trans-unit id="505" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.ResolveSignature(System.Int32)">
          <source>Returns the signature blob identified by a metadata token.</source>
          <target state="translated">Retorna o blob de assinatura identificado por um token de metadados.</target>       </trans-unit>
        <trans-unit id="506" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.ResolveSignature(System.Int32)">
          <source>An array of bytes representing the signature blob.</source>
          <target state="translated">Uma matriz de bytes que representa o blob de assinatura.</target>       </trans-unit>
        <trans-unit id="507" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.ResolveSignature(System.Int32)">
          <source>Information about metadata tokens and signatures can be found in the Common Language Infrastructure (CLI) documentation, especially "Partition II: Metadata Definition and Semantics".</source>
          <target state="translated">Informações sobre assinaturas e tokens de metadados podem ser encontradas na documentação do Common Language Infrastructure (CLI), especialmente "partição II: metadados definição e semântica".</target>       </trans-unit>
        <trans-unit id="508" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.ResolveSignature(System.Int32)">
          <source>The documentation is available online; see <bpt id="p1">[</bpt>ECMA C# and Common Language Infrastructure Standards<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=99212)</ept> on MSDN and <bpt id="p2">[</bpt>Standard ECMA-335 - Common Language Infrastructure (CLI)<ept id="p2">](http://go.microsoft.com/fwlink/?LinkID=65552)</ept> on the ECMA Web site.</source>
          <target state="translated">A documentação está disponível online; consulte <bpt id="p1">[</bpt>ECMA para c# e padrões de infra-estrutura de linguagem comum<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=99212)</ept> no MSDN e <bpt id="p2">[</bpt>padrão ECMA-335 - infraestrutura de linguagem comum (CLI)<ept id="p2">](http://go.microsoft.com/fwlink/?LinkID=65552)</ept> no site da Web de ECMA.</target>       </trans-unit>
        <trans-unit id="509" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.ResolveSignature(System.Int32)">
          <source><ph id="ph1">&lt;paramref name="metadataToken" /&gt;</ph> is not a valid <ph id="ph2">&lt;see langword="MemberRef" /&gt;</ph>, <ph id="ph3">&lt;see langword="MethodDef" /&gt;</ph>, <ph id="ph4">&lt;see langword="TypeSpec" /&gt;</ph>, signature, or <ph id="ph5">&lt;see langword="FieldDef" /&gt;</ph> token in the scope of the current module.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="metadataToken" /&gt;</ph> não é um <ph id="ph2">&lt;see langword="MemberRef" /&gt;</ph>, <ph id="ph3">&lt;see langword="MethodDef" /&gt;</ph>, <ph id="ph4">&lt;see langword="TypeSpec" /&gt;</ph>, assinatura ou token <ph id="ph5">&lt;see langword="FieldDef" /&gt;</ph> válido no escopo do módulo atual.</target>       </trans-unit>
        <trans-unit id="510" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.ResolveSignature(System.Int32)">
          <source><ph id="ph1">&lt;paramref name="metadataToken" /&gt;</ph> is not a valid token in the scope of the current module.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="metadataToken" /&gt;</ph> não é um token válido no escopo do módulo atual.</target>       </trans-unit>
        <trans-unit id="511" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.ResolveString(System.Int32)">
          <source>A metadata token that identifies a string in the string heap of the module.</source>
          <target state="translated">Um token de metadados que identifica uma cadeia de caracteres no heap de cadeia de caracteres do módulo.</target>       </trans-unit>
        <trans-unit id="512" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.ResolveString(System.Int32)">
          <source>Returns the string identified by the specified metadata token.</source>
          <target state="translated">Retorna a cadeia de caracteres identificada pelo token de metadados especificado.</target>       </trans-unit>
        <trans-unit id="513" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.ResolveString(System.Int32)">
          <source>A <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> containing a string value from the metadata string heap.</source>
          <target state="translated">Um <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> que contém um valor de cadeia de caracteres do heap de cadeia de caracteres de metadados.</target>       </trans-unit>
        <trans-unit id="514" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.ResolveString(System.Int32)">
          <source>Information about metadata tokens can be found in the Common Language Infrastructure (CLI) documentation, especially "Partition II: Metadata Definition and Semantics".</source>
          <target state="translated">Informações sobre tokens de metadados podem ser encontradas na documentação do Common Language Infrastructure (CLI), especialmente "partição II: metadados definição e semântica".</target>       </trans-unit>
        <trans-unit id="515" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.ResolveString(System.Int32)">
          <source>The documentation is available online; see <bpt id="p1">[</bpt>ECMA C# and Common Language Infrastructure Standards<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=99212)</ept> on MSDN and <bpt id="p2">[</bpt>Standard ECMA-335 - Common Language Infrastructure (CLI)<ept id="p2">](http://go.microsoft.com/fwlink/?LinkID=65552)</ept> on the ECMA Web site.</source>
          <target state="translated">A documentação está disponível online; consulte <bpt id="p1">[</bpt>ECMA para c# e padrões de infra-estrutura de linguagem comum<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=99212)</ept> no MSDN e <bpt id="p2">[</bpt>padrão ECMA-335 - infraestrutura de linguagem comum (CLI)<ept id="p2">](http://go.microsoft.com/fwlink/?LinkID=65552)</ept> no site da Web de ECMA.</target>       </trans-unit>
        <trans-unit id="516" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.ResolveString(System.Int32)">
          <source><ph id="ph1">&lt;paramref name="metadataToken" /&gt;</ph> is not a token for a string in the scope of the current module.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="metadataToken" /&gt;</ph> não é um token para uma cadeia de caracteres no escopo do módulo atual.</target>       </trans-unit>
        <trans-unit id="517" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.ResolveString(System.Int32)">
          <source><ph id="ph1">&lt;paramref name="metadataToken" /&gt;</ph> is not a valid token in the scope of the current module.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="metadataToken" /&gt;</ph> não é um token válido no escopo do módulo atual.</target>       </trans-unit>
        <trans-unit id="518" translate="yes" xml:space="preserve" uid="T:System.Reflection.Module">
          <source>Returns the type identified by a metadata token.</source>
          <target state="translated">Retorna o tipo identificado por um token de metadados.</target>       </trans-unit>
        <trans-unit id="519" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.ResolveType(System.Int32)">
          <source>A metadata token that identifies a type in the module.</source>
          <target state="translated">Um token de metadados que identifica um tipo no módulo.</target>       </trans-unit>
        <trans-unit id="520" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.ResolveType(System.Int32)">
          <source>Returns the type identified by the specified metadata token.</source>
          <target state="translated">Retorna o tipo identificado pelo token de metadados especificado.</target>       </trans-unit>
        <trans-unit id="521" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.ResolveType(System.Int32)">
          <source>A <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> object representing the type that is identified by the specified metadata token.</source>
          <target state="translated">Um objeto <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> que representa o tipo que é identificado pelo token de metadados especificado.</target>       </trans-unit>
        <trans-unit id="522" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.ResolveType(System.Int32)">
          <source>To resolve a metadata token for a <ph id="ph1">`TypeSpec`</ph> whose signature contains <ph id="ph2">`ELEMENT_TYPE_VAR`</ph> or <ph id="ph3">`ELEMENT_TYPE_MVAR`</ph>, use the <ph id="ph4">&lt;xref:System.Reflection.Module.ResolveType%28System.Int32%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%29&gt;</ph> method overload, which allows you to supply the necessary context.</source>
          <target state="translated">Para resolver um token de metadados para um <ph id="ph1">`TypeSpec`</ph> cuja assinatura contém <ph id="ph2">`ELEMENT_TYPE_VAR`</ph> ou <ph id="ph3">`ELEMENT_TYPE_MVAR`</ph>, use o <ph id="ph4">&lt;xref:System.Reflection.Module.ResolveType%28System.Int32%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%29&gt;</ph> sobrecarga de método, o que permite que você fornecer o contexto necessário.</target>       </trans-unit>
        <trans-unit id="523" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.ResolveType(System.Int32)">
          <source>That is, when you are resolving a metadata token for a type that depends on the generic type parameters of the generic type and/or the generic method in which the token is embedded, you must use the overload that allows you to supply those type parameters.</source>
          <target state="translated">Ou seja, quando você está resolvendo um token de metadados para um tipo que depende dos parâmetros de tipo genérico do tipo genérico e/ou o método genérico no qual o token é inserido, você deve usar a sobrecarga que permite que você forneça os parâmetros de tipo.</target>       </trans-unit>
        <trans-unit id="524" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.ResolveType(System.Int32)">
          <source>Information about metadata tokens can be found in the Common Language Infrastructure (CLI) documentation, especially "Partition II: Metadata Definition and Semantics".</source>
          <target state="translated">Informações sobre tokens de metadados podem ser encontradas na documentação do Common Language Infrastructure (CLI), especialmente "partição II: metadados definição e semântica".</target>       </trans-unit>
        <trans-unit id="525" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.ResolveType(System.Int32)">
          <source>The documentation is available online; see <bpt id="p1">[</bpt>ECMA C# and Common Language Infrastructure Standards<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=99212)</ept> on MSDN and <bpt id="p2">[</bpt>Standard ECMA-335 - Common Language Infrastructure (CLI)<ept id="p2">](http://go.microsoft.com/fwlink/?LinkID=65552)</ept> on the ECMA Web site.</source>
          <target state="translated">A documentação está disponível online; consulte <bpt id="p1">[</bpt>ECMA para c# e padrões de infra-estrutura de linguagem comum<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=99212)</ept> no MSDN e <bpt id="p2">[</bpt>padrão ECMA-335 - infraestrutura de linguagem comum (CLI)<ept id="p2">](http://go.microsoft.com/fwlink/?LinkID=65552)</ept> no site da Web de ECMA.</target>       </trans-unit>
        <trans-unit id="526" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.ResolveType(System.Int32)">
          <source><ph id="ph1">&lt;paramref name="metadataToken" /&gt;</ph> is not a token for a type in the scope of the current module.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="metadataToken" /&gt;</ph> não é um token para um tipo no escopo do módulo atual.</target>       </trans-unit>
        <trans-unit id="527" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.ResolveType(System.Int32)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="528" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.ResolveType(System.Int32)">
          <source><ph id="ph1">&lt;paramref name="metadataToken" /&gt;</ph> is a <ph id="ph2">&lt;see langword="TypeSpec" /&gt;</ph> whose signature contains element type <ph id="ph3">&lt;see langword="var" /&gt;</ph> (a type parameter of a generic type) or <ph id="ph4">&lt;see langword="mvar" /&gt;</ph> (a type parameter of a generic method).</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="metadataToken" /&gt;</ph> é um <ph id="ph2">&lt;see langword="TypeSpec" /&gt;</ph> cuja assinatura contém o tipo de elemento <ph id="ph3">&lt;see langword="var" /&gt;</ph> (um parâmetro de tipo de um tipo genérico) ou <ph id="ph4">&lt;see langword="mvar" /&gt;</ph> (um parâmetro de tipo de um método genérico).</target>       </trans-unit>
        <trans-unit id="529" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.ResolveType(System.Int32)">
          <source><ph id="ph1">&lt;paramref name="metadataToken" /&gt;</ph> is not a valid token in the scope of the current module.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="metadataToken" /&gt;</ph> não é um token válido no escopo do módulo atual.</target>       </trans-unit>
        <trans-unit id="530" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.ResolveType(System.Int32,System.Type[],System.Type[])">
          <source>A metadata token that identifies a type in the module.</source>
          <target state="translated">Um token de metadados que identifica um tipo no módulo.</target>       </trans-unit>
        <trans-unit id="531" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.ResolveType(System.Int32,System.Type[],System.Type[])">
          <source>An array of <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> objects representing the generic type arguments of the type where the token is in scope, or <ph id="ph2">&lt;see langword="null" /&gt;</ph> if that type is not generic.</source>
          <target state="translated">Uma matriz de objetos <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> que representam os argumentos de tipo genérico do tipo em que o token está no escopo ou <ph id="ph2">&lt;see langword="null" /&gt;</ph> se esse tipo não for genérico.</target>       </trans-unit>
        <trans-unit id="532" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.ResolveType(System.Int32,System.Type[],System.Type[])">
          <source>An array of <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> objects representing the generic type arguments of the method where the token is in scope, or <ph id="ph2">&lt;see langword="null" /&gt;</ph> if that method is not generic.</source>
          <target state="translated">Uma matriz de objetos <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> que representam os argumentos de tipo genérico do método em que o token está no escopo ou <ph id="ph2">&lt;see langword="null" /&gt;</ph> se esse método não for genérico.</target>       </trans-unit>
        <trans-unit id="533" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.ResolveType(System.Int32,System.Type[],System.Type[])">
          <source>Returns the type identified by the specified metadata token, in the context defined by the specified generic type parameters.</source>
          <target state="translated">Retorna o tipo identificado pelo token de metadados especificado no contexto definido pelos parâmetros de tipo genérico especificados.</target>       </trans-unit>
        <trans-unit id="534" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.ResolveType(System.Int32,System.Type[],System.Type[])">
          <source>A <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> object representing the type that is identified by the specified metadata token.</source>
          <target state="translated">Um objeto <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> que representa o tipo que é identificado pelo token de metadados especificado.</target>       </trans-unit>
        <trans-unit id="535" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.ResolveType(System.Int32,System.Type[],System.Type[])">
          <source>Use the <ph id="ph1">&lt;xref:System.Type.GetGenericArguments%2A?displayProperty=nameWithType&gt;</ph> method on the type where <ph id="ph2">`metadataToken`</ph> is in scope to obtain an array of generic type arguments for <ph id="ph3">`genericTypeArguments`</ph>.</source>
          <target state="translated">Use o <ph id="ph1">&lt;xref:System.Type.GetGenericArguments%2A?displayProperty=nameWithType&gt;</ph> método do tipo onde <ph id="ph2">`metadataToken`</ph> está no escopo para obter uma matriz de argumentos de tipo genérico para <ph id="ph3">`genericTypeArguments`</ph>.</target>       </trans-unit>
        <trans-unit id="536" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.ResolveType(System.Int32,System.Type[],System.Type[])">
          <source>Use the <ph id="ph1">&lt;xref:System.Reflection.MethodInfo.GetGenericArguments%2A?displayProperty=nameWithType&gt;</ph> method on the method where <ph id="ph2">`metadataToken`</ph> is in scope to obtain an array of generic type arguments for <ph id="ph3">`genericTypeArguments`</ph>.</source>
          <target state="translated">Use o <ph id="ph1">&lt;xref:System.Reflection.MethodInfo.GetGenericArguments%2A?displayProperty=nameWithType&gt;</ph> método no método onde <ph id="ph2">`metadataToken`</ph> está no escopo para obter uma matriz de argumentos de tipo genérico para <ph id="ph3">`genericTypeArguments`</ph>.</target>       </trans-unit>
        <trans-unit id="537" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.ResolveType(System.Int32,System.Type[],System.Type[])">
          <source>It is always safe to provide these arguments, even when they are not needed.</source>
          <target state="translated">É sempre seguro fornecer esses argumentos, mesmo quando eles não são necessários.</target>       </trans-unit>
        <trans-unit id="538" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.ResolveType(System.Int32,System.Type[],System.Type[])">
          <source>Information about metadata tokens can be found in the Common Language Infrastructure (CLI) documentation, especially "Partition II: Metadata Definition and Semantics".</source>
          <target state="translated">Informações sobre tokens de metadados podem ser encontradas na documentação do Common Language Infrastructure (CLI), especialmente "partição II: metadados definição e semântica".</target>       </trans-unit>
        <trans-unit id="539" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.ResolveType(System.Int32,System.Type[],System.Type[])">
          <source>The documentation is available online; see <bpt id="p1">[</bpt>ECMA C# and Common Language Infrastructure Standards<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=99212)</ept> on MSDN and <bpt id="p2">[</bpt>Standard ECMA-335 - Common Language Infrastructure (CLI)<ept id="p2">](http://go.microsoft.com/fwlink/?LinkID=65552)</ept> on the ECMA Web site.</source>
          <target state="translated">A documentação está disponível online; consulte <bpt id="p1">[</bpt>ECMA para c# e padrões de infra-estrutura de linguagem comum<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=99212)</ept> no MSDN e <bpt id="p2">[</bpt>padrão ECMA-335 - infraestrutura de linguagem comum (CLI)<ept id="p2">](http://go.microsoft.com/fwlink/?LinkID=65552)</ept> no site da Web de ECMA.</target>       </trans-unit>
        <trans-unit id="540" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.ResolveType(System.Int32,System.Type[],System.Type[])">
          <source>For code that demonstrates token resolution using the generic context (that is, the generic type parameters of the generic type and/or the generic method in which the token is embedded) see the <ph id="ph1">&lt;xref:System.Reflection.Module.ResolveMethod%28System.Int32%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%29&gt;</ph> method.</source>
          <target state="translated">Para o código que demonstra a resolução de token usando o contexto genérico (ou seja, os parâmetros de tipo genérico do tipo genérico e/ou o método genérico na qual o token é incorporado) consulte o <ph id="ph1">&lt;xref:System.Reflection.Module.ResolveMethod%28System.Int32%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%29&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="541" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.ResolveType(System.Int32,System.Type[],System.Type[])">
          <source><ph id="ph1">&lt;paramref name="metadataToken" /&gt;</ph> is not a token for a type in the scope of the current module.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="metadataToken" /&gt;</ph> não é um token para um tipo no escopo do módulo atual.</target>       </trans-unit>
        <trans-unit id="542" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.ResolveType(System.Int32,System.Type[],System.Type[])">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="543" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.ResolveType(System.Int32,System.Type[],System.Type[])">
          <source><ph id="ph1">&lt;paramref name="metadataToken" /&gt;</ph> is a <ph id="ph2">&lt;see langword="TypeSpec" /&gt;</ph> whose signature contains element type <ph id="ph3">&lt;see langword="var" /&gt;</ph> (a type parameter of a generic type) or <ph id="ph4">&lt;see langword="mvar" /&gt;</ph> (a type parameter of a generic method), and the necessary generic type arguments were not supplied for either or both of <ph id="ph5">&lt;paramref name="genericTypeArguments" /&gt;</ph> and <ph id="ph6">&lt;paramref name="genericMethodArguments" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="metadataToken" /&gt;</ph> é um <ph id="ph2">&lt;see langword="TypeSpec" /&gt;</ph> cuja assinatura contém o tipo de elemento <ph id="ph3">&lt;see langword="var" /&gt;</ph> (um parâmetro de tipo de um tipo genérico) ou <ph id="ph4">&lt;see langword="mvar" /&gt;</ph> (um parâmetro de tipo de um método genérico) e os argumentos de tipo genérico necessários não foram fornecidos para <ph id="ph5">&lt;paramref name="genericTypeArguments" /&gt;</ph> ou <ph id="ph6">&lt;paramref name="genericMethodArguments" /&gt;</ph>, ou para ambos.</target>       </trans-unit>
        <trans-unit id="544" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.ResolveType(System.Int32,System.Type[],System.Type[])">
          <source><ph id="ph1">&lt;paramref name="metadataToken" /&gt;</ph> is not a valid token in the scope of the current module.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="metadataToken" /&gt;</ph> não é um token válido no escopo do módulo atual.</target>       </trans-unit>
        <trans-unit id="545" translate="yes" xml:space="preserve" uid="P:System.Reflection.Module.ScopeName">
          <source>Gets a string representing the name of the module.</source>
          <target state="translated">Obtém uma cadeia de caracteres que representa o nome do módulo.</target>       </trans-unit>
        <trans-unit id="546" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Module.ScopeName">
          <source>The module name.</source>
          <target state="translated">O nome do módulo.</target>       </trans-unit>
        <trans-unit id="547" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Module.ScopeName">
          <source>The <ph id="ph1">`ScopeName`</ph> property is not used by the common language runtime, but you can use it to store any string you want in the property when you emit a module using the metadata APIs.</source>
          <target state="translated">O <ph id="ph1">`ScopeName`</ph> propriedade não é usada pelo common language runtime, mas você pode usá-lo para armazenar qualquer cadeia de caracteres que você deseja na propriedade quando você emite um módulo usando os APIs de metadados.</target>       </trans-unit>
        <trans-unit id="548" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Module.ScopeName">
          <source>Reflection itself does not allow you to set the <ph id="ph1">`ScopeName`</ph> property.</source>
          <target state="translated">Reflexão em si não permite que você defina o <ph id="ph1">`ScopeName`</ph> propriedade.</target>       </trans-unit>
        <trans-unit id="549" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Module.ScopeName">
          <source>This example shows the effect of the <ph id="ph1">`ScopeName`</ph>, <ph id="ph2">`FullyQualifiedName`</ph>, and <ph id="ph3">`Name`</ph> properties.</source>
          <target state="translated">Este exemplo mostra o efeito de <ph id="ph1">`ScopeName`</ph>, <ph id="ph2">`FullyQualifiedName`</ph>, e <ph id="ph3">`Name`</ph> propriedades.</target>       </trans-unit>
        <trans-unit id="550" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.System#Runtime#InteropServices#_Module#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)">
          <source>Reserved for future use.</source>
          <target state="translated">Reservado para uso futuro.</target>       </trans-unit>
        <trans-unit id="551" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.System#Runtime#InteropServices#_Module#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)">
          <source>Must be IID_NULL.</source>
          <target state="translated">Deve ser IID_NULL.</target>       </trans-unit>
        <trans-unit id="552" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.System#Runtime#InteropServices#_Module#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)">
          <source>Passed-in array of names to be mapped.</source>
          <target state="translated">Matriz passada de nomes a serem mapeados.</target>       </trans-unit>
        <trans-unit id="553" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.System#Runtime#InteropServices#_Module#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)">
          <source>Count of the names to be mapped.</source>
          <target state="translated">Contagem dos nomes a serem mapeados.</target>       </trans-unit>
        <trans-unit id="554" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.System#Runtime#InteropServices#_Module#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)">
          <source>The locale context in which to interpret the names.</source>
          <target state="translated">O contexto de localidade no qual interpretar os nomes.</target>       </trans-unit>
        <trans-unit id="555" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.System#Runtime#InteropServices#_Module#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)">
          <source>Caller-allocated array that receives the IDs corresponding to the names.</source>
          <target state="translated">Matriz alocada pelo chamador que recebe os IDs correspondentes aos nomes.</target>       </trans-unit>
        <trans-unit id="556" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.System#Runtime#InteropServices#_Module#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)">
          <source>Maps a set of names to a corresponding set of dispatch identifiers.</source>
          <target state="translated">Mapeia um conjunto de nomes para um conjunto correspondente de identificadores de expedição.</target>       </trans-unit>
        <trans-unit id="557" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.System#Runtime#InteropServices#_Module#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)">
          <source>This method is for access to managed classes from unmanaged code, and should not be called from managed code.</source>
          <target state="translated">Este método é para acesso a classes gerenciadas de código não gerenciado e não deve ser chamado em código gerenciado.</target>       </trans-unit>
        <trans-unit id="558" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.System#Runtime#InteropServices#_Module#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)">
          <source>For more information about <ph id="ph1">`IDispatch::GetIDsOfNames`</ph>, see the MSDN Library.</source>
          <target state="translated">Para obter mais informações sobre <ph id="ph1">`IDispatch::GetIDsOfNames`</ph>, consulte a Biblioteca MSDN.</target>       </trans-unit>
        <trans-unit id="559" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.System#Runtime#InteropServices#_Module#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)">
          <source>Late-bound access using the COM <bpt id="p1">&lt;c&gt;</bpt>IDispatch<ept id="p1">&lt;/c&gt;</ept> interface is not supported.</source>
          <target state="translated">Não há suporte para acesso com associação tardia usando a interface <bpt id="p1">&lt;c&gt;</bpt>IDispatch<ept id="p1">&lt;/c&gt;</ept> COM.</target>       </trans-unit>
        <trans-unit id="560" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.System#Runtime#InteropServices#_Module#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)">
          <source>The type information to return.</source>
          <target state="translated">As informações de tipo a serem retornadas.</target>       </trans-unit>
        <trans-unit id="561" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.System#Runtime#InteropServices#_Module#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)">
          <source>The locale identifier for the type information.</source>
          <target state="translated">O identificador de localidade das informações do tipo.</target>       </trans-unit>
        <trans-unit id="562" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.System#Runtime#InteropServices#_Module#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)">
          <source>Receives a pointer to the requested type information object.</source>
          <target state="translated">Recebe um ponteiro para o objeto de informações de tipo solicitado.</target>       </trans-unit>
        <trans-unit id="563" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.System#Runtime#InteropServices#_Module#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)">
          <source>Retrieves the type information for an object, which can then be used to get the type information for an interface.</source>
          <target state="translated">Recupera as informações do tipo de um objeto, que podem ser usadas para obter informações de tipo para uma interface.</target>       </trans-unit>
        <trans-unit id="564" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.System#Runtime#InteropServices#_Module#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)">
          <source>This method is for access to managed classes from unmanaged code, and should not be called from managed code.</source>
          <target state="translated">Este método é para acesso a classes gerenciadas de código não gerenciado e não deve ser chamado em código gerenciado.</target>       </trans-unit>
        <trans-unit id="565" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.System#Runtime#InteropServices#_Module#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)">
          <source>For more information about <ph id="ph1">`IDispatch::GetTypeInfo`</ph>, see the MSDN Library.</source>
          <target state="translated">Para obter mais informações sobre <ph id="ph1">`IDispatch::GetTypeInfo`</ph>, consulte a Biblioteca MSDN.</target>       </trans-unit>
        <trans-unit id="566" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.System#Runtime#InteropServices#_Module#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)">
          <source>Late-bound access using the COM <bpt id="p1">&lt;c&gt;</bpt>IDispatch<ept id="p1">&lt;/c&gt;</ept> interface is not supported.</source>
          <target state="translated">Não há suporte para acesso com associação tardia usando a interface <bpt id="p1">&lt;c&gt;</bpt>IDispatch<ept id="p1">&lt;/c&gt;</ept> COM.</target>       </trans-unit>
        <trans-unit id="567" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.System#Runtime#InteropServices#_Module#GetTypeInfoCount(System.UInt32@)">
          <source>Points to a location that receives the number of type information interfaces provided by the object.</source>
          <target state="translated">Aponta para um local que recebe o número de interfaces de informações de tipo fornecido pelo objeto.</target>       </trans-unit>
        <trans-unit id="568" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.System#Runtime#InteropServices#_Module#GetTypeInfoCount(System.UInt32@)">
          <source>Retrieves the number of type information interfaces that an object provides (either 0 or 1).</source>
          <target state="translated">Retorna o número de interfaces de informações do tipo que um objeto fornece (0 ou 1).</target>       </trans-unit>
        <trans-unit id="569" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.System#Runtime#InteropServices#_Module#GetTypeInfoCount(System.UInt32@)">
          <source>This method is for access to managed classes from unmanaged code, and should not be called from managed code.</source>
          <target state="translated">Este método é para acesso a classes gerenciadas de código não gerenciado e não deve ser chamado em código gerenciado.</target>       </trans-unit>
        <trans-unit id="570" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.System#Runtime#InteropServices#_Module#GetTypeInfoCount(System.UInt32@)">
          <source>For more information about <ph id="ph1">`IDispatch::GetTypeInfoCount`</ph>, see the MSDN Library.</source>
          <target state="translated">Para obter mais informações sobre <ph id="ph1">`IDispatch::GetTypeInfoCount`</ph>, consulte a Biblioteca MSDN.</target>       </trans-unit>
        <trans-unit id="571" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.System#Runtime#InteropServices#_Module#GetTypeInfoCount(System.UInt32@)">
          <source>Late-bound access using the COM <bpt id="p1">&lt;c&gt;</bpt>IDispatch<ept id="p1">&lt;/c&gt;</ept> interface is not supported.</source>
          <target state="translated">Não há suporte para acesso com associação tardia usando a interface <bpt id="p1">&lt;c&gt;</bpt>IDispatch<ept id="p1">&lt;/c&gt;</ept> COM.</target>       </trans-unit>
        <trans-unit id="572" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.System#Runtime#InteropServices#_Module#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>Identifies the member.</source>
          <target state="translated">Identifica o membro.</target>       </trans-unit>
        <trans-unit id="573" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.System#Runtime#InteropServices#_Module#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>Reserved for future use.</source>
          <target state="translated">Reservado para uso futuro.</target>       </trans-unit>
        <trans-unit id="574" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.System#Runtime#InteropServices#_Module#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>Must be IID_NULL.</source>
          <target state="translated">Deve ser IID_NULL.</target>       </trans-unit>
        <trans-unit id="575" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.System#Runtime#InteropServices#_Module#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>The locale context in which to interpret arguments.</source>
          <target state="translated">O contexto de localidade no qual interpretar argumentos.</target>       </trans-unit>
        <trans-unit id="576" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.System#Runtime#InteropServices#_Module#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>Flags describing the context of the call.</source>
          <target state="translated">Sinalizadores que descrevem o contexto da chamada.</target>       </trans-unit>
        <trans-unit id="577" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.System#Runtime#InteropServices#_Module#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>Pointer to a structure containing an array of arguments, an array of argument DispIDs for named arguments, and counts for the number of elements in the arrays.</source>
          <target state="translated">Ponteiro para uma estrutura que contém uma matriz de argumentos, uma matriz de DispIDs de argumentos para argumentos nomeados e contas para o número de elementos nas matrizes.</target>       </trans-unit>
        <trans-unit id="578" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.System#Runtime#InteropServices#_Module#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>Pointer to the location where the result is to be stored.</source>
          <target state="translated">Ponteiro para o local onde o resultado deve ser armazenado.</target>       </trans-unit>
        <trans-unit id="579" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.System#Runtime#InteropServices#_Module#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>Pointer to a structure that contains exception information.</source>
          <target state="translated">Ponteiro para uma estrutura que contém informações de exceção.</target>       </trans-unit>
        <trans-unit id="580" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.System#Runtime#InteropServices#_Module#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>The index of the first argument that has an error.</source>
          <target state="translated">O índice do primeiro argumento que tem um erro.</target>       </trans-unit>
        <trans-unit id="581" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.System#Runtime#InteropServices#_Module#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>Provides access to properties and methods exposed by an object.</source>
          <target state="translated">Fornece acesso a propriedades e métodos expostos por um objeto.</target>       </trans-unit>
        <trans-unit id="582" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.System#Runtime#InteropServices#_Module#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>This method is for access to managed classes from unmanaged code, and should not be called from managed code.</source>
          <target state="translated">Este método é para acesso a classes gerenciadas de código não gerenciado e não deve ser chamado em código gerenciado.</target>       </trans-unit>
        <trans-unit id="583" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.System#Runtime#InteropServices#_Module#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>For more information about <ph id="ph1">`IDispatch::Invoke`</ph>, see the MSDN Library.</source>
          <target state="translated">Para obter mais informações sobre <ph id="ph1">`IDispatch::Invoke`</ph>, consulte a Biblioteca MSDN.</target>       </trans-unit>
        <trans-unit id="584" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.System#Runtime#InteropServices#_Module#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>Late-bound access using the COM <bpt id="p1">&lt;c&gt;</bpt>IDispatch<ept id="p1">&lt;/c&gt;</ept> interface is not supported.</source>
          <target state="translated">Não há suporte para acesso com associação tardia usando a interface <bpt id="p1">&lt;c&gt;</bpt>IDispatch<ept id="p1">&lt;/c&gt;</ept> COM.</target>       </trans-unit>
        <trans-unit id="585" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.ToString">
          <source>Returns the name of the module.</source>
          <target state="translated">Retorna o nome do módulo.</target>       </trans-unit>
        <trans-unit id="586" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.ToString">
          <source>A <ph id="ph1">&lt;see langword="String" /&gt;</ph> representing the name of this module.</source>
          <target state="translated">Um <ph id="ph1">&lt;see langword="String" /&gt;</ph> que representa o nome do módulo.</target>       </trans-unit>
        <trans-unit id="587" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.ToString">
          <source>The following example demonstrates a use of the <ph id="ph1">`ToString`</ph> method.</source>
          <target state="translated">O exemplo a seguir demonstra um uso de <ph id="ph1">`ToString`</ph> método.</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>